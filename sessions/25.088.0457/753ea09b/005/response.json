{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule: Conditional Flood Fill based on Color Counts and Adjacency\n\n1.  **Analyze Colors**: Examine the input grid. Count the occurrences of each color.\n2.  **Check Color Count**: If there are fewer than three distinct colors in the grid, return the original grid without changes.\n3.  **Identify Key Colors**:\n    *   Find the `background_color`, which is the color that appears most frequently.\n    *   Identify the two remaining colors. If there are not exactly two other colors, return the original grid.\n    *   Compare the counts of these two remaining colors. The one with the *smaller* count is the `fill_color`. If they have the same count, the one with the numerically lower color value is the `fill_color`.\n    *   The color that is neither the `background_color` nor the `fill_color` is the `barrier_color`.\n4.  **Check Initial Adjacency**: Determine if any pixel with the `fill_color` is directly next to (up, down, left, or right, not diagonally) any pixel with the `background_color` in the original input grid.\n5.  **Apply Transformation**:\n    *   **If** no `fill_color` pixel is adjacent to a `background_color` pixel, return the original grid unchanged.\n    *   **If** at least one `fill_color` pixel *is* adjacent to a `background_color` pixel:\n        *   Create a copy of the input grid to modify.\n        *   Perform a \"flood fill\" operation: Imagine the `fill_color` spreading. Starting from all the original positions of the `fill_color`, change the color of any adjacent `background_color` pixel to the `fill_color`.\n        *   Continue this process iteratively: any newly colored pixel also spreads the `fill_color` to its adjacent `background_color` neighbors.\n        *   The spread stops at the grid boundaries and cannot change the color of `barrier_color` pixels or pixels that were already the `fill_color`.\n        *   Return the modified grid after the spread is complete.\n\"\"\"\n\n\ndef _is_adjacent(grid: np.ndarray, color1: int, color2: int) -> bool:\n    \"\"\"\n    Checks if any pixel of color1 is cardinally adjacent to a pixel of color2.\n    Optimized by only checking neighbors of color1 pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    color1_coords = np.argwhere(grid == color1) # Find all coordinates of color1\n\n    for r, c in color1_coords:\n        # Check cardinal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds and has color2\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color2:\n                return True # Found an adjacency\n    return False # No adjacency found after checking all color1 neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a conditional flood fill based on color frequencies and adjacency.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Analyze Input Colors\n    colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(colors, counts))\n\n    # 2. Check Color Count: Need at least 3 colors for the pattern\n    if len(colors) < 3:\n        return input_grid # Return original if less than 3 colors\n\n    # 3. Identify Key Colors\n    # Find background color (most frequent)\n    # If there's a tie for most frequent, the logic might need refinement,\n    # but np.argmax picks the first occurrence which is deterministic.\n    background_color = colors[np.argmax(counts)]\n\n    # Identify the other two colors and their counts\n    non_background_colors = []\n    non_background_counts = []\n    for color, count in color_counts.items():\n        if color != background_color:\n            non_background_colors.append(color)\n            non_background_counts.append(count)\n\n    # Ensure exactly two other colors exist\n    if len(non_background_colors) != 2:\n        return input_grid # Return original if not exactly 2 other colors\n\n    # Determine fill and barrier colors based on counts (fill = min count)\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    count1, count2 = non_background_counts[0], non_background_counts[1]\n\n    if count1 < count2:\n        fill_color = color1\n        barrier_color = color2\n    elif count2 < count1:\n        fill_color = color2\n        barrier_color = color1\n    else: # Tie in counts, use lower color value as fill color\n        fill_color = min(color1, color2)\n        barrier_color = max(color1, color2)\n\n    # 4. Check Initial Adjacency: Is fill_color adjacent to background_color?\n    # Use the optimized helper function\n    is_fill_adjacent = _is_adjacent(grid, fill_color, background_color)\n\n    # 5. Perform Transformation\n    if not is_fill_adjacent:\n        # If fill color doesn't touch background initially, no fill occurs\n        return input_grid\n    else:\n        # Perform flood fill\n        output_grid = grid.copy() # Work on a copy\n        queue = deque()\n        visited = set()\n\n        # Initialize queue and visited set with all initial fill_color pixels\n        initial_fill_coords = np.argwhere(grid == fill_color)\n        for r, c in initial_fill_coords:\n            coord = (r, c)\n            queue.append(coord)\n            visited.add(coord)\n\n        # BFS Flood Fill\n        while queue:\n            r, c = queue.popleft()\n\n            # Check 4 cardinal neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                neighbor_coord = (nr, nc)\n\n                # Check if neighbor is within bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if neighbor is background color (in original grid)\n                    # AND has not been visited yet\n                    # Note: We check the *original* grid (`grid`) for the background color\n                    # but modify the `output_grid`.\n                    if grid[nr, nc] == background_color and neighbor_coord not in visited:\n                        # Change color in the output grid\n                        output_grid[nr, nc] = fill_color\n                        # Mark as visited\n                        visited.add(neighbor_coord)\n                        # Add to queue for further propagation\n                        queue.append(neighbor_coord)\n\n        # Convert back to list of lists for the expected output format\n        return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4743,
    "candidates_token_count": 1676,
    "total_token_count": 6419,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.597406,
  "retries": null
}