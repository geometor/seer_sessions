{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransformation Rule: Conditional Flood Fill based on Color Counts and Adjacency\n\n1.  **Analyze Input Colors:**\n    *   Count the occurrences of each color in the input grid.\n    *   If there are fewer than 3 distinct colors, return the input grid unchanged.\n    *   Identify the `background_color` as the color with the highest frequency.\n    *   Identify the two remaining non-background colors.\n    *   Among these two non-background colors, identify the `fill_color` as the one with the lower frequency (minimum count). Use the lower color value as a tie-breaker if counts are equal.\n    *   Identify the `barrier_color` as the remaining non-background color.\n\n2.  **Check Fill Condition:**\n    *   Determine if any pixel with the identified `fill_color` is initially located cardinally adjacent (up, down, left, or right) to any pixel with the `background_color`.\n\n3.  **Perform Transformation:**\n    *   **If** the `fill_color` is *not* adjacent to the `background_color`: Return a copy of the original input grid.\n    *   **If** the `fill_color` *is* adjacent to the `background_color`:\n        *   Initialize the `output_grid` as a copy of the `input_grid`.\n        *   Perform a flood fill operation using Breadth-First Search (BFS):\n            *   Initialize a queue and add the coordinates of all pixels that originally had the `fill_color`.\n            *   Initialize a `visited` set containing the coordinates of all pixels that originally had the `fill_color`.\n            *   While the queue is not empty:\n                *   Dequeue a coordinate `(r, c)`.\n                *   For each of its 4 cardinal neighbors `(nr, nc)`:\n                    *   Check if the neighbor is within the grid boundaries.\n                    *   Check if the neighbor's color in the *original input grid* is the `background_color`.\n                    *   Check if the neighbor's coordinate `(nr, nc)` has *not* been visited yet.\n                    *   If all these conditions are met:\n                        *   Change the neighbor's color in the `output_grid` to `fill_color`.\n                        *   Add the neighbor's coordinate `(nr, nc)` to the `visited` set.\n                        *   Enqueue the neighbor's coordinate `(nr, nc)`.\n        *   Return the `output_grid` after the flood fill is complete.\n\"\"\"\n\ndef _is_adjacent(grid: np.ndarray, color1: int, color2: int) -> bool:\n    \"\"\"Checks if any pixel of color1 is cardinally adjacent to a pixel of color2.\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color1:\n                # Check cardinal neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color2:\n                        return True\n    return False\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a conditional flood fill based on color frequencies and adjacency.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Analyze Input Colors\n    colors, counts = np.unique(grid, return_counts=True)\n\n    # Need at least 3 colors for the pattern\n    if len(colors) < 3:\n        return input_grid # Return original if less than 3 colors\n\n    # Find background color (most frequent)\n    background_color_index = np.argmax(counts)\n    background_color = colors[background_color_index]\n\n    # Identify the other two colors and their counts\n    non_background_colors = []\n    non_background_counts = []\n    for i, color in enumerate(colors):\n        if color != background_color:\n            non_background_colors.append(color)\n            non_background_counts.append(counts[i])\n\n    # Should have exactly two other colors\n    if len(non_background_colors) != 2:\n         # This case shouldn't happen if len(colors) >= 3 and bg is unique max\n         # but added as a safeguard.\n        return input_grid \n\n    # Determine fill and barrier colors based on counts (fill = min count)\n    color1, color2 = non_background_colors[0], non_background_colors[1]\n    count1, count2 = non_background_counts[0], non_background_counts[1]\n\n    if count1 < count2:\n        fill_color = color1\n        barrier_color = color2\n    elif count2 < count1:\n        fill_color = color2\n        barrier_color = color1\n    else: # Tie in counts, use lower color value as fill color\n        fill_color = min(color1, color2)\n        barrier_color = max(color1, color2)\n\n    # 2. Check Fill Condition: Is fill_color adjacent to background_color?\n    is_fill_adjacent = _is_adjacent(grid, fill_color, background_color)\n\n    # 3. Perform Transformation\n    if not is_fill_adjacent:\n        # If fill color doesn't touch background, no fill occurs\n        return input_grid\n    else:\n        # Perform flood fill\n        output_grid = grid.copy()\n        queue = deque()\n        visited = set()\n\n        # Initialize queue and visited set with all initial fill_color pixels\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r, c] == fill_color:\n                    coord = (r, c)\n                    queue.append(coord)\n                    visited.add(coord)\n                # Optimization: also mark barrier cells as visited initially so we don't check them\n                # Update: No, don't mark barriers visited, just don't flood *into* them.\n                # The check `grid[nr, nc] == background_color` handles this.\n\n        # BFS Flood Fill\n        while queue:\n            r, c = queue.popleft()\n\n            # Check 4 cardinal neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                neighbor_coord = (nr, nc)\n\n                # Check if neighbor is within bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if neighbor is background color (in original grid)\n                    # AND has not been visited yet\n                    if grid[nr, nc] == background_color and neighbor_coord not in visited:\n                        # Change color in the output grid\n                        output_grid[nr, nc] = fill_color\n                        # Mark as visited\n                        visited.add(neighbor_coord)\n                        # Add to queue for further propagation\n                        queue.append(neighbor_coord)\n\n        # Convert back to list of lists for the expected output format\n        return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10073,
    "candidates_token_count": 1748,
    "total_token_count": 11821,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.812167,
  "retries": null
}