{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nIdentify trigger points and draw a 'shadow' pattern.\n\nThe transformation rule involves finding specific orange (7) pixels in the input grid that act as triggers. A trigger occurs at position (r, c) if:\n1. The pixel at (r, c) is orange (7).\n2. The pixel to its right (r, c+1) is also orange (7).\n3. The pixel below it (r+1, c) is white (0).\n4. The pixel diagonally below and right (r+1, c+1) is white (0).\n(Bounds checks are implicit).\n\nWhen a trigger is found at (r, c):\n1. The pixel at (r, c) in the output grid is changed to azure (8).\n2. A 'shadow' pattern is drawn starting from below and right of (r, c), but only onto pixels that are currently white (0) in the evolving output grid and are not blocked by magenta rows/columns.\n3. Magenta rows/columns are determined by the positions of magenta (6) pixels in the original input grid. Any row or column containing a magenta pixel acts as a barrier.\n\nThe shadow pattern consists of:\n- Yellow (4) at (r+1, c+1).\n- A horizontal line of red (2) pixels starting at (r+1, c+2) and extending rightwards.\n- A vertical line of red (2) pixels starting at (r+2, c+1) and extending downwards.\n- A green (3) pixel placed just beyond the end of the horizontal red line, at (r+1, c + horizontal_red_length + 2).\n\nDrawing rules:\n- The shadow components (4, 2, 3) are only drawn if the target cell is within the grid bounds, the target cell's row is not a magenta row, the target cell's column is not a magenta column, AND the target cell in the current output grid is white (0).\n- The red lines extend as far as possible under these constraints.\n- The output grid starts as a copy of the input grid. Modifications (8, 4, 2, 3) are made based on triggers found in the input grid.\n\"\"\"\n\ndef find_magenta_barriers(grid):\n    \"\"\"Finds rows and columns containing magenta (6) pixels.\"\"\"\n    magenta_rows = set()\n    magenta_cols = set()\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 6:\n                magenta_rows.add(r)\n                magenta_cols.add(c)\n    return magenta_rows, magenta_cols\n\ndef is_safe(r, c, height, width, magenta_rows, magenta_cols, output_grid):\n    \"\"\"Checks if a position is valid for drawing a shadow pixel.\"\"\"\n    return (0 <= r < height and\n            0 <= c < width and\n            r not in magenta_rows and\n            c not in magenta_cols and\n            output_grid[r, c] == 0) # Check if the target is currently background\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies trigger points (specific orange pixels) and draws a shadow pattern.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    \n    # Find rows and columns blocked by magenta pixels\n    magenta_rows, magenta_cols = find_magenta_barriers(input_np)\n\n    # Find trigger points and store them to avoid modifying grid during iteration\n    triggers = []\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Check trigger conditions\n            if (input_np[r, c] == 7 and\n                input_np[r, c+1] == 7 and\n                input_np[r+1, c] == 0 and\n                input_np[r+1, c+1] == 0):\n                triggers.append((r, c))\n\n    # Apply transformations for each trigger\n    for r, c in triggers:\n        # Change trigger pixel to azure\n        # Check if the trigger pixel itself is blocked (unlikely based on examples but good practice)\n        if r not in magenta_rows and c not in magenta_cols:\n             output_grid[r, c] = 8\n        else:\n             # If the trigger itself is blocked, maybe don't draw the shadow?\n             # Examples suggest the 7->8 change happens regardless, but shadow might be blocked.\n             # Let's assume the 7->8 change always happens if trigger conditions met on input.\n             output_grid[r, c] = 8 # Change even if blocked, shadow might still draw partially.\n\n        # Draw shadow pattern, checking safety for each pixel placement\n        \n        # Place yellow (4)\n        tr, tc = r + 1, c + 1\n        if is_safe(tr, tc, height, width, magenta_rows, magenta_cols, output_grid):\n            output_grid[tr, tc] = 4\n\n        # Place horizontal red line (2)\n        h_line_len = 0\n        for k in range(2, width): # Start checking from k=2 offset\n            hr_r, hr_c = r + 1, c + k\n            if is_safe(hr_r, hr_c, height, width, magenta_rows, magenta_cols, output_grid):\n                output_grid[hr_r, hr_c] = 2\n                h_line_len += 1\n            else:\n                break # Stop extending line if blocked or out of bounds or not white\n\n        # Place vertical red line (2)\n        for k in range(2, height): # Start checking from k=2 offset\n            vr_r, vr_c = r + k, c + 1\n            if is_safe(vr_r, vr_c, height, width, magenta_rows, magenta_cols, output_grid):\n                output_grid[vr_r, vr_c] = 2\n            else:\n                break # Stop extending line if blocked or out of bounds or not white\n\n        # Place green (3)\n        # Position is (r+1, c + length_of_red_starting_at_k=2 + 2)\n        # Example: trigger (4,12). Red at (5,14), (5,15). len=2. Green at (5, 12+2+2) = (5,16).\n        gr_r, gr_c = r + 1, c + h_line_len + 2 \n        if is_safe(gr_r, gr_c, height, width, magenta_rows, magenta_cols, output_grid):\n            output_grid[gr_r, gr_c] = 3\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9026,
    "candidates_token_count": 1618,
    "total_token_count": 10644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.821106,
  "retries": null
}