{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Identify different types of objects in the input grid:\n    *   Container Objects: Non-white, non-gray objects that enclose one or more regions of white pixels (pixels with value 0).\n    *   Filler Objects: Non-white, non-gray objects that are *not* containers.\n    *   Marker Objects: Gray pixels (pixels with value 5).\n    *   Internal White Regions: Contiguous areas of white pixels completely surrounded by a single container object (i.e., they do not touch the grid border or any other non-white object).\n    *   Background: White pixels (value 0).\n\n2.  For each Internal White Region:\n    a.  Find the closest Marker Object (gray pixel) to the region. Closeness is defined by the minimum Euclidean distance between any pixel of the region and any pixel of the marker object (typically a single pixel).\n    b.  Find the closest Filler Object to that specific Marker Object. Closeness is defined similarly by minimum Euclidean distance.\n    c.  Determine the color of this closest Filler Object.\n\n3.  Construct the Output Grid:\n    a.  Start with a grid of the same dimensions as the input, filled entirely with the background color (white, 0).\n    b.  Copy the original Container Objects (pixels) onto the output grid.\n    c.  For each Internal White Region identified in step 1, fill that region in the output grid with the corresponding Filler Object color determined in step 2c.\n    d.  Original Filler Objects and Marker Objects are *not* copied to the output grid, unless their locations are overwritten by the filled internal regions.\n\"\"\"\n\ndef find_objects(grid, condition_func):\n    \"\"\"Finds all contiguous objects satisfying a condition function.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if condition_func(grid[r, c]) and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n                color = grid[r,c] # Store color for consistency check if needed\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and \\\n                           condition_func(grid[nr, nc]) and \\\n                           grid[nr,nc] == color: # Ensure same color within object\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                objects.append({'coords': obj_coords, 'color': color})\n    return objects\n\ndef get_neighbors(coords, grid_shape):\n    \"\"\"Gets all unique valid neighbor coordinates for a set of coordinates.\"\"\"\n    height, width = grid_shape\n    neighbors = set()\n    for r, c in coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n             nr, nc = r + dr, c + dc\n             if 0 <= nr < height and 0 <= nc < width:\n                 neighbors.add((nr, nc))\n    # Remove the object's own coordinates\n    neighbors -= coords\n    return neighbors\n\ndef touches_border(coords, grid_shape):\n    \"\"\"Check if any coordinate in the set touches the grid border.\"\"\"\n    height, width = grid_shape\n    for r, c in coords:\n        if r == 0 or c == 0 or r == height - 1 or c == width - 1:\n            return True\n    return False\n\ndef min_euclidean_distance(coords1, coords2):\n    \"\"\"Calculates the minimum Euclidean distance between two sets of coordinates.\"\"\"\n    min_dist_sq = float('inf')\n    if not coords1 or not coords2:\n         return float('inf') # Should not happen if objects exist\n\n    # Convert sets to lists for indexing if needed, though iterating works\n    list1 = list(coords1)\n    list2 = list(coords2)\n\n    # Optimization: if sets are large, consider spatial indexing or other methods.\n    # For ARC constraints (max 30x30), brute force is feasible.\n    for r1, c1 in list1:\n        for r2, c2 in list2:\n            dist_sq = (r1 - r2)**2 + (c1 - c2)**2\n            if dist_sq < min_dist_sq:\n                min_dist_sq = dist_sq\n\n    return math.sqrt(min_dist_sq) if min_dist_sq != float('inf') else float('inf')\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the rules derived from examples.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Start with white background\n\n    # 1. Find all relevant objects/regions\n    markers = find_objects(input_grid, lambda x: x == 5) # Gray markers\n    potential_containers_fillers = find_objects(input_grid, lambda x: x != 0 and x != 5) # Non-white, non-gray\n    white_regions = find_objects(input_grid, lambda x: x == 0) # White regions\n\n    marker_coords = [m['coords'] for m in markers] # List of sets of coords\n    all_marker_pixels = set().union(*marker_coords) # Flattened set of all marker pixels\n\n\n    # 2. Identify Containers, Fillers, and Internal White Regions\n    containers = []\n    fillers = []\n    internal_regions_map = {} # Map: frozenset(region_coords) -> {'container_idx': int, 'fill_color': None}\n\n    potential_map = {frozenset(obj['coords']): obj for obj in potential_containers_fillers}\n    non_white_pixels = np.argwhere(input_grid != 0)\n    non_white_coords = set(map(tuple, non_white_pixels))\n\n\n    internal_candidate_regions = []\n    for region in white_regions:\n        if not touches_border(region['coords'], (height, width)):\n            internal_candidate_regions.append(region)\n\n    container_indices = {} # Map object coords (frozenset) to its index in `containers` list\n\n    # Assign internal regions to containers and identify containers\n    assigned_regions = set()\n    for i, p_obj in enumerate(potential_containers_fillers):\n        p_coords_fs = frozenset(p_obj['coords'])\n        is_container = False\n        for region in internal_candidate_regions:\n            region_coords_fs = frozenset(region['coords'])\n            if region_coords_fs in assigned_regions:\n                continue # Already assigned\n\n            neighbors = get_neighbors(region['coords'], (height, width))\n            adjacent_non_white_coords = neighbors.intersection(non_white_coords)\n\n            # Check if *all* adjacent non-white pixels belong *only* to this potential container\n            if adjacent_non_white_coords and adjacent_non_white_coords.issubset(p_coords_fs):\n                 is_container = True\n                 if p_coords_fs not in container_indices:\n                     container_indices[p_coords_fs] = len(containers)\n                     containers.append(p_obj) # Add to containers list\n\n                 container_idx = container_indices[p_coords_fs]\n                 internal_regions_map[region_coords_fs] = {'container_idx': container_idx, 'fill_color': None}\n                 assigned_regions.add(region_coords_fs) # Mark as assigned\n\n        # If an object wasn't identified as a container after checking all regions, it's a filler\n    # Correct filler identification: it's any potential object NOT in containers list\n    container_coord_sets = {frozenset(c['coords']) for c in containers}\n    fillers = [p_obj for p_obj in potential_containers_fillers if frozenset(p_obj['coords']) not in container_coord_sets]\n\n\n    # 3. Determine fill color for each internal region\n    for region_coords_fs, region_data in internal_regions_map.items():\n        region_coords = set(region_coords_fs) # Unfreeze for distance calc if needed\n\n        # a. Find closest marker to the region\n        closest_marker_idx = -1\n        min_dist_to_marker = float('inf')\n        for idx, m_coords in enumerate(marker_coords):\n            dist = min_euclidean_distance(region_coords, m_coords)\n            if dist < min_dist_to_marker:\n                min_dist_to_marker = dist\n                closest_marker_idx = idx\n\n        if closest_marker_idx == -1:\n            # print(f\"Warning: No marker found for region {region_coords_fs}\")\n            continue # Skip if no marker found\n\n        closest_marker_coords = marker_coords[closest_marker_idx]\n\n        # b. Find closest filler to that marker\n        closest_filler_idx = -1\n        min_dist_to_filler = float('inf')\n        for idx, filler in enumerate(fillers):\n            dist = min_euclidean_distance(closest_marker_coords, filler['coords'])\n            if dist < min_dist_to_filler:\n                min_dist_to_filler = dist\n                closest_filler_idx = idx\n\n        if closest_filler_idx == -1:\n            # print(f\"Warning: No filler found for marker near region {region_coords_fs}\")\n            continue # Skip if no filler found\n\n        # c. Get filler color and store it\n        fill_color = fillers[closest_filler_idx]['color']\n        region_data['fill_color'] = fill_color\n\n\n    # 4. Construct the output grid\n    # a. Copy containers\n    for container in containers:\n        for r, c in container['coords']:\n             # Check bounds just in case, though coords should be valid\n             if 0 <= r < height and 0 <= c < width:\n                output_grid[r, c] = container['color']\n\n    # b. Fill internal regions\n    for region_coords_fs, region_data in internal_regions_map.items():\n        fill_color = region_data['fill_color']\n        if fill_color is not None:\n            for r, c in region_coords_fs:\n                 if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = fill_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7853,
    "candidates_token_count": 2627,
    "total_token_count": 10480,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.437466,
  "retries": null
}