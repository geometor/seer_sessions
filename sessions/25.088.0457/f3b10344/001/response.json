{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom itertools import combinations\nfrom collections import deque\n\n\"\"\"\nFill the white space between pairs of same-colored, aligned (horizontally or vertically) \nrectangles with azure (8), provided the space between them is currently empty (white, 0).\n\"\"\"\n\ndef find_rectangles(grid):\n    \"\"\"\n    Identifies all distinct, contiguous rectangular blocks of non-white pixels.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a rectangle\n              with keys 'color', 'top', 'bottom', 'left', 'right'.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Use BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            pixels.add((nr, nc))\n                \n                # Verify if the found shape is a solid rectangle\n                is_rectangle = True\n                if len(pixels) != (max_r - min_r + 1) * (max_c - min_c + 1):\n                    is_rectangle = False # Not the right number of pixels for the bounding box\n                else:\n                    # Check if all pixels within the bounding box match the color\n                     for rr in range(min_r, max_r + 1):\n                         for cc in range(min_c, max_c + 1):\n                            if grid[rr, cc] != color:\n                                # This check isn't strictly necessary if we assume inputs are always rectangles\n                                # but it helps confirm the object identification.\n                                # We might only need to check if (rr, cc) is in the 'pixels' set found by BFS.\n                                if (rr, cc) not in pixels:\n                                    is_rectangle = False \n                                    break\n                         if not is_rectangle:\n                             break\n                \n                # Store if it's confirmed or assumed to be a rectangle based on BFS extent\n                # For this problem, the shapes appear to always be solid rectangles.\n                # We rely on the bounding box identified by BFS.\n                rectangles.append({\n                    'color': color,\n                    'top': min_r,\n                    'bottom': max_r,\n                    'left': min_c,\n                    'right': max_c\n                })\n                \n    return rectangles\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (np.ndarray): The input grid as a NumPy array.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Find all colored rectangles in the input grid\n    rectangles = find_rectangles(input_grid)\n\n    # Iterate through all unique pairs of rectangles\n    for rect_a, rect_b in combinations(rectangles, 2):\n        # Check if the rectangles have the same color\n        if rect_a['color'] != rect_b['color']:\n            continue\n\n        # --- Check for Horizontal Alignment and Gap ---\n        # Check if rows overlap\n        overlap_rows = max(rect_a['top'], rect_b['top']) <= min(rect_a['bottom'], rect_b['bottom'])\n        if overlap_rows:\n            # Determine which rectangle is left and which is right\n            left_rect, right_rect = (rect_a, rect_b) if rect_a['right'] < rect_b['left'] else (rect_b, rect_a)\n\n            # Check if they are separated horizontally with a gap > 0\n            if left_rect['right'] < right_rect['left'] -1:\n                # Define the gap region boundaries\n                gap_top = max(left_rect['top'], right_rect['top'])\n                gap_bottom = min(left_rect['bottom'], right_rect['bottom'])\n                gap_left = left_rect['right'] + 1\n                gap_right = right_rect['left'] - 1\n\n                # Check if the gap area in the input grid is entirely white\n                if np.all(input_grid[gap_top : gap_bottom + 1, gap_left : gap_right + 1] == 0):\n                    # Fill the gap area in the output grid with azure (8)\n                    output_grid[gap_top : gap_bottom + 1, gap_left : gap_right + 1] = 8\n\n        # --- Check for Vertical Alignment and Gap ---\n        # Check if columns overlap\n        overlap_cols = max(rect_a['left'], rect_b['left']) <= min(rect_a['right'], rect_b['right'])\n        if overlap_cols:\n            # Determine which rectangle is top and which is bottom\n            top_rect, bottom_rect = (rect_a, rect_b) if rect_a['bottom'] < rect_b['top'] else (rect_b, rect_a)\n\n            # Check if they are separated vertically with a gap > 0\n            if top_rect['bottom'] < bottom_rect['top'] - 1:\n                 # Define the gap region boundaries\n                gap_top = top_rect['bottom'] + 1\n                gap_bottom = bottom_rect['top'] - 1\n                gap_left = max(top_rect['left'], bottom_rect['left'])\n                gap_right = min(top_rect['right'], bottom_rect['right'])\n\n                # Check if the gap area in the input grid is entirely white\n                if np.all(input_grid[gap_top : gap_bottom + 1, gap_left : gap_right + 1] == 0):\n                     # Fill the gap area in the output grid with azure (8)\n                    output_grid[gap_top : gap_bottom + 1, gap_left : gap_right + 1] = 8\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12447,
    "candidates_token_count": 1662,
    "total_token_count": 14109,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.977831,
  "retries": null
}