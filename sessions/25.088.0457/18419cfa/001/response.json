{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all distinct hollow rectangular frames made of azure (8) pixels in the input grid.\n2. For each identified azure frame:\n    a. Determine the bounding box of the azure frame.\n    b. Define the inner area as the region strictly inside the bounding box (excluding the frame pixels themselves).\n    c. Find all red (2) pixels located within this inner area in the original input grid.\n    d. If no red pixels are found within the frame's inner area, do nothing for this frame.\n    e. If red pixels are found, determine the minimum bounding box that encloses *only these red pixels*.\n    f. Iterate through all pixel coordinates within the red pixels' bounding box.\n    g. For each pixel within this red bounding box, check if its location is also within the inner area of the current azure frame.\n    h. If the location is within the frame's inner area and its current color in the grid is white (0), change its color to red (2).\n3. Keep all other pixels (including the azure frames) unchanged.\n4. Return the modified grid.\n\"\"\"\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box of a set of coordinates.\n\n    Args:\n        coords: A set or list of (row, col) tuples.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col), or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color in the grid using BFS.\n\n    Args:\n        grid: The 2D numpy array representing the grid.\n        color: The color value to find components of.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) tuples\n        of a single connected component. Uses 4-way connectivity.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) to find the component\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check if neighbor is within bounds, is the correct color, and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n\n                # Add the found component to the list\n                components.append(component_coords)\n\n    return components\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid. Finds azure frames,\n    identifies red pixels inside, calculates their bounding box, and fills\n    white pixels within that bounding box inside the frame with red.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    azure_color = 8\n    red_color = 2\n    white_color = 0\n\n    # Find all connected components of azure pixels\n    azure_components = find_connected_components(input_grid, azure_color)\n\n    # Process each azure component (assumed to be a frame)\n    for component_coords in azure_components:\n        if not component_coords:\n            continue\n\n        # Determine the bounding box of the azure frame\n        frame_bbox = get_bounding_box(component_coords)\n        if frame_bbox is None:\n            continue\n        frame_min_r, frame_min_c, frame_max_r, frame_max_c = frame_bbox\n\n        # Find all red pixels strictly within the inner area of the frame\n        # The inner area is defined by coordinates > min and < max of the frame bbox\n        red_pixels_inside = []\n        # Iterate through the potential inner area of the frame\n        for r in range(frame_min_r + 1, frame_max_r):\n            for c in range(frame_min_c + 1, frame_max_c):\n                # Check bounds just in case, although range should handle it\n                if 0 <= r < rows and 0 <= c < cols:\n                    # Check the *original* input grid for red pixels\n                    if input_grid[r, c] == red_color:\n                        red_pixels_inside.append((r, c))\n\n        # If red pixels were found inside this frame\n        if red_pixels_inside:\n            # Calculate the bounding box of *these red pixels*\n            red_bbox = get_bounding_box(red_pixels_inside)\n            if red_bbox is None: # Should not happen if red_pixels_inside is not empty\n                continue\n            red_min_r, red_min_c, red_max_r, red_max_c = red_bbox\n\n            # Fill the area defined by the red pixels' bounding box\n            # but only paint white pixels that are also within the frame's inner area\n            for r in range(red_min_r, red_max_r + 1):\n                for c in range(red_min_c, red_max_c + 1):\n                    # Check 1: Is the coordinate (r, c) strictly inside the azure frame's bounds?\n                    is_inside_frame = (frame_min_r < r < frame_max_r and\n                                       frame_min_c < c < frame_max_c)\n\n                    # Check 2: Is the pixel currently white in the output grid?\n                    if is_inside_frame and output_grid[r, c] == white_color:\n                        # If both conditions are true, change the pixel to red\n                        output_grid[r, c] = red_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5951,
    "candidates_token_count": 1581,
    "total_token_count": 7532,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.992233,
  "retries": null
}