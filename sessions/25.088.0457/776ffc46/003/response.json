{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies shapes and colors of objects enclosed within gray (5) frames (\"template objects\").\nFinds all blue (1) objects located entirely outside any gray frames.\nIf an outside blue object's shape exactly matches the shape of a template object, \nthe blue object's color is changed to the color of the matching template object in the output grid.\nOther objects, gray frames, and the background remain unchanged.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _find_connected_components(grid, target_colors, mask=None):\n    \"\"\"\n    Finds all connected components (objects) of specified colors.\n    Uses BFS. Optionally respects a mask (only considers True cells in the mask).\n    Returns a list of objects, where each object is a tuple: \n    (color, set_of_coordinates).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel has the target color, hasn't been visited,\n            # and is allowed by the mask (if mask exists)\n            if (grid[r, c] in target_colors and \n                    not visited[r, c] and \n                    (mask is None or mask[r, c])):\n                \n                obj_color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (8-directional, assuming objects connect diagonally)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            if (_is_valid(nr, nc, rows, cols) and\n                                    not visited[nr, nc] and\n                                    grid[nr, nc] == obj_color and\n                                    (mask is None or mask[nr, nc])):\n                                \n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                if obj_coords:\n                    objects.append((obj_color, obj_coords))\n                    \n    return objects\n\ndef _get_normalized_shape(coords):\n    \"\"\"\n    Normalizes the coordinates of an object relative to its top-left corner.\n    Returns a frozenset of relative coordinates for hashability.\n    \"\"\"\n    if not coords:\n        return frozenset()\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    return frozenset((r - min_r, c - min_c) for r, c in coords)\n\ndef _find_outside_pixels(grid):\n    \"\"\"\n    Uses BFS starting from the border to find all pixels reachable \n    without crossing a gray (5) pixel. These are considered \"outside\".\n    Returns a boolean mask where True means the pixel is outside.\n    \"\"\"\n    rows, cols = grid.shape\n    is_outside = np.zeros((rows, cols), dtype=bool)\n    q = deque()\n    \n    # Add border cells to queue if they are not gray\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] != 5 and not is_outside[r, c]:\n                is_outside[r, c] = True\n                q.append((r, c))\n    # Avoid double-adding corners\n    for c in range(1, cols - 1):\n        for r in [0, rows - 1]:\n             if grid[r, c] != 5 and not is_outside[r, c]:\n                is_outside[r, c] = True\n                q.append((r, c))\n\n    # BFS\n    while q:\n        r, c = q.popleft()\n        \n        # Check neighbors (4-directional is sufficient for flood fill)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            if _is_valid(nr, nc, rows, cols) and \\\n               grid[nr, nc] != 5 and \\\n               not is_outside[nr, nc]:\n                is_outside[nr, nc] = True\n                q.append((nr, nc))\n                \n    return is_outside\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding template objects inside gray frames,\n    finding blue objects outside the frames, and changing the color of outside\n    blue objects that match the shape of a template object to that template's color.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Determine which pixels are \"outside\" the gray frames\n    is_outside_mask = _find_outside_pixels(input_grid)\n    \n    # 2. Determine which pixels are \"inside\" (not outside and not gray)\n    # We are interested in non-white pixels inside.\n    is_inside_mask = ~is_outside_mask & (input_grid != 5) & (input_grid != 0)\n    \n    # 3. Find all template objects (connected components inside frames)\n    # Colors can be anything except white(0) and gray(5)\n    template_colors = set(range(1, 10)) - {5} \n    template_objects = _find_connected_components(input_grid, template_colors, mask=is_inside_mask)\n\n    # Store template shapes and their corresponding colors\n    template_shapes = {} # {normalized_shape: color}\n    for color, coords in template_objects:\n        shape = _get_normalized_shape(coords)\n        if shape: # Avoid empty shapes\n             # If multiple templates have the same shape but different colors,\n             # the last one encountered will be used. This seems consistent\n             # with examples where only one color dictates the change.\n             # If a specific rule is needed (e.g., most frequent), adjust here.\n            template_shapes[shape] = color\n\n    # If no templates found, no changes needed\n    if not template_shapes:\n        return output_grid\n\n    # 4. Find all blue objects\n    blue_objects = _find_connected_components(input_grid, {1}) # Find only blue objects\n\n    # 5. Iterate through blue objects, check if outside, compare shape, and transform\n    for _, blue_coords in blue_objects:\n        # Check if the entire object is outside\n        is_entirely_outside = all(is_outside_mask[r, c] for r, c in blue_coords)\n        \n        if is_entirely_outside:\n            # Get the normalized shape of the blue object\n            blue_shape = _get_normalized_shape(blue_coords)\n            \n            # Check if this shape matches any template shape\n            if blue_shape in template_shapes:\n                target_color = template_shapes[blue_shape]\n                # Change the color of this blue object in the output grid\n                for r, c in blue_coords:\n                    output_grid[r, c] = target_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12048,
    "candidates_token_count": 1797,
    "total_token_count": 13845,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 44.235281,
  "retries": null
}