{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms an input grid by finding two unique pixels of the same color (endpoints), \nidentifying the background color (most frequent) and obstacle colors (all others),\nand then drawing the shortest path between the endpoints using the endpoint color. \nThe path can only traverse cells originally containing the background color and moves \nonly horizontally or vertically.\n\nWorkflow:\n1. Identify Key Components:\n    - Find the most frequent color and assume it's the background.\n    - Find a color that appears exactly twice, excluding the background color. These are the endpoints.\n    - Identify all other colors as obstacles.\n    - Handle cases where unique endpoints or background cannot be clearly identified.\n2. Find Shortest Path:\n    - Use Breadth-First Search (BFS) starting from one endpoint.\n    - Explore adjacent (up, down, left, right) cells.\n    - Valid moves are onto cells that match the background color.\n    - The target is the other endpoint.\n    - Keep track of the path taken.\n3. Draw Path:\n    - Create a copy of the input grid.\n    - If a path is found, iterate through the coordinates in the path (excluding the start and end points).\n    - Set the color of these path cells in the copied grid to the endpoint color.\n4. Return Result:\n    - Return the modified grid. If identification fails or no path is found, return the original grid copy.\n\"\"\"\n\ndef find_endpoints_and_obstacles(grid):\n    \"\"\"\n    Identifies the background color, endpoint color and coordinates, \n    and obstacle colors from the input grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, endpoint_color, endpoints, obstacle_colors)\n               Returns (None, None, None, None) if identification fails \n               (e.g., no color appears exactly twice besides background, or multiple colors appear twice).\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    \n    # Handle empty or single-color grids gracefully\n    if not unique_colors.size:\n        return None, None, None, None\n    if unique_colors.size == 1:\n         return unique_colors[0], None, None, set() # Only background exists\n\n    # Assume background color is the most frequent\n    background_color_index = np.argmax(counts)\n    background_color = unique_colors[background_color_index]\n\n    endpoint_color = None\n    endpoints = []\n    obstacle_colors = set()\n    potential_endpoint_colors_found = 0\n    \n    # Iterate through colors to find endpoints and obstacles\n    for i, color in enumerate(unique_colors):\n        if color == background_color:\n            continue # Skip background\n\n        count = counts[i]\n        if count == 2:\n            potential_endpoint_colors_found += 1\n            if potential_endpoint_colors_found > 1:\n                # Ambiguity: More than one color appears exactly twice\n                # print(f\"Warning: Ambiguous endpoints. Multiple colors ({endpoint_color}, {color}) appear twice.\")\n                return None, None, None, None \n            \n            endpoint_color = color\n            # Find coordinates efficiently using np.where\n            rows, cols = np.where(grid == color)\n            endpoints = list(zip(rows, cols))\n\n        else:\n            # Any other non-background color is an obstacle\n            obstacle_colors.add(color)\n            \n    # Check if exactly one endpoint color was found\n    if potential_endpoint_colors_found != 1 or not endpoints:\n        # print(f\"Warning: Could not find exactly one color appearing twice (found {potential_endpoint_colors_found}).\")\n        return None, None, None, None\n\n    return background_color, endpoint_color, endpoints, obstacle_colors\n\n\ndef solve_bfs(grid, start_pos, end_pos, background_color, obstacle_colors):\n    \"\"\"\n    Finds the shortest path between start_pos and end_pos using BFS, \n    avoiding obstacles and only moving on the background color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_pos (tuple): The (row, col) of the starting point.\n        end_pos (tuple): The (row, col) of the ending point.\n        background_color (int): The color of valid path cells.\n        obstacle_colors (set): A set of colors that the path cannot traverse.\n\n    Returns:\n        list: A list of (row, col) tuples representing the path, or None if no path exists.\n    \"\"\"\n    rows, cols = grid.shape\n    queue = deque([(start_pos, [start_pos])])  # Store (current_position, path_list)\n    visited = {start_pos} # Keep track of visited cells to avoid cycles and redundant work\n\n    while queue:\n        (r, c), path = queue.popleft()\n\n        # Check if we reached the end point\n        if (r, c) == end_pos:\n            return path # Path found\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                \n                # Check if already visited\n                if neighbor_pos in visited:\n                    continue\n\n                neighbor_color = grid[nr, nc]\n\n                # Determine if the neighbor cell is valid for traversal\n                # It's valid if it's the end position OR if it's a background cell\n                is_end_cell = (neighbor_pos == end_pos)\n                is_background_cell = (neighbor_color == background_color)\n                # is_obstacle = (neighbor_color in obstacle_colors) # Not strictly needed due to background check\n\n                if is_end_cell or is_background_cell:\n                    # Mark as visited and add to the queue\n                    visited.add(neighbor_pos)\n                    new_path = list(path) # Create a new path list\n                    new_path.append(neighbor_pos)\n                    queue.append((neighbor_pos, new_path))\n                    \n    # If the queue becomes empty and we haven't returned, no path exists\n    return None \n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding two endpoint pixels and drawing the shortest \n    path between them using the background color cells.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The output grid with the path drawn, or the original grid if \n                       identification fails or no path is found.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify and return\n    output_grid = np.copy(grid)\n    \n    # --- 1. Identify Key Components ---\n    background_color, endpoint_color, endpoints, obstacle_colors = find_endpoints_and_obstacles(grid)\n\n    # Check if identification was successful\n    if background_color is None or endpoint_color is None or not endpoints or len(endpoints) != 2:\n        # If identification failed (ambiguity, no clear endpoints), return the original grid copy\n        # print(\"Debug: Identification failed. Returning original grid.\")\n        return output_grid.tolist() \n\n    start_pos, end_pos = endpoints[0], endpoints[1]\n\n    # --- 2. Find the Shortest Path using BFS ---\n    # print(f\"Debug: Finding path from {start_pos} to {end_pos} over background {background_color}, avoiding {obstacle_colors}\")\n    path = solve_bfs(grid, start_pos, end_pos, background_color, obstacle_colors)\n\n    # --- 3. Draw the Path on the Output Grid ---\n    if path:\n        # print(f\"Debug: Path found: {path}\")\n        # Iterate through the coordinates in the found path\n        for r, c in path:\n            # Don't overwrite the start/end points unnecessarily (already correct color)\n            # Only color the intermediate path segments\n            if (r, c) != start_pos and (r, c) != end_pos:\n                 output_grid[r, c] = endpoint_color\n    else:\n        # Handle case where no path is found if necessary\n        # Currently, just returns the original grid copy (implicitly)\n        # print(\"Debug: No path found between endpoints. Returning original grid.\")\n        pass # Return the unmodified output_grid\n\n    # --- 4. Return Result ---\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6324,
    "candidates_token_count": 2068,
    "total_token_count": 8392,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.936921,
  "retries": null
}