{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\ndef find_endpoints_and_obstacles(grid):\n    \"\"\"\n    Identifies the background color, endpoint color and coordinates, \n    and obstacle colors from the input grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, endpoint_color, endpoints, obstacle_colors)\n               Returns None for any value if identification fails (e.g., not exactly 2 endpoints).\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    if not unique_colors.size:\n        return None, None, None, None\n\n    # Assume background color is the most frequent\n    background_color = unique_colors[np.argmax(counts)]\n\n    endpoint_color = None\n    endpoints = []\n    obstacle_colors = set()\n    \n    non_bg_pixels = {}\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in non_bg_pixels:\n                    non_bg_pixels[color] = []\n                non_bg_pixels[color].append((r, c))\n\n    # Find endpoint color (exactly 2 pixels) and obstacle colors\n    for color, positions in non_bg_pixels.items():\n        if len(positions) == 2:\n            if endpoint_color is not None: # Found more than one potential endpoint color\n                return None, None, None, None \n            endpoint_color = color\n            endpoints = positions\n        else:\n            obstacle_colors.add(color)\n            \n    if endpoint_color is None: # Did not find a color with exactly 2 pixels\n         return None, None, None, None\n\n    return background_color, endpoint_color, endpoints, obstacle_colors\n\n\ndef solve_bfs(grid, start_pos, end_pos, background_color, obstacle_colors):\n    \"\"\"\n    Finds the shortest path between start_pos and end_pos using BFS, \n    avoiding obstacles and only moving on the background color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_pos (tuple): The (row, col) of the starting point.\n        end_pos (tuple): The (row, col) of the ending point.\n        background_color (int): The color of valid path cells.\n        obstacle_colors (set): A set of colors that the path cannot traverse.\n\n    Returns:\n        list: A list of (row, col) tuples representing the path, or None if no path exists.\n    \"\"\"\n    rows, cols = grid.shape\n    queue = deque([(start_pos, [start_pos])])  # (current_position, path_list)\n    visited = {start_pos}\n\n    while queue:\n        (r, c), path = queue.popleft()\n\n        if (r, c) == end_pos:\n            return path\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                neighbor_color = grid[nr, nc]\n\n                # Check if visited or an obstacle\n                # The path can only go through background cells, except for the endpoint itself\n                is_valid_path_cell = (neighbor_color == background_color)\n                is_end_cell = (neighbor_pos == end_pos)\n                \n                if neighbor_pos not in visited and (is_valid_path_cell or is_end_cell) :\n                    visited.add(neighbor_pos)\n                    new_path = list(path)\n                    new_path.append(neighbor_pos)\n                    queue.append((neighbor_pos, new_path))\n                    \n    return None # No path found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Finds two unique pixels of the same color (endpoints) in the input grid,\n    ignoring the most frequent color (background) and other colors (obstacles).\n    It then finds the shortest path between these two endpoints, moving only\n    horizontally or vertically through the background color cells. Finally,\n    it draws this path onto the grid using the endpoint color.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The output grid with the path drawn.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify background, endpoints, and obstacles\n    background_color, endpoint_color, endpoints, obstacle_colors = find_endpoints_and_obstacles(grid)\n\n    # Check if identification was successful\n    if background_color is None or endpoint_color is None or not endpoints or len(endpoints) != 2:\n        # If we cannot clearly identify the elements, return the original grid\n        # Or handle error appropriately based on expected behavior for ambiguous cases\n        print(\"Warning: Could not uniquely identify background, endpoints, or obstacles. Returning original grid.\")\n        return input_grid \n\n    start_pos, end_pos = endpoints[0], endpoints[1]\n\n    # 2. Find the shortest path using BFS\n    path = solve_bfs(grid, start_pos, end_pos, background_color, obstacle_colors)\n\n    # 3. Draw the path on the output grid\n    if path:\n        for r, c in path:\n            # Don't overwrite the start/end points, they already have the correct color\n            # Although overwriting them with the same color is harmless.\n            # More importantly, ensure we only color the path itself.\n             if (r, c) != start_pos and (r, c) != end_pos:\n                 output_grid[r, c] = endpoint_color\n    else:\n        # Handle case where no path is found if necessary\n        # Currently, just returns the original grid implicitly if path is None\n        print(\"Warning: No path found between endpoints. Returning original grid.\")\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11906,
    "candidates_token_count": 1477,
    "total_token_count": 13383,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.722529,
  "retries": null
}