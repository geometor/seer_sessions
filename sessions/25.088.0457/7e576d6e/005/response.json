{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms an input grid by:\n1. Identifying the background color (most frequent color).\n2. Identifying two 'endpoint' pixels which share the same color, where that color appears exactly twice in the grid (excluding the background color).\n3. Identifying all other colors as 'obstacles'.\n4. Finding the shortest path between the two endpoints using Breadth-First Search (BFS). The path can only move horizontally or vertically and must only traverse cells that originally contained the background color.\n5. Constructing an output grid by copying the input grid and then drawing the found path (excluding the start and end points themselves) onto the copy using the endpoint color. If no unique endpoints are found or no path exists, the original grid is returned.\n\"\"\"\n\ndef find_endpoints_and_obstacles(grid):\n    \"\"\"\n    Identifies the background color, endpoint color and coordinates, \n    and obstacle colors from the input grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, endpoint_color, endpoints, obstacle_colors)\n               Returns (None, None, None, None) if identification fails \n               (e.g., no color appears exactly twice besides background, or multiple colors appear twice).\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    \n    # Handle empty or single-color grids gracefully\n    if not unique_colors.size:\n        return None, None, None, None\n    if unique_colors.size == 1:\n         return unique_colors[0], None, None, set() # Only background exists\n\n    # Assume background color is the most frequent\n    background_color_index = np.argmax(counts)\n    background_color = unique_colors[background_color_index]\n\n    endpoint_color = None\n    endpoints = []\n    obstacle_colors = set()\n    potential_endpoint_colors_found = 0\n    \n    # Iterate through colors to find endpoints and obstacles\n    for i, color in enumerate(unique_colors):\n        if color == background_color:\n            continue # Skip background\n\n        count = counts[i]\n        if count == 2:\n            potential_endpoint_colors_found += 1\n            if potential_endpoint_colors_found > 1:\n                # Ambiguity: More than one color appears exactly twice\n                return None, None, None, None \n            \n            endpoint_color = color\n            # Find coordinates efficiently using np.where\n            rows, cols = np.where(grid == color)\n            endpoints = list(zip(rows, cols))\n\n        else:\n            # Any other non-background color is an obstacle\n            obstacle_colors.add(color)\n            \n    # Check if exactly one endpoint color was found\n    if potential_endpoint_colors_found != 1 or not endpoints:\n        return None, None, None, None\n\n    return background_color, endpoint_color, endpoints, obstacle_colors\n\n\ndef solve_bfs_optimized(grid, start_pos, end_pos, background_color):\n    \"\"\"\n    Finds the shortest path between start_pos and end_pos using BFS, \n    moving only on the background color. Optimized to avoid storing full paths in the queue.\n\n    Args:\n        grid (np.array): The input grid.\n        start_pos (tuple): The (row, col) of the starting point.\n        end_pos (tuple): The (row, col) of the ending point.\n        background_color (int): The color of valid path cells.\n\n    Returns:\n        list: A list of (row, col) tuples representing the path, or None if no path exists.\n    \"\"\"\n    rows, cols = grid.shape\n    queue = deque([start_pos])  # Store just the current position\n    visited = {start_pos} # Keep track of visited cells\n    parents = {start_pos: None} # Store {child_pos: parent_pos} to reconstruct path\n\n    while queue:\n        r, c = queue.popleft()\n\n        # Check if we reached the end point\n        if (r, c) == end_pos:\n            # Reconstruct path\n            path = []\n            curr = end_pos\n            while curr is not None:\n                path.append(curr)\n                curr = parents[curr]\n            return path[::-1] # Return reversed path (start -> end)\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n\n            # Check if the neighbor is within grid bounds and not visited\n            if 0 <= nr < rows and 0 <= nc < cols and neighbor_pos not in visited:\n                neighbor_color = grid[nr, nc]\n\n                # Determine if the neighbor cell is valid for traversal\n                # It's valid if it's the end position OR if it's a background cell\n                is_end_cell = (neighbor_pos == end_pos)\n                is_background_cell = (neighbor_color == background_color)\n\n                if is_end_cell or is_background_cell:\n                    # Mark as visited, store parent, and add to the queue\n                    visited.add(neighbor_pos)\n                    parents[neighbor_pos] = (r, c)\n                    queue.append(neighbor_pos)\n                    \n    # If the queue becomes empty and we haven't returned, no path exists\n    return None \n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by finding two endpoint pixels and drawing the shortest \n    path between them using the background color cells.\n\n    Args:\n        input_grid_list (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The output grid with the path drawn, or the original grid if \n                       identification fails or no path is found.\n    \"\"\"\n    # Convert input list of lists to numpy array for processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # --- 1. Identify Key Components ---\n    # Find background color, endpoints, and obstacles based on color frequencies\n    background_color, endpoint_color, endpoints, obstacle_colors = find_endpoints_and_obstacles(input_grid)\n\n    # --- Check if Identification was Successful ---\n    # If we couldn't find a unique background or exactly two endpoints of the same color,\n    # return the original grid unmodified.\n    if background_color is None or endpoint_color is None or not endpoints or len(endpoints) != 2:\n        return output_grid.tolist() \n\n    # Extract start and end positions\n    start_pos, end_pos = endpoints[0], endpoints[1]\n\n    # --- 2. Find the Shortest Path using Optimized BFS ---\n    # Search for the shortest path from start to end, only moving on background cells\n    # Note: obstacle_colors aren't strictly needed by BFS if it only checks for background_color or end_pos\n    path = solve_bfs_optimized(input_grid, start_pos, end_pos, background_color)\n\n    # --- 3. Draw the Path on the Output Grid ---\n    # If a path was found by BFS:\n    if path:\n        # Iterate through the coordinates in the found path\n        for r, c in path:\n            # Do not recolor the original start and end points\n            # Only color the intermediate cells that were originally background\n            if (r, c) != start_pos and (r, c) != end_pos:\n                 output_grid[r, c] = endpoint_color\n    # else: # No path found or identification failed earlier\n        # If no path is found, we implicitly return the unmodified output_grid copy\n\n    # --- 4. Return Result ---\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6692,
    "candidates_token_count": 1873,
    "total_token_count": 8565,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.02814,
  "retries": null
}