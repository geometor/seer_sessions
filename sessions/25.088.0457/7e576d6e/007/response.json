{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nAnalyzes the input grid to identify key components based on pixel color frequencies. The background color is assumed to be the most frequent color. Identifies a pair of 'endpoint' pixels, defined as the only two pixels in the grid sharing the same color, provided that this color is unique in appearing exactly twice (and is not the background color). All other colors are considered 'obstacles'.\n\nIf a unique background color and exactly one pair of endpoint pixels are successfully identified, attempts to find the shortest path between the two endpoint pixel locations. This path must adhere to the following rules:\n1. Movement is restricted to adjacent cells horizontally or vertically (no diagonals).\n2. The path can only traverse cells that originally contained the identified background color. The starting endpoint is the beginning of the path, and the target endpoint cell is a valid final step.\n\nCreates the output grid by first making an exact copy of the input grid. If a valid shortest path was found, modifies the copied grid by changing the color of all pixels along the path to match the color of the endpoint pixels. Crucially, the original two endpoint pixels themselves retain their color; only the intermediate path segments (originally background color) are recolored.\n\nIf the initial identification step fails (e.g., no color appears exactly twice besides the background, or multiple colors appear twice), or if no path satisfying the conditions can be found between the identified endpoints, returns the original input grid without any modifications.\n\"\"\"\n\ndef find_endpoints_and_background(grid):\n    \"\"\"\n    Identifies the background color, endpoint color, and endpoint coordinates.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, endpoint_color, endpoints)\n               Returns (None, None, None) if identification fails.\n    \"\"\"\n    if grid.size == 0:\n        return None, None, None\n\n    unique_colors, counts = np.unique(grid, return_counts=True)\n\n    # Handle grid with only one color\n    if len(unique_colors) == 1:\n        return unique_colors[0], None, None # Only background exists\n\n    # Identify potential background color (most frequent)\n    background_color_index = np.argmax(counts)\n    background_color = unique_colors[background_color_index]\n\n    endpoint_color = None\n    endpoints = None\n    potential_endpoint_colors_found = 0\n\n    # Iterate through colors to find the unique color appearing exactly twice\n    for color, count in zip(unique_colors, counts):\n        if color == background_color:\n            continue # Skip background\n\n        if count == 2:\n            potential_endpoint_colors_found += 1\n            # If we find more than one color appearing twice, it's ambiguous\n            if potential_endpoint_colors_found > 1:\n                return background_color, None, None # Ambiguous endpoint color\n\n            endpoint_color = color\n            # Find coordinates using np.where\n            rows, cols = np.where(grid == color)\n            endpoints = list(zip(rows, cols))\n\n    # Check if exactly one endpoint color was found and it has 2 points\n    if potential_endpoint_colors_found == 1 and endpoints and len(endpoints) == 2:\n        return background_color, endpoint_color, endpoints\n    else:\n        # Either no color appeared twice, or the check above already caught ambiguity\n        return background_color, None, None\n\n\ndef solve_bfs(grid, start_pos, end_pos, background_color):\n    \"\"\"\n    Finds the shortest path using BFS, moving only on background_color.\n\n    Args:\n        grid (np.array): The input grid.\n        start_pos (tuple): (row, col) of the start point.\n        end_pos (tuple): (row, col) of the end point.\n        background_color (int): The color of valid path cells.\n\n    Returns:\n        list: List of (row, col) tuples for the path, or None if no path exists.\n    \"\"\"\n    rows, cols = grid.shape\n    queue = deque([start_pos]) # Queue stores current positions\n    visited = {start_pos}      # Set of visited (row, col) tuples\n    parents = {start_pos: None} # Dictionary {child_pos: parent_pos} for path reconstruction\n\n    while queue:\n        r, c = queue.popleft()\n\n        # Goal check\n        if (r, c) == end_pos:\n            # Reconstruct path from end to start using parents dictionary\n            path = []\n            curr = end_pos\n            while curr is not None:\n                path.append(curr)\n                curr = parents[curr]\n            return path[::-1] # Return path from start to end\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            neighbor_pos = (nr, nc)\n\n            # Check bounds and if already visited\n            if 0 <= nr < rows and 0 <= nc < cols and neighbor_pos not in visited:\n                neighbor_color = grid[nr, nc]\n\n                # Check if the neighbor is a valid step:\n                # It must be either the end position itself or a background cell\n                is_valid_step = (neighbor_pos == end_pos) or (neighbor_color == background_color)\n\n                if is_valid_step:\n                    visited.add(neighbor_pos)\n                    parents[neighbor_pos] = (r, c)\n                    queue.append(neighbor_pos)\n\n    # If queue empties and end_pos wasn't reached\n    return None\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid according to the described logic.\n    \"\"\"\n    # Convert list of lists to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify Components\n    background_color, endpoint_color, endpoints = find_endpoints_and_background(input_grid)\n\n    # Check if identification was successful (found background and unique pair of endpoints)\n    if endpoint_color is None or endpoints is None:\n        # If not successful, return the original grid\n        return output_grid.tolist()\n\n    start_pos, end_pos = endpoints[0], endpoints[1]\n\n    # 2. Find Shortest Path using BFS\n    path = solve_bfs(input_grid, start_pos, end_pos, background_color)\n\n    # 3. Draw Path if Found\n    if path:\n        # Iterate through the path coordinates\n        for r, c in path:\n            # Do not recolor the start and end points themselves\n            if (r, c) != start_pos and (r, c) != end_pos:\n                 # Only color the intermediate path cells\n                 output_grid[r, c] = endpoint_color\n    # else: # No path found, output_grid remains the unmodified copy\n\n    # 4. Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5660,
    "candidates_token_count": 1658,
    "total_token_count": 7318,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.806403,
  "retries": null
}