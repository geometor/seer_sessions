{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Initialize an output grid as an exact copy of the input grid.\n2. Identify all distinct, contiguous groups of yellow (4) pixels in the input grid using 4-way adjacency (these are \"yellow components\"). For each component, determine its pixel coordinates and its minimal bounding box.\n3. Analyze each yellow component:\n    a. Find all pixels within the component's bounding box in the input grid that are *not* yellow (4) and *not* white (0). These are the \"internal pixels\".\n    b. Check if any internal pixels were found.\n    c. If internal pixels exist, check if they *all* share the same single color (the \"inner color\").\n    d. If internal pixels exist and all share the same inner color, the component qualifies for a border. Calculate the border thickness (`T`) as the total number of internal pixels. Store the component's bounding box, original yellow pixel coordinates, the inner color, and the thickness `T`.\n4. Draw borders for all qualifying components onto the output grid:\n    a. For each qualifying component, calculate an expanded bounding box by extending its original bounding box outwards by thickness `T` in all directions (clamped to grid boundaries).\n    b. Fill all pixels in the output grid that are within the expanded bounding box but *outside* the original bounding box with the component's inner color.\n5. Preserve the original yellow pixels for all qualifying components:\n    a. For each qualifying component, iterate through its original yellow pixel coordinates.\n    b. Set the color of the corresponding pixel in the output grid back to yellow (4). This corrects any yellow pixels that might have been overwritten during border drawing.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_yellow_components(grid):\n    \"\"\"\n    Finds all connected components of yellow (4) pixels using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a\n              yellow component and contains:\n              - 'coords': A set of (row, col) tuples for the yellow pixels.\n              - 'bbox': A tuple (min_r, min_c, max_r, max_c) representing\n                        the bounding box of the component.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n    yellow_color = 4\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == yellow_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == yellow_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if component_coords:\n                    components.append({\n                        'coords': component_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return components\n\ndef find_internal_pixels_within_bbox(grid, bbox):\n    \"\"\"\n    Finds pixels strictly inside the bbox that are not yellow (4) or white (0).\n\n    Args:\n        grid (np.array): The input grid.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n\n    Returns:\n        list: A list of dictionaries, each containing:\n              - 'coord': (row, col) tuple of the internal pixel.\n              - 'color': The color of the internal pixel.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    internal_pixels = []\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            color = grid[r, c]\n            # Rule 3a: internal pixels are NOT yellow (4) and NOT white (0)\n            if color != 4 and color != 0:\n                internal_pixels.append({'coord': (r, c), 'color': color})\n    return internal_pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Step 1: Initialize output grid as a copy of the input\n    output_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Step 2: Identify yellow components and their bounding boxes\n    yellow_components = find_yellow_components(input_grid_np)\n\n    qualifying_components = []\n\n    # Step 3: Analyze each yellow component\n    for component in yellow_components:\n        bbox = component['bbox']\n        yellow_coords = component['coords'] # Need original coords for step 5\n\n        # Step 3a: Find internal pixels within this bounding box\n        internal_pixels = find_internal_pixels_within_bbox(input_grid_np, bbox)\n\n        # Step 3b & 3c: Check border conditions\n        if not internal_pixels:\n            continue # No internal pixels\n\n        first_inner_color = internal_pixels[0]['color']\n        all_same_color = all(p['color'] == first_inner_color for p in internal_pixels)\n\n        if not all_same_color:\n            continue # Internal pixels exist but have different colors\n\n        # Step 3d: Qualify for border and calculate properties\n        inner_color = first_inner_color\n        thickness_t = len(internal_pixels)\n\n        qualifying_components.append({\n            'bbox': bbox,\n            'inner_color': inner_color,\n            'thickness': thickness_t,\n            'yellow_coords': yellow_coords # Store original yellow coords\n        })\n\n    # Step 4: Draw borders for qualifying components\n    for qc in qualifying_components:\n        min_r, min_c, max_r, max_c = qc['bbox']\n        inner_color = qc['inner_color']\n        thickness = qc['thickness']\n\n        # Step 4a: Calculate expanded bounding box coordinates\n        exp_min_r = max(0, min_r - thickness)\n        exp_min_c = max(0, min_c - thickness)\n        exp_max_r = min(height - 1, max_r + thickness)\n        exp_max_c = min(width - 1, max_c + thickness)\n\n        # Step 4b: Fill border area\n        for r in range(exp_min_r, exp_max_r + 1):\n            for c in range(exp_min_c, exp_max_c + 1):\n                # Check if the pixel (r, c) is outside the original bounding box\n                is_outside_original_bbox = (r < min_r or r > max_r or c < min_c or c > max_c)\n                if is_outside_original_bbox:\n                    # Check bounds again just to be safe, though clamping should handle it\n                    if 0 <= r < height and 0 <= c < width:\n                         output_grid_np[r, c] = inner_color\n\n    # Step 5: Preserve original yellow pixels for qualifying components\n    for qc in qualifying_components:\n        yellow_coords = qc['yellow_coords']\n        for r, c in yellow_coords:\n            # Check bounds just in case, though coords should be valid\n            if 0 <= r < height and 0 <= c < width:\n                 output_grid_np[r, c] = 4 # Set back to yellow\n\n    # Step 6: Return the modified grid\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17732,
    "candidates_token_count": 2017,
    "total_token_count": 19749,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.993894,
  "retries": null
}