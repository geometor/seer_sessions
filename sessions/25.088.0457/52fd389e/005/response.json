{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Create an output grid as a copy of the input grid.\n2. Identify all distinct, contiguous, rectangular blocks composed solely of yellow (4) pixels in the input grid. These are the \"yellow rectangles\".\n3. For each identified yellow rectangle:\n    a. Determine its bounding box.\n    b. Find all pixels within this bounding box in the input grid that are *not* yellow (4) and *not* white (0). These are the \"internal pixels\". Note: These internal pixels are within the area covered by the yellow rectangle's bounding box but are not part of the yellow rectangle itself.\n    c. Check if any internal pixels were found.\n    d. If internal pixels exist, check if they *all* share the same single color (the \"inner color\").\n    e. If internal pixels exist and all share the same inner color:\n        i. Count the number of internal pixels (N). This count determines the \"border thickness\" (T = N).\n        ii. Calculate the coordinates of an expanded bounding box by extending the original bounding box outwards by the border thickness T in all four directions (up, down, left, right), ensuring the coordinates stay within the grid limits.\n        iii. In the output grid, fill all pixels that are within the *expanded* bounding box but *outside* the *original* bounding box with the inner color.\n        iv. In the output grid, ensure all pixels that were part of the original yellow rectangle (i.e., yellow pixels found in step 2) are set back to yellow (4). This preserves the yellow rectangle shape and overwrites any border pixels that might have overlapped with the original yellow area.\n4. Yellow rectangles that do not have internal pixels, or whose internal pixels have multiple different colors, do not get a border drawn around them. Their yellow pixels are retained in the output unless overwritten by a border from another qualifying rectangle.\n5. Return the modified output grid.\n\"\"\"\n\ndef find_yellow_rectangles(grid):\n    \"\"\"\n    Finds all connected components of yellow (4) pixels that form a solid rectangle.\n    Uses 4-way connectivity.\n    Returns a list of dictionaries, each containing the coordinates ('coords')\n    and bounding box ('bbox') of a yellow rectangle.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n    yellow_color = 4\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == yellow_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n                min_r, min_c, max_r, max_c = r, c, r, c # Keep track for bbox\n\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == yellow_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_coords.add((nr, nc))\n\n                # Verify if the component *itself* forms a solid rectangle\n                # Check if the number of yellow pixels found matches the area of their bounding box.\n                bbox_height = max_r - min_r + 1\n                bbox_width = max_c - min_c + 1\n                if len(component_coords) == bbox_height * bbox_width:\n                    # Further check: ensure all pixels within this bbox *in the component* are yellow\n                    # This check is implicitly covered by the BFS finding only yellow connected pixels\n                    # and the size check confirming it fills the bounding box derived *from those pixels*.\n                    is_solid_rect = True # If size matches bbox area, it must be solid.\n\n                    # Original code had a check here that iterated grid[r_rect, c_rect] != color,\n                    # which was incorrect as it rejected rectangles containing internal non-yellow pixels.\n                    # The current logic correctly identifies solid rectangles *of yellow*.\n\n                    if is_solid_rect and component_coords:\n                         rectangles.append({\n                             'coords': component_coords, # The set of (r, c) for yellow pixels\n                             'bbox': (min_r, min_c, max_r, max_c) # Bbox of the yellow pixels\n                         })\n    return rectangles\n\ndef find_internal_pixels(grid, bbox):\n    \"\"\"\n    Finds pixels strictly inside the bbox that are not yellow (4) or white (0).\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    internal_pixels = []\n    # Iterate within the bounding box defined by the yellow pixels.\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Check if the current coordinate (r,c) is actually part of the yellow rectangle pixels\n            # This isn't strictly needed if find_yellow_rectangles ensures solid yellow shapes,\n            # but it clarifies that we are looking for non-yellow/non-white *within* the rectangle's area.\n             color = grid[r, c]\n             # Rule 3b: internal pixels are NOT yellow (4) and NOT white (0)\n             if color != 4 and color != 0:\n                 # We only count pixels that are geometrically within the yellow rectangle's footprint\n                 internal_pixels.append({'coord': (r, c), 'color': color})\n\n    return internal_pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    # Step 1: Initialize output grid as a copy of the input\n    output_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Step 2: Identify yellow rectangular components and get their bounding boxes\n    yellow_rectangles_data = find_yellow_rectangles(input_grid_np)\n\n    objects_to_process = []\n\n    # Step 3: Analyze each yellow rectangle\n    for rect_data in yellow_rectangles_data:\n        yellow_coords = rect_data['coords'] # The actual coordinates of the yellow pixels\n        bbox = rect_data['bbox'] # Bbox of the yellow pixels themselves (min_r, min_c, max_r, max_c)\n\n        # Step 3b: Find internal pixels within this bounding box\n        # These are non-yellow, non-white pixels located within the rectangle's area\n        internal_pixels = find_internal_pixels(input_grid_np, bbox)\n\n        # Step 3c & 3d: Check if internal pixels exist and share the same color\n        if not internal_pixels:\n            continue # No internal pixels, skip border drawing for this object\n\n        first_inner_color = internal_pixels[0]['color']\n        all_same_color = all(p['color'] == first_inner_color for p in internal_pixels)\n\n        # Step 3e: If conditions met, prepare object data for processing\n        if all_same_color:\n            inner_color = first_inner_color\n            # Step 3.e.i: Border thickness = count of internal pixels\n            thickness_t = len(internal_pixels)\n            objects_to_process.append({\n                'bbox': bbox,\n                'inner_color': inner_color,\n                'thickness': thickness_t,\n                'yellow_coords': yellow_coords # Store the original yellow coords\n            })\n\n    # Process the qualified objects. A two-pass approach helps handle overlaps.\n    # Pass 1 (Step 3.e.iii): Draw borders onto the output grid\n    for obj in objects_to_process:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        inner_color = obj['inner_color']\n        thickness = obj['thickness']\n\n        # Step 3.e.ii: Calculate expanded bounding box coordinates, clamped to grid boundaries\n        exp_min_r = max(0, min_r - thickness)\n        exp_min_c = max(0, min_c - thickness)\n        exp_max_r = min(height - 1, max_r + thickness)\n        exp_max_c = min(width - 1, max_c + thickness)\n\n        # Draw the border: fill pixels in the expanded box BUT outside the original box\n        for r in range(exp_min_r, exp_max_r + 1):\n            for c in range(exp_min_c, exp_max_c + 1):\n                # Check if the pixel (r, c) is outside the original bounding box\n                is_outside_original_bbox = (r < min_r or r > max_r or c < min_c or c > max_c)\n                if is_outside_original_bbox:\n                    output_grid_np[r, c] = inner_color\n\n    # Pass 2 (Step 3.e.iv): Ensure the original yellow pixels are restored to yellow\n    # This corrects cases where a border might have overwritten part of the yellow shape\n    # or if the internal pixels were near the edge and got painted over.\n    for obj in objects_to_process:\n        yellow_coords = obj['yellow_coords']\n        for r, c in yellow_coords:\n            # Check bounds just in case, though coords should be valid\n            if 0 <= r < height and 0 <= c < width:\n                 output_grid_np[r, c] = 4 # Set back to yellow\n\n    # Step 5: Return the modified grid\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14936,
    "candidates_token_count": 2405,
    "total_token_count": 17341,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.590911,
  "retries": null
}