{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple, Optional\n\n\"\"\"\nTransformation Rule:\n\n1.  Determine the dimensions (Height H, Width W) of the input grid.\n2.  Identify the border color (B) from the input grid's frame (e.g., pixel at `[0, 0]`).\n3.  Initialize a new output grid of dimensions HxW, filled entirely with the background color (0, white).\n4.  Draw the border onto the output grid: Set row 0, row H-1, column 0, and column W-1 to the border color B. Handle edge cases for 1-pixel height/width grids.\n5.  Iterate through the rows `r` from 1 to H-2 to find the anchor pixels:\n    *   Check if the pixels at `(r, 1)` and `(r, 18)` exist and are identical.\n    *   Check if this identical color is not the background color (0) and not the border color (B).\n    *   If both conditions are met, record this color as the anchor color (C) and the row index as the anchor row (R). Stop searching once found.\n6.  If no anchor pixels are found, return the output grid with only the border drawn.\n7.  Draw a horizontal line onto the output grid using the anchor color (C). This line should be on the anchor row (R) and extend from column 1 to column 18 (inclusive).\n8.  Select the specific H-like shape pattern, its center row offset (CRO), and its starting column (Col) based *only* on the anchor color (C) using the following mapping:\n    *   If C is Orange (7): Pattern=[[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]], CRO=2, Col=13.\n    *   If C is Magenta (6): Pattern=[[1,1,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,1,1]], CRO=2, Col=2.\n    *   If C is Red (2): Pattern=[[1,0,1],[0,1,0],[1,1,1],[0,1,0],[1,0,1]], CRO=2, Col=6.\n    *   If C is Blue (1): Pattern=[[1,0,1],[1,1,1],[1,0,1]], CRO=1, Col=14.\n9.  Calculate the starting row for placing the shape: `start_row = R - CRO`.\n10. Draw the selected shape pattern onto the output grid. Place the top-left of the pattern at `(start_row, Col)`. Use the anchor color (C) for pixels corresponding to '1' in the pattern definition, leaving pixels corresponding to '0' as background. Ensure drawing stays within the grid boundaries.\n11. Return the completed output grid.\n\"\"\"\n\n\ndef _draw_border(grid: np.ndarray, border_color: int):\n    \"\"\"Draws a border onto the grid.\"\"\"\n    height, width = grid.shape\n    if height > 0 and width > 0:\n        grid[0, :] = border_color\n        if height > 1:\n            grid[-1, :] = border_color\n        grid[:, 0] = border_color\n        if width > 1:\n            grid[:, -1] = border_color\n\ndef _find_anchor(input_np: np.ndarray, border_color: int) -> Optional[Tuple[int, int]]:\n    \"\"\"Finds the anchor color (C) and row (R).\"\"\"\n    height, width = input_np.shape\n    background_color = 0\n\n    # Need at least 3 rows and 19 columns to have anchors at (r, 1) and (r, 18) with r > 0\n    if height < 3 or width < 19:\n        return None\n\n    for r in range(1, height - 1):\n        pixel1 = input_np[r, 1]\n        pixel18 = input_np[r, 18]\n\n        # Check if pixels match, are not background, and not border color\n        if pixel1 == pixel18 and pixel1 != background_color and pixel1 != border_color:\n            return pixel1, r  # Return anchor_color (C), anchor_row (R)\n\n    return None # Anchors not found\n\ndef _draw_horizontal_line(grid: np.ndarray, row: int, start_col: int, end_col: int, color: int):\n    \"\"\"Draws a horizontal line on the grid.\"\"\"\n    height, width = grid.shape\n    if 0 <= row < height:\n        for c in range(start_col, end_col + 1):\n            if 0 <= c < width:\n                grid[row, c] = color\n\ndef _draw_shape(grid: np.ndarray, shape_pattern: np.ndarray, top_row: int, left_col: int, color: int):\n    \"\"\"Draws the shape pattern onto the grid.\"\"\"\n    height, width = grid.shape\n    shape_height, shape_width = shape_pattern.shape\n\n    for r_idx in range(shape_height):\n        for c_idx in range(shape_width):\n            # Check if the pixel in the shape pattern should be drawn (represented by 1)\n            if shape_pattern[r_idx, c_idx] == 1:\n                # Calculate the target coordinates in the output grid\n                output_row = top_row + r_idx\n                output_col = left_col + c_idx\n\n                # Check bounds before drawing\n                if 0 <= output_row < height and 0 <= output_col < width:\n                    grid[output_row, output_col] = color\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule: identifies border and anchor pixels,\n    then draws a border, a horizontal line, and a specific H-shape in the\n    output grid based on the anchor pixel properties.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0\n\n    # Handle empty input case\n    if height == 0 or width == 0:\n        return input_grid\n\n    # 3. Initialize output_grid with background color\n    output_np = np.full_like(input_np, background_color)\n\n    # 2. Identify border color\n    border_color = input_np[0, 0]\n\n    # 4. Draw the border onto the output grid\n    _draw_border(output_np, border_color)\n\n    # 5. Find anchor pixels (color C, row R)\n    anchor_info = _find_anchor(input_np, border_color)\n\n    # 6. If no anchors found, return the grid with just the border\n    if anchor_info is None:\n        return output_np.tolist()\n\n    anchor_color, anchor_row = anchor_info\n\n    # 7. Draw the horizontal line\n    _draw_horizontal_line(output_np, anchor_row, 1, 18, anchor_color)\n\n    # 8. Define H-shapes, offsets, and start columns based on anchor color\n    # Using 1 for shape pixels, 0 for background\n    shape_definitions = {\n        7: {'shape': np.array([[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]]), 'offset': 2, 'col': 13}, # Orange\n        6: {'shape': np.array([[1,1,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,1,1]]), 'offset': 2, 'col': 2}, # Magenta\n        2: {'shape': np.array([[1,0,1],[0,1,0],[1,1,1],[0,1,0],[1,0,1]]), 'offset': 2, 'col': 6}, # Red\n        1: {'shape': np.array([[1,0,1],[1,1,1],[1,0,1]]),             'offset': 1, 'col': 14}  # Blue\n    }\n\n    # Check if a shape is defined for the found anchor color\n    if anchor_color not in shape_definitions:\n        # Return grid with border and line if shape unknown (shouldn't happen based on examples)\n        return output_np.tolist()\n\n    # Get the definition for the specific anchor color\n    selected_shape_info = shape_definitions[anchor_color]\n    shape_pattern = selected_shape_info['shape']\n    center_row_offset = selected_shape_info['offset']\n    start_col = selected_shape_info['col']\n\n    # 9. Calculate the starting row for the shape\n    start_row = anchor_row - center_row_offset\n\n    # 10. Draw the selected shape onto the output grid\n    _draw_shape(output_np, shape_pattern, start_row, start_col, anchor_color)\n\n    # 11. Convert back to list of lists for the required output format\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15457,
    "candidates_token_count": 2191,
    "total_token_count": 17648,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.209695,
  "retries": null
}