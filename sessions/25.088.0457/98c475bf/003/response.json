{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the color (B) of the single-pixel border frame in the input grid.\n2. Identify the pair of identical, non-border, non-background pixels located at columns 1 and 18 (0-based index) on the same row (R). Record their color (C) and row (R). These are the 'anchor' pixels.\n3. Create a new output grid of the same dimensions as the input, initially filled with the background color (white, 0).\n4. Draw the border onto the output grid using the identified border color B.\n5. Select the specific H-like output shape pattern, its height (H), its center row offset (CRO), and its starting column (Col) based *only* on the anchor pixel color (C):\n    * If C is Orange (7): Use the 5x3 H shape [[7,0,7],[7,0,7],[7,7,7],[7,0,7],[7,0,7]], H=5, CRO=2, Col=13.\n    * If C is Magenta (6): Use the 6x3 H shape [[6,6,6],[6,0,6],[6,6,6],[6,0,6],[6,0,6],[6,6,6]], H=6, CRO=2, Col=2.\n    * If C is Red (2): Use the 5x3 H shape [[2,0,2],[0,2,0],[2,2,2],[0,2,0],[2,0,2]], H=5, CRO=2, Col=6.\n    * If C is Blue (1): Use the 3x3 H shape [[1,0,1],[1,1,1],[1,0,1]], H=3, CRO=1, Col=14.\n6. Calculate the starting row for placing the shape in the output grid: start_row = R - CRO.\n7. Draw the selected shape onto the output grid. The top-left corner of the shape pattern is placed at (start_row, start_col). Use the anchor color C for the non-background pixels of the shape pattern when drawing.\n\"\"\"\n\nimport numpy as np\nfrom typing import List\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies border and anchor pixels, then draws a specific H-shaped pattern\n    in the output grid based on the anchor pixels' color and row.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    background_color = 0 # White\n\n    # 3. Initialize output_grid with background color\n    output_np = np.full_like(input_np, background_color)\n\n    # 1. Identify border color (assuming top-left is border)\n    # Also handles edge case where grid might be 1x1\n    if height > 0 and width > 0:\n        border_color = input_np[0, 0]\n    else:\n        return input_grid # Return empty/invalid grid as is\n\n    # 4. Draw the border onto the output grid\n    if height > 1 and width > 1:\n        output_np[0, :] = border_color\n        output_np[-1, :] = border_color\n        output_np[:, 0] = border_color\n        output_np[:, -1] = border_color\n    elif height == 1 and width > 0:\n         output_np[0, :] = border_color\n    elif width == 1 and height > 0:\n        output_np[:, 0] = border_color\n    # If 1x1, the full_like already handled it, or the checks above did.\n\n    # 2. Identify anchor pixels (color C, row R)\n    anchor_color = -1\n    anchor_row = -1\n    # Iterate through rows (excluding borders)\n    # Ensure there are non-border rows and columns 1 and 18 exist\n    if height > 2 and width > 18: # Need at least row 1, and col 1 and 18\n        for r in range(1, height - 1):\n            # Check columns 1 and 18 (0-based index)\n            pixel1 = input_np[r, 1]\n            pixel18 = input_np[r, 18]\n            # Check if they match, are not background, and not border\n            if pixel1 == pixel18 and pixel1 != background_color and pixel1 != border_color:\n                anchor_color = pixel1\n                anchor_row = r\n                break # Found the anchors\n\n    # If no anchors found, return the grid with just the border\n    if anchor_color == -1:\n        # This might be expected if input doesn't conform\n        # print(\"Warning: Anchor pixels not found or grid too small!\")\n        return output_np.tolist()\n\n    # 5. Define H-shapes, offsets, and start columns based on anchor color\n    # Note: Shape patterns themselves don't need the color, only the structure.\n    # We use the anchor_color C when drawing.\n    shape_definitions = {\n        7: {'shape': np.array([[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]]), 'offset': 2, 'col': 13}, # Orange\n        6: {'shape': np.array([[1,1,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,1,1]]), 'offset': 2, 'col': 2}, # Magenta\n        2: {'shape': np.array([[1,0,1],[0,1,0],[1,1,1],[0,1,0],[1,0,1]]), 'offset': 2, 'col': 6}, # Red\n        1: {'shape': np.array([[1,0,1],[1,1,1],[1,0,1]]),             'offset': 1, 'col': 14}  # Blue\n    }\n\n    # Check if a shape is defined for the found anchor color\n    if anchor_color not in shape_definitions:\n        # print(f\"Warning: No shape defined for anchor color {anchor_color}\")\n        return output_np.tolist() # Return grid with just border\n\n    # Get the definition for the specific anchor color\n    selected_shape_info = shape_definitions[anchor_color]\n    shape_pattern = selected_shape_info['shape']\n    center_row_offset = selected_shape_info['offset']\n    start_col = selected_shape_info['col']\n    shape_height, shape_width = shape_pattern.shape\n\n    # 6. Calculate the starting row for the shape\n    start_row = anchor_row - center_row_offset\n\n    # 7. Draw the selected shape onto the output grid\n    for r_idx in range(shape_height):\n        for c_idx in range(shape_width):\n            # Check if the pixel in the shape pattern is non-background (represented by 1)\n            if shape_pattern[r_idx, c_idx] != background_color: # Using 0 for background in pattern too\n                # Calculate the target coordinates in the output grid\n                output_row = start_row + r_idx\n                output_col = start_col + c_idx\n\n                # Check bounds before drawing to avoid errors\n                if 0 <= output_row < height and 0 <= output_col < width:\n                    # Draw using the ANCHOR color\n                    output_np[output_row, output_col] = anchor_color\n\n    # Convert back to list of lists for the required output format\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12698,
    "candidates_token_count": 1839,
    "total_token_count": 14537,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.756511,
  "retries": null
}