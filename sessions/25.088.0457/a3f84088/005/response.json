{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Regions:** Analyze the input grid to distinguish three types of pixels:\n    *   The **frame**: Pixels with gray (5) color.\n    *   The **exterior**: White (0) pixels that can reach the border of the grid through a path of only white pixels. These are identified using a Breadth-First Search (BFS) starting from all border white pixels.\n    *   The **interior**: White (0) pixels that are *not* part of the exterior (i.e., they are enclosed by the frame).\n2.  **Calculate Interior Distances:** Compute the minimum Manhattan distance (`d`) for each *interior* white pixel to the nearest gray (5) frame pixel. This is done using a BFS starting simultaneously from all frame pixels. The BFS only propagates through interior white pixels.\n3.  **Determine Fill Colors:** For each *interior* white pixel, determine its output color based on its calculated distance `d` using the following cyclical pattern (modulo 4):\n    *   If `d % 4 == 1`, set color to red (2).\n    *   If `d % 4 == 2`, set color to gray (5).\n    *   If `d % 4 == 3`, set color to white (0).\n    *   If `d % 4 == 0`, set color to white (0).\n4.  **Construct Output Grid:** Create the output grid. Initialize it as a copy of the input grid. Then, update the color of each *interior* white pixel according to the color determined in step 3. Leave the gray frame pixels and the exterior white pixels unchanged.\n\"\"\"\n\ndef _identify_exterior_pixels(grid):\n    \"\"\"\n    Identifies white (0) pixels connected to the grid border using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        set: A set of (row, col) tuples representing exterior white pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    exterior_pixels = set()\n    q = deque()\n\n    # Add border white pixels (color 0) to the queue and the set\n    for r in range(rows):\n        if grid[r, 0] == 0 and (r, 0) not in exterior_pixels:\n            q.append((r, 0))\n            exterior_pixels.add((r, 0))\n        # Check last column only if it exists and is different from the first\n        if cols > 1 and grid[r, cols - 1] == 0 and (r, cols - 1) not in exterior_pixels:\n            q.append((r, cols - 1))\n            exterior_pixels.add((r, cols - 1))\n            \n    for c in range(cols): # Check full top/bottom rows\n        if grid[0, c] == 0 and (0, c) not in exterior_pixels:\n            q.append((0, c))\n            exterior_pixels.add((0, c))\n        # Check last row only if it exists and is different from the first\n        if rows > 1 and grid[rows - 1, c] == 0 and (rows - 1, c) not in exterior_pixels:\n            q.append((rows - 1, c))\n            exterior_pixels.add((rows - 1, c))\n\n    # Perform BFS to find all reachable white pixels from the border\n    while q:\n        r, c = q.popleft()\n        # Check neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if neighbor is white, and if not already identified as exterior\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0 and (nr, nc) not in exterior_pixels:\n                exterior_pixels.add((nr, nc))\n                q.append((nr, nc))\n                \n    return exterior_pixels\n\ndef _get_fill_color(distance):\n    \"\"\"\n    Applies the coloring rule based on Manhattan distance to the frame.\n\n    Args:\n        distance (float): The Manhattan distance.\n\n    Returns:\n        int: The color value (0-9) for the pixel.\n    \"\"\"\n    # Ensure distance is treated as an integer for modulo\n    dist_int = int(distance)\n    \n    # Frame pixels (dist 0) or unreachable pixels (dist inf) retain original color\n    if dist_int <= 0 or distance == np.inf:\n        # This function should only be called for interior pixels with finite dist > 0.\n        # Return white as a fallback if called inappropriately.\n        return 0 \n\n    remainder = dist_int % 4\n    if remainder == 1:\n        return 2 # red\n    elif remainder == 2:\n        return 5 # gray\n    # elif remainder == 3:\n    #     return 0 # white\n    # elif remainder == 0: # distance is a multiple of 4\n    #     return 0 # white\n    else: # remainder is 0 or 3\n        return 0 # white\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the interior white region enclosed by a gray frame based on the \n    Manhattan distance to the frame boundary, using a cyclical color pattern:\n    dist % 4 = 1 -> red(2)\n    dist % 4 = 2 -> gray(5)\n    dist % 4 = 3 -> white(0)\n    dist % 4 = 0 -> white(0)\n    Exterior white pixels remain unchanged.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n\n    # 1. Identify Regions: Exterior White, Interior White, Frame\n    exterior_white_pixels = _identify_exterior_pixels(input_grid_np)\n    \n    interior_white_pixels = set()\n    frame_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid_np[r, c] == 0 and (r, c) not in exterior_white_pixels:\n                interior_white_pixels.add((r, c))\n            elif input_grid_np[r, c] == 5:\n                frame_pixels.append((r,c))\n\n    # If there are no interior pixels to color, return the original grid\n    if not interior_white_pixels:\n        return output_grid.tolist()\n        \n    # 2. Calculate Interior Distances using BFS from frame pixels\n    # Initialize distances grid with infinity, except for frame pixels (distance 0)\n    distances = np.full(input_grid_np.shape, np.inf)\n    queue = deque()\n\n    for r, c in frame_pixels:\n        distances[r, c] = 0\n        # Add frame pixels adjacent to interior white pixels to the queue to start BFS\n        # This optimizes BFS slightly by not starting from frame pixels fully surrounded by other frame pixels\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n             nr, nc = r + dr, c + dc\n             if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in interior_white_pixels:\n                 # Check if this neighbor needs adding (first time seeing it from a frame pixel)\n                 if distances[nr, nc] == np.inf:\n                     distances[nr, nc] = 1 # Distance is 1 from the frame\n                     queue.append(((nr, nc), 1)) # Add to queue with distance 1\n                 # Optimization: No need to add the frame pixel itself to the main BFS queue if it has interior neighbors\n                 # but we need to make sure all relevant interior pixels get queued if they touch the frame.\n                 # The code above handles this: if an interior pixel (nr, nc) touches frame pixel (r, c),\n                 # it will be added to the queue with distance 1.\n\n    # If the queue is empty after initialization (e.g., frame completely surrounds nothing, or no interior pixels)\n    # we might have missed frame pixels that were not adjacent to interior pixels. Re-initialize queue fully if needed.\n    # However, the BFS below starts from the already queued neighbors (dist 1).\n    # Let's refine the initialization to ensure all frame boundaries touching interior start the BFS correctly.\n    # The previous logic was sufficient, but let's stick to a simpler BFS start: initialize all frame pixels.\n    distances = np.full(input_grid_np.shape, np.inf)\n    queue = deque()\n    for r, c in frame_pixels:\n        distances[r, c] = 0\n        queue.append(((r, c), 0)) # Start BFS from all frame pixels\n\n    processed_for_dist_calc = set(frame_pixels) # Keep track of pixels whose distances are finalized\n\n    # Perform BFS, propagating distances through *interior* white pixels\n    while queue:\n        (r, c), dist = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds and if it's an *interior* white pixel\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in interior_white_pixels:\n                 # If this interior pixel hasn't been reached yet (distance is inf)\n                 if distances[nr, nc] == np.inf:\n                     new_dist = dist + 1\n                     distances[nr, nc] = new_dist\n                     queue.append(((nr, nc), new_dist))\n                     processed_for_dist_calc.add((nr,nc)) # Mark as processed for distance calc\n\n    # 3. & 4. Determine Fill Colors and Construct Output Grid\n    # Iterate through only the identified interior white pixels\n    for r, c in interior_white_pixels:\n        distance = distances[r,c]\n        # Check if the pixel was reachable from the frame (distance is finite and > 0)\n        if distance != np.inf and distance > 0:\n             # Apply the coloring rule based on the calculated distance\n             fill_color = _get_fill_color(distance)\n             output_grid[r, c] = fill_color\n        # else: \n             # If an interior pixel is unreachable (e.g., isolated white spot inside) \n             # or has dist 0 (shouldn't happen for interior pixels), leave it white (0).\n             # It's already initialized as white from the copy, so no action needed.\n             pass \n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8041,
    "candidates_token_count": 2576,
    "total_token_count": 10617,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 52.891617,
  "retries": null
}