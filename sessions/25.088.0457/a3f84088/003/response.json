{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  **Identify Regions:** Analyze the input grid to distinguish three types of pixels:\n    *   The **frame**: Pixels with gray (5) color.\n    *   The **exterior**: White (0) pixels that can reach the border of the grid through a path of only white pixels. These are identified using a Breadth-First Search (BFS) starting from all border white pixels.\n    *   The **interior**: White (0) pixels that are *not* part of the exterior (i.e., they are enclosed by the frame).\n2.  **Calculate Interior Distances:** Compute the minimum Manhattan distance (`d`) for each *interior* white pixel to the nearest gray (5) frame pixel. This is done using a BFS starting simultaneously from all frame pixels. The BFS only propagates through interior white pixels.\n3.  **Determine Fill Colors:** For each *interior* white pixel, determine its output color based on its calculated distance `d` using the following cyclical pattern (modulo 4):\n    *   If `d % 4 == 1`, set color to red (2).\n    *   If `d % 4 == 2`, set color to gray (5).\n    *   If `d % 4 == 3`, set color to white (0).\n    *   If `d % 4 == 0`, set color to gray (5).\n4.  **Construct Output Grid:** Create the output grid. Initialize it as a copy of the input grid. Then, update the color of each *interior* white pixel according to the color determined in step 3. Leave the gray frame pixels and the exterior white pixels unchanged.\n\"\"\"\n\ndef _identify_exterior_pixels(grid):\n    \"\"\"Identifies white (0) pixels connected to the border using BFS.\"\"\"\n    rows, cols = grid.shape\n    exterior_pixels = set()\n    q = deque()\n\n    # Add border white pixels (color 0) to the queue and the set\n    for r in range(rows):\n        if grid[r, 0] == 0 and (r, 0) not in exterior_pixels:\n            q.append((r, 0))\n            exterior_pixels.add((r, 0))\n        if cols > 0 and grid[r, cols - 1] == 0 and (r, cols - 1) not in exterior_pixels:\n            q.append((r, cols - 1))\n            exterior_pixels.add((r, cols - 1))\n            \n    for c in range(cols): # Check full top/bottom rows, including corners already checked\n        if grid[0, c] == 0 and (0, c) not in exterior_pixels:\n            q.append((0, c))\n            exterior_pixels.add((0, c))\n        if rows > 0 and grid[rows - 1, c] == 0 and (rows - 1, c) not in exterior_pixels:\n            q.append((rows - 1, c))\n            exterior_pixels.add((rows - 1, c))\n\n    # Perform BFS to find all reachable white pixels from the border\n    while q:\n        r, c = q.popleft()\n        # Check neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, if neighbor is white, and if not already identified as exterior\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 0 and (nr, nc) not in exterior_pixels:\n                exterior_pixels.add((nr, nc))\n                q.append((nr, nc))\n                \n    return exterior_pixels\n\ndef _get_fill_color(distance):\n    \"\"\"Applies the coloring rule based on Manhattan distance.\"\"\"\n    # Ensure distance is treated as an integer for modulo\n    dist_int = int(distance)\n    \n    # Pixels with distance 0 (frame pixels) or infinity (unreachable) should not be colored by this\n    if dist_int <= 0 or distance == np.inf:\n        # This case should ideally not be hit for interior pixels after BFS,\n        # but return original color (white) as a fallback.\n        return 0 \n\n    remainder = dist_int % 4\n    if remainder == 1:\n        return 2 # red\n    elif remainder == 2:\n        return 5 # gray\n    elif remainder == 3:\n        return 0 # white\n    elif remainder == 0: # distance is a multiple of 4\n        return 5 # gray\n\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the interior white region of a gray frame based on the Manhattan \n    distance to the frame boundary, using a cyclical color pattern. Exterior \n    white pixels remain unchanged.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n\n    # 1. Identify Regions\n    exterior_white_pixels = _identify_exterior_pixels(input_grid_np)\n    \n    interior_white_pixels = set()\n    frame_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid_np[r, c] == 0 and (r, c) not in exterior_white_pixels:\n                interior_white_pixels.add((r, c))\n            elif input_grid_np[r, c] == 5:\n                frame_pixels.append((r,c))\n\n    # If there are no interior pixels to color, return the original grid\n    if not interior_white_pixels:\n        return output_grid.tolist()\n        \n    # 2. Calculate Interior Distances\n    distances = np.full(input_grid_np.shape, np.inf)\n    queue = deque()\n\n    # Initialize queue with frame pixels (distance 0)\n    for r, c in frame_pixels:\n        distances[r, c] = 0\n        queue.append(((r, c), 0))\n\n    # Perform BFS, only propagating through interior white pixels\n    while queue:\n        (r, c), dist = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds, if it's an *interior* white pixel, and hasn't been reached yet\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in interior_white_pixels and distances[nr, nc] == np.inf:\n                 distances[nr, nc] = dist + 1\n                 queue.append(((nr, nc), dist + 1))\n\n    # 3. & 4. Determine Fill Colors and Construct Output Grid\n    # Iterate through only the interior white pixels identified earlier\n    for r, c in interior_white_pixels:\n        distance = distances[r,c]\n        # Check if the pixel was reachable from the frame (distance is not infinity)\n        if distance != np.inf and distance > 0:\n             # Apply the coloring rule based on the calculated distance\n             fill_color = _get_fill_color(distance)\n             output_grid[r, c] = fill_color\n        # else: # If an interior pixel is unreachable (shouldn't happen with closed frame), leave it white (0)\n             # output_grid[r,c] = 0 # Already initialized this way\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19971,
    "candidates_token_count": 1793,
    "total_token_count": 21764,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.910843,
  "retries": null
}