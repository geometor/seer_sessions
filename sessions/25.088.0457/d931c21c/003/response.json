{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify regions of white (0) pixels that are completely enclosed by blue (1) pixels. A white pixel is considered enclosed if it cannot reach the border of the grid by moving only through non-blue pixels (using 8-way connectivity).\n2.  Fill these enclosed white (0) pixels with green (3).\n3.  Identify the blue (1) pixels that form the immediate boundary of these enclosed (now green) regions. These are the 'enclosing' blue pixels.\n4.  Identify white (0) pixels that are *not* enclosed (i.e., they can reach the border without crossing blue pixels).\n5.  Color these non-enclosed white (0) pixels red (2) if they are adjacent (including diagonally, 8-connectivity) to any of the 'enclosing' blue pixels identified in step 3.\n6.  All other pixels (blue pixels, other colored pixels, and non-adjacent exterior white pixels) remain unchanged. Blue structures that do not enclose any white pixels are effectively ignored.\n\nImplementation Details:\n\n-   Use a flood fill algorithm starting from all non-blue border cells. The flood fill can traverse any non-blue cell. Mark all reachable cells as 'exterior'.\n-   Any white (0) pixel *not* marked as 'exterior' is considered 'interior' (enclosed).\n-   Change interior white pixels to green (3) in the output grid.\n-   Identify blue (1) pixels in the input grid that are adjacent (8-connectivity) to at least one *interior* white pixel (which are now green in the output grid). These are the 'enclosing_blue_coords'.\n-   Iterate through the original white (0) pixels. If a white pixel was marked as 'exterior' during the flood fill *and* it is adjacent (8-connectivity) to any coordinate in 'enclosing_blue_coords', change its color to red (2) in the output grid.\n\"\"\"\n\n\ndef get_neighbors(r, c, H, W, connectivity=8):\n    \"\"\" Helper function to get valid neighbors within grid bounds. \"\"\"\n    neighbors = []\n    if connectivity == 8:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    neighbors.append((nr, nc))\n    elif connectivity == 4:\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: fills enclosed areas with green (3)\n    and outlines the exterior boundary of the enclosure with red (2).\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    blue_color = 1\n    white_color = 0\n    red_color = 2\n    green_color = 3\n\n    # --- Step 1: Identify Exterior Region (non-blue reachable from border) ---\n    is_exterior = np.zeros_like(input_grid, dtype=bool)\n    queue = deque()\n\n    # Start flood fill from non-blue border cells\n    for r in range(H):\n        for c in range(W):\n            if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n                if input_grid[r, c] != blue_color and not is_exterior[r, c]:\n                    is_exterior[r, c] = True\n                    queue.append((r, c))\n\n    # Perform the flood fill through non-blue cells\n    while queue:\n        curr_r, curr_c = queue.popleft()\n        for nr, nc in get_neighbors(curr_r, curr_c, H, W, connectivity=8): # Use 8-way for region definition\n            if input_grid[nr, nc] != blue_color and not is_exterior[nr, nc]:\n                is_exterior[nr, nc] = True\n                queue.append((nr, nc))\n\n    # --- Step 2 & 3: Identify and Fill Interior White Pixels ---\n    interior_white_coords = set()\n    all_white_coords = set()\n    blue_coords = set()\n\n    for r in range(H):\n        for c in range(W):\n            if input_grid[r,c] == white_color:\n                all_white_coords.add((r,c))\n                if not is_exterior[r, c]:\n                    # This white pixel is enclosed\n                    interior_white_coords.add((r, c))\n                    output_grid[r, c] = green_color # Fill with green\n            elif input_grid[r,c] == blue_color:\n                blue_coords.add((r,c))\n\n    # --- Step 4: Identify Enclosing Blue Pixels ---\n    # Blue pixels adjacent (8-way) to any interior white pixel\n    enclosing_blue_coords = set()\n    if interior_white_coords: # Only proceed if there were enclosed regions\n        for br, bc in blue_coords:\n            is_enclosing = False\n            # Check neighbors for interior white pixels (which are now green in output_grid)\n            for nr, nc in get_neighbors(br, bc, H, W, connectivity=8):\n                if output_grid[nr, nc] == green_color and (nr, nc) in interior_white_coords:\n                    is_enclosing = True\n                    break\n            if is_enclosing:\n                enclosing_blue_coords.add((br, bc))\n\n    # --- Step 5 & 6: Color Exterior White Pixels Adjacent to Enclosing Blue ---\n    exterior_white_coords = all_white_coords - interior_white_coords\n    for r, c in exterior_white_coords:\n        is_adjacent_to_enclosing_blue = False\n        # Check neighbors (8-way) for enclosing blue pixels\n        for nr, nc in get_neighbors(r, c, H, W, connectivity=8):\n            if (nr, nc) in enclosing_blue_coords:\n                 is_adjacent_to_enclosing_blue = True\n                 break\n        if is_adjacent_to_enclosing_blue:\n            output_grid[r, c] = red_color # Color exterior white red\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7320,
    "candidates_token_count": 1572,
    "total_token_count": 8892,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 109.481734,
  "retries": null
}