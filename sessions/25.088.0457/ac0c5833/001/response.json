{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a specific \"source\" red object pattern based on its adjacency to a unique, isolated yellow pixel.\nIdentifies all occurrences of a horizontal \"target\" pattern (yellow-white-yellow: 4-0-4).\nCopies the source red object pattern and places it onto the output grid relative to each target pattern found.\nThe placement rule is: the top-left corner of the source object's bounding box is placed 2 rows below and 1 column to the right \nof the first yellow pixel of the target pattern. The copied pixels overwrite existing pixels.\nPixels not part of the source object or target patterns remain unchanged.\n\"\"\"\n\ndef find_connected_components(grid, color):\n    \"\"\"Finds all connected components of a given color in the grid.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    component.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if component:\n                    components.append(component)\n    return components\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box of a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef get_relative_pixels(pixels, min_r, min_c):\n    \"\"\"Converts absolute pixel coordinates to coordinates relative to a top-left corner.\"\"\"\n    return set((r - min_r, c - min_c) for r, c in pixels)\n\ndef get_adjacent_coords(r, c, height, width, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given cell.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: copy a specific red pattern identified by an adjacent yellow pixel\n    to locations marked by a yellow-white-yellow pattern.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    red_color = 2\n    yellow_color = 4\n    white_color = 0\n\n    # 1. Find all red objects and map pixels to their objects\n    red_objects = find_connected_components(input_grid, red_color)\n    if not red_objects:\n        return output_grid # No red objects, nothing to copy\n\n    pixel_to_red_object = {\n        pixel: obj_set for obj_set in red_objects for pixel in obj_set\n    }\n\n    # 2. Identify potential \"isolated\" yellow pixels (not part of the 4-0-4 target)\n    isolated_yellows = []\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] == yellow_color:\n                is_target_part = False\n                # Check if it's the first '4' in '4 0 4'\n                if c <= width - 3 and input_grid[r, c+1] == white_color and input_grid[r, c+2] == yellow_color:\n                    is_target_part = True\n                # Check if it's the second '4' in '4 0 4'\n                if c >= 2 and input_grid[r, c-1] == white_color and input_grid[r, c-2] == yellow_color:\n                    is_target_part = True\n                \n                if not is_target_part:\n                    isolated_yellows.append((r, c))\n\n    # 3. Identify the source red object\n    # It's the one adjacent (including diagonals) to exactly one isolated yellow pixel\n    source_object_pixels = None\n    source_object_found = False\n    \n    # Check each isolated yellow pixel for unique adjacency to a red object\n    for yr, yc in isolated_yellows:\n        adjacent_red_object_sets = set() # Store hashable representations of adjacent red objects\n        neighbors = get_adjacent_coords(yr, yc, height, width, include_diagonal=True)\n\n        for nr, nc in neighbors:\n            if input_grid[nr, nc] == red_color:\n                if (nr, nc) in pixel_to_red_object:\n                    obj_set = pixel_to_red_object[(nr, nc)]\n                    # Convert set to a hashable type (tuple of sorted coords)\n                    adjacent_red_object_sets.add(tuple(sorted(list(obj_set))))\n\n        # If this yellow pixel is adjacent to exactly one unique red object\n        if len(adjacent_red_object_sets) == 1:\n             # Check if this red object is adjacent to *only* this yellow pixel among all isolated yellows\n             candidate_object_tuple = list(adjacent_red_object_sets)[0]\n             candidate_object_pixels = set(candidate_object_tuple)\n             \n             adjacent_isolated_yellow_count = 0\n             all_adj_coords = set()\n             for pr, pc in candidate_object_pixels:\n                 all_adj_coords.update(get_adjacent_coords(pr, pc, height, width, include_diagonal=True))\n                 \n             for ar, ac in all_adj_coords:\n                 if (ar, ac) in isolated_yellows:\n                     adjacent_isolated_yellow_count += 1\n                     \n             if adjacent_isolated_yellow_count == 1:\n                 source_object_pixels = candidate_object_pixels\n                 source_object_found = True\n                 break # Found the source object\n\n    if not source_object_found:\n        # Fallback or error handling: Maybe check red objects directly\n        # Find red object adjacent to exactly one isolated yellow\n        for obj_pixels in red_objects:\n             adjacent_yellows_count = 0\n             all_adj_coords = set()\n             for pr, pc in obj_pixels:\n                 all_adj_coords.update(get_adjacent_coords(pr, pc, height, width, include_diagonal=True))\n             \n             num_adjacent_isolated_yellows = 0\n             for ar, ac in all_adj_coords:\n                 # Need to check if (ar,ac) is in the list of *isolated* yellows\n                 if (ar,ac) in isolated_yellows:\n                      num_adjacent_isolated_yellows += 1\n\n             if num_adjacent_isolated_yellows == 1:\n                 source_object_pixels = obj_pixels\n                 source_object_found = True\n                 break # Found source with fallback\n\n\n    if not source_object_found or source_object_pixels is None:\n       # print(\"Warning: Source red object could not be definitively identified.\")\n        return output_grid # Return original if source cannot be found\n\n    # 4. Get the relative shape of the source object\n    src_bb = get_bounding_box(source_object_pixels)\n    if src_bb is None:\n        return output_grid # Should not happen if source_object_found is True\n        \n    src_min_r, src_min_c, _, _ = src_bb\n    relative_shape = get_relative_pixels(source_object_pixels, src_min_r, src_min_c)\n\n    # 5. Find all target pattern locations (top-left of the first '4')\n    target_coords = []\n    for r in range(height):\n        for c in range(width - 2): # Ensure space for pattern '4 0 4'\n            if (input_grid[r, c] == yellow_color and\n                input_grid[r, c+1] == white_color and\n                input_grid[r, c+2] == yellow_color):\n                target_coords.append((r, c))\n\n    # 6. Place copies of the source object at target locations\n    for r_target, c_target in target_coords:\n        # Calculate the anchor point for the copy (top-left of the placed object)\n        # Offset is +2 rows, +1 column from the *first* yellow pixel (r_target, c_target)\n        anchor_r = r_target + 2\n        anchor_c = c_target + 1\n\n        # Place the object relative to the anchor point\n        for dr, dc in relative_shape:\n            final_r = anchor_r + dr\n            final_c = anchor_c + dc\n\n            # Check bounds before writing to the output grid\n            if 0 <= final_r < height and 0 <= final_c < width:\n                output_grid[final_r, final_c] = red_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11173,
    "candidates_token_count": 2360,
    "total_token_count": 13533,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 129.739582,
  "retries": null
}