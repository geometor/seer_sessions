{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies contiguous shapes of a single non-white color in the input grid.\nFor each shape, determines if it is \"closed\" by checking if it encloses an interior region \n(pixels not reachable from the grid boundary without crossing the shape).\n\nIf a shape is closed:\n1. Its boundary pixels are copied to the output grid (initially all white) using the boundary color.\n2. The interior region is identified.\n3. \"Marker\" pixels (non-white, non-boundary color) within the interior region are collected from the input grid.\n4. The number of *distinct* marker colors is counted.\n5. If there are two or more distinct marker colors:\n   a. The frequency of each marker color is counted.\n   b. The most frequent marker color is determined.\n   c. If there is a tie in frequency, the marker color with the *lowest* numerical value is chosen. This becomes the \"fill color\".\n   d. All pixels within the interior region are set to the fill color in the output grid.\n6. If a closed shape has fewer than two distinct marker colors in its interior, the interior remains white (0) in the output grid, and only the boundary is drawn.\n\nPixels belonging to shapes that are not closed, or pixels not part of any closed shape's boundary or filled interior, remain white (0) in the final output grid.\n\"\"\"\n\ndef find_shapes_and_boundaries(grid):\n    \"\"\"\n    Finds all distinct contiguous shapes of non-white colors.\n    Returns a list of tuples, where each tuple contains:\n    (set of boundary pixel coordinates, boundary_color)\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(H):\n        for c in range(W):\n            # If it's a non-white pixel and not yet visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                boundary_color = grid[r, c]\n                boundary_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                boundary_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < H and 0 <= nc < W and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == boundary_color:\n                            visited[nr, nc] = True\n                            boundary_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Ensure shape has pixels before adding\n                if boundary_pixels: \n                     shapes.append((boundary_pixels, boundary_color))\n    return shapes\n\ndef find_reachable(grid_shape, starts, impassable_pixels):\n    \"\"\"\n    Finds all pixels reachable from start points without crossing impassable pixels using BFS.\n    grid_shape is a tuple (H, W).\n    starts is a list or set of (r, c) tuples.\n    impassable_pixels is a set of (r, c) tuples.\n    Returns a set of reachable (r, c) tuples.\n    \"\"\"\n    H, W = grid_shape\n    # Filter out start points that are themselves impassable\n    q = deque(p for p in starts if 0 <= p[0] < H and 0 <= p[1] < W and p not in impassable_pixels)\n    reachable = set(q) # Initialize reachable with valid, non-impassable start points\n    \n    # Optimization: Keep track of visited to avoid redundant checks, initialize with reachable\n    visited = np.zeros(grid_shape, dtype=bool)\n    for r, c in reachable:\n        visited[r,c] = True\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds, visited status, and impassable status\n            if 0 <= nr < H and 0 <= nc < W and \\\n               not visited[nr, nc] and \\\n               (nr, nc) not in impassable_pixels:\n                visited[nr, nc] = True\n                reachable.add((nr, nc))\n                q.append((nr, nc))\n    return reachable\n\n\ndef get_interior_region(grid_shape, boundary_pixels):\n    \"\"\"\n    Determines the interior region enclosed by a set of boundary pixels.\n    Returns the set of interior pixels if the boundary forms a closed shape,\n    otherwise returns an empty set.\n    \"\"\"\n    H, W = grid_shape\n    all_pixels = set((r, c) for r in range(H) for c in range(W))\n    potential_interior_exterior = all_pixels - boundary_pixels\n\n    # If no pixels other than the boundary exist, no interior is possible\n    if not potential_interior_exterior:\n        return set()\n\n    # Define starting points for exterior flood fill: all edge points *not* on the boundary\n    edge_starts = set()\n    for r in range(H):\n        if (r, 0) not in boundary_pixels: edge_starts.add((r, 0))\n        if (r, W - 1) not in boundary_pixels: edge_starts.add((r, W - 1))\n    for c in range(1, W - 1): # Avoid adding corners twice\n        if (0, c) not in boundary_pixels: edge_starts.add((0, c))\n        if (H - 1, c) not in boundary_pixels: edge_starts.add((H - 1, c))\n\n    # If there are no valid starting points for the exterior (e.g., boundary touches all edges),\n    # then all non-boundary points *could* be interior. We still need the reachability check.\n    # But if edge_starts is empty AND potential_interior_exterior is not empty, it implies\n    # the boundary perfectly frames the grid, making everything inside potential interior.\n    # The flood fill handles this correctly. If edge_starts is empty because ALL edge points\n    # ARE on the boundary, find_reachable will return an empty set for exterior_pixels\n    # (as no starting points are valid), which is correct.\n\n    # Find all pixels reachable from the edges without crossing the boundary\n    exterior_pixels = find_reachable(grid_shape, edge_starts, boundary_pixels)\n\n    # The interior is whatever potential pixels are left after removing the exterior\n    interior_pixels = potential_interior_exterior - exterior_pixels\n\n    # If interior_pixels is not empty, the shape is considered closed w.r.t the grid boundary\n    # This also implicitly handles cases where a shape might enclose another shape entirely.\n    # The outer shape's interior calculation will correctly identify the inner area.\n    # The inner shape will be processed separately.\n    return interior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on closed shapes and internal marker diversity.\n    \"\"\"\n    H, W = input_grid.shape\n    # Initialize output grid with background color (white/0)\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all distinct shapes (boundaries) and their colors\n    shapes = find_shapes_and_boundaries(input_grid)\n\n    # 2. Process each shape found\n    for boundary_pixels, boundary_color in shapes:\n\n        # 3. Determine if the shape is closed and find its potential interior\n        interior_region_pixels = get_interior_region((H, W), boundary_pixels)\n\n        # 4. If the shape is closed (has an interior)\n        if interior_region_pixels:\n            # a. Copy the boundary pixels to the output grid\n            for r, c in boundary_pixels:\n                if 0 <= r < H and 0 <= c < W: # Bounds check for safety\n                     output_grid[r, c] = boundary_color\n\n            # b. Collect marker colors from the *input* grid within the interior region\n            marker_colors = []\n            for r, c in interior_region_pixels:\n                if 0 <= r < H and 0 <= c < W: # Bounds check for safety\n                    pixel_color = input_grid[r, c]\n                    # A marker is non-white and not the boundary color\n                    if pixel_color != 0 and pixel_color != boundary_color:\n                        marker_colors.append(pixel_color)\n\n            # c. Check the fill condition: at least two *distinct* marker colors\n            distinct_marker_colors = set(marker_colors)\n            \n            fill_color = None # Initialize fill color\n            if len(distinct_marker_colors) >= 2:\n                # d. Condition met: Determine the fill color\n                if marker_colors: # Should be true if distinct_marker_colors >= 2\n                    color_counts = Counter(marker_colors)\n                    # Find the maximum frequency\n                    max_freq = 0\n                    for color in color_counts:\n                        max_freq = max(max_freq, color_counts[color])\n\n                    # Find all colors with max frequency\n                    candidate_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n                    # Tie-breaking: Choose the color with the *lowest* numerical value\n                    fill_color = min(candidate_colors)\n\n            # e. Fill the interior region in the output grid if a fill_color was determined\n            if fill_color is not None:\n                for r, c in interior_region_pixels:\n                     if 0 <= r < H and 0 <= c < W: # Bounds check for safety\n                        output_grid[r, c] = fill_color\n            # Else (fill condition not met or no markers), the interior remains white (0)\n\n    # 5. Unclosed shapes are ignored (never processed in step 4).\n    # 6. Pixels not part of a closed boundary or a filled interior remain white.\n    # 7. Return the completed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9853,
    "candidates_token_count": 2414,
    "total_token_count": 12267,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.525604,
  "retries": null
}