{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies contiguous shapes of a single non-white color in the input grid.\nFor each shape, determines if it is \"closed\" by checking if it encloses an interior region (pixels not reachable from the grid boundary without crossing the shape).\nIf a shape is closed:\n  1. Its boundary pixels are copied to the output grid (initially all white).\n  2. The interior region is identified.\n  3. \"Marker\" pixels (non-white, non-boundary color) within the interior region are collected from the input grid.\n  4. If markers exist, the most frequent marker color is determined (highest numerical value breaks ties). This becomes the \"fill color\".\n  5. All pixels within the interior region (including originally white pixels or marker pixels) are set to the fill color in the output grid.\nPixels belonging to shapes that are not closed, or pixels not part of any closed shape's boundary or filled interior, remain white (0) in the final output grid.\n\"\"\"\n\ndef find_shapes_and_boundaries(grid):\n    \"\"\"\n    Finds all distinct contiguous shapes of non-white colors.\n    Returns a list of tuples, where each tuple contains:\n    (set of boundary pixel coordinates, boundary_color)\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(H):\n        for c in range(W):\n            # If it's a non-white pixel and not yet visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                boundary_color = grid[r, c]\n                boundary_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                boundary_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < H and 0 <= nc < W and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == boundary_color:\n                            visited[nr, nc] = True\n                            boundary_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if boundary_pixels: # Should always be true if we start on non-white\n                     shapes.append((boundary_pixels, boundary_color))\n    return shapes\n\ndef find_reachable(grid_shape, starts, impassable_pixels):\n    \"\"\"\n    Finds all pixels reachable from start points without crossing impassable pixels using BFS.\n    grid_shape is a tuple (H, W).\n    starts is a list or set of (r, c) tuples.\n    impassable_pixels is a set of (r, c) tuples.\n    \"\"\"\n    H, W = grid_shape\n    q = deque(starts)\n    reachable = set(starts)\n    # Optimization: Filter out starts that are impassable\n    q = deque(p for p in starts if p not in impassable_pixels)\n    reachable = set(p for p in starts if p not in impassable_pixels)\n    visited = np.zeros(grid_shape, dtype=bool)\n\n    for r, c in reachable:\n         if 0 <= r < H and 0 <= c < W: # Check bounds just in case start points were invalid\n            visited[r,c] = True\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, visited status, and impassable status\n            if 0 <= nr < H and 0 <= nc < W and \\\n               not visited[nr, nc] and \\\n               (nr, nc) not in impassable_pixels:\n                visited[nr, nc] = True\n                reachable.add((nr, nc))\n                q.append((nr, nc))\n    return reachable\n\n\ndef get_interior_region(grid_shape, boundary_pixels):\n    \"\"\"\n    Determines the interior region enclosed by a set of boundary pixels.\n    Returns the set of interior pixels if the boundary forms a closed shape,\n    otherwise returns an empty set.\n    \"\"\"\n    H, W = grid_shape\n    all_pixels = set((r, c) for r in range(H) for c in range(W))\n    potential_interior_exterior = all_pixels - boundary_pixels\n\n    if not potential_interior_exterior:\n        return set() # No pixels other than boundary, cannot have interior\n\n    # Define starting points for exterior flood fill (all edge points *not* on the boundary)\n    edge_starts = set()\n    for r in range(H):\n        if (r, 0) not in boundary_pixels: edge_starts.add((r, 0))\n        if (r, W - 1) not in boundary_pixels: edge_starts.add((r, W - 1))\n    for c in range(1, W - 1): # Avoid adding corners twice\n        if (0, c) not in boundary_pixels: edge_starts.add((0, c))\n        if (H - 1, c) not in boundary_pixels: edge_starts.add((H - 1, c))\n\n    # Find all pixels reachable from the edges without crossing the boundary\n    exterior_pixels = find_reachable(grid_shape, edge_starts, boundary_pixels)\n\n    # The interior is whatever is left that isn't boundary and isn't exterior\n    interior_pixels = potential_interior_exterior - exterior_pixels\n\n    # If interior_pixels is not empty, the shape is closed\n    return interior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding closed shapes, identifying their interiors,\n    determining a fill color based on the most frequent internal marker (if any),\n    and filling the interior. Only closed shapes' boundaries and filled interiors\n    are drawn onto an initially white output grid.\n    \"\"\"\n    H, W = input_grid.shape\n    # Initialize output grid with background color (white/0)\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all distinct shapes (boundaries) and their colors\n    shapes = find_shapes_and_boundaries(input_grid)\n\n    # 2. Process each shape\n    for boundary_pixels, boundary_color in shapes:\n\n        # 3a. Determine if the shape is closed and find its interior\n        interior_region_pixels = get_interior_region((H, W), boundary_pixels)\n\n        # 3b. If the shape is closed\n        if interior_region_pixels:\n            # i. Copy boundary pixels to output grid\n            for r, c in boundary_pixels:\n                output_grid[r, c] = boundary_color\n\n            # ii. Identify interior region (already done)\n            # iii. Collect marker colors from the *input* grid within the interior region\n            marker_colors = []\n            for r, c in interior_region_pixels:\n                pixel_color = input_grid[r, c]\n                # Marker is non-white and not the boundary color\n                if pixel_color != 0 and pixel_color != boundary_color:\n                    marker_colors.append(pixel_color)\n\n            # iv. Determine fill color if markers exist\n            fill_color = None\n            if marker_colors:\n                color_counts = Counter(marker_colors)\n                max_freq = 0\n                # Find the max frequency\n                # Using .most_common() handles finding max frequency implicitly\n                # It returns list of (element, count) sorted by count descending\n                most_common_pairs = color_counts.most_common()\n                if most_common_pairs:\n                    max_freq = most_common_pairs[0][1]\n\n                    # Find all colors with max frequency\n                    candidate_colors = [color for color, count in most_common_pairs if count == max_freq]\n\n                    # Choose the one with the highest numerical value if tied\n                    fill_color = max(candidate_colors)\n\n            # v. Fill the interior region in the output grid if fill_color determined\n            if fill_color is not None:\n                for r, c in interior_region_pixels:\n                    output_grid[r, c] = fill_color\n            # If no markers were found (fill_color is None), the interior\n            # remains white (0) as initialized in the output grid. This is\n            # different from the previous logic, but matches the refined rule\n            # where only boundary + filled interior are preserved. Example 1's\n            # top-right shape has no markers and its interior becomes white.\n\n    # 4. Pixels of unclosed shapes are implicitly ignored as they are never copied.\n    # 5. Pixels not part of a closed boundary or filled interior remain white.\n    # 6. Return the completed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11062,
    "candidates_token_count": 2115,
    "total_token_count": 13177,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 113.837117,
  "retries": null
}