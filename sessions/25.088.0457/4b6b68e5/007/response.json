{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies contiguous shapes of a single non-white color (boundaries) in the input grid.\nCopies all found boundaries to the output grid.\nThen, for each shape, determines if it encloses an interior region relative to the grid edges.\nAn interior region is defined as the set of pixels not belonging to the boundary itself and not reachable from the grid edges without crossing the boundary.\n\nIf a shape encloses an interior region:\n1. Collect \"marker\" pixels from the *input* grid within this interior region. A marker pixel is any pixel whose color is not white (0) and not the same as the boundary's color.\n2. Count the number of *distinct* marker colors found.\n3. If there are two or more distinct marker colors:\n   a. Count the frequency of each marker color.\n   b. Determine the most frequent marker color.\n   c. If there's a tie for the most frequent color, choose the color with the lowest numerical value among the tied colors. This is the \"fill color\".\n   d. Fill the *entire* identified interior region in the *output* grid with this fill color.\n4. If there are fewer than two distinct marker colors within the enclosed interior region (0 or 1):\n   a. Fill the *entire* identified interior region in the *output* grid with white (0).\n\nPixels not part of any boundary and not part of any filled interior remain white (0).\nShapes that do not enclose an interior region simply have their boundaries drawn; their potential 'inside' areas (reachable from the grid edge) are not explicitly filled or cleared.\n\"\"\"\n\ndef find_shapes_and_boundaries(grid):\n    \"\"\"\n    Finds all distinct contiguous shapes of non-white colors using BFS.\n    Returns a list of tuples, where each tuple contains:\n    (set of boundary pixel coordinates, boundary_color)\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(H):\n        for c in range(W):\n            # Start BFS from a non-white, unvisited pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                boundary_color = grid[r, c]\n                current_shape_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_shape_pixels.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and if neighbor has the same color\n                        if 0 <= nr < H and 0 <= nc < W and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == boundary_color:\n                            visited[nr, nc] = True\n                            current_shape_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Add the found shape to the list\n                if current_shape_pixels: \n                     shapes.append((current_shape_pixels, boundary_color))\n    return shapes\n\ndef find_reachable(grid_shape, starts, impassable_pixels):\n    \"\"\"\n    Finds all pixels reachable from start points without crossing impassable pixels using BFS.\n    grid_shape is a tuple (H, W).\n    starts is a list or set of (r, c) tuples (potential starting points).\n    impassable_pixels is a set of (r, c) tuples (pixels that block movement).\n    Returns a set of reachable (r, c) tuples.\n    \"\"\"\n    H, W = grid_shape\n    # Filter starts: must be within bounds and not impassable\n    q = deque(p for p in starts if 0 <= p[0] < H and 0 <= p[1] < W and p not in impassable_pixels)\n    reachable = set(q) # Initialize reachable with valid starting points\n    \n    # Use a visited array for efficiency\n    visited = np.zeros(grid_shape, dtype=bool)\n    for r_init, c_init in reachable:\n        visited[r_init, c_init] = True\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds, visited status, and impassable status\n            if 0 <= nr < H and 0 <= nc < W and \\\n               not visited[nr, nc] and \\\n               (nr, nc) not in impassable_pixels:\n                visited[nr, nc] = True\n                reachable.add((nr, nc))\n                q.append((nr, nc))\n    return reachable\n\n\ndef get_interior_region(grid_shape, boundary_pixels):\n    \"\"\"\n    Determines the interior region enclosed by a set of boundary pixels.\n    An interior region is pixels not on the boundary and not reachable from the grid edges.\n    Returns the set of interior pixels if the boundary encloses a region,\n    otherwise returns an empty set.\n    \"\"\"\n    H, W = grid_shape\n    all_pixels = set((r, c) for r in range(H) for c in range(W))\n    # Potential interior/exterior are all pixels EXCEPT the boundary itself\n    potential_interior_exterior = all_pixels - boundary_pixels\n\n    # If no pixels other than the boundary exist, no interior is possible\n    if not potential_interior_exterior:\n        return set()\n\n    # Define starting points for exterior flood fill: all edge points *not* on the boundary\n    edge_starts = set()\n    for r in range(H):\n        if (r, 0) not in boundary_pixels: edge_starts.add((r, 0))\n        if (r, W - 1) not in boundary_pixels: edge_starts.add((r, W - 1))\n    for c in range(1, W - 1): # Avoid adding corners twice\n        if (0, c) not in boundary_pixels: edge_starts.add((0, c))\n        if (H - 1, c) not in boundary_pixels: edge_starts.add((H - 1, c))\n\n    # Find all pixels reachable from the edges without crossing the boundary\n    # These are the exterior pixels (relative to this boundary)\n    exterior_pixels = find_reachable(grid_shape, edge_starts, boundary_pixels)\n\n    # The interior is whatever potential pixels are left after removing the exterior\n    interior_pixels = potential_interior_exterior - exterior_pixels\n\n    # If interior_pixels is not empty, the shape encloses a region w.r.t the grid boundary\n    return interior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    H, W = input_grid.shape\n    # Initialize output grid with background color (white/0)\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all distinct shapes (boundaries) and their colors\n    shapes = find_shapes_and_boundaries(input_grid)\n\n    # 2. Draw all boundaries onto the output grid first\n    for boundary_pixels, boundary_color in shapes:\n        for r, c in boundary_pixels:\n            # Basic bounds check for safety, though coordinates should be valid\n            if 0 <= r < H and 0 <= c < W: \n                 output_grid[r, c] = boundary_color\n\n    # 3. Process each shape again to handle interior filling\n    for boundary_pixels, boundary_color in shapes:\n        \n        # 4. Determine if the shape encloses an interior region\n        interior_region_pixels = get_interior_region((H, W), boundary_pixels)\n\n        # 5. If an interior region exists:\n        if interior_region_pixels:\n            # a. Collect marker colors from the *input* grid within the interior region\n            marker_colors = []\n            for r, c in interior_region_pixels:\n                # Bounds check just in case interior calculation yielded something odd\n                if 0 <= r < H and 0 <= c < W: \n                    pixel_color = input_grid[r, c]\n                    # A marker is non-white and not the boundary color\n                    if pixel_color != 0 and pixel_color != boundary_color:\n                        marker_colors.append(pixel_color)\n\n            # b. Check the fill condition: at least two *distinct* marker colors\n            distinct_marker_colors = set(marker_colors)\n            \n            fill_color = 0 # Default fill is white (0) if condition not met\n            \n            if len(distinct_marker_colors) >= 2:\n                # c. Condition met: Determine the actual fill color\n                if marker_colors: # Should be true if distinct_marker_colors >= 2\n                    color_counts = Counter(marker_colors)\n                    # Find the maximum frequency\n                    max_freq = 0\n                    # Find max frequency directly using Counter's values\n                    if color_counts: # Check if counter is not empty\n                         max_freq = max(color_counts.values())\n\n                    # Find all colors with max frequency\n                    candidate_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n                    # Tie-breaking: Choose the color with the *lowest* numerical value\n                    if candidate_colors: # Ensure candidates exist\n                         actual_fill_color = min(candidate_colors)\n                         fill_color = actual_fill_color # Set fill color for the interior\n            \n            # d. Fill the interior region in the output grid with the determined color (either calculated or default white)\n            for r, c in interior_region_pixels:\n                 if 0 <= r < H and 0 <= c < W: # Bounds check for safety\n                    output_grid[r, c] = fill_color\n\n    # 6. Return the completed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9730,
    "candidates_token_count": 2377,
    "total_token_count": 12107,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 157.59228,
  "retries": null
}