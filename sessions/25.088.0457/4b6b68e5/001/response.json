{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies closed shapes formed by a single non-white color (boundary color).\nFor each closed shape, it finds the region enclosed within it (interior region).\nIt then identifies all non-white pixels within the interior region that are *not* the boundary color (marker pixels).\nIf marker pixels exist, it determines the most frequent color among them. If there's a tie in frequency, the color with the highest numerical value is chosen.\nFinally, it fills the entire interior region (including original white pixels and marker pixels) with this determined fill color.\nPixels belonging to the boundary, pixels outside any closed shape, and pixels inside shapes that are not closed remain unchanged.\n\"\"\"\n\ndef find_shape(grid, start_r, start_c, visited_boundaries):\n    \"\"\"\n    Finds a contiguous shape of a single color using BFS.\n    Marks visited pixels in visited_boundaries.\n    \"\"\"\n    H, W = grid.shape\n    q = deque([(start_r, start_c)])\n    shape_color = grid[start_r, start_c]\n    shape_pixels = set()\n    visited_boundaries[start_r, start_c] = shape_color # Mark with its own color\n    shape_pixels.add((start_r, start_c))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and \\\n               visited_boundaries[nr, nc] == 0 and \\\n               grid[nr, nc] == shape_color:\n                visited_boundaries[nr, nc] = shape_color\n                shape_pixels.add((nr, nc))\n                q.append((nr, nc))\n    return shape_pixels, shape_color\n\ndef find_reachable(grid, starts, impassable_pixels):\n    \"\"\"\n    Finds all pixels reachable from start points without crossing impassable pixels using BFS.\n    \"\"\"\n    H, W = grid.shape\n    q = deque(starts)\n    reachable = set(starts)\n    visited = np.zeros((H,W), dtype=bool) # Track visited for this specific flood fill\n\n    for r, c in starts:\n         if 0 <= r < H and 0 <= c < W:\n            visited[r,c] = True\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and \\\n               not visited[nr, nc] and \\\n               (nr, nc) not in impassable_pixels:\n                visited[nr, nc] = True\n                reachable.add((nr, nc))\n                q.append((nr, nc))\n    return reachable\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding enclosed regions within single-color boundaries\n    and flood-filling them based on the most frequent internal marker color.\n    \"\"\"\n    H, W = input_grid.shape\n    output_grid = np.copy(input_grid)\n    visited_boundaries = np.zeros_like(input_grid, dtype=int) # 0=not visited, >0=boundary color\n\n    # Iterate through grid to find potential boundaries\n    for r in range(H):\n        for c in range(W):\n            # If it's a non-white pixel and not yet part of an identified boundary\n            if input_grid[r, c] != 0 and visited_boundaries[r, c] == 0:\n                # 1. Find the complete boundary shape\n                boundary_pixels, boundary_color = find_shape(input_grid, r, c, visited_boundaries)\n\n                # 2. Determine the exterior region reachable from grid edges without crossing the current boundary\n                edge_starts = []\n                for i in range(H):\n                    if (i, 0) not in boundary_pixels: edge_starts.append((i, 0))\n                    if (i, W - 1) not in boundary_pixels: edge_starts.append((i, W - 1))\n                for j in range(W):\n                     if (0, j) not in boundary_pixels: edge_starts.append((0, j))\n                     if (H - 1, j) not in boundary_pixels: edge_starts.append((H - 1, j))\n\n                exterior_pixels = find_reachable(input_grid, edge_starts, boundary_pixels)\n\n                # 3. Identify potential interior pixels (not boundary, not exterior)\n                potential_interior_pixels = set()\n                all_pixels = set((ir, ic) for ir in range(H) for ic in range(W))\n                potential_interior_pixels = all_pixels - boundary_pixels - exterior_pixels\n\n                # If there are potential interior pixels, they form the interior region(s)\n                if potential_interior_pixels:\n                    # Note: This assumes a single connected interior for a single boundary shape.\n                    # Complex shapes might require processing connected components of potential_interior_pixels.\n                    # However, ARC tasks often involve simple closed shapes.\n                    interior_region_pixels = potential_interior_pixels\n\n                    # 4. Collect marker colors from the *input* grid within the interior region\n                    marker_colors = []\n                    for ir, ic in interior_region_pixels:\n                        pixel_color = input_grid[ir, ic]\n                        if pixel_color != 0 and pixel_color != boundary_color:\n                            marker_colors.append(pixel_color)\n\n                    # 5. Determine fill color if markers exist\n                    if marker_colors:\n                        color_counts = Counter(marker_colors)\n                        # Find the max frequency\n                        max_freq = 0\n                        for color in color_counts:\n                           if color_counts[color] > max_freq:\n                               max_freq = color_counts[color]\n\n                        # Find colors with max frequency\n                        candidate_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n                        # Choose the one with the highest numerical value if tied\n                        fill_color = max(candidate_colors)\n\n                        # 6. Fill the interior region in the output grid\n                        for ir, ic in interior_region_pixels:\n                            output_grid[ir, ic] = fill_color\n                    else:\n                        # If no markers, fill with white (0) or leave as is?\n                        # Examples suggest filling based on markers. If no markers,\n                        # what happens? Example 1 top-right shape has no markers, remains white.\n                        # Example 3 has internal white and markers, all get filled.\n                        # Let's assume if no markers, interior remains as is (which includes white).\n                        # The code currently does this implicitly by only filling if markers exist.\n                        # Let's explicitly fill white regions with white if no markers are present?\n                        # No, the description says \"fill the *entire* interior region ... with this determined fill color\".\n                        # This implies *if* a fill color is determined, *then* fill everything inside.\n                        # If no markers, no fill color determined, so region stays as is. This matches Example 1.\n                        pass\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5958,
    "candidates_token_count": 1727,
    "total_token_count": 7685,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.272365,
  "retries": null
}