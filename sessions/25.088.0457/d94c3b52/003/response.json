{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specified color in the grid.\n\n    An object is defined as a set of connected pixels of the same color.\n    Connectivity includes diagonals (8-connectivity).\n\n    Args:\n        grid (list of list of int): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects. Each object is represented as a dictionary\n              with 'coords' (a set of (row, col) tuples) and\n              'shape' (a frozenset of relative (row, col) tuples from the top-left corner).\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is the target color and not yet visited\n            if grid[r][c] == color and (r, c) not in visited:\n                object_coords = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c # Keep track of top-left for shape calculation\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    object_coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check grid bounds, target color, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr][nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n\n                # If any coordinates were found, store the object\n                if object_coords:\n                    # Calculate relative coordinates for the shape representation\n                    # This makes the shape independent of its position in the grid\n                    relative_coords = frozenset((coord_r - min_r, coord_c - min_c)\n                                                for coord_r, coord_c in object_coords)\n                    objects.append({'coords': object_coords, 'shape': relative_coords})\n\n    return objects\n\ndef is_adjacent_to_color(grid, object_coords, target_color):\n    \"\"\"\n    Checks if any pixel of an object is adjacent (including diagonals)\n    to a pixel of the target color.\n\n    Args:\n        grid (list of list of int): The input grid.\n        object_coords (set): A set of (row, col) tuples representing the object's pixels.\n        target_color (int): The color to check for adjacency.\n\n    Returns:\n        bool: True if adjacent to the target color, False otherwise.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    # Iterate through each pixel coordinate of the object\n    for r, c in object_coords:\n        # Check its 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n\n                nr, nc = r + dr, c + dc\n\n                # Check grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if the neighbor has the target color\n                    # Also ensure the neighbor is not part of the object itself,\n                    # although this isn't strictly necessary if target_color is different\n                    # from the object's color.\n                    if grid[nr][nc] == target_color and (nr, nc) not in object_coords:\n                        return True # Found an adjacent pixel of the target color\n    return False # No adjacent pixel of the target color found\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify all blue (1) and azure (8) shapes.\n    2. For each blue shape:\n       a. Check if an azure shape with the exact same relative shape exists anywhere in the grid.\n       b. If a matching azure shape exists:\n          i. Check if the blue shape is immediately adjacent (including diagonals) to *any* azure pixel.\n          ii. If adjacent to azure, recolor the blue shape to azure (8).\n          iii. If not adjacent to azure, recolor the blue shape to orange (7).\n       c. If no matching azure shape exists, the blue shape remains blue (1).\n    3. Original azure shapes remain azure.\n    4. All other colors remain unchanged.\n    \"\"\"\n    # Create a deep copy of the input grid to modify and return\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find all blue objects (color 1)\n    blue_objects = find_objects(input_grid, 1)\n\n    # Find all azure objects (color 8)\n    azure_objects = find_objects(input_grid, 8)\n\n    # Create a set of unique shapes found among the azure objects for quick lookup\n    # The shape is represented by a frozenset of relative coordinates\n    azure_shapes = {obj['shape'] for obj in azure_objects}\n\n    # Iterate through each blue object found\n    for blue_obj in blue_objects:\n        blue_shape = blue_obj['shape']\n        blue_coords = blue_obj['coords']\n\n        # Check if the shape of the current blue object exists in the set of azure shapes\n        if blue_shape in azure_shapes:\n            # Shape match found. Now check for adjacency to any azure pixel.\n            adjacent_to_azure = is_adjacent_to_color(input_grid, blue_coords, 8)\n\n            if adjacent_to_azure:\n                # If adjacent to azure, recolor the blue object to azure (8)\n                for r, c in blue_coords:\n                    output_grid[r][c] = 8\n            else:\n                # If not adjacent to azure, recolor the blue object to orange (7)\n                for r, c in blue_coords:\n                    output_grid[r][c] = 7\n        # else:\n            # If no matching azure shape exists, the blue object remains blue (1).\n            # No action needed as output_grid started as a copy.\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9884,
    "candidates_token_count": 1586,
    "total_token_count": 11470,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.296561,
  "retries": null
}