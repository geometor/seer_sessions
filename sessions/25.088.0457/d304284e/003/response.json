{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis transformation identifies a single non-white 'template' object in the input grid. \nIt then tiles this object across a new grid, which has the same width as the input but is one row taller.\n\nThe tiling follows these rules:\n\n1.  **Output Grid Initialization:**\n    *   Create an output grid with dimensions (input_height + 1, input_width).\n    *   Initialize the output grid with the background color (white, 0).\n\n2.  **Template Identification:**\n    *   Find the first contiguous non-white object in the *input* grid. Determine its top-left corner (r0, c0), height (h), width (w), color (template_color), and the relative coordinates of its pixels (pattern).\n\n3.  **Horizontal Tiling (First Row on Output Grid):**\n    *   Place the original template object at its original location (r0, c0) on the *output* grid using its original color (template_color).\n    *   Generate copies horizontally to the right, starting from column `c0 + horizontal_gap`.\n    *   The horizontal gap between the start columns of adjacent objects is fixed (e.g., 4 columns).\n    *   The color of the copies follows a repeating pattern: [original_color, original_color, magenta (6)].\n    *   Tiling continues as long as the starting column (`current_c`) of the next potential copy is less than the output grid's width. Objects may be partially placed if they extend beyond the right edge.\n\n4.  **Vertical Tiling (Subsequent Rows on Output Grid):**\n    *   Replicate patterns downwards, starting from row `r0 + vertical_gap`.\n    *   The vertical gap between the start rows of adjacent patterns is fixed and equal to the template object's height plus one row (`h + 1`).\n    *   Crucially, only the *magenta* colored objects from the first row's pattern are copied into the subsequent rows. The original colored objects are *not* replicated vertically.\n    *   The vertically replicated objects retain the magenta color.\n    *   Tiling continues as long as the starting row (`current_r`) of the next potential row of copies is less than the output grid's height. Objects may be partially placed if they extend beyond the bottom edge.\n\nThe final output grid contains the tiled pattern.\n\"\"\"\n\ndef find_template_object(grid, background_color=0):\n    \"\"\"\n    Finds the first contiguous non-background object in the input grid\n    and returns its properties. Assumes there is only one such object.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color considered background (default 0).\n\n    Returns:\n        dict: A dictionary containing object properties:\n              'r0', 'c0': top-left coordinates (relative to input grid)\n              'h', 'w': height and width\n              'color': the object's color\n              'pattern': list of (dr, dc) relative coordinates of object pixels\n              Returns None if no object is found.\n    \"\"\"\n    non_bg_coords = np.argwhere(grid != background_color)\n    if non_bg_coords.size == 0:\n        return None # No object found\n\n    # Find the coordinates of the first non-background pixel\n    first_pixel_r, first_pixel_c = non_bg_coords[0]\n    obj_color = grid[first_pixel_r, first_pixel_c]\n\n    # Perform BFS to find all connected pixels of the same color\n    q = [(first_pixel_r, first_pixel_c)]\n    visited = set(q)\n    obj_pixels_abs = list(q) # Store absolute coordinates\n\n    while q:\n        r, c = q.pop(0)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-connectivity\n            nr, nc = r + dr, c + dc\n            if (0 <= nr < grid.shape[0] and\n                0 <= nc < grid.shape[1] and\n                grid[nr, nc] == obj_color and\n                (nr, nc) not in visited):\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                obj_pixels_abs.append((nr, nc))\n\n    if not obj_pixels_abs:\n         return None\n\n    # Determine bounding box\n    rows, cols = zip(*obj_pixels_abs)\n    r0 = min(rows)\n    c0 = min(cols)\n    r1 = max(rows)\n    c1 = max(cols)\n    h = r1 - r0 + 1\n    w = c1 - c0 + 1\n\n    # Extract relative pattern pixels\n    pattern_pixels_relative = sorted([(r_abs - r0, c_abs - c0) for r_abs, c_abs in obj_pixels_abs])\n\n    return {\n        \"r0\": r0, \"c0\": c0, \"h\": h, \"w\": w,\n        \"color\": obj_color, \"pattern\": pattern_pixels_relative\n    }\n\n\ndef place_pattern(grid, r_start, c_start, pattern_pixels, color):\n    \"\"\"\n    Places the object pattern onto the grid at the specified location and color,\n    handling boundary clipping.\n\n    Args:\n        grid (np.array): The target grid (modified in place).\n        r_start (int): Top row for placing the pattern.\n        c_start (int): Left column for placing the pattern.\n        pattern_pixels (list): List of (dr, dc) relative coordinates.\n        color (int): The color to draw the pattern with.\n    \"\"\"\n    grid_height, grid_width = grid.shape\n    for dr, dc in pattern_pixels:\n        r, c = r_start + dr, c_start + dc\n        # Check bounds before drawing\n        if 0 <= r < grid_height and 0 <= c < grid_width:\n            grid[r, c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described tiling transformation to the input grid.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # --- Step 1: Determine output grid size and initialize ---\n    input_height, input_width = input_grid.shape\n    output_height = input_height + 1\n    output_width = input_width\n    output_grid = np.zeros((output_height, output_width), dtype=int) # Default background is 0 (white)\n\n    # --- Step 2: Find the template object in the input grid ---\n    template_obj = find_template_object(input_grid)\n    if template_obj is None:\n        # If no object found, return the initialized (empty) output grid\n        return output_grid\n\n    r0, c0 = template_obj[\"r0\"], template_obj[\"c0\"] # Coordinates relative to input, used as start on output\n    h, w = template_obj[\"h\"], template_obj[\"w\"]\n    template_color = template_obj[\"color\"]\n    pattern = template_obj[\"pattern\"]\n\n    # --- Step 3: Define constants and parameters ---\n    magenta_color = 6\n    horizontal_gap = 4  # Gap between start columns\n    vertical_gap = h + 1 # Gap between start rows\n    color_sequence = [template_color, template_color, magenta_color]\n\n    # --- Step 4: Generate First Row on Output Grid ---\n    first_row_objects = [] # Store info for vertical tiling: (col_start, color)\n\n    # Place the original object first\n    place_pattern(output_grid, r0, c0, pattern, template_color)\n    first_row_objects.append({\"c\": c0, \"color\": template_color})\n\n    # Place horizontal copies\n    current_c = c0 + horizontal_gap\n    copy_index = 1 # Start counting copies from 1 (0 is the original)\n\n    # Loop condition checks if the *start* column is within bounds\n    while current_c < output_width:\n        # Determine color for this copy\n        copy_color = color_sequence[copy_index % len(color_sequence)]\n\n        # Place the copy (place_pattern handles clipping)\n        place_pattern(output_grid, r0, current_c, pattern, copy_color)\n\n        # Store info for vertical tiling\n        first_row_objects.append({\"c\": current_c, \"color\": copy_color})\n\n        # Move to the next potential position\n        current_c += horizontal_gap\n        copy_index += 1\n\n    # --- Step 5: Generate Subsequent Rows on Output Grid ---\n    current_r = r0 + vertical_gap\n\n    # Loop condition checks if the *start* row is within bounds\n    while current_r < output_height:\n        # Iterate through the objects placed in the first row\n        for obj_info in first_row_objects:\n            # Only copy if the object in the first row was magenta\n            if obj_info[\"color\"] == magenta_color:\n                obj_c = obj_info[\"c\"]\n                # Place a magenta copy in the current row (place_pattern handles clipping)\n                place_pattern(output_grid, current_r, obj_c, pattern, magenta_color)\n\n        # Move to the next potential row position\n        current_r += vertical_gap\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11093,
    "candidates_token_count": 2216,
    "total_token_count": 13309,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.009878,
  "retries": null
}