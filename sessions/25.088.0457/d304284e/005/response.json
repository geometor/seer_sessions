{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis transformation identifies a single non-white 'template' object in the input grid. \nIt then tiles this object across the output grid, which has the *same dimensions* as the input grid.\n\nThe tiling follows these rules:\n\n1.  **Output Grid Initialization**:\n    *   Create an output grid with the same height and width as the input grid.\n    *   Initialize the output grid with the background color (white, 0).\n\n2.  **Template Identification**:\n    *   Find the single contiguous non-white object in the *input* grid. Determine its top-left corner relative to the input grid (`r0`, `c0`), its height (`h`), width (`w`), color (`template_color`), and the relative coordinates of its constituent pixels (`pattern`).\n\n3.  **Horizontal Tiling (First Row on Output Grid)**:\n    *   Place the identified `pattern` onto the *output* grid starting at the template's original position (`r0`, `c0`) using its original `template_color`.\n    *   Generate copies horizontally to the right, starting from column `c0 + 4`.\n    *   The horizontal gap between the starting columns of adjacent objects is fixed at 4.\n    *   The color of the copies follows a repeating pattern: [`template_color`, `template_color`, magenta (6)]. The first copy (at `c0+4`) uses the second color in the sequence, the next (at `c0+8`) uses the third, and so on.\n    *   Store the starting column of each *magenta* object placed in this first row.\n    *   Tiling continues as long as the starting column (`current_c`) of the next potential copy is less than the output grid's width. Objects are clipped if they extend beyond the right edge.\n\n4.  **Vertical Tiling (Subsequent Rows on Output Grid)**:\n    *   Replicate patterns downwards, starting from row `r0 + h + 1`.\n    *   The vertical gap between the starting rows of adjacent pattern rows is fixed and equal to the template object's height plus one row (`h + 1`).\n    *   Crucially, only the *magenta* colored objects from the first row's pattern are copied into the subsequent rows. The corresponding column positions are used.\n    *   The vertically replicated objects retain the magenta color (6).\n    *   Tiling continues as long as the starting row (`current_r`) of the next potential row of copies is less than the output grid's height. Objects are clipped if they extend beyond the bottom edge.\n\nThe final output grid contains the completed tiled pattern.\n\"\"\"\n\ndef find_template_object(grid, background_color=0):\n    \"\"\"\n    Finds the first contiguous non-background object in the input grid\n    and returns its properties. Assumes there is only one such object.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color considered background (default 0).\n\n    Returns:\n        dict: A dictionary containing object properties:\n              'r0', 'c0': top-left coordinates (relative to input grid)\n              'h', 'w': height and width\n              'color': the object's color\n              'pattern': list of (dr, dc) relative coordinates of object pixels\n              Returns None if no object is found.\n    \"\"\"\n    non_bg_coords = np.argwhere(grid != background_color)\n    if non_bg_coords.size == 0:\n        return None # No object found\n\n    # Find the coordinates of the first non-background pixel found during iteration\n    start_r, start_c = non_bg_coords[0]\n    obj_color = grid[start_r, start_c]\n\n    # Perform BFS to find all connected pixels of the same color\n    q = deque([(start_r, start_c)])\n    visited = set(q)\n    obj_pixels_abs = list(q) # Store absolute coordinates\n\n    while q:\n        r, c = q.popleft()\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check grid boundaries\n            if 0 <= nr < grid.shape[0] and 0 <= nc < grid.shape[1]:\n                # Check if neighbor is the same color and not visited\n                if grid[nr, nc] == obj_color and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    obj_pixels_abs.append((nr, nc))\n\n    if not obj_pixels_abs:\n         return None # Should not happen if non_bg_coords was found, but safety check\n\n    # Determine bounding box from the collected absolute pixel coordinates\n    rows, cols = zip(*obj_pixels_abs)\n    r0 = min(rows)\n    c0 = min(cols)\n    r1 = max(rows)\n    c1 = max(cols)\n    h = r1 - r0 + 1\n    w = c1 - c0 + 1\n\n    # Create the relative pattern (coordinates relative to r0, c0)\n    pattern_pixels_relative = sorted([(r_abs - r0, c_abs - c0) for r_abs, c_abs in obj_pixels_abs])\n\n    return {\n        \"r0\": r0, \"c0\": c0, \"h\": h, \"w\": w,\n        \"color\": obj_color, \"pattern\": pattern_pixels_relative\n    }\n\n\ndef place_pattern(grid, r_start, c_start, pattern_pixels, color):\n    \"\"\"\n    Places the object pattern onto the grid at the specified location and color,\n    handling boundary clipping.\n\n    Args:\n        grid (np.array): The target grid (modified in place).\n        r_start (int): Top row for placing the pattern's origin (0,0).\n        c_start (int): Left column for placing the pattern's origin (0,0).\n        pattern_pixels (list): List of (dr, dc) relative coordinates.\n        color (int): The color to draw the pattern with.\n    \"\"\"\n    grid_height, grid_width = grid.shape\n    for dr, dc in pattern_pixels:\n        r, c = r_start + dr, c_start + dc\n        # Check bounds before drawing pixel\n        if 0 <= r < grid_height and 0 <= c < grid_width:\n            grid[r, c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described tiling transformation to the input grid.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # --- Step 1: Initialize output grid ---\n    input_height, input_width = input_grid.shape\n    # Output grid has the SAME dimensions as the input\n    output_height = input_height\n    output_width = input_width\n    output_grid = np.zeros((output_height, output_width), dtype=int) # Default background is 0 (white)\n\n    # --- Step 2: Find the template object in the input grid ---\n    template_obj = find_template_object(input_grid)\n    if template_obj is None:\n        # If no object found, return the initialized (empty) output grid\n        return output_grid\n\n    # Extract template properties\n    r0, c0 = template_obj[\"r0\"], template_obj[\"c0\"] # Top-left coords relative to input\n    h, w = template_obj[\"h\"], template_obj[\"w\"]     # Height and width\n    template_color = template_obj[\"color\"]          # Original color\n    pattern = template_obj[\"pattern\"]               # Relative pixel coordinates\n\n    # --- Step 3: Define constants and parameters ---\n    magenta_color = 6\n    horizontal_gap = 4             # Gap between start columns of horizontal copies\n    vertical_gap = h + 1           # Gap between start rows of vertical copies\n    color_sequence = [template_color, template_color, magenta_color] # Color cycle for horizontal copies\n\n    # --- Step 4: Generate First Row on Output Grid (Horizontal Tiling) ---\n    magenta_cols_in_first_row = [] # Store starting columns of magenta objects placed in this row\n\n    # Place the original template object first\n    place_pattern(output_grid, r0, c0, pattern, template_color)\n    # Note: The original object itself is never magenta based on the sequence starting point\n\n    # Place horizontal copies\n    current_c = c0 + horizontal_gap # Start column for the first copy\n    copy_index = 1 # Start counting copies from 1 (0 is the original object)\n\n    # Loop condition checks if the *start* column is within bounds\n    while current_c < output_width:\n        # Determine color for this copy based on its index in the sequence\n        # copy_index 1 -> color_sequence[1%3] = color_sequence[1]\n        # copy_index 2 -> color_sequence[2%3] = color_sequence[2] (magenta)\n        # copy_index 3 -> color_sequence[3%3] = color_sequence[0]\n        copy_color = color_sequence[copy_index % len(color_sequence)]\n\n        # Place the copy (place_pattern handles clipping)\n        place_pattern(output_grid, r0, current_c, pattern, copy_color)\n\n        # Store the starting column if this copy was magenta\n        if copy_color == magenta_color:\n            magenta_cols_in_first_row.append(current_c)\n\n        # Move to the next potential position\n        current_c += horizontal_gap\n        copy_index += 1\n\n    # --- Step 5: Generate Subsequent Rows on Output Grid (Vertical Tiling) ---\n    current_r = r0 + vertical_gap # Start row for the first row of vertical copies\n\n    # Loop condition checks if the *start* row is within bounds\n    while current_r < output_height:\n        # Iterate through the starting columns of the magenta objects placed in the first row\n        for magenta_c in magenta_cols_in_first_row:\n            # Place a magenta copy in the current row at the corresponding column\n            # (place_pattern handles clipping)\n            place_pattern(output_grid, current_r, magenta_c, pattern, magenta_color)\n\n        # Move to the next potential row position\n        current_r += vertical_gap\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19240,
    "candidates_token_count": 2473,
    "total_token_count": 21713,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.395205,
  "retries": null
}