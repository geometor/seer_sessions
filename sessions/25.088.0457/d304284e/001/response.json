{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis transformation identifies a single non-white 'template' object in the input grid. \nIt then tiles this object across the grid according to specific rules:\n\n1. Horizontal Tiling (First Row):\n   - The original object remains in place.\n   - Copies are placed horizontally to the right with a fixed gap of 4 columns between their starting positions.\n   - The color of the copies follows a repeating pattern: [original_color, original_color, magenta].\n   - Tiling stops if the next copy would extend beyond the grid's width.\n\n2. Vertical Tiling (Subsequent Rows):\n   - The entire pattern generated in the first row (including the original object and its horizontal copies) acts as a template for vertical replication.\n   - Rows are replicated downwards with a fixed vertical gap equal to the template object's height plus one row.\n   - Crucially, only the *magenta* colored objects from the first row's pattern are copied into the subsequent rows. The original colored objects are skipped.\n   - Tiling stops if the next row would extend beyond the grid's height.\n\nThe output grid contains the original object and all generated copies.\n\"\"\"\n\ndef find_template_object(grid, background_color=0):\n    \"\"\"\n    Finds the first contiguous non-background object and returns its properties.\n    Assumes there is only one such object in the input.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color considered background.\n\n    Returns:\n        dict: A dictionary containing object properties:\n              'r0', 'c0': top-left coordinates\n              'h', 'w': height and width\n              'color': the object's color\n              'pattern': list of (dr, dc) relative coordinates of object pixels\n              Returns None if no object is found.\n    \"\"\"\n    non_bg_coords = np.argwhere(grid != background_color)\n    if non_bg_coords.size == 0:\n        return None # No object found\n\n    # Find the coordinates of the first non-background pixel found during standard iteration\n    # This assumes the first pixel belongs to the single object we care about.\n    first_pixel_r, first_pixel_c = non_bg_coords[0]\n    obj_color = grid[first_pixel_r, first_pixel_c]\n\n    # Find all pixels belonging to this object (same color, contiguous)\n    q = [(first_pixel_r, first_pixel_c)]\n    visited = set(q)\n    obj_pixels_abs = list(q) # Store absolute coordinates first\n\n    while q:\n        r, c = q.pop(0)\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-connectivity\n            nr, nc = r + dr, c + dc\n            if (0 <= nr < grid.shape[0] and\n                0 <= nc < grid.shape[1] and\n                grid[nr, nc] == obj_color and\n                (nr, nc) not in visited):\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                obj_pixels_abs.append((nr, nc))\n\n    if not obj_pixels_abs: # Should not happen if non_bg_coords was found\n         return None\n\n    # Determine bounding box from the collected object pixels\n    rows, cols = zip(*obj_pixels_abs)\n    r0 = min(rows)\n    c0 = min(cols)\n    r1 = max(rows)\n    c1 = max(cols)\n    h = r1 - r0 + 1\n    w = c1 - c0 + 1\n\n    # Extract relative pattern pixels\n    pattern_pixels_relative = []\n    for r_abs, c_abs in obj_pixels_abs:\n         pattern_pixels_relative.append((r_abs - r0, c_abs - c0))\n\n    return {\n        \"r0\": r0, \"c0\": c0, \"h\": h, \"w\": w,\n        \"color\": obj_color, \"pattern\": pattern_pixels_relative\n    }\n\n\ndef place_pattern(grid, r_start, c_start, pattern_pixels, color):\n    \"\"\"\n    Places the object pattern onto the grid at the specified location and color.\n\n    Args:\n        grid (np.array): The target grid (modified in place).\n        r_start (int): Top row for placing the pattern.\n        c_start (int): Left column for placing the pattern.\n        pattern_pixels (list): List of (dr, dc) relative coordinates.\n        color (int): The color to draw the pattern with.\n    \"\"\"\n    grid_height, grid_width = grid.shape\n    for dr, dc in pattern_pixels:\n        r, c = r_start + dr, c_start + dc\n        # Check bounds before drawing\n        if 0 <= r < grid_height and 0 <= c < grid_width:\n            grid[r, c] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described tiling transformation to the input grid.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    grid_height, grid_width = output_grid.shape\n\n    # --- Step 1: Find the template object ---\n    template_obj = find_template_object(output_grid)\n    if template_obj is None:\n        return output_grid # Return copy of input if no object found\n\n    r0, c0 = template_obj[\"r0\"], template_obj[\"c0\"]\n    h, w = template_obj[\"h\"], template_obj[\"w\"]\n    template_color = template_obj[\"color\"]\n    pattern = template_obj[\"pattern\"]\n\n    # --- Step 2: Define constants and parameters ---\n    magenta_color = 6\n    horizontal_gap = 4\n    vertical_gap = h + 1\n    color_sequence = [template_color, template_color, magenta_color]\n\n    # --- Step 3: Generate First Row ---\n    first_row_objects = [] # Store info needed for vertical tiling: (col_start, color)\n    # The original object is implicitly the first in the row\n    first_row_objects.append({\"c\": c0, \"color\": template_color})\n\n    current_c = c0 + horizontal_gap\n    copy_index = 1 # Start counting copies from 1\n\n    while current_c + w <= grid_width:\n        # Determine color for this copy\n        copy_color = color_sequence[copy_index % len(color_sequence)]\n\n        # Place the copy\n        place_pattern(output_grid, r0, current_c, pattern, copy_color)\n\n        # Store info for vertical tiling\n        first_row_objects.append({\"c\": current_c, \"color\": copy_color})\n\n        # Move to the next potential position\n        current_c += horizontal_gap\n        copy_index += 1\n\n    # --- Step 4: Generate Subsequent Rows ---\n    current_r = r0 + vertical_gap\n\n    while current_r + h <= grid_height:\n        # Iterate through the objects placed in the first row\n        for obj_info in first_row_objects:\n            # Only copy if the object in the first row was magenta\n            if obj_info[\"color\"] == magenta_color:\n                obj_c = obj_info[\"c\"]\n                # Place a magenta copy in the current row\n                place_pattern(output_grid, current_r, obj_c, pattern, magenta_color)\n\n        # Move to the next potential row position\n        current_r += vertical_gap\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7447,
    "candidates_token_count": 1836,
    "total_token_count": 9283,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.25798,
  "retries": null
}