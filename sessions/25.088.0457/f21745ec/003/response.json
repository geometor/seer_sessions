{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# Define white color constant\nWHITE = 0\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-white colors in the grid using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (color (int), set_of_pixels (set of (r, c) tuples)).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != WHITE and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    objects.append((color, obj_pixels))\n\n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on object properties.\n\n    Rule:\n    1. Identify all non-white connected objects.\n    2. For each object:\n       a. Determine its bounding box.\n       b. Check if the object perfectly forms the border of its bounding box AND\n          all pixels strictly inside the bounding box are white. Call this a \"perfect hollow rectangle\".\n       c. Calculate the area of the region strictly inside the bounding box (interior area).\n    3. Apply transformation:\n       a. If the object is a perfect hollow rectangle:\n          i. If its interior area is >= 10: Fill the interior white pixels with the object's color.\n          ii. If its interior area is < 10: Remove the object (set its pixels to white).\n       b. Else (if the object is not a perfect hollow rectangle OR its interior contains non-white pixels):\n          Keep the object as is.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    objects = find_objects(input_grid)\n\n    for color, object_pixels in objects:\n        # Find bounding box\n        bbox = get_bounding_box(object_pixels)\n        if bbox is None:\n            continue\n        min_r, min_c, max_r, max_c = bbox\n\n        # Calculate dimensions and interior area\n        obj_height = max_r - min_r + 1\n        obj_width = max_c - min_c + 1\n        interior_area = max(0, obj_height - 2) * max(0, obj_width - 2)\n\n        # Check properties: perfect hollow rectangle and interior content\n        is_perfect_hollow_rectangle = True\n        interior_is_only_white = True\n        interior_pixels_to_fill = [] # Keep track of pixels to fill later\n\n        # If width or height is less than 3, it cannot have a hollow interior\n        if obj_width < 3 or obj_height < 3:\n             is_perfect_hollow_rectangle = False # Cannot be hollow if too small\n             # We still need to check if *all* pixels match the border in this case,\n             # otherwise it's a complex shape.\n             if len(object_pixels) != (obj_height * obj_width): # check if solid rectangle\n                 is_perfect_hollow_rectangle = False # If not solid, it's complex/irregular\n\n        # Check if the object pixels perfectly match the border and if interior is white\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                is_border = (r == min_r or r == max_r or c == min_c or c == max_c)\n\n                if is_border:\n                    # If a border pixel is NOT part of the object, it's not a perfect hollow rect\n                    if (r, c) not in object_pixels:\n                        is_perfect_hollow_rectangle = False\n                else: # Inside the bounding box\n                    # If an interior pixel IS part of the object, it's not a perfect hollow rect\n                    if (r, c) in object_pixels:\n                        is_perfect_hollow_rectangle = False\n                    # If an interior pixel is NOT white, the interior is not only white\n                    if input_grid[r, c] != WHITE:\n                        interior_is_only_white = False\n                    # If interior is white, add to potential fill list\n                    elif input_grid[r, c] == WHITE:\n                        interior_pixels_to_fill.append((r, c))\n\n        # One final check: ensure the number of object pixels matches the border pixel count\n        # for potential perfect hollow rectangles (this guards against extra pixels).\n        # Border pixel count = 2 * width + 2 * height - 4 (subtract corners counted twice)\n        # Handle edge cases where width or height is 1 or 2\n        if obj_width <= 1 or obj_height <= 1:\n             border_pixel_count = obj_width * obj_height\n        elif obj_width == 2 or obj_height == 2:\n             border_pixel_count = obj_width * obj_height # Border is the whole thing\n        else:\n             border_pixel_count = 2 * obj_width + 2 * (obj_height - 2)\n\n        if len(object_pixels) != border_pixel_count:\n            is_perfect_hollow_rectangle = False\n\n\n        # Apply transformation rule based on checks\n        if is_perfect_hollow_rectangle and interior_is_only_white:\n            if interior_area >= 10:\n                # Fill the interior white pixels\n                for r_in, c_in in interior_pixels_to_fill:\n                     # Double check it's inside the bounding box and white (safety)\n                     if min_r < r_in < max_r and min_c < c_in < max_c and output_grid[r_in, c_in] == WHITE:\n                         output_grid[r_in, c_in] = color\n            else: # interior_area < 10\n                # Remove the object\n                for r_obj, c_obj in object_pixels:\n                    output_grid[r_obj, c_obj] = WHITE\n        # Else (not perfect hollow rect OR interior not only white): Keep the object (do nothing)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11176,
    "candidates_token_count": 1790,
    "total_token_count": 12966,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.010202,
  "retries": null
}