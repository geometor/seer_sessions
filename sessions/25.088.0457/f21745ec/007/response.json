{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# Define white color constant\nWHITE = 0\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-white colors in the grid using BFS.\n    Only considers orthogonal connectivity (4 neighbors).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (color (int), set_of_pixels (set of (r, c) tuples)).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != WHITE and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_pixels.add((r, c)) # Add starting pixel\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_pixels.add((nr, nc)) # Add neighbor pixel\n\n                if obj_pixels:\n                    objects.append((color, obj_pixels))\n\n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef check_hollow_rectangle_and_interior(input_grid, object_pixels, bbox):\n    \"\"\"\n    Checks if an object forms a perfect hollow rectangle border within its\n    bounding box and if the interior is entirely white in the input grid.\n\n    Args:\n        input_grid (np.ndarray): The original input grid.\n        object_pixels (set): The set of pixels belonging to the object.\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n\n    Returns:\n        tuple: (is_hollow_rect (bool), is_white_interior (bool))\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    obj_height = max_r - min_r + 1\n    obj_width = max_c - min_c + 1\n\n    # A hollow rectangle must be at least 3x3\n    if obj_width < 3 or obj_height < 3:\n        return False, False # Cannot be a hollow rectangle\n\n    is_hollow_rect = True\n    is_white_interior = True\n\n    # Check every pixel within the bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_border = (r == min_r or r == max_r or c == min_c or c == max_c)\n            pixel_coord = (r, c)\n\n            if is_border:\n                # Border pixel MUST be part of the object for it to be a hollow rectangle\n                if pixel_coord not in object_pixels:\n                    is_hollow_rect = False\n                    # We can stop checking the border shape, but continue to check interior\n            else: # Interior pixel\n                # Interior pixel MUST NOT be part of the object for it to be a hollow rectangle\n                if pixel_coord in object_pixels:\n                    is_hollow_rect = False\n                # Interior pixel MUST be white in the input grid for the interior condition\n                if input_grid[r, c] != WHITE:\n                    is_white_interior = False\n\n            # Optimization: if we know it's not a hollow rect AND not a white interior, we can exit early\n            # However, the conditions are separate, so we need to check both fully unless one condition forces the other check to be irrelevant (e.g. if is_hollow_rect becomes false, we might not care about is_white_interior, but the current logic requires both).\n            # Let's complete the loop to get accurate status for both conditions.\n\n    return is_hollow_rect, is_white_interior\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies non-white objects in the input grid.\n    If an object forms a perfect hollow rectangle border (at least 3x3)\n    and its interior is entirely white in the input grid,\n    the interior area is filled with the object's color in the output grid.\n    All other objects and parts of the grid remain unchanged.\n    \"\"\"\n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    # Find all connected components (objects) of non-white colors\n    objects = find_objects(input_grid)\n\n    # Iterate through each found object\n    for color, object_pixels in objects:\n        # Calculate the bounding box of the current object\n        bbox = get_bounding_box(object_pixels)\n        if bbox is None:\n            continue # Should not happen\n\n        min_r, min_c, max_r, max_c = bbox\n        obj_height = max_r - min_r + 1\n        obj_width = max_c - min_c + 1\n\n        # A hollow rectangle must be at least 3x3 to have an interior\n        if obj_width < 3 or obj_height < 3:\n            continue\n\n        # Check if the object is a perfect hollow rectangle border\n        # AND if its interior is purely white in the input grid.\n        is_hollow, is_white_inside = check_hollow_rectangle_and_interior(input_grid, object_pixels, bbox)\n\n        if is_hollow and is_white_inside:\n            # If both conditions are met, fill the interior of the bounding box\n            # in the output grid with the object's color.\n            # The interior is from min_r+1 to max_r-1 and min_c+1 to max_c-1.\n            for r_fill in range(min_r + 1, max_r):\n                for c_fill in range(min_c + 1, max_c):\n                    # Double-check we are filling a pixel that was originally white,\n                    # although is_white_inside should guarantee this.\n                    # This check is redundant if check_hollow_rectangle_and_interior is correct.\n                    # if input_grid[r_fill, c_fill] == WHITE:\n                    output_grid[r_fill, c_fill] = color\n        # Else (the object does not meet the criteria): Keep the object and interior\n        # as is (no changes needed as output_grid started as a copy).\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10355,
    "candidates_token_count": 1767,
    "total_token_count": 12122,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.387363,
  "retries": null
}