{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Set all original blue (1) pixels in the output grid to white (0).\n3.  Find all connected components (objects) in the input grid that are neither white (0) nor blue (1).\n4.  For each object, calculate its canonical shape signature based on the relative coordinates of its pixels from its top-leftmost point.\n5.  Group the identified objects based on having the exact same color and shape signature.\n6.  Identify groups that contain exactly two objects (these are the pairs).\n7.  For each identified pair of objects (Object A and Object B):\n    a.  Determine the fixed translation (row offset `dr`, column offset `dc`) that maps the position of each pixel in Object A to its corresponding pixel in Object B. This can be found by comparing the top-left coordinates of both objects.\n    b.  Iterate through each pixel `(r_A, c_A)` belonging to Object A.\n    c.  Find the corresponding pixel `(r_B, c_B)` in Object B using the translation: `r_B = r_A + dr`, `c_B = c_A + dc`.\n    d.  Horizontal Connection: If the corresponding pixels are in the same row (`r_A == r_B`) and different columns (`c_A != c_B`): Draw a horizontal blue line segment by changing the color to blue (1) for all pixels `(r_A, c)` where `c` is strictly between `c_A` and `c_B`. Only change pixels in the output grid that are currently white (0).\n    e.  Vertical Connection: If the corresponding pixels are in the same column (`c_A == c_B`) and different rows (`r_A != r_B`): Draw a vertical blue line segment by changing the color to blue (1) for all pixels `(r, c_A)` where `r` is strictly between `r_A` and `r_B`. Only change pixels in the output grid that are currently white (0).\n8.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0}):\n    \"\"\"\n    Finds connected objects of the same color in the grid, ignoring specified colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of color values to ignore.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color' (int), 'coords' (set of (row, col) tuples),\n              and 'min_coord' (tuple of (min_r, min_c)).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] not in ignore_colors:\n                color = grid[r, c]\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({\n                        'color': color,\n                        'coords': obj_coords,\n                        'min_coord': (min_r, min_c)\n                    })\n    return objects\n\ndef get_shape_signature(obj_coords):\n    \"\"\"\n    Calculates a canonical representation (signature) of an object's shape.\n    The signature is based on the relative coordinates of the object's pixels\n    from its top-left corner.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        frozenset: A frozenset of relative (dr, dc) coordinates, representing the shape.\n                   Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    relative_coords = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return relative_coords\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding pairs of identical objects (non-white, non-blue),\n    removing original blue pixels, and drawing blue lines between corresponding\n    pixels of each pair.\n\n    Args:\n        input_grid (np.ndarray): The input 2D numpy array.\n\n    Returns:\n        np.ndarray: The transformed 2D numpy array.\n    \"\"\"\n    # 1. Initialize Output Grid\n    output_grid = copy.deepcopy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 2. Clear Existing Blue pixels\n    output_grid[output_grid == 1] = 0\n\n    # 3. Identify non-white, non-blue objects in the *original* grid\n    # We ignore blue (1) here because they are irrelevant for pairing\n    objects = find_objects(input_grid, ignore_colors={0, 1})\n\n    # 4 & 5. Group objects by color and shape signature\n    objects_by_signature = defaultdict(list)\n    for obj in objects:\n        signature = (obj['color'], get_shape_signature(obj['coords']))\n        if signature[1] is not None: # Ensure shape signature is valid\n             objects_by_signature[signature].append(obj)\n\n    # 6 & 7. Find pairs and connect them\n    for signature, obj_list in objects_by_signature.items():\n        if len(obj_list) == 2:\n            # Found a pair\n            obj_A, obj_B = obj_list[0], obj_list[1]\n\n            # 7a. Determine translation between the pair\n            min_r_A, min_c_A = obj_A['min_coord']\n            min_r_B, min_c_B = obj_B['min_coord']\n            dr = min_r_B - min_r_A\n            dc = min_c_B - min_c_A\n\n            # 7b & 7c. Iterate through pixels of Object A and find corresponding in B\n            for r_A, c_A in obj_A['coords']:\n                r_B = r_A + dr\n                c_B = c_A + dc\n\n                # Check if the corresponding pixel actually exists in Object B\n                # This is a sanity check, should always be true for identical shapes\n                if (r_B, c_B) in obj_B['coords']:\n\n                    # 7d. Horizontal Connection\n                    if r_A == r_B and c_A != c_B:\n                        start_c = min(c_A, c_B) + 1\n                        end_c = max(c_A, c_B)\n                        for c in range(start_c, end_c):\n                             # Check bounds and if the pixel is currently white\n                             if 0 <= r_A < rows and 0 <= c < cols and output_grid[r_A, c] == 0:\n                                output_grid[r_A, c] = 1\n\n                    # 7e. Vertical Connection\n                    elif c_A == c_B and r_A != r_B:\n                        start_r = min(r_A, r_B) + 1\n                        end_r = max(r_A, r_B)\n                        for r in range(start_r, end_r):\n                             # Check bounds and if the pixel is currently white\n                             if 0 <= r < rows and 0 <= c_A < cols and output_grid[r, c_A] == 0:\n                                output_grid[r, c_A] = 1\n\n    # 8. Final Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13729,
    "candidates_token_count": 2043,
    "total_token_count": 15772,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.406787,
  "retries": null
}