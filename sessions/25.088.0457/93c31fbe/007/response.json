{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport copy\nimport math\n\n\"\"\"\nTransformation Rule:\n\n1.  Initialize the output grid as a copy of the input grid.\n2.  Set all original blue (1) pixels in the output grid to white (0).\n3.  Find all connected components (objects) in the input grid that are neither white (0) nor blue (1).\n4.  For each object, calculate its canonical shape signature based on the relative coordinates of its pixels from its top-leftmost point.\n5.  Group the identified objects based on having the exact same color and shape signature.\n6.  Identify groups that contain exactly two objects (these are the pairs).\n7.  For each identified pair of objects (Object A and Object B):\n    a.  Determine the fixed translation (row offset `dr_obj`, column offset `dc_obj`) that maps the position of Object A's top-left corner to Object B's top-left corner.\n    b.  Iterate through each pixel `(r_A, c_A)` belonging to Object A.\n    c.  Find the corresponding pixel `(r_B, c_B)` in Object B using the translation: `r_B = r_A + dr_obj`, `c_B = c_A + dc_obj`.\n    d.  Draw a line segment between the corresponding pixel pair `(r_A, c_A)` and `(r_B, c_B)` using a line drawing algorithm (Bresenham's).\n    e.  The line drawing process involves:\n        i. Calculating all integer pixel coordinates on the line segment using Bresenham's algorithm.\n        ii. Iterating through the calculated points, *excluding* the start point `(r_A, c_A)` and the end point `(r_B, c_B)`.\n        iii. For each intermediate point `(r_pixel, c_pixel)`:\n            - Checking if the point is within the grid boundaries.\n            - If the pixel `(r_pixel, c_pixel)` in the *output grid* is currently white (0), set its color to blue (1).\n8.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0}):\n    \"\"\"\n    Finds connected objects of the same color in the grid, ignoring specified colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of color values to ignore.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color' (int), 'coords' (set of (row, col) tuples),\n              and 'min_coord' (tuple of (min_r, min_c)).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] not in ignore_colors:\n                color = grid[r, c]\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                # Initialize min_r/min_c here, will find true min later\n                # min_r_init, min_c_init = r, c \n\n                queue = [(r, c)]\n                visited[r,c] = True\n                current_coords = set([(r,c)])\n\n                while queue:\n                    row, col = queue.pop(0)\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            queue.append((nr, nc))\n                            current_coords.add((nr,nc))\n                \n                if current_coords:\n                    obj_coords = current_coords\n                    # Find the true minimum coordinate after collecting all coords\n                    actual_min_r = min(r_coord for r_coord, c_coord in obj_coords)\n                    actual_min_c = min(c_coord for r_coord, c_coord in obj_coords)\n                    objects.append({\n                        'color': color,\n                        'coords': obj_coords,\n                        'min_coord': (actual_min_r, actual_min_c)\n                    })\n    return objects\n\ndef get_shape_signature(obj_coords):\n    \"\"\"\n    Calculates a canonical representation (signature) of an object's shape.\n    The signature is based on the relative coordinates of the object's pixels\n    from its top-left corner.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        frozenset: A frozenset of relative (dr, dc) coordinates, representing the shape.\n                   Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    relative_coords = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return relative_coords\n\ndef get_line_pixels_bresenham(r1, c1, r2, c2):\n    \"\"\"\n    Generates all integer pixel coordinates on the line from (r1, c1) to (r2, c2)\n    using Bresenham's line algorithm. Includes start and end points.\n    \"\"\"\n    pixels = []\n    r, c = r1, c1\n    dr = abs(r2 - r1)\n    dc = abs(c2 - c1)\n    sr = 1 if r1 < r2 else -1\n    sc = 1 if c1 < c2 else -1\n    err = dc - dr\n\n    while True:\n        pixels.append((r, c))\n        if r == r2 and c == c2:\n            break # Reached the end point\n\n        e2 = 2 * err\n        moved_c = False # Flag to check if horizontal move happened\n        \n        # Check horizontal move first (arbitrary choice, could be vertical)\n        if e2 > -dr: # Equivalent to e2 >= dy in some formulations where dy is negative\n            err -= dr\n            c += sc\n            moved_c = True\n\n        # Check if endpoint was reached *exactly* after the horizontal move\n        # If so, and we also need a vertical move (e2 < dc), we skip the vertical move\n        # to avoid overshooting or landing on a pixel not strictly on the ideal line path.\n        # This handles diagonal movements landing perfectly on the corner.\n        if r == r2 and c == c2 and moved_c : \n             continue \n\n        # Check vertical move\n        if e2 < dc: # Equivalent to e2 <= dx in some formulations\n            err += dc\n            r += sr\n            \n    return pixels\n\n\ndef draw_line(grid, r1, c1, r2, c2, color):\n    \"\"\"\n    Draws the intermediate points of a line between (r1, c1) and (r2, c2)\n    on the grid with the specified color using Bresenham's algorithm.\n    Only modifies pixels that are currently white (0).\n    Does not draw the start or end points themselves.\n\n    Args:\n        grid (np.ndarray): The grid to draw on (modified in-place).\n        r1, c1 (int): Coordinates of the starting point.\n        r2, c2 (int): Coordinates of the ending point.\n        color (int): The color to draw the line with.\n    \"\"\"\n    rows, cols = grid.shape\n    line_pixels = get_line_pixels_bresenham(r1, c1, r2, c2)\n\n    # Iterate through points, excluding the first (start) and the last (end)\n    if len(line_pixels) > 2:\n        for i in range(1, len(line_pixels) - 1):\n            r_pixel, c_pixel = line_pixels[i]\n            \n            # Check bounds and if the pixel is white\n            if 0 <= r_pixel < rows and 0 <= c_pixel < cols:\n                if grid[r_pixel, c_pixel] == 0:\n                    grid[r_pixel, c_pixel] = color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding pairs of identical objects (non-white, non-blue),\n    removing original blue pixels, and drawing blue lines between corresponding\n    pixels of each pair using Bresenham's line drawing algorithm.\n\n    Args:\n        input_grid (np.ndarray): The input 2D numpy array.\n\n    Returns:\n        np.ndarray: The transformed 2D numpy array.\n    \"\"\"\n    # 1. Initialize Output Grid\n    output_grid = copy.deepcopy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 2. Clear Existing Blue pixels (color 1) from the output grid\n    output_grid[output_grid == 1] = 0\n\n    # 3. Identify non-white (0), non-blue (1) objects in the *original* input grid\n    objects = find_objects(input_grid, ignore_colors={0, 1})\n\n    # 4 & 5. Group objects by color and shape signature\n    objects_by_signature = defaultdict(list)\n    for obj in objects:\n        signature_key = (obj['color'], get_shape_signature(obj['coords']))\n        if signature_key[1] is not None: # Ensure shape signature is valid\n             objects_by_signature[signature_key].append(obj)\n\n    # 6 & 7. Find pairs and connect them\n    for signature_key, obj_list in objects_by_signature.items():\n        if len(obj_list) == 2:\n            # Found a pair\n            obj_A, obj_B = obj_list[0], obj_list[1]\n\n            # 7a. Determine translation between the pair based on top-left corners\n            min_r_A, min_c_A = obj_A['min_coord']\n            min_r_B, min_c_B = obj_B['min_coord']\n            dr_obj = min_r_B - min_r_A\n            dc_obj = min_c_B - min_c_A\n\n            # 7b & 7c. Iterate through pixels of Object A and find corresponding in B\n            # Ensure iteration order is consistent if needed, though set order is arbitrary\n            # Sorting coords might make debugging easier if order mattered, but it shouldn't here.\n            sorted_coords_A = sorted(list(obj_A['coords'])) \n            \n            for r_A, c_A in sorted_coords_A:\n                # Calculate the theoretical corresponding coordinate in B\n                r_B_target = r_A + dr_obj\n                c_B_target = c_A + dc_obj\n\n                # Check if the corresponding pixel actually exists in Object B's coordinate set\n                # This is crucial because the translation is based on min_coord,\n                # ensuring the shape overlay works pixel by pixel.\n                if (r_B_target, c_B_target) in obj_B['coords']:\n                    # 7d & 7e. Draw a line between the corresponding points (r_A, c_A) and (r_B_target, c_B_target)\n                    # The draw_line function handles only coloring white pixels (0) with blue (1)\n                    # and skips drawing the start/end points.\n                    draw_line(output_grid, r_A, c_A, r_B_target, c_B_target, 1) # Draw with blue (1)\n                # else: # Optional: Add logging here if a corresponding point is unexpectedly missing\n                    # print(f\"Warning: Corresponding point ({r_B_target},{c_B_target}) not found in Object B for source point ({r_A},{c_A})\")\n\n\n    # 8. Final Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12757,
    "candidates_token_count": 2904,
    "total_token_count": 15661,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 145.798656,
  "retries": null
}