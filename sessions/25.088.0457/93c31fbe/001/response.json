{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1. Identify all connected components (objects) in the input grid that are neither white (0) nor blue (1).\n2. Group these objects based on their color and shape. A shape is defined by the relative positions of its pixels.\n3. Find groups containing exactly two identical objects (pairs).\n4. For each identified pair:\n   a. Determine the minimum bounding box that encloses both objects in the pair.\n   b. Create an initial output grid by copying the input grid and removing all original blue (1) pixels (setting them to white (0)).\n   c. Within the calculated bounding box in the output grid, fill all cells with blue (1) *unless* the cell corresponds to a pixel belonging to either of the two objects forming the pair.\n5. If no pairs are found, the output grid is simply the input grid with all original blue pixels removed.\n\"\"\"\n\ndef find_objects(grid, ignore_colors={0, 1}):\n    \"\"\"\n    Finds connected objects of the same color in the grid, ignoring specified colors.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        ignore_colors (set): Set of color values to ignore.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] not in ignore_colors:\n                color = grid[r, c]\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    objects.append({'color': color, 'coords': obj_coords})\n    return objects\n\ndef get_shape_signature(obj_coords):\n    \"\"\"\n    Calculates a canonical representation (signature) of an object's shape.\n    The signature is based on the relative coordinates of the object's pixels\n    from its top-left corner.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        frozenset: A frozenset of relative (dr, dc) coordinates, representing the shape.\n                   Returns None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    min_r = min(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    relative_coords = frozenset((r - min_r, c - min_c) for r, c in obj_coords)\n    return relative_coords\n\ndef get_bounding_box(coords_list):\n    \"\"\"\n    Calculates the minimum bounding box containing all coordinates in the list.\n\n    Args:\n        coords_list (list): A list of sets, where each set contains (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, max_r, min_c, max_c) or None if the list is empty or contains only empty sets.\n    \"\"\"\n    all_coords = set().union(*coords_list)\n    if not all_coords:\n        return None\n    min_r = min(r for r, c in all_coords)\n    max_r = max(r for r, c in all_coords)\n    min_c = min(c for r, c in all_coords)\n    max_c = max(c for r, c in all_coords)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding pairs of identical objects (non-white, non-blue)\n    and filling the bounding box between each pair with blue (1), preserving the\n    original pair objects and removing any original blue pixels.\n\n    Args:\n        input_grid (np.ndarray): The input 2D numpy array.\n\n    Returns:\n        np.ndarray: The transformed 2D numpy array.\n    \"\"\"\n    output_grid = copy.deepcopy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Remove original blue pixels from the output grid\n    output_grid[output_grid == 1] = 0\n\n    # 2. Find all non-white, non-blue objects\n    objects = find_objects(input_grid, ignore_colors={0, 1})\n\n    # 3. Group objects by color and shape signature\n    objects_by_signature = defaultdict(list)\n    for obj in objects:\n        signature = (obj['color'], get_shape_signature(obj['coords']))\n        if signature[1] is not None: # Ensure shape signature is valid\n             objects_by_signature[signature].append(obj)\n\n    # 4. Identify pairs and process them\n    for signature, obj_list in objects_by_signature.items():\n        if len(obj_list) == 2:\n            # Found a pair\n            obj1, obj2 = obj_list[0], obj_list[1]\n            pair_coords = obj1['coords'].union(obj2['coords'])\n\n            # 4a. Determine bounding box\n            bbox = get_bounding_box([obj1['coords'], obj2['coords']])\n            if bbox is None:\n                continue\n            min_r, max_r, min_c, max_c = bbox\n\n            # 4c. Fill the bounding box with blue, skipping pair pixels\n            for r in range(min_r, max_r + 1):\n                for c in range(min_c, max_c + 1):\n                    # Check bounds just in case (though bbox should be within grid)\n                    if 0 <= r < rows and 0 <= c < cols:\n                        if (r, c) not in pair_coords:\n                            output_grid[r, c] = 1\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8106,
    "candidates_token_count": 1574,
    "total_token_count": 9680,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.344975,
  "retries": null
}