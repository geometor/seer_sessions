{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentify the largest solid monochromatic rectangle for each color (excluding white/0).\nIf the area of the largest rectangle for a given color is 25 or greater, \nchange the color of all pixels within that rectangle to yellow (4).\nOtherwise, leave the pixels unchanged.\nPerform this check and potential modification for every non-white color present\nin the input grid.\n\"\"\"\n\ndef _largest_rectangle_in_histogram(heights, current_row):\n    \"\"\"\n    Helper function to find the largest rectangle in a histogram represented by the heights array.\n    Uses a stack-based approach.\n    Args:\n        heights (np.array): 1D array representing the heights of histogram bars.\n        current_row (int): The row index in the original grid corresponding to this histogram.\n    Returns:\n        tuple: (max_area, coords) where coords is (top_row, left_col, height, width) or None.\n    \"\"\"\n    stack = []  # Stores indices of heights array\n    max_area = 0\n    coords = None\n    \n    # Append a sentinel 0 height at the end to flush the stack\n    extended_heights = np.append(heights, 0)\n    \n    for i, h in enumerate(extended_heights):\n        # While stack is not empty and the current height is less than the height at stack top\n        while stack and extended_heights[stack[-1]] >= h:\n            height = extended_heights[stack.pop()]\n            # Calculate width: if stack is empty, width is i; otherwise, it's i - index_before_top - 1\n            width = i if not stack else i - stack[-1] - 1\n            area = height * width\n            \n            if area > max_area:\n                max_area = area\n                # Calculate coordinates in the original grid\n                rect_h = height\n                rect_w = width\n                top_left_col = stack[-1] + 1 if stack else 0\n                top_left_row = current_row - height + 1\n                coords = (top_left_row, top_left_col, rect_h, rect_w)\n                \n        # Push current index onto stack\n        stack.append(i)\n        \n    return max_area, coords\n\ndef find_largest_solid_rectangle(grid, color):\n    \"\"\"\n    Finds the largest solid rectangle of a given color in the grid using the\n    largest rectangle in histogram algorithm row by row.\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to search for.\n    Returns:\n        tuple: (max_area, coords) where coords is (top_row, left_col, height, width) or None.\n               Returns (0, None) if no rectangle of the given color is found.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return 0, None\n        \n    # heights[r][c] = height of consecutive cells of 'color' ending at (r, c)\n    heights = np.zeros((rows, cols), dtype=int)\n    \n    # Calculate heights grid based on the target color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                heights[r, c] = heights[r-1, c] + 1 if r > 0 else 1\n            else:\n                heights[r, c] = 0\n                \n    overall_max_area = 0\n    overall_coords = None\n    \n    # Apply the histogram algorithm for each row\n    for r in range(rows):\n        area, rect_coords = _largest_rectangle_in_histogram(heights[r, :], r)\n        if area > overall_max_area:\n            overall_max_area = area\n            overall_coords = rect_coords\n            \n    return overall_max_area, overall_coords\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the largest solid rectangle for each color \n    (excluding 0) and recoloring it to yellow (4) if its area is >= 25.\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n    \n    # Find all unique colors in the grid, excluding the background color 0\n    unique_colors = np.unique(input_array)\n    colors_to_check = [c for c in unique_colors if c != 0]\n    \n    # Iterate through each unique non-background color\n    for color in colors_to_check:\n        # Find the largest solid rectangle for the current color\n        max_area, coords = find_largest_solid_rectangle(input_array, color)\n        \n        # Check if the area meets the threshold (>= 25)\n        if max_area >= 25 and coords is not None:\n            r, c, h, w = coords\n            # Recolor the identified rectangle to yellow (4) in the output grid\n            # Ensure slicing indices are within bounds (though they should be by definition)\n            r_end = min(r + h, rows)\n            c_end = min(c + w, cols)\n            output_array[r:r_end, c:c_end] = 4\n            \n    # Convert the output numpy array back to a list of lists\n    output_grid = output_array.tolist()\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9292,
    "candidates_token_count": 1355,
    "total_token_count": 10647,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.259046,
  "retries": null
}