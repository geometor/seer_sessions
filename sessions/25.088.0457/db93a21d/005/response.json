{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom scipy.spatial import ConvexHull\nfrom skimage.draw import polygon as skimg_polygon # Use alias to avoid potential name conflicts\n\n\"\"\"\nColors white background pixels based on their proximity (Chebyshev distance)\nto distinct maroon rectangular objects, but only within the convex hull\nenclosing all maroon pixels. Pixels outside this hull remain white.\n\n1. Find all distinct maroon (9) objects (4-directional connectivity).\n2. Determine the set of all maroon pixels across all objects.\n3. Calculate the 2D convex hull of these maroon pixels.\n4. Create a boolean mask representing the area inside or on the boundary of this convex hull.\n5. Perform a multi-source Breadth-First Search (BFS) starting simultaneously from all maroon pixels, using 8-directional (Chebyshev) distance.\n6. Calculate the shortest distance from each grid cell to the nearest maroon object(s).\n7. Track the set of unique maroon object IDs that are equidistant at the shortest distance for each cell.\n8. Create the output grid:\n   - Maroon pixels remain maroon (9).\n   - Originally white pixels (0) that fall *within* the convex hull mask are colored:\n     - Green (3) if closest to exactly one maroon object.\n     - Blue (1) if equidistant from multiple maroon objects.\n     - White (0) if unreachable by the BFS (infinitely far), though this is unlikely within the hull.\n   - Originally white pixels (0) *outside* the convex hull mask remain white (0).\n   - Other pixels (if any) are assumed to become white (0).\n\"\"\"\n\ndef find_objects(grid, color_val):\n    \"\"\"\n    Finds connected components of a specific color in the grid using 4-directional adjacency.\n    \n    Args:\n        grid (np.array): The input grid.\n        color_val (int): The color value to find objects of.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of objects, where each object is a set of (row, col) tuples.\n            - dict: A dictionary mapping each pixel coordinate (row, col) belonging \n                    to an object to its unique object ID (1-based integer).\n            - set: A set containing all pixel coordinates (row, col) belonging to any found object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    pixel_to_object_id = {}\n    all_object_pixels = set()\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color_val and not visited[r, c]:\n                object_id_counter += 1\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    # Add pixel to the current object, map it to the object ID, and add to all pixels set\n                    current_object_pixels.add((row, col))\n                    pixel_to_object_id[(row, col)] = object_id_counter\n                    all_object_pixels.add((row, col))\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color_val and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the completed object to the list\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n                    \n    return objects, pixel_to_object_id, all_object_pixels\n\n\ndef get_convex_hull_mask(pixels, grid_shape):\n    \"\"\"\n    Calculates the convex hull of a set of pixels and returns a boolean mask\n    representing the filled polygon area within the grid dimensions.\n\n    Args:\n        pixels (set): A set of (row, col) coordinates.\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        np.array: A boolean mask of shape grid_shape. True for pixels inside\n                  or on the boundary of the convex hull.\n    \"\"\"\n    height, width = grid_shape\n    mask = np.zeros(grid_shape, dtype=bool)\n\n    # Convex hull requires at least 3 points. Handle edge cases.\n    if len(pixels) == 0:\n        return mask\n    \n    pixel_array = np.array(list(pixels))\n    \n    if len(pixels) == 1:\n        # Single point\n        r, c = pixel_array[0]\n        if 0 <= r < height and 0 <= c < width:\n             mask[r, c] = True\n        return mask\n        \n    if len(pixels) == 2:\n         # Line segment - use skimage.draw.line\n         r0, c0 = pixel_array[0]\n         r1, c1 = pixel_array[1]\n         rr, cc = skimg_polygon([r0, r1], [c0, c1], shape=grid_shape) # polygon can draw lines too\n         mask[rr, cc] = True\n         return mask\n\n    try:\n        # Need to swap row/col as ConvexHull expects (x, y) -> (col, row)\n        points_for_hull = pixel_array[:, [1, 0]] # Get columns (x) then rows (y)\n        hull = ConvexHull(points_for_hull)\n        # Get the vertices of the hull in (col, row) format\n        hull_vertices_xy = points_for_hull[hull.vertices]\n        # Extract row and column coordinates for skimage.draw.polygon\n        hull_rows = hull_vertices_xy[:, 1]\n        hull_cols = hull_vertices_xy[:, 0]\n        # Generate mask using skimage.draw.polygon\n        rr, cc = skimg_polygon(hull_rows, hull_cols, shape=grid_shape)\n        mask[rr, cc] = True\n    except Exception as e:\n        # QHullError might occur if points are collinear\n        # In case of collinear points, treat them as a line or bounding box\n        # For simplicity, let's try filling the bounding box of the points if hull fails\n        # This might not be perfectly accurate for collinear cases but covers some scenarios\n        print(f\"ConvexHull failed: {e}. Falling back to bounding box fill for ROI.\")\n        min_r = np.min(pixel_array[:, 0])\n        max_r = np.max(pixel_array[:, 0])\n        min_c = np.min(pixel_array[:, 1])\n        max_c = np.max(pixel_array[:, 1])\n        mask[min_r:max_r+1, min_c:max_c+1] = True\n\n    # Ensure original maroon pixels are definitely included in the mask, \n    # sometimes floating point issues in hull/polygon can miss boundary pixels\n    for r, c in pixels:\n         if 0 <= r < height and 0 <= c < width:\n             mask[r,c] = True\n             \n    return mask\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by coloring white pixels within the convex hull\n    of maroon objects based on their proximity to these objects.\n    \n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    height, width = input_arr.shape\n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_arr, dtype=int) \n\n    # 1. Identify maroon objects and all maroon pixels\n    maroon_objects, pixel_to_object_id, all_maroon_pixels = find_objects(input_arr, 9)\n    \n    # If there are no maroon objects, return the original grid (or white grid)\n    if not maroon_objects: \n        return input_arr.tolist() # Return original if no maroon\n\n    # 2. Define the Region of Interest (ROI) using Convex Hull\n    roi_mask = get_convex_hull_mask(all_maroon_pixels, (height, width))\n\n    # 3. Initialize helper grids for BFS\n    # Distance grid: stores shortest distance (Chebyshev) to any maroon object\n    distance = np.full((height, width), np.inf, dtype=float)\n    # Sources grid: stores sets of object IDs for the closest object(s)\n    sources = np.empty((height, width), dtype=object)\n    for r in range(height):\n        for c in range(width):\n            sources[r, c] = set() # Initialize each cell with an empty set\n\n    # 4. Initialize BFS queue with all maroon pixels\n    queue = deque()\n    for r, c in all_maroon_pixels:\n        if (r, c) in pixel_to_object_id: # Ensure pixel belongs to a tracked object\n            obj_id = pixel_to_object_id[(r, c)]\n            distance[r, c] = 0.0\n            sources[r, c] = {obj_id} # Source is the object itself\n            queue.append((r, c))\n\n    # 5. Perform Multi-Source BFS (using 8 directions for distance)\n    # Define 8 directions (including diagonals)\n    directions = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance[r, c]\n        current_sources = sources[r, c]\n        \n        # Explore 8 neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Calculate distance to neighbor (always +1 in Chebyshev)\n                new_dist = current_dist + 1.0\n                \n                # If we found a shorter path to this neighbor\n                if new_dist < distance[nr, nc]:\n                    distance[nr, nc] = new_dist\n                    # Replace sources with sources from the current path\n                    sources[nr, nc] = current_sources.copy() \n                    queue.append((nr, nc)) # Add neighbor to queue\n                # If we found another path of the same minimum distance\n                elif new_dist == distance[nr, nc]:\n                    # Add sources from the current path to the neighbor's sources\n                    # Only add if sources are different to prevent redundant updates?\n                    # BFS ensures shortest path, so adding sources is correct.\n                    if not current_sources.issubset(sources[nr, nc]):\n                       sources[nr, nc].update(current_sources)\n                       # Re-adding to the queue is complex here. If sources update,\n                       # neighbors might need re-evaluation if *their* sources change.\n                       # However, standard BFS handles this implicitly: if a node\n                       # is reached again via an equal-length path, its state (sources)\n                       # is updated, but it's typically not re-added unless it leads\n                       # to *shorter* paths later, which won't happen here.\n                       # Let's stick to not re-adding for now.\n\n\n    # 6. Color the output grid based on BFS results and ROI mask\n    for r in range(height):\n        for c in range(width):\n            # Handle original maroon pixels\n            if input_arr[r, c] == 9:\n                output_grid[r, c] = 9\n            # Handle original white pixels\n            elif input_arr[r, c] == 0:\n                # Check if the white pixel is within the ROI\n                if roi_mask[r, c]:\n                    # Check if it was reached by the BFS\n                    if distance[r, c] != np.inf:\n                        num_sources = len(sources[r, c])\n                        if num_sources == 1:\n                            output_grid[r, c] = 3 # Green for single closest object\n                        elif num_sources > 1:\n                            output_grid[r, c] = 1 # Blue for multiple equidistant objects\n                        # else: num_sources == 0 (shouldn't happen if distance != inf), leave white (0)\n                    else:\n                        # Inside ROI but unreachable -> leave white (0)\n                         output_grid[r, c] = 0\n                else:\n                    # White pixel outside ROI -> leave white (0)\n                    output_grid[r, c] = 0\n            # Handle any other input colors (if they exist) -> output white (0)\n            # else:\n            #    output_grid[r, c] = 0  # This line is implicitly covered by init\n\n    # Convert final numpy array back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20408,
    "candidates_token_count": 3141,
    "total_token_count": 23549,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.444433,
  "retries": null
}