{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nColors white (0) background pixels based on their proximity to distinct maroon (9) rectangular objects using 8-directional (Chebyshev) distance.\n- Finds all distinct maroon objects (4-directional connectivity).\n- Performs a multi-source Breadth-First Search (BFS) starting simultaneously from all maroon pixels.\n- Calculates the shortest distance from each grid cell to the nearest maroon object(s).\n- Tracks the set of unique maroon object IDs that are equidistant at the shortest distance.\n- Colors originally white pixels:\n    - Green (3) if closest to exactly one maroon object.\n    - Blue (1) if equidistant from multiple maroon objects.\n- Maroon pixels remain maroon (9).\n- White pixels unreachable by the BFS (infinitely far) remain white (0).\n\"\"\"\n\ndef find_objects(grid, color_val):\n    \"\"\"\n    Finds connected components of a specific color in the grid using 4-directional adjacency.\n    \n    Args:\n        grid (np.array): The input grid.\n        color_val (int): The color value to find objects of.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of objects, where each object is a set of (row, col) tuples.\n            - dict: A dictionary mapping each pixel coordinate (row, col) belonging \n                    to an object to its unique object ID (1-based integer).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    pixel_to_object_id = {}\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color_val and not visited[r, c]:\n                object_id_counter += 1\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    # Add pixel to the current object and map it to the object ID\n                    current_object_pixels.add((row, col))\n                    pixel_to_object_id[(row, col)] = object_id_counter\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color_val and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the completed object to the list\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n                    \n    return objects, pixel_to_object_id\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on proximity to maroon objects.\n    \n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    height, width = input_arr.shape\n    # Initialize output grid as a copy of the input\n    output_grid = input_arr.copy() \n\n    # 1. Identify maroon objects and map pixels to object IDs\n    maroon_objects, pixel_to_object_id = find_objects(input_arr, 9)\n    \n    # If there are no maroon objects, return the original grid\n    if not maroon_objects: \n        return output_grid.tolist()\n\n    # 2. Initialize helper grids for BFS\n    # Distance grid: stores shortest distance (Chebyshev) to any maroon object\n    distance = np.full((height, width), np.inf, dtype=float)\n    # Sources grid: stores sets of object IDs for the closest object(s)\n    sources = np.empty((height, width), dtype=object)\n    for r in range(height):\n        for c in range(width):\n            sources[r, c] = set() # Initialize each cell with an empty set\n\n    # 3. Initialize BFS queue with all maroon pixels\n    queue = deque()\n    for r in range(height):\n        for c in range(width):\n            if input_arr[r, c] == 9:\n                obj_id = pixel_to_object_id[(r, c)]\n                distance[r, c] = 0.0\n                sources[r, c] = {obj_id} # Source is the object itself\n                queue.append((r, c))\n\n    # 4. Perform Multi-Source BFS (using 8 directions for distance)\n    # Define 8 directions (including diagonals)\n    directions = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance[r, c]\n        current_sources = sources[r, c]\n        \n        # Explore 8 neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Calculate distance to neighbor (always +1 in Chebyshev)\n                new_dist = current_dist + 1.0\n                \n                # If we found a shorter path to this neighbor\n                if new_dist < distance[nr, nc]:\n                    distance[nr, nc] = new_dist\n                    # Replace sources with sources from the current path\n                    sources[nr, nc] = current_sources.copy() \n                    queue.append((nr, nc)) # Add neighbor to queue\n                # If we found another path of the same minimum distance\n                elif new_dist == distance[nr, nc]:\n                    # Add sources from the current path to the neighbor's sources\n                    # Important: Only update if the sources are different to potentially avoid cycles\n                    # although BFS structure largely prevents infinite loops here.\n                    # Check if current_sources is already fully contained within sources[nr, nc]\n                    if not current_sources.issubset(sources[nr, nc]):\n                        sources[nr, nc].update(current_sources)\n                        # No need to re-add to queue, as shortest distance is already known.\n                        # Any further paths reaching this neighbor will either be longer,\n                        # or if equal, will also update sources.\n\n    # 5. Color the output grid based on the calculated distances and sources\n    for r in range(height):\n        for c in range(width):\n            # Only modify originally white pixels that were reached by the BFS\n            if input_arr[r, c] == 0 and distance[r, c] != np.inf:\n                num_sources = len(sources[r, c])\n                if num_sources == 1:\n                    output_grid[r, c] = 3 # Green for single closest object\n                elif num_sources > 1:\n                    output_grid[r, c] = 1 # Blue for multiple equidistant objects\n            # Pixels that were originally maroon (9) or were white (0) but unreachable \n            # (distance == inf) retain their original color (already set in output_grid copy).\n\n    # Convert final numpy array back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16944,
    "candidates_token_count": 1795,
    "total_token_count": 18739,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.278429,
  "retries": null
}