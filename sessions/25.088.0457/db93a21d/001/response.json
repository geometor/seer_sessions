{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct maroon (9) rectangular objects in the input grid. \nCalculates the shortest distance from each non-maroon pixel to the nearest maroon object(s), considering 8-directional adjacency (including diagonals).\nColors originally white (0) pixels based on this proximity:\n- If a white pixel is closest to exactly one maroon object, it becomes green (3).\n- If a white pixel is equidistant from multiple maroon objects, it becomes blue (1).\nMaroon pixels remain unchanged. White pixels unreachable from any maroon object remain white.\n\"\"\"\n\ndef find_objects(grid, color_val):\n    \"\"\"\n    Finds connected components of a specific color in the grid.\n    Uses BFS to find all pixels belonging to each object.\n    Returns a list of objects, where each object is a set of (row, col) tuples,\n    and a dictionary mapping each pixel coordinate to its object ID (1-based).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    pixel_to_object_id = {}\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color_val and not visited[r, c]:\n                object_id_counter += 1\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    pixel_to_object_id[(row, col)] = object_id_counter\n                    \n                    # Check 4-directional neighbors for connectivity of the same color\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color_val and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n                    \n    return objects, pixel_to_object_id\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on proximity to maroon objects.\n    \n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    height, width = input_arr.shape\n    output_grid = input_arr.copy() # Initialize output grid\n\n    # 1. Identify maroon objects and map pixels to object IDs\n    maroon_objects, pixel_to_object_id = find_objects(input_arr, 9)\n    \n    if not maroon_objects: # Handle case with no maroon objects\n        return output_grid.tolist()\n\n    # 2. Initialize helper grids for BFS\n    # Distance grid: stores shortest distance to any maroon object\n    distance = np.full((height, width), np.inf, dtype=float)\n    # Sources grid: stores sets of object IDs for the closest object(s)\n    sources = np.empty((height, width), dtype=object)\n    for r in range(height):\n        for c in range(width):\n            sources[r, c] = set() # Initialize each cell with an empty set\n\n    # 3. Initialize BFS queue with pixels adjacent to maroon objects\n    queue = deque()\n    \n    # Define 8 directions for adjacency check\n    directions = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    for r in range(height):\n        for c in range(width):\n            if input_arr[r, c] == 0: # Consider only background pixels\n                adjacent_maroon_ids = set()\n                is_adjacent = False\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < height and 0 <= nc < width and input_arr[nr, nc] == 9:\n                        is_adjacent = True\n                        # Add the ID of the adjacent maroon object\n                        adjacent_maroon_ids.add(pixel_to_object_id[(nr, nc)]) \n                \n                if is_adjacent:\n                    distance[r, c] = 1.0 # Distance for directly adjacent pixels is 1\n                    sources[r, c] = adjacent_maroon_ids\n                    queue.append(((r, c), 1.0)) # Add (coordinate, distance) to queue\n\n    # 4. Perform BFS to calculate distances and sources for all reachable white pixels\n    while queue:\n        (r, c), d = queue.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 <= nr < height and 0 <= nc < width and input_arr[nr, nc] == 0:\n                new_dist = d + 1.0\n                \n                # If we found a shorter path to this pixel\n                if new_dist < distance[nr, nc]:\n                    distance[nr, nc] = new_dist\n                    sources[nr, nc] = sources[r, c].copy() # Inherit sources from the closer path\n                    queue.append(((nr, nc), new_dist))\n                # If we found another path of the same minimum distance\n                elif new_dist == distance[nr, nc]:\n                     # Check if the sources are different before updating and appending\n                    if not sources[r,c].issubset(sources[nr,nc]):\n                        sources[nr, nc].update(sources[r, c]) # Add sources from this new path\n                        # No need to re-add to queue if distance hasn't changed, \n                        # but subsequent steps might need the updated source info.\n                        # This is tricky; standard BFS usually doesn't re-queue on equal distance.\n                        # However, source propagation requires considering equal paths.\n                        # A simple approach is to just update sources. If a neighbor finds \n                        # *this* node later with the same distance, it will update its own sources correctly.\n\n    # 5. Color the output grid based on the calculated sources\n    for r in range(height):\n        for c in range(width):\n            # Only color originally white pixels that were reached\n            if input_arr[r, c] == 0 and distance[r, c] != np.inf:\n                num_sources = len(sources[r, c])\n                if num_sources == 1:\n                    output_grid[r, c] = 3 # Green for single source\n                elif num_sources > 1:\n                    output_grid[r, c] = 1 # Blue for multiple equidistant sources\n            # Maroon pixels (9) and unreachable white pixels (0) remain unchanged\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7043,
    "candidates_token_count": 1673,
    "total_token_count": 8716,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.86182,
  "retries": null
}