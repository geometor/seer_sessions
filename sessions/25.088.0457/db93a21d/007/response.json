{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom scipy.spatial import ConvexHull\n# Use alias to avoid potential name conflicts and be explicit\nfrom skimage.draw import polygon as skimg_polygon \n\n\"\"\"\nTransforms the input grid based on the proximity of white pixels to distinct maroon objects within a defined region.\n\n1.  Identifies all distinct connected regions (objects) of maroon pixels (color 9) using 4-directional connectivity.\n2.  Collects the coordinates of all maroon pixels from all identified objects.\n3.  Determines the 2D convex hull enclosing all these maroon pixel coordinates. The area inside and on the boundary of this hull defines the Region of Interest (ROI).\n4.  Initializes the output grid to white (0).\n5.  Copies the original maroon pixels (9) to the output grid.\n6.  Performs a multi-source Breadth-First Search (BFS) starting simultaneously from all maroon pixels, using Chebyshev distance (8-directional steps). This calculates the shortest distance from each grid cell to the nearest maroon object(s) and identifies which object(s) are closest.\n7.  Colors the output grid pixels based on the input color, ROI status, and BFS results:\n    a.  Maroon (9) input pixels remain maroon (9).\n    b.  White (0) input pixels *within* the ROI are colored:\n        i.   Green (3) if uniquely closest to one maroon object.\n        ii.  Blue (1) if equidistant from multiple maroon objects.\n        iii. White (0) if unreachable by the BFS within the ROI (unlikely if maroon objects exist).\n    c.  White (0) input pixels *outside* the ROI remain white (0).\n    d.  Any other input pixel color (not 0 or 9) becomes white (0) in the output.\n\"\"\"\n\n# Helper function to find connected components of a specific color\ndef find_objects(grid, color_val):\n    \"\"\"\n    Finds connected components of a specific color in the grid using 4-directional adjacency.\n    \n    Args:\n        grid (np.array): The input grid.\n        color_val (int): The color value to find objects of.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of objects, where each object is a set of (row, col) tuples.\n            - dict: A dictionary mapping each pixel coordinate (row, col) belonging \n                    to an object to its unique object ID (1-based integer).\n            - set: A set containing all pixel coordinates (row, col) belonging to any found object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    pixel_to_object_id = {}\n    all_object_pixels = set()\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a pixel of the target color that hasn't been visited\n            if grid[r, c] == color_val and not visited[r, c]:\n                object_id_counter += 1\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    # Add pixel to the current object, map it to the object ID, and add to all pixels set\n                    current_object_pixels.add((row, col))\n                    pixel_to_object_id[(row, col)] = object_id_counter\n                    all_object_pixels.add((row, col))\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color_val and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the completed object to the list\n                if current_object_pixels:\n                    objects.append(current_object_pixels)\n                    \n    return objects, pixel_to_object_id, all_object_pixels\n\n# Helper function to calculate convex hull mask\ndef get_convex_hull_mask(pixels, grid_shape):\n    \"\"\"\n    Calculates the convex hull of a set of pixels and returns a boolean mask\n    representing the filled polygon area within the grid dimensions. Handles\n    cases with fewer than 3 points and potential QHull errors for collinear points.\n\n    Args:\n        pixels (set): A set of (row, col) coordinates.\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        np.array: A boolean mask of shape grid_shape. True for pixels inside\n                  or on the boundary of the convex hull.\n    \"\"\"\n    height, width = grid_shape\n    mask = np.zeros(grid_shape, dtype=bool)\n\n    if not pixels:\n        return mask # No pixels, empty mask\n\n    pixel_array = np.array(list(pixels))\n\n    if len(pixels) == 1:\n        # Single point case\n        r, c = pixel_array[0]\n        if 0 <= r < height and 0 <= c < width:\n            mask[r, c] = True\n        return mask\n        \n    if len(pixels) == 2:\n        # Line segment case - fill the line\n        r0, c0 = pixel_array[0]\n        r1, c1 = pixel_array[1]\n        # Use polygon drawing which handles lines between two points correctly\n        # Ensure points are within bounds before drawing\n        points_r = [p[0] for p in pixel_array]\n        points_c = [p[1] for p in pixel_array]\n        rr, cc = skimg_polygon(points_r, points_c, shape=grid_shape)\n        mask[rr, cc] = True\n        # Also ensure the original pixels themselves are marked True\n        for r, c in pixels:\n             if 0 <= r < height and 0 <= c < width:\n                 mask[r, c] = True\n        return mask\n\n    try:\n        # Standard case: Calculate Convex Hull for 3+ points\n        # ConvexHull expects points as (x, y), which corresponds to (col, row)\n        points_for_hull = pixel_array[:, [1, 0]] # Swap to (col, row)\n        hull = ConvexHull(points_for_hull)\n        \n        # Get the vertices of the hull polygon\n        hull_vertices_xy = points_for_hull[hull.vertices]\n        hull_rows = hull_vertices_xy[:, 1] # Extract row coords\n        hull_cols = hull_vertices_xy[:, 0] # Extract col coords\n        \n        # Fill the polygon defined by the hull vertices\n        rr, cc = skimg_polygon(hull_rows, hull_cols, shape=grid_shape)\n        mask[rr, cc] = True\n        \n    except Exception as e: # Catch potential QhullError (e.g., for collinear points)\n        # Fallback: if convex hull fails (e.g., collinear points), fill the bounding box.\n        # This is an approximation but handles the edge case.\n        print(f\"ConvexHull calculation failed: {e}. Falling back to bounding box fill for ROI.\")\n        min_r, max_r = np.min(pixel_array[:, 0]), np.max(pixel_array[:, 0])\n        min_c, max_c = np.min(pixel_array[:, 1]), np.max(pixel_array[:, 1])\n        # Ensure bounds are within grid limits before slicing\n        min_r, max_r = max(0, min_r), min(height - 1, max_r)\n        min_c, max_c = max(0, min_c), min(width - 1, max_c)\n        mask[min_r : max_r + 1, min_c : max_c + 1] = True\n\n    # Ensure original pixels are definitely included, polygon rasterization might miss edge cases\n    for r, c in pixels:\n         if 0 <= r < height and 0 <= c < width:\n             mask[r, c] = True\n             \n    return mask\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    height, width = input_arr.shape\n    \n    # 1. Identify maroon objects and all maroon pixels\n    maroon_color = 9\n    maroon_objects, pixel_to_object_id, all_maroon_pixels = find_objects(input_arr, maroon_color)\n    \n    # If there are no maroon objects, the transformation likely doesn't apply.\n    # Return the original grid or perhaps an all-white grid depending on task spec.\n    # Based on the logic, returning original seems safer if no sources exist.\n    if not maroon_objects: \n        return input_arr.tolist() \n\n    # 2. Define the Region of Interest (ROI) using Convex Hull\n    roi_mask = get_convex_hull_mask(all_maroon_pixels, (height, width))\n\n    # 3. Initialize helper grids for BFS\n    # Distance grid: stores shortest distance (Chebyshev) to any maroon pixel\n    distance = np.full((height, width), np.inf, dtype=float)\n    # Sources grid: stores sets of object IDs for the closest object(s) at shortest distance\n    sources = np.empty((height, width), dtype=object)\n    for r in range(height):\n        for c in range(width):\n            sources[r, c] = set() # Initialize each cell with an empty set\n\n    # 4. Initialize BFS queue with all maroon pixels\n    queue = deque()\n    for r, c in all_maroon_pixels:\n        # Ensure the pixel is mapped to a valid object ID (should always be true here)\n        if (r, c) in pixel_to_object_id: \n            obj_id = pixel_to_object_id[(r, c)]\n            distance[r, c] = 0.0\n            sources[r, c] = {obj_id} # Source is the object itself\n            queue.append((r, c))\n\n    # 5. Perform Multi-Source BFS (using 8 directions for Chebyshev distance)\n    # Directions: Up, Down, Left, Right, and Diagonals\n    directions = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance[r, c]\n        current_sources = sources[r, c]\n        \n        # Explore 8 neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Calculate distance to neighbor (Chebyshev distance increments by 1 for each step)\n                new_dist = current_dist + 1.0\n                \n                # If we found a shorter path to this neighbor\n                if new_dist < distance[nr, nc]:\n                    distance[nr, nc] = new_dist\n                    sources[nr, nc] = current_sources.copy() # Replace sources\n                    queue.append((nr, nc)) # Add neighbor to queue\n                \n                # If we found another path of the same minimum distance\n                elif new_dist == distance[nr, nc]:\n                    # Add the sources from this path to the existing sources for the neighbor\n                    # No need to re-add to queue, BFS structure guarantees shortest path exploration\n                     sources[nr, nc].update(current_sources)\n\n    # 6. Create the output grid based on BFS results and ROI mask\n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_arr, dtype=int) \n\n    for r in range(height):\n        for c in range(width):\n            input_color = input_arr[r, c]\n            \n            # Preserve original maroon pixels\n            if input_color == maroon_color:\n                output_grid[r, c] = maroon_color\n            # Process original white pixels\n            elif input_color == 0:\n                # Check if the white pixel is within the ROI\n                if roi_mask[r, c]:\n                    # Check if it was reached by the BFS (distance is not infinity)\n                    if distance[r, c] != np.inf:\n                        num_sources = len(sources[r, c])\n                        if num_sources == 1:\n                            output_grid[r, c] = 3 # Green: uniquely closest to one object\n                        elif num_sources > 1:\n                            output_grid[r, c] = 1 # Blue: equidistant from multiple objects\n                        else: # num_sources == 0\n                            # This case (within ROI, finite distance, but 0 sources) should not happen\n                            # with correct BFS logic starting from maroon pixels. Leave as white.\n                             output_grid[r, c] = 0\n                    else:\n                        # Inside ROI but unreachable -> leave white (0)\n                         output_grid[r, c] = 0\n                else:\n                    # White pixel outside ROI -> leave white (0)\n                    output_grid[r, c] = 0\n            # Handle any other input colors (non-maroon, non-white) -> output white (0)\n            else:\n                output_grid[r, c] = 0 # Default other colors to white\n\n    # Convert final numpy array back to list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5965,
    "candidates_token_count": 3268,
    "total_token_count": 9233,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.933556,
  "retries": null
}