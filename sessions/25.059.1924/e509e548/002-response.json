{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Shapes:** Locate all connected components (shapes) of green (value 3) pixels in the input grid. Each distinct connected component will be treated as a separate object.\n\n2.  **Determine Output Color based on shape id**:\n    *   If the shape looks similar to a reversed \"L\", change the color to red (2).\n    *   If the shape is a horizontal or vertical line, change to blue (1).\n    *   If the shape looks like \"U\", change the color to magenta (6).\n\n3.  **Recolor Shapes:** For each identified shape:\n    *   Replace all pixels of color green (3) with respective new colors.\n\n4.  **Preserve Background:** Leave all pixels with a value of 0 (white) unchanged.\n\n5.  **Output:** Create an output grid identical in dimensions to the input grid, with recolored shapes and the unchanged background.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, measurements\n\ndef find_shapes(grid, color):\n    \"\"\"Find connected components of a specific color.\"\"\"\n    colored_pixels = (grid == color).astype(int)\n    labeled_array, num_features = label(colored_pixels)\n    return labeled_array, num_features\n\ndef get_shape_coords(labeled_array, shape_label):\n    \"\"\"Get coordinates of pixels belonging to a specific shape.\"\"\"\n    return np.where(labeled_array == shape_label)\n\ndef is_line(coords):\n    \"\"\"Determine if a shape is approximately a line (horizontal or vertical).\"\"\"\n    rows = coords[0]\n    cols = coords[1]\n    if len(set(rows)) == 1 or len(set(cols)) == 1:\n        return True\n\n    # Check for near-linearity allowing some tolerance\n    if len(rows) > 2:  # Check only if more than 2 points to avoid division by zero/small numbers\n      row_range = np.max(rows) - np.min(rows)\n      col_range = np.max(cols) - np.min(cols)\n\n      # If primarily horizontal or vertical (with a small tolerance)\n      if (row_range > 0 and col_range/max(1,row_range) < 0.2) or \\\n         (col_range > 0 and row_range/max(1,col_range) < 0.2):\n          return True\n\n    return False\n\ndef is_reversed_L(coords):\n    \"\"\"\n    Determine if a shape resembles a reversed \"L\". This is a simplified check\n    and might need refinement for more complex cases or rotations.\n\n    A simple heuristic: check if it has two \"arms\" that meet at a near-90 degree angle.\n    This is approximated by looking for distinct row and column clusters.\n    \"\"\"\n    rows = coords[0]\n    cols = coords[1]\n    if len(rows) < 3 : return False\n\n    # divide into 3 segments and calculate the center of mass for each one.\n    indices = np.argsort(rows)\n    rows_sorted = rows[indices]\n    cols_sorted = cols[indices]\n    \n    segment_size = len(rows) // 3\n\n    if (segment_size == 0): return False\n    \n    segments = []\n    for i in range(3):\n        start_index = i * segment_size\n        end_index = (i + 1) * segment_size if i < 2 else len(rows)\n        segments.append((rows_sorted[start_index:end_index], cols_sorted[start_index:end_index]))\n    \n    centroids = []\n    for segment in segments:\n      centroids.append((np.mean(segment[0]), np.mean(segment[1])))\n\n    # Check if the center point connects the other two and that those lines are orthogonal\n    if len(centroids) == 3:\n        # Check if the middle point is near the first point in either row/col\n        dist1_row = abs(centroids[0][0]- centroids[1][0]) < 2\n        dist1_col = abs(centroids[0][1] - centroids[1][1]) < 2\n        dist2_row = abs(centroids[1][0]- centroids[2][0]) < 2\n        dist2_col = abs(centroids[1][1] - centroids[2][1]) < 2\n\n        if dist1_row and dist2_col or dist1_col and dist2_row :\n            return True\n\n    return False\n\ndef is_U(coords):\n    \"\"\"\n    Determine if shape resembles \"U\". Very basic heuristic.  Could use refinement\n    \"\"\"\n    rows = coords[0]\n    cols = coords[1]\n\n    if len(rows) < 3: return False # Need at least 3 pixels\n\n    min_row, max_row = np.min(rows), np.max(rows)\n    min_col, max_col = np.min(cols), np.max(cols)\n\n    # Check if more pixels are towards the top (smaller row indices), suggesting a \"U\" shape.\n    top_count = np.sum(rows == min_row)\n    bottom_count = np.sum(rows == max_row)\n\n    if top_count > 1 and bottom_count > 1:\n        return True\n\n\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the observed rules:\n    - Green shapes are identified and recolored based on their shape.\n    - Background (white, 0) remains unchanged.\n    \"\"\"\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    labeled_array, num_features = find_shapes(input_grid, 3)\n\n    # change output pixels\n    for i in range(1, num_features + 1):\n        coords = get_shape_coords(labeled_array, i)\n        if is_line(coords):\n            output_grid[coords] = 1  # Blue\n        elif is_reversed_L(coords):\n            output_grid[coords] = 2  # Red\n        elif is_U(coords):\n            output_grid[coords] = 6 # Magenta\n        else:\n            #default to blue\n            output_grid[coords] = 1\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6171,
    "candidates_token_count": 1462,
    "total_token_count": 7633,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 17.462211,
  "response_file": "002-response.json"
}