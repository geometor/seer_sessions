{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation rule involves identifying horizontal and vertical segments of gray pixels (color 5).\nThese gray segments act as triggers and boundaries for propagating adjacent colored patterns (non-white 0, non-gray 5) into adjacent white space (color 0).\n\n1.  **Horizontal Propagation:** If a non-white, non-gray pixel exists immediately below a horizontal gray segment, its color is propagated horizontally to the right, filling any white pixels in the same row, up to the end column of the gray segment above it.\n\n2.  **Vertical Propagation:** If a pattern (a connected block of non-white, non-gray pixels) exists immediately to the right of a vertical gray segment, this pattern block is tiled/repeated vertically upwards, filling white space in the same columns, up to the top row of the gray segment. The tiling repeats the source pattern block cyclically from bottom to top.\n\nThe process involves:\n- Finding all maximal gray segments (horizontal and vertical).\n- For each segment, finding the adjacent source pattern (if any).\n- Applying the corresponding propagation rule (horizontal fill or vertical tiling) to modify a copy of the input grid.\n\"\"\"\n\ndef find_connected_component_bbox(grid, seed_points, r_min_bound, r_max_bound, c_min_bound):\n    \"\"\"\n    Finds the bounding box of the connected component of non-white, non-gray pixels\n    containing the seed points, constrained by row and column bounds. Uses BFS.\n    \"\"\"\n    if not seed_points:\n        return None\n\n    H, W = grid.shape\n    q = deque(seed_points)\n    visited = set(seed_points)\n    component_points = set(seed_points)\n\n    min_r, max_r = float('inf'), float('-inf')\n    min_c, max_c = float('inf'), float('-inf')\n\n    for r, c in seed_points:\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n\n    while q:\n        r, c = q.popleft()\n\n        # Update bounding box based on component points found so far\n        min_r = min(min_r, r)\n        max_r = max(max_r, r)\n        min_c = min(min_c, c)\n        max_c = max(max_c, c)\n\n        # Explore neighbors (4-way adjacency)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check grid bounds\n            if not (0 <= nr < H and 0 <= nc < W):\n                continue\n\n            # Check task-specific bounds\n            if not (r_min_bound <= nr <= r_max_bound and nc >= c_min_bound):\n                continue\n\n            # Check if neighbor is part of the component (non-white, non-gray)\n            if grid[nr, nc] == 0 or grid[nr, nc] == 5:\n                continue\n\n            # Check if visited\n            if (nr, nc) in visited:\n                continue\n\n            # Add valid neighbor to queue, visited set, and component points\n            visited.add((nr, nc))\n            q.append((nr, nc))\n            component_points.add((nr, nc))\n\n    # Recompute exact bbox from all component points found\n    if not component_points:\n        return None # Should not happen if seed_points is not empty\n\n    final_min_r = min(r for r, c in component_points)\n    final_max_r = max(r for r, c in component_points)\n    final_min_c = min(c for r, c in component_points)\n    final_max_c = max(c for r, c in component_points)\n\n    return final_min_r, final_max_r, final_min_c, final_max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the propagation rules based on gray segments and adjacent patterns.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    H, W = input_np.shape\n\n    # --- Horizontal Propagation ---\n    processed_horizontal_starts = set()\n    for r in range(H):\n        for c in range(W):\n            if (r, c) in processed_horizontal_starts:\n                continue\n            # Found potential start of a horizontal gray segment\n            if input_np[r, c] == 5:\n                c_start = c\n                c_end = c\n                # Find the end of the horizontal segment\n                while c_end + 1 < W and input_np[r, c_end + 1] == 5:\n                    c_end += 1\n\n                # Mark all pixels in this segment as processed for starting horizontal checks\n                for k in range(c_start, c_end + 1):\n                    processed_horizontal_starts.add((r, k))\n\n                # Check row below for source pixels\n                r_source_row = r + 1\n                if r_source_row < H:\n                    for c_source in range(c_start, c_end + 1):\n                        source_color = input_np[r_source_row, c_source]\n                        # Check if it's a valid source color (non-white, non-gray)\n                        if source_color != 0 and source_color != 5:\n                            # Propagate horizontally to the right within bounds\n                            for c_fill in range(c_source + 1, c_end + 1):\n                                # Only fill if the target pixel is white\n                                if output_np[r_source_row, c_fill] == 0:\n                                    output_np[r_source_row, c_fill] = source_color\n                                # Stop propagation in this row if we hit a non-white pixel\n                                elif output_np[r_source_row, c_fill] != source_color:\n                                     # This behavior (stopping) isn't explicitly shown but seems safer\n                                     # than overwriting existing colors. Let's stick to only filling white (0).\n                                     pass # Keep the original logic, only fill 0s.\n\n\n    # --- Vertical Propagation ---\n    processed_vertical_starts = set()\n    for c in range(W):\n        for r in range(H):\n            if (r, c) in processed_vertical_starts:\n                continue\n            # Found potential start of a vertical gray segment\n            if input_np[r, c] == 5:\n                r_top = r\n                r_bottom = r\n                # Find the end of the vertical segment\n                while r_bottom + 1 < H and input_np[r_bottom + 1, c] == 5:\n                    r_bottom += 1\n\n                # Mark all pixels in this segment as processed for starting vertical checks\n                for k in range(r_top, r_bottom + 1):\n                    processed_vertical_starts.add((k, c))\n\n                # Check column to the right for source pattern seeds\n                c_adj_col = c + 1\n                if c_adj_col < W:\n                    seed_points = []\n                    for r_adj in range(r_top, r_bottom + 1):\n                        if input_np[r_adj, c_adj_col] != 0 and input_np[r_adj, c_adj_col] != 5:\n                            seed_points.append((r_adj, c_adj_col))\n\n                    if not seed_points:\n                        continue # No adjacent pattern found for this segment\n\n                    # Find the bounding box of the connected component starting from the seeds\n                    bbox = find_connected_component_bbox(input_np, seed_points, r_top, r_bottom, c_adj_col)\n\n                    if bbox is None:\n                        continue # No valid component found\n\n                    r_source_top, r_source_bottom, c_source_left, c_source_right = bbox\n                    pattern_height = r_source_bottom - r_source_top + 1\n\n                    if pattern_height <= 0:\n                        continue # Invalid pattern height\n\n                    # Perform vertical tiling upwards\n                    for r_target in range(r_source_top - 1, r_top - 1, -1): # Iterate target rows upwards (r_source_top-1 down to r_top)\n                        # Calculate corresponding source row using modulo arithmetic\n                        # We want to map r_target to a row within [r_source_top, r_source_bottom]\n                        # The pattern repeats every pattern_height rows.\n                        # The row r_source_bottom should map to r_source_bottom - pattern_height, etc.\n                        # r_source = r_source_bottom - (distance_from_bottom % pattern_height)\n                        distance_from_r_source_bottom = r_source_bottom - r_target\n                        r_source = r_source_bottom - (distance_from_r_source_bottom % pattern_height)\n\n                        # Fill the target row based on the source row pattern\n                        for c_target in range(c_source_left, c_source_right + 1):\n                            # Only fill if the target pixel is white\n                            if output_np[r_target, c_target] == 0:\n                                source_color = input_np[r_source, c_target]\n                                # Ensure we only copy non-white/non-gray from pattern block in case bbox included some zeros/grays unexpectedly\n                                if source_color != 0 and source_color != 5:\n                                     output_np[r_target, c_target] = source_color\n\n\n    # Convert back to list of lists for the required output format\n    output_list = output_np.tolist()\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4556,
    "candidates_token_count": 2334,
    "total_token_count": 6890,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 119.006304,
  "retries": null
}