{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nInitialize the output_grid as an identical copy of the input_grid.\nScan the input_grid to find all occurrences of a specific \"cross\" pattern. A cross is defined by:\n    *   A central pixel at coordinates (r, c) with color C1, where C1 is not white (0).\n    *   The four cardinal neighbors (up, down, left, right) of the center pixel all have the same color C2, where C2 is not white (0) and C1 is different from C2.\n    *   The four diagonal neighbors of the center pixel are all white (0) (checking only those neighbors that fall within the grid boundaries).\nFor each identified cross pattern with center (r, c), center color C1, and arm color C2:\n    a.  Define the set of eight diagonal offsets: D = {(-2, -2), (-2, 2), (-1, -1), (-1, 1), (1, -1), (1, 1), (2, -2), (2, 2)}.\n    b.  For each offset (dr, dc) in D:\n        i.  Calculate the target coordinates (target_r, target_c) = (r + dr, c + dc).\n        ii. If (target_r, target_c) is within the grid bounds, update the output_grid at (target_r, target_c) to color C1 (overwriting any previous color).\n    c.  Define the set of four extended cardinal offsets: E = {(-2, 0), (2, 0), (0, -2), (0, 2)}.\n    d.  For each offset (dr, dc) in E:\n        i.  Calculate the target coordinates (target_r, target_c) = (r + dr, c + dc).\n        ii. If (target_r, target_c) is within the grid bounds, update the output_grid at (target_r, target_c) to color C2 (overwriting any previous color).\nAfter processing all identified crosses, return the final output_grid.\n\"\"\"\n\ndef _is_within_bounds(r, c, height, width):\n  \"\"\"Checks if coordinates (r, c) are within the grid dimensions.\"\"\"\n  return 0 <= r < height and 0 <= c < width\n\ndef _find_crosses(grid, height, width):\n  \"\"\"\n  Finds all cross patterns in the grid.\n\n  Yields:\n      tuple: (center_row, center_col, center_color, arm_color)\n             for each valid cross found.\n  \"\"\"\n  cardinal_offsets = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right\n  diagonal_offsets = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # Diagonals\n\n  # Iterate through potential center cells (can't be on the very edge for a full cross)\n  for r in range(1, height - 1):\n      for c in range(1, width - 1):\n          center_color_c1 = grid[r, c]\n\n          # 1. Center must not be white\n          if center_color_c1 == 0:\n              continue\n\n          arm_color_c2 = None\n          valid_cardinal = True\n\n          # 2. Check cardinal neighbors (arms)\n          for dr, dc in cardinal_offsets:\n              nr, nc = r + dr, c + dc\n              neighbor_color = grid[nr, nc]\n\n              # Arms must not be white and not same color as center\n              if neighbor_color == 0 or neighbor_color == center_color_c1:\n                  valid_cardinal = False\n                  break\n\n              if arm_color_c2 is None:\n                  arm_color_c2 = neighbor_color # Set expected arm color C2\n              elif neighbor_color != arm_color_c2:\n                  valid_cardinal = False # All arms must have same color C2\n                  break\n\n          if not valid_cardinal or arm_color_c2 is None:\n              continue # Move to next potential center if cardinal checks fail\n\n          # 3. Check diagonal neighbors (must be white)\n          valid_diagonal = True\n          for dr, dc in diagonal_offsets:\n              nr, nc = r + dr, c + dc\n              # Only check if within bounds, edge crosses might not have all diagonals\n              if _is_within_bounds(nr, nc, height, width):\n                  if grid[nr, nc] != 0:\n                      valid_diagonal = False\n                      break # Diagonal neighbor is not white\n\n          if valid_diagonal:\n              # If all checks pass, yield the cross details needed for placement\n              yield r, c, center_color_c1, arm_color_c2\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation: finds crosses and places the center color\n    at specific diagonal offsets and the arm color at extended cardinal offsets.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n\n    # Define the required offsets from the center\n    diagonal_placement_offsets = [\n        (-2, -2), (-2, 2),\n        (-1, -1), (-1, 1),\n        (1, -1), (1, 1),\n        (2, -2), (2, 2)\n    ]\n    extended_cardinal_placement_offsets = [\n        (-2, 0), (2, 0),\n        (0, -2), (0, 2)\n    ]\n\n    # Find all cross patterns in the input grid\n    # Now includes arm_color_c2\n    crosses = list(_find_crosses(input_grid_np, height, width))\n\n    # Process each found cross\n    for center_r, center_c, center_color_c1, arm_color_c2 in crosses:\n        # Apply the 8 diagonal placement offsets using the center color C1\n        for dr, dc in diagonal_placement_offsets:\n            target_r, target_c = center_r + dr, center_c + dc\n\n            # Check if the target coordinate is within bounds\n            if _is_within_bounds(target_r, target_c, height, width):\n                # Place the center color C1 at the target destination\n                output_grid[target_r, target_c] = center_color_c1\n\n        # Apply the 4 extended cardinal placement offsets using the arm color C2\n        for dr, dc in extended_cardinal_placement_offsets:\n            target_r, target_c = center_r + dr, center_c + dc\n\n            # Check if the target coordinate is within bounds\n            if _is_within_bounds(target_r, target_c, height, width):\n                # Place the arm color C2 at the target destination\n                output_grid[target_r, target_c] = arm_color_c2\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6977,
    "candidates_token_count": 1732,
    "total_token_count": 8709,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.65111,
  "retries": null
}