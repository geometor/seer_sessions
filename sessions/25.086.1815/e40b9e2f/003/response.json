{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the largest contiguous object (main_object) and its color (main_color).\nIdentifies the color of other non-background pixels (seed_color).\nIterates through all background (white, 0) pixels in the grid.\nIf a background pixel is diagonally adjacent (up-left, up-right, down-left, down-right) to any pixel belonging to the main_object,\nchange the color of that background pixel in the output grid to the seed_color.\nPreserve all original non-background pixels.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (list of (row, col) tuples), and 'size'.\n              Returns an empty list if no non-background pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start BFS if we find an unvisited non-background pixel\n            if color != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_color = color\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n\n                    # Check cardinal neighbors for connectivity within the same object\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Add the found object to the list\n                if obj_pixels:\n                    objects.append({'color': current_color, 'pixels': obj_pixels, 'size': len(obj_pixels)})\n    return objects\n\ndef get_largest_object(objects):\n    \"\"\"\n    Finds the object with the maximum number of pixels from a list of objects.\n\n    Args:\n        objects (list): A list of object dictionaries as returned by find_objects.\n\n    Returns:\n        dict: The dictionary representing the largest object, or None if the list is empty.\n    \"\"\"\n    if not objects:\n        return None\n    # Find the object with the maximum 'size'\n    return max(objects, key=lambda obj: obj['size'])\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # 1. Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Find all non-background objects in the input grid\n    objects = find_objects(input_grid)\n\n    # If no objects are found, return the original grid\n    if not objects:\n        return output_grid\n\n    # 3. Identify the largest object and its color (main_color)\n    largest_object = get_largest_object(objects)\n    if largest_object is None: # Should not happen if objects is not empty\n        return output_grid\n        \n    main_color = largest_object['color']\n    # Create a set of pixel coordinates for the largest object for efficient lookup (optional)\n    # main_object_pixels = set(largest_object['pixels']) \n\n    # 4. Identify the seed_color (the color of objects other than the largest one)\n    all_colors = set(obj['color'] for obj in objects)\n    seed_colors = all_colors - {main_color}\n\n    # Assume there is exactly one seed color based on examples.\n    if len(seed_colors) != 1:\n        # Handle cases not covered by examples if needed, for now return unchanged.\n        return output_grid \n    \n    seed_color = seed_colors.pop() # Get the single seed color\n\n    # 5. Iterate through each cell of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # 6. Check if the current cell is background (color 0)\n            if input_grid[r, c] == 0:\n                has_main_diag_neighbor = False\n                # a. Check its DIAGONAL neighbors\n                for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]: # Diagonal offsets\n                    nr, nc = r + dr, c + dc\n                    # b. Check if the neighbor is within bounds and has the main_color\n                    if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] == main_color:\n                        has_main_diag_neighbor = True\n                        break  # Found a diagonal neighbor with main_color\n\n                # i. If a main_color diagonal neighbor was found, change the output pixel to seed_color\n                if has_main_diag_neighbor:\n                    output_grid[r, c] = seed_color\n\n    # 7. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4490,
    "candidates_token_count": 1353,
    "total_token_count": 5843,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 88.669501,
  "retries": null
}