{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_unique_contiguous_gray_line(grid):\n    \"\"\"\n    Finds all gray pixels (5) and checks if they form exactly one\n    contiguous vertical OR horizontal line.\n    Returns a tuple (type, coord, min_val, max_val) or None.\n    - type: 'vertical' or 'horizontal'.\n    - coord: The column index (c_gray) if vertical, or row index (r_gray) if horizontal.\n    - min_val: The minimum row index (r_min) if vertical, or minimum column index (c_min) if horizontal.\n    - max_val: The maximum row index (r_max) if vertical, or maximum column index (c_max) if horizontal.\n    Returns None if no gray pixels are found, or if they don't form exactly one\n    contiguous vertical or horizontal line.\n    \"\"\"\n    rows, cols = grid.shape\n    gray_pixels = []\n    # Collect coordinates of all gray pixels\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 5:\n                gray_pixels.append((r, c))\n\n    # Return None if no gray pixels found\n    if not gray_pixels:\n        return None\n\n    num_gray = len(gray_pixels)\n\n    # Check if all gray pixels form a single contiguous vertical line\n    gray_pixels.sort() # Sort primarily by row, then by column\n    first_r, first_c = gray_pixels[0]\n    is_vertical = all(c == first_c for r, c in gray_pixels)\n    if is_vertical:\n        min_r = first_r\n        max_r = gray_pixels[-1][0]\n        # Check contiguity: number of pixels must match row span,\n        # and rows must be sequential.\n        is_contiguous_vertical = (num_gray == (max_r - min_r + 1)) and \\\n                                 all(gray_pixels[i][0] == min_r + i for i in range(num_gray))\n        if is_contiguous_vertical:\n             return ('vertical', first_c, min_r, max_r)\n\n    # Check if all gray pixels form a single contiguous horizontal line\n    # Sort primarily by column, then by row, needed for horizontal check\n    gray_pixels.sort(key=lambda x: (x[1], x[0]))\n    first_r, first_c = gray_pixels[0] # Potentially different first_r/first_c after resort\n    is_horizontal = all(r == first_r for r, c in gray_pixels)\n    if is_horizontal:\n        min_c = first_c\n        max_c = gray_pixels[-1][1]\n        # Check contiguity: number of pixels must match col span,\n        # and columns must be sequential.\n        is_contiguous_horizontal = (num_gray == (max_c - min_c + 1)) and \\\n                                   all(gray_pixels[i][1] == min_c + i for i in range(num_gray))\n        if is_contiguous_horizontal:\n            return ('horizontal', first_r, min_c, max_c)\n\n    # If all gray pixels did not form exactly one contiguous vertical or horizontal line\n    return None\n\ndef find_maroon_pixel(grid):\n    \"\"\"\n    Finds the coordinates (row, col) of a single maroon pixel (9).\n    Returns (r_m, c_m) if exactly one maroon pixel is found, otherwise returns None.\n    \"\"\"\n    rows, cols = grid.shape\n    maroon_coords = []\n    # Collect coordinates of all maroon pixels\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 9:\n                maroon_coords.append((r, c))\n\n    # Return coordinates only if exactly one maroon pixel exists\n    if len(maroon_coords) == 1:\n        return maroon_coords[0]\n    else:\n        return None # Zero or multiple maroon pixels found\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the relative position of a single contiguous gray line (color 5)\n    and a single maroon pixel (color 9). Changes specific yellow pixels (color 4) to orange (color 7).\n\n    Rule Cases:\n    1. Vertical Gray Line, Maroon Left: If maroon is one step left (c_m = c_gray - 1) and row-aligned\n       (r_min <= r_m <= r_max), change yellow pixels within a calculated bounding box to the right\n       of the gray line to orange. The box starts at the top row of the gray line and extends downwards.\n       Its width is twice the height of the gray line, starting 2 columns right of the gray line.\n    2. Vertical Gray Line, Maroon Right: If maroon is one step right (c_m = c_gray + 1) and row-aligned\n       (r_min <= r_m <= r_max), change yellow pixels in the region to the left of the gray line\n       (c < c_gray) and between the maroon row and the bottom of the gray line (inclusive, r_m <= r <= r_max)\n       to orange.\n    3. Horizontal Gray Line, Maroon Below: If maroon is one step below (r_m = r_gray + 1) and col-aligned\n       (c_min <= c_m <= c_max), the transformation observed in the examples does not follow a clear\n       geometric rule related to the gray/maroon positions analyzed so far. Example 1, which fits this case,\n       shows no change between input and output. Therefore, this function returns the input grid unchanged\n       for this specific configuration.\n    4. Other Cases: If no unique contiguous gray line, no unique maroon pixel, or their relative positions\n       don't match cases 1, 2, or 3, the input grid is returned unchanged.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    # Create a copy to modify, ensuring the original input is not changed\n    output_grid_np = np.copy(input_grid_np)\n\n    # --- Step 1: Find the required structures ---\n    # Find exactly one contiguous gray line (vertical or horizontal)\n    gray_line_info = find_unique_contiguous_gray_line(input_grid_np)\n    # Find exactly one maroon pixel\n    maroon_pos = find_maroon_pixel(input_grid_np)\n\n    # --- Step 2: Check if required structures exist uniquely ---\n    # If either structure is missing or not unique, no transformation applies\n    if gray_line_info is None or maroon_pos is None:\n        return input_grid # Return the original input grid\n\n    # Unpack structure details\n    line_type, line_coord, line_min, line_max = gray_line_info\n    r_m, c_m = maroon_pos\n\n    # --- Step 3: Apply transformation based on the identified case ---\n    transformation_applied = False\n\n    # Case 1: Vertical Gray Line, Maroon Immediately Left\n    if line_type == 'vertical':\n        c_gray, r_min_gray, r_max_gray = line_coord, line_min, line_max\n        # Check relative position: maroon left and row-aligned\n        if c_m == c_gray - 1 and r_min_gray <= r_m <= r_max_gray:\n            # Calculate bounding box parameters\n            height_gray = r_max_gray - r_min_gray + 1\n            # Row start is the top of the gray line\n            r_start_box = r_min_gray\n            # Row end depends on gray line span and maroon row relative position\n            r_end_box = r_max_gray + (r_m - r_min_gray + 1)\n            # Column start is 2 columns to the right of the gray line\n            c_start_box = c_gray + 2\n            # Column end depends on gray line column and height * 2\n            c_end_box = c_gray + height_gray * 2\n\n            # Apply transformation: Change yellow (4) to orange (7) within the box\n            # Iterate safely within grid boundaries\n            for r in range(max(0, r_start_box), min(rows, r_end_box + 1)):\n                for c in range(max(0, c_start_box), min(cols, c_end_box + 1)):\n                    if output_grid_np[r, c] == 4: # If pixel is yellow\n                        output_grid_np[r, c] = 7 # Change to orange\n            transformation_applied = True\n\n    # Case 2: Vertical Gray Line, Maroon Immediately Right\n    elif line_type == 'vertical': # Check vertical type again for clarity\n        c_gray, r_min_gray, r_max_gray = line_coord, line_min, line_max\n        # Check relative position: maroon right and row-aligned\n        if c_m == c_gray + 1 and r_min_gray <= r_m <= r_max_gray:\n            # Apply transformation in the specified region to the left\n            # Iterate through rows from maroon row down to gray line bottom\n            for r in range(max(0, r_m), min(rows, r_max_gray + 1)):\n                # Iterate through columns strictly left of the gray line\n                for c in range(0, max(0, c_gray)): # c goes from 0 to c_gray-1\n                    if output_grid_np[r, c] == 4: # If pixel is yellow\n                        output_grid_np[r, c] = 7 # Change to orange\n            transformation_applied = True\n\n    # Case 3: Horizontal Gray Line, Maroon Immediately Below\n    elif line_type == 'horizontal':\n        r_gray, c_min_gray, c_max_gray = line_coord, line_min, line_max\n        # Check relative position: maroon below and column-aligned\n        if r_m == r_gray + 1 and c_min_gray <= c_m <= c_max_gray:\n            # Based on Example 1, no change occurs in this configuration.\n            # The 'pass' means transformation_applied remains False.\n            pass\n\n    # --- Step 4: Return the result ---\n    if transformation_applied:\n        # If a transformation was made, return the modified grid\n        return output_grid_np.tolist()\n    else:\n        # If no conditions matched or Case 3 triggered, return the original input grid\n        return input_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10847,
    "candidates_token_count": 2504,
    "total_token_count": 13351,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 45.664628,
  "retries": null
}