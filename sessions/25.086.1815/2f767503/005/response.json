{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule applies conditionally based on the presence and relative positioning of specific structures: a vertical contiguous gray line (color 5) and a single maroon pixel (color 9).\n\n1.  **Identify Structures:**\n    *   Search for a contiguous vertical line composed solely of gray pixels (color 5). Determine its column index (`c_gray`), top row index (`r_min_gray`), and bottom row index (`r_max_gray`).\n    *   Search for a maroon pixel (color 9) and determine its coordinates (`r_m`, `c_m`).\n\n2.  **Check Trigger Condition:**\n    *   The transformation is triggered *only if* both the vertical gray line and the maroon pixel exist, *and* the maroon pixel is located immediately to the left of the gray line (i.e., `c_m == c_gray - 1`) and its row index `r_m` is within the vertical span of the gray line (i.e., `r_min_gray <= r_m <= r_max_gray`).\n\n3.  **Apply Transformation (if Triggered):**\n    *   If the trigger condition is met, calculate a bounding box using parameters derived from the gray line and maroon pixel:\n        *   `height_gray = r_max_gray - r_min_gray + 1`\n        *   `r_start = r_min_gray`\n        *   `r_end = r_max_gray + (r_m - r_min_gray + 1)`\n        *   `c_start = c_gray + (c_gray - c_m + 1)`\n        *   `c_end = c_gray + height_gray * 2`\n    *   Iterate through all pixels within this calculated bounding box (inclusive of boundaries).\n    *   Change any yellow pixel (color 4) found within this bounding box to orange (color 7).\n    *   All other pixels remain unchanged.\n\n4.  **No Transformation (if Not Triggered):**\n    *   If the trigger condition is not met (e.g., no vertical gray line, no maroon pixel, or incorrect relative positioning), the input grid is returned completely unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_vertical_contiguous_gray_line(grid):\n    \"\"\"\n    Finds all gray pixels (5) and checks if they form a single contiguous vertical line.\n    Returns the column index (c_gray), min row index (r_min), and max row index (r_max)\n    if such a line is found, otherwise returns None, None, None.\n    \"\"\"\n    rows, cols = grid.shape\n    gray_pixels = []\n    # Collect coordinates of all gray pixels\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 5:\n                gray_pixels.append((r, c))\n\n    # Return None if no gray pixels found\n    if not gray_pixels:\n        return None, None, None\n\n    # Check if all gray pixels are in the same column\n    first_col = gray_pixels[0][1]\n    if not all(c == first_col for r, c in gray_pixels):\n        return None, None, None # Not all in the same column (not vertical)\n\n    # Check for vertical contiguity\n    gray_rows = sorted([r for r, c in gray_pixels])\n    min_row, max_row = gray_rows[0], gray_rows[-1]\n\n    # Verify contiguity: the number of gray pixels must match the row span,\n    # and they must form a sequence without gaps.\n    is_contiguous = (len(gray_rows) == (max_row - min_row + 1)) and \\\n                    all(gray_rows[i] == min_row + i for i in range(len(gray_rows)))\n\n    if not is_contiguous:\n        return None, None, None # Not contiguous\n\n    return first_col, min_row, max_row\n\ndef find_maroon_pixel(grid):\n    \"\"\"\n    Finds the coordinates (row, col) of the first maroon pixel (9) encountered.\n    Returns (r_m, c_m) or None if not found.\n    Assumes at most one maroon pixel based on examples.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 9:\n                return r, c\n    return None # No maroon pixel found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the gray line, maroon pixel,\n    and calculated bounding box, if the trigger condition is met.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Identify structures: vertical contiguous gray line and maroon pixel\n    c_gray, r_min_gray, r_max_gray = find_vertical_contiguous_gray_line(input_grid_np)\n    maroon_pos = find_maroon_pixel(input_grid_np)\n\n    # Initialize trigger flag\n    trigger = False\n\n    # 2. Check Trigger Condition\n    if c_gray is not None and maroon_pos is not None:\n        r_m, c_m = maroon_pos\n        # Check if maroon is immediately left of the gray line's column\n        is_left = (c_m == c_gray - 1)\n        # Check if maroon's row aligns with the gray line's vertical span\n        is_aligned = (r_min_gray <= r_m <= r_max_gray)\n\n        # Set trigger if both conditions are met\n        if is_left and is_aligned:\n            trigger = True\n\n    # 3. Perform Transformation (if triggered)\n    if trigger:\n        # Calculate bounding box parameters based on gray line and maroon position\n        height_gray = r_max_gray - r_min_gray + 1\n        # Row start is the top of the gray line\n        r_start_box = r_min_gray\n        # Row end depends on gray line span and maroon row relative position\n        r_end_box = r_max_gray + (r_m - r_min_gray + 1)\n        # Column start depends on gray line and maroon column relative position\n        # Since c_m = c_gray - 1, (c_gray - c_m + 1) simplifies to (c_gray - (c_gray-1) + 1) = (1 + 1) = 2\n        c_start_box = c_gray + 2 # Derived from c_gray + (c_gray - c_m + 1)\n        # Column end depends on gray line column and height\n        c_end_box = c_gray + height_gray * 2\n\n        # Create a copy of the grid to modify\n        output_grid_np = np.copy(input_grid_np)\n\n        # Iterate through the pixels within the bounding box\n        # Ensure indices stay within grid boundaries\n        for r in range(max(0, r_start_box), min(rows, r_end_box + 1)):\n            for c in range(max(0, c_start_box), min(cols, c_end_box + 1)):\n                # Check if the pixel is yellow (4)\n                if input_grid_np[r, c] == 4:\n                    # Change the color to orange (7) in the output grid\n                    output_grid_np[r, c] = 7\n\n        # Return the modified grid as a list of lists\n        return output_grid_np.tolist()\n    else:\n        # 4. No Transformation: If trigger condition not met, return the original input grid\n        return input_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6239,
    "candidates_token_count": 1816,
    "total_token_count": 8055,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.833428,
  "retries": null
}