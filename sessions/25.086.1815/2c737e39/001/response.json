{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies two key structures in the input grid: a multi-pixel, potentially multi-color 'pattern object' containing at least one gray (5) pixel, and a single, isolated gray (5) 'marker pixel'.\nThe transformation copies the input grid to the output grid, then overlays a modified version of the 'pattern object' onto the output grid.\nThe position of this overlay is determined by the 'marker pixel'. Specifically, the location of the gray pixel *within* the original pattern object is mapped to the location of the marker pixel in the input grid.\nThe copied pattern object is identical to the original, except the gray pixel corresponding to the one in the original pattern object is replaced with a white (0) pixel.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"\n    Finds all connected components of non-background pixels.\n    Connectivity is based on 4-way adjacency (up, down, left, right).\n    A component includes all connected non-zero pixels, regardless of their color.\n    \"\"\"\n    H, W = grid.shape\n    visited = set()\n    components = []\n\n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                # Start BFS for a new component\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                current_component_coords = set([(r, c)])\n                component_pixels = {(r, c): grid[r, c]}\n                contains_gray = (grid[r, c] == 5)\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < H and 0 <= nc < W and grid[nr, nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            current_component_coords.add((nr, nc))\n                            pixel_color = grid[nr, nc]\n                            component_pixels[(nr, nc)] = pixel_color\n                            if pixel_color == 5:\n                                contains_gray = True\n                \n                components.append({\n                    'coords': current_component_coords,\n                    'pixels': component_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'contains_gray': contains_gray,\n                    'size': len(current_component_coords)\n                })\n                \n    return components\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule described above.\n    \"\"\"\n    H, W = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Find all connected components of non-background pixels\n    components = find_connected_components(input_grid)\n\n    # 2. Identify the pattern object and the marker pixel\n    pattern_object = None\n    marker_pixel_coord = None\n\n    for comp in components:\n        # A single gray pixel is the marker\n        if comp['size'] == 1 and comp['contains_gray']: \n            # Assuming only one such marker based on examples\n             marker_pixel_coord = list(comp['coords'])[0] \n        # The largest component containing gray is the pattern object\n        elif comp['contains_gray']:\n             if pattern_object is None or comp['size'] > pattern_object['size']:\n                 pattern_object = comp\n\n    # 3. Check if both pattern and marker were found\n    if pattern_object is None or marker_pixel_coord is None:\n        # If the expected structures aren't found, return the original grid\n        # Or handle error appropriately based on task constraints (not specified)\n        print(\"Warning: Pattern object or marker pixel not found as expected.\")\n        return output_grid \n\n    # 4. Find the coordinate of the gray pixel within the pattern object\n    gray_pixel_in_pattern_coord = None\n    for coord, color in pattern_object['pixels'].items():\n        if color == 5:\n            gray_pixel_in_pattern_coord = coord\n            break # Assume only one gray pixel in the pattern object based on examples\n            \n    if gray_pixel_in_pattern_coord is None:\n         print(\"Warning: Gray pixel not found within the identified pattern object.\")\n         return output_grid\n\n    # 5. Calculate the relative offset of the gray pixel within the pattern's bounding box\n    pat_min_r, pat_min_c, _, _ = pattern_object['bbox']\n    gray_rel_r = gray_pixel_in_pattern_coord[0] - pat_min_r\n    gray_rel_c = gray_pixel_in_pattern_coord[1] - pat_min_c\n\n    # 6. Calculate the target top-left corner for the copied object\n    # The marker pixel's location corresponds to where the gray pixel should land\n    marker_r, marker_c = marker_pixel_coord\n    copy_origin_r = marker_r - gray_rel_r\n    copy_origin_c = marker_c - gray_rel_c\n\n    # 7. Copy the pattern object to the new location, modifying the gray pixel\n    for (r, c), color in pattern_object['pixels'].items():\n        # Relative position within the pattern object\n        rel_r = r - pat_min_r\n        rel_c = c - pat_min_c\n\n        # Target position in the output grid\n        target_r = copy_origin_r + rel_r\n        target_c = copy_origin_c + rel_c\n\n        # Check if the target is within grid bounds\n        if 0 <= target_r < H and 0 <= target_c < W:\n            # Determine the color to write\n            if (r, c) == gray_pixel_in_pattern_coord:\n                # Replace the gray pixel's position with white\n                write_color = 0\n            else:\n                # Copy the original color\n                write_color = color\n            \n            # Write to the output grid\n            output_grid[target_r, target_c] = write_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3835,
    "candidates_token_count": 1584,
    "total_token_count": 5419,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.438847,
  "retries": null
}