{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies non-white (0) and non-magenta (6) pixels as 'markers'.\nIdentifies contiguous shapes made of magenta (6) pixels using 4-way connectivity ('templates').\nAssociates each marker with its spatially closest template shape based on minimum Manhattan distance between the marker and any pixel of the shape. A one-to-one mapping is ensured by processing the globally closest marker-template pairs first.\nFor each associated marker-template pair, creates a new small grid containing the template's shape within its bounding box, colored with the marker's color against a white (0) background.\nDetermines the final arrangement (horizontal or vertical) of these colored shapes based on the spatial range of the original marker positions. If the column range is strictly greater than the row range, arrangement is horizontal; otherwise, it's vertical.\nSorts the colored shapes based on the marker's column index (for horizontal) or row index (for vertical).\nCombines the sorted shapes into a final output grid, padding with white (0) as necessary to align shapes (pad bottom for horizontal, pad right for vertical).\n\"\"\"\n\n# Helper function to find marker pixels\ndef find_marker_pixels(grid):\n    \"\"\"Finds pixels that are not white (0) or magenta (6).\"\"\"\n    markers = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Markers are any color other than white (0) and magenta (6)\n            if color != 0 and color != 6:\n                markers.append({'pos': (r, c), 'color': color})\n    return markers\n\n# Helper function for Manhattan distance\ndef manhattan_distance(p1, p2):\n    \"\"\"Calculates the Manhattan distance between two points (tuples).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n# Helper function to find contiguous shapes using BFS (4-connectivity)\ndef find_shapes(grid, color):\n    \"\"\"Finds contiguous shapes of a specific color using BFS (4-connectivity).\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    shapes = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's the target color and not visited yet, start BFS\n            if grid[r, c] == color and not visited[r, c]:\n                current_shape_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_shape_coords.append((curr_r, curr_c))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # If neighbor is target color and not visited\n                            if grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                if current_shape_coords:\n                    shapes.append({'coords': current_shape_coords}) # Store coordinates list\n                    \n    return shapes\n\n# Helper function to get bounding box\ndef get_bounding_box(coords):\n    \"\"\"Calculates the minimum bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None, None, None, None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return min_r, min_c, height, width\n\n# Helper function to calculate min distance from a point to a set of points\ndef distance_marker_to_shape(marker_pos, shape_coords):\n    \"\"\"Calculates the minimum Manhattan distance from a marker point to any pixel in a shape.\"\"\"\n    min_dist = float('inf')\n    for shape_pos in shape_coords:\n        dist = manhattan_distance(marker_pos, shape_pos)\n        if dist < min_dist:\n            min_dist = dist\n    return min_dist\n\n# Helper function to extract shape and recolor\ndef extract_and_recolor(shape_coords, marker_color):\n    \"\"\"Extracts shape within bounding box and recolors magenta to marker color.\"\"\"\n    if not shape_coords:\n        return None\n        \n    min_r, min_c, height, width = get_bounding_box(shape_coords)\n    \n    # Create the output subgrid, initialized to white (0)\n    subgrid = np.zeros((height, width), dtype=np.uint8)\n    \n    # Fill the subgrid with the marker color where the shape exists\n    for r, c in shape_coords:\n        subgrid[r - min_r, c - min_c] = marker_color\n            \n    return subgrid\n\n# Helper function to combine grids with padding\ndef combine_grids(grids, orientation):\n    \"\"\"Combines multiple grids horizontally or vertically, padding with 0s.\"\"\"\n    if not grids:\n        # Return an empty grid if there are no shapes to combine\n        return np.array([[]], dtype=np.uint8) \n\n    if orientation == 'horizontal':\n        if not any(g.size > 0 for g in grids): # Check if all grids are empty\n            return np.array([[]], dtype=np.uint8)\n        # Find max height among non-empty grids\n        max_height = max(g.shape[0] for g in grids if g.size > 0) if grids else 0\n        padded_grids = []\n        for g in grids:\n            if g.size == 0: # Handle potentially empty grids if needed\n                 # Create an empty grid of correct height to avoid padding errors\n                 padded_g = np.zeros((max_height, 0), dtype=np.uint8)\n            else:\n                 pad_height = max_height - g.shape[0]\n                 # Pad at the bottom\n                 padded_g = np.pad(g, ((0, pad_height), (0, 0)), mode='constant', constant_values=0)\n            padded_grids.append(padded_g)\n        # Filter out potentially zero-width padded grids before hstack\n        padded_grids = [g for g in padded_grids if g.shape[1] > 0]\n        if not padded_grids: return np.array([[]], dtype=np.uint8) # All inputs were empty\n        return np.hstack(padded_grids)\n    else: # vertical\n        if not any(g.size > 0 for g in grids): # Check if all grids are empty\n             return np.array([[]], dtype=np.uint8)\n        # Find max width among non-empty grids\n        max_width = max(g.shape[1] for g in grids if g.size > 0) if grids else 0\n        padded_grids = []\n        for g in grids:\n            if g.size == 0: # Handle potentially empty grids\n                # Create an empty grid of correct width\n                padded_g = np.zeros((0, max_width), dtype=np.uint8)\n            else:\n                pad_width = max_width - g.shape[1]\n                # Pad on the right\n                padded_g = np.pad(g, ((0, 0), (0, pad_width)), mode='constant', constant_values=0)\n            padded_grids.append(padded_g)\n        # Filter out potentially zero-height padded grids before vstack\n        padded_grids = [g for g in padded_grids if g.shape[0] > 0]\n        if not padded_grids: return np.array([[]], dtype=np.uint8) # All inputs were empty\n        return np.vstack(padded_grids)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the specified rules.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=np.uint8)\n\n    # 1. Find marker pixels\n    markers = find_marker_pixels(input_grid_np)\n    if not markers:\n        # If no markers, return empty grid (or input, depending on spec - assume empty)\n        return np.array([[]], dtype=np.uint8).tolist()\n\n    # 2. Find template shapes (magenta color = 6) using BFS\n    template_shapes = find_shapes(input_grid_np, 6)\n    if not template_shapes:\n         # If no template shapes, return empty grid\n        return np.array([[]], dtype=np.uint8).tolist()\n\n    # 3. Associate each marker with the closest template shape\n    marker_shape_distances = []\n    for i, marker in enumerate(markers):\n        for j, shape in enumerate(template_shapes):\n            # Calculate distance only if shape has coordinates\n            if shape['coords']:\n                 dist = distance_marker_to_shape(marker['pos'], shape['coords'])\n                 marker_shape_distances.append({'marker_idx': i, 'shape_idx': j, 'dist': dist})\n            \n    # Sort distances to prioritize closest pairs globally\n    marker_shape_distances.sort(key=lambda x: x['dist'])\n\n    processed_pairs = []\n    marker_assigned = [False] * len(markers)\n    shape_assigned = [False] * len(template_shapes)\n\n    for M_S_dist in marker_shape_distances:\n        marker_idx = M_S_dist['marker_idx']\n        shape_idx = M_S_dist['shape_idx']\n        \n        # If this marker and shape haven't been assigned yet, make the assignment\n        if not marker_assigned[marker_idx] and not shape_assigned[shape_idx]:\n            marker = markers[marker_idx]\n            shape = template_shapes[shape_idx]\n            processed_pairs.append({\n                'marker': marker,\n                'shape_coords': shape['coords']\n            })\n            marker_assigned[marker_idx] = True\n            shape_assigned[shape_idx] = True\n            \n        # Optimization: Stop if all markers have been assigned\n        if all(marker_assigned):\n            break\n            \n    # Check if all markers were successfully associated (optional, for debugging)\n    # if len(processed_pairs) != len(markers):\n    #     print(f\"Warning: Could not associate all {len(markers)} markers. Found {len(processed_pairs)} associations.\")\n\n    # 4. Process each pair: Extract and recolor\n    output_shapes_data = []\n    for pair in processed_pairs:\n        marker = pair['marker']\n        shape_coords = pair['shape_coords']\n        # Recolor the shape based on marker color\n        recolored_shape = extract_and_recolor(shape_coords, marker['color'])\n        if recolored_shape is not None and recolored_shape.size > 0: # Ensure shape is valid\n            output_shapes_data.append({\n                'shape': recolored_shape,\n                'marker_pos': marker['pos'] # Store original marker position for sorting\n            })\n\n    # If no valid shapes were generated (e.g., all markers failed association)\n    if not output_shapes_data:\n         return np.array([[]], dtype=np.uint8).tolist()\n\n    # 5. Determine arrangement strategy based on marker positions\n    marker_rows = [data['marker_pos'][0] for data in output_shapes_data]\n    marker_cols = [data['marker_pos'][1] for data in output_shapes_data]\n\n    # Handle case with only one marker/shape\n    if len(output_shapes_data) <= 1:\n         # Default to vertical if only one, or if ranges are zero (doesn't matter)\n         orientation = 'vertical'\n    else:\n        row_range = max(marker_rows) - min(marker_rows)\n        col_range = max(marker_cols) - min(marker_cols)\n\n        # Rule: Horizontal if col_range > row_range, otherwise vertical\n        if col_range > row_range:\n            orientation = 'horizontal'\n        else: # Includes row_range >= col_range (handles ties)\n            orientation = 'vertical'\n\n    # 6. Sort the shapes based on the chosen orientation and marker positions\n    if orientation == 'horizontal':\n        # Sort by marker column index (left-to-right)\n        output_shapes_data.sort(key=lambda x: x['marker_pos'][1])\n    else: # vertical\n        # Sort by marker row index (top-to-bottom)\n        output_shapes_data.sort(key=lambda x: x['marker_pos'][0])\n\n    # 7. Assemble the output grid by combining sorted shapes with padding\n    final_shapes = [data['shape'] for data in output_shapes_data]\n    output_grid = combine_grids(final_shapes, orientation)\n\n    # 8. Return the result as a list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7279,
    "candidates_token_count": 3174,
    "total_token_count": 10453,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.405378,
  "retries": null
}