{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nfrom skimage.measure import label, regionprops\n\n\"\"\"\nIdentify non-white (0), non-magenta (6) \"marker\" pixels and their locations/colors.\nIdentify contiguous shapes made of magenta (6) pixels (\"template shapes\").\nAssociate each marker pixel with the spatially closest template shape (minimum distance from marker to any pixel of the shape).\nFor each marker-template pair:\n  Extract the template shape within its minimal bounding box.\n  Create a new grid of the bounding box size.\n  Fill this new grid: where the template shape had magenta (6), place the marker's color; otherwise, place white (0).\nDetermine arrangement:\n  Calculate the row and column range spanned by marker pixels.\n  If column range > row range, arrange horizontally, sorted by marker column.\n  Otherwise, arrange vertically, sorted by marker row.\nCombine the colored shapes according to the determined arrangement and sorting order to create the final output grid.\n\"\"\"\n\ndef find_marker_pixels(grid):\n    \"\"\"Finds pixels that are not white (0) or magenta (6).\"\"\"\n    markers = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != 0 and color != 6:\n                markers.append({'pos': (r, c), 'color': color})\n    return markers\n\ndef find_shapes(grid, color):\n    \"\"\"Finds contiguous shapes of a specific color.\"\"\"\n    binary_grid = (grid == color).astype(int)\n    labeled_grid, num_labels = label(binary_grid, connectivity=1, background=0, return_num=True) # Use connectivity=1 for 4-way adjacency\n    \n    shapes = []\n    if num_labels > 0:\n        regions = regionprops(labeled_grid)\n        for region in regions:\n            coords = region.coords # Gives list of (row, col) tuples\n            # Convert coords to list of tuples for consistency\n            coords_list = [tuple(coord) for coord in coords]\n            shapes.append({'coords': coords_list, 'label': region.label})\n            \n    # Filter out potential empty shapes if any issue with regionprops\n    shapes = [s for s in shapes if s['coords']] \n    return shapes\n\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the minimum bounding box for a set of coordinates.\"\"\"\n    if not coords:\n        return None, None, None, None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return min_r, min_c, height, width\n\ndef distance_marker_to_shape(marker_pos, shape_coords):\n    \"\"\"Calculates the minimum Manhattan distance from a marker point to any pixel in a shape.\"\"\"\n    marker_np = np.array([marker_pos])\n    shape_np = np.array(shape_coords)\n    # Use cdist with 'cityblock' for Manhattan distance\n    distances = cdist(marker_np, shape_np, metric='cityblock')\n    return np.min(distances)\n\ndef extract_and_recolor(grid, shape_coords, marker_color):\n    \"\"\"Extracts shape within bounding box and recolors magenta to marker color.\"\"\"\n    if not shape_coords:\n        return None\n        \n    min_r, min_c, height, width = get_bounding_box(shape_coords)\n    \n    # Create the output subgrid, initialized to white (0)\n    subgrid = np.zeros((height, width), dtype=np.uint8)\n    \n    # Convert shape_coords to a set for faster lookup\n    shape_coords_set = set(shape_coords)\n\n    # Iterate through the bounding box in the original grid coordinates\n    for r in range(min_r, min_r + height):\n        for c in range(min_c, min_c + width):\n            # Check if the current coordinate belongs to the shape\n            if (r, c) in shape_coords_set:\n                 # Check if the original pixel was magenta (redundant if shape_coords only contains magenta pixels)\n                 # if grid[r, c] == 6: # This check might be unnecessary if find_shapes is correct\n                 subgrid[r - min_r, c - min_c] = marker_color\n                 # Else case is handled by initialization to 0 (white)\n\n    return subgrid\n\ndef combine_grids(grids, orientation):\n    \"\"\"Combines multiple grids horizontally or vertically, padding with 0s.\"\"\"\n    if not grids:\n        return np.array([[]], dtype=np.uint8) # Return empty if no grids\n\n    if orientation == 'horizontal':\n        max_height = max(g.shape[0] for g in grids)\n        padded_grids = []\n        for g in grids:\n            pad_height = max_height - g.shape[0]\n            # Pad at the bottom\n            padded_g = np.pad(g, ((0, pad_height), (0, 0)), mode='constant', constant_values=0)\n            padded_grids.append(padded_g)\n        return np.hstack(padded_grids)\n    else: # vertical\n        max_width = max(g.shape[1] for g in grids)\n        padded_grids = []\n        for g in grids:\n            pad_width = max_width - g.shape[1]\n            # Pad on the right\n            padded_g = np.pad(g, ((0, 0), (0, pad_width)), mode='constant', constant_values=0)\n            padded_grids.append(padded_g)\n        return np.vstack(padded_grids)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding marker pixels and magenta template shapes,\n    associating them by proximity, extracting and recoloring the shapes based on markers,\n    and arranging the resulting shapes based on marker positions.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=np.uint8)\n\n    # 1. Find marker pixels\n    markers = find_marker_pixels(input_grid_np)\n    if not markers:\n        # Handle case with no markers if necessary, maybe return empty or input?\n        # Assuming task guarantees markers.\n        return np.array([[]], dtype=np.uint8)\n\n\n    # 2. Find template shapes (magenta color = 6)\n    template_shapes = find_shapes(input_grid_np, 6)\n    if not template_shapes:\n         # Handle case with no template shapes if necessary.\n        return np.array([[]], dtype=np.uint8)\n\n    # 3. Associate each marker with the closest template shape\n    associations = []\n    used_shape_labels = set() # Keep track of shapes already assigned\n\n    # Calculate all distances first to handle potential multiple markers closest to the same shape\n    marker_shape_distances = []\n    for i, marker in enumerate(markers):\n        for j, shape in enumerate(template_shapes):\n            dist = distance_marker_to_shape(marker['pos'], shape['coords'])\n            marker_shape_distances.append({'marker_idx': i, 'shape_idx': j, 'dist': dist})\n            \n    # Sort distances to prioritize closest pairs\n    marker_shape_distances.sort(key=lambda x: x['dist'])\n\n    marker_assigned = [False] * len(markers)\n    shape_assigned = [False] * len(template_shapes)\n    \n    processed_pairs = []\n\n    for M_S_dist in marker_shape_distances:\n        marker_idx = M_S_dist['marker_idx']\n        shape_idx = M_S_dist['shape_idx']\n        \n        # If this marker and shape haven't been assigned yet, make the assignment\n        if not marker_assigned[marker_idx] and not shape_assigned[shape_idx]:\n            marker = markers[marker_idx]\n            shape = template_shapes[shape_idx]\n            processed_pairs.append({\n                'marker': marker,\n                'shape_coords': shape['coords']\n            })\n            marker_assigned[marker_idx] = True\n            shape_assigned[shape_idx] = True\n            \n        # Stop if all markers have been assigned\n        if all(marker_assigned):\n            break\n\n    # Ensure we found an association for every marker\n    if len(processed_pairs) != len(markers):\n        # This might indicate an issue with the association logic or input data mismatch\n        print(f\"Warning: Could not associate all {len(markers)} markers. Found {len(processed_pairs)} associations.\")\n        # Depending on requirements, could raise an error or return empty/partial grid\n        # Let's proceed with the associations found for now.\n\n    # 4. Process each pair: Extract and recolor\n    output_shapes_data = []\n    for pair in processed_pairs:\n        marker = pair['marker']\n        shape_coords = pair['shape_coords']\n        recolored_shape = extract_and_recolor(input_grid_np, shape_coords, marker['color'])\n        if recolored_shape is not None:\n            output_shapes_data.append({\n                'shape': recolored_shape,\n                'marker_pos': marker['pos']\n            })\n\n    if not output_shapes_data:\n         return np.array([[]], dtype=np.uint8)\n\n    # 5. Determine arrangement strategy\n    marker_rows = [data['marker_pos'][0] for data in output_shapes_data]\n    marker_cols = [data['marker_pos'][1] for data in output_shapes_data]\n\n    row_range = max(marker_rows) - min(marker_rows) if len(marker_rows) > 1 else 0\n    col_range = max(marker_cols) - min(marker_cols) if len(marker_cols) > 1 else 0\n\n    if col_range > row_range:\n        orientation = 'horizontal'\n        # Sort by marker column index\n        output_shapes_data.sort(key=lambda x: x['marker_pos'][1])\n    else:\n        orientation = 'vertical'\n        # Sort by marker row index\n        output_shapes_data.sort(key=lambda x: x['marker_pos'][0])\n\n    # 6. Assemble the output grid\n    final_shapes = [data['shape'] for data in output_shapes_data]\n    output_grid = combine_grids(final_shapes, orientation)\n\n    # 7. Return the result\n    return output_grid.tolist() # Convert back to list of lists if required by ARC env\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4163,
    "candidates_token_count": 2550,
    "total_token_count": 6713,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.564933,
  "retries": null
}