{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a specific 'trigger' pixel based on its color (Red=2 or Orange=7).\nFinds a corresponding 'mover' pattern associated with that trigger color (Red -> Green L + Azure, Orange -> Magenta L + Orange).\nDetermines a placement offset based on the trigger color (Red -> (0, 2), Orange -> (0, 0)).\nErases the original 'mover' pattern from the grid.\nRedraws the 'mover' pattern at a new location calculated by adding the offset to the trigger pixel's location.\n\"\"\"\n\n# Define the patterns as lists of (relative_row, relative_col, color) tuples\n# relative to their top-left corner.\nGREEN_L_AZURE_PATTERN = [\n    (0, 0, 3), (0, 1, 3), (0, 2, 3), (0, 3, 3),\n    (1, 2, 8), (1, 3, 3),\n    (2, 3, 3)\n]\n\nMAGENTA_L_ORANGE_PATTERN = [\n    (0, 0, 6), (0, 1, 6), (0, 2, 6),\n    (1, 0, 6), (1, 1, 7),\n    (2, 0, 6)\n]\n\n# Map trigger colors to their corresponding pattern and placement offset (dR, dC)\nTRIGGER_MAP = {\n    2: {'pattern': GREEN_L_AZURE_PATTERN, 'offset': (0, 2)},  # Red trigger\n    7: {'pattern': MAGENTA_L_ORANGE_PATTERN, 'offset': (0, 0)}   # Orange trigger\n}\n\n# --- Helper Functions ---\n\ndef find_trigger_pixel(grid):\n    \"\"\"\n    Finds the first pixel whose color is a key in TRIGGER_MAP.\n    Returns its color, row, and column, or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color in TRIGGER_MAP:\n                return color, r, c\n    return None, -1, -1 # No trigger found\n\ndef check_pattern_at(grid, r_start, c_start, pattern):\n    \"\"\"\n    Checks if the specified pattern exists at the given top-left coordinates.\n    \"\"\"\n    height, width = grid.shape\n    for dr, dc, color in pattern:\n        r, c = r_start + dr, c_start + dc\n        # Check bounds and color match\n        if not (0 <= r < height and 0 <= c < width and grid[r, c] == color):\n            return False\n    return True\n\ndef find_pattern_location(grid, pattern):\n    \"\"\"\n    Finds the top-left corner (row, col) of the first occurrence of the pattern.\n    Returns (row, col) or (-1, -1) if not found.\n    \"\"\"\n    height, width = grid.shape\n    # Determine pattern dimensions (max row/col offset) to avoid searching too close to edges\n    max_dr = max(dr for dr, dc, color in pattern) if pattern else -1\n    max_dc = max(dc for dr, dc, color in pattern) if pattern else -1\n\n    if max_dr == -1 or max_dc == -1: # Empty pattern\n        return -1, -1\n\n    for r in range(height - max_dr):\n        for c in range(width - max_dc):\n            if check_pattern_at(grid, r, c, pattern):\n                return r, c\n    return -1, -1\n\ndef modify_grid_with_pattern(grid, r_start, c_start, pattern, new_color=0):\n    \"\"\"\n    Modifies the grid by setting pixels matching the pattern to new_color.\n    Used for both erasing (new_color=0) and drawing (new_color=pattern_color).\n    For drawing, new_color is ignored, and actual pattern colors are used.\n    \"\"\"\n    height, width = grid.shape\n    for dr, dc, pattern_color in pattern:\n        r, c = r_start + dr, c_start + dc\n        if 0 <= r < height and 0 <= c < width:\n            if new_color is None: # Draw mode\n                 grid[r, c] = pattern_color\n            else: # Erase mode (or fill with a specific color)\n                 # Only erase if the current pixel matches the pattern's color at that spot\n                 if grid[r,c] == pattern_color:\n                     grid[r, c] = new_color\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: find trigger, find associated pattern,\n    erase pattern, redraw pattern at new location based on trigger and offset.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # 1. Find the trigger pixel\n    trigger_color, r_trigger, c_trigger = find_trigger_pixel(input_grid)\n\n    # If no trigger found, return the original grid copy\n    if trigger_color is None:\n        print(\"No trigger pixel found.\")\n        return output_grid\n\n    # 2. Get the associated pattern and offset from the map\n    if trigger_color not in TRIGGER_MAP:\n         print(f\"Trigger color {trigger_color} not in TRIGGER_MAP.\")\n         return output_grid # Should not happen if find_trigger_pixel works correctly\n\n    mover_pattern = TRIGGER_MAP[trigger_color]['pattern']\n    offset = TRIGGER_MAP[trigger_color]['offset']\n    dr_offset, dc_offset = offset\n\n    # 3. Find the original location of the mover pattern\n    r_original, c_original = find_pattern_location(input_grid, mover_pattern)\n\n    if r_original == -1:\n        print(f\"Mover pattern for trigger {trigger_color} not found.\")\n        return output_grid # Pattern associated with trigger not found\n\n    # 4. Erase the mover pattern from its original location in the output grid\n    # We pass the original grid to check_pattern_at inside find_pattern_location,\n    # but modify the output_grid here.\n    # Erase by setting matched pixels to background color 0.\n    modify_grid_with_pattern(output_grid, r_original, c_original, mover_pattern, new_color=0)\n\n    # 5. Calculate the new top-left corner for the pattern\n    r_new = r_trigger + dr_offset\n    c_new = c_trigger + dc_offset\n\n    # 6. Draw the mover pattern at the new location in the output grid\n    # Pass new_color=None to signal drawing mode\n    modify_grid_with_pattern(output_grid, r_new, c_new, mover_pattern, new_color=None)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3713,
    "candidates_token_count": 1655,
    "total_token_count": 5368,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.193785,
  "retries": null
}