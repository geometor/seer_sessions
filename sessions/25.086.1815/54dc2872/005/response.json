{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies all 'trigger' pixels (Red=2 or Orange=7).\nFor each trigger, identifies its associated 'mover' pattern (Red -> Green L + Azure, Orange -> Magenta L + Orange) and placement offset (Red -> (0, 2), Orange -> (0, 0)).\nSearches the grid for the mover pattern corresponding to the trigger.\nThe *first* trigger found (scanning top-to-bottom, left-to-right) for which its corresponding mover pattern *also exists* in the grid determines the transformation. This trigger becomes the 'active trigger'.\nIf such a trigger/pattern pair is found:\n    1. Erases the original 'mover' pattern from the grid (setting its pixels to white=0).\n    2. Redraws the 'mover' pattern at a new location, calculated by adding the placement offset to the location of the *active trigger* pixel. The new location defines the top-left corner for drawing the pattern.\n    3. **Conditional Cleanup:** If the active trigger was Red (2), *after* the pattern move, all remaining Magenta (6) and Maroon (9) pixels in the entire grid are set to white (0). This cleanup does not occur if the active trigger was Orange (7).\nIf no trigger pixel has its corresponding mover pattern present in the grid, the original grid is returned unchanged.\n\"\"\"\n\n# Define the patterns as lists of (relative_row, relative_col, color) tuples\n# relative to their top-left corner.\nGREEN_L_AZURE_PATTERN = [\n    (0, 0, 3), (0, 1, 3), (0, 2, 3), (0, 3, 3), # Top row: GGGG\n    (1, 2, 8), (1, 3, 3),                      # Middle row: ..AG\n    (2, 3, 3)                                  # Bottom row: ...G\n]\n\nMAGENTA_L_ORANGE_PATTERN = [\n    (0, 0, 6), (0, 1, 6), (0, 2, 6),           # Top row: MMM\n    (1, 0, 6), (1, 1, 7),                      # Middle row: MO.\n    (2, 0, 6)                                  # Bottom row: M..\n]\n\n# Map trigger colors to their corresponding pattern and placement offset (dR, dC)\nTRIGGER_MAP = {\n    2: {'pattern': GREEN_L_AZURE_PATTERN, 'offset': (0, 2)},  # Red trigger\n    7: {'pattern': MAGENTA_L_ORANGE_PATTERN, 'offset': (0, 0)}   # Orange trigger\n}\n\n# Define colors to be cleaned up if the trigger is Red\nRED_TRIGGER_CLEANUP_COLORS = {6, 9} # Magenta and Maroon\n\n# --- Helper Functions ---\n\ndef find_all_trigger_pixels(grid):\n    \"\"\"\n    Finds all pixels whose color is a key in TRIGGER_MAP.\n    Returns a list of (color, row, col) tuples, ordered by scan order\n    (top-to-bottom, left-to-right).\n    \"\"\"\n    triggers = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color in TRIGGER_MAP:\n                triggers.append((color, r, c))\n    return triggers\n\ndef check_pattern_at(grid, r_start, c_start, pattern):\n    \"\"\"\n    Checks if the specified pattern exists at the given top-left coordinates (r_start, c_start)\n    in the grid.\n    Returns True if the pattern matches, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    for dr, dc, color in pattern:\n        r, c = r_start + dr, c_start + dc\n        # Check bounds and color match\n        if not (0 <= r < height and 0 <= c < width and grid[r, c] == color):\n            return False\n    return True\n\ndef find_pattern_location(grid, pattern):\n    \"\"\"\n    Finds the top-left corner (row, col) of the first occurrence of the pattern\n    in the grid, searching top-to-bottom, left-to-right.\n    Returns (row, col) or (-1, -1) if not found.\n    \"\"\"\n    height, width = grid.shape\n    # Determine pattern dimensions (max row/col offset)\n    if not pattern: # Empty pattern\n        return -1, -1\n    # Calculate the required height and width span of the pattern\n    max_dr = max(dr for dr, dc, color in pattern) if pattern else -1\n    max_dc = max(dc for dr, dc, color in pattern) if pattern else -1\n\n    if max_dr == -1 or max_dc == -1: # Handle case where pattern is empty or malformed\n        return -1, -1\n\n    # Iterate through possible top-left starting positions\n    for r in range(height - max_dr):\n        for c in range(width - max_dc):\n            # Check if the pattern exists starting at (r, c)\n            if check_pattern_at(grid, r, c, pattern):\n                return r, c # Return the first location found\n    return -1, -1 # Pattern not found\n\ndef modify_grid_with_pattern(grid, r_start, c_start, pattern, new_color=0):\n    \"\"\"\n    Modifies the grid:\n    - If new_color is None (draw mode): Draws the pattern at (r_start, c_start),\n      overwriting existing pixels within grid bounds.\n    - If new_color is not None (erase mode): Sets pixels corresponding to the\n      pattern shape at (r_start, c_start) to new_color, ONLY IF the current pixel\n      in the grid matches the expected pattern color at that relative position.\n      This prevents accidentally erasing non-pattern pixels.\n    \"\"\"\n    height, width = grid.shape\n    for dr, dc, pattern_color in pattern:\n        r, c = r_start + dr, c_start + dc\n        # Ensure the coordinates are within the grid boundaries\n        if 0 <= r < height and 0 <= c < width:\n            if new_color is None: # Draw mode\n                 grid[r, c] = pattern_color\n            else: # Erase mode\n                 # Only erase if the current grid pixel matches the expected pattern color\n                 if grid[r, c] == pattern_color:\n                     grid[r, c] = new_color # Set to background/erase color\n\ndef perform_cleanup(grid, colors_to_remove):\n    \"\"\"\n    Sets all pixels with colors in the 'colors_to_remove' set to white (0).\n    Modifies the grid in place.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] in colors_to_remove:\n                grid[r, c] = 0\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    # Initialize output_grid as a copy of the input to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # --- Find the active transformation details ---\n    active_trigger_loc = None\n    active_pattern_loc = None\n    active_pattern = None\n    active_offset = None\n    active_trigger_color = None # Keep track of the active trigger's color\n    found_active_pair = False\n\n    # 1. Find all potential trigger pixels in the input grid\n    all_triggers = find_all_trigger_pixels(input_grid)\n\n    # 2. Iterate through triggers in the order they were found\n    for trigger_color, r_trigger, c_trigger in all_triggers:\n        # 3. Get the associated pattern and offset for this trigger color\n        # (Check is redundant but safe)\n        if trigger_color not in TRIGGER_MAP:\n            continue\n\n        details = TRIGGER_MAP[trigger_color]\n        mover_pattern = details['pattern']\n        offset = details['offset']\n\n        # 4. Search for the associated mover pattern in the *original* input grid\n        r_original, c_original = find_pattern_location(input_grid, mover_pattern)\n\n        # 5. If the pattern is found, this trigger/pattern pair is the active one\n        if r_original != -1:\n            active_trigger_loc = (r_trigger, c_trigger)\n            active_pattern_loc = (r_original, c_original)\n            active_pattern = mover_pattern\n            active_offset = offset\n            active_trigger_color = trigger_color # Store the color of the active trigger\n            found_active_pair = True\n            break # Crucial: Stop searching once the first valid pair is found\n\n    # --- Apply the transformation if an active pair was found ---\n    if not found_active_pair:\n        # If no trigger had its corresponding pattern present in the grid,\n        # return the unmodified copy of the input grid.\n        return output_grid\n\n    # 6. Unpack the details of the active transformation for clarity\n    r_trigger, c_trigger = active_trigger_loc\n    r_original, c_original = active_pattern_loc\n    dr_offset, dc_offset = active_offset\n\n    # 7. Erase the mover pattern from its original location in the output grid.\n    modify_grid_with_pattern(output_grid, r_original, c_original, active_pattern, new_color=0)\n\n    # 8. Calculate the new top-left corner for drawing the pattern.\n    r_new = r_trigger + dr_offset\n    c_new = c_trigger + dc_offset\n\n    # 9. Draw the mover pattern at the new location in the output grid.\n    modify_grid_with_pattern(output_grid, r_new, c_new, active_pattern, new_color=None)\n\n    # 10. Conditional Cleanup: If the active trigger was Red (2)\n    if active_trigger_color == 2:\n        perform_cleanup(output_grid, RED_TRIGGER_CLEANUP_COLORS)\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9471,
    "candidates_token_count": 2401,
    "total_token_count": 11872,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.13596,
  "retries": null
}