{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify the background color (most frequent color in the grid).\n2. Identify all foreground pixels (pixels not matching the background color). Assume only one foreground color exists.\n3. Find all contiguous objects of the foreground color using 8-way connectivity.\n4. For each object:\n    a. Determine its bounding box.\n    b. Calculate its width and height.\n    c. Classify the object based on its dimensions:\n        - Point: width=1 and height=1\n        - Vertical Line (V-Line): width=1 and height > 1\n        - Horizontal Line (H-Line): width > 1 and height=1\n        - Other: width > 1 and height > 1 (Assume this case doesn't occur based on examples, or handle as error/ignore).\n    d. Calculate the center coordinates (cr, cc) and length (L) of the object.\n        - For V-Line: cr = (min_row + max_row) // 2, cc = column, L = height\n        - For H-Line: cr = row, cc = (min_col + max_col) // 2, L = width\n        - For Point: cr = row, cc = col, L = 1\n5. Create an output grid initialized with the background color.\n6. Draw the transformed shape onto the output grid for each input object:\n    - Point: Draw a point at the same location (cr, cc).\n    - V-Line: Draw an H-Line in the output grid. The H-Line has row = cr, length = L, and is centered horizontally at column = cc.\n    - H-Line: Draw a V-Line in the output grid. The V-Line has column = cc, length = L, and is centered vertically at row = cr.\n7. Ensure drawing stays within the grid boundaries.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default white\n    # Handle ties by picking the smaller color index? Or assume one clear background.\n    return counts.most_common(1)[0][0]\n\ndef find_foreground_color(grid, background_color):\n    \"\"\"Finds the first color that is not the background color.\"\"\"\n    for row in grid:\n        for cell in row:\n            if cell != background_color:\n                return cell\n    return None # No foreground color found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object-based H<->V line swap transformation.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify background color\n    background_color = find_background_color(input_grid_np)\n    \n    # Find foreground color (assuming one)\n    foreground_color = find_foreground_color(input_grid_np, background_color)\n    if foreground_color is None:\n        # If no foreground color, return the input grid or background-filled grid\n        return input_grid \n\n    # 2. Initialize output grid with background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 3. Find foreground objects\n    foreground_mask = input_grid_np == foreground_color\n    # Use 8-way connectivity (structure=np.ones((3,3)))\n    labeled_array, num_features = label(foreground_mask, structure=np.ones((3,3), dtype=bool))\n\n    # 4. Process each object\n    for i in range(1, num_features + 1):\n        # Find pixels belonging to this object\n        object_pixels = np.argwhere(labeled_array == i)\n        if object_pixels.size == 0:\n            continue\n        \n        # a. Determine bounding box\n        min_row = np.min(object_pixels[:, 0])\n        max_row = np.max(object_pixels[:, 0])\n        min_col = np.min(object_pixels[:, 1])\n        max_col = np.max(object_pixels[:, 1])\n\n        # b. Calculate width and height\n        obj_height = max_row - min_row + 1\n        obj_width = max_col - min_col + 1\n\n        # c/d. Classify object and calculate center/length\n        is_point = (obj_width == 1 and obj_height == 1)\n        is_vline = (obj_width == 1 and obj_height > 1)\n        is_hline = (obj_width > 1 and obj_height == 1)\n        \n        center_row = -1\n        center_col = -1\n        length = -1\n        \n        if is_point:\n            center_row = min_row\n            center_col = min_col\n            length = 1\n        elif is_vline:\n            center_row = (min_row + max_row) // 2\n            center_col = min_col # or max_col, they are the same\n            length = obj_height\n        elif is_hline:\n            center_row = min_row # or max_row, they are the same\n            center_col = (min_col + max_col) // 2\n            length = obj_width\n        else:\n            # Handle 'Other' case if necessary - for now, ignore\n            # print(f\"Warning: Found non-line/point object {i} - ignoring.\")\n            continue\n            \n        # 6. Draw transformed shape onto output grid\n        if is_point:\n            # Draw point directly\n            if 0 <= center_row < height and 0 <= center_col < width:\n                output_grid[center_row, center_col] = foreground_color\n        \n        elif is_vline:\n            # Input V-Line -> Output H-Line\n            # Output line is at row = center_row\n            # Output line has length = length\n            # Output line is centered at col = center_col\n            out_row = center_row\n            start_col = center_col - (length - 1) // 2\n            end_col = center_col + length // 2\n            \n            # Draw the horizontal line within bounds\n            for c in range(start_col, end_col + 1):\n                if 0 <= out_row < height and 0 <= c < width:\n                    output_grid[out_row, c] = foreground_color\n                    \n        elif is_hline:\n            # Input H-Line -> Output V-Line\n            # Output line is at col = center_col\n            # Output line has length = length\n            # Output line is centered at row = center_row\n            out_col = center_col\n            start_row = center_row - (length - 1) // 2\n            end_row = center_row + length // 2\n            \n            # Draw the vertical line within bounds\n            for r in range(start_row, end_row + 1):\n                 if 0 <= r < height and 0 <= out_col < width:\n                    output_grid[r, out_col] = foreground_color\n\n    # Convert back to list of lists for consistency if needed\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11890,
    "candidates_token_count": 1733,
    "total_token_count": 13623,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.146673,
  "retries": null
}