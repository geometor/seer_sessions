{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque # Using deque for efficiency in BFS\n\n\"\"\"\nIdentifies the unique non-black color forming complete horizontal and vertical \ndividing lines in the input grid. These lines partition the grid into four \nquadrants. Within each quadrant, locates the single contiguous object whose color \nis neither the background (black, 0) nor the divider line color. Extracts the \n3x3 minimal bounding box of each of these four objects. Assembles a 6x6 output \ngrid by placing the extracted 3x3 regions into the corresponding quadrants \nof the output grid (e.g., input Top-Left object -> output Top-Left 3x3 section).\n\"\"\"\n\ndef _find_divider_lines(grid):\n    \"\"\"\n    Finds the unique non-black color forming exactly one complete horizontal line\n    and exactly one complete vertical line, and returns the color and indices.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (divider_color, h_row_index, v_col_index)\n               Returns (-1, -1, -1) if no such unique divider is found.\n    \"\"\"\n    H, W = grid.shape\n    h_lines = {} # color -> list of row indices\n    v_lines = {} # color -> list of col indices\n\n    # Find potential horizontal lines (must be uniform and not black)\n    for r in range(H):\n        row = grid[r, :]\n        unique_colors = np.unique(row)\n        if len(unique_colors) == 1:\n            color = unique_colors[0]\n            # Ensure color is treated as a standard int and is not black (0)\n            color_int = int(color)\n            if color_int != 0:\n                if color_int not in h_lines:\n                    h_lines[color_int] = []\n                h_lines[color_int].append(r)\n\n    # Find potential vertical lines (must be uniform and not black)\n    for c in range(W):\n        col = grid[:, c]\n        unique_colors = np.unique(col)\n        if len(unique_colors) == 1:\n            color = unique_colors[0]\n            # Ensure color is treated as a standard int and is not black (0)\n            color_int = int(color)\n            if color_int != 0:\n                if color_int not in v_lines:\n                    v_lines[color_int] = []\n                v_lines[color_int].append(c)\n\n    # Find the unique color present in both and ensure exactly one line each\n    divider_color = -1\n    h_row = -1\n    v_col = -1\n\n    common_colors = set(h_lines.keys()) & set(v_lines.keys())\n\n    # Expect exactly one color to form both lines\n    valid_dividers = []\n    for color in common_colors:\n        # Expect exactly one horizontal line and one vertical line of that color\n        if len(h_lines.get(color, [])) == 1 and len(v_lines.get(color, [])) == 1:\n             valid_dividers.append(color)\n\n    # Ensure only ONE such color exists\n    if len(valid_dividers) == 1:\n        divider_color = valid_dividers[0]\n        h_row = h_lines[divider_color][0]\n        v_col = v_lines[divider_color][0]\n        return divider_color, h_row, v_col\n    else:\n        # print(f\"Warning: Expected exactly one common divider color with single H/V lines, found {len(valid_dividers)}: {valid_dividers}\")\n        return -1, -1, -1 # Indicate failure\n\n\ndef _bfs_find_object(grid, start_r, start_c, target_color, r_start, r_end, c_start, c_end, visited):\n    \"\"\"\n    Performs BFS to find all connected pixels of target_color within quadrant bounds.\n\n    Args:\n        grid (np.array): The full input grid.\n        start_r, start_c (int): Starting coordinates for BFS.\n        target_color (int): The color of the object to find.\n        r_start, r_end (int): Row boundaries of the quadrant (exclusive end).\n        c_start, c_end (int): Column boundaries of the quadrant (exclusive end).\n        visited (set): A set of (r, c) tuples already visited during the search\n                       within the parent function's quadrant scan. Modified in place.\n\n    Returns:\n        list: A list of (r, c) tuples representing the pixels of the found object.\n              Returns an empty list if the start pixel itself is invalid or already visited.\n    \"\"\"\n    # Check if starting point is valid and within bounds and has the right color\n    if not (r_start <= start_r < r_end and c_start <= start_c < c_end and \\\n            grid[start_r, start_c] == target_color and (start_r, start_c) not in visited):\n        return []\n\n    q = deque([(start_r, start_c)])\n    object_pixels = []\n    visited.add((start_r, start_c)) # Mark start as visited for this BFS traversal\n\n    while q:\n        r, c = q.popleft()\n        object_pixels.append((r, c))\n\n        # Check neighbors (4-connectivity: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within quadrant bounds\n            if r_start <= nr < r_end and c_start <= nc < c_end:\n                # Check if neighbor has the target color and hasn't been visited yet in this specific object search\n                if grid[nr, nc] == target_color and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    \n    return object_pixels\n\n\ndef _find_and_extract(grid, r_start, r_end, c_start, c_end, excluded_colors):\n    \"\"\"\n    Finds the single non-excluded object in the specified quadrant region\n    of the grid and extracts its 3x3 minimal bounding box.\n\n    Args:\n        grid (np.array): The full input grid.\n        r_start, r_end (int): Row boundaries of the quadrant (exclusive end).\n        c_start, c_end (int): Column boundaries of the quadrant (exclusive end).\n        excluded_colors (set): Set of colors to ignore (e.g., background, divider).\n\n    Returns:\n        np.array: The 3x3 extracted region.\n\n    Raises:\n        ValueError: If no suitable object is found, more than one is found,\n                    or if the object's bounding box is not exactly 3x3.\n    \"\"\"\n    # Check for invalid quadrant dimensions\n    if r_start >= r_end or c_start >= c_end:\n        raise ValueError(f\"Invalid quadrant dimensions: rows {r_start}-{r_end}, cols {c_start}-{c_end}\")\n\n    quadrant_visited = set() # Track visited cells *within this quadrant* to avoid re-processing pixels as starting points\n    found_object_region = None\n    object_found = False\n\n    for r in range(r_start, r_end):\n        for c in range(c_start, c_end):\n            current_color = grid[r, c]\n            # Check if the pixel is a potential start of our target object\n            if current_color not in excluded_colors and (r, c) not in quadrant_visited:\n                # Perform BFS to find the whole object connected to (r, c)\n                # Pass a copy of visited to BFS if you don't want BFS to modify the outer loop's visited set directly,\n                # but here it's intended to mark all pixels of the found object as visited for the outer loop.\n                object_pixels = _bfs_find_object(grid, r, c, current_color,\n                                                 r_start, r_end, c_start, c_end, quadrant_visited)\n\n                # If BFS found a valid object starting at (r, c)\n                if object_pixels:\n                    # Ensure only one object is found per quadrant\n                    if object_found:\n                         raise ValueError(f\"Found more than one suitable object in quadrant ({r_start}:{r_end}, {c_start}:{c_end}) \"\n                                          f\"excluding colors {excluded_colors}.\")\n                    object_found = True\n\n                    # Calculate the minimal bounding box based on absolute coordinates\n                    min_r = min(p[0] for p in object_pixels)\n                    max_r = max(p[0] for p in object_pixels)\n                    min_c = min(p[1] for p in object_pixels)\n                    max_c = max(p[1] for p in object_pixels)\n\n                    # Check if the bounding box is exactly 3x3\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    if height != 3 or width != 3:\n                        raise ValueError(f\"Found object in quadrant ({r_start}:{r_end}, {c_start}:{c_end}) \"\n                                         f\"with color {current_color}, but its bounding box \"\n                                         f\"({min_r}:{max_r+1}, {min_c}:{max_c+1}) size is {height}x{width}, not 3x3.\")\n\n                    # Extract the 3x3 region from the original grid\n                    found_object_region = grid[min_r : max_r + 1, min_c : max_c + 1]\n                    # Don't return immediately; continue scanning to ensure only one object exists.\n                    # The object pixels are already marked in quadrant_visited by BFS.\n\n    # After checking the entire quadrant, if exactly one object was found, return its region\n    if object_found:\n        return found_object_region\n    else:\n        # If the loops complete without finding any object\n        raise ValueError(f\"No suitable object found in quadrant ({r_start}:{r_end}, {c_start}:{c_end}) \"\n                         f\"excluding colors {excluded_colors}.\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding divider lines, identifying objects\n    in the resulting quadrants, extracting their 3x3 bounding boxes, and\n    assembling them into a 6x6 output grid.\n\n    Args:\n        input_grid (list of list of int): The input grid.\n\n    Returns:\n        list of list of int: The transformed 6x6 grid.\n\n    Raises:\n        ValueError: If divider lines are invalid, no object is found in a quadrant,\n                    more than one object is found, or an object's bounding box isn't 3x3.\n    \"\"\"\n    # Convert input list of lists to a numpy array\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n\n    # 1. Identify the divider lines and their color\n    divider_color, h_row, v_col = _find_divider_lines(grid)\n    if divider_color == -1:\n        raise ValueError(\"Could not find unique horizontal and vertical divider lines.\")\n\n    # Define colors to exclude when searching for objects\n    excluded_colors = {0, divider_color} # Black (background) and the divider color\n\n    # 2. Create a new 6x6 output grid initialized with black (0).\n    output_grid = np.zeros((6, 6), dtype=int)\n\n    # 3. Define quadrant boundaries (exclusive end indices)\n    # Top-Left (TL)\n    tl_r_start, tl_r_end = 0, h_row\n    tl_c_start, tl_c_end = 0, v_col\n    # Top-Right (TR)\n    tr_r_start, tr_r_end = 0, h_row\n    tr_c_start, tr_c_end = v_col + 1, W\n    # Bottom-Left (BL)\n    bl_r_start, bl_r_end = h_row + 1, H\n    bl_c_start, bl_c_end = 0, v_col\n    # Bottom-Right (BR)\n    br_r_start, br_r_end = h_row + 1, H\n    br_c_start, br_c_end = v_col + 1, W\n\n    # 4. Find object, extract 3x3 region, and place in output grid for each quadrant\n    # Errors during extraction (ValueError) will propagate up.\n\n    # Process Top-Left Quadrant\n    region_tl = _find_and_extract(grid, tl_r_start, tl_r_end, tl_c_start, tl_c_end, excluded_colors)\n    output_grid[0:3, 0:3] = region_tl\n\n    # Process Top-Right Quadrant\n    region_tr = _find_and_extract(grid, tr_r_start, tr_r_end, tr_c_start, tr_c_end, excluded_colors)\n    output_grid[0:3, 3:6] = region_tr\n\n    # Process Bottom-Left Quadrant\n    region_bl = _find_and_extract(grid, bl_r_start, bl_r_end, bl_c_start, bl_c_end, excluded_colors)\n    output_grid[3:6, 0:3] = region_bl\n\n    # Process Bottom-Right Quadrant\n    region_br = _find_and_extract(grid, br_r_start, br_r_end, br_c_start, br_c_end, excluded_colors)\n    output_grid[3:6, 3:6] = region_br\n\n    # 5. Return the resulting 6x6 grid as a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11325,
    "candidates_token_count": 3319,
    "total_token_count": 14644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.704693,
  "retries": null
}