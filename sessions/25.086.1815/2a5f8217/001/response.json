{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all distinct, connected objects (non-white pixels) in the input grid.\nSeparates objects into blue objects (color 1) and non-blue objects (other non-white colors).\nCreates a mapping from object shape to color based on the non-blue objects. If multiple non-blue objects share the same shape, the color of the object whose top-left corner appears latest in a top-to-bottom, left-to-right scan is used.\nIterates through the blue objects. If a blue object's shape matches a shape in the mapping, the blue object is assigned the corresponding color. Both the blue object and the shape entry are marked as used.\nIf exactly one blue object remains unassigned and exactly one color from the original set of non-blue object colors remains unused after the shape-matching step, the remaining blue object is assigned the remaining unused color.\nCreates the output grid by copying the input grid and changing the color of the pixels belonging to the assigned blue objects to their newly assigned colors.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected objects of the same color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'pixels': set of (row, col) tuples for the object's pixels.\n              'color': the color of the object.\n              'top_left': the (row, col) tuple of the top-leftmost pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                objects.append({'pixels': obj_pixels, 'color': color, 'top_left': (min_r, min_c)})\n                \n    return objects\n\ndef get_shape(pixels):\n    \"\"\"\n    Calculates a canonical shape representation for an object.\n\n    Args:\n        pixels (set): A set of (row, col) tuples for the object's pixels.\n\n    Returns:\n        tuple: A sorted tuple of (row, col) tuples representing the shape,\n               normalized relative to the top-left corner. Returns None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n        \n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    \n    # Normalize coordinates relative to the top-left corner\n    shape_coords = tuple(sorted([(r - min_r, c - min_c) for r, c in pixels]))\n    return shape_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Find all objects in the input grid\n    all_objects = find_objects(np.array(input_grid))\n\n    # Separate objects into blue and non-blue\n    blue_objects = []\n    non_blue_objects = []\n    for obj in all_objects:\n        obj['shape'] = get_shape(obj['pixels']) # Add shape representation\n        if obj['color'] == 1:\n            blue_objects.append(obj)\n        elif obj['color'] != 0:\n            non_blue_objects.append(obj)\n\n    # Sort non-blue objects by top-left corner (top-to-bottom, left-to-right)\n    non_blue_objects.sort(key=lambda o: (o['top_left'][0], o['top_left'][1]))\n\n    # Create the shape-to-color map from non-blue objects\n    shape_to_color_map = {}\n    available_non_blue_colors = set()\n    for obj in non_blue_objects:\n        shape_to_color_map[obj['shape']] = obj['color']\n        available_non_blue_colors.add(obj['color'])\n\n    # Perform shape matching\n    recolor_assignments = {} # Map from original blue object index to new color\n    unhandled_blue_indices = list(range(len(blue_objects)))\n    used_shapes = set()\n    used_colors = set()\n\n    for i in unhandled_blue_indices[:]: # Iterate over a copy for safe removal\n        blue_obj = blue_objects[i]\n        blue_shape = blue_obj['shape']\n        if blue_shape in shape_to_color_map and blue_shape not in used_shapes:\n            target_color = shape_to_color_map[blue_shape]\n            # Check if this target color derived from this shape is already used by another match\n            # Find the non-blue object that provided this color for this shape\n            provider_obj = None\n            for nb_obj in reversed(non_blue_objects): # Check in reverse to find the last one\n                if nb_obj['shape'] == blue_shape:\n                    provider_obj = nb_obj\n                    break\n            \n            # Ensure the *specific instance* of the shape/color pair hasn't been conceptually 'used'\n            # In this logic, shape uniqueness is the primary key. If a shape matches, we use its associated color.\n            # We need to track which shapes from the map have been used.\n            \n            recolor_assignments[i] = target_color\n            unhandled_blue_indices.remove(i)\n            used_shapes.add(blue_shape)\n            used_colors.add(target_color) # Track which colors got assigned\n\n    # Handle the remainder case\n    remaining_blue_indices = unhandled_blue_indices\n    unused_colors = available_non_blue_colors - used_colors\n\n    if len(remaining_blue_indices) == 1 and len(unused_colors) == 1:\n        remaining_blue_idx = remaining_blue_indices[0]\n        remaining_color = list(unused_colors)[0]\n        recolor_assignments[remaining_blue_idx] = remaining_color\n        # No need to remove from remaining_blue_indices as we won't iterate further\n\n    # Create the output grid and apply recoloring\n    output_grid = np.array(input_grid).copy()\n    for blue_idx, new_color in recolor_assignments.items():\n        blue_obj = blue_objects[blue_idx]\n        for r, c in blue_obj['pixels']:\n            output_grid[r, c] = new_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3834,
    "candidates_token_count": 1772,
    "total_token_count": 5606,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.60642,
  "retries": null
}