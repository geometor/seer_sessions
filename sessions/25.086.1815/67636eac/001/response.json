{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nExtracts all instances of repeating 3x3 patterns from the input grid. \nEach pattern consists of a single non-white color against a white background within its 3x3 area.\nThe extracted patterns are then arranged adjacent to each other (vertically or horizontally) \nin the output grid based on their overall spatial distribution in the input. \nPatterns are ordered top-to-bottom for vertical arrangement and left-to-right for horizontal arrangement.\n\nColor mapping (for reference):\n0: white, 1: blue, 2: red, 3: green, 4: yellow, \n5: gray, 6: magenta, 7: orange, 8: azure, 9: maroon\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_connected_component(grid, start_r, start_c, visited):\n    \"\"\"\n    Finds all connected cells of the same color starting from (start_r, start_c) using BFS.\n    Updates the visited set. Returns the set of coordinates for the component.\n    Uses 4-way connectivity (up, down, left, right).\n    \"\"\"\n    rows, cols = grid.shape\n    color = grid[start_r, start_c]\n    \n    # Ignore background color (0) or cells already visited as part of another component\n    if color == 0 or (start_r, start_c) in visited: \n        return set()\n\n    q = deque([(start_r, start_c)])\n    component = set()\n    \n    while q:\n        r, c = q.popleft()\n        \n        # Check bounds, visited status, and if the color matches the component's color\n        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited or grid[r, c] != color:\n            continue\n            \n        visited.add((r, c)) # Mark cell as visited for this component search\n        component.add((r, c)) # Add cell to the current component\n        \n        # Add valid neighbors to the queue for exploration\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Add to queue regardless of visited status; the check at the start of the loop handles it.\n            q.append((nr, nc))\n                 \n    return component\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box (min_r, min_c, max_r, max_c) \n    for a non-empty set of coordinates {(r, c), ...}.\n    \"\"\"\n    if not coords:\n        # This should ideally not be reached if called after finding a non-empty component\n        raise ValueError(\"Cannot get bounding box for empty set of coordinates.\") \n        \n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies 3x3 patterns in the input grid, determines their overall spatial layout \n    (predominantly vertical or horizontal), sorts them accordingly, and concatenates \n    them into the output grid.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    \n    # Handle empty input grid case\n    if rows == 0 or cols == 0:\n        return []\n        \n    visited = set() # Keep track of pixels already assigned to a component\n    patterns = [] # Stores tuples: (top_left_row, top_left_col, extracted_3x3_subgrid_np_array)\n\n    # Step 1: Scan grid to find connected components of non-white colors\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is non-white and not yet visited\n            if grid_np[r, c] != 0 and (r, c) not in visited:\n                # Find the full connected component of the same color\n                component_coords = find_connected_component(grid_np, r, c, visited)\n                \n                # Skip if the component finding didn't yield coordinates (e.g., started on visited cell)\n                if not component_coords:\n                    continue\n\n                # Step 2: Calculate the bounding box of the found component\n                min_r, min_c, max_r, max_c = get_bounding_box(component_coords)\n                \n                # Step 3: Check if the bounding box dimensions are exactly 3x3\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                if height == 3 and width == 3:\n                    # Step 4: Extract the 3x3 subgrid from the input grid corresponding to the bounding box\n                    # This subgrid contains the pattern including any background pixels within the 3x3 area\n                    subgrid_3x3 = grid_np[min_r:min_r+3, min_c:min_c+3]\n                    \n                    # Store the pattern's top-left corner coordinates and the extracted grid data\n                    patterns.append((min_r, min_c, subgrid_3x3))\n\n    # Step 5: Handle cases based on the number of patterns found\n    if not patterns:\n        # No patterns matching the criteria were found\n        return [] \n    if len(patterns) == 1:\n        # Only one pattern found, output is just that pattern\n        return patterns[0][2].tolist()\n\n    # Step 6: Determine the overall spatial arrangement (vertical or horizontal)\n    # Collect the top-left coordinates of all found patterns\n    coords = [(r, c) for r, c, _ in patterns]\n    min_r_all = min(r for r, c in coords)\n    max_r_all = max(r for r, c in coords)\n    min_c_all = min(c for r, c in coords)\n    max_c_all = max(c for r, c in coords)\n    \n    # Calculate the vertical and horizontal span covering all pattern top-left corners\n    height_span = max_r_all - min_r_all\n    width_span = max_c_all - min_c_all\n    \n    # Determine arrangement: if height span is greater, stack vertically. Otherwise (including equal span), stack horizontally.\n    arrangement = 'vertical' if height_span > width_span else 'horizontal'\n\n    # Step 7: Sort the patterns based on their original position and the determined arrangement\n    if arrangement == 'vertical':\n        # Sort primarily by the top row index (min_r) for top-to-bottom order\n        patterns.sort(key=lambda p: p[0]) \n    else: # arrangement == 'horizontal'\n        # Sort primarily by the left column index (min_c) for left-to-right order\n        patterns.sort(key=lambda p: p[1])\n\n    # Step 8: Construct the final output grid by concatenating the sorted patterns\n    # Get the list of 3x3 numpy arrays in the correct sorted order\n    sorted_grids = [p[2] for p in patterns]\n    \n    if arrangement == 'vertical':\n        # Stack the 3x3 grids one above the other\n        output_np = np.vstack(sorted_grids)\n    else: # arrangement == 'horizontal'\n        # Stack the 3x3 grids side-by-side\n        output_np = np.hstack(sorted_grids)\n        \n    # Step 9: Convert the final numpy array back to the required list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3561,
    "candidates_token_count": 1836,
    "total_token_count": 5397,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.60748,
  "retries": null
}