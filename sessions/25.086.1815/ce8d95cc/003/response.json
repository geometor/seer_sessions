{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nCondense a grid by representing it as an intersection of significant horizontal and vertical lines.\n\n1.  Identify Horizontal Lines: Scan the input grid row by row. Identify rows that are completely filled with a single non-white color. Record the row index and the color for each such horizontal line found.\n2.  Identify Vertical Lines: Scan the input grid column by column. For each column, consider only the rows that were *not* identified as horizontal lines in step 1. Examine the pixels in this column within these specific rows. If there is at least one non-white pixel among them, and *all* non-white pixels share the same color, then identify this column as a vertical line. Record the column index and the shared color for each vertical line found, maintaining their left-to-right order.\n3.  Determine Output Dimensions: Calculate the output grid height as 2 * (number of horizontal lines) + 1 and the width as 2 * (number of vertical lines) + 1.\n4.  Initialize Output Grid: Create an output grid of the calculated dimensions, filled with white (0).\n5.  Populate Output Grid: Iterate through the output grid cells (r_out, c_out).\n    *   If r_out is odd and c_out is odd (Intersection Point): Fill with the color from the input grid at the intersection of the corresponding original horizontal line row and vertical line column.\n    *   If r_out is odd and c_out is even (Horizontal Line Segment): Fill with the color of the corresponding horizontal line.\n    *   If r_out is even and c_out is odd (Vertical Line Segment): Fill with the color of the corresponding vertical line.\n    *   If r_out is even and c_out is even (Background Corner): Leave as white (0).\n6.  Return the populated output grid.\n\"\"\"\n\n\ndef find_horizontal_lines(grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Identifies rows that are completely filled with a single non-white color.\n    Returns a list of tuples (row_index, color).\n    \"\"\"\n    h_lines = []\n    height, width = grid.shape\n    for r in range(height):\n        row = grid[r, :]\n        non_white_pixels = row[row != 0]\n        # Check if the row contains any non-white pixels\n        if len(non_white_pixels) > 0:\n            # Check if all pixels in the row are non-white (i.e., length matches width)\n            # and if all these non-white pixels are the same color\n            if len(non_white_pixels) == width:\n                 first_color = non_white_pixels[0]\n                 if np.all(non_white_pixels == first_color):\n                     h_lines.append((r, first_color))\n    return h_lines\n\ndef find_vertical_lines(grid: np.ndarray, h_line_indices: List[int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Identifies columns that represent vertical lines based on segments between horizontal lines.\n    A column is a vertical line if, considering only rows *not* in h_line_indices,\n    it contains at least one non-white pixel, and all such non-white pixels share the same color.\n    Returns a list of tuples (column_index, color).\n    \"\"\"\n    v_lines = []\n    height, width = grid.shape\n    h_line_set = set(h_line_indices)\n    # Rows that are NOT horizontal lines (these define the segments)\n    segment_rows = [r for r in range(height) if r not in h_line_set]\n\n    # If there are no segment rows, we can't find vertical lines this way.\n    if not segment_rows:\n        return []\n\n    for c in range(width):\n        # Extract the part of the column that falls within the segments\n        column_segment = grid[segment_rows, c]\n        non_white_pixels = column_segment[column_segment != 0]\n        if len(non_white_pixels) > 0:\n            first_color = non_white_pixels[0]\n            if np.all(non_white_pixels == first_color):\n                v_lines.append((c, first_color))\n    return v_lines\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on horizontal and vertical line structures.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n\n    # 1. Find Horizontal Lines (rows completely filled with one non-white color)\n    h_lines = find_horizontal_lines(grid)\n    h_line_indices = [r for r, c in h_lines]\n\n    # 2. Find Vertical Lines (based on segments between horizontal lines)\n    v_lines = find_vertical_lines(grid, h_line_indices)\n\n    # 3. Determine Output Dimensions\n    output_height = 2 * len(h_lines) + 1\n    output_width = 2 * len(v_lines) + 1\n\n    # 4. Initialize Output Grid (default to white)\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 5. Populate Output Grid\n    for r_out in range(output_height):\n        is_intersection_row = r_out % 2 != 0 # Corresponds to an h_line\n\n        for c_out in range(output_width):\n            is_intersection_col = c_out % 2 != 0 # Corresponds to a v_line\n\n            h_idx = r_out // 2\n            v_idx = c_out // 2\n\n            # Ensure indices are valid before accessing h_lines/v_lines\n            valid_h_idx = 0 <= h_idx < len(h_lines)\n            valid_v_idx = 0 <= v_idx < len(v_lines)\n\n            if is_intersection_row and is_intersection_col:\n                # Case 1: Intersection Point (r_out odd, c_out odd)\n                if valid_h_idx and valid_v_idx:\n                    r_in = h_lines[h_idx][0]\n                    c_in = v_lines[v_idx][0]\n                    # Check if input indices are within bounds (safety check)\n                    if 0 <= r_in < grid.shape[0] and 0 <= c_in < grid.shape[1]:\n                         output_grid[r_out, c_out] = grid[r_in, c_in]\n                    # else: remains 0 (white) - should not happen with valid indices\n\n            elif is_intersection_row and not is_intersection_col:\n                # Case 2: Horizontal Line Segment (r_out odd, c_out even)\n                 if valid_h_idx:\n                     h_color = h_lines[h_idx][1]\n                     output_grid[r_out, c_out] = h_color\n                 # else: remains 0 (white)\n\n            elif not is_intersection_row and is_intersection_col:\n                # Case 3: Vertical Line Segment (r_out even, c_out odd)\n                if valid_v_idx:\n                    v_color = v_lines[v_idx][1]\n                    output_grid[r_out, c_out] = v_color\n                # else: remains 0 (white)\n\n            else: # not is_intersection_row and not is_intersection_col\n                # Case 4: Background Corner (r_out even, c_out even)\n                # Already initialized to 0 (white), so no action needed.\n                pass\n\n    # 6. Return Output Grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10251,
    "candidates_token_count": 1827,
    "total_token_count": 12078,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.475606,
  "retries": null
}