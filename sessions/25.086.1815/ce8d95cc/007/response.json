{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict\nfrom collections import Counter\nimport collections\n\n\"\"\"\nCompresses an input grid by identifying major structural rows and columns and \nrepresenting their intersections and the segments between them in a smaller grid.\n\n1.  Identify Major Columns: Scan the input grid column by column. A column is \n    considered \"major\" if it either contains more than one distinct non-white \n    color OR if the entire column consists of a single non-white color. Record \n    the indices of these major columns in order.\n2.  Identify Major Rows: Scan the input grid row by row. Consider only the \n    pixels in a row that do *not* belong to any major column identified in step 1. \n    A row is considered \"major\" if, within these non-major column positions, it \n    either contains more than one distinct non-white color OR if all its \n    non-major column positions are filled with the same single non-white color. \n    Record the indices of these major rows in order.\n3.  Determine Output Dimensions: Calculate the output grid height as \n    `2 * (number of major rows) + 1` and the width as \n    `2 * (number of major columns) + 1`.\n4.  Initialize Output Grid: Create an output grid of the calculated dimensions, \n    filled entirely with white (color 0).\n5.  Populate Output Grid: Iterate through each cell `(r_out, c_out)` of the \n    output grid:\n    *   Intersection Points (r_out is odd, c_out is odd): Find the corresponding \n        major row index `r_in = major_rows[r_out // 2]` and major column index \n        `c_in = major_cols[c_out // 2]`. Fill the output cell `(r_out, c_out)` \n        with the color from the input grid at `input[r_in, c_in]`.\n    *   Horizontal Segments (r_out is odd, c_out is even): Find the corresponding \n        major row index `r_in = major_rows[r_out // 2]`. Determine the range of \n        input columns *between* the relevant major columns (or from the edge to \n        the first/last major column). Collect all non-white pixels from \n        `input[r_in, c]` within this column range. Fill the output cell \n        `(r_out, c_out)` with the most frequent non-white color found (using the \n        smallest color index in case of a tie). If no non-white pixels exist in \n        the segment, leave the cell white (0).\n    *   Vertical Segments (r_out is even, c_out is odd): Find the corresponding \n        major column index `c_in = major_cols[c_out // 2]`. Determine the range \n        of input rows *between* the relevant major rows (or from the edge to \n        the first/last major row). Collect all non-white pixels from \n        `input[r, c_in]` within this row range. Fill the output cell \n        `(r_out, c_out)` with the most frequent non-white color found (using the \n        smallest color index in case of a tie). If no non-white pixels exist in \n        the segment, leave the cell white (0).\n    *   Corner Points (r_out is even, c_out is even): Leave the output cell \n        white (0).\n6.  Return the populated output grid.\n\"\"\"\n\ndef find_most_frequent(colors: List[int]) -> Optional[int]:\n    \"\"\"\n    Finds the most frequent non-white color in a list of colors.\n    Returns the color, or 0 if the list is empty or contains only white.\n    Handles ties by returning the smallest color index among the most frequent.\n    \"\"\"\n    non_white_colors = [c for c in colors if c != 0]\n    if not non_white_colors:\n        return 0 # Return white if no non-white colors\n\n    counts = Counter(non_white_colors)\n    if not counts:\n         return 0 # Should not happen if non_white_colors is not empty, but safety check\n\n    max_count = 0\n    # Find the maximum count\n    # Use try-except in case counts is empty, though logic above should prevent it\n    try:\n        max_count = counts.most_common(1)[0][1]\n    except IndexError:\n        return 0 # Return white if Counter failed unexpectedly\n\n    # Find all colors with the maximum count\n    most_common_colors = sorted([color for color, count in counts.items() if count == max_count])\n\n    # Return the smallest color index among the most frequent\n    return most_common_colors[0] if most_common_colors else 0\n\n\ndef find_major_columns(grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Identifies major columns based on the criteria:\n    - Contains more than one distinct non-white color.\n    - Is entirely filled with the same single non-white color.\n    Returns a list of major column indices.\n    \"\"\"\n    major_cols = []\n    height, width = grid.shape\n    for c in range(width):\n        column = grid[:, c]\n        non_white_pixels = column[column != 0]\n        unique_non_white = np.unique(non_white_pixels)\n\n        if len(unique_non_white) > 1:\n            # Criterion 1: More than one distinct non-white color\n            major_cols.append(c)\n        elif len(unique_non_white) == 1:\n            # Check if it's a single non-white color\n            # Criterion 2: Entire column is this single non-white color\n            if len(non_white_pixels) == height:\n                 major_cols.append(c)\n    return major_cols\n\ndef find_major_rows(grid: np.ndarray, major_col_indices: List[int]) -> List[int]:\n    \"\"\"\n    Identifies major rows based on pixels in non-major columns:\n    - Contains more than one distinct non-white color in non-major columns.\n    - All non-major column positions are filled with the same single non-white color.\n    Returns a list of major row indices.\n    \"\"\"\n    major_rows = []\n    height, width = grid.shape\n    major_col_set = set(major_col_indices)\n    non_major_cols = [c for c in range(width) if c not in major_col_set]\n\n    if not non_major_cols: # Handle case where all columns are major\n        return []\n\n    for r in range(height):\n        row_segment = grid[r, non_major_cols]\n        non_white_pixels = row_segment[row_segment != 0]\n        unique_non_white = np.unique(non_white_pixels)\n\n        if len(unique_non_white) > 1:\n            # Criterion 1: More than one distinct non-white color in non-major cols\n            major_rows.append(r)\n        elif len(unique_non_white) == 1:\n            # Check if it's a single non-white color\n            # Criterion 2: All non-major positions are this single non-white color\n            if len(non_white_pixels) == len(non_major_cols):\n                 major_rows.append(r)\n    return major_rows\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the revised grid compression transformation.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Identify Major Columns\n    major_cols = find_major_columns(grid)\n    major_col_set = set(major_cols) # For faster lookups\n\n    # 2. Identify Major Rows\n    major_rows = find_major_rows(grid, major_cols)\n    major_row_set = set(major_rows) # For faster lookups\n\n    # 3. Determine Output Dimensions\n    output_height = 2 * len(major_rows) + 1\n    output_width = 2 * len(major_cols) + 1\n\n    # 4. Initialize Output Grid\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 5. Populate Output Grid\n    for r_out in range(output_height):\n        is_major_row_line = r_out % 2 != 0 # Corresponds to a major row index\n\n        for c_out in range(output_width):\n            is_major_col_line = c_out % 2 != 0 # Corresponds to a major column index\n\n            if is_major_row_line and is_major_col_line:\n                # Case: Intersection Point (r_out odd, c_out odd)\n                r_idx = r_out // 2\n                c_idx = c_out // 2\n                if 0 <= r_idx < len(major_rows) and 0 <= c_idx < len(major_cols):\n                    r_in = major_rows[r_idx]\n                    c_in = major_cols[c_idx]\n                    output_grid[r_out, c_out] = grid[r_in, c_in]\n\n            elif is_major_row_line and not is_major_col_line:\n                # Case: Horizontal Segment (r_out odd, c_out even)\n                r_idx = r_out // 2\n                if 0 <= r_idx < len(major_rows):\n                    r_in = major_rows[r_idx]\n                    # Determine column range for the segment\n                    c_idx_major = c_out // 2 # index *in major_cols* for the *next* major col\n                    c_start = major_cols[c_idx_major - 1] + 1 if c_idx_major > 0 else 0\n                    c_end = major_cols[c_idx_major] if c_idx_major < len(major_cols) else width\n                    \n                    if c_start < c_end:\n                       segment_pixels = grid[r_in, c_start:c_end].tolist()\n                       dominant_color = find_most_frequent(segment_pixels)\n                       output_grid[r_out, c_out] = dominant_color\n                    # else segment is empty, remains 0\n\n            elif not is_major_row_line and is_major_col_line:\n                # Case: Vertical Segment (r_out even, c_out odd)\n                c_idx = c_out // 2\n                if 0 <= c_idx < len(major_cols):\n                    c_in = major_cols[c_idx]\n                    # Determine row range for the segment\n                    r_idx_major = r_out // 2 # index *in major_rows* for the *next* major row\n                    r_start = major_rows[r_idx_major - 1] + 1 if r_idx_major > 0 else 0\n                    r_end = major_rows[r_idx_major] if r_idx_major < len(major_rows) else height\n\n                    if r_start < r_end:\n                        segment_pixels = grid[r_start:r_end, c_in].tolist()\n                        dominant_color = find_most_frequent(segment_pixels)\n                        output_grid"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5397,
    "candidates_token_count": 2709,
    "total_token_count": 8106,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 199.343694,
  "retries": null
}