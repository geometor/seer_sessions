{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict\nfrom collections import Counter\n\n\"\"\"\nCompresses an input grid by extracting significant rows and columns and arranging \nthem into a new grid that represents their intersections and connecting segments.\n\n1.  Identify Significant Rows: Scan the input grid row by row. A row is \n    considered \"significant\" if it either contains more than one distinct \n    non-white color OR if the entire row consists of a single non-white color. \n    Record the indices of these significant rows in order.\n2.  Identify Significant Columns: Scan the input grid column by column. A column \n    is considered \"significant\" if it contains any non-white pixel located in \n    a row whose index was *not* identified as a significant row in step 1. \n    Record the indices of these significant columns in order.\n3.  Determine Output Dimensions: Calculate the output grid height as \n    `2 * (number of significant rows) + 1` and the width as \n    `2 * (number of significant columns) + 1`.\n4.  Initialize Output Grid: Create an output grid of the calculated dimensions, \n    filled entirely with white (color 0).\n5.  Populate Output Grid: Iterate through each cell `(r_out, c_out)` of the \n    output grid:\n    *   Intersection Points (r_out is odd, c_out is odd): Find the \n        corresponding significant row index `r_in = sig_rows[r_out // 2]` and \n        significant column index `c_in = sig_cols[c_out // 2]`. Fill the output \n        cell `(r_out, c_out)` with the color from the input grid at \n        `input[r_in, c_in]`.\n    *   Horizontal Segments (r_out is odd, c_out is even): Find the \n        corresponding significant row index `r_in = sig_rows[r_out // 2]`. \n        Examine the pixels in this input row `input[r_in, :]` located at column \n        indices that are *not* significant columns. Identify the most frequent \n        non-white color among these pixels. Fill the output cell `(r_out, c_out)` \n        with this dominant color (if no such non-white pixels exist, leave it \n        white).\n    *   Vertical Segments (r_out is even, c_out is odd): Find the \n        corresponding significant column index `c_in = sig_cols[c_out // 2]`. \n        Examine the pixels in this input column `input[:, c_in]` located at \n        row indices that are *not* significant rows. Identify the most frequent \n        non-white color among these pixels. Fill the output cell `(r_out, c_out)` \n        with this dominant color (if no such non-white pixels exist, leave it \n        white).\n    *   Corner Points (r_out is even, c_out is even): Leave the output cell \n        white (0).\n6.  Return the populated output grid.\n\"\"\"\n\ndef find_significant_rows(grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Identifies significant rows based on the criteria:\n    - Contains more than one distinct non-white color.\n    - Is entirely filled with the same single non-white color.\n    Returns a list of significant row indices.\n    \"\"\"\n    sig_rows = []\n    height, width = grid.shape\n    for r in range(height):\n        row = grid[r, :]\n        non_white_pixels = row[row != 0]\n        unique_non_white = np.unique(non_white_pixels)\n\n        if len(unique_non_white) > 1:\n            # Criterion 1: More than one distinct non-white color\n            sig_rows.append(r)\n        elif len(unique_non_white) == 1:\n            # Check if it's a single non-white color\n            # Criterion 2: Entire row is this single non-white color\n            if len(non_white_pixels) == width:\n                 sig_rows.append(r)\n    return sig_rows\n\ndef find_significant_columns(grid: np.ndarray, sig_row_indices: List[int]) -> List[int]:\n    \"\"\"\n    Identifies significant columns based on the criteria:\n    - Contains at least one non-white pixel at a row index that is NOT significant.\n    Returns a list of significant column indices.\n    \"\"\"\n    sig_cols = []\n    height, width = grid.shape\n    sig_row_set = set(sig_row_indices)\n\n    for c in range(width):\n        column = grid[:, c]\n        found_non_white_outside_sig_row = False\n        for r in range(height):\n            if grid[r, c] != 0 and r not in sig_row_set:\n                found_non_white_outside_sig_row = True\n                break # Found one, no need to check further in this column\n        if found_non_white_outside_sig_row:\n            sig_cols.append(c)\n    return sig_cols\n\ndef find_most_frequent(colors: List[int]) -> Optional[int]:\n    \"\"\"\n    Finds the most frequent color in a list of colors.\n    Returns the color, or None if the list is empty.\n    Handles ties by returning the smallest color index (arbitrary but consistent).\n    \"\"\"\n    if not colors:\n        return None\n    \n    counts = Counter(colors)\n    # Find the maximum count\n    max_count = 0\n    for color in counts:\n        if counts[color] > max_count:\n            max_count = counts[color]\n            \n    # Find all colors with the maximum count\n    most_common_colors = [color for color, count in counts.items() if count == max_count]\n    \n    # If there's a tie, return the smallest color index among the most frequent\n    if not most_common_colors: # Should not happen if input list is not empty\n         return None\n    return min(most_common_colors)\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the grid compression transformation.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Identify Significant Rows\n    sig_rows = find_significant_rows(grid)\n    sig_row_set = set(sig_rows) # For faster lookups\n\n    # 2. Identify Significant Columns\n    sig_cols = find_significant_columns(grid, sig_rows)\n    sig_col_set = set(sig_cols) # For faster lookups\n\n    # 3. Determine Output Dimensions\n    output_height = 2 * len(sig_rows) + 1\n    output_width = 2 * len(sig_cols) + 1\n\n    # 4. Initialize Output Grid\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 5. Populate Output Grid\n    for r_out in range(output_height):\n        is_sig_row_line = r_out % 2 != 0 # Corresponds to a significant row index\n\n        for c_out in range(output_width):\n            is_sig_col_line = c_out % 2 != 0 # Corresponds to a significant column index\n\n            if is_sig_row_line and is_sig_col_line:\n                # Case: Intersection Point (r_out odd, c_out odd)\n                r_idx_in_list = r_out // 2\n                c_idx_in_list = c_out // 2\n                if 0 <= r_idx_in_list < len(sig_rows) and 0 <= c_idx_in_list < len(sig_cols):\n                    r_in = sig_rows[r_idx_in_list]\n                    c_in = sig_cols[c_idx_in_list]\n                    output_grid[r_out, c_out] = grid[r_in, c_in]\n                # else: remains 0 (should not happen with valid indices)\n\n            elif is_sig_row_line and not is_sig_col_line:\n                # Case: Horizontal Segment (r_out odd, c_out even)\n                r_idx_in_list = r_out // 2\n                if 0 <= r_idx_in_list < len(sig_rows):\n                    r_in = sig_rows[r_idx_in_list]\n                    # Collect non-white colors in this row from non-significant columns\n                    segment_colors = [grid[r_in, c] for c in range(width) if c not in sig_col_set and grid[r_in, c] != 0]\n                    dominant_color = find_most_frequent(segment_colors)\n                    output_grid[r_out, c_out] = dominant_color if dominant_color is not None else 0\n                # else: remains 0\n\n            elif not is_sig_row_line and is_sig_col_line:\n                # Case: Vertical Segment (r_out even, c_out odd)\n                c_idx_in_list = c_out // 2\n                if 0 <= c_idx_in_list < len(sig_cols):\n                    c_in = sig_cols[c_idx_in_list]\n                    # Collect non-white colors in this column from non-significant rows\n                    segment_colors = [grid[r, c_in] for r in range(height) if r not in sig_row_set and grid[r, c_in] != 0]\n                    dominant_color = find_most_frequent(segment_colors)\n                    output_grid[r_out, c_out] = dominant_color if dominant_color is not None else 0\n                # else: remains 0\n\n            else: # not is_sig_row_line and not is_sig_col_line\n                # Case: Background Corner (r_out even, c_out even)\n                # Already initialized to 0 (white), so no action needed.\n                pass\n\n    # 6. Return Output Grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13145,
    "candidates_token_count": 2425,
    "total_token_count": 15570,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.841692,
  "retries": null
}