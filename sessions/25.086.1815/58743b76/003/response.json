{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule identifies a 2x2 key block of colors, typically located near a corner, distinct from the background (usually white 0) and a potential border (usually azure 8). It also identifies a single 'target' color present elsewhere in the grid (excluding background, border, and key). The rule then divides the bounding box of all target color pixels into four quadrants based on its center. Each target color pixel *that is not part of the key* is then replaced by one of the four key colors, depending on which quadrant the pixel falls into: top-left quadrant maps to the top-left key color, top-right quadrant to top-right key color, bottom-left quadrant to bottom-left key color, and bottom-right quadrant to bottom-right key color. Other pixels (background, border, key pixels, and any target color pixels outside the bounding box if any existed) remain unchanged.\n\"\"\"\n\ndef find_key(grid, border_color, background_color):\n    \"\"\"\n    Finds the 2x2 key block in the grid.\n    The key is the first 2x2 block encountered (scanning row-by-row, then col-by-col)\n    where all four cells are neither the border_color nor the background_color.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color assumed to be the border.\n        background_color (int): The color assumed to be the background.\n\n    Returns:\n        tuple: (key_r, key_c, k00, k01, k10, k11) or None if not found.\n               key_r, key_c: top-left coordinates of the key.\n               k00, k01, k10, k11: the four colors of the key.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            k00 = grid[r, c]\n            k01 = grid[r, c+1]\n            k10 = grid[r+1, c]\n            k11 = grid[r+1, c+1]\n            \n            colors = [k00, k01, k10, k11]\n            \n            is_key = True\n            for color in colors:\n                # Check if any color in the 2x2 block matches border or background\n                if color == border_color or color == background_color:\n                    is_key = False\n                    break\n            \n            if is_key:\n                # If all colors are valid, return the key info\n                return r, c, k00, k01, k10, k11\n    # Return None if no key is found\n    return None\n\ndef find_target_color(grid, border_color, background_color, key_coords, key_colors):\n    \"\"\"\n    Finds the color that needs to be transformed.\n    It's the most frequent color in the grid, excluding border, background,\n    and key colors.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color assumed to be the border.\n        background_color (int): The color assumed to be the background.\n        key_coords (tuple): (key_r, key_c) top-left coordinates of the key.\n        key_colors (list): The four colors [k00, k01, k10, k11] of the key.\n\n\n    Returns:\n        int or None: The target color, or None if no candidate pixels found.\n    \"\"\"\n    height, width = grid.shape\n    candidate_pixels = []\n    key_r, key_c = key_coords\n    # Define the set of positions occupied by the key\n    key_positions = {\n        (key_r, key_c), (key_r, key_c + 1),\n        (key_r + 1, key_c), (key_r + 1, key_c + 1)\n    }\n    \n    # Iterate through all pixels in the grid\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the pixel is not border, background, or part of the key block\n            # Note: We only need to exclude pixels by position, as colors might overlap.\n            # However, the original description implied excluding the key *colors* generally.\n            # Let's stick to excluding based on position for now, aligning with the updated logic.\n            # It might be safer to exclude the specific colors found in the key.\n            # Let's refine: exclude border, background, and any pixel whose position is in the key.\n            if color != border_color and \\\n               color != background_color and \\\n               (r, c) not in key_positions:\n                candidate_pixels.append(color)\n\n    # If no candidate pixels were found, return None\n    if not candidate_pixels:\n        return None\n\n    # Count the frequency of each candidate color\n    count = Counter(candidate_pixels)\n    # The target color is the most frequent one\n    target_color = count.most_common(1)[0][0]\n    return target_color\n\ndef find_bounding_box(grid, target_color):\n    \"\"\"\n    Finds the minimum bounding box containing all pixels of target_color.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find the bounding box for.\n\n    Returns:\n        tuple or None: (min_r, max_r, min_c, max_c) or None if target_color not found.\n    \"\"\"\n    # Find all row and column indices where the grid matches the target color\n    rows, cols = np.where(grid == target_color)\n\n    # If no pixels match the target color, return None\n    if rows.size == 0:\n        return None\n\n    # Determine the min/max row and column indices\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    \n    return min_r, max_r, min_c, max_c\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the quadrant-based color transformation based on a 2x2 key.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    \n    # Convert input list of lists to a numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy of the grid to modify, preserving the original\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Define assumed border and background colors based on examples\n    border_color = 8  # Typically azure\n    background_color = 0 # Typically white\n\n    # --- Step 1: Find the 2x2 key ---\n    key_info = find_key(grid, border_color, background_color)\n    if key_info is None:\n        # If no key is found, assume no transformation is needed and return the original grid\n        # print(\"No key found.\")\n        return output_grid.tolist() \n        \n    key_r, key_c, k00, k01, k10, k11 = key_info\n    key_coords = (key_r, key_c)\n    key_colors = [k00, k01, k10, k11]\n    # Define the set of positions occupied by the key\n    key_positions = {\n        (key_r, key_c), (key_r, key_c + 1),\n        (key_r + 1, key_c), (key_r + 1, key_c + 1)\n    }\n    # print(f\"Key found at ({key_r}, {key_c}) with colors {key_colors}\")\n\n\n    # --- Step 2: Find the target color ---\n    # Target color is the most frequent color excluding border, background, and key *pixels*.\n    target_color = find_target_color(grid, border_color, background_color, key_coords, key_colors)\n    if target_color is None:\n        # If no target color found (e.g., grid only has border, bg, key), return original grid\n        # print(\"No target color found.\")\n        return output_grid.tolist()\n    # print(f\"Target color identified as: {target_color}\")\n\n\n    # --- Step 3: Find the bounding box of the target color pixels ---\n    bbox = find_bounding_box(grid, target_color)\n    if bbox is None:\n         # Should not happen if target_color was found, but include as a safety check\n        # print(\"Bounding box not found for target color (unexpected).\")\n        return output_grid.tolist()\n\n    min_r, max_r, min_c, max_c = bbox\n    # print(f\"Bounding box for target color: rows {min_r}-{max_r}, cols {min_c}-{max_c}\")\n\n\n    # --- Step 4: Calculate the center of the bounding box ---\n    # Use floating point for potentially non-integer center, crucial for quadrant division\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n    # print(f\"Center of bounding box: ({center_r}, {center_c})\")\n\n\n    # --- Step 5: Iterate through the grid and apply transformation ---\n    for r in range(height):\n        for c in range(width):\n            # Check if the current pixel has the target color\n            # AND importantly, check if it's NOT part of the key block\n            if grid[r, c] == target_color and (r, c) not in key_positions:\n                \n                # Determine the quadrant relative to the center\n                # Note: Pixels exactly on the center line go to bottom/right halves\n                if r < center_r and c < center_c:\n                    # Top-left quadrant\n                    output_grid[r, c] = k00  \n                elif r < center_r and c >= center_c:\n                    # Top-right quadrant\n                    output_grid[r, c] = k01  \n                elif r >= center_r and c < center_c:\n                    # Bottom-left quadrant\n                    output_grid[r, c] = k10  \n                elif r >= center_r and c >= center_c:\n                    # Bottom-right quadrant\n                    output_grid[r, c] = k11  \n\n    # Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4497,
    "candidates_token_count": 2551,
    "total_token_count": 7048,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 98.393923,
  "retries": null
}