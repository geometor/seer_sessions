{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies a 2x2 key block of colors, typically located near a corner, distinct from the background (usually white 0) and a potential border (usually azure 8). It also identifies a single 'target' color, which is the most frequent color present elsewhere in the grid (excluding background, border, and the pixels *at the key's location*). The rule then determines the bounding box encompassing *all* pixels of the target color (including any within the key block). Based on the center of this bounding box, the grid is conceptually divided into four quadrants. Each pixel having the target color *that is not part of the key block* is then replaced by one of the four key colors, depending on which quadrant the pixel falls into: top-left quadrant (r <= center_r, c < center_c) maps to the top-left key color, top-right quadrant (r <= center_r, c >= center_c) to top-right key color, bottom-left quadrant (r > center_r, c < center_c) to bottom-left key color, and bottom-right quadrant (r > center_r, c >= center_c) to bottom-right key color. Other pixels (background, border, key pixels, and any non-target color pixels) remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_key(grid, border_color, background_color):\n    \"\"\"\n    Finds the first 2x2 key block scanning top-to-bottom, left-to-right.\n    A key block has no border or background colored pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color designated as the border.\n        background_color (int): The color designated as the background.\n\n    Returns:\n        tuple: (key_r, key_c, k00, k01, k10, k11) top-left coords and colors,\n               or None if no key is found.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Extract 2x2 block colors\n            k00 = grid[r, c]\n            k01 = grid[r, c+1]\n            k10 = grid[r+1, c]\n            k11 = grid[r+1, c+1]\n            colors = [k00, k01, k10, k11]\n\n            # Check if any color in the block is background or border\n            is_valid_key = True\n            for color in colors:\n                if color == border_color or color == background_color:\n                    is_valid_key = False\n                    break\n            \n            # If all colors are valid, this is the key\n            if is_valid_key:\n                return r, c, k00, k01, k10, k11\n    # No key found\n    return None\n\ndef find_target_color(grid, border_color, background_color, key_positions):\n    \"\"\"\n    Finds the most frequent color excluding border, background, and key pixels.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The border color.\n        background_color (int): The background color.\n        key_positions (set): A set of (r, c) tuples representing key locations.\n\n    Returns:\n        int or None: The target color, or None if no candidates found.\n    \"\"\"\n    height, width = grid.shape\n    candidate_pixels = []\n    \n    # Iterate through all pixels to find candidates for target color\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Pixel is a candidate if not border, background, and not in key position\n            if color != border_color and \\\n               color != background_color and \\\n               (r, c) not in key_positions:\n                candidate_pixels.append(color)\n\n    # If no candidates found, return None\n    if not candidate_pixels:\n        return None\n\n    # Count frequency and return the most common color\n    count = Counter(candidate_pixels)\n    target_color = count.most_common(1)[0][0]\n    return target_color\n\ndef find_bounding_box(grid, target_color):\n    \"\"\"\n    Finds the minimum bounding box containing ALL pixels of target_color.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find the bounding box for.\n\n    Returns:\n        tuple or None: (min_r, max_r, min_c, max_c) or None if target_color not found.\n    \"\"\"\n    # Find indices of all pixels matching the target color\n    rows, cols = np.where(grid == target_color)\n\n    # If no such pixels exist, return None\n    if rows.size == 0:\n        return None\n\n    # Determine min/max row and column indices\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    \n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the quadrant-based color transformation based on a 2x2 key.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify for the output\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Define assumed border and background colors\n    border_color = 8  # azure\n    background_color = 0 # white\n\n    # 1. Identify Key\n    key_info = find_key(grid, border_color, background_color)\n    if key_info is None:\n        # No key found, return the original grid\n        return output_grid.tolist() \n        \n    key_r, key_c, k00, k01, k10, k11 = key_info\n    # Store the set of coordinates occupied by the key\n    key_positions = {\n        (key_r, key_c), (key_r, key_c + 1),\n        (key_r + 1, key_c), (key_r + 1, key_c + 1)\n    }\n\n    # 2. Identify Target Color\n    target_color = find_target_color(grid, border_color, background_color, key_positions)\n    if target_color is None:\n        # No target color found, return the original grid\n        return output_grid.tolist()\n\n    # 3. Determine Target Bounding Box and Center\n    bbox = find_bounding_box(grid, target_color)\n    if bbox is None:\n         # Should not happen if target_color was found, but safety check\n        return output_grid.tolist()\n    min_r, max_r, min_c, max_c = bbox\n\n    # Calculate the center of the bounding box (can be float)\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n\n    # 4. Apply Quadrant Transformation\n    for r in range(height):\n        for c in range(width):\n            # Check if the pixel has the target color AND is NOT part of the key\n            if grid[r, c] == target_color and (r, c) not in key_positions:\n                \n                # Determine the quadrant relative to the center based on refined rules\n                # Pixels exactly on horizontal center line go to TOP halves\n                # Pixels exactly on vertical center line go to RIGHT halves\n                if r <= center_r and c < center_c:\n                    # Top-left quadrant -> top-left key color\n                    output_grid[r, c] = k00  \n                elif r <= center_r and c >= center_c:\n                    # Top-right quadrant -> top-right key color\n                    output_grid[r, c] = k01  \n                elif r > center_r and c < center_c:\n                    # Bottom-left quadrant -> bottom-left key color\n                    output_grid[r, c] = k10  \n                elif r > center_r and c >= center_c:\n                    # Bottom-right quadrant -> bottom-right key color\n                    output_grid[r, c] = k11  \n            # Else (pixel is bg, border, key, or non-target): keep original color \n            # (already in output_grid copy)\n\n    # 5. Return Result\n    # Convert the final numpy array back to a list of lists for return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7165,
    "candidates_token_count": 2067,
    "total_token_count": 9232,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.096568,
  "retries": null
}