{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef find_key(grid, border_color, background_color):\n    \"\"\"\n    Finds the 2x2 key block in the grid.\n    The key is the first 2x2 block encountered (scanning row-by-row, then col-by-col)\n    where all four cells are neither the border_color nor the background_color.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color assumed to be the border.\n        background_color (int): The color assumed to be the background.\n\n    Returns:\n        tuple: (key_r, key_c, k00, k01, k10, k11) or None if not found.\n               key_r, key_c: top-left coordinates of the key.\n               k00, k01, k10, k11: the four colors of the key.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            k00 = grid[r, c]\n            k01 = grid[r, c+1]\n            k10 = grid[r+1, c]\n            k11 = grid[r+1, c+1]\n            \n            colors = [k00, k01, k10, k11]\n            \n            is_key = True\n            for color in colors:\n                if color == border_color or color == background_color:\n                    is_key = False\n                    break\n            \n            if is_key:\n                return r, c, k00, k01, k10, k11\n    return None\n\ndef find_target_color(grid, border_color, background_color, key_coords):\n    \"\"\"\n    Finds the color that needs to be transformed.\n    It's the most frequent color in the grid, excluding border, background,\n    and key colors.\n\n    Args:\n        grid (np.array): The input grid.\n        border_color (int): The color assumed to be the border.\n        background_color (int): The color assumed to be the background.\n        key_coords (tuple): (key_r, key_c) top-left coordinates of the key.\n\n    Returns:\n        int or None: The target color, or None if no candidate pixels found.\n    \"\"\"\n    height, width = grid.shape\n    candidate_pixels = []\n    key_r, key_c = key_coords\n    key_positions = {\n        (key_r, key_c), (key_r, key_c + 1),\n        (key_r + 1, key_c), (key_r + 1, key_c + 1)\n    }\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != border_color and \\\n               color != background_color and \\\n               (r, c) not in key_positions:\n                candidate_pixels.append(color)\n\n    if not candidate_pixels:\n        return None\n\n    count = Counter(candidate_pixels)\n    target_color = count.most_common(1)[0][0]\n    return target_color\n\ndef find_bounding_box(grid, target_color):\n    \"\"\"\n    Finds the minimum bounding box containing all pixels of target_color.\n\n    Args:\n        grid (np.array): The input grid.\n        target_color (int): The color to find the bounding box for.\n\n    Returns:\n        tuple or None: (min_r, max_r, min_c, max_c) or None if target_color not found.\n    \"\"\"\n    height, width = grid.shape\n    rows, cols = np.where(grid == target_color)\n\n    if rows.size == 0:\n        return None\n\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    \n    return min_r, max_r, min_c, max_c\n\n\n\"\"\"\nThe transformation rule identifies a 2x2 key block of colors, typically located near a corner, distinct from the background (usually white 0) and a potential border (usually azure 8). It also identifies a single 'target' color present elsewhere in the grid (excluding background, border, and key). The rule then divides the bounding box of all target color pixels into four quadrants based on its center. Each target color pixel is then replaced by one of the four key colors, depending on which quadrant the pixel falls into: top-left quadrant maps to the top-left key color, top-right quadrant to top-right key color, bottom-left quadrant to bottom-left key color, and bottom-right quadrant to bottom-right key color. Other pixels (background, border, key) remain unchanged.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the quadrant-based color transformation based on a 2x2 key.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    \n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Define assumed border and background colors\n    border_color = 8\n    background_color = 0\n    \n    # 1. Find the 2x2 key\n    key_info = find_key(grid, border_color, background_color)\n    if key_info is None:\n        # If no key is found, assume no transformation is needed\n        return output_grid.tolist() \n        \n    key_r, key_c, k00, k01, k10, k11 = key_info\n    key_coords = (key_r, key_c)\n\n    # 2. Find the target color (most frequent color excluding border, bg, key)\n    target_color = find_target_color(grid, border_color, background_color, key_coords)\n    if target_color is None:\n        # If no target color found, return original grid\n        return output_grid.tolist()\n\n    # 3. Find the bounding box of the target color pixels\n    bbox = find_bounding_box(grid, target_color)\n    if bbox is None:\n         # Should not happen if target_color was found, but safety check\n        return output_grid.tolist()\n\n    min_r, max_r, min_c, max_c = bbox\n\n    # 4. Calculate the center of the bounding box\n    # Use floating point for potentially non-integer center\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n\n    # 5. Iterate through the grid and apply transformation to target pixels\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color:\n                # Determine quadrant and assign new color\n                if r < center_r and c < center_c:\n                    output_grid[r, c] = k00  # Top-left quadrant\n                elif r < center_r and c >= center_c:\n                    output_grid[r, c] = k01  # Top-right quadrant\n                elif r >= center_r and c < center_c:\n                    output_grid[r, c] = k10  # Bottom-left quadrant\n                elif r >= center_r and c >= center_c:\n                    output_grid[r, c] = k11  # Bottom-right quadrant\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2058,
    "candidates_token_count": 1837,
    "total_token_count": 3895,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.67525,
  "retries": null
}