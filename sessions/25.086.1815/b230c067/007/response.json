{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nRecolor azure (8) objects based on geometric properties: solidity and size/area difference.\n\n1.  Create a copy of the input grid to serve as the output grid.\n2.  Identify all distinct contiguous objects composed of azure (8) pixels using 4-way adjacency.\n3.  For each identified azure object:\n    a.  Calculate its size (number of pixels).\n    b.  Determine its bounding box (the smallest rectangle enclosing the object).\n    c.  Calculate the area of the bounding box (height * width).\n    d.  Compare the object's size to its bounding box area.\n    e.  **Rule 1:** If the object's size is equal to its bounding box area (it's a \"solid block\"), recolor all pixels of the object to Red (2) in the output grid.\n    f.  **Rule 2:** If the object's size is *not* equal to its bounding box area:\n        i.  Calculate the difference: `diff = bounding_box_area - size`.\n        ii. Check if the object's size is Even or Odd.\n        iii. If the `diff` is exactly 1 AND the object's size is Even, recolor all pixels of the object to Red (2) in the output grid.\n        iv. Otherwise (if `diff` is not 1, OR if the object's size is Odd), recolor all pixels of the object to Blue (1) in the output grid.\n4.  Pixels not part of any azure object remain unchanged.\n5.  Return the modified output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If pixel is the target color and not yet visited, start a search\n            if grid[r, c] == color and (r, c) not in visited:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                # Breadth-First Search (BFS) for connected pixels\n                while q:\n                    row, col = q.popleft()\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is the same color and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Add the found object's coordinates to the list if it's not empty\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object pixels.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n        \n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    \n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    # initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Define colors\n    azure_color = 8\n    blue_color = 1\n    red_color = 2\n    \n    # Find all azure (8) objects using 4-way adjacency\n    azure_objects = find_objects(input_grid, azure_color)\n    \n    # Process each identified azure object\n    for obj_coords in azure_objects:\n        # Calculate the size (pixel count)\n        object_size = len(obj_coords)\n        if object_size == 0: # Should not happen with find_objects implementation, but safe check\n             continue\n\n        # Determine the bounding box\n        bbox = get_bounding_box(obj_coords)\n        min_row, min_col, max_row, max_col = bbox\n        \n        # Calculate bounding box dimensions and area\n        bbox_height = max_row - min_row + 1\n        bbox_width = max_col - min_col + 1\n        bbox_area = bbox_height * bbox_width\n        \n        # Determine the output color based on the rules\n        output_color = blue_color # Default to Blue (covers most non-solid cases)\n        \n        # Rule 1: Check if it's a Solid Block\n        if object_size == bbox_area:\n            output_color = red_color\n        else:\n            # Rule 2: Not a Solid Block - check special case\n            diff = bbox_area - object_size\n            is_even = (object_size % 2 == 0)\n            \n            # Check if diff is 1 AND size is even\n            if diff == 1 and is_even:\n                output_color = red_color\n            # Otherwise, it remains Blue (the default)\n\n        # Recolor the pixels of the current object in the output grid\n        for r, c in obj_coords:\n            output_grid[r, c] = output_color\n            \n    # Return the final transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13412,
    "candidates_token_count": 1481,
    "total_token_count": 14893,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.322663,
  "retries": null
}