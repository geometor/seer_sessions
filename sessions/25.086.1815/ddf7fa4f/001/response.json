{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all contiguous blocks of gray pixels (color 5). \nIdentify all non-white source pixels in the first row (row 0).\nFor each gray block, find the source pixel in the first row that is horizontally closest to it. \nThe horizontal distance is the minimum absolute difference in column indices between any pixel in the block and the source pixel.\nReplace the color of all pixels in the gray block with the color of its closest source pixel. \nAll other pixels remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of sets, where each set contains the (row, col) coordinates \n              of the pixels belonging to one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj:\n                    objects.append(obj)\n    return objects\n\ndef get_block_columns(block):\n    \"\"\"\n    Finds the minimum and maximum column indices covered by a block.\n\n    Args:\n        block (set): A set of (row, col) coordinates representing the block.\n\n    Returns:\n        tuple: (min_col, max_col)\n    \"\"\"\n    if not block:\n        return None, None\n    cols = [c for r, c in block]\n    return min(cols), max(cols)\n\ndef calculate_horizontal_distance(block_min_col, block_max_col, source_col):\n    \"\"\"\n    Calculates the minimum horizontal distance between a block's column range \n    and a source pixel's column.\n\n    Args:\n        block_min_col (int): The minimum column index of the block.\n        block_max_col (int): The maximum column index of the block.\n        source_col (int): The column index of the source pixel.\n\n    Returns:\n        int: The minimum horizontal distance.\n    \"\"\"\n    if block_min_col <= source_col <= block_max_col:\n        return 0\n    elif source_col < block_min_col:\n        return block_min_col - source_col\n    else: # source_col > block_max_col\n        return source_col - block_max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by recoloring gray blocks based on the horizontally \n    closest source color in the top row.\n    \n    Args:\n        input_grid (list or np.array): The input grid.\n        \n    Returns:\n        np.array: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Identify source pixels in the first row\n    source_pixels = []\n    if rows > 0:\n        for c in range(cols):\n            color = grid[0, c]\n            if color != 0: # Assuming 0 is white/background\n                source_pixels.append({'color': color, 'col': c})\n\n    # If no source pixels, return the original grid (or handle as needed)\n    if not source_pixels:\n        return output_grid\n\n    # 2. Identify all gray (color 5) blocks\n    gray_blocks = find_objects(grid, 5)\n\n    # 3. For each gray block, find the closest source and recolor\n    for block in gray_blocks:\n        if not block:\n            continue\n\n        # 3a. Determine the column range of the block\n        min_col, max_col = get_block_columns(block)\n        \n        min_dist = float('inf')\n        closest_color = -1 # Default or error color if needed\n\n        # 3b-c. Find the closest source pixel\n        for source in source_pixels:\n            dist = calculate_horizontal_distance(min_col, max_col, source['col'])\n            \n            # Update if this source is closer\n            if dist < min_dist:\n                min_dist = dist\n                closest_color = source['color']\n            # Tie-breaking: If distances are equal, the original description doesn't specify.\n            # Common ARC tie-breakers are first-encountered (leftmost source).\n            # Let's stick with the first one found at the minimum distance.\n            # If a different tie-breaker is needed, logic would go here.\n\n        # 3d-5. Recolor the block in the output grid\n        if closest_color != -1: # Check if a closest color was found\n            for r, c in block:\n                output_grid[r, c] = closest_color\n\n    # 6. Return the modified output grid\n    return output_grid.tolist() # Return as list of lists if required by context\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3131,
    "candidates_token_count": 1380,
    "total_token_count": 4511,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.660108,
  "retries": null
}