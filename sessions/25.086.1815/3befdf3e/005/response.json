{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the input grid based on the following steps:\n1.  Find the single non-white object and its bounding box.\n2.  Identify the object's frame color (C1) and content color (C2).\n3.  Determine the expansion amount (E) based on the object's dimensions (1 if 3x3, 2 otherwise).\n4.  Create an output grid initialized with the background color (white, 0).\n5.  Fill the area within the original bounding box in the output grid by swapping C1 and C2 from the input grid.\n6.  Fill the expanded border area in the output grid with C1, but only along the horizontal and vertical extensions of the original object (excluding corners).\n\"\"\"\n\ndef find_bbox(grid: np.ndarray, ignore_color: int = 0) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of all pixels in the grid that do not match the ignore_color.\n\n    Args:\n        grid: A numpy array representing the grid.\n        ignore_color: The color value to ignore (typically the background color).\n\n    Returns:\n        A tuple (min_r, min_c, max_r, max_c) representing the bounding box,\n        or None if no non-ignored pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c = rows, cols\n    max_r, max_c = -1, -1\n    found = False\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color:\n                found = True\n                min_r = min(min_r, r)\n                min_c = min(min_c, c)\n                max_r = max(max_r, r)\n                max_c = max(max_c, c)\n    if not found:\n        return None\n    return min_r, min_c, max_r, max_c\n\ndef get_frame_content_colors(grid: np.ndarray, bbox: Tuple[int, int, int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Determines the frame (C1) and content (C2) colors of an object within a bounding box.\n    Assumes the frame color is the most frequent color on the boundary and\n    the content color is a different color found inside.\n\n    Args:\n        grid: A numpy array representing the grid.\n        bbox: The bounding box (min_r, min_c, max_r, max_c) of the object.\n\n    Returns:\n        A tuple (frame_color, content_color). Defaults content_color to frame_color\n        if no distinct content color is found.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    \n    # Simple assumption: frame color is at the top-left corner of the bbox\n    frame_color = grid[min_r, min_c]\n    content_color = frame_color # Default if no other color found\n\n    # Search within the bounding box for a color different from the frame_color\n    found_content = False\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r, c] != frame_color and grid[r,c] != 0: # Ensure it's not background\n                content_color = grid[r, c]\n                found_content = True\n                break\n        if found_content:\n            break\n            \n    # Refined check specifically for neighbors if initial search failed (e.g., solid color obj)\n    # This part might be redundant given the broad search above, but kept for potential robustness\n    if not found_content:\n         potential_content_coords = []\n         if min_r + 1 <= max_r: potential_content_coords.append((min_r + 1, min_c))\n         if min_c + 1 <= max_c: potential_content_coords.append((min_r, min_c + 1))\n         if min_r + 1 <= max_r and min_c + 1 <= max_c: potential_content_coords.append((min_r + 1, min_c + 1))\n         \n         for r_in, c_in in potential_content_coords:\n              if 0 <= r_in < grid.shape[0] and 0 <= c_in < grid.shape[1]:\n                   neighbor_color = grid[r_in, c_in]\n                   if neighbor_color != frame_color and neighbor_color != 0:\n                        content_color = neighbor_color\n                        found_content = True\n                        break\n\n    return frame_color, content_color\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the bounding box of the non-white object\n    bbox = find_bbox(input_np, ignore_color=0)\n    \n    # If no object found, return the empty grid\n    if bbox is None:\n        return output_np.tolist()\n\n    min_r, min_c, max_r, max_c = bbox\n    in_h = max_r - min_r + 1\n    in_w = max_c - min_c + 1\n    \n    # 2. Identify frame and content colors\n    frame_color, content_color = get_frame_content_colors(input_np, bbox)\n\n    # 3. Determine expansion amount based on input size\n    expansion = 1 if (in_h == 3 and in_w == 3) else 2\n\n    # 4. Calculate output object bounding box coordinates\n    out_min_r = min_r - expansion\n    out_min_c = min_c - expansion\n    out_max_r = max_r + expansion\n    out_max_c = max_c + expansion\n\n    # Iterate through each pixel of the grid to determine its output color\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current coordinate (r, c) is within the output bounding box\n            is_in_output_bbox = (out_min_r <= r <= out_max_r and out_min_c <= c <= out_max_c)\n\n            if is_in_output_bbox:\n                # Check if the coordinate is within the original input bounding box\n                is_in_input_bbox = (min_r <= r <= max_r and min_c <= c <= max_c)\n\n                if is_in_input_bbox:\n                    # 5. Fill Swapped Interior: Process pixels within the original footprint\n                    original_color = input_np[r, c]\n                    if original_color == frame_color:\n                        output_np[r, c] = content_color\n                    elif original_color == content_color:\n                        output_np[r, c] = frame_color\n                    # else: leave as background (already 0) - handles background pixels within bbox\n                \n                else:\n                    # 6. Fill Expanded Border (excluding corners)\n                    # Check if it lies on the horizontal extension (same row range as input bbox)\n                    is_horizontal_extension = (min_r <= r <= max_r) and \\\n                                              (out_min_c <= c < min_c or max_c < c <= out_max_c)\n                    # Check if it lies on the vertical extension (same column range as input bbox)\n                    is_vertical_extension = (min_c <= c <= max_c) and \\\n                                            (out_min_r <= r < min_r or max_r < r <= out_max_r)\n\n                    if is_horizontal_extension or is_vertical_extension:\n                        output_np[r, c] = frame_color\n                    # else: it's a corner of the expanded box, leave as background (already 0)\n            \n            # else: Pixel is outside the output object's expanded bbox, remains background (already 0)\n\n    # Convert back to list of lists for the ARC standard output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13557,
    "candidates_token_count": 2006,
    "total_token_count": 15563,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.339438,
  "retries": null
}