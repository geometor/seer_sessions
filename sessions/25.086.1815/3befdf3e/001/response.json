{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nExpands a two-color framed object found in the input grid by one pixel in all directions, \nswaps the inner content color and the frame color within the original object's footprint, \nand uses the original frame color for the new expanded border.\n\n1.  Identify the single contiguous non-white object in the input grid.\n2.  Determine the bounding box of this object.\n3.  Identify the color of the object's outer frame (frame_color) and the color of its inner content (content_color).\n4.  Calculate the bounding box for the output object by expanding the input object's bounding box by 1 pixel outwards.\n5.  Create an output grid initialized with the background color (white, 0).\n6.  Iterate through each cell (r, c) within the calculated output bounding box:\n    a.  If (r, c) lies on the outermost border of the output bounding box, set the output cell color to the original frame_color.\n    b.  If (r, c) lies inside the outermost border:\n        i.   Look up the color of the cell at the same coordinate (r, c) in the *input* grid (this corresponds to a pixel within the original object). Let this be original_color.\n        ii.  If original_color matches the input frame_color, set the output cell color to the input content_color.\n        iii. If original_color matches the input content_color, set the output cell color to the input frame_color.\n        iv.  (Edge case) If original_color matches neither (e.g., background pixel somehow inside), leave it as background.\n7. Return the constructed output grid.\n\"\"\"\n\ndef find_bbox(grid: np.ndarray, ignore_color: int = 0) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of all pixels in the grid that do not match the ignore_color.\n\n    Args:\n        grid: A numpy array representing the grid.\n        ignore_color: The color value to ignore (typically the background color).\n\n    Returns:\n        A tuple (min_r, min_c, max_r, max_c) representing the bounding box,\n        or None if no non-ignored pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c = rows, cols\n    max_r, max_c = -1, -1\n    found = False\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color:\n                found = True\n                min_r = min(min_r, r)\n                min_c = min(min_c, c)\n                max_r = max(max_r, r)\n                max_c = max(max_c, c)\n    if not found:\n        return None\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the expansion and color-swapping rule.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the bounding box of the non-white object\n    bbox = find_bbox(input_np, ignore_color=0)\n    \n    # If no object found, return the empty grid\n    if bbox is None:\n        return output_np.tolist()\n\n    min_r, min_c, max_r, max_c = bbox\n    \n    # Handle edge case: object is smaller than 2x2 (cannot have distinct frame/content)\n    # In such cases, the rule is ambiguous. Based on examples, assume >= 3x3 structure.\n    # If the object is 1 pixel wide/high, treat frame/content as the same?\n    # The examples show clear frame/content, so we proceed assuming that structure.\n    if max_r - min_r < 1 or max_c - min_c < 1:\n         # If it's a line or dot, just expand it? Let's stick to the frame/content swap logic.\n         # It might behave strangely but follows the derived rule best.\n         # If it's 1xN or Nx1, the first pixel is frame, others are content? Unclear.\n         # Let's get frame from corner and content from adjacent if possible.\n        frame_color = input_np[min_r, min_c]\n        if max_r > min_r : # vertical line or block\n             content_color = input_np[min_r + 1, min_c]\n        elif max_c > min_c: # horizontal line or block\n             content_color = input_np[min_r, min_c + 1]\n        else: # single pixel\n             content_color = frame_color\n    else:\n        # 2. Identify frame and content colors (assuming frame is 1px thick)\n        frame_color = input_np[min_r, min_c]\n        content_color = input_np[min_r + 1, min_c + 1] # Color inside the frame\n\n    # 3. Calculate output object bounding box (expanded by 1 pixel)\n    # Note: No boundary checks needed based on ARC examples/constraints (output fits)\n    out_min_r = min_r - 1\n    out_min_c = min_c - 1\n    out_max_r = max_r + 1\n    out_max_c = max_c + 1\n\n    # 4. Construct the output object within the output grid\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current pixel (r, c) falls within the output object's bounding box\n            if out_min_r <= r <= out_max_r and out_min_c <= c <= out_max_c:\n                \n                # Check if it's on the new outer frame (the border of the output bbox)\n                is_outer_frame = (r == out_min_r or r == out_max_r or \n                                  c == out_min_c or c == out_max_c)\n                \n                if is_outer_frame:\n                    # Set color to the original frame color for the new border\n                    output_np[r, c] = frame_color\n                else:\n                    # Pixel is inside the new outer frame. \n                    # Its color depends on the color at the *same coordinate* in the *input* grid.\n                    original_color = input_np[r, c]\n                    \n                    # Swap colors based on the original color at this position\n                    if original_color == frame_color:\n                        output_np[r, c] = content_color\n                    elif original_color == content_color:\n                        output_np[r, c] = frame_color\n                    else:\n                        # If the original color was neither (e.g., background), keep background.\n                        # This handles cases where the input object might not be perfectly rectangularly filled.\n                        output_np[r, c] = 0 \n            # else: Pixel is outside the output object, remains background (already initialized)\n\n    # Convert back to list of lists for the ARC standard output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3508,
    "candidates_token_count": 1770,
    "total_token_count": 5278,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 46.070575,
  "retries": null
}