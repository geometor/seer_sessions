{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the input grid by finding a single two-color framed object, expanding its bounding box by 2 pixels in all directions, filling the expanded area with the original frame color, and swapping the frame and content colors within the area corresponding to the original object's footprint.\n\n1.  Identify the single contiguous non-white object and its bounding box (`min_r`, `min_c`, `max_r`, `max_c`) in the input grid.\n2.  Determine the object's outer frame color (C1) and inner content color (C2). Handle cases where the object is small or colors are indistinct.\n3.  Calculate the bounding box for the output object by expanding the input bounding box by 2 pixels outwards (`out_min_r`, `out_min_c`, `out_max_r`, `out_max_c`).\n4.  Create an output grid of the same dimensions as the input grid, initialized with the background color (white, 0).\n5.  Iterate through each coordinate (`r`, `c`) within the calculated *output* bounding box range.\n6.  For each coordinate, check if it falls within the original *input* bounding box.\n7.  If (`r`, `c`) is outside the input bounding box (but within the output bounding box), set the corresponding pixel in the output grid to the original frame color (C1).\n8.  If (`r`, `c`) is inside the input bounding box:\n    a.  Retrieve the color `original_color` from the input grid at (`r`, `c`).\n    b.  If `original_color` is the frame color (C1), set the output pixel to the content color (C2).\n    c.  If `original_color` is the content color (C2), set the output pixel to the frame color (C1).\n    d.  Otherwise (e.g., background pixel within the object's bbox), leave the output pixel as background.\n9.  Return the resulting output grid.\n\"\"\"\n\ndef find_bbox(grid: np.ndarray, ignore_color: int = 0) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of all pixels in the grid that do not match the ignore_color.\n\n    Args:\n        grid: A numpy array representing the grid.\n        ignore_color: The color value to ignore (typically the background color).\n\n    Returns:\n        A tuple (min_r, min_c, max_r, max_c) representing the bounding box,\n        or None if no non-ignored pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    min_r, min_c = rows, cols\n    max_r, max_c = -1, -1\n    found = False\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color:\n                found = True\n                min_r = min(min_r, r)\n                min_c = min(min_c, c)\n                max_r = max(max_r, r)\n                max_c = max(max_c, c)\n    if not found:\n        return None\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the expansion and color-swapping rule.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output grid with background color (0) - same size as input\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the bounding box of the non-white object\n    bbox = find_bbox(input_np, ignore_color=0)\n    \n    # If no object found, return the empty grid\n    if bbox is None:\n        return output_np.tolist()\n\n    min_r, min_c, max_r, max_c = bbox\n    in_h = max_r - min_r + 1\n    in_w = max_c - min_c + 1\n    \n    # 2. Identify frame and content colors\n    # Assume frame is the color at the top-left corner of the bbox\n    frame_color = input_np[min_r, min_c]\n    content_color = frame_color # Default: if no distinct content color found\n\n    # Try to find a different content color inside the frame\n    # Look at neighbors of the top-left pixel within the bbox\n    potential_content_coords = []\n    if min_r + 1 <= max_r: potential_content_coords.append((min_r + 1, min_c))\n    if min_c + 1 <= max_c: potential_content_coords.append((min_r, min_c + 1))\n    if min_r + 1 <= max_r and min_c + 1 <= max_c: potential_content_coords.append((min_r + 1, min_c + 1))\n    \n    found_content = False\n    for r_in, c_in in potential_content_coords:\n         neighbor_color = input_np[r_in, c_in]\n         if neighbor_color != frame_color:\n              content_color = neighbor_color\n              found_content = True\n              break\n    # If after checking neighbors, content_color is still frame_color,\n    # check further inside just in case of thick frames (e.g. 3x3 center in 5x5)\n    if not found_content and in_h > 2 and in_w > 2:\n        center_color = input_np[min_r + 1, min_c + 1]\n        if center_color != frame_color:\n             content_color = center_color\n\n\n    # 3. Calculate output object bounding box (expanded by 2 pixels)\n    out_min_r = min_r - 2\n    out_min_c = min_c - 2\n    out_max_r = max_r + 2\n    out_max_c = max_c + 2\n\n    # 4. & 5. Construct the output object within the output grid\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current pixel (r, c) falls within the output object's bounding box\n            is_in_output_bbox = (out_min_r <= r <= out_max_r and out_min_c <= c <= out_max_c)\n            \n            if is_in_output_bbox:\n                # 6. Check if inside original input footprint\n                is_in_input_bbox = (min_r <= r <= max_r and min_c <= c <= max_c)\n\n                if is_in_input_bbox:\n                    # 8. Fill Swapped Interior: Only process if coords are valid for input_np\n                    if 0 <= r < rows and 0 <= c < cols:\n                        original_color = input_np[r, c]\n                        # Swap colors based on the original color at this position\n                        if original_color == frame_color:\n                            output_np[r, c] = content_color\n                        elif original_color == content_color:\n                            output_np[r, c] = frame_color\n                        else:\n                            # If the original color was neither (e.g., background), keep background.\n                            # This handles cases where the input object might not be perfectly rectangularly filled.\n                            output_np[r, c] = 0 \n                else:\n                    # 7. Fill Expanded Border (outside input bbox, inside output bbox)\n                    output_np[r, c] = frame_color\n            # else: Pixel is outside the output object, remains background (already initialized)\n\n    # 9. Convert back to list of lists for the ARC standard output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19776,
    "candidates_token_count": 1887,
    "total_token_count": 21663,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.450393,
  "retries": null
}