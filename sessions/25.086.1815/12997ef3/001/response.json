{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the contiguous object composed of blue pixels (color 1) in the input grid. Determine its shape pattern relative to its top-left corner within its minimal bounding box (assumed to be at most 3x3 based on examples). This is the template_shape.\nIdentify all single pixels in the input grid that are not blue (color 1) and not white (color 0). Store these color_source_pixels, noting their color and original position (row, column). A single pixel has no adjacent (orthogonal or diagonal) neighbors of the same color.\nSort the color_source_pixels based on their position: primarily by row index, then by column index.\nFor each color_source_pixel in the sorted list:\n    Create a 3x3 grid initialized with white pixels (color 0).\n    Apply the template_shape to this 3x3 grid, coloring the corresponding pixels with the color of the current color_source_pixel. This creates an individual_output_shape.\nCollect all generated individual_output_shapes.\nDetermine the arrangement of the color_source_pixels:\n    If all color_source_pixels share the same column index in the input grid, arrange the individual_output_shapes vertically, stacked top-to-bottom in their generated order.\n    If all color_source_pixels share the same row index in the input grid, arrange the individual_output_shapes horizontally, placed left-to-right in their generated order, separated by a single column of white pixels.\nConstruct the final output grid based on the determined arrangement.\n\"\"\"\n\ndef find_connected_component(grid, start_r, start_c, target_color):\n    \"\"\"Finds all connected pixels of target_color starting from (start_r, start_c) using BFS.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    component = set([(start_r, start_c)])\n\n    while q:\n        r, c = q.popleft()\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and \\\n                   grid[nr, nc] == target_color and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    component.add((nr, nc))\n    return component\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef is_single_pixel(grid, r, c):\n    \"\"\"Checks if a pixel at (r, c) is isolated from pixels of the same color.\"\"\"\n    rows, cols = grid.shape\n    color = grid[r, c]\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color:\n                return False\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Replicates a template shape (derived from the blue object) using colors\n    derived from specific input pixels (color sources), arranging the results\n    vertically or horizontally based on the source pixel alignment.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the blue template shape\n    blue_pixels = set()\n    template_shape_relative = set()\n    min_r_blue, min_c_blue = -1, -1\n\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 1:\n                # Find the first blue pixel and get the whole component\n                blue_pixels = find_connected_component(input_np, r, c, 1)\n                break\n        if blue_pixels:\n            break\n\n    if not blue_pixels:\n        # Handle case where no blue object is found (return empty grid or error?)\n        # Based on examples, let's assume it always exists. For safety, return empty.\n        return np.array([[]], dtype=int)\n\n    bbox_blue = get_bounding_box(blue_pixels)\n    min_r_blue, min_c_blue, _, _ = bbox_blue\n\n    # Calculate relative coordinates for the template shape\n    for r, c in blue_pixels:\n        template_shape_relative.add((r - min_r_blue, c - min_c_blue))\n\n    # 2. Identify color source pixels (single, non-blue, non-white)\n    color_sources = []\n    for r in range(rows):\n        for c in range(cols):\n            color = input_np[r, c]\n            if color not in [0, 1]:\n                 # Check if it's a single pixel (no neighbors of same color)\n                 is_isolated = True\n                 for dr in range(-1, 2):\n                     for dc in range(-1, 2):\n                         if dr == 0 and dc == 0: continue\n                         nr, nc = r + dr, c + dc\n                         if 0 <= nr < rows and 0 <= nc < cols and input_np[nr, nc] == color:\n                             is_isolated = False\n                             break\n                     if not is_isolated: break\n                 \n                 if is_isolated:\n                     color_sources.append({'color': color, 'r': r, 'c': c})\n\n\n    if not color_sources:\n        # Handle case where no color sources are found\n        return np.array([[]], dtype=int)\n\n    # 3. Sort color sources by row, then column\n    color_sources.sort(key=lambda x: (x['r'], x['c']))\n\n    # 4. Generate individual 3x3 output shapes\n    individual_shapes = []\n    for source in color_sources:\n        shape_grid = np.zeros((3, 3), dtype=int) # Initialize 3x3 with white\n        for r_rel, c_rel in template_shape_relative:\n            # Ensure template fits within 3x3 (based on examples)\n            if 0 <= r_rel < 3 and 0 <= c_rel < 3:\n                 shape_grid[r_rel, c_rel] = source['color']\n        individual_shapes.append(shape_grid)\n\n    # 5. Determine arrangement and combine\n    output_grid = None\n    if len(individual_shapes) > 0:\n        # Check if all sources share the same column\n        if len(set(s['c'] for s in color_sources)) == 1:\n            # Vertical stacking\n            output_grid = np.vstack(individual_shapes)\n        # Check if all sources share the same row\n        elif len(set(s['r'] for s in color_sources)) == 1:\n            # Horizontal stacking with separators\n            combined_elements = []\n            separator = np.zeros((3, 1), dtype=int) # White column separator\n            for i, shape in enumerate(individual_shapes):\n                combined_elements.append(shape)\n                if i < len(individual_shapes) - 1:\n                    combined_elements.append(separator)\n            output_grid = np.hstack(combined_elements)\n        else:\n            # Undefined behavior for scattered sources based on examples\n            # Defaulting to vertical stacking or return error? Let's default to vertical for now.\n             output_grid = np.vstack(individual_shapes) # Or return error/empty\n\n    # Handle case where output_grid might still be None\n    if output_grid is None:\n         return np.array([[]], dtype=int) # Return empty grid if no shapes or undefined arrangement\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3931,
    "candidates_token_count": 1948,
    "total_token_count": 5879,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 98.029768,
  "retries": null
}