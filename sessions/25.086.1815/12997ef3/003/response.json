{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Identify Template: Locate the single, contiguous object composed of blue (1) pixels in the input grid (using diagonal adjacency). Determine its shape relative to its top-left corner, fitting it within a 3x3 area. This is the `template_pattern`.\n2. Identify Color Sources: Find all pixels in the input grid that are *not* white (0) and *not* blue (1), and which are 'single' pixels (meaning they have no neighbors, including diagonals, of the same color). Record the color and original (row, column) position of each such `color_source_pixel`.\n3. Sort Sources: Sort the list of `color_source_pixel`s based first on their row index (ascending) and then on their column index (ascending).\n4. Generate Shapes: For each `color_source_pixel` in the sorted list:\n    a. Create a new 3x3 grid filled with white (0) pixels.\n    b. Apply the `template_pattern` onto this 3x3 grid, using the color of the current `color_source_pixel`. This results in an `individual_output_shape`.\n    c. Collect these `individual_output_shape`s in the order they were generated.\n5. Arrange Shapes: Determine the arrangement based on the original positions of the sorted `color_source_pixel`s:\n    a. Vertical Alignment: If all `color_source_pixel`s have the same column index, stack the generated `individual_output_shape`s vertically, top-to-bottom, in the order they were generated.\n    b. Horizontal Alignment: If all `color_source_pixel`s have the same row index, place the generated `individual_output_shape`s horizontally adjacent to each other, left-to-right, in the order they were generated, with **no** separator columns between them.\n    c. Other Alignments: Default to vertical stacking if sources are neither strictly vertical nor horizontal.\n6. Construct Output: Combine the `individual_output_shape`s according to the determined arrangement to create the final output grid.\n\"\"\"\n\ndef find_connected_component(grid, start_r, start_c, target_color):\n    \"\"\"Finds all connected pixels of target_color starting from (start_r, start_c) using BFS, considering diagonal adjacency.\"\"\"\n    rows, cols = grid.shape\n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    component = set([(start_r, start_c)])\n\n    while q:\n        r, c = q.popleft()\n        # Check 8 neighbors (orthogonal and diagonal)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and \\\n                   grid[nr, nc] == target_color and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    component.add((nr, nc))\n    return component\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    # Return top-left row, top-left col, bottom-right row, bottom-right col\n    return min(rows), min(cols), max(rows), max(cols)\n\n# is_single_pixel helper is not strictly needed as the logic is embedded in transform,\n# but could be reinstated if desired for modularity.\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by replicating a blue template shape with colors\n    from isolated source pixels, arranging the results based on source alignment.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the blue template shape (template_pattern)\n    blue_pixels = set()\n    template_shape_relative = set()\n    min_r_blue, min_c_blue = -1, -1\n\n    # Find the first blue pixel and get the whole component\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] == 1:\n                blue_pixels = find_connected_component(input_np, r, c, 1)\n                break\n        if blue_pixels:\n            break\n\n    # Handle case where no blue object is found\n    if not blue_pixels:\n        # Returning an empty grid or the input might be options.\n        # Based on ARC structure, likely need *some* output.\n        # Let's return an empty list-of-lists for now.\n        return [[]]\n\n    # Determine the template's top-left corner for relative coordinates\n    bbox_blue = get_bounding_box(blue_pixels)\n    min_r_blue, min_c_blue, _, _ = bbox_blue\n\n    # Calculate relative coordinates for the template shape (template_pattern)\n    for r, c in blue_pixels:\n        template_shape_relative.add((r - min_r_blue, c - min_c_blue))\n\n    # 2. Identify color source pixels (single, non-blue, non-white)\n    color_sources = []\n    for r in range(rows):\n        for c in range(cols):\n            color = input_np[r, c]\n            # Check if color is valid source color (not white 0, not blue 1)\n            if color not in [0, 1]:\n                 # Check if it's a single pixel (no neighbors, incl. diagonal, of same color)\n                 is_isolated = True\n                 for dr in range(-1, 2):\n                     for dc in range(-1, 2):\n                         if dr == 0 and dc == 0: continue\n                         nr, nc = r + dr, c + dc\n                         # Check bounds and color match\n                         if 0 <= nr < rows and 0 <= nc < cols and input_np[nr, nc] == color:\n                             is_isolated = False\n                             break\n                     if not is_isolated: break # Stop checking neighbors for this pixel\n\n                 # If it remained isolated after checking all neighbors\n                 if is_isolated:\n                     color_sources.append({'color': color, 'r': r, 'c': c})\n\n    # Handle case where no color sources are found\n    if not color_sources:\n        return [[]] # Return empty list-of-lists\n\n    # 3. Sort color sources by row, then column\n    color_sources.sort(key=lambda x: (x['r'], x['c']))\n\n    # 4. Generate individual 3x3 output shapes\n    individual_shapes = []\n    for source in color_sources:\n        # Initialize 3x3 grid with white (0)\n        # Assuming template fits within 3x3 based on examples\n        shape_grid = np.zeros((3, 3), dtype=int)\n        for r_rel, c_rel in template_shape_relative:\n            # Apply template pattern using source color, ensure it stays within 3x3\n            if 0 <= r_rel < 3 and 0 <= c_rel < 3:\n                 shape_grid[r_rel, c_rel] = source['color']\n        individual_shapes.append(shape_grid)\n\n    # 5. Determine arrangement and combine\n    output_grid = None\n    if len(individual_shapes) > 0:\n        # Check for Vertical Alignment (all sources share the same column index)\n        if len(set(s['c'] for s in color_sources)) == 1:\n            output_grid = np.vstack(individual_shapes)\n        # Check for Horizontal Alignment (all sources share the same row index)\n        elif len(set(s['r'] for s in color_sources)) == 1:\n            # Stack horizontally with NO separators\n            output_grid = np.hstack(individual_shapes)\n        else:\n            # Default behavior for scattered sources (e.g., stack vertically)\n            output_grid = np.vstack(individual_shapes)\n\n    # Handle case where output_grid might still be None (e.g., if individual_shapes was empty)\n    # This is covered by the earlier checks for blue_pixels and color_sources,\n    # but added for robustness.\n    if output_grid is None:\n         return [[]] # Return empty list-of-lists\n\n    # 6. Construct Output (Convert final numpy array to list of lists)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8518,
    "candidates_token_count": 2040,
    "total_token_count": 10558,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.167571,
  "retries": null
}