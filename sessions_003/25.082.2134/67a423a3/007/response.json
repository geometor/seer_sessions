{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Find Vertical Line:** Scan the input grid to locate a vertical line. A vertical line is a column where all cells have the same non-zero color. Note the column index and color of this line. If no such line exists, the grid remains unchanged.\n\n2.  **Find Intersecting Horizontal Line:** Find a horizontal line that intersects the vertical line. This horizontal line:\n    *   Must intersect the vertical line (share the same row index).\n    *   Must have at least one segment of contiguous cells with the same color, different from the vertical line's color and not 0. This segment must include the intersecting cell.\n    *   Record the row index.\n\n3.  **Determine Frame Placement:**\n    *   The yellow frame (color 4) is always three cells wide and centered vertically on the intersection of the vertical and horizontal line. It is placed above, on, and below the row of the intersection point.\n    *   **Left Side:** If the horizontal line extends to the left of the intersection (cells to the left of the vertical line have same color), place a yellow pixel to the *left* of the vertical line.\n    *   **Right Side:** If the horizontal line extends to the right of the intersection (cells to the right of the vertical line have same color), place a yellow pixel to the *right* of the vertical line.\n\n4. **Create/Modify Grid:** If a vertical and a suitable horizontal line are detected, create yellow frame based on direction of horizontal line extension, otherwise, return the original input grid.\n\n5.  **Preserve Other Pixels:** All cells that are not part of the created yellow frame and vertical line must retain their original colors. The vertical line itself is preserved.\n\"\"\"\n\nimport numpy as np\n\ndef find_vertical_line(grid):\n    \"\"\"Finds a vertical line in the grid.\"\"\"\n    rows, cols = grid.shape\n    for j in range(cols):\n        first_color = grid[0, j]\n        if first_color == 0:\n            continue\n        if all(grid[i, j] == first_color for i in range(rows)):\n            return j, first_color\n    return None, None\n\ndef find_horizontal_line(grid, vertical_line_col, vertical_line_color):\n    \"\"\"Finds a horizontal line intersecting the vertical line.\"\"\"\n    rows, cols = grid.shape\n    for i in range(rows):\n        if grid[i, vertical_line_col] == vertical_line_color:\n            # Check for a contiguous segment of the same color, excluding 0 and vertical_line_color\n            for j in range(cols):\n                if grid[i, j] != 0 and grid[i, j] != vertical_line_color:\n                    # Check left\n                    left_color = None\n                    left_valid = True\n                    if j < vertical_line_col:\n                        for k in range(j,vertical_line_col):\n                            if left_color is None:\n                                left_color = grid[i,k]\n                            elif grid[i,k] != left_color or grid[i,k] == 0:\n                                left_valid = False\n                                break\n\n                    #check right\n                    right_color = None\n                    right_valid = True\n                    if j > vertical_line_col:\n                        for k in range(vertical_line_col + 1, j + 1):\n                            if right_color is None:\n                                right_color = grid[i,k]\n                            elif grid[i, k] != right_color or grid[i,k] == 0:\n                                right_valid = False\n                                break\n                    if j == vertical_line_col and (left_valid or right_valid):\n                        return i, j\n                    elif left_valid and j < vertical_line_col and grid[i,j] == left_color:\n                        return i, j\n                    elif right_valid and j > vertical_line_col and grid[i,j] == right_color:\n                        return i, j\n    return None, None\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the described rule.\"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    output_grid = grid.copy()\n\n    # Find the vertical line\n    vertical_line_col, vertical_line_color = find_vertical_line(grid)\n    if vertical_line_col is None:\n        return output_grid.tolist()\n\n    # Find the horizontal line\n    horizontal_line_row, horizontal_color_col = find_horizontal_line(grid, vertical_line_col, vertical_line_color)\n\n    if horizontal_line_row is None:\n        return output_grid.tolist()\n\n    horizontal_line_color = grid[horizontal_line_row, horizontal_color_col]\n    # Determine frame placement\n    for r in range(horizontal_line_row - 1, horizontal_line_row + 2):\n        if 0 <= r < rows:\n            # Left side\n            if all(grid[horizontal_line_row,k] == horizontal_line_color for k in range(horizontal_color_col, vertical_line_col)):\n                if vertical_line_col > 0:\n                    output_grid[r, vertical_line_col - 1] = 4\n            # Right side\n            if all(grid[horizontal_line_row, k] == horizontal_line_color for k in range(vertical_line_col+1, horizontal_color_col + 1)):\n                if vertical_line_col < cols - 1:\n                    output_grid[r, vertical_line_col + 1] = 4\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6728,
    "candidates_token_count": 1308,
    "total_token_count": 8036,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.404464
}