{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation identifies specific connected components in the input grid, extracts them, and arranges them in the output grid. The color mapping appears to be: 2 -> 4, 8 -> 8, 3 -> 3, 6->6, and 4 -> 4. The identified shapes are \"L\" shaped structures, except in example 2 where they are 2x2 blocks. The extracted shapes are placed in the top-left corner of the output, and subsequent shapes are placed either below or to the right, maintaining a specific arrangement. In example 4, the 8 shape is rotated.\n\"\"\"\n\nimport numpy as np\n\ndef get_connected_component(grid, start_pixel, value):\n    \"\"\"\n    Finds all pixels connected to the start pixel with the specified value using a flood-fill approach.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    component = []\n    stack = [start_pixel]\n\n    while stack:\n        r, c = stack.pop()\n        if 0 <= r < rows and 0 <= c < cols and grid[r, c] == value and not visited[r, c]:\n            visited[r, c] = True\n            component.append((r, c))\n            stack.extend([(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)])\n    return component\n\ndef find_all_connected_components(input_grid):\n    \"\"\"Finds all connected components of non-zero pixels.\"\"\"\n    rows, cols = input_grid.shape\n    visited = np.zeros_like(input_grid, dtype=bool)\n    components = {}\n\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r, c] != 0 and not visited[r, c]:\n                value = input_grid[r, c]\n                component = get_connected_component(input_grid, (r, c), value)\n                for pixel in component:\n                    visited[pixel] = True\n                if value not in components:\n                  components[value] = []\n                components[value].append(component)\n    return components\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box of a set of pixels.\"\"\"\n    min_r = min(p[0] for p in pixels)\n    max_r = max(p[0] for p in pixels)\n    min_c = min(p[1] for p in pixels)\n    max_c = max(p[1] for p in pixels)\n    return (min_r, min_c), (max_r, max_c)\n\ndef translate_shape(shape, offset):\n    \"\"\"Translates a set of pixels by a given offset.\"\"\"\n    return [(r + offset[0], c + offset[1]) for r, c in shape]\n\ndef rotate_shape_90(shape, bbox_size):\n  \"\"\"Rotates the shape 90 degrees clockwise within its bounding box.\"\"\"\n  rotated_shape = []\n  height = bbox_size[0]\n  width = bbox_size[1]\n  for r, c in shape:\n        new_r = c\n        new_c = height - 1 - r\n        rotated_shape.append((new_r, new_c))\n\n  return rotated_shape\ndef transform(input_grid):\n    # Find all connected components.\n    components_by_color = find_all_connected_components(input_grid)\n\n    # Color and shape handling.\n    output_shapes = []\n    output_colors = []  # Store colors for later\n\n    for color, components in components_by_color.items():\n        # Specific color mapping\n        output_color = color\n        if color == 2:\n          output_color = 4\n        elif color == 8:\n          output_color = 8\n        elif color==3:\n          output_color = 3\n        elif color == 6:\n          output_color = 6\n        elif color == 4:\n          output_color = 4\n\n        for component in components:\n          # Determine if rotation.\n          (min_r, min_c), (max_r, max_c) = get_bounding_box(component)\n          bbox_height = max_r - min_r + 1\n          bbox_width = max_c - min_c + 1\n          \n          if (color == 8 and bbox_height == 2 and bbox_width == 1): #Example 4 rotation\n            rotated_component = rotate_shape_90(component, (bbox_height, bbox_width))\n            translated_component = translate_shape(rotated_component, (-min_c, -min_r)) #Rotate around min_c for 90 rotation\n            output_shapes.append(translated_component)\n            output_colors.append(output_color)\n\n          \n          elif (color == 8 and bbox_height == 1 and bbox_width == 2): #Example 4 rotation\n            rotated_component = rotate_shape_90(component, (bbox_height, bbox_width))\n            \n            translated_component = translate_shape(rotated_component, (-min_c, -min_r) ) #Rotate around min_c for 90 rotation\n            output_shapes.append(translated_component)\n            output_colors.append(output_color)\n          elif (color == 8 and bbox_height == 2 and bbox_width == 2 and input_grid.shape[0] > input_grid.shape[1]): # rotated. Example 4\n             rotated_component = rotate_shape_90(component, (bbox_height, bbox_width))\n             translated_component = translate_shape(rotated_component, (-min_c,-min_r))\n             output_shapes.append(translated_component)\n             output_colors.append(output_color)\n\n          else:\n            translated_component = translate_shape(component, (-min_r, -min_c))\n            output_shapes.append(translated_component)\n            output_colors.append(output_color)\n\n    # Determine output grid size and arrange components.\n    max_r, max_c = 0, 0\n    for shape in output_shapes:\n        (min_r, min_c), (max_r_shape, max_c_shape) = get_bounding_box(shape)\n        max_r = max(max_r, max_r_shape + 1)  # +1 for height\n        max_c = max(max_c, max_c_shape + 1) # + 1 for width\n\n    # Initialize output grid\n    if (len(output_shapes) > 1 and len(output_shapes[0]) < len(output_shapes[1])): #example 2\n      output_grid = np.zeros((max_r, max_c*len(output_shapes)), dtype=int)\n\n      current_col_offset = 0\n      for i, shape in enumerate(output_shapes):\n          (min_r, min_c), (max_r_bb, max_c_bb) = get_bounding_box(shape)\n          for r, c in shape:\n                output_grid[r, c + current_col_offset] = output_colors[i]\n          current_col_offset += (max_c_bb+1 - min_c)\n\n    else: # Example 1, 3\n      output_grid = np.zeros((max_r * len(output_shapes) , max_c), dtype=int)\n\n      # Place components in the output grid.\n      current_row_offset = 0\n      for i, shape in enumerate(output_shapes):\n          (min_r, min_c), (max_r_bb, max_c_bb) = get_bounding_box(shape)\n          for r, c in shape:\n              output_grid[r + current_row_offset, c] = output_colors[i]\n          current_row_offset += (max_r_bb - min_r + 1)  # Add height of bounding box\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14870,
    "candidates_token_count": 1897,
    "total_token_count": 16767,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 26.904496
}