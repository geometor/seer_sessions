{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Find the Longest Horizontal Line:** Examine the input grid to identify the longest horizontal line. A horizontal line is defined as a contiguous sequence of pixels of the same color in a single row. If there are multiple lines of the same maximum length, *any* of them is acceptable. Record the row index, color, starting column, and length of this line.\n\n2.  **Identify Pixels for Reflection:** Identify all pixels in the input grid that *do not* belong to the longest horizontal line found in step 1, and are not black (color 0).\n\n3.  **Reflect Pixels:** For each pixel identified in step 2:\n    *   **Vertical Reflection:** Calculate the new row index. The new row will be the same distance from the horizontal line's row as the original pixel, but on the opposite side.  If the pixel is above the line, the reflected pixel will be below. If the pixel is below the line, the reflected pixel is above it.\n    *   **Horizontal Reflection:** Calculate the new column index. The new column will be mirrored across the vertical center of the grid.  This is calculated as `grid_width - 1 - original_column`.\n    *   **Boundary Check:** If the new row or column index falls outside the grid boundaries (less than 0 or greater than or equal to the grid's height or width, respectively), *ignore* that pixel; it is not reflected.\n\n4.  **Create Output Grid:** Create a new grid of the same dimensions as the input grid, initially filled with black (0) pixels.\n\n5.  **Place Horizontal Line:** Copy the longest horizontal line found in step 1 to the output grid, preserving its original row, color, starting column, and length.\n\n6.  **Place Reflected Pixels:** For each reflected pixel (those not ignored due to boundary checks), place it in the output grid at its new row and column, using its original color.\n\"\"\"\n\nimport numpy as np\n\ndef find_longest_horizontal_line(grid):\n    \"\"\"Finds the longest horizontal line of contiguous pixels of the same color.\"\"\"\n    rows, cols = grid.shape\n    longest_line_row = -1\n    longest_line_color = 0\n    longest_line_start_col = -1\n    longest_line_length = 0\n\n    for r in range(rows):\n        current_length = 0\n        current_color = 0\n        current_start_col = -1\n        for c in range(cols):\n            if grid[r, c] != 0:\n                if current_length == 0:\n                    current_start_col = c\n                    current_color = grid[r,c]\n                current_length += 1\n            else:\n                if current_length > longest_line_length:\n                    longest_line_length = current_length\n                    longest_line_row = r\n                    longest_line_color = current_color\n                    longest_line_start_col = current_start_col\n                current_length = 0\n                current_start_col = -1\n\n        # Check at the end of the row\n        if current_length > longest_line_length:\n            longest_line_length = current_length\n            longest_line_row = r\n            longest_line_color = current_color\n            longest_line_start_col = current_start_col\n\n    return longest_line_row, longest_line_color, longest_line_start_col, longest_line_length\n\ndef find_pixels_for_reflection(grid, longest_line_row, longest_line_start_col, longest_line_length):\n    \"\"\"Find all non-black pixels that are NOT part of the longest horizontal line\"\"\"\n    rows, cols = grid.shape\n    pixels_to_reflect = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            is_part_of_line = (\n                r == longest_line_row and\n                c >= longest_line_start_col and\n                c < longest_line_start_col + longest_line_length\n            )\n            if grid[r,c] != 0 and not is_part_of_line:\n                pixels_to_reflect.append( (r, c, grid[r,c]) )  # Store row, col, and color\n    return pixels_to_reflect\n    \n\ndef mirrored_column(c, cols):\n    \"\"\"calculate the mirrored column\"\"\"\n    return cols - 1 - c\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the rules described above.\"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    output_grid = np.zeros((rows, cols), dtype=int)\n\n    # 1. Find the Longest Horizontal Line\n    line_row, line_color, line_start_col, line_length = find_longest_horizontal_line(grid)\n\n    # 2. Find Pixels for Reflection\n    pixels_to_reflect = find_pixels_for_reflection(grid, line_row, line_start_col, line_length)\n\n\n    # 3. Reflect Pixels and 4. Create/Fill Output Grid\n    # 5. Place Horizontal line\n    if line_row != -1:  # Ensure a line was found\n      for i in range(line_length):\n          output_grid[line_row, line_start_col + i] = line_color\n\n    # 6. Place Reflected Pixels\n    for r, c, color in pixels_to_reflect:\n        # Vertical Reflection\n        new_row = line_row - (r - line_row)\n\n        # Horizontal Reflection\n        new_col = mirrored_column(c, cols)\n\n        # Boundary Check\n        if 0 <= new_row < rows and 0 <= new_col < cols:\n            output_grid[new_row, new_col] = color\n\n    return output_grid\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5769,
    "candidates_token_count": 1356,
    "total_token_count": 7125,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 14.138589
}