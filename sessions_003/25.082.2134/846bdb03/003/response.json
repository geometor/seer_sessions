{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Corner Colors:** Find single-pixel colors in the four corners of the input grid.\n2.  **Identify Objects:** Identify connected components (objects) of the same color within the entire input grid (not just a subgrid). These are groups of adjacent pixels (including diagonals) that have the same color.\n3.  **Copy and Compress Objects:** Copy each identified object to the output grid.  Preserve the general shape of the objects during the copy, but compress them. The compression should maintain connectivity and relative positions of pixels within an object. *Do not* simply reduce each object to a single pixel. The amount of compression and the output grid size appears to be related to the size and complexity of the input, although the exact relationship is not yet clear.\n4.  **Position Objects:** Preserve the spatial arrangements between copied objects.\n5. **Preserve Corner Colors:** Place the identified corner colors from the input grid into the corresponding corners of the output grid. The output grid dimensions may vary so adjust appropriately.\n\"\"\"\n\nimport numpy as np\n\ndef get_corners(grid):\n    \"\"\"Finds isolated single-pixel colors in the corners of the grid.\"\"\"\n    rows, cols = grid.shape\n    corners = {}\n\n    # Check top-left corner\n    if grid[0, 0] != 0:\n        corners[(0, 0)] = grid[0, 0]\n\n    # Check top-right corner\n    if grid[0, cols - 1] != 0:\n        corners[(0, cols - 1)] = grid[0, cols - 1]\n\n    # Check bottom-left corner\n    if grid[rows - 1, 0] != 0:\n        corners[(rows - 1, 0)] = grid[rows - 1, 0]\n\n    # Check bottom-right corner\n    if grid[rows - 1, cols - 1] != 0:\n        corners[(rows - 1, cols - 1)] = grid[rows - 1, cols - 1]\n\n    return corners\n\ndef find_connected_components(grid):\n    \"\"\"Identifies connected components (objects) in a grid, including diagonal connections.\"\"\"\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    def dfs(r, c, color, component):\n        if (r < 0 or r >= grid.shape[0] or c < 0 or c >= grid.shape[1] or\n                visited[r, c] or grid[r, c] != color):\n            return\n        visited[r, c] = True\n        component.append((r, c))\n        # Check all 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                dfs(r + dr, c + dc, color, component)\n\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] != 0 and not visited[r, c]:\n                component = []\n                dfs(r, c, grid[r, c], component)\n                components.append((grid[r, c], component))\n    return components\n\ndef compress_component(component, scale_factor=0.5):\n    \"\"\"Compresses a component while preserving its shape.\"\"\"\n    if not component:\n        return []\n\n    # Find bounding box\n    min_row = min(p[0] for p in component)\n    max_row = max(p[0] for p in component)\n    min_col = min(p[1] for p in component)\n    max_col = max(p[1] for p in component)\n\n    # Calculate new dimensions\n    new_height = int(round((max_row - min_row + 1) * scale_factor))\n    new_width = int(round((max_col - min_col + 1) * scale_factor))\n    \n    # if new dimensions are zero, set minimum size\n    new_height = max(1, new_height)\n    new_width = max(1, new_width)\n\n    # Create a mapping from old to new coordinates\n    new_component = []\n    for r, c in component:\n        new_r = int(round((r - min_row) * (new_height - 1) / max(1, (max_row - min_row))))  if max_row > min_row else 0\n        new_c = int(round((c - min_col) * (new_width - 1) / max(1, (max_col - min_col)))) if max_col > min_col else 0\n        new_component.append((new_r, new_c))\n    \n    return list(set(new_component))  # Remove duplicates\n\n\ndef estimate_output_size(input_grid, components):\n    \"\"\"Estimates output grid size based on input and components.\"\"\"\n    input_rows, input_cols = input_grid.shape\n    \n    # Start with a base size, here, taking half of the max dimension of the input grid.\n    base_size = max(input_rows, input_cols) // 2\n    \n    # Adjust base size if it's zero\n    base_size = max(1, base_size)\n    \n    # find number of objects\n    num_objects = len(components)\n\n    # refine by number of objects\n    scale_factor = 1 + (num_objects // 4) # for every four objects scale up by one\n\n    # find average size of components\n    total_pixels = sum(len(c) for _, c in components)\n    if (len(components) > 0):\n      avg_pixels = total_pixels // len(components)\n    else:\n      avg_pixels = 0\n\n    # refine by pixel count\n    pixel_factor = 1+ (avg_pixels // 5)\n    \n    height = base_size + scale_factor + pixel_factor\n    width = base_size + scale_factor + pixel_factor\n\n    return height, width\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the defined rules.\"\"\"\n\n    # 1. Identify Corner Colors\n    corners = get_corners(input_grid)\n\n    # 2. Identify Objects\n    components = find_connected_components(input_grid)\n\n    # Estimate output size\n    output_rows, output_cols = estimate_output_size(input_grid, components)\n\n    # 3. Copy and Compress Objects\n    output_grid = np.zeros((output_rows, output_cols), dtype=int)\n    for color, component in components:\n        compressed_component = compress_component(component)\n        for r, c in compressed_component:\n            if r < output_rows and c < output_cols:\n                output_grid[r, c] = color\n\n    # 4. Preserve Corner Colors (adjusting for output grid dimensions)\n    for corner, color in corners.items():\n        r, c = corner\n        if r == 0 and c == 0:\n            output_grid[0, 0] = color  # Top-left\n        if r == 0 and c == input_grid.shape[1] - 1:\n            output_grid[0, output_cols - 1] = color  # Top-right\n        if r == input_grid.shape[0] - 1 and c == 0:\n            output_grid[output_rows - 1, 0] = color  # Bottom-left\n        if r == input_grid.shape[0] - 1 and c == input_grid.shape[1] - 1:\n            output_grid[output_rows - 1, output_cols - 1] = color  # Bottom-right\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10341,
    "candidates_token_count": 1813,
    "total_token_count": 12154,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 30.421383
}