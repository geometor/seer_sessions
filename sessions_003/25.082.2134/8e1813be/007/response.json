{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by identifying and extracting uniform rows and columns.\nPrioritizes full uniform rows. If uniform columns are present, it extracts those,\ncreating rows in the output grid where each cell represents a column's uniform color.\nIf there are no fully uniform rows, it looks for the longest uniform segment in\neach row and constructs output rows using these segments.\n\"\"\"\n\nimport numpy as np\n\ndef _find_uniform_rows(grid):\n    \"\"\"Identifies rows with a contiguous sequence of non-zero pixels of the same color.\"\"\"\n    uniform_rows = []\n    for i, row in enumerate(grid):\n        if _longest_uniform_subsequence(row) > 0:\n             #check that the longest subsequence represents entire row by comparing it with count of non-zero\n            color = -1\n            count = 0\n            for x in row:\n                if x!= 0:\n                    if color==-1:\n                        color = x\n                        count = 1\n                    elif color == x:\n                        count+=1\n\n            if _longest_uniform_subsequence(row) == count:\n                uniform_rows.append((i, row, 'full'))  # Store row index and the row itself, and flag \"full\"\n            elif count>0:\n                uniform_rows.append((i, row, 'partial'))\n    return uniform_rows\n\ndef _longest_uniform_subsequence(row):\n    \"\"\"Finds the length of the longest uniform non-zero subsequence.\"\"\"\n    max_len = 0\n    current_len = 0\n    current_val = None\n    for val in row:\n        if val == current_val and val != 0:\n            current_len += 1\n        elif val != 0:\n            max_len = max(max_len, current_len)\n            current_len = 1\n            current_val = val\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 0\n            current_val = None\n\n    max_len = max(max_len, current_len)  # Check at the end\n    return max_len\n\ndef _find_uniform_columns(grid):\n    \"\"\"Finds columns with consistent non-zero values, allowing for 0s.\"\"\"\n    uniform_cols = []\n    num_rows, num_cols = grid.shape\n    for j in range(num_cols):\n        first_val = None\n        consistent = True\n        for i in range(num_rows):\n            if grid[i,j] != 0:\n                if first_val is None:\n                    first_val = grid[i, j]\n                elif first_val != grid[i,j]:\n                    consistent = False\n                    break\n        if first_val is not None and consistent:\n            uniform_cols.append((j, first_val))\n    return uniform_cols\n\ndef _extract_uniform_segment(row):\n    \"\"\"Extracts the longest uniform segment from a row.\"\"\"\n    max_len = 0\n    current_len = 0\n    current_val = None\n    start_index = -1\n    max_start_index = -1\n\n    for i, val in enumerate(row):\n        if val == current_val and val != 0:\n            current_len += 1\n        elif val != 0:\n            if current_len > max_len:\n                max_len = current_len\n                max_start_index = start_index\n            current_len = 1\n            current_val = val\n            start_index = i\n        else:\n            if current_len > max_len:\n                max_len = current_len\n                max_start_index = start_index\n            current_len = 0\n            current_val = None\n            start_index = -1\n\n    if current_len > max_len:\n        max_len = current_len\n        max_start_index = start_index\n\n    if max_start_index != -1:\n        return row[max_start_index : max_start_index + max_len]\n    else:\n        return np.array([])\n\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid based on uniform rows and columns.\"\"\"\n\n    uniform_rows = _find_uniform_rows(input_grid)\n    uniform_columns = _find_uniform_columns(input_grid)\n    # 1. Prioritize full uniform rows\n    full_uniform_rows = [ (i,row) for i, row, flag in uniform_rows if flag == 'full']\n    if full_uniform_rows:\n        output_rows = [row for i, row in full_uniform_rows]\n        output_grid = np.array(output_rows)\n        if output_grid.size > 0:\n\n          #now, reduce length\n          first_output_row = output_grid[0,:]\n          new_len = 0\n\n          for x in first_output_row:\n            if x!=0:\n              new_len+=1\n\n          output_grid_short = []\n          for i in range(output_grid.shape[0]):\n            output_grid_short.append(output_grid[i,:new_len])\n\n          return np.array(output_grid_short)\n\n    # 2. If uniform columns are present, use them\n    if uniform_columns:\n        output_rows = []\n        for _, color in uniform_columns:\n            output_rows.append([color] * len(uniform_columns)) # length = number of columns\n        return np.array(output_rows)\n\n    # 3.  Extract partial uniform rows\n    partial_uniform_rows_with_segments = [ (i, _extract_uniform_segment(row))   for i, row, flag in uniform_rows if flag == 'partial']\n\n    # 4. Sort by length\n    sorted_partial = sorted(partial_uniform_rows_with_segments, key=lambda x: len(x[1]), reverse=True)\n    if not sorted_partial:\n        return np.array([]).reshape(0, 0)\n\n\n    # 5. Construct the output based on max segment length\n    max_seg_len = len(sorted_partial[0][1])\n\n    output_grid = []\n    for i, seg in sorted_partial:\n      if len(seg)>0:\n          output_grid.append(seg)\n\n    if not output_grid:\n      return np.array([]).reshape(0, 0)\n\n    return np.array(output_grid)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12184,
    "candidates_token_count": 1509,
    "total_token_count": 13693,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 25.810974
}