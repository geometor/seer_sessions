{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Background Transformation:** Change all pixels of the initial background color (0) to color 3 (green).\n\n2.  **Shape Identification:** Identify all contiguous shapes (orthogonally connected pixels of the same color) in the input grid. Do *not* change any pixel values yet.\n\n3. **Target shape selection:**\n    *   If color 6 is present, then do nothing to shape 6\n    *   If color 2 is present, the shape that contains it is the \"target shape\"\n    *   If only color 2 is not present, the \"target shape\" is defined by the shape with color 4, 7, or 8 (in order of example occurrence).\n\n4.  **Target Shape Expansion:** Expand the target shape by one pixel in all four orthogonal directions (up, down, left, and right) *only if* the target pixel for expansion was originally the background color (0) in the input grid.\n\n5.  **Other Shape Color Change:**\n    *   In example 1, the non-target shape has color 2, and it is transformed to color 6.\n    *    In example 4, the non-target shape has color 2 and is transformed to color 8.\n\n6.  **Combined Color Change and Target Expansion:**\n    *   If the \"target\" shape contains the color 2, it should be expanded to the background, and the expanded pixels should be of the \"other shape color change\", from step 5, that corresponds to the example.\n        *   Example 1: shape 4 expands, shape 2 becomes 6\n        *   Example 2: shape 2 expands, shape 6 remains\n        *   Example 3: shape 7 expands, shape 2 remains.\n        *   Example 4: shape 8 expands, shape 2 becomes 6.\n\"\"\"\n\nimport numpy as np\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.full_like(input_grid, 3)\n    rows, cols = input_grid.shape\n\n    def get_neighbors(r, c):\n        \"\"\"Gets the orthogonal neighbors of a cell.\"\"\"\n        neighbors = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n        return neighbors\n\n    def find_shapes(grid):\n        \"\"\"Finds all contiguous shapes in the grid.\"\"\"\n        visited = set()\n        shapes = []\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r, c] != 0 and (r, c) not in visited:\n                    color = grid[r, c]\n                    shape_pixels = []\n                    stack = [(r, c)]\n                    while stack:\n                        cr, cc = stack.pop()\n                        if (cr, cc) in visited:\n                            continue\n                        visited.add((cr, cc))\n                        shape_pixels.append((cr, cc))\n                        for nr, nc in get_neighbors(cr, cc):\n                            if grid[nr, nc] == color:\n                                stack.append((nr, nc))\n                    shapes.append({'color': color, 'pixels': shape_pixels})\n        return shapes\n\n    # Shape Identification\n    shapes = find_shapes(input_grid)\n\n    # Target shape selection\n    target_shape = None\n    other_shape_color_change = None\n\n    for shape in shapes:\n      if shape['color'] == 6:\n          continue # skip shape with color 6\n      if shape['color'] == 2:\n          target_shape = shape\n          break # first shape\n\n    # handle case where there are no shapes of color 2\n    if target_shape is None:\n        for shape in shapes:\n            if shape['color'] in [4, 7, 8]:\n                target_shape = shape\n                break\n\n    # determine the other shape change\n    if target_shape:\n        if target_shape['color'] == 4:\n            other_shape_color_change = 6\n        elif target_shape['color'] == 8:\n            other_shape_color_change = 6 # color 2 to 6\n        elif any(shape['color'] == 4 for shape in shapes): # color 2\n           other_shape_color_change = 6\n        elif any(shape['color'] == 8 for shape in shapes):\n            other_shape_color_change = 6\n\n\n    for shape in shapes:\n        if shape is target_shape:\n            # Expansion of target shape\n            expansion_color = shape['color']\n\n            # check if color is 2 to overide expansion\n            if shape['color'] == 2 and other_shape_color_change:\n                expansion_color = other_shape_color_change\n\n            for r, c in shape['pixels']:\n              output_grid[r,c] = expansion_color # first fill the target\n              for nr, nc in get_neighbors(r, c):\n                  if input_grid[nr, nc] == 0:\n                      output_grid[nr, nc] = expansion_color\n\n        else: # Other shapes\n            new_color = shape['color']\n\n            # change other shape color, if needed\n            if shape['color'] == 2 and other_shape_color_change is not None :\n                new_color = other_shape_color_change\n\n            for r, c in shape['pixels']:\n                output_grid[r, c] = new_color\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9339,
    "candidates_token_count": 1302,
    "total_token_count": 10641,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 22.139991
}