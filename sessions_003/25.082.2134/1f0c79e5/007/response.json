{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule involves identifying a contiguous object in the input grid, determining its core and unique colors, and then performing a mirroring operation based on the unique color's position relative to the object's bounding box. If a unique color exists and is on an edge, the object is mirrored along that edge. If the unique color is in a corner, a diagonal mirror is performed. The output grid's dimensions are two greater in both height and width than the bounding box, or size adjusted to contain object. If there is only one pixel, a 3x3 is produced. If there is only a row, a 3 high grid is returned, and if there is only a column, a 3 wide grid is returned.\n\n\"\"\"\n\nimport numpy as np\n\ndef find_object_and_bbox(grid):\n    \"\"\"Finds the object (non-zero pixels) and its bounding box.\"\"\"\n    non_zero_pixels = np.argwhere(grid != 0)\n    if len(non_zero_pixels) == 0:\n        return [], None  # No object found\n\n    min_row, min_col = np.min(non_zero_pixels, axis=0)\n    max_row, max_col = np.max(non_zero_pixels, axis=0)\n    object_pixels = [(r, c) for r in range(min_row, max_row + 1)\n                     for c in range(min_col, max_col + 1)\n                     if grid[r, c] != 0]\n    bbox = ((min_row, max_row), (min_col, max_col))\n    return object_pixels, bbox\n\ndef get_core_and_unique_colors(grid, object_pixels):\n    \"\"\"Identifies the core and unique/pseudo-unique colors within the object.\"\"\"\n    if not object_pixels:\n        return None, None, None\n\n    color_counts = {}\n    for r, c in object_pixels:\n        color = grid[r, c]\n        color_counts[color] = color_counts.get(color, 0) + 1\n\n    sorted_colors = sorted(color_counts.items(), key=lambda item: item[1], reverse=True)\n    core_color = sorted_colors[0][0]\n    unique_color = None\n    pseudo_unique_color = None\n\n    if len(sorted_colors) > 1:\n      min_count = min(count for _, count in sorted_colors)\n      min_colors = [color for color, count in sorted_colors if count == min_count]\n      if len(min_colors) == 1 and min_count == 1:\n        unique_color = min_colors[0]\n      elif len(min_colors) >= 1:\n        pseudo_unique_color = min_colors[0]\n\n    return core_color, unique_color, pseudo_unique_color\n\ndef find_pixel_location(grid, object_pixels, color):\n    \"\"\"Finds the first location of a given color within the object.\"\"\"\n    if color is None:\n        return None\n    for r, c in object_pixels:\n        if grid[r, c] == color:\n            return (r, c)\n    return None\n\ndef determine_mirroring(bbox, unique_pixel_loc, core_color, input_grid):\n    \"\"\"Determines mirroring operations based on unique pixel location.\"\"\"\n    if unique_pixel_loc is None:\n        return \"none\", None  # No mirroring\n\n    (min_row, max_row), (min_col, max_col) = bbox\n    row, col = unique_pixel_loc\n\n    obj_h = max_row - min_row + 1\n    obj_w = max_col - min_col + 1\n\n    # check for simple extension\n    if obj_h == 1 and obj_w == 1:\n        return \"extend_all\", None\n    # Check for horizontal extension\n    if obj_h == 1:\n        return \"extend_horizontal\", obj_w\n    # Check for vertical extension\n    if obj_w == 1:\n        return \"extend_vertical\", obj_h\n\n    # Check if unique color is on any edge\n    if col == max_col:\n       return \"horizontal\", \"right\"\n    if col == min_col:\n        return \"horizontal\", \"left\"\n    if row == max_row:\n        return \"vertical\", \"up\"\n    if row == min_row:\n        return \"vertical\", \"down\"\n\n    # Corner mirroring\n    if row == min_row and col == min_col:\n        return \"diagonal\", \"top_left\"\n    if row == min_row and col == max_col:\n       return \"diagonal\", \"top_right\"\n    if row == max_row and col == min_col:\n        return \"diagonal\", \"bottom_left\"\n    if row == max_row and col == max_col:\n        return \"diagonal\", \"bottom_right\"\n\n    return \"unknown\", None # this case should be investigated\n\ndef transform(input_grid):\n    # Find the object and its bounding box\n    object_pixels, bbox = find_object_and_bbox(input_grid)\n\n    # Get the core and unique/pseudo colors\n    core_color, unique_color, pseudo_unique_color = get_core_and_unique_colors(input_grid, object_pixels)\n\n    # Find the location of the unique or pseudo-unique pixel\n    unique_pixel_loc = find_pixel_location(input_grid, object_pixels, unique_color)\n    if unique_pixel_loc is None:\n        unique_pixel_loc = find_pixel_location(input_grid, object_pixels, pseudo_unique_color)\n\n    # Determine mirroring direction and details\n    mirror_type, mirror_details = determine_mirroring(bbox, unique_pixel_loc, core_color, input_grid)\n\n    if mirror_type == \"extend_all\":\n        output_grid = np.full((3, 3), core_color)\n\n    elif mirror_type == \"extend_horizontal\":\n        extended = np.tile(input_grid[unique_pixel_loc[0],:], (1, mirror_details + 2))\n        output_grid = np.vstack([extended, input_grid, extended])\n\n    elif mirror_type == \"extend_vertical\":\n        extended = np.tile(input_grid[:,unique_pixel_loc[1]].reshape(-1,1), (mirror_details + 2, 1))\n        output_grid = np.hstack([extended, input_grid, extended])\n\n    elif mirror_type == \"horizontal\":\n        (min_row, max_row), (min_col, max_col) = bbox\n        obj = input_grid[min_row:max_row+1, min_col:max_col+1]\n        h, w = obj.shape\n\n        if mirror_details == \"right\":\n            output_grid = np.hstack([np.fliplr(obj), obj[:, 1:]])\n\n        elif mirror_details == \"left\":\n            output_grid = np.hstack([obj[:, :-1], np.fliplr(obj)])\n        output_grid = np.pad(output_grid, pad_width=1, mode='constant', constant_values=0)\n\n    elif mirror_type == \"vertical\":\n        (min_row, max_row), (min_col, max_col) = bbox\n        obj = input_grid[min_row:max_row+1, min_col:max_col+1]\n        h, w = obj.shape\n        if mirror_details == \"up\":\n            output_grid = np.vstack([np.flipud(obj), obj[1:, :]])\n        elif mirror_details == \"down\":\n            output_grid = np.vstack([obj[:-1,:], np.flipud(obj)])\n\n        output_grid = np.pad(output_grid, pad_width=1, mode='constant', constant_values=0)\n\n    elif mirror_type == \"diagonal\":\n        (min_row, max_row), (min_col, max_col) = bbox\n        obj = input_grid[min_row:max_row+1, min_col:max_col+1]\n        h, w = obj.shape\n        flipped_obj = np.transpose(obj)\n\n        if mirror_details == \"top_left\":\n            output_grid = np.block([[obj, np.fliplr(obj)], [np.flipud(obj), flipped_obj]])\n        elif mirror_details == \"top_right\":\n           output_grid = np.block([[np.fliplr(obj),obj], [np.fliplr(np.flipud(obj)), np.flipud(obj)]])\n        elif mirror_details == \"bottom_left\":\n           output_grid = np.block([[np.flipud(obj), np.fliplr(np.flipud(obj))], [obj, np.fliplr(obj)]])\n        elif mirror_details == \"bottom_right\":\n            output_grid = np.block([[np.fliplr(obj), np.fliplr(np.flipud(obj))], [np.flipud(obj), obj]])\n\n        # find object and pad\n        output_grid = np.pad(output_grid[1:-1, 1:-1], pad_width=1, mode='constant', constant_values=0)\n\n    else: # case \"unknown\"\n        # default empty grid of max size\n        output_grid = np.zeros((9,9), dtype=int)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23397,
    "candidates_token_count": 2210,
    "total_token_count": 25607,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 23.743059
}