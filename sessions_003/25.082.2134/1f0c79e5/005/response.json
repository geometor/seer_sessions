{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Input Object:** Find the contiguous non-zero pixels in the input grid. Determine the bounding box (min/max row and min/max column) of this object.\n\n2.  **Determine Core and Unique Colors:** Calculate the frequency of each non-zero color within the object. The core color is the most frequent color.  If there's a color that appears only once, it's the unique color. If no unique colors exist, check if there exists colors that tie in lowest frequency and pick the first one encountered as pseudo-unique color.\n\n3.  **Locate Unique/Pseudo-Unique Pixel:** Find the coordinates of the unique color pixel. If no unique color exists, find the coordinates of pseudo-unique color pixels.\n\n4. **Determine Output Dimensions:** Calculate the final dimensions of the output: `output_rows = object_height + 2`, `output_cols = object_width + 2`, where `object_height = max_row - min_row +1` and `object_width = max_col - min_col + 1`.\n\n5.  **Create a 3x3 Core:** Create a 3x3 block filled with the core color.\n\n6.  **Position and Mirror based on Unique/Pseudo-Unique Pixel:**\n    *   If a unique pixel exists and is located on an edge of the object's bounding box:\n        *   Right edge: Create a horizontal mirror of the 3x3 core to the *left*.\n        *   Left edge: Create a horizontal mirror of the 3x3 core to the *right*.\n        *   Bottom edge: Create a vertical mirror of the 3x3 core *above*.\n        *   Top edge: Create a vertical mirror of the 3x3 core *below*.\n    *   If a unique pixel is in a corner:\n        * Mirror horizontally *and* vertically *and* diagonally to the opposite corner quadrant.\n    * If there are only two pixels colors, and no true unique pixel, consider the less frequent color the \"pseudo-unique\" and use position of the first encountered pixel.\n\n7.  **Construct Output Grid:** Create an output grid of zeros with the calculated dimensions. Place the 3x3 core and its mirrored versions based on the unique/pseudo-unique pixel's location.\n\n8. Place original `core` to the center position of the `output_grid`.\n\n\"\"\"\n\nimport numpy as np\n\ndef find_object_and_bbox(grid):\n    \"\"\"Finds the object (non-zero pixels) and its bounding box.\"\"\"\n    non_zero_pixels = np.argwhere(grid != 0)\n    if len(non_zero_pixels) == 0:\n        return [], None  # No object found\n\n    min_row, min_col = np.min(non_zero_pixels, axis=0)\n    max_row, max_col = np.max(non_zero_pixels, axis=0)\n    object_pixels = [(r, c) for r in range(min_row, max_row + 1)\n                     for c in range(min_col, max_col + 1)\n                     if grid[r, c] != 0]\n    bbox = ((min_row, max_row), (min_col, max_col))\n    return object_pixels, bbox\n\ndef get_core_and_unique_colors(grid, object_pixels):\n    \"\"\"Identifies the core and unique/pseudo-unique colors within the object.\"\"\"\n    if not object_pixels:\n        return None, None, None\n\n    color_counts = {}\n    for r, c in object_pixels:\n        color = grid[r, c]\n        color_counts[color] = color_counts.get(color, 0) + 1\n\n    sorted_colors = sorted(color_counts.items(), key=lambda item: item[1], reverse=True)\n    core_color = sorted_colors[0][0]\n    unique_color = None\n    pseudo_unique_color = None\n\n    if len(sorted_colors) > 1:\n      min_count = min(count for _, count in sorted_colors)\n      min_colors = [color for color, count in sorted_colors if count == min_count]\n      if len(min_colors) == 1 and min_count == 1:\n        unique_color = min_colors[0]\n      elif len(min_colors) >= 1:\n        pseudo_unique_color = min_colors[0]\n    \n    return core_color, unique_color, pseudo_unique_color\n\ndef find_pixel_location(grid, object_pixels, color):\n    \"\"\"Finds the first location of a given color within the object.\"\"\"\n    if color is None:\n        return None\n    for r, c in object_pixels:\n        if grid[r, c] == color:\n            return (r, c)\n    return None\n\ndef determine_output_dimensions(bbox):\n    \"\"\"Calculates output dimensions based on the bounding box.\"\"\"\n    (min_row, max_row), (min_col, max_col) = bbox\n    object_height = max_row - min_row + 1\n    object_width = max_col - min_col + 1\n    return object_height + 2, object_width + 2\n\ndef determine_mirroring(bbox, unique_pixel_loc):\n    \"\"\"Determines mirroring operations based on unique pixel location.\"\"\"\n    if unique_pixel_loc is None:\n        return False, False, False  # No mirroring\n\n    (min_row, max_row), (min_col, max_col) = bbox\n    row, col = unique_pixel_loc\n\n    horizontal_mirror = False\n    vertical_mirror = False\n    diagonal_mirror = False\n\n    # Edge mirroring\n    if col == max_col:\n        horizontal_mirror = True  # Right edge\n    if col == min_col:\n        horizontal_mirror = True  # Left edge\n    if row == max_row:\n        vertical_mirror = True  # Bottom edge\n    if row == min_row:\n        vertical_mirror = True  # Top edge\n\n    # Corner mirroring\n    if row == min_row and col == min_col:\n        diagonal_mirror = True  # Top-left\n    if row == min_row and col == max_col:\n        diagonal_mirror = True  # Top-right\n    if row == max_row and col == min_col:\n        diagonal_mirror = True  # Bottom-left\n    if row == max_row and col == max_col:\n        diagonal_mirror = True  # Bottom-right\n        \n    return horizontal_mirror, vertical_mirror, diagonal_mirror\n\ndef create_and_place_core(output_grid, core_color):\n  \"\"\"Creates 3x3 core block\"\"\"\n  core = np.full((3, 3), core_color)\n  center_row = output_grid.shape[0] // 2\n  center_col = output_grid.shape[1] // 2\n  output_grid[center_row-1:center_row+2, center_col-1:center_col+2] = core\n  return output_grid\n\ndef apply_mirroring(output_grid, core_color, horizontal_mirror, vertical_mirror, diagonal_mirror, unique_pixel_loc, bbox):\n    \"\"\"Applies mirroring to the output grid based on flags.\"\"\"\n    core = np.full((3, 3), core_color)\n    center_row = output_grid.shape[0] // 2\n    center_col = output_grid.shape[1] // 2\n    (min_row, max_row), (min_col, max_col) = bbox\n\n    # Horizontal mirroring\n    if horizontal_mirror:\n        if unique_pixel_loc[1] == max_col:  # Right\n            output_grid[center_row - 1:center_row + 2, center_col - 4:center_col - 1] = np.fliplr(core)\n        elif unique_pixel_loc[1] == min_col: # Left\n             output_grid[center_row - 1:center_row + 2, center_col + 2:center_col + 5] = np.fliplr(core)\n    # Vertical mirroring\n    if vertical_mirror:\n        if unique_pixel_loc[0] == max_row:  # Bottom\n            output_grid[center_row - 4:center_row - 1, center_col - 1:center_col + 2] = np.flipud(core)\n        elif unique_pixel_loc[0] == min_row:  #Top\n            output_grid[center_row + 2:center_row + 5, center_col - 1:center_col + 2] = np.flipud(core)\n\n    # Diagonal mirroring\n    if diagonal_mirror:\n       flipped = np.transpose(core)\n       if unique_pixel_loc == (min_row, min_col): #top-left\n            output_grid[center_row + 2:center_row + 5, center_col+2:center_col+5] = flipped\n       if unique_pixel_loc == (min_row, max_col):  #top-right\n            output_grid[center_row + 2:center_row + 5, center_col - 4:center_col - 1] = flipped\n       if unique_pixel_loc == (max_row, min_col):  #bottom-left\n            output_grid[center_row - 4:center_row - 1, center_col+2:center_col+5] = flipped\n       if unique_pixel_loc == (max_row, max_col):  #bottom-right\n            output_grid[center_row - 4:center_row - 1, center_col - 4:center_col - 1] = flipped\n    return output_grid\n\ndef transform(input_grid):\n    # Find the object and its bounding box\n    object_pixels, bbox = find_object_and_bbox(input_grid)\n\n    # Get the core and unique/pseudo colors\n    core_color, unique_color, pseudo_unique_color = get_core_and_unique_colors(input_grid, object_pixels)\n\n    # Find the location of the unique or pseudo-unique pixel\n    unique_pixel_loc = find_pixel_location(input_grid, object_pixels, unique_color)\n    if unique_pixel_loc is None:\n        unique_pixel_loc = find_pixel_location(input_grid, object_pixels, pseudo_unique_color)\n\n    # Determine output dimensions\n    output_rows, output_cols = determine_output_dimensions(bbox)\n\n    # Create output grid\n    output_grid = np.zeros((output_rows, output_cols), dtype=int)\n    \n    # Determine mirroring\n    horizontal_mirror, vertical_mirror, diagonal_mirror = determine_mirroring(bbox, unique_pixel_loc)\n\n    # Create and place core\n    output_grid = create_and_place_core(output_grid, core_color)\n\n    # Apply mirroring\n    output_grid = apply_mirroring(output_grid, core_color, horizontal_mirror, vertical_mirror, diagonal_mirror, unique_pixel_loc, bbox)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10211,
    "candidates_token_count": 2613,
    "total_token_count": 12824,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 33.590882
}