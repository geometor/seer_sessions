{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Key Colors:** Determine the colors in the input grid that are *not* the most frequent (dominant) color. These are the \"key\" colors.\n2.  **Locate Key Color Instances:**  For each key color, find the (row, column) coordinates of all pixels of that color.\n3.  **Determine Output Pattern and Size**: Analyze the spatial relationship between groups of pixels of key colours and use this to determine output size\n    *   If there are four key colors and each occurs in four pixels forming corners of rectangles, the output is likely a set of concentric rectangles. The output size is 5x5.\n    *   If two key colors exist and four pixels of each form corners of rectangles, output is likely two concentric rectangles. Output size 5x5.\n    *  If there are two key colors, and one forms a \"plus\" shape, while another forms a rectangle/square encompassing it. Output size will be 3x3\n4. **Construct Output Grid**:\n    *   **Concentric Rectangles:** Create a 5x5 output grid. Place the key colors as corners of concentric rectangles, working inwards. The outermost rectangle uses the color that formed the rectangle with a corner closest to [0,0]. The next inner one uses color with next further, and so on.\n    *   **Rectangle with Plus:**  Create a 3x3 output grid. The color forming the corners of outermost rectangle will now form a solid filled rectangle. The \"plus\" shape color is placed in a plus shape (+) in the output, with color 1 placed at the center.\n    * **Background:** If the input dominant colour and the output dominant colour match, then maintain the dominant colour as the output background (fill all cells of output with dominant input colour, and 'draw on top'.) Otherwise, create a new background with 0\n5.  **Return:** Return the constructed output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef get_dominant_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    flat_grid = grid.flatten()\n    color_counts = Counter(flat_grid)\n    dominant_color = color_counts.most_common(1)[0][0]\n    return dominant_color\n\ndef find_key_colors(grid):\n    \"\"\"Identifies colors that are not the dominant color.\"\"\"\n    dominant_color = get_dominant_color(grid)\n    return [color for color in np.unique(grid) if color != dominant_color]\n\ndef get_pixel_positions(grid, color):\n    \"\"\"Returns a list of (row, col) tuples for all pixels of the given color.\"\"\"\n    return np.argwhere(grid == color).tolist()\n\ndef is_rectangle_corners(positions):\n    \"\"\"Checks if the given positions form the corners of a rectangle.\"\"\"\n    if len(positions) != 4:\n        return False\n    \n    rows = sorted(list(set([r for r, c in positions])))\n    cols = sorted(list(set([c for r, c in positions])))\n\n    if len(rows) != 2 or len(cols) != 2:\n        return False;\n\n    expected_corners = [[rows[0], cols[0]], [rows[0], cols[1]], [rows[1], cols[0]], [rows[1], cols[1]]]\n\n    return all([corner in positions for corner in expected_corners])\n\n\ndef find_rectangle_corners_closest_to_origin(positions):\n     \"\"\"Of the corners, find one which is closest to origin\"\"\"\n     min_dist = float('inf')\n     closest_corner = None\n\n     for r,c in positions:\n        dist = (r**2 + c**2)\n        if dist< min_dist:\n            min_dist = dist\n            closest_corner = (r,c)\n\n     return closest_corner\n\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    key_colors = find_key_colors(input_grid)\n    dominant_color = get_dominant_color(input_grid)\n    key_color_positions = {color: get_pixel_positions(input_grid, color) for color in key_colors}\n\n    # Determine output pattern and size\n    if len(key_colors) == 4 and all(is_rectangle_corners(key_color_positions[color]) for color in key_colors):\n        # Concentric rectangles pattern\n        output_grid = np.full((5, 5), dominant_color)\n        \n        # Sort colors based on distance of their closest corner to origin\n        sorted_colors = sorted(key_colors, key=lambda color: find_rectangle_corners_closest_to_origin(key_color_positions[color])[0] + find_rectangle_corners_closest_to_origin(key_color_positions[color])[1] )\n\n\n        output_grid[0, 0] = sorted_colors[0]\n        output_grid[0, 4] = sorted_colors[0]\n        output_grid[4, 0] = sorted_colors[0]\n        output_grid[4, 4] = sorted_colors[0]\n\n        output_grid[0, 1] = sorted_colors[1]\n        output_grid[0, 3] = sorted_colors[1]\n        output_grid[4, 1] = sorted_colors[1]\n        output_grid[4, 3] = sorted_colors[1]\n\n        output_grid[1, 0] = sorted_colors[3]\n        output_grid[1, 4] = sorted_colors[3]\n        output_grid[3, 0] = sorted_colors[3]\n        output_grid[3, 4] = sorted_colors[3]\n\n        output_grid[0, 2] = sorted_colors[2]\n        output_grid[2, 0] = sorted_colors[2]\n        output_grid[2, 4] = sorted_colors[2]\n        output_grid[4, 2] = sorted_colors[2]\n        \n    elif len(key_colors) == 2 and all(is_rectangle_corners(key_color_positions[color]) for color in key_colors):\n        output_grid = np.full((5,5), dominant_color)\n\n        sorted_colors = sorted(key_colors, key=lambda color: find_rectangle_corners_closest_to_origin(key_color_positions[color])[0] + find_rectangle_corners_closest_to_origin(key_color_positions[color])[1] )\n\n        output_grid[0, 0] = sorted_colors[0]\n        output_grid[0, 4] = sorted_colors[0]\n        output_grid[4, 0] = sorted_colors[0]\n        output_grid[4, 4] = sorted_colors[0]\n\n        output_grid[0, 2] = sorted_colors[1]\n        output_grid[2, 0] = sorted_colors[1]\n        output_grid[2, 4] = sorted_colors[1]\n        output_grid[4, 2] = sorted_colors[1]\n\n    elif len(key_colors) == 2:\n        # Rectangle with plus pattern\n        output_grid = np.zeros((3, 3), dtype=int)\n        color1 = key_colors[0]\n        color2 = key_colors[1]\n\n        #Determine which one is rectangle\n        if is_rectangle_corners(key_color_positions[color1]):\n            rect_color = color1\n            plus_color = color2\n        else:\n            rect_color = color2\n            plus_color = color1\n\n        #fill rectangle\n        for r in range(3):\n          for c in range(3):\n            output_grid[r,c] = rect_color\n        \n        #make plus\n        output_grid[1,1] = 1\n        output_grid[0,1] = plus_color\n        output_grid[1,0] = plus_color\n        output_grid[1,2] = plus_color\n        output_grid[2,1] = plus_color\n\n\n    else:\n        output_grid = np.full((5, 5), dominant_color)  # Default case\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8491,
    "candidates_token_count": 1923,
    "total_token_count": 10414,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 22.459136
}