{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Dominant and Key Colors:** Find the most frequent (dominant) color in the input grid.  Key colors are all other colors.\n\n2.  **Locate Key Color Positions:** For each key color, find all (row, column) coordinates of its pixels.\n\n3. **Determine Object and Transformation Types**\n     * Check for *rectangle*: Four pixels of a key color that form rectangle corners.\n     * Check for *plus*: Five pixels of a key color, in a '+' shape.\n     * **Concentric Rectangles**: If key colors form only rectangle corners and there are 2 or 4 key colors, then we have potentially concentric rectangles.\n        - Determine output grid size:\n            - If two sets of rectangle corners, and pixels form \"plus\" shape, then output is 3 x 3\n            - Otherwise, output is 5 x 5.\n     * **Rectangle with Plus**: If only two key colors, and one forms corners of a rectangle, and another forms a plus shape, then the transformation is 'Rectangle with plus'\n\n4.  **Construct Output Grid:**\n\n    *   **Concentric Rectangles:**\n        1. Create an output grid of the determined size filled with input's dominant color.\n        2. For each rectangle, starting with outermost to innermost:\n            * Identify the four corner pixels.\n            * Calculate the average row and column indices for each rectangle formed by key colors.\n            * Sort rectangles by their average distance from origin (0,0).\n            * The outermost rectangle's color in the output uses the key color of the rectangle whose average coordinate is closest to the origin (0, 0). The next inner rectangle uses the next closest, and so forth.\n            * Place the corner pixels of the rectangle in the output grid. Example: for 5x5, 1st rectangle has corners at (0,0), (0,4), (4,0), (4,4), 2nd has (0,1),(0,3),(4,1)(4,3) and so on.\n    *   **Rectangle with Plus:**\n        1.  Create a 3x3 output grid filled with 0.\n        2.  Fill the entire output grid with the color of the rectangle object.\n        3.  Place the 'plus' color at the center and the four adjacent positions (up, down, left, right) of the center pixel. Set output center pixel color to 1.\n\n5.  **Return:** Return the constructed output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef get_dominant_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    flat_grid = grid.flatten()\n    color_counts = Counter(flat_grid)\n    dominant_color = color_counts.most_common(1)[0][0]\n    return dominant_color\n\ndef find_key_colors(grid):\n    \"\"\"Identifies colors that are not the dominant color.\"\"\"\n    dominant_color = get_dominant_color(grid)\n    return [color for color in np.unique(grid) if color != dominant_color]\n\ndef get_pixel_positions(grid, color):\n    \"\"\"Returns a list of (row, col) tuples for all pixels of the given color.\"\"\"\n    return np.argwhere(grid == color).tolist()\n\ndef is_rectangle_corners(positions):\n    \"\"\"Checks if the given positions form the corners of a rectangle.\"\"\"\n    if len(positions) != 4:\n        return False\n\n    rows = sorted(list(set([r for r, c in positions])))\n    cols = sorted(list(set([c for r, c in positions])))\n\n    if len(rows) != 2 or len(cols) != 2:\n        return False;\n\n    expected_corners = [[rows[0], cols[0]], [rows[0], cols[1]], [rows[1], cols[0]], [rows[1], cols[1]]]\n\n    return all([corner in positions for corner in expected_corners])\n\ndef is_plus_shape(positions):\n    \"\"\"Checks if positions form a plus shape.\"\"\"\n    if len(positions) != 5:\n        return False\n\n    #Find Center\n    rows = [r for r,c in positions]\n    cols = [c for r,c in positions]\n    center_row = sum(rows)/len(rows)\n    center_col = sum(cols)/len(cols)\n\n    if not (center_row.is_integer() and center_col.is_integer()):\n        return False\n    \n    center = [int(center_row), int(center_col)]\n\n    # Check if center is present\n    if center not in positions:\n       return False;\n    \n    expected_neighbors = [[center[0]-1, center[1]], [center[0]+1, center[1]],\n                          [center[0], center[1]-1], [center[0], center[1]+1]]\n    \n    return all([neighbor in positions for neighbor in expected_neighbors])\n\ndef average_coordinate(positions):\n    \"\"\"Calculates the average row and column indices for a set of positions.\"\"\"\n    if not positions:\n        return (0, 0)  # Handle empty list case\n    avg_row = sum(r for r, c in positions) / len(positions)\n    avg_col = sum(c for r, c in positions) / len(positions)\n    return (avg_row, avg_col)\n\ndef transform(input_grid):\n    input_grid = np.array(input_grid)\n    key_colors = find_key_colors(input_grid)\n    dominant_color = get_dominant_color(input_grid)\n    key_color_positions = {color: get_pixel_positions(input_grid, color) for color in key_colors}\n\n    # Determine output pattern and size\n    rectangle_shapes = {}\n    plus_shape = None\n    output_size = None\n\n    for color in key_colors:\n       if is_rectangle_corners(key_color_positions[color]):\n           rectangle_shapes[color] = key_color_positions[color]\n       elif is_plus_shape(key_color_positions[color]):\n           plus_shape = color\n\n    if plus_shape is not None and len(rectangle_shapes) == 1:\n        # Rectangle with plus pattern\n      output_size = (3,3)\n      output_grid = np.full(output_size, 0, dtype=int)\n\n      rect_color = list(rectangle_shapes.keys())[0]\n      plus_color = plus_shape\n\n       #fill rectangle\n      for r in range(3):\n        for c in range(3):\n          output_grid[r,c] = rect_color\n      \n      #make plus\n      output_grid[1,1] = 1\n      output_grid[0,1] = plus_color\n      output_grid[1,0] = plus_color\n      output_grid[1,2] = plus_color\n      output_grid[2,1] = plus_color\n\n    elif len(rectangle_shapes)>=2:\n        output_size = (5,5)\n        output_grid = np.full(output_size, dominant_color, dtype=int)\n\n        # Sort rectangles based on average distance to origin\n        sorted_rectangles = sorted(rectangle_shapes.items(),\n                                  key=lambda item: average_coordinate(item[1])[0] + average_coordinate(item[1])[1])\n        \n        #Concentric Rectangle Filling\n        for i, (color, corners) in enumerate(sorted_rectangles):\n          if i==0:\n            output_grid[0, 0] = color\n            output_grid[0, 4] = color\n            output_grid[4, 0] = color\n            output_grid[4, 4] = color\n          elif i == 1:\n            if len(sorted_rectangles) == 4: #Example 1, four concentric rects\n              output_grid[0, 1] = color\n              output_grid[0, 3] = color\n              output_grid[4, 1] = color\n              output_grid[4, 3] = color\n            elif len(sorted_rectangles) == 2: #Example 3, two concentric rects\n              output_grid[0, 2] = color\n              output_grid[2, 0] = color\n              output_grid[2, 4] = color\n              output_grid[4, 2] = color\n          elif i == 2:  #Example 1 only\n            output_grid[0, 2] = color\n            output_grid[2, 0] = color\n            output_grid[2, 4] = color\n            output_grid[4, 2] = color\n          elif i == 3:  #Example 1 only\n            output_grid[1, 0] = color\n            output_grid[1, 4] = color\n            output_grid[3, 0] = color\n            output_grid[3, 4] = color\n\n    else: #Default, fill with background\n        output_grid = np.full((5,5), dominant_color)\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8084,
    "candidates_token_count": 2119,
    "total_token_count": 10203,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 26.004508
}