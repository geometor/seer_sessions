{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all contiguous objects in the input grid.\n2.  **Find the \"L\" Object:** Locate the \"L\"-shaped object (color 0, three pixels, two with one neighbor, one with two).\n3.  **Identify the Enclosed Object:** Find the object enclosed by the \"L\" object (any color other than 0, adjacent to L-object).\n4.  **Create Output Grid:** Construct a 3x3 output grid.\n5.  **Fill Output Grid:** Fill with the color of the enclosed object.\n6.  **Overlay L-Shape:** Determine orientation (top-left, top-right, bottom-left, bottom-right).\n7.  **Place \"L\" Pixels:** Overlay the \"L\" shape (color 0) based on orientation.\n8.  **If no enclosed object, output a grid full of zeros.**\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Finds contiguous objects in a grid.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = len(grid), len(grid[0])\n\n    def dfs(r, c, color, current_object):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != color:\n            return\n        visited.add((r, c))\n        current_object.append((r, c))\n        dfs(r + 1, c, color, current_object)\n        dfs(r - 1, c, color, current_object)\n        dfs(r, c + 1, color, current_object)\n        dfs(r, c - 1, color, current_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited:\n                current_object = []\n                dfs(r, c, grid[r][c], current_object)\n                if current_object:\n                    objects.append((grid[r][c], current_object))\n    return objects\n\ndef find_l_object(objects):\n    \"\"\"Finds the L-shaped object (color 0, three pixels, correct neighbor counts).\"\"\"\n    for color, obj in objects:\n        if color == 0 and len(obj) == 3:\n            neighbors = 0\n            neighbor_counts = {}\n            for r, c in obj:\n                neighbor_counts[(r,c)] = 0\n\n            for r, c in obj:\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if (nr, nc) in obj:\n                        neighbor_counts[(r,c)] += 1\n\n            one_neighbor_count = 0\n            two_neighbor_count = 0\n            for count in neighbor_counts.values():\n                if count == 1:\n                    one_neighbor_count += 1\n                elif count == 2:\n                    two_neighbor_count += 1\n\n            if one_neighbor_count == 2 and two_neighbor_count == 1:\n                return obj\n    return None\n\ndef get_neighbors(grid, r, c):\n    \"\"\"Gets the neighbors of a cell, including diagonals.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\n\ndef find_enclosed_object(grid, objects, l_object):\n    \"\"\"Finds the object enclosed by the L-shaped object. Considers direct adjacency to L.\"\"\"\n    if not l_object:\n        return None, None\n\n    for color, obj in objects:\n        if color == 0:  # Skip the L-object itself\n            continue\n\n        enclosed = False\n        for r, c in obj:\n            neighbors = get_neighbors(grid, r, c)\n            for nr, nc in neighbors:\n                if (nr, nc) in l_object:\n                    enclosed = True  # At least one neighbor is part of L\n                    break\n            if enclosed: # if one pixel of the object is next to l, the whole object is enclosed\n                break\n\n        if enclosed:\n            return color, obj\n\n    return None, None\n\n\ndef determine_orientation(l_object):\n    \"\"\"Determines the orientation of the L shape.\"\"\"\n    rows, cols = zip(*l_object)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Count pixels in each row and column of the bounding box\n    row_counts = [0] * (max_r - min_r + 1)\n    col_counts = [0] * (max_c - min_c + 1)\n\n    for r, c in l_object:\n      row_counts[r - min_r] += 1\n      col_counts[c - min_c] += 1\n\n    # Determine orientation based on counts:\n    if row_counts[0] > 0 and row_counts[-1] == 0 and col_counts[0] > 0 and col_counts[-1] == 0:\n        return \"top-left\" #standard L\n    elif row_counts[0] > 0 and row_counts[-1] == 0 and col_counts[0] == 0 and col_counts[-1] > 0:\n        return \"top-right\" # reverse L\n    elif row_counts[0] == 0 and row_counts[-1] > 0 and col_counts[0] > 0 and col_counts[-1] == 0:\n         return \"bottom-left\" # flipped\n    else:\n        return 'bottom-right'\n\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the rules.\"\"\"\n\n    grid = np.array(input_grid)\n\n    # 1. Object Identification\n    objects = find_objects(grid)\n    l_object = find_l_object(objects)\n    enclosed_color, enclosed_object = find_enclosed_object(grid, objects, l_object)\n\n    # If no enclosed object, return all zeros (as per instructions, if this happens)\n    if enclosed_color is None:\n      return [[0,0,0],[0,0,0],[0,0,0]]\n\n    # 2. Output Construction\n    output_grid = np.full((3, 3), enclosed_color)\n\n    # 3. Overlay \"L\" Shape\n    orientation = determine_orientation(l_object)\n\n    if orientation == \"top-left\":\n        output_grid[0, 0] = 0\n        output_grid[1, 0] = 0\n        output_grid[0, 1] = 0\n    elif orientation == \"top-right\":\n        output_grid[0, 2] = 0\n        output_grid[0, 1] = 0\n        output_grid[1, 2] = 0\n    elif orientation == \"bottom-left\":\n        output_grid[2, 0] = 0\n        output_grid[1, 0] = 0\n        output_grid[2, 1] = 0\n    elif orientation == \"bottom-right\":\n        output_grid[2, 2] = 0\n        output_grid[2, 1] = 0\n        output_grid[1, 2] = 0\n\n    return output_grid.tolist()\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11258,
    "candidates_token_count": 1832,
    "total_token_count": 13090,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.882907
}