{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid based on blue/green shapes and a yellow marker.\n\n1.  Initialize the output grid with the same dimensions as the input, filled with azure (8).\n2.  Identify all distinct contiguous shapes composed of blue (1) or green (3) pixels using 8-way connectivity. Let N be the number of shapes found. Calculate the bounding box for each shape.\n3.  Locate the single yellow (4) marker pixel at position (mr, mc).\n4.  Calculate the minimum Manhattan distance (min_dist) from the marker's position (mr, mc) to any pixel location covered by any of the shapes' bounding boxes.\n5.  Apply rules based on the number of shapes (N):\n    *   If N > 1:\n        *   Fill the bounding box of every blue/green shape with red (2).\n        *   Fill the entire column mc (the marker's column) with red (2), overwriting previous fills.\n    *   If N == 1:\n        *   Check the marker's proximity:\n            *   If min_dist <= 2:\n                *   Calculate the centroid (average row, average column) of the single shape's pixels. Determine the centroid's column index cc (floor of the average column value).\n                *   Fill the shape's bounding box with red (2).\n                *   Fill the entire column cc (the centroid's column index) with red (2), overwriting previous fills.\n            *   If min_dist > 2:\n                *   Fill only the single pixel at the marker's original position (mr, mc) with red (2).\n6.  Return the final output grid.\n\"\"\"\n\ndef find_shapes_and_bboxes(input_grid_np, shape_colors):\n    \"\"\"\n    Identifies contiguous shapes of specified colors using 8-way connectivity\n    and calculates their bounding boxes and pixel coordinates.\n\n    Args:\n        input_grid_np (np.array): The input grid.\n        shape_colors (list): List of colors that constitute shapes.\n\n    Returns:\n        tuple: (list_of_shapes, num_shapes)\n            list_of_shapes: A list where each element is a dict:\n                            {'pixels': set((r, c), ...), 'bbox': (rmin, rmax, cmin, cmax)}\n            num_shapes: The total number of distinct shapes found.\n    \"\"\"\n    rows, cols = input_grid_np.shape\n    shape_mask = np.isin(input_grid_np, shape_colors)\n    labeled_grid = np.zeros_like(input_grid_np, dtype=int)\n    visited = np.zeros_like(shape_mask, dtype=bool)\n    current_label = 0\n    shapes = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if shape_mask[r, c] and not visited[r, c]:\n                current_label += 1\n                component_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                while q:\n                    row, col = q.pop(0) # Use queue for BFS-like exploration\n                    labeled_grid[row, col] = current_label\n                    component_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               shape_mask[nr, nc] and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                shapes.append({\n                    'pixels': component_pixels,\n                    'bbox': (min_r, max_r, min_c, max_c) # inclusive max\n                })\n\n    return shapes, current_label\n\ndef calculate_min_manhattan_dist(marker_pos, shapes):\n    \"\"\"\n    Calculates the minimum Manhattan distance from the marker position\n    to any point within any of the shapes' bounding boxes.\n\n    Args:\n        marker_pos (tuple): (row, col) of the marker.\n        shapes (list): List of shape dictionaries, each with a 'bbox'.\n\n    Returns:\n        float: Minimum Manhattan distance, or infinity if no shapes.\n    \"\"\"\n    if not shapes:\n        return float('inf')\n        \n    mr, mc = marker_pos\n    min_dist = float('inf')\n\n    for shape in shapes:\n        rmin, rmax, cmin, cmax = shape['bbox']\n        \n        # Find the closest point (pr, pc) in the bbox rectangle to (mr, mc)\n        pr = max(rmin, min(mr, rmax))\n        pc = max(cmin, min(mc, cmax))\n        \n        # Calculate Manhattan distance to this closest point\n        dist = abs(mr - pr) + abs(mc - pc)\n        min_dist = min(min_dist, dist)\n        \n    return min_dist\n\ndef calculate_centroid_column(pixels):\n    \"\"\"\n    Calculates the floor of the average column index for a set of pixels.\n\n    Args:\n        pixels (set): Set of (row, col) tuples.\n\n    Returns:\n        int: The floor of the average column index, or -1 if no pixels.\n    \"\"\"\n    if not pixels:\n        return -1\n    \n    avg_c = sum(c for r, c in pixels) / len(pixels)\n    return math.floor(avg_c)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on shapes, marker, and distance.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    background_color = 8\n    fill_color = 2\n    shape_colors = [1, 3] # blue, green\n    marker_color = 4 # yellow\n\n    # 1. Initialize output_grid with background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 2. Identify shapes and their properties\n    shapes, num_shapes = find_shapes_and_bboxes(input_grid_np, shape_colors)\n\n    # 3. Locate the marker\n    marker_coords = np.argwhere(input_grid_np == marker_color)\n    if marker_coords.size == 0:\n        # If no marker, maybe return background? Or handle as error?\n        # Based on examples, marker is always present. Assume it exists.\n        # If it *could* be absent, rules need clarification.\n        # Let's proceed assuming it's found.\n        print(\"Warning: Marker not found!\") # Or raise error\n        return output_grid.tolist() # Return background for now\n\n    marker_pos = tuple(marker_coords[0]) # (mr, mc)\n    mr, mc = marker_pos\n\n    # Handle N=0 case explicitly if needed (though not seen in examples)\n    if num_shapes == 0:\n         # Rule unclear for N=0. Maybe fill marker pos? Or just background?\n         # Let's stick to background as safest default.\n         # output_grid[mr, mc] = fill_color # Alternative: fill marker pos\n         return output_grid.tolist()\n\n\n    # 4. Calculate minimum distance from marker to any shape bbox\n    min_dist = calculate_min_manhattan_dist(marker_pos, shapes)\n\n    # 5. Apply rules based on number of shapes (N)\n    if num_shapes > 1:\n        # 5a. N > 1: Fill all bboxes + marker column\n        for shape in shapes:\n            rmin, rmax, cmin, cmax = shape['bbox']\n            output_grid[rmin:rmax+1, cmin:cmax+1] = fill_color\n        output_grid[:, mc] = fill_color # Overwrite column mc\n        \n    elif num_shapes == 1:\n        # 5b. N == 1: Check distance\n        single_shape = shapes[0]\n        \n        if min_dist <= 2:\n            # Marker \"close\": Fill bbox + centroid column\n            rmin, rmax, cmin, cmax = single_shape['bbox']\n            cc = calculate_centroid_column(single_shape['pixels'])\n            \n            if cc != -1: # Ensure centroid column is valid\n               output_grid[rmin:rmax+1, cmin:cmax+1] = fill_color\n               output_grid[:, cc] = fill_color # Overwrite column cc\n            else:\n                 # Should not happen if num_shapes == 1\n                 print(\"Warning: Could not calculate centroid column for single shape.\")\n        \n        else: # min_dist > 2\n            # Marker \"distant\": Fill only marker position\n            output_grid[mr, mc] = fill_color\n\n    # 6. Return the modified output grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16942,
    "candidates_token_count": 2233,
    "total_token_count": 19175,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.743653
}