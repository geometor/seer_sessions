{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies the background color, two main non-background objects. One object is a 'pattern tile' (a solid rectangle of potentially multiple colors). The other is a 'control object'. The dimensions of the control object's bounding box determine how many times the pattern tile is repeated horizontally and vertically to form the output grid.\n\n1. Identify Background: Find the most frequent color in the input grid.\n2. Find Non-Background Objects: Locate all contiguous groups of pixels that are not the background color. Objects can consist of multiple colors.\n3. Isolate Pattern Tile and Control Object:\n    - Iterate through the found objects.\n    - Identify the object whose pixels perfectly fill its rectangular bounding box as the 'pattern_tile'. Extract this tile's pixel data and dimensions (ph, pw).\n    - Identify the other significant object as the 'control_object'.\n4. Determine Control Dimensions: Calculate the height (ch) and width (cw) of the bounding box of the 'control_object'.\n5. Construct Output Grid: Create a new grid with dimensions (ch * ph) rows by (cw * pw) columns.\n6. Tile Pattern: Fill the new grid by repeating the 'pattern_tile' ch times vertically and cw times horizontally.\n7. Return Output: The fully tiled grid is the final output.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds contiguous objects of non-background colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (a set of (r, c) tuples) and 'bbox'\n              (a tuple of min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                # Start BFS for a new object\n                current_object_coords = set()\n                q = [(r, c)]\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    current_object_coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != background_color and \\\n                           (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if current_object_coords:\n                    objects.append({\n                        'coords': current_object_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying a pattern tile and a control object,\n    then tiling the pattern according to the control object's bounding box dimensions.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify Background Color\n    color_counts = Counter(grid.flatten())\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Find Non-Background Objects\n    objects = find_objects(grid, background_color)\n\n    if len(objects) < 2:\n         # Handle cases where fewer than 2 objects are found (though examples suggest 2)\n         # Maybe return input or an empty grid, depending on desired behavior for invalid inputs.\n         # For now, let's assume the structure holds based on examples.\n         print(\"Warning: Expected at least two non-background objects.\")\n         # Returning original grid might be safer if structure is unexpected\n         return input_grid \n\n    # 3. Isolate Pattern Tile and Control Object\n    pattern_tile_obj = None\n    pattern_tile_data = None\n    control_obj = None\n\n    for obj in objects:\n        min_r, min_c, max_r, max_c = obj['bbox']\n        bbox_h = max_r - min_r + 1\n        bbox_w = max_c - min_c + 1\n        \n        # Check if the object perfectly fills its bounding box\n        is_solid_rect = True\n        if len(obj['coords']) != bbox_h * bbox_w:\n            is_solid_rect = False\n        else:\n            # Double check: ensure all cells within bbox *that are part of the object* match the coords\n            # (This check is slightly redundant if len matches area, but good for clarity)\n            count_in_bbox = 0\n            for r_idx in range(min_r, max_r + 1):\n                for c_idx in range(min_c, max_c + 1):\n                    if (r_idx, c_idx) in obj['coords']:\n                       count_in_bbox += 1\n            if count_in_bbox != len(obj['coords']): # Should not happen if length check passed\n                is_solid_rect = False\n\n\n        if is_solid_rect:\n            pattern_tile_obj = obj\n            # Extract the pattern tile data from the original grid\n            pattern_tile_data = grid[min_r:max_r+1, min_c:max_c+1]\n            break # Assume only one solid rectangular pattern tile\n\n    # Find the control object (the one that is NOT the pattern tile)\n    # This assumes exactly two significant objects are found.\n    # More robust logic might be needed for other cases (e.g., largest non-pattern object).\n    found_control = False\n    for obj in objects:\n        if obj != pattern_tile_obj: # Check object identity, not content\n            control_obj = obj\n            found_control = True\n            break\n\n    if pattern_tile_obj is None or not found_control:\n        print(\"Error: Could not identify both pattern tile and control object.\")\n        return input_grid # Return original on failure\n\n    # 4. Determine Control Dimensions\n    c_min_r, c_min_c, c_max_r, c_max_c = control_obj['bbox']\n    ch = c_max_r - c_min_r + 1\n    cw = c_max_c - c_min_c + 1\n\n    # Get pattern tile dimensions\n    ph, pw = pattern_tile_data.shape\n\n    # 5. Construct Output Grid\n    output_height = ch * ph\n    output_width = cw * pw\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # 6. Tile Pattern\n    # Use numpy's tile function for efficient repetition\n    # np.tile repeats the array. We need to tile it ch times vertically and cw times horizontally.\n    output_grid = np.tile(pattern_tile_data, (ch, cw))\n\n    # 7. Return Output (convert back to list of lists)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4101,
    "candidates_token_count": 1819,
    "total_token_count": 5920,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.696671
}