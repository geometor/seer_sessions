{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on identifying two structures: a pattern tile and a control object.\n1. Identifies the background color (most frequent).\n2. Partitions non-background colors into two sets corresponding to the two structures.\n   Uses a heuristic: finds the partition ({c} vs {rest}) where one structure's\n   bounding box contains the fewest background pixels compared to other such partitions.\n3. Calculates bounding boxes for both structures.\n4. Identifies the Pattern Structure (min background pixels in bbox) and Control Structure.\n5. Extracts the Pattern Tile (subgrid matching Pattern Structure's bbox).\n6. Determines Control Dimensions (height/width of Control Structure's bbox).\n7. Creates the output by tiling the Pattern Tile according to Control Dimensions.\n\"\"\"\n\ndef get_bbox(coords):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c), height, and width for a set of coordinates.\"\"\"\n    if not coords:\n        return None, 0, 0\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    bbox = (min_r, min_c, max_r, max_c)\n    h = max_r - min_r + 1\n    w = max_c - min_c + 1\n    return bbox, h, w\n\ndef count_bg_in_bbox(grid, bbox, background_color):\n    \"\"\"Counts background pixels within a given bounding box.\"\"\"\n    if not bbox:\n        # Return infinity if no bbox, ensures it won't be chosen as the minimum background count\n        return float('inf') \n    min_r, min_c, max_r, max_c = bbox\n    count = 0\n    rows, cols = grid.shape\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Ensure coordinates are within grid bounds before checking color\n            if 0 <= r < rows and 0 <= c < cols:\n                 if grid[r, c] == background_color:\n                    count += 1\n    return count\n\ndef find_coords_for_colors(grid, colors):\n    \"\"\"Finds all (r, c) coordinates in the grid matching the given set of colors.\"\"\"\n    rows, cols = grid.shape\n    coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in colors:\n                coords.add((r, c))\n    return coords\n\ndef partition_colors(grid, background_color):\n    \"\"\"\n    Partitions non-background colors into two sets based on a heuristic.\n    Heuristic: Try partitions of {c} vs {rest}. Choose the partition where\n    one set's bounding box (the potential pattern) has the absolute minimum \n    background count compared to the minimum background counts found in \n    all other potential ({c} vs {rest}) partitions.\n\n    Returns:\n        tuple: (set1, set2) representing the two color partitions, or (None, None) if failed.\n    \"\"\"\n    rows, cols = grid.shape\n    all_colors = set(grid.flatten())\n    non_bg_colors = sorted(list(all_colors - {background_color}))\n\n    if len(non_bg_colors) < 2:\n        # Needs at least two distinct non-bg colors for partitioning\n        return None, None \n\n    # If exactly two non-bg colors, the partition is trivial and likely correct\n    if len(non_bg_colors) == 2:\n         return {non_bg_colors[0]}, {non_bg_colors[1]}\n\n    best_partition = None\n    # Initialize with infinity to ensure the first valid partition sets the baseline\n    min_bg_found_across_partitions = float('inf') \n\n    # Iterate through partitions of the type {c} vs {rest}\n    for c1 in non_bg_colors:\n        set1 = {c1}\n        set2 = set(non_bg_colors) - set1\n\n        # Should not happen with len(non_bg_colors) >= 2, but safe check\n        if not set2: continue \n\n        # Find coordinates for each set in the current partition\n        coords1 = find_coords_for_colors(grid, set1)\n        coords2 = find_coords_for_colors(grid, set2)\n\n        # Both sets must correspond to actual pixels in the grid\n        if not coords1 or not coords2: continue \n\n        # Calculate bounding boxes for both sets\n        bbox1, _, _ = get_bbox(coords1)\n        bbox2, _, _ = get_bbox(coords2)\n\n        # Both sets must have valid bounding boxes\n        if not bbox1 or not bbox2: continue \n\n        # Count background pixels within each bounding box\n        bg_in_bbox1 = count_bg_in_bbox(grid, bbox1, background_color)\n        bg_in_bbox2 = count_bg_in_bbox(grid, bbox2, background_color)\n\n        # Determine the minimum background count *within this specific partition*\n        current_partition_min_bg = min(bg_in_bbox1, bg_in_bbox2)\n\n        # Check if the minimum background count for this partition is the\n        # smallest minimum found so far across all tested partitions.\n        if current_partition_min_bg < min_bg_found_across_partitions:\n            min_bg_found_across_partitions = current_partition_min_bg\n            best_partition = (set1, set2)\n        # Tie-breaking: If current_partition_min_bg == min_bg_found_across_partitions,\n        # we could add more heuristics (e.g., prefer partition with larger bg count difference,\n        # prefer smaller pattern area, etc.), but for now, we keep the first one found.\n\n    # Return the best partition found based on the minimum background count heuristic\n    if best_partition:\n        return best_partition\n    else:\n        # If no valid partition was found (e.g., always failed bbox/coords checks)\n        return None, None\n\n\ndef transform(input_grid):\n    # Convert input list of lists to a NumPy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # Handle empty or invalid input grid\n    if grid.size == 0:\n        return [] \n\n    # --- Step 1: Identify Background Color ---\n    color_counts = Counter(grid.flatten())\n    # Check if grid has any elements\n    if not color_counts:\n        print(\"Warning: Input grid seems empty or invalid.\")\n        return input_grid # Return original grid if counter is empty\n    # Background is the most frequent color\n    background_color = color_counts.most_common(1)[0][0]\n\n    # --- Step 2: Partition Non-Background Colors ---\n    color_set1, color_set2 = partition_colors(grid, background_color)\n\n    # Check if partitioning was successful\n    if color_set1 is None or color_set2 is None:\n        print(\"Error: Could not determine color partition for structures. Returning input.\")\n        return input_grid \n\n    # --- Step 3: Define Structures (Find Coords and BBoxes) ---\n    coords1 = find_coords_for_colors(grid, color_set1)\n    coords2 = find_coords_for_colors(grid, color_set2)\n\n    # Ensure both sets actually correspond to pixels\n    if not coords1 or not coords2:\n         print(\"Error: One or both color sets have no corresponding pixels. Returning input.\")\n         return input_grid\n\n    # Calculate bounding boxes and dimensions for both structures\n    bbox1, h1, w1 = get_bbox(coords1)\n    bbox2, h2, w2 = get_bbox(coords2)\n\n    # Ensure bounding boxes could be calculated\n    if not bbox1 or not bbox2:\n        print(\"Error: Could not calculate bounding box for both structures. Returning input.\")\n        return input_grid\n\n    # --- Step 4: Identify Pattern and Control Structures ---\n    # Count background pixels within each structure's bounding box\n    bg_in_bbox1 = count_bg_in_bbox(grid, bbox1, background_color)\n    bg_in_bbox2 = count_bg_in_bbox(grid, bbox2, background_color)\n\n    # The structure whose bounding box contains fewer (or equal) background pixels is the Pattern\n    # The other is the Control\n    if bg_in_bbox1 <= bg_in_bbox2:\n        pattern_bbox, pattern_h, pattern_w = bbox1, h1, w1\n        control_bbox, control_h, control_w = bbox2, h2, w2\n    else:\n        pattern_bbox, pattern_h, pattern_w = bbox2, h2, w2\n        control_bbox, control_h, control_w = bbox1, h1, w1\n\n    # --- Sanity Check Dimensions ---\n    # Ensure no zero dimensions which would lead to errors or empty output\n    if pattern_h <= 0 or pattern_w <= 0 or control_h <= 0 or control_w <= 0:\n        print(f\"Error: Invalid dimensions detected. Pattern (h,w):({pattern_h},{pattern_w}), Control (h,w):({control_h},{control_w}). Returning input.\")\n        return input_grid\n\n    # --- Step 5: Extract Pattern Tile ---\n    # Get the coordinates of the pattern's bounding box\n    p_min_r, p_min_c, p_max_r, p_max_c = pattern_bbox\n    # Extract the rectangular subgrid corresponding to the pattern bbox\n    # NumPy slicing is [start_row:end_row+1, start_col:end_col+1]\n    pattern_tile_data = grid[p_min_r : p_max_r + 1, p_min_c : p_max_c + 1]\n    \n    # Verify extracted tile shape matches calculated pattern dimensions\n    if pattern_tile_data.shape != (pattern_h, pattern_w):\n         print(f\"Warning: Extracted pattern tile shape {pattern_tile_data.shape} differs from calculated bbox dimensions ({pattern_h}, {pattern_w}). Using actual extracted shape.\")\n         pattern_h, pattern_w = pattern_tile_data.shape\n         # Re-check dimensions after update\n         if pattern_h <= 0 or pattern_w <= 0:\n             print(f\"Error: Pattern tile has zero dimension after extraction. Returning input.\")\n             return input_grid\n\n\n    # --- Step 6: Get Control Dimensions ---\n    # control_h and control_w are already determined\n\n    # --- Step 7: Construct Output Grid via Tiling ---\n    try:\n        # Use NumPy's tile function to repeat the pattern tile\n        # It repeats the array `control_h` times vertically and `control_w` times horizontally\n        output_grid = np.tile(pattern_tile_data, (control_h, control_w))\n    except ValueError as e:\n        # Catch potential errors during tiling (e.g., if dimensions somehow became invalid)\n        print(f\"Error during np.tile: {e}\")\n        print(f\"Pattern Tile Shape: {pattern_tile_data.shape}\")\n        print(f\"Tiling Factors (ch, cw): ({control_h}, {control_w})\")\n        return input_grid # Return original grid on tiling failure\n\n    # --- Step 8: Return Output ---\n    # Convert the final NumPy array back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13335,
    "candidates_token_count": 2759,
    "total_token_count": 16094,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.128907
}