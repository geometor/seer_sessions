{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent) and foreground color (second most frequent) in the input grid.\n2. Find all contiguous objects composed of the foreground color pixels (using 8-way connectivity).\n3. For each foreground object, determine its minimal bounding box (MBB).\n4. Count the number of background-colored pixels within the MBB of each foreground object in the original input grid.\n5. Select the target object: the foreground object whose MBB contains the *largest* number of background-colored pixels. If there's a tie, select the largest object (by pixel count) among the tied objects.\n6. Determine the minimal bounding box enclosing only the pixels of the selected target object.\n7. Create an output grid whose dimensions are 2 larger (in height and width) than the bounding box of the target object.\n8. Initialize the output grid with the background color.\n9. Draw a 1-pixel thick border around the output grid using the foreground color.\n10. Copy only the pixels belonging to the target object into the center of the output grid (inside the border), placed relative to the object's bounding box. The color copied is the foreground color. Pixels within the central area that do not correspond to a pixel from the target object remain the background color.\n\"\"\"\n\ndef find_colors(grid):\n    \"\"\"\n    Finds the background (most frequent) and foreground (typically the second most frequent) colors.\n    Handles cases with only one color.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    \n    if len(colors) == 1:\n        return colors[0], None # Only one color present\n    \n    # Sort colors by frequency in descending order\n    sorted_indices = np.argsort(-counts)\n    background_color = colors[sorted_indices[0]]\n    \n    # Find the first color that is not the background color\n    foreground_color = None\n    for i in range(1, len(sorted_indices)):\n        if colors[sorted_indices[i]] != background_color:\n             foreground_color = colors[sorted_indices[i]]\n             break\n        # If all remaining colors are the same as background (shouldn't happen if len(colors)>1)\n        # Or if only background exists, foreground remains None\n\n    # If still None (e.g., grid was [0,0,0,1]), the second most frequent is the foreground\n    if foreground_color is None and len(sorted_indices) > 1:\n        foreground_color = colors[sorted_indices[1]]\n\n    return background_color, foreground_color\n\n\ndef count_background_in_bbox(grid, bbox, background_color):\n    \"\"\"Counts background pixels within a given bounding box.\"\"\"\n    min_r, max_r, min_c, max_c = bbox\n    count = 0\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Ensure coordinates are within grid bounds (should be by definition of bbox from find_objects)\n            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:\n                if grid[r, c] == background_color:\n                    count += 1\n    return count\n\ndef find_objects(grid, target_color, background_color):\n    \"\"\"\n    Finds all contiguous objects of the target_color using Breadth-First Search (BFS)\n    with 8-way connectivity. Calculates the number of background pixels within each object's bounding box.\n    Returns a list of objects (dictionaries with pixels, bbox, size, bg_in_bbox).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if pixel is target color and not visited\n            if grid[r, c] == target_color and not visited[r, c]:\n                current_object_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.append((row, col))\n                    \n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor is target color and not visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == target_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Store the found object's details\n                if current_object_pixels:\n                    bbox = (min_r, max_r, min_c, max_c)\n                    bg_count = count_background_in_bbox(grid, bbox, background_color)\n                    \n                    objects.append({\n                        'pixels': set(current_object_pixels),\n                        'min_row': min_r, 'max_row': max_r,\n                        'min_col': min_c, 'max_col': max_c,\n                        'size': len(current_object_pixels),\n                        'bg_in_bbox': bg_count # Store the background count\n                    })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Handle empty/invalid input grids\n    if input_np.size == 0: return []\n    if input_np.shape[0] == 0 or input_np.shape[1] == 0: return [[]] \n\n    # 1. Identify Background and Foreground Colors\n    background_color, foreground_color = find_colors(input_np)\n\n    # Handle edge case: Only one color in the grid\n    if foreground_color is None:\n        single_color = background_color\n        # Return a 3x3 grid with the single color as border and center\n        # Based on observation, might need adjustment, but plausible default.\n        output_grid = np.full((3, 3), single_color, dtype=int)\n        return output_grid.tolist()\n\n    # 2. Find all contiguous objects of the foreground color and count bg pixels in their bbox\n    objects = find_objects(input_np, foreground_color, background_color)\n\n    # Handle edge case: No foreground objects found\n    if not objects:\n        # Return a minimal 3x3 grid: foreground border, background center.\n        output_grid = np.full((3, 3), background_color, dtype=int)\n        output_grid[0, :] = foreground_color\n        output_grid[-1, :] = foreground_color\n        output_grid[:, 0] = foreground_color\n        output_grid[:, -1] = foreground_color\n        return output_grid.tolist()\n\n    # 3-5. Select the target object based on max background pixels in bbox, tie-break with size\n    \n    # Find the maximum background count\n    max_bg_count = -1\n    for obj in objects:\n        if obj['bg_in_bbox'] > max_bg_count:\n            max_bg_count = obj['bg_in_bbox']\n            \n    # Filter objects that have the maximum background count\n    candidate_objects = [obj for obj in objects if obj['bg_in_bbox'] == max_bg_count]\n    \n    # Select the largest object among candidates (tie-breaker)\n    if not candidate_objects: # Should not happen if objects list is not empty\n         return [] # Or raise error\n    \n    target_object = max(candidate_objects, key=lambda obj: obj['size'])\n\n\n    # 6. Determine the bounding box coordinates of the target object\n    min_row, max_row = target_object['min_row'], target_object['max_row']\n    min_col, max_col = target_object['min_col'], target_object['max_col']\n    object_pixels = target_object['pixels'] # Set of (r, c) tuples\n\n    # Calculate bounding box dimensions and output grid dimensions\n    bbox_h = max_row - min_row + 1\n    bbox_w = max_col - min_col + 1\n    output_h = bbox_h + 2 # Add 2 for the border\n    output_w = bbox_w + 2 # Add 2 for the border\n\n    # 7. Create the OutputGrid initialized with the BackgroundColor\n    output_grid = np.full((output_h, output_w), background_color, dtype=int)\n\n    # 8. Draw the 1-pixel border using the ForegroundColor\n    output_grid[0, :] = foreground_color  # Top row\n    output_grid[-1, :] = foreground_color # Bottom row\n    output_grid[:, 0] = foreground_color  # Left column\n    output_grid[:, -1] = foreground_color # Right column\n\n    # 9. Copy the pixels belonging to the target object into the OutputGrid's inner area\n    for r_in, c_in in object_pixels:\n        # Calculate the corresponding position within the output grid's central area\n        # Offset by 1 due to the border\n        r_out = (r_in - min_row) + 1\n        c_out = (c_in - min_col) + 1\n        \n        # Place the foreground color at the calculated position\n        # Basic bounds check (should always be true given calculation)\n        if 1 <= r_out < output_h - 1 and 1 <= c_out < output_w - 1:\n             output_grid[r_out, c_out] = foreground_color\n\n    # Return the final grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8527,
    "candidates_token_count": 2458,
    "total_token_count": 10985,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 92.452487
}