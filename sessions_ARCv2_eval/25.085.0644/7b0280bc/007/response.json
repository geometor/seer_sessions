{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Determine Context:** Identify the `background_color` from the top-left pixel. Based on this, determine the `trigger_color`: Azure(8)->White(0), Maroon(9)->Yellow(4), Orange(7)->Magenta(6).\n2.  **Identify Regions:**\n    *   `outside_region`: Flood fill (4-way) from border `background_color` pixels to find all reachable `background_color` pixels.\n    *   `inside_region`: All pixels not `background_color` and not in `outside_region`.\n3.  **Find Objects and Triggers:**\n    *   `inside_objects`: Contiguous groups (4-way) of same-colored pixels in the `inside_region`. Note color, coordinates, and shape (line/dot or 2x2 square).\n    *   `trigger_pixels`: Coordinates of all pixels with the `trigger_color`.\n4.  **Apply Transformation:**\n    *   Iterate through each `inside_object`.\n    *   Check if the object's color/shape matches transformation rules for the `background_color`:\n        *   BG=8: White(0) line/dot -> Gray(5); Red(2) 2x2 -> Green(3).\n        *   BG=9: Yellow(4) line/dot -> Gray(5); Orange(7) 2x2 -> Green(3).\n        *   BG=7: Magenta(6) line/dot -> Gray(5); Blue(1) 2x2 -> Green(3).\n    *   If applicable, check if any pixel of the object is adjacent (8-way) to a `trigger_pixel`, AND if at least one such adjacent `trigger_pixel` is itself adjacent (4-way) to a pixel in the `outside_region`.\n    *   If both conditions are met, change the color of all pixels of the object in the output grid according to the rule.\n5.  Return the modified grid.\n\"\"\"\n\nimport collections\nimport copy\n\ndef _find_outside_pixels(grid, bg_color):\n    \"\"\"Performs flood fill from borders to mark outside background pixels.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    is_outside = [[False for _ in range(cols)] for _ in range(rows)]\n    q = collections.deque()\n\n    # Seed queue with border background pixels (4-directional adjacency check)\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if not is_outside[r][c] and grid[r][c] == bg_color:\n                is_outside[r][c] = True\n                q.append((r, c))\n    for c in range(1, cols - 1):\n        for r in [0, rows - 1]:\n            if not is_outside[r][c] and grid[r][c] == bg_color:\n                is_outside[r][c] = True\n                q.append((r, c))\n\n    # Flood fill (4-directional)\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               not is_outside[nr][nc] and grid[nr][nc] == bg_color:\n                is_outside[nr][nc] = True\n                q.append((nr, nc))\n    return is_outside\n\ndef _find_inside_objects(grid, bg_color, is_outside):\n    \"\"\"Finds all contiguous objects within the 'inside' region.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    # Mark all background and outside pixels as visited initially\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == bg_color or is_outside[r][c]:\n                 visited[r][c] = True\n\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            # If not visited -> potential start of an inside object\n            if not visited[r][c]:\n                obj_color = grid[r][c]\n                obj_coords = set()\n                q = collections.deque([(r, c)])\n                visited[r][c] = True\n\n                # BFS to find all connected pixels of the same color (4-connectivity)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_coords.add((curr_r, curr_c))\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr][nc] and grid[nr][nc] == obj_color:\n                            visited[nr][nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                   objects.append({'color': obj_color, 'coords': obj_coords})\n\n    return objects\n\ndef _get_object_shape(obj_coords):\n    \"\"\"Determines if an object is a line/dot or a 2x2 square.\"\"\"\n    if not obj_coords:\n        return False, False\n\n    min_r = min(r for r, c in obj_coords)\n    max_r = max(r for r, c in obj_coords)\n    min_c = min(c for r, c in obj_coords)\n    max_c = max(c for r, c in obj_coords)\n\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    num_pixels = len(obj_coords)\n\n    is_line_dot = (height == 1 or width == 1)\n    is_2x2 = (height == 2 and width == 2 and num_pixels == 4)\n\n    return is_line_dot, is_2x2\n\ndef _check_adjacency_to_outside_trigger(obj_coords, trigger_pixels, is_outside, rows, cols):\n    \"\"\"\n    Checks if any pixel in obj_coords is 8-directionally adjacent to a trigger pixel,\n    AND that trigger pixel is 4-directionally adjacent to an 'outside' background pixel.\n    \"\"\"\n    # Iterate through each pixel coordinate of the object\n    for r, c in obj_coords:\n        # Check its 8 neighbors (including diagonals)\n        for dr_obj in [-1, 0, 1]:\n            for dc_obj in [-1, 0, 1]:\n                if dr_obj == 0 and dc_obj == 0:\n                    continue # Skip the pixel itself\n                nr_trig, nc_trig = r + dr_obj, c + dc_obj\n\n                # Check if the neighbor is within bounds and is a trigger pixel\n                if 0 <= nr_trig < rows and 0 <= nc_trig < cols and (nr_trig, nc_trig) in trigger_pixels:\n                    # Now check if this trigger pixel is adjacent (4-way) to an 'outside' pixel\n                    for dr_trig, dc_trig in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr_out, nc_out = nr_trig + dr_trig, nc_trig + dc_trig\n                        # Check bounds and if the neighbor is marked as 'outside'\n                        if 0 <= nr_out < rows and 0 <= nc_out < cols and is_outside[nr_out][nc_out]:\n                            return True # Found the required condition, no need to check further\n\n    return False # No object pixel met the combined adjacency condition\n\ndef transform(input_grid):\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    if rows == 0 or cols == 0:\n        return []\n\n    # 1. Initialize output grid\n    output_grid = copy.deepcopy(input_grid)\n\n    # 2. Determine background color\n    bg_color = input_grid[0][0]\n\n    # 3. Determine Trigger Color based on background\n    trigger_color = -1 # Default value if no rule matches\n    if bg_color == 8: trigger_color = 0 # white\n    elif bg_color == 9: trigger_color = 4 # yellow\n    elif bg_color == 7: trigger_color = 6 # magenta\n\n    # If no trigger color rule applies, return the original grid\n    if trigger_color == -1:\n        return output_grid\n\n    # 4. Find 'outside' background pixels\n    is_outside = _find_outside_pixels(input_grid, bg_color)\n\n    # 5. Find all 'inside' objects (not background, not outside)\n    inside_objects = _find_inside_objects(input_grid, bg_color, is_outside)\n\n    # 6. Identify all trigger pixels in the grid\n    trigger_pixels = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r][c] == trigger_color:\n                trigger_pixels.add((r, c))\n\n    # 7. Iterate through objects, check conditions, and apply transformations\n    for obj in inside_objects:\n        obj_color = obj['color']\n        obj_coords = obj['coords']\n\n        # Determine object shape\n        is_line_dot, is_2x2 = _get_object_shape(obj_coords)\n\n        # Check if this object matches transformation rules based on BG color\n        relevant_object = False\n        potential_new_color = obj_color # Default: no change\n        if bg_color == 8:  # Azure background, Trigger White(0)\n            if obj_color == 0 and is_line_dot: relevant_object = True; potential_new_color = 5  # white -> gray\n            elif obj_color == 2 and is_2x2: relevant_object = True; potential_new_color = 3  # red -> green\n        elif bg_color == 9:  # Maroon background, Trigger Yellow(4)\n            if obj_color == 4 and is_line_dot: relevant_object = True; potential_new_color = 5  # yellow -> gray\n            elif obj_color == 7 and is_2x2: relevant_object = True; potential_new_color = 3  # orange -> green\n        elif bg_color == 7:  # Orange background, Trigger Magenta(6)\n            if obj_color == 6 and is_line_dot: relevant_object = True; potential_new_color = 5  # magenta -> gray\n            elif obj_color == 1 and is_2x2: relevant_object = True; potential_new_color = 3  # blue -> green\n\n        # If the object is relevant, check the refined adjacency condition\n        if relevant_object:\n            should_transform = _check_adjacency_to_outside_trigger(obj_coords, trigger_pixels, is_outside, rows, cols)\n\n            # Apply transformation if the adjacency condition is met\n            if should_transform:\n                for r, c in obj_coords:\n                    output_grid[r][c] = potential_new_color\n\n    # 8. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11718,
    "candidates_token_count": 2728,
    "total_token_count": 14446,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.632867
}