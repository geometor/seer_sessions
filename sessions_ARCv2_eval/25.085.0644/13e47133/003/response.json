{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent, excluding Red=2).\n2. Identify the divider intersection point (h, v):\n    - 'v' is the index of the first complete vertical Red column.\n    - 'h' is the index of the first row where the horizontal Red segment starts at column 'v' (i.e., grid[h, v] == 2 and grid[h, v+1] == 2).\n3. Identify initiator pixels (non-background, non-Red).\n4. Create an output grid, initially a copy of the input.\n5. Perform flood fill on the output grid starting from neighbors of each initiator pixel. Fill replaces background color with initiator color, stopping at Red, other colors, or grid edges.\n6. Check if the Bottom-Left (BL) quadrant (rows >= h, cols < v) of the *input* grid contains any initiators.\n7. If the input BL quadrant has no initiators, take the Top-Left (TL) quadrant (rows < h, cols < v) of the *output* grid, flip it vertically, and paste it into the BL quadrant of the *output* grid.\n8. Return the final output grid.\n\"\"\"\n\ndef find_background_color(grid, divider_color):\n    \"\"\"Finds the most frequent color excluding the divider color.\"\"\"\n    pixels = grid[grid != divider_color]\n    if pixels.size == 0:\n        # Default to 0 if only divider color exists or grid is empty,\n        # though examples suggest a dominant background exists.\n        return 0\n    count = Counter(pixels)\n    background_color = count.most_common(1)[0][0]\n    return background_color\n\ndef find_dividing_intersection(grid, divider_color):\n    \"\"\"\n    Finds the intersection point (h, v) defined by the vertical divider\n    and the start of the horizontal divider segment.\n    'v' is the index of the first full vertical divider column.\n    'h' is the index of the first row where grid[h, v] and grid[h, v+1] are divider_color.\n    Returns (h, v) or (None, None) if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    v_idx = None\n    h_idx = None\n\n    # Find vertical divider index 'v' (first full column of divider_color)\n    for c in range(cols):\n        if np.all(grid[:, c] == divider_color):\n            v_idx = c\n            break\n\n    if v_idx is None:\n        # No full vertical divider found\n        return None, None\n\n    # Check if v_idx+1 is within bounds for horizontal check\n    if v_idx + 1 >= cols:\n        # Vertical divider is at the right edge, no horizontal segment possible from it\n        return None, v_idx # Return v_idx but None for h\n\n    # Find horizontal start row 'h'\n    for r in range(rows):\n        # Check if the cell at (r, v_idx) and the one to its right are the divider color\n        if grid[r, v_idx] == divider_color and grid[r, v_idx + 1] == divider_color:\n            h_idx = r\n            break\n\n    # h_idx might still be None if no horizontal segment starts at v_idx\n    return h_idx, v_idx\n\ndef find_initiators(grid, background_color, divider_color):\n    \"\"\"Finds coordinates and colors of initiator pixels.\"\"\"\n    initiators = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = grid[r, c]\n            if pixel_color != background_color and pixel_color != divider_color:\n                initiators.append({'row': r, 'col': c, 'color': pixel_color})\n    return initiators\n\ndef flood_fill(grid, start_r, start_c, fill_color, target_color, divider_color):\n    \"\"\"\n    Performs flood fill on grid, starting from neighbors of (start_r, start_c),\n    replacing target_color with fill_color. Stops at grid edges, divider_color,\n    or any color that is not target_color. Modifies grid in place.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque()\n    visited = set() # Tracks visited cells *for this specific fill operation*\n\n    # Seed the queue with valid neighbors of the initiator location\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = start_r + dr, start_c + dc\n        # Check bounds and if the neighbor is the target color\n        if (0 <= nr < rows and 0 <= nc < cols and\n                grid[nr, nc] == target_color):\n            # Check visited *before* adding to queue\n            if (nr, nc) not in visited:\n                q.append((nr, nc))\n                visited.add((nr, nc))\n\n    # Process the queue\n    while q:\n        r, c = q.popleft()\n\n        # Double check conditions for the current cell (r, c)\n        # Should be target_color because we only added target_color cells\n        if grid[r, c] == target_color:\n            # Fill the cell\n            grid[r, c] = fill_color\n\n            # Check neighbors (4-directional)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Add neighbor to queue if valid, is target color, and not visited\n                if (0 <= nr < rows and 0 <= nc < cols and\n                        grid[nr, nc] == target_color and\n                        (nr, nc) not in visited):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n        # If grid[r,c] is not target_color, it means another fill might have reached it first,\n        # or it's a divider/initiator - either way, stop exploring from here.\n\n\ndef check_initiators_in_region(grid, r_start, r_end, c_start, c_end, background_color, divider_color):\n    \"\"\"Checks if any initiator pixels exist within the specified region [r_start:r_end, c_start:c_end].\"\"\"\n    # Ensure bounds are valid before slicing/iterating\n    r_end = min(r_end, grid.shape[0])\n    c_end = min(c_end, grid.shape[1])\n    r_start = max(r_start, 0)\n    c_start = max(c_start, 0)\n\n    if r_start >= r_end or c_start >= c_end:\n        return False # Region is empty\n\n    region = grid[r_start:r_end, c_start:c_end]\n    \n    # Check if any pixel in the region is neither background nor divider\n    for r in range(region.shape[0]):\n        for c in range(region.shape[1]):\n            if region[r, c] != background_color and region[r, c] != divider_color:\n                return True # Found an initiator\n    return False # No initiators found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies flood fill from initiators and conditionally reflects the\n    top-left quadrant to the bottom-left based on initiator presence\n    in the input grid's bottom-left quadrant.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n    divider_color = 2 # Red\n\n    # --- Step 1 & 2: Identify Grid Elements & Intersection ---\n    background_color = find_background_color(input_np, divider_color)\n    h_intersect, v_intersect = find_dividing_intersection(input_np, divider_color)\n\n    # Handle cases where intersection wasn't properly found (e.g., no full V divider)\n    # Based on examples, we expect h and v to be found. If not, the logic breaks down.\n    # Returning input might be safest default, but problem constraints likely guarantee intersection.\n    if h_intersect is None or v_intersect is None:\n         print(f\"Warning: Could not find valid intersection point (h={h_intersect}, v={v_intersect}). Returning copy of input.\")\n         # Or raise an error, depending on expected behavior for invalid inputs.\n         # For ARC, often best to return input copy if assumptions fail.\n         return output_np.tolist()\n\n    # --- Step 3: Identify Initiators ---\n    initiators = find_initiators(input_np, background_color, divider_color)\n\n    # --- Step 5: Perform Flood Fill ---\n    # Apply flood fill from each initiator onto the output grid\n    for init in initiators:\n        r_init, c_init, color_init = init['row'], init['col'], init['color']\n        # The flood fill modifies output_np in place\n        flood_fill(output_np, r_init, c_init, color_init, background_color, divider_color)\n\n    # --- Step 6, 7, 8, 9: Conditional Reflection ---\n    # Define Bottom-Left quadrant bounds for input grid check\n    bl_r_start, bl_r_end = h_intersect, rows\n    bl_c_start, bl_c_end = 0, v_intersect\n\n    # Check the INPUT grid's bottom-left region for initiators\n    bottom_left_has_initiators = check_initiators_in_region(\n        input_np, bl_r_start, bl_r_end, bl_c_start, bl_c_end, background_color, divider_color\n    )\n\n    if not bottom_left_has_initiators:\n        # Define Top-Left quadrant bounds for output grid extraction\n        tl_r_start, tl_r_end = 0, h_intersect\n        tl_c_start, tl_c_end = 0, v_intersect\n\n        # Check if TL region has valid dimensions before proceeding\n        if tl_r_end > tl_r_start and tl_c_end > tl_c_start:\n            # Extract the processed top-left region from the OUTPUT grid\n            top_left_region = output_np[tl_r_start:tl_r_end, tl_c_start:tl_c_end]\n\n            # Flip it vertically\n            flipped_tl_region = np.flipud(top_left_region)\n\n            # Define Bottom-Left quadrant bounds for output grid pasting\n            # (Bounds are the same as the input check region)\n\n            # Ensure dimensions match before pasting\n            target_bl_shape = (bl_r_end - bl_r_start, bl_c_end - bl_c_start)\n            if flipped_tl_region.shape == target_bl_shape:\n                # Paste the flipped region into the bottom-left of the OUTPUT grid\n                output_np[bl_r_start:bl_r_end, bl_c_start:bl_c_end] = flipped_tl_region\n            else:\n                # This case indicates an issue, maybe h_intersect or v_intersect was 0 or at boundary\n                print(f\"Warning: Shape mismatch during reflection. Flipped TL shape {flipped_tl_region.shape} vs Target BL shape {target_bl_shape}. Skipping reflection.\")\n\n    # --- Step 10: Return Result ---\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18763,
    "candidates_token_count": 2751,
    "total_token_count": 21514,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.493499
}