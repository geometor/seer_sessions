{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nApplies gravity to whole objects in the input grid.\n\nIdentifies connected objects of non-background colors (anything other than azure - 8). \nEach object falls downwards as a single unit, maintaining its shape. \nAn object stops falling when any part of its bottom edge reaches the bottom of the grid \nor lands on top of any part of another object that has already settled in the output grid. \nObjects do not move horizontally. The relative vertical order of pixels within an object \nis preserved, and the relative horizontal positions of objects are preserved.\nThe output grid is initially filled with the background color (azure - 8), and the \nobjects are drawn in their final settled positions.\n\"\"\"\n\ndef find_connected_components(grid, background_color):\n    \"\"\"\n    Finds connected components (objects) of non-background colors using 8-connectivity.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (a set of (r, c) tuples of absolute\n              coordinates), 'rel_coords' (a set of (r, c) tuples relative to the\n              bounding box top-left), and 'bbox' (min_r, min_c, max_r, max_c).\n    \"\"\"\n    mask = grid != background_color\n    # structure=np.array([[1,1,1],[1,1,1],[1,1,1]]) defines 8-connectivity (including diagonals)\n    labeled_grid, num_labels = label(mask, structure=np.array([[1,1,1],[1,1,1],[1,1,1]]))\n\n    objects = []\n    for i in range(1, num_labels + 1):\n        # Find all pixels belonging to the current label\n        obj_mask = labeled_grid == i\n        coords = set(tuple(coord) for coord in np.array(np.where(obj_mask)).T) # set of (row, col) tuples\n\n        if not coords: # Should not happen with labels > 0, but good practice\n            continue\n\n        # Get the color from the first pixel of the component (all pixels in a component have the same color)\n        first_coord = next(iter(coords))\n        obj_color = grid[first_coord]\n\n        # Calculate bounding box\n        rows, cols = zip(*coords)\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n\n        # Calculate coordinates relative to the top-left corner of the bounding box\n        rel_coords = set((r - min_r, c - min_c) for r, c in coords)\n\n        objects.append({\n            'color': obj_color,\n            'coords': coords, # Absolute coordinates in the original grid\n            'rel_coords': rel_coords, # Coordinates relative to bbox top-left\n            'bbox': (min_r, min_c, max_r, max_c) # Bounding box: top, left, bottom, right\n        })\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies gravity simulation to non-background objects in the grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the transformed grid with objects settled by gravity.\n    \"\"\"\n    background_color = 8\n    height, width = input_grid.shape\n\n    # 1. Identify all distinct non-background objects\n    objects = find_connected_components(input_grid, background_color)\n\n    # 2. Sort objects primarily by their bottom edge (max_r), then top edge (min_r).\n    # This helps in processing objects that should settle lower first.\n    objects.sort(key=lambda obj: (obj['bbox'][2], obj['bbox'][0]))\n\n    # 3. Initialize the output grid with the background color\n    output_grid = np.full((height, width), background_color, dtype=int)\n\n    # 4. Process each object to determine its final position after falling\n    for obj in objects:\n        color = obj['color']\n        rel_coords = obj['rel_coords']\n        min_r, min_c, _, _ = obj['bbox'] # Original top-left position\n\n        # Determine the maximum distance the object can fall vertically\n        fall_distance = 0\n        while True:\n            # Assume it can fall one step further\n            can_fall_further = True\n            # Calculate the potential vertical offset for the next step down\n            next_r_offset = fall_distance + 1\n\n            # Check collision for every pixel of the object at the potential new position\n            for rel_r, rel_c in rel_coords:\n                # Calculate the target row and column in the grid for this pixel\n                target_r = min_r + rel_r + next_r_offset\n                target_c = min_c + rel_c\n\n                # Check if the target row hits or exceeds the grid bottom\n                if target_r >= height:\n                    can_fall_further = False\n                    break # Collision with bottom\n\n                # Check if the target cell in the output grid is already occupied by another settled object\n                if output_grid[target_r, target_c] != background_color:\n                    can_fall_further = False\n                    break # Collision with another object\n\n            # If no collision detected for any pixel at the next step down\n            if can_fall_further:\n                fall_distance += 1 # Increment the fall distance\n            else:\n                # Collision detected or bottom reached, stop checking further fall for this object\n                break\n\n        # 5. Calculate the final top-left position of the object after falling\n        final_r = min_r + fall_distance\n        final_c = min_c # Object only moves vertically\n\n        # 6. Place the object onto the output grid at its final settled position\n        for rel_r, rel_c in rel_coords:\n            # Draw each pixel of the object using its relative coordinates and final position\n            output_grid[final_r + rel_r, final_c + rel_c] = color\n\n    # 7. Return the final grid with all objects settled\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9777,
    "candidates_token_count": 1485,
    "total_token_count": 11262,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 178.037969
}