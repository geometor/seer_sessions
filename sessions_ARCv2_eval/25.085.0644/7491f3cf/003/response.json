{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation operates on a grid divided into four zones (1-4) separated by\nvertical borders, all enclosed within a main border. The zones are assumed to be\nof equal width (5 pixels) and the separators are 1 pixel wide.\n\n1. **Identify Borders and Backgrounds**:\n   - Determine the grid's overall border color (most frequent color).\n   - Determine the background color for Zone 2, Zone 3, and Zone 4 independently.\n     The background is the most frequent color within the zone's inner area\n     (excluding the main border), ignoring the border color itself.\n\n2. **Clear Zone 4**:\n   - Set all pixels within the inner area of Zone 4 (excluding the main border)\n     to the background color determined for Zone 4.\n\n3. **Copy Pattern from Zone 2 to Zone 4**:\n   - Identify \"pattern\" pixels in Zone 2: these are pixels within the inner\n     area that are neither the border color nor Zone 2's background color.\n   - Copy these pattern pixels to the corresponding relative positions within\n     Zone 4.\n\n4. **Check for Zone 3 Modifier**:\n   - Identify pattern pixels in Zone 3 (pixels within the inner area that are\n     neither the border color nor Zone 3's background color).\n   - Check if these pattern pixels meet two conditions:\n     a) All pattern pixels are green (color 3).\n     b) They form a single, continuous horizontal line spanning the entire\n        width of Zone 3's inner area.\n\n5. **Apply Zone 3 Modifier (if applicable)**:\n   - If the conditions in step 4 are met, overlay the green horizontal line\n     pattern from Zone 3 onto Zone 4 at the corresponding relative positions.\n     These green pixels overwrite any pixels previously copied from Zone 2\n     at the same locations.\n\n6. **Output**:\n   - The resulting grid after these operations is the output.\n\"\"\"\n\n# Define constants based on observed structure\nZONE_WIDTH = 5\nZONE_SEPARATOR_WIDTH = 1\nMODIFIER_COLOR = 3  # green\n\n# Pre-calculate zone column indices for efficiency\nZONE_COLUMNS = {\n    # Zone index: list of column indices (0-based)\n    1: list(range(1, 1 + ZONE_WIDTH)),\n    2: list(range(1 + ZONE_WIDTH + ZONE_SEPARATOR_WIDTH, 1 + ZONE_WIDTH + ZONE_SEPARATOR_WIDTH + ZONE_WIDTH)),\n    3: list(range(1 + 2 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH), 1 + 2 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH) + ZONE_WIDTH)),\n    4: list(range(1 + 3 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH), 1 + 3 * (ZONE_WIDTH + ZONE_SEPARATOR_WIDTH) + ZONE_WIDTH)),\n}\n\ndef _get_border_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assuming it's the border color.\"\"\"\n    # Ensure grid is numpy array\n    grid_np = np.array(grid)\n    counts = Counter(grid_np.flatten())\n    # If grid is empty or has no colors, handle appropriately (e.g., return default or raise error)\n    if not counts:\n        # Fallback or error, depends on expected input constraints.\n        # Assuming valid ARC grid, this shouldn't happen.\n        # Let's default to 0 (black) if truly empty, though unlikely.\n        return 0 \n    return counts.most_common(1)[0][0]\n\ndef _get_zone_subgrid(grid, zone_index):\n    \"\"\"Extracts the inner part (excluding borders) of a specified zone.\"\"\"\n    grid_np = np.array(grid)\n    rows, _ = grid_np.shape\n    # Check if grid is too small to have an 'inner' part\n    if rows <= 2:\n        return np.array([[]], dtype=grid_np.dtype) # Return empty array matching dtype\n\n    cols = ZONE_COLUMNS.get(zone_index)\n    if not cols:\n         raise ValueError(f\"Invalid zone index: {zone_index}\")\n    min_col, max_col = min(cols), max(cols)\n\n    # Ensure column indices are within grid bounds\n    if max_col >= grid_np.shape[1] -1 : # Needs to be less than last col index\n         # This suggests grid structure doesn't match expected zone layout\n         # Handle gracefully, perhaps return empty or raise error depending on strictness\n         # Let's return empty for robustness\n         return np.array([[]], dtype=grid_np.dtype)\n\n\n    return grid_np[1:rows-1, min_col:max_col+1]\n\ndef _get_zone_background(grid, zone_index, border_color):\n    \"\"\"Finds the most frequent color within a zone's inner area, excluding the border color.\"\"\"\n    zone_subgrid = _get_zone_subgrid(grid, zone_index)\n    \n    # Handle case where subgrid is empty (e.g., grid height <= 2)\n    if zone_subgrid.size == 0:\n        # No inner area to analyze. Return a value that won't interfere.\n        # Returning border_color might be problematic if a pattern could be border_color.\n        # Returning -1 might be safer to indicate 'no background'.\n        # Let's reconsider: If the zone is JUST border, maybe the 'background'\n        # concept doesn't apply or should default? ARC usually uses 0 (black/white)\n        # as a common background. Let's default to 0 if no other color exists.\n        grid_np = np.array(grid)\n        if grid_np.size > 0: # If original grid wasn't empty\n            unique_colors = np.unique(grid_np)\n            if len(unique_colors) == 1 and unique_colors[0] == border_color:\n                return border_color # The whole grid is border color\n            else:\n                return 0 # Default to black/white if unsure\n        else:\n            return 0 # Default if original grid was empty\n\n    counts = Counter(zone_subgrid.flatten())\n    \n    # Remove border color count if present\n    if border_color in counts:\n        del counts[border_color]\n\n    if not counts:\n         # This means the zone's inner area only contained the border color (or was empty after removing border color)\n         # What should be the background? Often it's 0 in ARC.\n         # Let's check if 0 exists elsewhere in the subgrid *before* removing border\n         original_counts = Counter(zone_subgrid.flatten())\n         if 0 in original_counts:\n             return 0\n         else:\n             # If 0 wasn't present, and only border was, this is ambiguous.\n             # Maybe return the border color, assuming pattern won't match it.\n             # Or stick to 0 as a general default background. Let's stick to 0.\n             return 0\n             # Alternative: return border_color\n\n    # Return the most frequent *remaining* color\n    return counts.most_common(1)[0][0]\n\n\ndef _get_pattern_pixels(grid, zone_index, bg_color, border_color):\n    \"\"\"Finds relative coordinates (within zone) and colors of pattern pixels.\"\"\"\n    pattern_pixels = []\n    grid_np = np.array(grid)\n    rows, cols_total = grid_np.shape\n    zone_cols = ZONE_COLUMNS.get(zone_index)\n\n    if not zone_cols or rows <= 2: # No zone or no inner rows\n        return []\n\n    min_col, max_col = min(zone_cols), max(zone_cols)\n\n    # Check bounds to prevent errors\n    if max_col >= cols_total -1:\n        return [] # Zone definition exceeds grid boundary\n\n    for r in range(1, rows - 1):\n        for c_abs in range(min_col, max_col + 1):\n            color = grid_np[r, c_abs]\n            if color != bg_color and color != border_color:\n                # Store relative coordinates (r_rel, c_rel) and color\n                r_rel = r - 1 # Relative row index within the inner area\n                c_rel = c_abs - min_col # Relative col index within the inner area\n                pattern_pixels.append(((r_rel, c_rel), color))\n    return pattern_pixels\n\ndef _is_horizontal_line(pattern_pixels, zone_index, grid_shape):\n    \"\"\"Checks if pattern pixels form a single horizontal green line across the zone.\"\"\"\n    if not pattern_pixels:\n        return False\n\n    inner_height = grid_shape[0] - 2\n    inner_width = ZONE_WIDTH # Expected width of the inner zone area\n\n    if inner_height <= 0 or inner_width <= 0:\n        return False # Not a valid inner area\n\n    first_rel_row = pattern_pixels[0][0][0]\n    pixel_rel_cols = set()\n\n    for (r_rel, c_rel), color in pattern_pixels:\n        # Check row consistency\n        if r_rel != first_rel_row:\n            return False # Must all be on the same relative row\n        # Check color\n        if color != MODIFIER_COLOR: # Must all be the modifier color (green)\n            return False\n        # Check relative column is within expected zone width\n        if not (0 <= c_rel < inner_width):\n             return False # Outside zone bounds\n        pixel_rel_cols.add(c_rel)\n\n    # Check if all relative columns (0 to inner_width-1) are present exactly once\n    return len(pixel_rel_cols) == inner_width\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: clears Zone 4, copies Zone 2 pattern,\n    and potentially overlays Zone 3's green line pattern.\n    \"\"\"\n    grid_np = np.array(input_grid)\n    output_grid = np.copy(grid_np)\n    rows, cols = grid_np.shape\n\n    # --- 1. Identify Borders and Backgrounds ---\n    border_color = _get_border_color(grid_np)\n    # Need backgrounds for Z2, Z3 (pattern detection) and Z4 (clearing)\n    bg_z2 = _get_zone_background(grid_np, 2, border_color)\n    bg_z3 = _get_zone_background(grid_np, 3, border_color)\n    bg_z4 = _get_zone_background(grid_np, 4, border_color)\n\n    # --- 2. Clear Zone 4 ---\n    zone4_cols = ZONE_COLUMNS.get(4)\n    if zone4_cols and rows > 2: # Check if zone exists and has inner area\n        min_col4, max_col4 = min(zone4_cols), max(zone4_cols)\n        # Ensure indices are within actual grid bounds before slicing\n        if max_col4 < cols -1:\n             for r in range(1, rows - 1):\n                 for c in range(min_col4, max_col4 + 1):\n                     # Only clear if it's not already the background OR if we need to ensure it IS bg_z4\n                     # Safest is just to set it regardless\n                     output_grid[r, c] = bg_z4\n\n    # --- 3. Copy Pattern from Zone 2 to Zone 4 ---\n    z2_pattern_pixels = _get_pattern_pixels(grid_np, 2, bg_z2, border_color)\n    zone2_cols = ZONE_COLUMNS.get(2)\n\n    if zone2_cols and zone4_cols: # Check both zones exist\n        min_col2 = min(zone2_cols)\n        min_col4 = min(zone4_cols)\n        col_offset = min_col4 - min_col2\n\n        for (r_rel, c_rel), color in z2_pattern_pixels:\n            # Calculate absolute target coordinates\n            r_abs_tgt = r_rel + 1\n            c_abs_tgt = c_rel + min_col4 # Apply offset relative to Z4 start\n\n            # Check bounds before writing\n            if 1 <= r_abs_tgt < rows - 1 and min_col4 <= c_abs_tgt <= max(zone4_cols):\n                 output_grid[r_abs_tgt, c_abs_tgt] = color\n\n    # --- 4. Check for Zone 3 Modifier ---\n    z3_pattern_pixels = _get_pattern_pixels(grid_np, 3, bg_z3, border_color)\n    is_modifier = _is_horizontal_line(z3_pattern_pixels, 3, grid_np.shape)\n\n    # --- 5. Apply Zone 3 Modifier (if applicable) ---\n    if is_modifier:\n        zone3_cols = ZONE_COLUMNS.get(3)\n        if zone3_cols and zone4_cols: # Check both zones exist\n            min_col3 = min(zone3_cols)\n            min_col4 = min(zone4_cols)\n            # No need for col_offset calculation here, relative coords are sufficient\n\n            for (r_rel, c_rel), color in z3_pattern_pixels: # Color must be MODIFIER_COLOR\n                # Calculate absolute target coordinates\n                r_abs_tgt = r_rel + 1\n                c_abs_tgt = c_rel + min_col4 # Apply offset relative to Z4 start\n\n                # Check bounds before writing\n                if 1 <= r_abs_tgt < rows - 1 and min_col4 <= c_abs_tgt <= max(zone4_cols):\n                    output_grid[r_abs_tgt, c_abs_tgt] = color # Overlay green pixel\n\n    # --- 6. Output ---\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7900,
    "candidates_token_count": 3277,
    "total_token_count": 11177,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 97.612883
}