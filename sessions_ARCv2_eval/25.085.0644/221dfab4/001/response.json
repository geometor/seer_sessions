{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the unique \"key\" object which has color 4 (Yellow). Determine its horizontal column span, defined by its minimum and maximum column indices (`key_min_col`, `key_max_col`).\n2. Determine the \"target\" color. This is the color of the objects that will be processed, other than the key object and the background color. Identify the target objects, which are connected components of the target color.\n3. Determine the \"background\" color, which is the most frequent color in the grid excluding the key and target colors.\n4. Initialize the output grid as a copy of the input grid.\n5. For each distinct target object:\n    a. Find all coordinates `(r, c)` belonging to this object.\n    b. Determine the minimum and maximum row indices spanned by the object (`obj_min_row`, `obj_max_row`).\n    c. Check if *any* pixel of the object falls within the key's column span (i.e., if there exists a pixel `(r, c)` in the object such that `key_min_col <= c <= key_max_col`).\n    d. If there IS an overlap with the key column span:\n        i. The \"paint color\" is Yellow (4).\n        ii. For every row `r` from `obj_min_row` to `obj_max_row`, set the pixels in the output grid from column `key_min_col` to `key_max_col` to the paint color (Yellow).\n        iii. Pixels of the original target object that fall *outside* the key column span retain their original target color in the output. Pixels *inside* the key column span are overwritten by the Yellow paint. (Step ii handles the overwrite implicitly if the output starts as a copy).\n    e. If there is NO overlap with the key column span:\n        i. The \"paint color\" is Green (3).\n        ii. For every row `r` from `obj_min_row` to `obj_max_row`, set the pixels in the output grid from column `key_min_col` to `key_max_col` to the paint color (Green).\n        iii. All pixels of the original target object are changed to the background color in the output grid.\n6. The key object itself remains unchanged in the output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all connected components of a given color using BFS.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                \n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_colors(grid):\n    \"\"\"Identifies key, target, and background colors.\"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    key_color = 4\n    \n    # Remove key color if present\n    if key_color in color_counts:\n        del color_counts[key_color]\n        \n    if not color_counts: # Should not happen in this task based on examples\n        return key_color, None, None \n\n    # Assume background is the most frequent remaining color\n    background_color = max(color_counts, key=color_counts.get)\n    del color_counts[background_color]\n\n    # Assume target is the only remaining color (or one of them if multiple)\n    target_color = list(color_counts.keys())[0] if color_counts else None # Takes the first if multiple targets exist\n\n    return key_color, target_color, background_color\n\n\ndef transform(input_grid):\n    \"\"\"Applies the transformation rule to the input grid.\"\"\"\n    \n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.copy(input_np)\n\n    # 1. Identify key object and its column span\n    key_color, target_color, background_color = get_colors(input_np)\n    \n    if target_color is None: # No target objects to process\n        return output_grid.tolist()\n        \n    key_coords = np.argwhere(input_np == key_color)\n    if key_coords.size == 0:\n         # No key object found, maybe return input or handle error\n         # Based on the problem description, let's assume a key object always exists.\n         # If not, this part needs specific error handling.\n         # For now, return original grid if no key.\n         return output_grid.tolist()\n\n    key_min_col = np.min(key_coords[:, 1])\n    key_max_col = np.max(key_coords[:, 1])\n\n    # 2 & 6. Find target objects\n    target_objects = find_objects(input_np, target_color)\n\n    # 5. Process each target object\n    for obj_coords in target_objects:\n        if not obj_coords:\n            continue\n\n        rows = [r for r, c in obj_coords]\n        cols = [c for r, c in obj_coords]\n        \n        obj_min_row = min(rows)\n        obj_max_row = max(rows)\n\n        # 5c. Check for overlap\n        has_overlap = any(key_min_col <= c <= key_max_col for r, c in obj_coords)\n\n        if has_overlap:\n            # 5d. Overlap case: Paint Yellow\n            paint_color = 4 # Yellow\n            for r in range(obj_min_row, obj_max_row + 1):\n                for c in range(key_min_col, key_max_col + 1):\n                    output_grid[r, c] = paint_color\n            # Original pixels outside key columns retain target color (already copied)\n            # Original pixels inside key columns are overwritten above.\n            \n        else:\n            # 5e. No overlap case: Paint Green, erase original object\n            paint_color = 3 # Green\n            for r in range(obj_min_row, obj_max_row + 1):\n                for c in range(key_min_col, key_max_col + 1):\n                    output_grid[r, c] = paint_color\n            # Erase original object pixels\n            for r_orig, c_orig in obj_coords:\n                 output_grid[r_orig, c_orig] = background_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14336,
    "candidates_token_count": 1748,
    "total_token_count": 16084,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 85.086101
}