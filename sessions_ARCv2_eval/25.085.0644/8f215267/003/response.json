{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid by identifying hollow rectangles, preserving their borders, and drawing a pattern along their internal horizontal midline based on the background color's parity.\n\n1.  **Identify Background:** Determine the most frequent color (`background_color`) and its parity (`background_parity`).\n2.  **Initialize Output:** Create an output grid of the same dimensions, filled with `background_color`.\n3.  **Find Hollow Rectangles:**\n    *   Use a connected components search (like BFS) to find groups of connected, non-background pixels of the same color.\n    *   For each component, check if it forms a valid \"hollow rectangle\":\n        *   Must consist of a single color (`rectangle_color`).\n        *   Must form a single-pixel thick rectangular border.\n        *   The area strictly inside the border must contain only the `background_color` in the input grid.\n4.  **Draw Borders:** Draw the border pixels of each identified hollow rectangle onto the output grid using its `rectangle_color`.\n5.  **Apply Midline Pattern:** For each hollow rectangle with an internal area:\n    *   Calculate the row index of the horizontal midline of its *internal* area.\n    *   Identify the column indices corresponding to the *internal* area.\n    *   Iterate through these internal columns. If a column index's parity matches the `background_parity`, color the corresponding pixel on the midline row in the output grid with the `rectangle_color`.\n6.  **Return:** The modified output grid.\n\"\"\"\n\ndef _get_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle potential ties by picking the most frequent; ARC usually has clear background\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _find_connected_components(grid: np.ndarray, background_color: int) -> list:\n    \"\"\"\n    Finds connected components of non-background colors using BFS.\n    Returns a list of components, where each component is a list of (r, c) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new component\n                component_color = grid[r, c]\n                component_coords = []\n                queue = [(r, c)]\n                visited[r, c] = True\n\n                while queue:\n                    curr_r, curr_c = queue.pop(0)\n                    component_coords.append((curr_r, curr_c))\n\n                    # Check 8 neighbors (including diagonals for connectivity)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds, color match, and visited status\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and \\\n                               grid[nr, nc] == component_color:\n                                visited[nr, nc] = True\n                                queue.append((nr, nc))\n                \n                if component_coords:\n                     components.append({\"color\": component_color, \"coords\": component_coords})\n\n    return components\n\n\ndef _is_valid_hollow_rectangle(grid: np.ndarray, component_coords: list, background_color: int) -> tuple:\n    \"\"\"\n    Checks if a component defined by coords is a hollow rectangle.\n    Returns (is_valid, rect_color, bounding_box)\n    \"\"\"\n    if not component_coords:\n        return False, -1, None\n\n    rows, cols = zip(*component_coords)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    # Get the color from the first coordinate (all should be the same)\n    rect_color = grid[component_coords[0]]\n\n    # 1. Check if all component pixels lie on the bounding box edges\n    on_border = True\n    for r, c in component_coords:\n        if not (r == min_r or r == max_r or c == min_c or c == max_c):\n            on_border = False\n            break\n    if not on_border:\n        return False, -1, None\n        \n    # 2. Check if the number of pixels matches the perimeter for single thickness\n    # Perimeter = 2 * (height + width - 2) for rectangles > 1x1\n    # Perimeter = N for lines (1xN or Nx1)\n    if height > 1 and width > 1:\n        expected_perimeter_pixels = 2 * (height + width - 2)\n    else: # Handle lines\n        expected_perimeter_pixels = max(height, width)\n        \n    if len(component_coords) != expected_perimeter_pixels :\n         return False, -1, None\n\n    # 3. Check internal area (if it exists) for background color\n    has_internal_area = (height > 2 and width > 2)\n    if has_internal_area:\n        internal_slice = grid[min_r + 1:max_r, min_c + 1:max_c]\n        if not np.all(internal_slice == background_color):\n            return False, -1, None\n            \n    # If all checks pass\n    bounding_box = (min_r, min_c, max_r, max_c)\n    return True, rect_color, bounding_box\n\n\ndef transform(input_grid: list) -> list:\n    \"\"\"\n    Applies the transformation: finds hollow rectangles, copies their borders,\n    and draws a pattern on the internal midline based on background parity.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n\n    # 1. Identify Background Color and Parity\n    background_color = _get_background_color(input_array)\n    background_parity = background_color % 2 # 0 for even, 1 for odd\n\n    # 2. Initialize Output Grid\n    output_grid = np.full_like(input_array, background_color)\n\n    # 3. Find Connected Components (potential rectangles)\n    components = _find_connected_components(input_array, background_color)\n\n    # Store valid hollow rectangles found\n    hollow_rectangles = [] \n    \n    # Validate each component\n    for component in components:\n        coords = component[\"coords\"]\n        is_valid, rect_color, bbox = _is_valid_hollow_rectangle(\n            input_array, \n            coords, \n            background_color\n        )\n        \n        if is_valid:\n            hollow_rectangles.append({\n                \"color\": rect_color,\n                \"coords\": coords,\n                \"bbox\": bbox # (min_r, min_c, max_r, max_c)\n            })\n\n    # 4. Draw Rectangle Borders onto Output\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        for r, c in rect[\"coords\"]:\n            # Basic bounds check (should always be true if coords are from grid)\n            if 0 <= r < height and 0 <= c < width:\n                output_grid[r, c] = rect_color\n\n    # 5. Apply Midline Pattern\n    for rect in hollow_rectangles:\n        rect_color = rect[\"color\"]\n        min_r, min_c, max_r, max_c = rect[\"bbox\"]\n        \n        # Calculate internal dimensions\n        internal_height = max_r - min_r - 1\n        internal_width = max_c - min_c - 1\n\n        # Proceed only if there is an internal area\n        if internal_height > 0 and internal_width > 0:\n            # Calculate midline row index relative to the top of the grid\n            # Add min_r + 1 (start of internal area) to the relative midline index\n            midline_row = min_r + 1 + (internal_height // 2) \n\n            # Iterate through internal column indices\n            start_col = min_c + 1\n            end_col = max_c # The range stops *before* end_col, corresponding to max_c - 1\n\n            for col in range(start_col, end_col):\n                # Check if column index parity matches background parity\n                if col % 2 == background_parity:\n                    # Check bounds just in case (should be within grid)\n                    if 0 <= midline_row < height and 0 <= col < width:\n                         # Ensure we only color over background pixels in the output grid\n                         # (This prevents overwriting parts of other rectangles if they somehow overlap,\n                         # although the hollow rectangle definition should prevent internal overlap).\n                        if output_grid[midline_row, col] == background_color:\n                            output_grid[midline_row, col] = rect_color\n\n    # 6. Return Output as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4810,
    "candidates_token_count": 2232,
    "total_token_count": 7042,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.924249
}