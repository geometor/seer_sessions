{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies enclosed white regions (pixels with value 0) bounded entirely by a single non-white color (the outline color).\nCalculates the frequency of all non-white colors in the entire input grid.\nDetermines the set of unique colors (U, count=1) and double colors (D, count=2).\nFor each enclosed white region, determines a fill color based on the outline color (C_outline), U, and D using a specific priority:\n1. If max(U) exists and is not C_outline, use max(U).\n2. Else if min(U) exists and is not C_outline, use min(U).\n3. Else if min(D) exists and is not C_outline, use min(D).\n4. Else if max(D) exists and is not C_outline, use max(D).\n5. Else, use C_outline.\nFills the identified white regions in the output grid with the calculated fill color.\n\"\"\"\n\ndef find_regions(grid):\n    \"\"\"\n    Finds connected components of white pixels (0) that are exclusively bordered\n    by a single non-zero color. Uses Breadth-First Search (BFS).\n    \n    Args:\n        grid (np.ndarray): The input grid.\n        \n    Returns:\n        list: A list of tuples, where each tuple contains:\n              (set of (r, c) coordinates of the white component, outline_color)\n    \"\"\"\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = [] # List to store results: (component_coords, outline_color)\n\n    for r in range(h):\n        for c in range(w):\n            # Start BFS from an unvisited white cell\n            if grid[r, c] == 0 and not visited[r, c]:\n                component = set() # Store coordinates of the current white component\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n                border_colors = set() # Store colors bordering this component\n                is_enclosed_component = True # Assume enclosed until proven otherwise\n                \n                while q:\n                    row, col = q.popleft()\n                    component.add((row, col))\n\n                    # Check 8 neighbors (Moore neighborhood)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = row + dr, col + dc\n\n                            # Check grid bounds\n                            if 0 <= nr < h and 0 <= nc < w:\n                                neighbor_val = grid[nr, nc]\n                                if neighbor_val != 0:\n                                    # Found a non-white neighbor, add its color to the set\n                                    border_colors.add(neighbor_val)\n                                elif not visited[nr, nc]:\n                                    # Found an adjacent white pixel, mark visited and add to queue\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                            else:\n                                # Touched grid edge - means the component is not enclosed\n                                is_enclosed_component = False\n                                # We can continue BFS to mark all parts visited, but know it's not enclosed\n                \n                # After BFS for this component, check if it was enclosed and bordered by exactly one color\n                if is_enclosed_component and len(border_colors) == 1:\n                    outline_color = list(border_colors)[0]\n                    regions.append((component, outline_color))\n                    \n    return regions\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to fill enclosed white regions based on global\n    color counts and outline color.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    h, w = input_grid.shape\n\n    # 1. Calculate global color counts (excluding white=0)\n    non_white_pixels = input_grid[input_grid != 0]\n    # If grid is all white or empty, return copy\n    if non_white_pixels.size == 0:\n        return output_grid \n        \n    counts = Counter(non_white_pixels)\n    \n    # 2. Determine Unique (U) and Double (D) sets (sorted)\n    uniques = sorted([color for color, count in counts.items() if count == 1])\n    doubles = sorted([color for color, count in counts.items() if count == 2])\n    \n    # 3. Find enclosed white regions and their outline colors\n    #    A region is a connected component of white pixels bordered ONLY by a single color.\n    regions = find_regions(input_grid)\n\n    # 4. Determine fill color for each region and apply it\n    for component_coords, c_outline in regions:\n        c_fill = None # Initialize fill color for this region\n\n        # Apply priority rules based on U and D sets\n        # Priority: max(U) -> min(U) -> min(D) -> max(D) -> C_outline\n        \n        # Check Uniques first\n        if uniques:\n            max_u = uniques[-1] # Highest value unique color\n            min_u = uniques[0]  # Lowest value unique color\n            if max_u != c_outline:\n                c_fill = max_u\n            elif min_u != c_outline:\n                 c_fill = min_u\n        \n        # Check Doubles if no Unique fill found yet\n        if c_fill is None and doubles:\n            min_d = doubles[0]  # Lowest value double color\n            max_d = doubles[-1] # Highest value double color\n            if min_d != c_outline:\n                 c_fill = min_d\n            elif max_d != c_outline:\n                c_fill = max_d\n\n        # Default case: Use outline color if no other rule applied\n        if c_fill is None:\n            c_fill = c_outline\n\n        # Fill the region in the output grid\n        for r, c in component_coords:\n            # Check bounds just in case, and ensure we only fill pixels that were originally white\n            if 0 <= r < h and 0 <= c < w and input_grid[r,c] == 0: \n                 output_grid[r, c] = c_fill\n                 \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13265,
    "candidates_token_count": 1493,
    "total_token_count": 14758,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.199543
}