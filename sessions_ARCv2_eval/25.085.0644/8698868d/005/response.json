{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\nimport itertools\n\n\"\"\"\nIdentifies hollow rectangular frames in the input grid. For each frame, it analyzes the pixels within its bounds but not part of the border itself. It determines a global 'placeholder' color (P) which is common across frame interiors and is replaced in the output. It also identifies a 'content' color (C_content) specific to each frame's interior (the non-P color). The transformation then creates new versions of each frame where the border is preserved, but internal pixels originally colored P are replaced with C_content. Finally, these transformed frames are assembled into an output grid, maintaining their original relative spatial arrangement, on a default white background.\n\"\"\"\n\n# ============================================\n# Helper Functions: Finding Objects & Properties\n# ============================================\n\ndef find_contiguous_regions(grid, colors_to_find=None, ignore_colors=None):\n    \"\"\"Finds all contiguous regions for specified colors, ignoring others.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = defaultdict(list) # color -> list of sets of coordinates\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if visited[r, c]:\n                continue\n\n            # Check if this color should be processed\n            valid_start = True\n            if ignore_colors is not None and color in ignore_colors:\n                valid_start = False\n            if colors_to_find is not None and color not in colors_to_find:\n                 valid_start = False\n\n            if not valid_start:\n                visited[r,c] = True # Mark visited anyway\n                continue\n\n            # Start BFS for a new region\n            region_coords = set()\n            q = [(r, c)]\n            visited[r, c] = True\n            region_color = color\n\n            while q:\n                row, col = q.pop(0)\n                region_coords.add((row, col))\n\n                # Check neighbors (4-connectivity)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < height and 0 <= nc < width and \\\n                       not visited[nr, nc] and grid[nr, nc] == region_color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            if region_coords:\n                regions[region_color].append(region_coords)\n\n    return regions\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) of a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef is_hollow_rectangle(coords, grid_shape):\n    \"\"\"Checks if a set of coordinates forms a hollow rectangle.\"\"\"\n    if len(coords) < 4: # Need at least 4 points for a minimal 2x2 frame (or 3x3 box)\n        return False, None\n\n    min_r, min_c, max_r, max_c = get_bounding_box(coords)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Basic size check (must be at least 3x3 to have a distinct interior)\n    if height < 3 or width < 3:\n        return False, None\n\n    # Check if all expected border pixels are present\n    expected_border_pixels = set()\n    for r in range(min_r, max_r + 1):\n        if (r, min_c) not in coords: return False, None\n        if (r, max_c) not in coords: return False, None\n        expected_border_pixels.add((r, min_c))\n        expected_border_pixels.add((r, max_c))\n    for c in range(min_c + 1, max_c): # Avoid double counting corners\n        if (min_r, c) not in coords: return False, None\n        if (max_r, c) not in coords: return False, None\n        expected_border_pixels.add((min_r, c))\n        expected_border_pixels.add((max_r, c))\n        \n    # Ensure the object *only* consists of border pixels (it shouldn't contain internal pixels of the same color)\n    if coords != expected_border_pixels:\n        return False, None\n\n    # Check if there's a potential interior (at least one non-border pixel within bounds)\n    has_potential_interior = False\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            # Check grid bounds just in case, though should be within by definition\n            # if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]: # Not needed if bounds are correct\n            has_potential_interior = True\n            break\n        if has_potential_interior: break\n\n    if not has_potential_interior:\n        return False, None # Not hollow\n\n    return True, (min_r, min_c, max_r, max_c)\n\n# ============================================\n# Helper Functions: Analysis\n# ============================================\n\ndef find_frames(grid):\n    \"\"\"Identifies hollow rectangular frame objects in the grid.\"\"\"\n    frames = []\n    # Consider all colors except 0 (white) as potential frame colors initially\n    # Background/separator colors will be filtered out if they don't form hollow rectangles\n    potential_frame_colors = np.unique(grid[grid != 0])\n    if len(potential_frame_colors) == 0:\n         return [] # No non-white colors\n\n    all_regions = find_contiguous_regions(grid, colors_to_find=potential_frame_colors)\n\n    obj_id_counter = 0\n    for color, regions_list in all_regions.items():\n        for region_coords in regions_list:\n            is_frame, bounds = is_hollow_rectangle(region_coords, grid.shape)\n            if is_frame:\n                frames.append({\n                    \"id\": obj_id_counter,\n                    \"color\": color,\n                    \"coords\": region_coords,\n                    \"bounds\": bounds, # (min_r, min_c, max_r, max_c)\n                    \"height\": bounds[2] - bounds[0] + 1,\n                    \"width\": bounds[3] - bounds[1] + 1,\n                    \"key\": (color, bounds) # Unique identifier\n                })\n                obj_id_counter += 1\n    return frames\n\ndef analyze_interiors_and_find_placeholder(grid, frames):\n    \"\"\"Analyzes pixels inside frames to find placeholder and content colors.\"\"\"\n    internal_colors_by_frame = {} # frame_key -> set of internal colors\n    all_internal_colors_counts = Counter()\n    internal_pixels_by_frame = {} # frame_key -> set of internal coords\n\n    if not frames:\n        return -1, {}, {} # Return default placeholder (-1), empty dicts\n\n    for frame in frames:\n        frame_key = frame[\"key\"]\n        min_r, min_c, max_r, max_c = frame[\"bounds\"]\n        frame_coords = frame[\"coords\"]\n        internal_colors = set()\n        internal_pixels = set()\n\n        for r in range(min_r + 1, max_r):\n            for c in range(min_c + 1, max_c):\n                # Check if the pixel is inside bounds but NOT part of the frame border itself\n                # The is_hollow_rectangle check already ensures frame_coords only contains the border\n                coord = (r, c)\n                # Double check it's not part of frame coords (shouldn't be necessary with correct is_hollow_rectangle)\n                if coord not in frame_coords:\n                    color = grid[r, c]\n                    internal_colors.add(color)\n                    all_internal_colors_counts[color] += 1\n                    internal_pixels.add(coord)\n\n\n        internal_colors_by_frame[frame_key] = internal_colors\n        internal_pixels_by_frame[frame_key] = internal_pixels\n\n    # Determine placeholder color (P)\n    # Heuristic: Most frequent color found across all internal areas.\n    placeholder_color = -1 # Default\n    if all_internal_colors_counts:\n        # Sort by count (desc) then by color (asc) for determinism\n        sorted_internal_colors = sorted(all_internal_colors_counts.items(), key=lambda item: (-item[1], item[0]))\n        placeholder_color = sorted_internal_colors[0][0]\n\n    return placeholder_color, internal_colors_by_frame, internal_pixels_by_frame\n\n\ndef find_content_colors(internal_colors_by_frame, placeholder_color):\n    \"\"\"Determines the content color for each frame.\"\"\"\n    content_colors = {} # frame_key -> content_color\n\n    for frame_key, colors_in_interior in internal_colors_by_frame.items():\n        possible_content_colors = colors_in_interior - {placeholder_color}\n        \n        if len(possible_content_colors) == 1:\n            content_colors[frame_key] = list(possible_content_colors)[0]\n        elif len(possible_content_colors) == 0:\n             # If only placeholder color is inside, maybe content color is same as frame color?\n             # Or maybe the frame should be filled entirely with frame color?\n             # Let's assume content color = frame color in this case.\n             frame_color = frame_key[0] # Get color from frame_key (color, bounds)\n             content_colors[frame_key] = frame_color\n             # print(f\"Warning: Frame {frame_key} interior only contains placeholder. Assuming content color = frame color ({frame_color}).\")\n        else:\n            # Multiple non-placeholder colors found. This case is ambiguous based on examples.\n            # Let's pick the most frequent one *within this specific frame* as a guess.\n            # Or maybe the least frequent? Or rely on order? Default to first found.\n            # This needs refinement if such cases occur.\n            # print(f\"Warning: Frame {frame_key} interior has multiple non-placeholder colors: {possible_content_colors}. Picking first one.\")\n            content_colors[frame_key] = sorted(list(possible_content_colors))[0]\n\n    return content_colors\n\n# ============================================\n# Helper Functions: Transformation & Assembly\n# ============================================\n\ndef transform_single_frame(grid, frame_data, internal_pixels, placeholder_color, content_color):\n    \"\"\"Creates the transformed grid for a single frame.\"\"\"\n    height = frame_data['height']\n    width = frame_data['width']\n    frame_color = frame_data['color']\n    min_r, min_c, _, _ = frame_data['bounds']\n\n    # Initialize the new frame grid - start with content color, then draw border? Or vice versa?\n    # Let's initialize with a temp value (-1) then fill border and interior.\n    transformed_grid = np.full((height, width), -1, dtype=int)\n\n    # Iterate through the relative coordinates of the new grid\n    for r_rel in range(height):\n        for c_rel in range(width):\n            orig_r, orig_c = min_r + r_rel, min_c + c_rel\n            coord = (orig_r, orig_c)\n\n            if coord in frame_data['coords']: # Is it a border pixel?\n                transformed_grid[r_rel, c_rel] = frame_color\n            elif coord in internal_pixels: # Is it an internal pixel?\n                original_color = grid[orig_r, orig_c]\n                if original_color == placeholder_color:\n                    transformed_grid[r_rel, c_rel] = content_color\n                else:\n                    # Assume it was already the content color or another color to preserve\n                    # Based on the logic, it *should* be the content color if not placeholder\n                    transformed_grid[r_rel, c_rel] = original_color\n            else:\n                # Should not happen if internal_pixels covers all non-border pixels within bounds\n                # If it does, maybe fill with default background (0)? Or leave as -1 for debugging?\n                # Let's fill with white (0) as a safe default for unexpected spots inside bounds.\n                transformed_grid[r_rel, c_rel] = 0\n                # print(f\"Warning: Coordinate {coord} is within bounds but neither border nor identified internal pixel for frame {frame_data['key']}. Filling with 0.\")\n\n\n    # Check for any remaining -1s (indicates logic error)\n    if np.any(transformed_grid == -1):\n         print(f\"Error: Untouched pixels (-1) remaining in transformed frame {frame_data['key']}. Filling with 0.\")\n         transformed_grid[transformed_grid == -1] = 0\n\n\n    return transformed_grid\n\n\ndef assemble_output(transformed_frames_map, original_frames):\n    \"\"\"Assembles the final output grid.\"\"\"\n    if not transformed_frames_map or not original_frames:\n        return np.array([[0]], dtype=int) # Default minimal grid\n\n    # Find overall bounding box of original frames\n    all_min_r, all_min_c = float('inf'), float('inf')\n    all_max_r, all_max_c = float('-inf'), float('-inf')\n\n    original_frame_data_map = {f['key']: f for f in original_frames}\n\n    # Use keys present in transformed_frames_map for bounds calculation\n    relevant_keys = transformed_frames_map.keys()\n    if not relevant_keys:\n        return np.array([[0]], dtype=int)\n\n    for frame_key in relevant_keys:\n        if frame_key in original_frame_data_map:\n            min_r, min_c, max_r, max_c = original_frame_data_map[frame_key]['bounds']\n            all_min_r = min(all_min_r, min_r)\n            all_min_c = min(all_min_c, min_c)\n            all_max_r = max(all_max_r, max_r)\n            all_max_c = max(all_max_c, max_c)\n        else:\n            # This indicates a key mismatch, should not happen\n            print(f\"Warning: Key {frame_key} from transformed map not found in original frames for bounds calculation.\")\n\n\n    if all_min_r == float('inf'): # No valid frames found/matched\n        return np.array([[0]], dtype=int)\n\n    output_height = all_max_r - all_min_r + 1\n    output_width = all_max_c - all_min_c + 1\n\n    # Create output grid, initialized with white (0)\n    output_grid = np.full((output_height, output_width), 0, dtype=int)\n\n    # Sort original frames by top-left corner for consistent placement order\n    sorted_original_frames = sorted(original_frames, key=lambda f: (f['bounds'][0], f['bounds'][1]))\n\n    # Place transformed frames\n    for frame_data in sorted_original_frames:\n        frame_key = frame_data['key']\n        if frame_key in transformed_frames_map:\n            transformed_grid = transformed_frames_map[frame_key]\n            h, w = transformed_grid.shape\n            \n            # Calculate relative position in the output grid\n            orig_min_r, orig_min_c, _, _ = frame_data['bounds']\n            rel_r = orig_min_r - all_min_r\n            rel_c = orig_min_c - all_min_c\n\n            # Place the transformed grid\n            if rel_r >= 0 and rel_c >= 0 and rel_r + h <= output_height and rel_c + w <= output_width:\n                output_grid[rel_r:rel_r + h, rel_c:rel_c + w] = transformed_grid\n            else:\n                 # This suggests an issue with overall bounds calculation or frame size mismatch\n                 print(f\"Warning: Frame {frame_key} placement [{rel_r}:{rel_r+h}, {rel_c}:{rel_c+w}] out of bounds for output grid size ({output_height}, {output_width}). Clipping.\")\n                 # Attempt to clip placement\n                 paste_h = min(h, output_height - rel_r)\n                 paste_w = min(w, output_width - rel_c)\n                 if paste_h > 0 and paste_w > 0 and rel_r>=0 and rel_c>=0:\n                     output_grid[rel_r:rel_r + paste_h, rel_c:rel_c + paste_w] = transformed_grid[:paste_h, :paste_w]\n\n\n    return output_grid\n\n\n# ============================================\n# Main Transformation Function\n# ============================================\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the frame interior transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for processing\n    input_grid_np = np.array(input_grid, dtype=int)\n\n    # Step 1: Identify Frame Objects\n    frames = find_frames(input_grid_np)\n    if not frames:\n        # print(\"No frames identified. Returning default grid.\")\n        return np.array([[0]], dtype=int).tolist()\n\n    # Step 2 & 3: Analyze Frame Interiors & Determine Placeholder Color (P)\n    placeholder_color, internal_colors_by_frame, internal_pixels_by_frame = analyze_interiors_and_find_placeholder(input_grid_np, frames)\n    if placeholder_color == -1:\n        # print(\"Could not determine placeholder color. Returning default grid.\")\n        # This might happen if frames have no interior pixels\n        return np.array([[0]], dtype=int).tolist()\n\n    # Step 4: Identify Frame-Specific Content Color (C_content)\n    content_colors = find_content_colors(internal_colors_by_frame, placeholder_color)\n    if not content_colors:\n         # This might happen if internal_colors_by_frame was empty etc.\n         # print(\"Could not determine content colors. Returning default grid.\")\n         return np.array([[0]], dtype=int).tolist()\n\n    # Step 5: Transform Frames\n    transformed_frames_map = {} # frame_key -> transformed_grid\n    for frame_data in frames:\n        frame_key = frame_data['key']\n        if frame_key in content_colors and frame_key in internal_pixels_by_frame:\n            content_color = content_colors[frame_key]\n            internal_pixels = internal_pixels_by_frame[frame_key]\n            transformed_grid = transform_single_frame(input_grid_np, frame_data, internal_pixels, placeholder_color, content_color)\n            transformed_frames_map[frame_key] = transformed_grid\n        else:\n            # print(f\"Warning: Missing content color or internal pixels for frame {frame_key}. Skipping transformation.\")\n             pass\n\n\n    # Step 6: Assemble Output Grid\n    output_grid_np = assemble_output(transformed_frames_map, frames)\n\n    # Convert final numpy array back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17747,
    "candidates_token_count": 4654,
    "total_token_count": 22401,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 52.257086
}