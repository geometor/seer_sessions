{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Initialize:** Start with the input grid. Create a working copy.\n2.  **Iterative Connection:**\n    *   Repeatedly scan the current working grid:\n        *   For each row, identify all pairs of pixels `(r, c1)` and `(r, c2)` (where `c1 < c2`) that have the *same* non-White (0) color `C`.\n        *   Check if all pixels in the range `(r, c1+1)` to `(r, c2-1)` are White (0) in the grid's state *at the beginning of the current pass*.\n        *   If the path is clear (all White), fill the pixels from `(r, c1+1)` to `(r, c2-1)` with color `C` in the working grid. Mark that a change was made in this pass.\n    *   Continue these passes until a full pass completes with no new connections made.\n    *   Store the resulting grid as `grid_with_connections`.\n3.  **Source Identification and Mapping:**\n    *   Refer back to the *original* input grid.\n    *   Identify all non-White (0) pixels. These are the \"expansion sources\". Record their locations `(sr, sc)` and original colors.\n    *   Determine global conditions from the *original* input grid:\n        *   `has_magenta_source`: True if any identified source has original color Magenta (6).\n        *   `has_orange_anywhere`: True if *any* pixel (source or not) in the original grid has color Orange (7).\n    *   Create a mapping for how each source's original color determines its expansion color:\n        *   If a source's original color is Azure (8) AND `has_magenta_source` is true, its expansion color is Blue (1).\n        *   If a source's original color is Magenta (6) AND `has_orange_anywhere` is true, its expansion color is Orange (7).\n        *   Otherwise, a source's expansion color is its own original color.\n4.  **Simultaneous Expansion (BFS):**\n    *   Initialize data structures to track distance from the nearest source and the owner (source coordinate tuple) for each cell, initially marking all as unreached/unowned.\n    *   Create a queue for the BFS, initially populated with all source locations `(sr, sc)` found in Step 3, marked with distance 0. Set the owner of each source location to its own coordinate tuple `(sr, sc)`. Sources start expansion regardless of whether their cell was filled by connection.\n    *   Process the BFS level by level (incrementing distance):\n        *   In each step, determine all potential next cells `(nr, nc)` reachable from the cells processed in the *previous* step.\n        *   A cell `(nr, nc)` is a potential target if it is within grid bounds, is White (0) in `grid_with_connections`, and has not yet been reached or contested (`owner[nr, nc]` is `None`).\n        *   Keep track of which source(s) (identified by their origin coordinates) attempt to reach each potential target `(nr, nc)` *in this specific step*.\n        *   After checking all cells at the current level:\n            *   For each potential target `(nr, nc)`:\n                *   If exactly one unique source reached it in this step, assign ownership `owner[nr, nc]` to that source's coordinate tuple, record the new distance `distance[nr, nc]`, and add `(nr, nc)` to the queue for the next level.\n                *   If multiple *different* sources reached it in this step, mark `owner[nr, nc]` as \"CONTESTED\". It remains White (0) and does not get added to the queue (acts as an obstacle).\n    *   Continue the BFS until the queue is empty.\n5.  **Output Construction:**\n    *   Start with a copy of `grid_with_connections`.\n    *   Iterate through the grid cells `(r, c)`.\n    *   If cell `(r, c)` was successfully claimed by a source `(sr, sc)` during the BFS (i.e., `owner[r, c]` is a coordinate tuple), find the corresponding expansion color determined in Step 3 for the source `(sr, sc)` and update the cell `(r, c)` in the final grid to this expansion color.\n    *   If the cell `(r, c)` was marked as \"CONTESTED\", ensure it is White (0) in the final grid (though it should be already if it was eligible for expansion).\n    *   Otherwise (if the cell was part of `grid_with_connections` and was never reached or contested), it retains its color from `grid_with_connections`.\n    *   Return the final grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules involving iterative horizontal connection\n    of same-colored pixels and subsequent simultaneous expansion (BFS) with\n    color mapping and conflict resolution.\n    \"\"\"\n    rows, cols = input_grid.shape\n    \n    # --- Step 1: Initialize ---\n    working_grid = np.copy(input_grid)\n\n    # --- Step 2: Iterative Connection ---\n    while True:\n        made_connection_in_pass = False\n        # Check paths against the state at the beginning of the pass\n        grid_at_pass_start = np.copy(working_grid) \n\n        for r in range(rows):\n            # Find indices and colors of non-white pixels in the row (using state at pass start)\n            non_white_pixels = {}\n            for c in range(cols):\n                color = grid_at_pass_start[r, c]\n                if color != 0:\n                    non_white_pixels[c] = color\n\n            sorted_indices = sorted(non_white_pixels.keys())\n\n            # Iterate through pairs of non-white pixels in the row\n            for i in range(len(sorted_indices)):\n                for j in range(i + 1, len(sorted_indices)):\n                    c1 = sorted_indices[i]\n                    c2 = sorted_indices[j]\n                    color1 = non_white_pixels[c1]\n                    color2 = non_white_pixels[c2]\n\n                    # Check if colors match\n                    if color1 == color2:\n                        # Check if path between c1 and c2 (exclusive) is all white (0) in grid_at_pass_start\n                        can_connect = True\n                        if c2 > c1 + 1: # Only check if there are cells between them\n                            for k in range(c1 + 1, c2):\n                                if grid_at_pass_start[r, k] != 0:\n                                    can_connect = False\n                                    break\n                        else: # Adjacent, no path to check/fill\n                            can_connect = False \n\n                        if can_connect:\n                            # Fill the path with color1 in the working_grid\n                            # Check if we are actually changing anything (target cell is white)\n                            path_changed = False\n                            for k in range(c1 + 1, c2):\n                                # Modify working_grid if the target is currently white\n                                if working_grid[r, k] == 0:\n                                    working_grid[r, k] = color1\n                                    path_changed = True\n                            if path_changed:\n                                made_connection_in_pass = True # Signal change\n\n        # If no connections were made in the entire pass, break the loop\n        if not made_connection_in_pass:\n            break\n\n    grid_with_connections = working_grid # Final state after connections\n\n    # --- Step 3: Source Identification and Mapping ---\n    sources = []\n    has_magenta_source = False\n    has_orange_anywhere = False\n    source_coords_colors = {} # Store original color at source coord: {(r, c): color}\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c] # Check ORIGINAL grid\n            if color != 0:\n                if color == 7:\n                    has_orange_anywhere = True # Check if orange exists anywhere in original\n                # All non-white pixels are potential sources\n                sources.append(((r, c), color))\n                source_coords_colors[(r, c)] = color\n                if color == 6:\n                    has_magenta_source = True # Check if any source is magenta\n\n    # Create the expansion color map based on original source colors\n    expansion_color_map = {}\n    # Iterate through unique original source colors to build the map\n    unique_source_colors = {color for _, color in sources}\n    for color in unique_source_colors:\n        if color == 8 and has_magenta_source:\n            expansion_color_map[color] = 1 # Azure -> Blue\n        elif color == 6 and has_orange_anywhere:\n            expansion_color_map[color] = 7 # Magenta -> Orange\n        else:\n            expansion_color_map[color] = color # Other sources expand as themselves\n\n\n    # --- Step 4: Simultaneous Expansion (BFS) ---\n    # distance: Stores the step count when a cell is reached. -1 means unreached.\n    # owner: Stores the coordinate tuple (sr, sc) of the source that reached the cell.\n    #        None means unreached/unowned. \"CONTESTED\" means multiple sources reached simultaneously.\n    distance = np.full((rows, cols), -1, dtype=int)\n    owner = np.full((rows, cols), None, dtype=object)\n    queue = deque()\n\n    # Initialize BFS queue and state grids with sources\n    for (r, c), _ in sources:\n         # Sources always start, regardless of connection phase results at their location.\n         # If the source location is already owned (e.g., two sources at same spot, impossible), handle gracefully.\n         if owner[r,c] is None:\n             distance[r, c] = 0\n             owner[r, c] = (r, c) # Owner is the coord tuple of the source itself\n             queue.append(((r, c), 0)) # ((row, col), dist)\n         # Note: If multiple sources start at the same location (input error?), the first one processed wins initialization.\n\n    # Main BFS loop processing level by level\n    while queue:\n        # Dictionary to track cells reached in this specific step for conflict detection\n        # Format: {(nr, nc): {originating_owner_coord1, originating_owner_coord2, ...}}\n        newly_reached_this_step = {}\n\n        # Determine current distance level\n        if not queue: break\n        current_dist = queue[0][1]\n\n        # Process all elements belonging to the current distance level\n        processed_in_level = 0\n        while queue and queue[0][1] == current_dist:\n             (r, c), dist = queue.popleft()\n             processed_in_level += 1\n\n             # Get the owner coord tuple of the current cell expanding\n             current_owner_coord = owner[r, c]\n\n             # If the current cell became contested earlier, it cannot expand further\n             # Also check if it's a valid tuple (source origin)\n             if not isinstance(current_owner_coord, tuple):\n                 continue\n\n             # Explore neighbors (Manhattan distance)\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n\n                 # Check bounds\n                 if 0 <= nr < rows and 0 <= nc < cols:\n                     # *** Expansion Condition ***\n                     # 1. Must be white (0) in the grid *after* connections.\n                     # 2. Must be currently unreached/unowned (owner is None).\n                     if grid_with_connections[nr, nc] == 0 and owner[nr, nc] is None:\n                        # Record this reach attempt for conflict resolution after the level is processed\n                        if (nr, nc) not in newly_reached_this_step:\n                            newly_reached_this_step[(nr, nc)] = set()\n                        # Add the *originating source* coord\n                        newly_reached_this_step[(nr, nc)].add(current_owner_coord)\n\n        # End of step processing: Update owner/distance grids and queue based on newly_reached_this_step\n        next_level_dist = current_dist + 1\n        for (nr, nc), owners_reaching in newly_reached_this_step.items():\n            if len(owners_reaching) == 1:\n                 # Successfully claimed by exactly one owner source in this step\n                 assigned_owner_coord = owners_reaching.pop() # Get the single owner coord\n                 distance[nr, nc] = next_level_dist\n                 owner[nr, nc] = assigned_owner_coord # Store the tuple coord of the owner source\n                 queue.append(((nr, nc), next_level_dist)) # Add to queue for next level\n            elif len(owners_reaching) > 1:\n                 # Contested: Reached by multiple different sources in this step\n                 owner[nr, nc] = \"CONTESTED\"\n                 # Do not update distance\n                 # Crucially, do *not* add contested cells to the queue for further expansion.\n\n    # --- Step 5: Final Output Construction ---\n    # Start with the grid after connections\n    final_output_grid = np.copy(grid_with_connections)\n    # Now fill in the expanded areas based on the BFS results\n    for r in range(rows):\n        for c in range(cols):\n            cell_owner = owner[r, c]\n            # Fill if owned by a non-contested source (owner is a tuple)\n            if isinstance(cell_owner, tuple):\n                sr, sc = cell_owner\n                # Get the original color of the source that owns this cell\n                original_source_color = source_coords_colors[(sr, sc)]\n                # Determine the fill color using the expansion map\n                fill_color = expansion_color_map.get(original_source_color, original_source_color) # Use map, fallback to original\n                final_output_grid[r, c] = fill_color\n            elif cell_owner == \"CONTESTED\":\n                # Ensure contested cells remain white (they should be white in grid_with_connections anyway)\n                final_output_grid[r, c] = 0\n            # Else: cell keeps its color from grid_with_connections (original non-white, connected line, or unreached white)\n\n\n    return final_output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13795,
    "candidates_token_count": 3397,
    "total_token_count": 17192,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.838697
}