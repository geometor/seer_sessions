{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThe transformation rule depends on the specific set of non-white colors present in the input grid, checked in a specific priority order:\n\n1.  **Magenta/Orange Swap & Flip (Trigger: {6, 7} present):**\n    *   Swap Magenta (6) pixels to Orange (7) and Orange (7) pixels to Magenta (6) in place.\n    *   For Red (2) pixels at (r, c), place Yellow (4) at the horizontally flipped position (r, width - 1 - c) in the output.\n    *   For Yellow (4) pixels at (r, c), place Red (2) at the horizontally flipped position (r, width - 1 - c) in the output.\n    *   All other non-white pixels (e.g., Azure 8) become white (0).\n\n2.  **Blue/Yellow Conditional Conversion (Trigger: {1, 4} present, and Rule 1 did not apply):**\n    *   Convert Yellow (4) pixels to Red (2).\n    *   Convert Blue (1) pixels to Orange (7).\n    *   Convert Azure (8) pixels based on row: If the row index `r` is less than or equal to the median row index (floor((height - 1) / 2)), convert to Red (2); otherwise, convert to Orange (7).\n    *   All other non-white pixels (e.g., original Red 2, Orange 7, Magenta 6) become white (0).\n    *   Note: This rule primarily addresses color transformation; the spatial placement in the output might require more complex logic based on observed patterns in Example 3.\n\n3.  **Red/Yellow Swap (Trigger: {2, 4} present, and Rules 1, 2 did not apply):**\n    *   Swap Red (2) pixels to Yellow (4) and Yellow (4) pixels to Red (2).\n    *   All other non-white pixels become white (0).\n\n4.  **Blue/Red Swap (+ Azure Handling) (Trigger: {1, 2} present, and Rules 1, 2, 3 did not apply):**\n    *   Check if Azure (8) is also present.\n    *   **Case 4a (Azure present: {1, 2, 8}):**\n        *   Swap Blue (1) pixels to Red (2).\n        *   Swap Red (2) pixels to Blue (1).\n        *   Convert Azure (8) pixels to Blue (1).\n        *   All other non-white pixels become white (0). (Derived from Ex 4, but known to be inconsistent with Ex 1).\n    *   **Case 4b (Azure absent: {1, 2} only):**\n        *   Swap Blue (1) pixels to Red (2).\n        *   Swap Red (2) pixels to Blue (1).\n        *   All other non-white pixels become white (0).\n\n5.  **Default (No specific trigger matched):**\n    *   The output grid is entirely white (0).\n\"\"\"\n\ndef get_present_colors(grid_np):\n    \"\"\"Finds the set of unique non-zero colors in a numpy grid.\"\"\"\n    return set(grid_np.flatten()) - {0}\n\ndef transform(input_grid):\n    \"\"\"\n    Applies a transformation rule based on the prioritized set of colors present.\n    Rules involve color swaps, conditional conversions, positional flips,\n    and handling based on the presence/absence of specific colors like Azure.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Initialize output grid with white (0)\n    output_np = np.zeros_like(input_np)\n    \n    # Determine the set of non-white colors present\n    present_colors = get_present_colors(input_np)\n    \n    # Calculate median row index for Rule 2\n    median_row = (height - 1) // 2\n\n    # --- Rule Priority Check ---\n\n    # Rule 1: Magenta(6)/Orange(7) present\n    if {6, 7}.issubset(present_colors):\n        # Use a temporary grid to store the results of the Red/Yellow flip+swap\n        # This prevents overwriting a pixel at (r, c) before its value is used\n        # to determine the output at (r, width - 1 - c), especially if c = width - 1 - c.\n        temp_flip = np.zeros_like(input_np)\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                flipped_c = width - 1 - c\n                # Check bounds for flipped column index\n                is_flipped_c_valid = 0 <= flipped_c < width\n\n                if pixel == 6:\n                    output_np[r, c] = 7 # Magenta -> Orange\n                elif pixel == 7:\n                    output_np[r, c] = 6 # Orange -> Magenta\n                elif pixel == 2:\n                    # Red at (r, c) becomes Yellow at (r, flipped_c)\n                    if is_flipped_c_valid:\n                         temp_flip[r, flipped_c] = 4\n                elif pixel == 4:\n                    # Yellow at (r, c) becomes Red at (r, flipped_c)\n                    if is_flipped_c_valid:\n                        temp_flip[r, flipped_c] = 2\n                # Other colors (like Azure 8) are ignored by default, remain 0 in output_np\n\n        # Merge the flipped Red/Yellow pixels into the output grid.\n        # Only update where temp_flip has a non-zero value.\n        output_np[temp_flip != 0] = temp_flip[temp_flip != 0]\n\n    # Rule 2: Blue(1)/Yellow(4) present (and Rule 1 didn't apply)\n    elif {1, 4}.issubset(present_colors):\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 4:\n                    output_np[r, c] = 2 # Yellow -> Red\n                elif pixel == 1:\n                    output_np[r, c] = 7 # Blue -> Orange\n                elif pixel == 8:\n                    # Azure -> Red (top) / Orange (bottom) based on median row\n                    if r <= median_row:\n                        output_np[r, c] = 2\n                    else:\n                        output_np[r, c] = 7\n                # Other original colors (Red 2, Orange 7, Magenta 6, etc.) become White(0)\n\n    # Rule 3: Red(2)/Yellow(4) present (and Rules 1, 2 didn't apply)\n    elif {2, 4}.issubset(present_colors):\n         for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 2:\n                    output_np[r, c] = 4 # Red -> Yellow\n                elif pixel == 4:\n                    output_np[r, c] = 2 # Yellow -> Red\n                # Other colors become White(0)\n\n    # Rule 4: Blue(1)/Red(2) present (and Rules 1, 2, 3 didn't apply)\n    elif {1, 2}.issubset(present_colors):\n        has_azure = 8 in present_colors # Check if Azure is present for sub-casing\n        for r in range(height):\n            for c in range(width):\n                pixel = input_np[r, c]\n                if pixel == 1:\n                    output_np[r, c] = 2 # Blue -> Red\n                elif pixel == 2:\n                    output_np[r, c] = 1 # Red -> Blue\n                elif pixel == 8 and has_azure:\n                     # Case 4a: {1, 2, 8} are present\n                     output_np[r, c] = 1 # Azure -> Blue\n                # Else (pixel is not 1, 2, or (8 when azure is present)):\n                # - If pixel was 8 but azure is not present (Case 4b): Remains 0.\n                # - If pixel was any other color: Remains 0.\n                # -> Correctly handled by default initialization.\n\n    # Default: If no specific trigger combination matched, output_np remains all zeros (white)\n\n    # Convert numpy array back to list of lists for the final output\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12936,
    "candidates_token_count": 2017,
    "total_token_count": 14953,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 44.880804
}