{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1. Identify the background color (typically green, color 3).\n2. Locate the single, contiguous red object (color 2).\n3. Locate all distinct, contiguous white objects (color 0).\n4. Identify all blue pixels (color 1) forming potential paths.\n5. Find the 'target' white object: Perform a Breadth-First Search (BFS) starting from blue pixels adjacent (including diagonally) to the red object. The search moves through adjacent blue pixels. The first white object encountered (i.e., a blue pixel adjacent to a white pixel) during this search is the target.\n6. Create the output grid:\n   a. Replace the pixels of the original red object with the background color.\n   b. Replace the pixels of the target white object with blue (color 1).\n   c. Keep all other pixels the same as the input grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a given color.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n                objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(coord, grid_shape, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given coordinate.\"\"\"\n    r, c = coord\n    rows, cols = grid_shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Finds a red object and the closest white object connected by a blue path,\n    then replaces the red object with background and the white object with blue.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Define colors (could be inferred, but seem fixed in examples)\n    background_color = 3\n    agent_color = 2\n    path_color = 1\n    target_color = 0\n    result_color = 1 # Color to change the target object to\n\n    # --- 1. Find Objects and Path Pixels ---\n    \n    # Find the red object (expecting exactly one)\n    red_objects = find_objects(grid, agent_color)\n    if not red_objects:\n        # Handle error: No red object found (or return input?)\n        return input_grid \n    red_object_coords = red_objects[0]\n\n    # Find all white objects\n    white_objects = find_objects(grid, target_color)\n    if not white_objects:\n         # Handle error: No white objects found (or return input?)\n        return input_grid\n        \n    # Create a mapping from coordinate to the white object it belongs to\n    white_coord_to_object_index = {}\n    for idx, obj in enumerate(white_objects):\n        for coord in obj:\n            white_coord_to_object_index[coord] = idx\n            \n    # Get coordinates of all blue path pixels\n    blue_path_coords = set(zip(*np.where(grid == path_color)))\n    if not blue_path_coords:\n        # Handle error: No blue path found (or return input?)\n        # Or maybe just change red to background and return? Let's follow example logic.\n        # In the examples, if there's a red and white, there seems to be a path.\n        # If BFS below finds nothing, the original grid minus red object might be correct.\n         pass # Continue processing, BFS will handle empty path\n\n    # --- 2. Find Target White Object via BFS ---\n\n    # Initialize BFS queue with blue neighbors of the red object\n    queue = deque()\n    visited = set()\n    start_nodes = set()\n\n    for r_coord in red_object_coords:\n        for neighbor in get_neighbors(r_coord, grid.shape, include_diagonal=True):\n            if neighbor in blue_path_coords:\n                start_nodes.add(neighbor)\n\n    for node in start_nodes:\n         if node not in visited:\n             queue.append(node)\n             visited.add(node)\n\n    target_white_object_coords = None\n\n    while queue:\n        current_coord = queue.popleft()\n\n        # Check neighbors for adjacent white pixels\n        found_target = False\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            if neighbor in white_coord_to_object_index:\n                target_object_index = white_coord_to_object_index[neighbor]\n                target_white_object_coords = white_objects[target_object_index]\n                found_target = True\n                break # Found the closest white object\n\n        if found_target:\n            break # Exit BFS\n\n        # Add unvisited blue neighbors to the queue\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            if neighbor in blue_path_coords and neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    # --- 3. Modify the Grid ---\n\n    # Change red object pixels to background color\n    for r, c in red_object_coords:\n        output_grid[r, c] = background_color\n\n    # Change target white object pixels to result color (blue)\n    if target_white_object_coords:\n        for r, c in target_white_object_coords:\n            output_grid[r, c] = result_color\n    # else: if no target found, the red object is still removed, white objects remain unchanged.\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 4543,
            "end_index": 4878,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5254,
    "candidates_token_count": 1684,
    "total_token_count": 6938,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.118919
}