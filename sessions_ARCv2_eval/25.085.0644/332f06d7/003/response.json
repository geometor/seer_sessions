{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1. Identify the background color (typically green, 3).\n2. Locate the single, contiguous red object (color 2, 'Agent').\n3. Locate all distinct, contiguous white objects (color 0, 'Targets'). Count the total number of white objects.\n4. Identify all blue pixels (color 1, 'Path').\n5. Perform a Breadth-First Search (BFS) starting from blue pixels adjacent (including diagonally) to the red object. The search moves through adjacent blue pixels.\n6. Identify the 'reachable' white object: This is the first white object encountered during the BFS (i.e., a blue pixel in the path is adjacent to a pixel belonging to a white object). If no white object is reachable, proceed without changing any white objects.\n7. Create the output grid, initially as a copy of the input grid.\n8. Transformation Rules:\n   a. If a white object was reachable via the BFS path:\n      i. Change all pixels of the reachable white object to blue (color 1).\n      ii. If the total number of white objects found in step 3 was exactly one, change all pixels of the original red object to white (color 0).\n      iii. If the total number of white objects found in step 3 was greater than one, leave the original red object unchanged (keep it red, color 2).\n   b. If no white object was reachable via the BFS path, make no changes to the grid (return the copy).\n   c. All other pixels (background, other path pixels, unreachable white objects) remain unchanged from the input grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a given color using 8-way connectivity.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited pixel of the target color\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is same color and unvisited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n                # Add the found object's coordinates to the list of objects\n                objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(coord, grid_shape, include_diagonal=True):\n    \"\"\"Gets valid neighbor coordinates for a given coordinate.\"\"\"\n    r, c = coord\n    rows, cols = grid_shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center pixel itself\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonal neighbors if not included\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the revised transformation rule based on white object count and reachability.\n    Finds a red object, finds all white objects, finds the one reachable via a blue path,\n    and transforms the red and reachable white objects based on the total count of white objects.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Start with a copy\n    rows, cols = grid.shape\n\n    # Define colors used in the transformation\n    agent_color = 2             # Red\n    path_color = 1              # Blue\n    target_color = 0            # White\n    result_color_target = 1     # Blue (color to change reachable white object to)\n    result_color_agent_single = 0 # White (color to change red agent to if only 1 white obj)\n    # background_color = 3      # Green (not explicitly needed for modification rule)\n\n    # --- 1. Find Objects and Path Pixels ---\n\n    # Find the red agent object (assuming exactly one)\n    red_objects = find_objects(grid, agent_color)\n    if not red_objects:\n        # If no red agent is found, return the original grid\n        return input_grid\n    # We assume based on examples there's only one red object\n    red_object_coords = red_objects[0]\n\n    # Find all white target objects\n    white_objects = find_objects(grid, target_color)\n    num_white_objects = len(white_objects)\n    if num_white_objects == 0:\n        # If no white targets are found, return the original grid\n        return input_grid\n\n    # Create a quick lookup map from a coordinate to the index of the white object it belongs to\n    white_coord_to_object_index = {}\n    for idx, obj in enumerate(white_objects):\n        for coord in obj:\n            white_coord_to_object_index[coord] = idx\n\n    # Get coordinates of all blue path pixels\n    blue_path_coords = set(zip(*np.where(grid == path_color)))\n    # If there's no path, BFS will naturally find no reachable object\n\n    # --- 2. Find Reachable White Object via BFS ---\n\n    # Initialize BFS queue with blue pixels directly adjacent (including diagonally) to the red object\n    queue = deque()\n    visited_path = set() # Keep track of visited blue path pixels\n    start_nodes = set()  # Blue pixels adjacent to the red object\n\n    for r_coord in red_object_coords:\n        for neighbor in get_neighbors(r_coord, grid.shape, include_diagonal=True):\n            # Check if neighbor is a blue path pixel\n            if neighbor in blue_path_coords:\n                start_nodes.add(neighbor)\n\n    # Add starting blue nodes to the queue and mark as visited\n    for node in start_nodes:\n         if node not in visited_path:\n             queue.append(node)\n             visited_path.add(node)\n\n    reachable_white_object_index = -1 # Index of the reachable white object\n    reachable_white_object_coords = None # Coordinates of the reachable white object\n\n    # Perform BFS through the blue path\n    while queue:\n        current_coord = queue.popleft()\n\n        # Check if current blue pixel is adjacent (including diagonally) to any white pixel\n        found_target = False\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            if neighbor in white_coord_to_object_index:\n                # Found a connection to a white object\n                target_object_index = white_coord_to_object_index[neighbor]\n                # Record the first reachable white object found\n                reachable_white_object_index = target_object_index\n                reachable_white_object_coords = white_objects[target_object_index]\n                found_target = True\n                break # Stop searching once the first reachable object is identified\n\n        if found_target:\n            break # Exit BFS\n\n        # Add unvisited blue neighbors to the queue for further exploration\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            # Check if neighbor is a blue path pixel and hasn't been visited yet\n            if neighbor in blue_path_coords and neighbor not in visited_path:\n                visited_path.add(neighbor)\n                queue.append(neighbor)\n\n    # --- 3. Modify the Output Grid based on findings ---\n\n    # Only proceed with modifications if a white object was reachable\n    if reachable_white_object_coords is not None:\n        # Rule a.i: Change reachable white object pixels to blue\n        for r, c in reachable_white_object_coords:\n            output_grid[r, c] = result_color_target\n\n        # Determine the transformation of the red object based on the total count of white objects\n        if num_white_objects == 1:\n            # Rule a.ii: If only one white object total, change red object to white\n            for r, c in red_object_coords:\n                output_grid[r, c] = result_color_agent_single\n        elif num_white_objects > 1:\n            # Rule a.iii: If multiple white objects, red object remains red\n            # No action needed as output_grid started as a copy\n            pass\n        # Note: The case num_white_objects == 0 was handled earlier\n\n    # else: Rule b: If no white object was reachable, no changes are made to output_grid.\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 11380,
            "end_index": 11715,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7423,
    "candidates_token_count": 2226,
    "total_token_count": 9649,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 51.513684
}