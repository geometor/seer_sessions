
## train_1

**input:**
```
0 0 0 0 6 6 6 6 6 6 6 5 6 6 6 6
0 0 6 0 6 6 6 6 6 6 6 5 6 6 6 6
6 0 0 0 0 6 6 6 6 6 6 5 6 6 6 6
0 0 0 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


**output:**
```
6 6 6 6 6 0 0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 0 0 6 0 6 6 5 6 6 6 6
6 6 6 6 6 6 0 0 0 0 6 5 6 6 6 6
6 6 6 6 6 0 0 0 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


## train_2

**input:**
```
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
```


**output:**
```
6 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 0 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
```


## train_3

**input:**
```
6 0 0 0 0 0 6 5 6 6
6 0 6 6 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 0 6 0 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 0 6 6 0 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 6 6 6 6 6 6 5 6 6
```


**output:**
```
6 6 0 0 0 0 0 5 6 6
6 6 0 6 6 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 0 5 6 6
6 6 0 6 0 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
```

*   **Perception:**
    *   The input and output are grids of pixels.
    *   The primary colors involved are white (0), magenta (6), gray (5), and red (2).
    *   A prominent feature in the input grid is a single vertical line composed of gray (5) pixels. This line acts as a barrier.
    *   To the left of the gray line, there are regions or objects composed of white (0) pixels, set against a background of magenta (6) pixels.
    *   The transformation involves shifting these white objects horizontally to the right.
    *   Each distinct contiguous white object calculates its own shift distance. The object shifts rightwards until its rightmost edge is immediately adjacent to the left of the gray line (i.e., in the column `gray_line_column - 1`).
    *   The original positions of the shifted white pixels are changed to magenta (6).
    *   If a white object is shifted (i.e., its shift distance is greater than 0), new red (2) pixels appear in the output grid.
    *   These red pixels form rectangular blocks located immediately to the right of the gray line.
    *   Red pixels only appear in rows where a shifted white object's rightmost edge ended up adjacent to the gray line after the shift.
    *   The width of the red rectangular block seems consistent within a single task example but varies between examples (4 in train_1, 4 in train_2, 2 in train_3). The exact determination of this width is not immediately obvious from the provided examples alone but seems related to the rows where shifted objects collide with the barrier. Pixels to the right of the gray line, not replaced by red, retain their original color from the input.

*   **Facts:**
    
```yaml
    Grid:
      type: 2D array of integers (pixels)
      colors: [0, 2, 5, 6] # white, red, gray, magenta primarily involved
      size: variable (e.g., 16x16, 16x10, 20x10)

    Objects:
      - type: Gray_Line
        color: 5
        shape: vertical line (1 pixel wide)
        location: specific column index C
        role: barrier
      - type: White_Object
        color: 0
        shape: contiguous region of pixels
        location: left of Gray_Line (column index < C)
        properties:
          - bounding_box
          - rightmost_column_index
      - type: Background
        color: 6 (magenta)
        location: fills space around White_Objects left of Gray_Line
      - type: Red_Region
        color: 2
        shape: rectangle
        location: right of Gray_Line (column index > C)
        status: appears only in output

    Relationships:
      - White_Objects are positioned relative to the Gray_Line.
      - Red_Regions appear adjacent to the Gray_Line in the output.
      - Red_Regions appear only in rows corresponding to White_Objects that shifted and reached the column C-1.

    Actions:
      - Identify the column index 'C' of the Gray_Line.
      - Identify all contiguous White_Objects left of column C.
      - For each White_Object:
          - Find its rightmost column index 'max_c_obj'.
          - Calculate shift distance: 'shift = (C - 1) - max_c_obj'.
      - Create the output grid (initially copy of input, or magenta background).
      - Copy the Gray_Line and everything to its right from input to output.
      - For each White_Object:
          - If shift > 0:
              - For each pixel (r, c) in the object:
                  - Set output[r, c] = 6 (magenta).
              - For each pixel (r, c) in the object:
                  - Set output[r, c + shift] = 0 (white).
              - Identify rows 'R_touch' where shifted pixels land at column C-1.
              - Determine the width 'W_red' for the Red_Region (e.g., 4 for train_1/2, 2 for train_3).
              - For each row 'r' in 'R_touch':
                  - Fill output[r, C+1 : C+1+W_red] = 2 (red).
          - If shift == 0:
              - Copy the White_Object pixels to the output without change.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the column index `C` of the vertical gray (5) line.
    3.  Find all distinct contiguous objects composed of white (0) pixels located entirely in columns less than `C`.
    4.  For each white object identified:
        a.  Determine the maximum column index `max_c` occupied by any pixel within that object.
        b.  Calculate the shift distance required for this object: `shift = (C - 1) - max_c`.
        c.  If `shift` is greater than 0:
            i.  Keep track of the rows `R_touch` where pixels of this object originally existed at column `max_c`.
            ii. For every pixel `(r, c)` belonging to this object in the input grid, change the corresponding pixel `(r, c)` in the output grid to magenta (6).
            iii.For every pixel `(r, c)` belonging to this object in the input grid, change the pixel `(r, c + shift)` in the output grid to white (0).
            iv. Determine the width `W_red` for the red region associated with this task (this seems to be a fixed value per task, e.g., 4 for the first two examples, 2 for the third).
            v.  For each row `r` in `R_touch`, set the pixels in the output grid from column `C + 1` to `C + W_red` (inclusive) to red (2).
    5.  Leave all other pixels in the output grid (the gray line, pixels to its right not overwritten by red, magenta background pixels not part of an original white object, and unshifted white objects) unchanged from their initial state (copied from the input).
```python
import numpy as np
from collections import deque

"""
Transforms the input grid based on the following rules:
1. Identify a vertical gray line (color 5). This acts as a barrier.
2. Find all distinct contiguous white objects (color 0) located entirely to the 
   left of the gray line.
3. For each white object:
   a. Determine its rightmost column index ('max_c').
   b. Calculate the horizontal shift distance required to move the object rightwards 
      so that its rightmost edge ends up in the column immediately to the left 
      of the gray line ('gray_col' - 1). The shift distance is ('gray_col' - 1) - 'max_c'.
   c. If the shift distance is greater than 0:
      i.  Identify the rows where the object's original rightmost pixels were located. 
          These rows will potentially receive red pixels later.
      ii. In the output grid, change the original pixels of the object to magenta (6).
      iii.In the output grid, draw the object's pixels in their new shifted positions 
          using white (0).
      iv. Determine a width 'W_red'. This is calculated based on the *input* grid: 
          count the number of contiguous columns, starting immediately to the right 
          of the gray line, that consist *entirely* of magenta (6) pixels. 
          Cap this count at a maximum of 4. So, W_red = min(4, count).
      v.  For each row identified in step (i), paint a horizontal segment of red (2) 
          pixels in the output grid. This segment starts at the column immediately 
          to the right of the gray line ('gray_col' + 1) and extends for 'W_red' columns.
4. Pixels not involved in the shifting (the gray line itself, pixels to its right 
   not overwritten by red, background magenta pixels, and white objects that did 
   not need to shift) remain unchanged from the input grid unless overwritten by 
   the shifted white objects during step (iii).
"""

# Color constants
WHITE = 0
RED = 2
GRAY = 5
MAGENTA = 6

def find_objects(grid: np.ndarray, color: int, max_col: int) -> list[list[tuple[int, int]]]:
    """
    Finds connected objects of a specific color strictly to the left of max_col.
    Uses Breadth-First Search (BFS). Returns a list of objects, where each
    object is a list of its (row, col) coordinates.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        # Only start searching in columns strictly less than max_col
        for c in range(max_col): 
            if grid[r, c] == color and not visited[r, c]:
                obj_coords = []
                q = deque([(r, c)])
                visited[r, c] = True
                is_valid_object = True # Assume valid until proven otherwise

                current_obj_visited_in_bfs = set([(r,c)]) # Track visited within this BFS

                while q:
                    row, col = q.popleft()

                    # Check if any part of the object reaches or exceeds max_col
                    if col >= max_col:
                        is_valid_object = False
                        # Continue BFS to mark all connected pixels as visited,
                        # but flag this object as invalid.

                    obj_coords.append((row, col))

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        neighbor = (nr, nc)
                        
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] == color and \
                           not visited[nr, nc] and \
                           neighbor not in current_obj_visited_in_bfs:
                            
                            # Mark visited globally and for this BFS traversal
                            visited[nr, nc] = True
                            current_obj_visited_in_bfs.add(neighbor)
                            q.append(neighbor)
                
                # Only add objects that are entirely contained left of max_col
                if is_valid_object and obj_coords:
                    objects.append(obj_coords)
                # If !is_valid_object, obj_coords are discarded, but pixels remain 'visited'.

    return objects


def get_object_properties(obj_coords: list[tuple[int, int]]) -> tuple[int, set[int]]:
    """
    Calculates the rightmost column and the set of rows touching that column for an object.
    """
    if not obj_coords:
        return -1, set()

    max_c = -1
    # Find the maximum column index for this object
    for _, c in obj_coords:
        if c > max_c:
            max_c = c

    # Find all rows that have a pixel at this maximum column index
    touching_rows = set()
    for r, c in obj_coords:
        if c == max_c:
            touching_rows.add(r)

    return max_c, touching_rows

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the object shifting and red region painting transformation.
    """
    input_arr = np.array(input_grid, dtype=int)
    # Initialize output as a copy of the input
    output_arr = np.copy(input_arr)
    rows, cols = input_arr.shape

    # --- Step 1: Find the gray line column ---
    gray_col = -1
    for c in range(cols):
        # Assuming the gray line is solid and unique
        if np.all(input_arr[:, c] == GRAY):
            gray_col = c
            break
            
    # If no solid gray line, try finding the first column with *any* gray pixel
    # This is a fallback, might need adjustment if gray appears elsewhere.
    if gray_col == -1:
         for c in range(cols):
             if GRAY in input_arr[:, c]:
                 # Basic check if it's a line-like feature
                 if np.sum(input_arr[:, c] == GRAY) > rows // 2: 
                     gray_col = c
                     break

    # If still no gray line found, return input as we can't proceed
    if gray_col == -1:
        # print("Warning: Gray line column not found. Returning input.")
        return input_grid 

    # --- Step 2: Find white objects strictly left of the gray line ---
    # Pass gray_col as the exclusive upper bound for columns to search/consider
    white_objects = find_objects(input_arr, WHITE, max_col=gray_col)

    # --- Step 3: Determine the width for the red regions ---
    # This is based on contiguous magenta columns in the input grid
    contiguous_magenta_cols = 0
    if gray_col + 1 < cols: # Check if there are columns to the right
        for c_check in range(gray_col + 1, cols):
            # Check if all pixels in this column are magenta
            if np.all(input_arr[:, c_check] == MAGENTA):
                contiguous_magenta_cols += 1
            else:
                break # Stop counting at the first column that's not fully magenta
    # The width is capped at 4, based on observed examples
    w_red = min(4, contiguous_magenta_cols)

    # --- Step 4: Process each white object ---
    rows_to_paint_red = set() # Collect all rows that need red painting
    objects_to_modify = [] # Store info needed for modification steps

    for obj_coords in white_objects:
        if not obj_coords: continue # Skip if an empty object was somehow found

        # Get properties of the object
        max_c, touching_rows = get_object_properties(obj_coords)
        
        # Calculate required shift distance
        shift = (gray_col - 1) - max_c

        # Store information if the object needs to be shifted
        if shift > 0:
            objects_to_modify.append({
                'coords': obj_coords,
                'shift': shift,
                'touching_rows': touching_rows
            })

    # --- Perform modifications in stages to avoid conflicts ---

    # Stage A: Erase original positions of shifted objects
    for obj_data in objects_to_modify:
        for r, c in obj_data['coords']:
            # Check bounds just in case, though coords should be valid
            if 0 <= r < rows and 0 <= c < cols:
                output_arr[r, c] = MAGENTA # Overwrite original with magenta

    # Stage B: Draw shifted objects in new positions
    for obj_data in objects_to_modify:
        shift = obj_data['shift']
        for r, c in obj_data['coords']:
            new_c = c + shift
            # Check bounds for the new position and ensure it's left of gray line
            if 0 <= r < rows and 0 <= new_c < gray_col:
                output_arr[r, new_c] = WHITE # Draw shifted object part

        # Collect the rows that need red painting for this object
        rows_to_paint_red.update(obj_data['touching_rows'])

    # Stage C: Paint red regions if applicable
    if w_red > 0 and rows_to_paint_red:
        red_start_col = gray_col + 1
        # Calculate end column, ensuring it doesn't exceed grid bounds
        red_end_col = min(cols, red_start_col + w_red) 

        for r in rows_to_paint_red:
             # Ensure row is valid and there are columns to paint
             if 0 <= r < rows and red_start_col < red_end_col:
                 output_arr[r, red_start_col:red_end_col] = RED

    # Convert the final NumPy array back to a list of lists
    return output_arr.tolist()
```
