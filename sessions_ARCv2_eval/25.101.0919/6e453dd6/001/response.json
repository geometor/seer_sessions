{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify a vertical gray line (color 5). This acts as a barrier.\n2. Find all distinct contiguous white objects (color 0) located entirely to the \n   left of the gray line.\n3. For each white object:\n   a. Determine its rightmost column index ('max_c').\n   b. Calculate the horizontal shift distance required to move the object rightwards \n      so that its rightmost edge ends up in the column immediately to the left \n      of the gray line ('gray_col' - 1). The shift distance is ('gray_col' - 1) - 'max_c'.\n   c. If the shift distance is greater than 0:\n      i.  Identify the rows where the object's original rightmost pixels were located. \n          These rows will potentially receive red pixels later.\n      ii. In the output grid, change the original pixels of the object to magenta (6).\n      iii.In the output grid, draw the object's pixels in their new shifted positions \n          using white (0).\n      iv. Determine a width 'W_red'. This is calculated based on the *input* grid: \n          count the number of contiguous columns, starting immediately to the right \n          of the gray line, that consist *entirely* of magenta (6) pixels. \n          Cap this count at a maximum of 4. So, W_red = min(4, count).\n      v.  For each row identified in step (i), paint a horizontal segment of red (2) \n          pixels in the output grid. This segment starts at the column immediately \n          to the right of the gray line ('gray_col' + 1) and extends for 'W_red' columns.\n4. Pixels not involved in the shifting (the gray line itself, pixels to its right \n   not overwritten by red, background magenta pixels, and white objects that did \n   not need to shift) remain unchanged from the input grid unless overwritten by \n   the shifted white objects during step (iii).\n\"\"\"\n\n# Color constants\nWHITE = 0\nRED = 2\nGRAY = 5\nMAGENTA = 6\n\ndef find_objects(grid: np.ndarray, color: int, max_col: int) -> list[list[tuple[int, int]]]:\n    \"\"\"\n    Finds connected objects of a specific color strictly to the left of max_col.\n    Uses Breadth-First Search (BFS). Returns a list of objects, where each\n    object is a list of its (row, col) coordinates.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        # Only start searching in columns strictly less than max_col\n        for c in range(max_col): \n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                is_valid_object = True # Assume valid until proven otherwise\n\n                current_obj_visited_in_bfs = set([(r,c)]) # Track visited within this BFS\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check if any part of the object reaches or exceeds max_col\n                    if col >= max_col:\n                        is_valid_object = False\n                        # Continue BFS to mark all connected pixels as visited,\n                        # but flag this object as invalid.\n\n                    obj_coords.append((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        neighbor = (nr, nc)\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and \\\n                           not visited[nr, nc] and \\\n                           neighbor not in current_obj_visited_in_bfs:\n                            \n                            # Mark visited globally and for this BFS traversal\n                            visited[nr, nc] = True\n                            current_obj_visited_in_bfs.add(neighbor)\n                            q.append(neighbor)\n                \n                # Only add objects that are entirely contained left of max_col\n                if is_valid_object and obj_coords:\n                    objects.append(obj_coords)\n                # If !is_valid_object, obj_coords are discarded, but pixels remain 'visited'.\n\n    return objects\n\n\ndef get_object_properties(obj_coords: list[tuple[int, int]]) -> tuple[int, set[int]]:\n    \"\"\"\n    Calculates the rightmost column and the set of rows touching that column for an object.\n    \"\"\"\n    if not obj_coords:\n        return -1, set()\n\n    max_c = -1\n    # Find the maximum column index for this object\n    for _, c in obj_coords:\n        if c > max_c:\n            max_c = c\n\n    # Find all rows that have a pixel at this maximum column index\n    touching_rows = set()\n    for r, c in obj_coords:\n        if c == max_c:\n            touching_rows.add(r)\n\n    return max_c, touching_rows\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the object shifting and red region painting transformation.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    # Initialize output as a copy of the input\n    output_arr = np.copy(input_arr)\n    rows, cols = input_arr.shape\n\n    # --- Step 1: Find the gray line column ---\n    gray_col = -1\n    for c in range(cols):\n        # Assuming the gray line is solid and unique\n        if np.all(input_arr[:, c] == GRAY):\n            gray_col = c\n            break\n            \n    # If no solid gray line, try finding the first column with *any* gray pixel\n    # This is a fallback, might need adjustment if gray appears elsewhere.\n    if gray_col == -1:\n         for c in range(cols):\n             if GRAY in input_arr[:, c]:\n                 # Basic check if it's a line-like feature\n                 if np.sum(input_arr[:, c] == GRAY) > rows // 2: \n                     gray_col = c\n                     break\n\n    # If still no gray line found, return input as we can't proceed\n    if gray_col == -1:\n        # print(\"Warning: Gray line column not found. Returning input.\")\n        return input_grid \n\n    # --- Step 2: Find white objects strictly left of the gray line ---\n    # Pass gray_col as the exclusive upper bound for columns to search/consider\n    white_objects = find_objects(input_arr, WHITE, max_col=gray_col)\n\n    # --- Step 3: Determine the width for the red regions ---\n    # This is based on contiguous magenta columns in the input grid\n    contiguous_magenta_cols = 0\n    if gray_col + 1 < cols: # Check if there are columns to the right\n        for c_check in range(gray_col + 1, cols):\n            # Check if all pixels in this column are magenta\n            if np.all(input_arr[:, c_check] == MAGENTA):\n                contiguous_magenta_cols += 1\n            else:\n                break # Stop counting at the first column that's not fully magenta\n    # The width is capped at 4, based on observed examples\n    w_red = min(4, contiguous_magenta_cols)\n\n    # --- Step 4: Process each white object ---\n    rows_to_paint_red = set() # Collect all rows that need red painting\n    objects_to_modify = [] # Store info needed for modification steps\n\n    for obj_coords in white_objects:\n        if not obj_coords: continue # Skip if an empty object was somehow found\n\n        # Get properties of the object\n        max_c, touching_rows = get_object_properties(obj_coords)\n        \n        # Calculate required shift distance\n        shift = (gray_col - 1) - max_c\n\n        # Store information if the object needs to be shifted\n        if shift > 0:\n            objects_to_modify.append({\n                'coords': obj_coords,\n                'shift': shift,\n                'touching_rows': touching_rows\n            })\n\n    # --- Perform modifications in stages to avoid conflicts ---\n\n    # Stage A: Erase original positions of shifted objects\n    for obj_data in objects_to_modify:\n        for r, c in obj_data['coords']:\n            # Check bounds just in case, though coords should be valid\n            if 0 <= r < rows and 0 <= c < cols:\n                output_arr[r, c] = MAGENTA # Overwrite original with magenta\n\n    # Stage B: Draw shifted objects in new positions\n    for obj_data in objects_to_modify:\n        shift = obj_data['shift']\n        for r, c in obj_data['coords']:\n            new_c = c + shift\n            # Check bounds for the new position and ensure it's left of gray line\n            if 0 <= r < rows and 0 <= new_c < gray_col:\n                output_arr[r, new_c] = WHITE # Draw shifted object part\n\n        # Collect the rows that need red painting for this object\n        rows_to_paint_red.update(obj_data['touching_rows'])\n\n    # Stage C: Paint red regions if applicable\n    if w_red > 0 and rows_to_paint_red:\n        red_start_col = gray_col + 1\n        # Calculate end column, ensuring it doesn't exceed grid bounds\n        red_end_col = min(cols, red_start_col + w_red) \n\n        for r in rows_to_paint_red:\n             # Ensure row is valid and there are columns to paint\n             if 0 <= r < rows and red_start_col < red_end_col:\n                 output_arr[r, red_start_col:red_end_col] = RED\n\n    # Convert the final NumPy array back to a list of lists\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5026,
    "candidates_token_count": 7792,
    "total_token_count": 12818,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 62.458097,
  "retries": 1
}