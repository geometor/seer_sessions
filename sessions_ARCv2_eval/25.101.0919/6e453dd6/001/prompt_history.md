
## train_1

**input:**
```
0 0 0 0 6 6 6 6 6 6 6 5 6 6 6 6
0 0 6 0 6 6 6 6 6 6 6 5 6 6 6 6
6 0 0 0 0 6 6 6 6 6 6 5 6 6 6 6
0 0 0 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 6 0 6 6 6 6 6 5 6 6 6 6
6 6 6 0 0 0 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


**output:**
```
6 6 6 6 6 0 0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 0 0 6 0 6 6 5 6 6 6 6
6 6 6 6 6 6 0 0 0 0 6 5 6 6 6 6
6 6 6 6 6 0 0 0 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 6 0 5 2 2 2 2
6 6 6 6 6 6 6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 5 6 6 6 6
```


## train_2

**input:**
```
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
0 6 0 6 6 5 6 6 6 6
0 0 0 6 6 5 6 6 6 6
```


**output:**
```
6 0 0 0 6 5 6 6 6 6
6 0 6 0 6 5 6 6 6 6
6 0 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
6 6 0 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 6 6 6 5 6 6 6 6
6 6 0 0 0 5 6 6 6 6
6 6 0 6 0 5 2 2 2 2
6 6 0 0 0 5 6 6 6 6
```


## train_3

**input:**
```
6 0 0 0 0 0 6 5 6 6
6 0 6 6 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 6 6 0 6 5 6 6
6 6 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 0 6 0 6 0 6 5 6 6
6 0 0 0 0 0 6 5 6 6
6 6 6 6 6 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 0 6 6 0 6 6 5 6 6
6 0 0 0 0 6 6 5 6 6
6 6 6 6 6 6 6 5 6 6
```


**output:**
```
6 6 0 0 0 0 0 5 6 6
6 6 0 6 6 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 0 0 0 0 0 5 6 6
6 6 0 6 0 6 0 5 2 2
6 6 0 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
6 6 6 0 0 0 0 5 6 6
6 6 6 0 6 6 0 5 2 2
6 6 6 0 0 0 0 5 6 6
6 6 6 6 6 6 6 5 6 6
```

*   **Perception:**
    *   The input and output are grids of pixels.
    *   The primary colors involved are white (0), magenta (6), gray (5), and red (2).
    *   A prominent feature in the input grid is a single vertical line composed of gray (5) pixels. This line acts as a barrier.
    *   To the left of the gray line, there are regions or objects composed of white (0) pixels, set against a background of magenta (6) pixels.
    *   The transformation involves shifting these white objects horizontally to the right.
    *   Each distinct contiguous white object calculates its own shift distance. The object shifts rightwards until its rightmost edge is immediately adjacent to the left of the gray line (i.e., in the column `gray_line_column - 1`).
    *   The original positions of the shifted white pixels are changed to magenta (6).
    *   If a white object is shifted (i.e., its shift distance is greater than 0), new red (2) pixels appear in the output grid.
    *   These red pixels form rectangular blocks located immediately to the right of the gray line.
    *   Red pixels only appear in rows where a shifted white object's rightmost edge ended up adjacent to the gray line after the shift.
    *   The width of the red rectangular block seems consistent within a single task example but varies between examples (4 in train_1, 4 in train_2, 2 in train_3). The exact determination of this width is not immediately obvious from the provided examples alone but seems related to the rows where shifted objects collide with the barrier. Pixels to the right of the gray line, not replaced by red, retain their original color from the input.

*   **Facts:**
    
```yaml
    Grid:
      type: 2D array of integers (pixels)
      colors: [0, 2, 5, 6] # white, red, gray, magenta primarily involved
      size: variable (e.g., 16x16, 16x10, 20x10)

    Objects:
      - type: Gray_Line
        color: 5
        shape: vertical line (1 pixel wide)
        location: specific column index C
        role: barrier
      - type: White_Object
        color: 0
        shape: contiguous region of pixels
        location: left of Gray_Line (column index < C)
        properties:
          - bounding_box
          - rightmost_column_index
      - type: Background
        color: 6 (magenta)
        location: fills space around White_Objects left of Gray_Line
      - type: Red_Region
        color: 2
        shape: rectangle
        location: right of Gray_Line (column index > C)
        status: appears only in output

    Relationships:
      - White_Objects are positioned relative to the Gray_Line.
      - Red_Regions appear adjacent to the Gray_Line in the output.
      - Red_Regions appear only in rows corresponding to White_Objects that shifted and reached the column C-1.

    Actions:
      - Identify the column index 'C' of the Gray_Line.
      - Identify all contiguous White_Objects left of column C.
      - For each White_Object:
          - Find its rightmost column index 'max_c_obj'.
          - Calculate shift distance: 'shift = (C - 1) - max_c_obj'.
      - Create the output grid (initially copy of input, or magenta background).
      - Copy the Gray_Line and everything to its right from input to output.
      - For each White_Object:
          - If shift > 0:
              - For each pixel (r, c) in the object:
                  - Set output[r, c] = 6 (magenta).
              - For each pixel (r, c) in the object:
                  - Set output[r, c + shift] = 0 (white).
              - Identify rows 'R_touch' where shifted pixels land at column C-1.
              - Determine the width 'W_red' for the Red_Region (e.g., 4 for train_1/2, 2 for train_3).
              - For each row 'r' in 'R_touch':
                  - Fill output[r, C+1 : C+1+W_red] = 2 (red).
          - If shift == 0:
              - Copy the White_Object pixels to the output without change.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Identify the column index `C` of the vertical gray (5) line.
    3.  Find all distinct contiguous objects composed of white (0) pixels located entirely in columns less than `C`.
    4.  For each white object identified:
        a.  Determine the maximum column index `max_c` occupied by any pixel within that object.
        b.  Calculate the shift distance required for this object: `shift = (C - 1) - max_c`.
        c.  If `shift` is greater than 0:
            i.  Keep track of the rows `R_touch` where pixels of this object originally existed at column `max_c`.
            ii. For every pixel `(r, c)` belonging to this object in the input grid, change the corresponding pixel `(r, c)` in the output grid to magenta (6).
            iii.For every pixel `(r, c)` belonging to this object in the input grid, change the pixel `(r, c + shift)` in the output grid to white (0).
            iv. Determine the width `W_red` for the red region associated with this task (this seems to be a fixed value per task, e.g., 4 for the first two examples, 2 for the third).
            v.  For each row `r` in `R_touch`, set the pixels in the output grid from column `C + 1` to `C + W_red` (inclusive) to red (2).
    5.  Leave all other pixels in the output grid (the gray line, pixels to its right not overwritten by red, magenta background pixels not part of an original white object, and unshifted white objects) unchanged from their initial state (copied from the input).
