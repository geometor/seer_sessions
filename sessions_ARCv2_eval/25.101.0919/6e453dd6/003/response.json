{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on object movement and boundary interaction rules:\n1.  Identify a vertical gray line (color 5) acting as a barrier.\n2.  Calculate the width for potential red regions (`w_red`) based on the number \n    of contiguous all-magenta (color 6) columns immediately to the right of the \n    gray line in the input grid, capped at a maximum width of 4.\n3.  Find all distinct contiguous white objects (color 0) located entirely to the \n    left of the gray line.\n4.  For each white object:\n    a.  Determine its rightmost column (`max_c`).\n    b.  Calculate the necessary horizontal shift (`shift`) to move its rightmost \n        edge to the column immediately left of the gray line (`gray_col - 1`).\n    c.  If the shift is greater than 0, mark the object's original pixels for \n        erasure (change to magenta).\n    d.  Mark the object's pixels for drawing at their new, shifted positions.\n    e.  Determine the rows where the object's pixels land in the column \n        `gray_col - 1` after shifting (or originally, if shift is 0).\n5.  Apply the erasures and drawings to create an intermediate grid state.\n6.  Determine the final set of rows (`R_red`) that should receive red pixels. \n    This step involves a filtering rule applied to the rows identified in step 4e, \n    specifically for objects that required a shift > 0. The exact filtering rule \n    is currently uncertain but is hypothesized to be based on the interaction \n    at the boundary. **(Current implementation uses a placeholder/incorrect rule: \n    includes all rows touched by *shifted* objects at the boundary).**\n7.  If `w_red` is greater than 0, paint horizontal red segments (color 2) of \n    width `w_red` starting at column `gray_col + 1` for each row in the \n    final `R_red` set.\n\"\"\"\n\n# Color constants\nWHITE = 0\nRED = 2\nGRAY = 5\nMAGENTA = 6\n\ndef find_gray_line_col(grid: np.ndarray) -> int:\n    \"\"\"Finds the column index of the vertical gray line.\"\"\"\n    rows, cols = grid.shape\n    for c in range(cols):\n        # Prioritize solid gray lines\n        if np.all(grid[:, c] == GRAY):\n            return c\n    # Fallback: find first column with a majority of gray pixels (heuristic)\n    for c in range(cols):\n         if np.sum(grid[:, c] == GRAY) > rows // 2:\n             return c\n    return -1 # Indicate not found\n\ndef calculate_red_width(grid: np.ndarray, gray_col: int) -> int:\n    \"\"\"Calculates the width of the red region based on contiguous magenta columns.\"\"\"\n    rows, cols = grid.shape\n    contiguous_magenta_cols = 0\n    if gray_col != -1 and gray_col + 1 < cols:\n        for c_check in range(gray_col + 1, cols):\n            if np.all(grid[:, c_check] == MAGENTA):\n                contiguous_magenta_cols += 1\n            else:\n                break\n    # Cap width at 4 based on observations\n    return min(4, contiguous_magenta_cols)\n\ndef find_objects(grid: np.ndarray, color: int, max_col: int) -> list[list[tuple[int, int]]]:\n    \"\"\"Finds connected objects of a specific color strictly left of max_col.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        # Only search columns left of the barrier\n        for c in range(max_col):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                is_valid_object = True # Assume valid until proven otherwise\n                current_obj_visited_in_bfs = set([(r,c)])\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Crucial Check: Ensure the *entire* object is left of max_col\n                    if col >= max_col:\n                        is_valid_object = False\n                        # Continue BFS to mark all connected pixels, but invalidate object\n                    \n                    obj_coords.append((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        neighbor = (nr, nc)\n                        \n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and \\\n                           not visited[nr, nc] and \\\n                           neighbor not in current_obj_visited_in_bfs:\n                            \n                            visited[nr, nc] = True\n                            current_obj_visited_in_bfs.add(neighbor)\n                            q.append(neighbor)\n                \n                if is_valid_object and obj_coords:\n                    objects.append(obj_coords)\n                    \n    return objects\n\ndef get_object_properties(obj_coords: list[tuple[int, int]]) -> tuple[int, set[int]]:\n    \"\"\"Calculates the rightmost column and the set of rows touching that column.\"\"\"\n    if not obj_coords:\n        return -1, set()\n    max_c = -1\n    for _, c in obj_coords:\n        max_c = max(max_c, c)\n    touching_rows = {r for r, c in obj_coords if c == max_c}\n    return max_c, touching_rows\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Applies the object shifting and red region painting transformation.\"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    output_arr = np.copy(input_arr)\n    rows, cols = input_arr.shape\n\n    # --- Step 1: Find the gray line column ---\n    gray_col = find_gray_line_col(input_arr)\n    if gray_col == -1:\n        # Cannot proceed without the barrier\n        return input_grid\n\n    # --- Step 2: Calculate red width ---\n    w_red = calculate_red_width(input_arr, gray_col)\n\n    # --- Step 3: Find white objects ---\n    # Search strictly left of the gray column\n    white_objects = find_objects(input_arr, WHITE, max_col=gray_col)\n\n    # --- Step 4 & 5: Prepare modification lists ---\n    coords_to_erase = []\n    coords_to_draw = []\n    # Store info for determining red rows later: (object_index, final_touch_rows, was_shifted)\n    boundary_touchers_info = [] \n\n    for idx, obj_coords in enumerate(white_objects):\n        if not obj_coords: continue\n\n        max_c, _ = get_object_properties(obj_coords) # Original touching rows not directly needed here\n        \n        # Calculate shift\n        shift = 0\n        if max_c != -1 : # Ensure object exists\n             shift = max(0, (gray_col - 1) - max_c)\n\n        final_touch_rows_for_obj = set()\n        object_shifted = shift > 0\n\n        # Collect coords for drawing and check final boundary touches\n        for r, c in obj_coords:\n            new_c = c + shift\n            # Ensure drawing happens within bounds and left of gray line\n            if 0 <= r < rows and 0 <= new_c < gray_col:\n                 coords_to_draw.append((r, new_c))\n                 if new_c == gray_col - 1:\n                     final_touch_rows_for_obj.add(r)\n        \n        # Collect coords for erasing if shifted\n        if object_shifted:\n            coords_to_erase.extend(obj_coords)\n\n        # Store info if object touches boundary in final state\n        if final_touch_rows_for_obj:\n             boundary_touchers_info.append({\n                 'id': idx, \n                 'final_touch_rows': final_touch_rows_for_obj,\n                 'shifted': object_shifted\n                 })\n\n    # --- Step 6: Apply modifications ---\n    # Erase original positions first\n    for r, c in coords_to_erase:\n        if 0 <= r < rows and 0 <= c < cols: # Boundary check\n            output_arr[r, c] = MAGENTA\n\n    # Draw objects in new positions\n    for r, c_new in coords_to_draw:\n         if 0 <= r < rows and 0 <= c_new < cols: # Boundary check\n            output_arr[r, c_new] = WHITE\n\n    # --- Step 7: Determine R_red (rows to paint red) ---\n    # !!! Placeholder Logic: Select rows touched by SHIFTED objects only !!!\n    # This is known to be incorrect based on test results, but serves as a structure.\n    # The correct logic needs to filter `final_touch_rows` based on the unknown rule.\n    R_red = set()\n    for info in boundary_touchers_info:\n        if info['shifted']: # Apply the filter (currently just checks if shifted)\n            R_red.update(info['final_touch_rows'])\n            \n    # --- Step 8: Paint red regions ---\n    if w_red > 0 and R_red:\n        red_start_col = gray_col + 1\n        red_end_col = min(cols, red_start_col + w_red) # Ensure stay within bounds\n        \n        for r in R_red:\n            if 0 <= r < rows and red_start_col < red_end_col: # Check row and col bounds\n                 output_arr[r, red_start_col:red_end_col] = RED\n\n    # Convert back to list of lists\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16610,
    "candidates_token_count": 2799,
    "total_token_count": 19409,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.111222,
  "retries": 1
}