{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n1.  Create the output grid by copying the input grid.\n2.  Locate the vertical gray (5) line and identify its column index, `gray_col`. If no gray line is found, return the initial copy.\n3.  Calculate the width for the red regions, `w_red`, by counting the number of consecutive columns starting immediately to the right of the gray line (`gray_col + 1`) in the *input* grid that consist entirely of magenta (6) pixels. The width `w_red` is this count, capped at a maximum of 4.\n4.  Identify all distinct contiguous white (0) objects located entirely to the left of the gray line (`gray_col`) in the input grid using 4-connectivity.\n5.  For each white object identified:\n    a.  Determine its rightmost column index, `max_c`.\n    b.  Calculate the horizontal shift distance needed: `shift = max(0, (gray_col - 1) - max_c)`.\n    c.  Determine if the object was shifted (`shifted = shift > 0`).\n    d.  Find the set of rows (`final_touch_rows`) where the object's pixels will reside in the column `gray_col - 1` in the output grid (after applying the shift).\n6.  Perform the object movement on the output grid:\n    a.  For every white object that `shifted`, change all its original pixel locations `(r, c)` in the output grid to magenta (6).\n    b.  For every white object, draw its pixels at their new locations `(r, c + shift)` in the output grid using white (0), ensuring `c + shift` is less than `gray_col`.\n7.  Determine the final set of rows (`R_red`) that will receive red pixels:\n    a.  Initialize `R_red` as an empty set.\n    b.  For each white object that has a non-empty `final_touch_rows` set (i.e., it touches the boundary column `gray_col - 1` in the output):\n        i.  Identify the contiguous vertical segments within its `final_touch_rows`. (e.g., if `final_touch_rows` is `{7, 8, 9, 11}`, the segments are `{7, 8, 9}` and `{11}`).\n        ii. For each segment found:\n            *   If the segment contains 3 or more rows: Add all rows from that segment to `R_red`, *except* for the smallest (topmost) row index and the largest (bottommost) row index within that segment.\n            *   If the segment contains fewer than 3 rows, it contributes nothing to `R_red`.\n8.  If the calculated `w_red` is greater than 0, paint the red regions: For each row index `r` in the final `R_red` set, change the pixels in the output grid from column `gray_col + 1` up to (but not including) column `gray_col + 1 + w_red` to red (2). Do not paint outside the grid's boundaries.\n9.  Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\n# Color constants\nWHITE = 0\nRED = 2\nGRAY = 5\nMAGENTA = 6\n\ndef find_gray_line_col(grid: np.ndarray) -> int:\n    \"\"\"Finds the column index of the vertical gray line.\"\"\"\n    rows, cols = grid.shape\n    for c in range(cols):\n        # Prioritize solid gray lines\n        if np.all(grid[:, c] == GRAY):\n            return c\n    # Fallback: find first column with a majority of gray pixels (heuristic)\n    for c in range(cols):\n         if np.sum(grid[:, c] == GRAY) > rows // 2:\n             return c\n    return -1 # Indicate not found\n\ndef calculate_red_width(grid: np.ndarray, gray_col: int) -> int:\n    \"\"\"Calculates the width of the red region based on contiguous magenta columns in input.\"\"\"\n    rows, cols = grid.shape\n    contiguous_magenta_cols = 0\n    if gray_col != -1 and gray_col + 1 < cols:\n        for c_check in range(gray_col + 1, cols):\n            if np.all(grid[:, c_check] == MAGENTA):\n                contiguous_magenta_cols += 1\n            else:\n                break\n    # Cap width at 4 based on observations\n    return min(4, contiguous_magenta_cols)\n\ndef find_objects(grid: np.ndarray, color: int, max_col: int) -> list[list[tuple[int, int]]]:\n    \"\"\"\n    Finds connected objects (4-connectivity) of a specific color strictly left of max_col.\n    Returns a list of objects, where each object is a list of its (row, col) coordinates.\n    Ensures entire object is within bounds.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(rows):\n        # Only start searching in columns strictly less than max_col\n        for c in range(max_col):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_obj_visited = set([(r,c)]) # Track visited within this BFS\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.append((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        neighbor = (nr, nc)\n\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and \\\n                           not visited[nr, nc] and \\\n                           neighbor not in current_obj_visited:\n\n                            visited[nr, nc] = True\n                            current_obj_visited.add(neighbor)\n                            q.append(neighbor)\n\n                # Final validity check: Ensure ALL pixels of the found object are < max_col\n                final_is_valid = all(obj_c < max_col for _, obj_c in obj_coords)\n\n                if final_is_valid and obj_coords:\n                    objects.append(obj_coords)\n                else:\n                     # If invalid, ensure all explored pixels are marked visited anyway\n                     # This prevents re-starting BFS from parts of an invalid object\n                     for vr, vc in obj_coords:\n                         if 0 <= vr < rows and 0 <= vc < cols:\n                            visited[vr,vc] = True\n    return objects\n\n\ndef get_object_max_c(obj_coords: list[tuple[int, int]]) -> int:\n    \"\"\"Calculates the rightmost column index for an object.\"\"\"\n    if not obj_coords:\n        return -1\n    return max(c for _, c in obj_coords)\n\ndef get_contiguous_segments(rows_set: set[int]) -> list[list[int]]:\n    \"\"\" Groups a set of row indices into lists of contiguous segments. \"\"\"\n    if not rows_set:\n        return []\n\n    sorted_rows = sorted(list(rows_set))\n    segments = []\n    current_segment = [sorted_rows[0]]\n\n    for i in range(1, len(sorted_rows)):\n        if sorted_rows[i] == sorted_rows[i-1] + 1:\n            current_segment.append(sorted_rows[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [sorted_rows[i]]\n    segments.append(current_segment) # Add the last segment\n    return segments\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\" Applies the object shifting and red region painting transformation based on boundary interactions.\"\"\"\n    \n    # Initialize grid\n    input_arr = np.array(input_grid, dtype=int)\n    output_arr = np.copy(input_arr)\n    rows, cols = input_arr.shape\n\n    # --- Step 2: Find the gray line column ---\n    gray_col = find_gray_line_col(input_arr)\n    if gray_col == -1:\n        # Cannot proceed without the barrier\n        return input_grid # Return the copy\n\n    # --- Step 3: Calculate red width ---\n    w_red = calculate_red_width(input_arr, gray_col)\n\n    # --- Step 4: Find white objects ---\n    # Search strictly left of the gray column\n    white_objects = find_objects(input_arr, WHITE, max_col=gray_col)\n\n    # --- Step 5 & 6 prep: Calculate shifts and identify boundary interactions ---\n    coords_to_erase = []\n    coords_to_draw = []\n    # Store info needed for red row calculation: (object_index, final_touch_rows)\n    boundary_touchers_info = [] \n\n    for idx, obj_coords in enumerate(white_objects):\n        if not obj_coords: continue\n\n        # 5a: Get object's original rightmost column\n        max_c = get_object_max_c(obj_coords)\n        \n        # 5b: Calculate shift\n        shift = 0\n        if max_c != -1 : # Ensure object exists\n             shift = max(0, (gray_col - 1) - max_c)\n\n        # 5c: Determine if shifted\n        object_shifted = shift > 0\n        \n        # 5d: Find rows touching the boundary in the final state\n        final_touch_rows_for_obj = set()\n        target_coords_for_obj = [] # Collect target coords for drawing later\n\n        for r, c in obj_coords:\n            new_c = c + shift\n            # Ensure drawing happens within bounds and left of gray line\n            if 0 <= r < rows and 0 <= new_c < gray_col:\n                 target_coords_for_obj.append((r, new_c))\n                 if new_c == gray_col - 1:\n                     final_touch_rows_for_obj.add(r)\n        \n        # Store info for drawing\n        coords_to_draw.extend(target_coords_for_obj)\n        \n        # Store coords for erasing if shifted\n        if object_shifted:\n            coords_to_erase.extend(obj_coords)\n\n        # Store info if object touches boundary in final state (for red row calculation)\n        if final_touch_rows_for_obj:\n             boundary_touchers_info.append({\n                 'id': idx, \n                 'final_touch_rows': final_touch_rows_for_obj,\n                 # 'shifted' status not strictly needed for Hypothesis 12 rule\n             })\n\n    # --- Step 6: Apply modifications (object movement) ---\n    # Erase original positions first for shifted objects\n    for r, c in coords_to_erase:\n        if 0 <= r < rows and 0 <= c < cols: # Boundary check\n            output_arr[r, c] = MAGENTA\n\n    # Draw objects in new positions (handles shifted and unshifted)\n    for r, c_new in coords_to_draw:\n         if 0 <= r < rows and 0 <= c_new < cols: # Boundary check\n            output_arr[r, c_new] = WHITE\n\n    # --- Step 7: Determine R_red (rows to paint red) using Hypothesis 12 ---\n    R_red = set()\n    for info in boundary_touchers_info:\n        touch_rows = info['final_touch_rows']\n        # 7bi: Find contiguous vertical segments\n        segments = get_contiguous_segments(touch_rows)\n        \n        # 7bii: Apply filtering rule based on segment length\n        for segment in segments:\n            seg_len = len(segment)\n            if seg_len >= 3:\n                min_r_seg, max_r_seg = min(segment), max(segment)\n                # Add all rows except the min and max of the segment\n                R_red.update({r for r in segment if r != min_r_seg and r != max_r_seg})\n\n    # --- Step 8: Paint red regions ---\n    if w_red > 0 and R_red:\n        red_start_col = gray_col + 1\n        # Calculate end column, ensuring it doesn't exceed grid bounds\n        red_end_col = min(cols, red_start_col + w_red) \n        \n        for r in R_red:\n             # Ensure row is valid and there are columns to paint\n             if 0 <= r < rows and red_start_col < red_end_col: \n                 output_arr[r, red_start_col:red_end_col] = RED\n\n    # --- Step 9: Return final grid ---\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 41251,
    "candidates_token_count": 3573,
    "total_token_count": 44824,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.387617,
  "retries": 1
}