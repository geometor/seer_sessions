{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nimport math\n\n\"\"\"\nApplies a conditional horizontal alignment based on an isolated marker.\n\n1.  Determines the background color (most common color).\n2.  Finds all 'isolated markers': single non-background pixels with no adjacent non-background neighbors (8-way).\n3.  If no isolated markers exist, returns the input grid unchanged.\n4.  Identifies the 'reference marker': the isolated marker with the smallest row index, then smallest column index. Records its column (`ref_col`) and color (`ref_color`).\n5.  Creates an output grid filled with the background color.\n6.  Places the reference marker pixel at its original coordinates in the output grid.\n7.  For every other isolated marker, places its color in the output grid at its original row but in column `ref_col`.\n8.  Finds all 'objects': connected components (8-way) of non-background pixels with size > 1, or single non-background pixels that were not isolated.\n9.  For each object:\n    a. Calculates its geometric center column (`center_col`) by rounding the mean of its pixel column indices.\n    b. Checks if the object contains any pixel matching the `ref_color`.\n    c. Determines the horizontal shift (`dx`):\n        i.  If the object contains the `ref_color`:\n            1.  Finds the top-most, left-most pixel within the object having the `ref_color`. Records its column as `local_ref_c`.\n            2.  If `abs(center_col - local_ref_c) <= 1`, sets `dx = ref_col - local_ref_c`.\n            3.  Else, sets `dx = ref_col - center_col`.\n        ii. If the object does not contain the `ref_color`, sets `dx = ref_col - center_col`.\n    d. Applies the shift: For each pixel `(r, c)` in the object, places its original color into the output grid at `(r, c + dx)`, checking bounds. Overwrites are possible.\n10. Returns the completed output grid.\n\n(Note: This procedure is based on Examples 1 and 3. Example 2 requires a different transformation logic.)\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color, assumed to be the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    if counts.size == 0: return -1 # Handle empty grid case\n    return colors[np.argmax(counts)]\n\ndef find_components(grid: np.ndarray, background_color: int) -> list[dict]:\n    \"\"\"\n    Finds all connected components of non-background pixels using BFS (8-way connectivity).\n    Returns a list of dictionaries, each representing a component with its pixels and size.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n    component_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            # Find the start of a new component\n            if grid[r, c] != background_color and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Perform BFS to find all connected pixels\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if it's a non-background pixel not yet visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != background_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store the found component\n                if component_pixels:\n                    components.append({\n                        'id': component_id_counter,\n                        'pixels': sorted(component_pixels), # Sort for consistency\n                        'size': len(component_pixels)\n                    })\n                    component_id_counter += 1\n    return components\n\ndef is_isolated(pixel_coord: tuple[int, int], all_non_bg_coords: set[tuple[int, int]], rows: int, cols: int) -> bool:\n    \"\"\"Checks if a single pixel has no non-background neighbors (8-way).\"\"\"\n    r, c = pixel_coord\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds AND is a non-background pixel\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in all_non_bg_coords:\n                return False # Found a non-background neighbor\n    return True # No non-background neighbors found\n\ndef get_component_center_col(component_pixels: list[tuple[int, int]]) -> int:\n    \"\"\"Calculates the center column by rounding the mean of column indices.\"\"\"\n    if not component_pixels: return -1\n    cols = [c for r, c in component_pixels]\n    return int(round(np.mean(cols)))\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Convert input to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Handle edge case: empty grid\n    if rows == 0 or cols == 0:\n        return input_grid\n\n    # 1. Determine the background color\n    background_color = find_background(input_np)\n    if background_color == -1: # Grid was likely empty or had issues\n         return input_grid\n\n    # 2. Find all non-background coordinates (used for isolation checks)\n    all_non_bg_coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] != background_color:\n                all_non_bg_coords.add((r, c))\n\n    # Handle edge case: grid contains only background color\n    if not all_non_bg_coords:\n        return input_grid \n\n    # 3. Find all connected components\n    all_components = find_components(input_np, background_color)\n    if not all_components:\n         # This case should ideally not be reached if all_non_bg_coords is populated\n         return input_grid \n\n    # 4. Identify isolated markers and objects\n    isolated_markers = [] # Stores {'id': comp_id, 'pixel': (r,c), 'color': color}\n    objects = [] # Stores component dictionaries {'id': comp_id, 'pixels': [...], 'size': size}\n    \n    for comp in all_components:\n        if comp['size'] == 1:\n            pixel_coord = comp['pixels'][0]\n            # Check for strict isolation (needs all_non_bg_coords *excluding itself*)\n            if is_isolated(pixel_coord, all_non_bg_coords - {pixel_coord}, rows, cols):\n                 isolated_markers.append({\n                     'id': comp['id'], \n                     'pixel': pixel_coord, \n                     'color': input_np[pixel_coord]\n                 })\n            else:\n                 # Non-isolated single pixel, treat as object\n                 objects.append(comp) \n        else:\n            # Multi-pixel component, treat as object\n            objects.append(comp)\n\n    # 5. Determine reference marker and column\n    if not isolated_markers:\n        # No isolated markers found, return input unchanged as per rule\n        return input_grid \n\n    # Sort markers by row, then column to find the top-most, left-most\n    isolated_markers.sort(key=lambda m: m['pixel']) \n    ref_marker = isolated_markers[0]\n    ref_col = ref_marker['pixel'][1]\n    ref_color = ref_marker['color']\n    \n    # 6. Initialize output grid\n    output_np = np.full_like(input_np, background_color)\n\n    # 7. Place the reference marker at its original position\n    ref_r, ref_c = ref_marker['pixel']\n    # Ensure marker is within bounds (should always be true)\n    if 0 <= ref_r < rows and 0 <= ref_c < cols:\n        output_np[ref_r, ref_c] = ref_marker['color']\n\n    # 8. Place other isolated markers at the reference column\n    for marker in isolated_markers[1:]:\n        r, _ = marker['pixel'] # Original row\n        color = marker['color']\n        new_c = ref_col\n        # Check bounds before writing\n        if 0 <= r < rows and 0 <= new_c < cols:\n            output_np[r, new_c] = color\n\n    # 9. Process and move objects\n    for obj_comp in objects:\n        obj_pixels = obj_comp['pixels']\n        \n        # Calculate geometric center column\n        center_col = get_component_center_col(obj_pixels)\n        if center_col == -1: continue # Skip if object is empty (shouldn't happen)\n\n        # Check if object contains the reference color and find local ref column if it does\n        contains_ref_color = False\n        local_ref_c = -1\n        ref_color_pixels = []\n        for r, c in obj_pixels:\n            if input_np[r, c] == ref_color:\n                contains_ref_color = True\n                ref_color_pixels.append((r, c))\n        \n        # Determine the horizontal shift (dx) based on the V4 hypothesis\n        dx = 0 # Default shift if no rule applied (shouldn't happen with valid objects)\n        if contains_ref_color:\n            # Sort pixels with ref_color to find top-left one\n            ref_color_pixels.sort()\n            local_ref_c = ref_color_pixels[0][1]\n            \n            # Check distance between geometric center and local ref point\n            if abs(center_col - local_ref_c) <= 1:\n                # Rule: Use local reference point alignment\n                dx = ref_col - local_ref_c\n            else:\n                # Rule: Local reference point too far, use geometric center alignment\n                dx = ref_col - center_col\n        else:\n            # Rule: Object doesn't contain ref color, use geometric center alignment\n            dx = ref_col - center_col\n\n        # Apply the calculated shift dx to each pixel of the object\n        for (r, c) in obj_pixels:\n            new_c = c + dx\n            # Check bounds before writing to output grid\n            if 0 <= r < rows and 0 <= new_c < cols:\n                # Use original color from input grid\n                output_np[r, new_c] = input_np[r, c] \n\n    # 10. Convert the result back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40493,
    "candidates_token_count": 3336,
    "total_token_count": 43829,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.490283,
  "retries": 1
}