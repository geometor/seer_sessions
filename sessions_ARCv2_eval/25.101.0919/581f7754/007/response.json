{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nimport math\n\n\"\"\"\nApplies a conditional horizontal alignment based on an isolated marker (Pattern Observed in Examples 1 & 3).\n\n1.  Identifies the background color (most common color).\n2.  Finds all 'isolated markers': single non-background pixels with no adjacent non-background neighbors (8-way).\n3.  If no isolated markers exist, returns the input grid unchanged.\n4.  Identifies the 'reference marker': the isolated marker with the smallest row index, then smallest column index. Records its column (`ref_col`) and color (`ref_color`).\n5.  Creates an output grid filled with the background color.\n6.  Places the reference marker pixel at its original coordinates in the output grid (it does not move).\n7.  For every other isolated marker, places its color in the output grid at its original row but in column `ref_col`.\n8.  Finds all 'objects': connected components (8-way) of non-background pixels with size > 1, or single non-background pixels that were not isolated.\n9.  For each object:\n    a. Calculates its geometric center column (`center_col`) by rounding the mean of its pixel column indices.\n    b. Checks if the object contains any pixel matching the `ref_color`.\n    c. Determines the horizontal shift (`dx`):\n        i.  If the object contains the `ref_color`:\n            1.  Finds the top-most, left-most pixel within the object having the `ref_color`. Records its column as `local_ref_c`.\n            2.  If `abs(center_col - local_ref_c) <= 1`, sets `dx = ref_col - local_ref_c`.\n            3.  Else, sets `dx = ref_col - center_col`.\n        ii. If the object does not contain the `ref_color`, sets `dx = ref_col - center_col`.\n    d. Applies the shift: For each pixel `(r, c)` in the object, places its original color into the output grid at `(r, c + dx)`, checking bounds. Overwrites are possible.\n10. Returns the completed output grid.\n\n(Disclaimer: This program describes the transformation logic observed in Examples 1 and 3. It does not apply to Example 2, which follows a distinct and more complex set of rules involving vertical movement and different marker interactions.)\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color, assumed to be the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    # Handle case where grid is empty or has no elements\n    if counts.size == 0: \n        return -1 # Return an invalid color index\n    return colors[np.argmax(counts)]\n\ndef find_components(grid: np.ndarray, background_color: int) -> list[dict]:\n    \"\"\"\n    Finds all connected components of non-background pixels using BFS (8-way connectivity).\n    Returns a list of dictionaries, each representing a component with its pixels and size.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n    component_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            # Find the start of a new component (non-background and not visited)\n            if grid[r, c] != background_color and not visited[r, c]:\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Perform BFS to find all connected pixels\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if it's a non-background pixel not yet visited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != background_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                # Store the found component if it has pixels\n                if component_pixels:\n                    components.append({\n                        'id': component_id_counter,\n                        # Sort pixels for consistent ordering (e.g., finding top-left)\n                        'pixels': sorted(component_pixels), \n                        'size': len(component_pixels)\n                    })\n                    component_id_counter += 1\n    return components\n\ndef is_isolated(pixel_coord: tuple[int, int], all_non_bg_coords: set[tuple[int, int]], rows: int, cols: int) -> bool:\n    \"\"\"Checks if a single pixel has no non-background neighbors (8-way).\"\"\"\n    r, c = pixel_coord\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue # Skip self\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is within bounds AND is a non-background pixel\n            # The check `(nr, nc) in all_non_bg_coords` implicitly handles bounds if \n            # all_non_bg_coords was generated correctly, but explicit bounds check is safer.\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in all_non_bg_coords:\n                return False # Found a non-background neighbor\n    return True # No non-background neighbors found\n\ndef get_component_center_col(component_pixels: list[tuple[int, int]]) -> int:\n    \"\"\"Calculates the center column by rounding the mean of column indices.\"\"\"\n    # Handle empty component case\n    if not component_pixels: \n        return -1 \n    cols = [c for r, c in component_pixels]\n    # Use numpy mean for potentially better precision before rounding\n    return int(round(np.mean(cols)))\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid based on the conditional horizontal alignment rule \n    derived from Examples 1 and 3.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Handle edge case: empty grid\n    if rows == 0 or cols == 0:\n        return input_grid\n\n    # Step 1: Determine the background color\n    background_color = find_background(input_np)\n    # Handle case where find_background failed (e.g., empty array passed)\n    if background_color == -1: \n         return input_grid\n\n    # Step 2: Find all non-background coordinates (used for isolation checks)\n    all_non_bg_coords = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] != background_color:\n                all_non_bg_coords.add((r, c))\n\n    # Handle edge case: grid contains only background color\n    if not all_non_bg_coords:\n        return input_grid \n\n    # Step 3: Find all connected components\n    all_components = find_components(input_np, background_color)\n    # This check should be redundant if all_non_bg_coords is not empty, but good practice\n    if not all_components:\n         return input_grid \n\n    # Step 4: Identify isolated markers and objects\n    isolated_markers = [] # Stores {'id': comp_id, 'pixel': (r,c), 'color': color}\n    objects = [] # Stores component dictionaries {'id': comp_id, 'pixels': [...], 'size': size}\n    \n    for comp in all_components:\n        if comp['size'] == 1:\n            pixel_coord = comp['pixels'][0]\n            # Check for strict isolation (needs all_non_bg_coords *excluding itself*)\n            # Create a temporary set excluding the current pixel for the check\n            coords_without_self = all_non_bg_coords - {pixel_coord}\n            if is_isolated(pixel_coord, coords_without_self, rows, cols):\n                 isolated_markers.append({\n                     'id': comp['id'], \n                     'pixel': pixel_coord, \n                     'color': input_np[pixel_coord] # Get color from the grid\n                 })\n            else:\n                 # Non-isolated single pixel, treat as object\n                 objects.append(comp) \n        else:\n            # Multi-pixel component, treat as object\n            objects.append(comp)\n\n    # Step 3 (Early Exit): If no isolated markers are found, return input unchanged.\n    if not isolated_markers:\n        return input_grid \n\n    # Step 4: Identify the 'reference marker' and its properties\n    # Sort markers by row, then column to find the top-most, left-most\n    isolated_markers.sort(key=lambda m: m['pixel']) \n    ref_marker = isolated_markers[0]\n    ref_col = ref_marker['pixel'][1]\n    ref_color = ref_marker['color']\n    \n    # Step 5: Create a new output grid filled with the background color.\n    output_np = np.full_like(input_np, background_color)\n\n    # Step 6: Place the reference marker onto the output grid at its original input coordinates.\n    ref_r, ref_c = ref_marker['pixel']\n    # Check bounds just in case, although it should be valid if found\n    if 0 <= ref_r < rows and 0 <= ref_c < cols:\n        output_np[ref_r, ref_c] = ref_marker['color']\n\n    # Step 7: Place other isolated markers at the reference column\n    for marker in isolated_markers[1:]: # Iterate through markers *except* the first (reference) one\n        r, _ = marker['pixel'] # Original row\n        color = marker['color']\n        new_c = ref_col\n        # Check bounds before writing to the output grid\n        if 0 <= r < rows and 0 <= new_c < cols:\n            output_np[r, new_c] = color\n\n    # Step 8 & 9: Identify objects and determine/apply their shift\n    for obj_comp in objects:\n        obj_pixels = obj_comp['pixels']\n        \n        # Step 9a: Calculate geometric center column\n        center_col = get_component_center_col(obj_pixels)\n        # Skip if object is empty or center calculation failed\n        if center_col == -1: \n            continue \n\n        # Step 9b: Check if object contains the reference color\n        contains_ref_color = False\n        local_ref_c = -1\n        ref_color_pixels = [] # Store coordinates of pixels with the ref_color\n        for r, c in obj_pixels:\n            if input_np[r, c] == ref_color:\n                contains_ref_color = True\n                ref_color_pixels.append((r, c))\n        \n        # Step 9c: Determine the horizontal shift (dx) based on the conditional rule\n        dx = 0 # Initialize shift\n        if contains_ref_color:\n            # 9ci: Find the top-most, left-most pixel with the ref_color\n            # Pixels are already sorted in component finding, so the first one is it.\n            # Need to re-sort just the ref_color_pixels if they weren't inherently sorted.\n            ref_color_pixels.sort() # Ensure correct top-left pixel is chosen\n            local_ref_c = ref_color_pixels[0][1]\n            \n            # 9cii & 9ciii: Apply the distance check rule\n            if abs(center_col - local_ref_c) <= 1:\n                # Rule: Align using local reference color pixel\n                dx = ref_col - local_ref_c\n            else:\n                # Rule: Local reference point too far, use geometric center alignment\n                dx = ref_col - center_col\n        else:\n            # 9d: Object doesn't contain ref color, use geometric center alignment\n            dx = ref_col - center_col\n\n        # Step 10: Apply the calculated shift dx to each pixel of the object\n        for (r, c) in obj_pixels:\n            new_c = c + dx\n            # Check bounds before writing to output grid\n            if 0 <= r < rows and 0 <= new_c < cols:\n                # Use original color from input grid for the moved pixel\n                output_np[r, new_c] = input_np[r, c] \n\n    # Step 11: Convert the result back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 51635,
    "candidates_token_count": 3260,
    "total_token_count": 54895,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.764123,
  "retries": 1
}