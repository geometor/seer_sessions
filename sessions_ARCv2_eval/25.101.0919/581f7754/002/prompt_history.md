
## train_1

**input:**
```
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 8 8 8 1 1 1 1
1 8 4 8 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 8 1
1 1 1 1 8 8 4 1
1 1 1 1 1 1 8 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 8 1 8 1 1 1 1
1 8 4 8 1 1 1 1
1 8 1 8 1 1 1 1
1 8 8 8 1 1 1 1
1 1 1 1 1 4 1 1
```


**output:**
```
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 8 8 8 1
1 1 1 1 8 4 8 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 8 1 1
1 1 1 8 8 4 1 1
1 1 1 1 1 8 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 8 1 8 1
1 1 1 1 8 4 8 1
1 1 1 1 8 1 8 1
1 1 1 1 8 8 8 1
1 1 1 1 1 4 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 3 1 3 8 8 8 8 8 8 8 8 8
1 8 4 8 3 3 3 8 8 3 3 3 8 8 8 8 8 8 8 8 8
8 8 4 8 3 8 3 8 8 8 8 8 8 8 8 8 8 3 8 8 8
8 8 6 8 3 8 3 8 8 8 8 8 8 8 3 1 3 3 8 8 8
8 8 8 8 3 1 3 8 8 8 8 8 8 8 8 8 8 3 8 8 8
6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 3 8 3 3 3 8 8 8 8 8 8 3 8 8 8
1 8 4 8 3 1 3 8 3 1 3 8 8 8 3 1 3 3 8 8 8
8 8 4 8 8 8 8 8 3 3 3 8 8 8 8 8 8 3 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
6 8 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
3 3 3 3 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3 3
3 3 1 3 3 3 3 3 3 3 3
3 3 2 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 1 1 3 3 3
3 3 3 1 3 3 3 1 3 3 3
3 3 3 1 1 1 2 1 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 1 1 1 3 3 3 3
3 3 3 1 1 2 1 1 3 3 3
3 3 3 3 3 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 1 1 1 1 1 3 3 3 3 3
3 1 3 3 3 1 3 3 3 3 3
3 1 1 1 2 1 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 1 1 1 3 3 3 3 3
3 3 1 1 2 1 1 3 3 3 3
3 3 3 3 1 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3
```

Okay, let's break down this task.

**Perception of Task Elements:**

1.  **Grid Structure:** The input and output are 2D grids of colored pixels.
2.  **Background Color:** Each example has a dominant background color (Blue=1 in Ex1, Azure=8 in Ex2, Green=3 in Ex3) which remains largely unchanged.
3.  **Objects/Shapes:** There are distinct shapes or patterns made of non-background colors. These shapes appear to be the primary elements being manipulated. They are often composite, using 2 or more colors (e.g., Azure frame with Yellow center in Ex1, Blue frame with Red center in Ex3, Green shape with Blue center in Ex2).
4.  **Marker Elements:** In each example, there seem to be specific pixels or simple shapes (like isolated pixels or lines) that serve as references or markers. Their colors are distinct from the main moving shapes and the background (Yellow in Ex1, Magenta/Yellow in Ex2, Red in Ex3). These markers might remain static or move themselves.
5.  **Transformation:** The core transformation involves moving the identified objects/shapes horizontally across the grid. The background and the relative structure of the shapes themselves remain intact during the move. The distance and direction of the horizontal movement appear to be determined by the relationship between the object's horizontal position and the horizontal position of a reference marker.
6.  **Variability:** While the core idea seems consistent (horizontal movement relative to a marker), the specifics vary:
    *   Train 1: A single isolated marker pixel seems to define a target column, but the movement isn't perfectly aligning the object centers to it; there's a small offset in some cases.
    *   Train 2: Involves multiple potential marker types (isolated pixels, a vertical bar) and the markers themselves move, plus some objects appear to move vertically as well as horizontally.
    *   Train 3: Seems the clearest case where isolated marker pixels define a reference column, and objects move horizontally to align with that column based on their initial horizontal distance from it.

**YAML Facts:**


```yaml
Task: Horizontal alignment of objects based on a reference marker column.

Common_Elements:
  - Grid: 2D array of integer colors (0-9).
  - Background: A dominant color filling most of the grid, remains constant.
  - Objects:
    - Type: Contiguous shapes/patterns made of non-background colors.
    - Composition: Can be single-color or multi-color (e.g., frame and center).
    - Property: Have a location (e.g., center coordinates, bounding box).
  - Markers:
    - Type: Pixels or simple shapes (lines) of specific colors, distinct from objects and background.
    - Property: Have a location (coordinates).
    - Role: Act as a reference point for transformation.
    - Behavior: May be static or may move.

Transformation_Rule:
  - Action: Move identified objects horizontally.
  - Vertical_Movement: Generally none for objects (observed only in Train 2 for objects and markers).
  - Horizontal_Movement:
    - Trigger: Presence of marker(s) and object(s).
    - Determinant: The horizontal position (column index) of a specific reference marker pixel.
    - Calculation (Hypothesized based on Train 3):
      1. Identify the reference marker pixel (e.g., the isolated marker pixel with the lowest row index). Let its column be `ref_col`.
      2. For each object, identify its representative column (e.g., center column `obj_col`).
      3. Calculate horizontal shift `dx = ref_col - obj_col`.
      4. Apply shift `dx` to the object.
  - Preservation: The internal structure of objects and the background grid remain unchanged.

Variations:
  - Marker_Identification: Method to select the specific reference marker pixel might vary.
  - Movement_Calculation: Exact calculation of `dx` might have adjustments or alternatives (as seen in Train 1 offset, Train 2 complexity).
  - Marker_Movement: Markers themselves can move (Train 2, Train 3).
  - Vertical_Shift: Objects might shift vertically in some cases (Train 2).
```


**Natural Language Program:**

1.  Identify the background color (typically the most frequent color in the input grid).
2.  Identify all distinct objects/shapes in the input grid that are composed of non-background colors. Note their structure, colors, and locations (e.g., center coordinates or bounding box).
3.  Identify potential marker pixels/shapes. These are often isolated pixels or simple geometric forms (like lines) whose colors are distinct from the background and the main components of the movable objects.
4.  From the potential markers, determine the single "reference marker pixel". A common heuristic is to choose the marker pixel with the lowest row index, breaking ties using the lowest column index. Record the column index of this reference marker pixel (`ref_col`).
5.  Create the output grid, initially copying the background color from the input grid. Also, place any static markers or markers whose movement is independent of the main objects onto the output grid. (Note: Marker movement rules might be complex as seen in Train 2/3).
6.  For each identified movable object from step 2:
    a. Determine the object's representative horizontal position, typically the column index of its center (`obj_col`).
    b. Calculate the required horizontal shift: `dx = ref_col - obj_col`.
    c. Determine the object's new position by applying the horizontal shift `dx` to its original coordinates.
    d. Draw the object (preserving its internal structure and colors) at its new position onto the output grid.
7.  Return the completed output grid.
```python
import numpy as np
from collections import Counter, deque

"""
Identifies a background color, movable objects (multi-pixel components), and potential marker pixels (single-pixel components).
Determines a reference column based on the top-most, left-most marker pixel.
Shifts all movable objects and all marker pixels horizontally so that their center column aligns with the reference column.
The internal structure of objects is preserved during the shift.
"""

def find_connected_components(grid: np.ndarray, background_color: int) -> list[list[tuple[int, int]]]:
    """
    Finds all connected components of non-background pixels.
    Uses Breadth-First Search (BFS).
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != background_color and not visited[r, c]:
                component_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    component_pixels.append((row, col))
                    
                    # Check 8 neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue
                            nr, nc = row + dr, col + dc
                            
                            if 0 <= nr < rows and 0 <= nc < cols and \
                               grid[nr, nc] != background_color and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                
                if component_pixels:
                    components.append(component_pixels)
    return components

def get_component_center_col(component_pixels: list[tuple[int, int]]) -> int:
    """Calculates the approximate center column of a component."""
    if not component_pixels:
        return -1 # Should not happen for valid components
    cols = [c for r, c in component_pixels]
    # Using integer division for center calculation, consistent with grid indices
    # Alternative: round(np.mean(cols)) 
    # Using median might be more robust to outliers if shapes are complex/skewed
    # Using (min_col + max_col) // 2 is another option
    center_col = int(np.median(cols)) 
    # Let's use average rounded for potentially better centering
    center_col = int(round(np.mean(cols))) 
    return center_col
    

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Shifts non-background objects horizontally to align with a reference marker column.
    """
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape

    # 1. Identify background color (most frequent color)
    colors, counts = np.unique(input_np, return_counts=True)
    background_color = colors[np.argmax(counts)]

    # 2. Find all connected components of non-background colors
    all_components_pixels = find_connected_components(input_np, background_color)

    if not all_components_pixels:
        # No non-background elements, return input as is
        return input_grid

    # 3. Separate components into markers (single-pixel) and objects (multi-pixel)
    marker_components = []
    object_components = []
    for comp_pixels in all_components_pixels:
        if len(comp_pixels) == 1:
            marker_components.append(comp_pixels)
        else:
            object_components.append(comp_pixels)

    # 4. Determine the reference marker column
    ref_col = -1
    if marker_components:
        # Sort markers by row, then column to find the top-most, left-most
        marker_components.sort() 
        ref_marker_pixel = marker_components[0][0] # The single pixel (r, c)
        ref_col = ref_marker_pixel[1]
    else:
        # Fallback if no single-pixel markers? 
        # Based on examples, this seems unlikely for this specific task pattern.
        # If needed, could try using the center of the top-most object, etc.
        # For now, if no markers, maybe no movement? Return input.
         return input_grid # Or define alternative reference logic

    # 5. Initialize output grid with background color
    output_np = np.full_like(input_np, background_color)

    # 6. Process and move all components (markers and objects)
    all_components_to_move = marker_components + object_components
    
    for comp_pixels in all_components_to_move:
        # a. Get original colors and calculate center column
        original_colors = {pixel: input_np[pixel] for pixel in comp_pixels}
        comp_center_col = get_component_center_col(comp_pixels)
        
        # b. Calculate horizontal shift
        dx = ref_col - comp_center_col
        
        # c. Apply shift and draw onto output grid
        for (r, c) in comp_pixels:
            new_c = c + dx
            # Ensure the new position is within grid bounds
            if 0 <= r < rows and 0 <= new_c < cols:
                output_np[r, new_c] = original_colors[(r, c)]
            # else: pixel moves off-grid (discarded)

    # 7. Convert back to list of lists and return
    return output_np.tolist()
```
