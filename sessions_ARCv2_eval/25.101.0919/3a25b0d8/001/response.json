{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n# Helper function to find connected components (objects) using BFS\ndef find_objects(grid, color):\n    \"\"\"Finds all connected components of a given color in the grid.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            # If the cell has the target color and hasn't been visited yet\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check grid boundaries, target color, and visited status\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                # Add the found object (set of coordinates) to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\n# Helper function to get bounding box of a set of coordinates\ndef get_bounding_box(coords):\n    \"\"\"Calculates the min/max row/col for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    # Transpose coordinates if necessary (e.g., from find_objects)\n    if isinstance(coords, set) or isinstance(coords, list) and coords and isinstance(coords[0], tuple):\n       rows = [r for r, c in coords]\n       cols = [c for r, c in coords]\n    else: # Assume numpy array format N x 2\n       rows = coords[:, 0]\n       cols = coords[:, 1]\n\n    if not rows or not cols:\n        return None\n        \n    return min(rows), min(cols), max(rows), max(cols)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies patterns within 'containers' in the input grid and stacks them vertically,\n    applying a duplication rule for specific rows, and padding the result.\n\n    Transformation Steps:\n    1. Identify the background color (most frequent pixel value).\n    2. Find all contiguous objects for each color different from the background.\n    3. For each object (potential container):\n        a. Determine its bounding box.\n        b. Identify all pixels within this bounding box that are NOT the background color ('non-background pixels').\n        c. Identify all pixels within this bounding box that are NEITHER the background color NOR the container's color ('true content pixels').\n        d. If any 'true content pixels' exist for this container object:\n            i. Calculate the bounding box of the 'non-background pixels'.\n            ii. Extract the rectangular subgrid from the input corresponding to this non-background bounding box. This is the 'pattern'.\n            iii. Store the pattern, its top row index (min_r of non-background bbox), and the container color.\n    4. Sort the extracted patterns based on their top row index.\n    5. Assemble the final output grid row by row:\n        a. For each pattern, iterate through its rows.\n        b. Add the current row to the output list.\n        c. Apply duplication rule: If the 'true content pixels' in the current row consist of exactly 3 pixels of the same color, add the row to the output list again.\n    6. Pad all rows in the output list with the background color to match the width of the widest row.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Handle empty input grid\n    if grid.size == 0: return []\n    \n    # 1. Identify background color\n    counts = Counter(grid.flatten())\n    # If grid is uniform color, handle appropriately (e.g., return empty or original)\n    # For this task, assume diverse colors exist if examples show it.\n    if not counts: return [] \n    background_color = counts.most_common(1)[0][0]\n\n    # 2. Identify potential container colors\n    unique_colors = np.unique(grid)\n    potential_container_colors = [c for c in unique_colors if c != background_color]\n\n    patterns_data = []\n\n    # Keep track of objects already processed to avoid duplicates \n    processed_objects = set() \n\n    # 3. & 4. Find container objects and extract potential patterns\n    for container_color in potential_container_colors:\n        # Find all objects of the current potential container color\n        container_objects = find_objects(grid, container_color)\n        \n        for obj_coords in container_objects:\n            # Skip if object is empty\n            if not obj_coords: continue\n            \n            # Use frozenset of coordinates to check if this object was already processed\n            # This handles cases where an object might be found via different color searches if needed, though unlikely here.\n            obj_frozen = frozenset(obj_coords)\n            if obj_frozen in processed_objects:\n                continue\n            processed_objects.add(obj_frozen)\n\n            # 3a. Get container object's bounding box\n            c_bb = get_bounding_box(obj_coords)\n            if c_bb is None: continue\n            c_min_r, c_min_c, c_max_r, c_max_c = c_bb\n\n            # 3b. Find non-background pixels within container BBox\n            # Uses BBox as an approximation for \"inside\" the container for simplicity.\n            non_bg_coords = set()\n            for r in range(c_min_r, c_max_r + 1):\n                 for c in range(c_min_c, c_max_c + 1):\n                     # Check bounds and if pixel is not background\n                     if 0 <= r < height and 0 <= c < width and grid[r, c] != background_color:\n                         non_bg_coords.add((r,c))\n\n            # 3c. Find true content pixels (non-bg, non-container) within the set of non-bg pixels found\n            true_content_coords = set()\n            if non_bg_coords:\n                 for r, c in non_bg_coords:\n                     if grid[r,c] != container_color:\n                         true_content_coords.add((r,c))\n\n            # 3d. Check if true content exists for this object\n            if true_content_coords:\n                 # 3d.i. Get bounding box of *non-background* pixels associated with this object\n                 nb_bb = get_bounding_box(non_bg_coords)\n                 if nb_bb:\n                     nb_min_r, nb_min_c, nb_max_r, nb_max_c = nb_bb\n                     \n                     # Clamp bbox coordinates to grid dimensions to prevent slicing errors\n                     nb_min_r = max(0, nb_min_r)\n                     nb_max_r = min(height - 1, nb_max_r)\n                     nb_min_c = max(0, nb_min_c)\n                     nb_max_c = min(width - 1, nb_max_c)\n\n                     # Ensure bbox is still valid after clamping\n                     if nb_max_r >= nb_min_r and nb_max_c >= nb_min_c:\n                         # 3d.ii. Extract the pattern subgrid based on the non-background bounding box\n                         pattern = grid[nb_min_r:nb_max_r + 1, nb_min_c:nb_max_c + 1]\n                         # 3d.iii Store pattern data for later processing\n                         patterns_data.append({\n                             'min_row': nb_min_r, # Use the top of the non-bg bounding box for sorting\n                             'pattern': pattern.tolist(), # Convert numpy array to list of lists\n                             'container_color': container_color\n                         })\n\n    # 5. Sort patterns based on original vertical position (top of non-bg bbox)\n    patterns_data.sort(key=lambda x: x['min_row'])\n\n    # 6. Assemble output rows and apply duplication rule\n    output_rows_raw = []\n    for data in patterns_data:\n        pattern = data['pattern']\n        container_color = data['container_color']\n        # Iterate through each row of the extracted pattern\n        for row in pattern:\n            # 6a. Add current row to the list of rows to be potentially included in the output\n            output_rows_raw.append(list(row))\n\n            # 6b/c. Check for duplication rule\n            # Find pixels in the current row that are neither background nor the container color\n            true_content_pixels = [p for p in row if p != background_color and p != container_color]\n            \n            # Check if there are exactly 3 true content pixels\n            if len(true_content_pixels) == 3:\n                # Check if all three pixels are identical (only 1 unique color among them)\n                if len(set(true_content_pixels)) == 1:\n                     # If duplication rule met, add the row again\n                     output_rows_raw.append(list(row)) \n\n    # Handle case where no patterns were found or processed\n    if not output_rows_raw:\n         return []\n\n    # 7. Pad rows to max width\n    max_width = 0\n    # Find the maximum width among all collected rows\n    for row in output_rows_raw:\n        max_width = max(max_width, len(row))\n\n    output_grid_final = []\n    # Pad each row to the maximum width using the background color\n    for row in output_rows_raw:\n        current_width = len(row)\n        pad_total = max_width - current_width\n        # Calculate padding for left and right sides for centering\n        pad_left = pad_total // 2\n        pad_right = pad_total - pad_left\n        # Construct the padded row\n        padded_row = [background_color] * pad_left + row + [background_color] * pad_right\n        output_grid_final.append(padded_row)\n\n    return output_grid_final\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5001,
    "candidates_token_count": 22397,
    "total_token_count": 27398,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 164.373616,
  "retries": 1
}