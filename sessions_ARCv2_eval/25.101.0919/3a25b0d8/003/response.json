{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nfrom itertools import groupby\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent pixel value).\n2. Identify the 'container' color: This is the non-background color whose objects are most consistently found adjacent to objects of other diverse non-background colors ('true content').\n3. Find all distinct objects made of the container color.\n4. Filter these container objects, keeping only those that are adjacent to at least one 'true content' pixel (a pixel that is neither background nor container color).\n5. For each valid container object:\n    a. Find all 'true content' pixels adjacent to it.\n    b. Find all container pixels adjacent to these 'true content' pixels.\n    c. Combine the true content and adjacent container pixels to define the 'pattern coordinates'.\n    d. Calculate the bounding box of the 'pattern coordinates'.\n    e. Extract the subgrid ('pattern') from the input corresponding to this bounding box.\n    f. Record the pattern and the minimum row index of its 'true content' pixels.\n6. Sort the extracted patterns based on the minimum row index of their true content (top to bottom).\n7. Assemble the output rows:\n    a. Create a list by sequentially taking all rows from the sorted patterns.\n    b. Create a final list. Iterate through the assembled rows:\n        i. Add the current row to the final list.\n        ii. Identify the 'true content' pixels within the row.\n        iii. If these true content pixels form exactly one contiguous block of three identical pixels (X X X), add the row to the final list again.\n8. Pad the final list of rows: Calculate the maximum width and pad each row symmetrically with the background color to match this width.\n9. Construct the final output grid by stacking the padded rows.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color, connectivity=4):\n    \"\"\"\n    Finds all connected components of a given color using BFS.\n    Connectivity: 4 (von Neumann) or 8 (Moore).\n    Returns a list of sets, where each set contains (row, col) tuples for an object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    for dr, dc in deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets valid neighbor coordinates.\"\"\"\n    neighbors = set()\n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n        \n    for dr, dc in deltas:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.add((nr, nc))\n    return neighbors\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the min/max row/col for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    if not rows or not cols: return None # Handle empty lists case\n    return min(rows), min(cols), max(rows), max(cols)\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule described in the module docstring.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Handle empty or trivial grids\n    if grid.size == 0: return []\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    if len(unique_colors) <= 1: return input_grid # No transformation possible\n\n    # 1. Identify Background Color\n    background_color = unique_colors[np.argmax(counts)]\n    non_background_colors = [c for c in unique_colors if c != background_color]\n\n    # 2. Identify Container Color (Revised Strategy)\n    # Map potential container colors to the set of *other* non-background colors they are adjacent to.\n    adjacency_map = {color: set() for color in non_background_colors}\n    all_objects = {} # Store objects to avoid recalculating: {color: [obj1_coords, obj2_coords,...]}\n\n    for obj_color in non_background_colors:\n        if obj_color not in all_objects:\n            all_objects[obj_color] = find_objects(grid, obj_color, connectivity=4) # Use 4-connectivity for content objects\n\n        for obj_coords in all_objects[obj_color]:\n            adjacent_pixels = set()\n            for r, c in obj_coords:\n                # Find 8-way neighbors for adjacency check\n                neighbors = get_neighbors(r, c, height, width, connectivity=8)\n                adjacent_pixels.update(neighbors)\n            \n            # Remove pixels belonging to the object itself\n            adjacent_pixels -= obj_coords \n            \n            for nr, nc in adjacent_pixels:\n                neighbor_color = grid[nr, nc]\n                # If the neighbor is a potential container (non-bg) and different from the object's color\n                if neighbor_color != background_color and neighbor_color != obj_color:\n                    adjacency_map[neighbor_color].add(obj_color) # Record that neighbor_color is adjacent to obj_color\n\n    # Determine the container color: the one adjacent to the most *diverse* other non-background colors\n    container_color = -1\n    max_diversity = -1\n    for color, adjacent_to_colors in adjacency_map.items():\n        if len(adjacent_to_colors) > max_diversity:\n            max_diversity = len(adjacent_to_colors)\n            container_color = color\n        # Tie-breaking: if diversity is equal, maybe prefer the one with more total objects? (Not needed for examples)\n\n    if container_color == -1: # Fallback or error case\n        # Heuristic: If only one non-background color exists, it might be the container (though unlikely for this task type)\n        if len(non_background_colors) == 1:\n            container_color = non_background_colors[0]\n        else:\n             print(\"Warning: Could not determine container color reliably.\")\n             # Attempt a simpler fallback: color forming the largest non-background objects?\n             best_fallback_color = -1\n             max_obj_size = -1\n             for c in non_background_colors:\n                  if c not in all_objects: all_objects[c] = find_objects(grid, c, connectivity=4)\n                  if all_objects[c]:\n                      current_max = max(len(obj) for obj in all_objects[c])\n                      if current_max > max_obj_size:\n                           max_obj_size = current_max\n                           best_fallback_color = c\n             container_color = best_fallback_color\n             if container_color == -1: return [] # Failed to find any container candidate\n\n\n    # 3. Find all objects of the determined container color\n    if container_color not in all_objects: # Ensure container objects are found (might not have been iterated over if it wasn't adjacent to anything)\n         all_objects[container_color] = find_objects(grid, container_color, connectivity=4) # Use 4-connectivity for containers too\n    container_objects = all_objects.get(container_color, [])\n\n    # 4. Filter valid containers & 5. Extract Patterns\n    patterns_data = []\n    processed_content_coords = set() # Prevent processing the same content blob multiple times if touched by container parts\n\n    for container_obj_coords in container_objects:\n        adjacent_true_content_coords = set()\n        # Find true content adjacent to this container object\n        for r, c in container_obj_coords:\n            # Check 8-way neighbors\n            for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                neighbor_color = grid[nr, nc]\n                if neighbor_color != background_color and neighbor_color != container_color:\n                    # Check if this content coord was already part of a processed pattern\n                    if (nr, nc) not in processed_content_coords:\n                       adjacent_true_content_coords.add((nr, nc))\n\n        if adjacent_true_content_coords:\n            # Found a valid container, now define the pattern\n            \n            # Need to potentially group adjacent content coords if one container touches multiple blobs\n            # Let's assume for now each container interacts with one connected content region nearby\n            # Find the connected components within the adjacent_true_content_coords\n            \n            # Simplified approach: Treat all adjacent content as one group for pattern extraction\n            # Mark these content coords as processed\n            processed_content_coords.update(adjacent_true_content_coords)\n\n            # Find container pixels adjacent to THIS set of true content\n            frame_coords = set()\n            min_content_row = height # Initialize high\n            for r_tc, c_tc in adjacent_true_content_coords:\n                 min_content_row = min(min_content_row, r_tc)\n                 # Check 8-way neighbors for container pixels\n                 for nr, nc in get_neighbors(r_tc, c_tc, height, width, connectivity=8):\n                     if grid[nr, nc] == container_color:\n                         # Only include frame pixels belonging to the CURRENT container object\n                         if (nr, nc) in container_obj_coords: \n                             frame_coords.add((nr, nc))\n\n            # Combine content and relevant frame pixels\n            pattern_coords = adjacent_true_content_coords.union(frame_coords)\n\n            if pattern_coords:\n                # Calculate bounding box and extract pattern\n                bb = get_bounding_box(pattern_coords)\n                if bb:\n                    min_r, min_c, max_r, max_c = bb\n                    # Ensure valid slice indices\n                    min_r = max(0, min_r); min_c = max(0, min_c)\n                    max_r = min(height - 1, max_r); max_c = min(width - 1, max_c)\n                    \n                    if max_r >= min_r and max_c >= min_c: # Check if bbox is valid\n                        pattern = grid[min_r : max_r + 1, min_c : max_c + 1]\n                        patterns_data.append({\n                            'min_content_row': min_content_row,\n                            'pattern': pattern.tolist() # Store as list of lists\n                        })\n\n\n    # 6. Sort Patterns\n    patterns_data.sort(key=lambda x: x['min_content_row'])\n\n    # 7. Assemble and Duplicate Rows\n    assembled_rows = []\n    for data in patterns_data:\n        assembled_rows.extend(data['pattern']) # Add all rows from the pattern\n\n    final_output_rows = []\n    for row in assembled_rows:\n        final_output_rows.append(list(row)) # Add the row\n\n        # Check duplication rule\n        true_content_in_row = []\n        indices = []\n        for i, pixel in enumerate(row):\n            if pixel != background_color and pixel != container_color:\n                true_content_in_row.append(pixel)\n                indices.append(i)\n        \n        # Check if exactly 3 true content pixels, all same color, and contiguous\n        if len(true_content_in_row) == 3:\n            if len(set(true_content_in_row)) == 1: # All same color?\n                 # Check contiguity based on indices\n                 if len(indices) == 3 and indices[2] == indices[1] + 1 and indices[1] == indices[0] + 1:\n                     final_output_rows.append(list(row)) # Duplicate the row\n\n\n    if not final_output_rows:\n        return [] # No patterns resulted in output rows\n\n    # 8. Pad Rows\n    max_width = 0\n    for row in final_output_rows:\n        max_width = max(max_width, len(row))\n\n    padded_grid = []\n    for row in final_output_rows:\n        current_width = len(row)\n        pad_total = max_width - current_width\n        pad_left = pad_total // 2\n        pad_right = pad_total - pad_left\n        padded_row = ([background_color] * pad_left) + row + ([background_color] * pad_right)\n        padded_grid.append(padded_row)\n\n    # 9. Construct Final Output\n    return padded_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15115,
    "candidates_token_count": 4698,
    "total_token_count": 19813,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 40.074208,
  "retries": 1
}