{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (most frequent pixel value) and the container color (the non-background color adjacent to the most diverse set of other non-background colors).\n2. Find all distinct, connected objects composed solely of the container color ('container_objects'). Find all distinct, connected objects composed of any single color that is neither the background color nor the container color ('content_objects'). Use 4-connectivity for object definition.\n3. Map content objects to patterns: For each content_object, find its adjacent (8-way) container_color pixels ('frame_coords'). If frame_coords exist and the content_object hasn't been processed, store its coordinates ('content_coords'), the frame_coords, and the minimum row index from content_coords ('sort_key'). Mark the content_object's coordinates as processed.\n4. Extract and Sort Patterns: For each stored definition, combine content_coords and frame_coords, calculate the minimal bounding box, extract the corresponding subgrid ('pattern_grid') from the input, and store the pair (sort_key, pattern_grid). Sort these pairs by sort_key.\n5. Assemble and Duplicate Rows: Concatenate all rows from the sorted pattern_grids into an initial list ('assembled_rows'). Create a final list ('final_rows'). Iterate through assembled_rows: add the row to final_rows. Then, extract the 'true_content_pixels' (those != background and != container color). If this sequence is non-empty and palindromic, add the row to final_rows again.\n6. Pad and Finalize: Calculate the maximum width of rows in final_rows. Pad each row symmetrically with the background_color to match this width. Stack the padded rows to form the output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid, color, connectivity=4):\n    \"\"\"\n    Finds all connected components of a given color using BFS.\n    Returns a list of sets, where each set contains (row, col) tuples for an object.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    for dr, dc in deltas:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets valid neighbor coordinates based on connectivity.\"\"\"\n    neighbors = set()\n    if connectivity == 4:\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    elif connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else:\n        raise ValueError(\"Connectivity must be 4 or 8\")\n        \n    for dr, dc in deltas:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.add((nr, nc))\n    return neighbors\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the min/max row/col for a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    if not rows or not cols: return None # Handle empty lists case\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef is_palindrome(seq):\n    \"\"\"Checks if a list or tuple is a palindrome.\"\"\"\n    # Convert numpy array row to list if necessary\n    if isinstance(seq, np.ndarray):\n        seq = seq.tolist()\n    return seq == seq[::-1]\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Handle edge cases\n    if grid.size == 0: return []\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    if len(unique_colors) <= 1: return input_grid \n\n    # --- Step 1: Identify Colors ---\n    background_color = unique_colors[np.argmax(counts)]\n    non_background_colors = [c for c in unique_colors if c != background_color]\n    if not non_background_colors: return input_grid\n\n    # --- Step 2: Identify Container Color ---\n    adjacency_map = {color: set() for color in non_background_colors}\n    all_objects_cache = {} # Cache objects: {color: [obj1_coords, obj2_coords,...]}\n\n    # Build adjacency map based on 8-way connectivity between different non-background colors\n    for current_color in non_background_colors:\n        if current_color not in all_objects_cache:\n            all_objects_cache[current_color] = find_objects(grid, current_color, connectivity=4)\n\n        for obj_coords in all_objects_cache[current_color]:\n            for r, c in obj_coords:\n                # Check 8-way neighbors\n                for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                    neighbor_color = grid[nr, nc]\n                    if neighbor_color != background_color and neighbor_color != current_color:\n                        adjacency_map[neighbor_color].add(current_color)\n\n    # Determine container color by max diversity of adjacent colors\n    container_color = -1\n    max_diversity = -1\n    sorted_non_bg = sorted(non_background_colors) # Deterministic tie-breaking\n\n    for potential_container in sorted_non_bg:\n        diversity = len(adjacency_map.get(potential_container, set()))\n        if diversity > max_diversity:\n            max_diversity = diversity\n            container_color = potential_container\n        # If diversity is equal, the sort order provides tie-breaking\n\n    # Fallback if heuristic fails\n    if container_color == -1:\n         if len(non_background_colors) == 1:\n              container_color = non_background_colors[0] \n         else: # Fallback: largest non-background object color\n              max_size = -1\n              for c in sorted_non_bg:\n                   if c not in all_objects_cache: all_objects_cache[c] = find_objects(grid, c, connectivity=4)\n                   if all_objects_cache.get(c):\n                        current_max = max(len(obj) for obj in all_objects_cache[c])\n                        if current_max > max_size:\n                             max_size = current_max\n                             container_color = c\n              if container_color == -1: return [] # Total failure to identify container\n\n    # --- Step 3: Locate Objects ---\n    content_colors = [c for c in non_background_colors if c != container_color]\n    all_content_objects = []\n    for c_color in content_colors:\n        if c_color not in all_objects_cache:\n            all_objects_cache[c_color] = find_objects(grid, c_color, connectivity=4)\n        all_content_objects.extend(all_objects_cache.get(c_color, []))\n\n    # container_objects are needed implicitly by checking grid[nr,nc] == container_color later\n    # No need to explicitly find them unless optimizing the frame finding step\n\n    # --- Step 4: Map Content to Patterns ---\n    pattern_definitions = []\n    processed_content_coords = set() \n\n    for content_object_coords in all_content_objects:\n        # Check if already processed\n        if not content_object_coords.isdisjoint(processed_content_coords):\n            continue\n\n        frame_coords = set()\n        min_content_row = height \n        \n        # Find adjacent container pixels and min content row\n        for r_content, c_content in content_object_coords:\n            min_content_row = min(min_content_row, r_content)\n            # Check 8-way neighbors for container color\n            for nr, nc in get_neighbors(r_content, c_content, height, width, connectivity=8):\n                if grid[nr, nc] == container_color:\n                    frame_coords.add((nr, nc))\n\n        # If content touches container color\n        if frame_coords:\n            pattern_definitions.append({\n                'content_coords': content_object_coords,\n                'frame_coords': frame_coords,\n                'sort_key': min_content_row,\n            })\n            # Mark as processed\n            processed_content_coords.update(content_object_coords)\n\n    # --- Step 5: Extract and Sort Patterns ---\n    extracted_patterns = []\n    for definition in pattern_definitions:\n        content_coords = definition['content_coords']\n        frame_coords = definition['frame_coords']\n        sort_key = definition['sort_key']\n        \n        pattern_coords = content_coords.union(frame_coords)\n        \n        bb = get_bounding_box(pattern_coords)\n        if bb:\n            min_r, min_c, max_r, max_c = bb\n            # Clamp bounds to grid dimensions (redundant if get_neighbors is correct, but safe)\n            min_r = max(0, min_r); min_c = max(0, min_c)\n            max_r = min(height - 1, max_r); max_c = min(width - 1, max_c)\n            \n            if max_r >= min_r and max_c >= min_c: \n                pattern_grid = grid[min_r : max_r + 1, min_c : max_c + 1]\n                extracted_patterns.append((sort_key, pattern_grid.tolist())) # Store pattern as list of lists\n\n    # Sort patterns by the minimum row of their original content\n    extracted_patterns.sort(key=lambda x: x[0])\n\n    # --- Step 6: Assemble and Duplicate Rows ---\n    assembled_rows = []\n    for _, pattern_grid in extracted_patterns:\n        assembled_rows.extend(pattern_grid) # Concatenate rows from sorted patterns\n\n    final_rows = []\n    for row in assembled_rows:\n        final_rows.append(list(row)) # Add row (ensure it's a list)\n\n        # Extract true content pixels for palindrome check\n        true_content_pixels = [p for p in row if p != background_color and p != container_color]\n\n        # Apply duplication rule\n        if true_content_pixels and is_palindrome(true_content_pixels):\n            final_rows.append(list(row)) # Add again if non-empty palindrome\n\n    if not final_rows:\n        return [] # Return empty if no patterns resulted in rows\n\n    # --- Step 7: Pad and Finalize ---\n    max_width = 0\n    for row in final_rows:\n        max_width = max(max_width, len(row))\n\n    output_grid = []\n    for row in final_rows:\n        current_width = len(row)\n        pad_total = max_width - current_width\n        pad_left = pad_total // 2\n        pad_right = pad_total - pad_left\n        # Construct the padded row\n        padded_row = ([background_color] * pad_left) + row + ([background_color] * pad_right)\n        output_grid.append(padded_row)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 39156,
    "candidates_token_count": 3407,
    "total_token_count": 42563,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 25.475764,
  "retries": 1
}