
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 4 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 6 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 6 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 4 6 1
1 6 4 4 4 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 6 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 4 6 1
1 6 6 6 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 4 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 1 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 1 1 1 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 4 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 4 4 3
3 4 4 1 1 4 3
3 4 1 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
```

**Perception**

1.  **Grid Structure**: Both input examples show a grid composed of smaller, repeating blocks or patterns. These blocks are separated by single-pixel lines (horizontal and vertical) of a specific color (blue in `train_1`, green in `train_2`).
2.  **Block Pattern**: Each block consists of a 5x5 pattern area surrounded by the separator lines. Inside the 5x5 area, there's an outer frame of one color (magenta in `train_1`, yellow in `train_2`) and an inner pattern made of another color (yellow in `train_1`, blue in `train_2`).
3.  **Variability**: Within the input grid, most of the 5x5 inner patterns are identical, but one or more patterns are different. These different patterns appear to be variations of the common pattern.
4.  **Transformation**: The output grid retains the vertical structure (number of blocks stacked vertically and separator lines) but reduces the horizontal structure to just one column of blocks. The key change is that *all* blocks in the output column contain the *same* 5x5 pattern.
5.  **Pattern Selection**: The pattern used in the output grid seems to be one of the *unique* patterns from the input grid. In `train_1`, there were two patterns that appeared only once; the one chosen for the output was the one located in the top-right block (first unique pattern encountered when scanning top-to-bottom, left-to-right). In `train_2`, there were also two unique patterns; the one chosen for the output was again the first unique one encountered in reading order.
6.  **Output Construction**: The output grid takes the selected unique 5x5 pattern, places it within the standard separator frame (using the input's separator color), and repeats this structure vertically the same number of times as the input grid had rows of blocks. The output width is fixed to the width of one block plus its two vertical separator lines (5 + 2 = 7 pixels). The output height matches the input height.

**Facts**

```
yaml
task_elements:
  - item: grid
    properties:
      - composed_of: blocks
      - separated_by: lines
  - item: blocks
    properties:
      - arrangement: grid (Rows x Columns)
      - size: H x W (appears to be 5x5 in examples)
      - structure: internal_pattern surrounded by separator_lines
  - item: separator_lines
    properties:
      - thickness: 1 pixel
      - color: consistent within a task (blue for train_1, green for train_2)
      - role: define block boundaries
  - item: internal_pattern
    properties:
      - size: H x W (5x5)
      - structure: potentially contains frame and inner pixels
      - variability: most are identical (common pattern), some are unique (occur once)

actions:
  - action: identify_grid_parameters
    inputs: input_grid
    outputs: separator_color, block_size (H, W), block_grid_dimensions (R, C)
    steps:
      - Find the color of pixels at grid line positions (e.g., row 0, col 0).
      - Determine block height H (distance between horizontal lines - 1).
      - Determine block width W (distance between vertical lines - 1).
      - Calculate R = (input_height - 1) / (H + 1).
      - Calculate C = (input_width - 1) / (W + 1).
  - action: extract_patterns
    inputs: input_grid, H, W, R, C
    outputs: list_of_patterns, list_of_positions
    steps:
      - Iterate through R rows and C columns of blocks.
      - For each block (r, c), extract the HxW subgrid corresponding to its internal pattern.
      - Store the pattern and its original position (r, c).
  - action: find_target_pattern
    inputs: list_of_patterns, list_of_positions
    outputs: selected_unique_pattern
    steps:
      - Count the occurrences of each distinct pattern.
      - Identify patterns with a count of 1 (unique patterns).
      - Create a list of unique patterns and their corresponding positions.
      - Find the unique pattern whose position (r, c) has the minimum row index `r`, and then the minimum column index `c` among those with the minimum `r`.
      - Return this selected unique pattern.
  - action: construct_output
    inputs: selected_unique_pattern, R, H, W, separator_color
    outputs: output_grid
    steps:
      - Calculate output dimensions: height = R*H + (R+1), width = W+2.
      - Create an empty grid of these dimensions.
      - Fill column 0 and column W+1 with separator_color.
      - Fill rows 0, H+1, 2*(H+1), ..., R*(H+1) with separator_color.
      - For each row `r` from 0 to R-1:
        - Calculate pattern top row index: `row_start = r*(H+1) + 1`.
        - Place the `selected_unique_pattern` into the output grid starting at `(row_start, 1)`.

relationships:
  - The output pattern is derived from a unique pattern within the input.
  - The output grid dimensions depend on the input grid structure (number of rows of blocks R, block size HxW).
  - The separator color remains consistent from input to output.
  - If multiple unique patterns exist, positional priority (top-leftmost) determines the selection.

```

**Natural Language Program**

1.  Analyze the input grid to identify the separator color, the dimensions (H, W) of the internal patterns within blocks (e.g., 5x5), and the number of block rows (R) and columns (C).
2.  Extract all HxW internal patterns from the R*C blocks in the input grid, keeping track of the original row and column index of each block.
3.  Count the frequency of each distinct pattern identified in step 2.
4.  Identify all patterns that occurred exactly once (the unique patterns).
5.  From the set of unique patterns, select the one that came from the block with the lowest row index in the original input grid. If there's a tie in row index, select the one with the lowest column index among the tied rows. This is the "target pattern".
6.  Create a new output grid with R*H + (R+1) rows and W+2 columns.
7.  Fill the first column (index 0) and the last column (index W+1) of the output grid with the separator color.
8.  Fill the horizontal separator rows (indices 0, H+1, 2*(H+1), ..., R*(H+1)) of the output grid with the separator color.
9.  For each block row `r` from 0 to R-1, place the target pattern (identified in step 5) into the output grid, starting at row index `r*(H+1) + 1` and column index 1.
