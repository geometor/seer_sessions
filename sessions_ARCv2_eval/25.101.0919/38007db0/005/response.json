{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n\n1.  **Analyze Input Structure**: Determine the grid's separator color (from the top-left pixel). Find the block height (H) and width (W) by locating the first full row and column of the separator color. Calculate the number of block rows (R) and columns (C).\n2.  **Extract and Count Patterns**: Extract the HxW pattern from each block in the input grid. Store each distinct pattern along with a list of all its positions (r, c) and its total frequency (count). Keep track of the first position (top-leftmost) where each distinct pattern appears.\n3.  **Identify Unique Patterns**: Create a list of all patterns that have a frequency count of exactly 1.\n4.  **Select Target Pattern**:\n    *   **If** the list of unique patterns is not empty: Sort the unique patterns based on their position (first by row index, then by column index). The target pattern is the pattern from the first entry in this sorted list (the top-leftmost unique pattern).\n    *   **Else** (if no unique patterns exist): Find the highest frequency count among all patterns. Identify all patterns that have this highest frequency (the most common patterns). Sort these most common patterns based on their *first* recorded position (first by row index, then by column index). The target pattern is the pattern from the first entry in this sorted list (the top-leftmost occurrence of the most common patterns).\n5.  **Construct Output Grid**: Create a new grid with dimensions corresponding to R blocks high and 1 block wide (total pixels: (R*H + R + 1) rows, (W + 2) columns).\n6.  **Populate Output Grid**: Fill the entire output grid with the separator color. Then, place the selected target pattern into the HxW area within each of the R block locations in the single output column.\n\"\"\"\n\nimport collections\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef to_np(grid: list[list[int]]) -> np.ndarray:\n    \"\"\"Converts a list of lists grid to a numpy array.\"\"\"\n    return np.array(grid, dtype=int)\n\ndef pattern_to_tuple(pattern_np: np.ndarray) -> tuple[tuple[int]]:\n    \"\"\"Converts a numpy pattern array to a hashable tuple of tuples.\"\"\"\n    return tuple(tuple(int(x) for x in row) for row in pattern_np)\n\ndef find_grid_parameters(np_grid: np.ndarray) -> tuple[int, int, int, int, int]:\n    \"\"\"\n    Analyzes the numpy grid to find separator color, block dimensions (H, W),\n    and grid block count (R, C). Looks for full separator lines.\n    \"\"\"\n    input_height, input_width = np_grid.shape\n\n    # Separator color is assumed to be at (0, 0)\n    separator_color = int(np_grid[0, 0])\n\n    # Find block height H by finding the first full separator row\n    h = -1\n    for r in range(1, input_height):\n        if np.all(np_grid[r, :] == separator_color):\n            h = r - 1\n            break\n    if h == -1: # No full horizontal separator found, assume single row of blocks\n        if input_height > 1:\n             h = input_height - 2\n        else: # Cannot determine height if grid is 1xN\n             raise ValueError(\"Cannot determine block height H.\")\n\n\n    # Find block width W by finding the first full separator column\n    w = -1\n    for c in range(1, input_width):\n         if np.all(np_grid[:, c] == separator_color):\n            w = c - 1\n            break\n    if w == -1: # No full vertical separator found, assume single column of blocks\n        if input_width > 1:\n            w = input_width - 2\n        else: # Cannot determine width if grid is Nx1\n             raise ValueError(\"Cannot determine block width W.\")\n\n    # Validate H and W\n    if h <= 0 or w <= 0:\n         raise ValueError(f\"Invalid block dimensions determined: H={h}, W={w}\")\n\n    # Calculate number of block rows (R) and columns (C)\n    # Check divisibility first for robust calculation\n    if (input_height - 1) % (h + 1) != 0:\n         # Allow for single row case\n         if input_height == h + 2:\n             r_blocks = 1\n         else:\n            raise ValueError(f\"Grid height {input_height} inconsistent with block height H={h}.\")\n    else:\n        r_blocks = (input_height - 1) // (h + 1)\n\n    if (input_width - 1) % (w + 1) != 0:\n        # Allow for single col case\n         if input_width == w + 2:\n             c_blocks = 1\n         else:\n            raise ValueError(f\"Grid width {input_width} inconsistent with block width W={w}.\")\n    else:\n        c_blocks = (input_width - 1) // (w + 1)\n\n\n    # Final validation check on dimensions based on calculated R,C,H,W\n    if input_height != r_blocks * h + (r_blocks + 1) or input_width != c_blocks * w + (c_blocks + 1):\n         raise ValueError(f\"Grid dimensions Ht={input_height}, Wd={input_width} do not match calculated structure R={r_blocks}, C={c_blocks}, H={h}, W={w}.\")\n\n    if r_blocks <= 0 or c_blocks <= 0:\n        raise ValueError(\"Could not determine valid block counts R and C.\")\n\n    return separator_color, h, w, r_blocks, c_blocks\n\ndef extract_patterns_and_details(np_grid: np.ndarray, h: int, w: int, r_blocks: int, c_blocks: int) -> list[dict]:\n    \"\"\"\n    Extracts patterns, calculates frequencies, and records all positions and the first position.\n    Returns a list of dictionaries, one for each distinct pattern:\n    [{'pattern': tuple, 'count': int, 'positions': list[tuple], 'first_pos': tuple}]\n    \"\"\"\n    patterns_data = {} # Use dict for easy aggregation: {pattern_tuple: {'count':..., 'positions':..., 'first_pos':...}}\n\n    for r in range(r_blocks):\n        for c in range(c_blocks):\n            start_row = r * (h + 1) + 1\n            start_col = c * (w + 1) + 1\n            # Extract pattern using numpy slicing\n            pattern_np = np_grid[start_row : start_row + h, start_col : start_col + w]\n            pattern_tuple = pattern_to_tuple(pattern_np)\n            current_pos = (r, c)\n\n            if pattern_tuple not in patterns_data:\n                patterns_data[pattern_tuple] = {\n                    'pattern': pattern_tuple,\n                    'count': 0,\n                    'positions': [],\n                    'first_pos': current_pos # Record first time seen\n                }\n            patterns_data[pattern_tuple]['count'] += 1\n            patterns_data[pattern_tuple]['positions'].append(current_pos)\n\n    # Convert the aggregated dictionary back to a list\n    return list(patterns_data.values())\n\ndef select_target_pattern(patterns_details: list[dict]) -> tuple[tuple[int]]:\n    \"\"\"\n    Selects the target pattern based on uniqueness and position.\n    Prioritizes top-leftmost unique pattern. If none, selects top-leftmost most common pattern.\n    \"\"\"\n    unique_patterns = [p for p in patterns_details if p['count'] == 1]\n\n    if unique_patterns:\n        # Sort unique patterns by position (row, then column)\n        # We use the first position encountered, which IS the top-leftmost for a unique pattern\n        unique_patterns.sort(key=lambda p: p['first_pos'])\n        return unique_patterns[0]['pattern']\n    else:\n        # No unique patterns, find the most common\n        if not patterns_details:\n             raise ValueError(\"No patterns found to select from.\")\n\n        max_count = 0\n        for p in patterns_details:\n            if p['count'] > max_count:\n                max_count = p['count']\n        # Could also use: max_count = max(p['count'] for p in patterns_details)\n\n        most_common_patterns = [p for p in patterns_details if p['count'] == max_count]\n\n        # Tie-break most common using the first position encountered\n        most_common_patterns.sort(key=lambda p: p['first_pos'])\n        return most_common_patterns[0]['pattern']\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by finding the top-leftmost unique pattern (or\n    top-leftmost most common if no uniques exist) and replicating it in a\n    single column structure with the original separators.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    np_grid = to_np(input_grid)\n\n    # 1. Analyze Input Structure\n    try:\n        separator_color, h, w, r_blocks, c_blocks = find_grid_parameters(np_grid)\n    except ValueError as e:\n        print(f\"Error analyzing grid structure: {e}\")\n        raise # Re-raise error for clear feedback\n\n    # 2. Extract and Count Patterns\n    patterns_details = extract_patterns_and_details(np_grid, h, w, r_blocks, c_blocks)\n    if not patterns_details:\n         raise ValueError(\"No patterns extracted from the grid.\")\n\n    # 3. & 4. Select Target Pattern\n    try:\n        target_pattern = select_target_pattern(patterns_details)\n    except ValueError as e:\n        print(f\"Error selecting target pattern: {e}\")\n        raise # Re-raise error\n\n    # 5. Construct Output Grid Dimensions\n    output_height = r_blocks * h + (r_blocks + 1)\n    output_width = w + 2 # One block width + 2 separator columns\n\n    # 6. Initialize Output Grid and Populate\n    output_grid_np = np.full((output_height, output_width), separator_color, dtype=int)\n\n    for r in range(r_blocks):\n        # Calculate top-left corner for placing the pattern in the output\n        start_row = r * (h + 1) + 1\n        start_col = 1 # Pattern always starts in the second column (index 1)\n\n        # Place the target pattern (which is a tuple of tuples)\n        for i in range(h):\n            for j in range(w):\n                # Ensure indices are within bounds (should be guaranteed by correct H/W)\n                if i < len(target_pattern) and j < len(target_pattern[i]):\n                    output_grid_np[start_row + i, start_col + j] = target_pattern[i][j]\n                else:\n                    # This indicates an error in H/W or pattern extraction\n                    print(f\"Warning: Index out of bounds when placing pattern at block row {r}, pattern coords ({i},{j})\")\n\n    # Convert numpy array back to list of lists for the expected output format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 49088,
    "candidates_token_count": 2966,
    "total_token_count": 52054,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.03826,
  "retries": 1
}