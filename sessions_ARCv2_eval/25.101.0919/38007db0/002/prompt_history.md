
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 4 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 6 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 6 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 4 6 1
1 6 4 4 4 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 6 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 4 6 1
1 6 6 6 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 4 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 1 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 1 1 1 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 4 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 4 4 3
3 4 4 1 1 4 3
3 4 1 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
```

**Perception**

1.  **Grid Structure**: Both input examples show a grid composed of smaller, repeating blocks or patterns. These blocks are separated by single-pixel lines (horizontal and vertical) of a specific color (blue in `train_1`, green in `train_2`).
2.  **Block Pattern**: Each block consists of a 5x5 pattern area surrounded by the separator lines. Inside the 5x5 area, there's an outer frame of one color (magenta in `train_1`, yellow in `train_2`) and an inner pattern made of another color (yellow in `train_1`, blue in `train_2`).
3.  **Variability**: Within the input grid, most of the 5x5 inner patterns are identical, but one or more patterns are different. These different patterns appear to be variations of the common pattern.
4.  **Transformation**: The output grid retains the vertical structure (number of blocks stacked vertically and separator lines) but reduces the horizontal structure to just one column of blocks. The key change is that *all* blocks in the output column contain the *same* 5x5 pattern.
5.  **Pattern Selection**: The pattern used in the output grid seems to be one of the *unique* patterns from the input grid. In `train_1`, there were two patterns that appeared only once; the one chosen for the output was the one located in the top-right block (first unique pattern encountered when scanning top-to-bottom, left-to-right). In `train_2`, there were also two unique patterns; the one chosen for the output was again the first unique one encountered in reading order.
6.  **Output Construction**: The output grid takes the selected unique 5x5 pattern, places it within the standard separator frame (using the input's separator color), and repeats this structure vertically the same number of times as the input grid had rows of blocks. The output width is fixed to the width of one block plus its two vertical separator lines (5 + 2 = 7 pixels). The output height matches the input height.

**Facts**

```
yaml
task_elements:
  - item: grid
    properties:
      - composed_of: blocks
      - separated_by: lines
  - item: blocks
    properties:
      - arrangement: grid (Rows x Columns)
      - size: H x W (appears to be 5x5 in examples)
      - structure: internal_pattern surrounded by separator_lines
  - item: separator_lines
    properties:
      - thickness: 1 pixel
      - color: consistent within a task (blue for train_1, green for train_2)
      - role: define block boundaries
  - item: internal_pattern
    properties:
      - size: H x W (5x5)
      - structure: potentially contains frame and inner pixels
      - variability: most are identical (common pattern), some are unique (occur once)

actions:
  - action: identify_grid_parameters
    inputs: input_grid
    outputs: separator_color, block_size (H, W), block_grid_dimensions (R, C)
    steps:
      - Find the color of pixels at grid line positions (e.g., row 0, col 0).
      - Determine block height H (distance between horizontal lines - 1).
      - Determine block width W (distance between vertical lines - 1).
      - Calculate R = (input_height - 1) / (H + 1).
      - Calculate C = (input_width - 1) / (W + 1).
  - action: extract_patterns
    inputs: input_grid, H, W, R, C
    outputs: list_of_patterns, list_of_positions
    steps:
      - Iterate through R rows and C columns of blocks.
      - For each block (r, c), extract the HxW subgrid corresponding to its internal pattern.
      - Store the pattern and its original position (r, c).
  - action: find_target_pattern
    inputs: list_of_patterns, list_of_positions
    outputs: selected_unique_pattern
    steps:
      - Count the occurrences of each distinct pattern.
      - Identify patterns with a count of 1 (unique patterns).
      - Create a list of unique patterns and their corresponding positions.
      - Find the unique pattern whose position (r, c) has the minimum row index `r`, and then the minimum column index `c` among those with the minimum `r`.
      - Return this selected unique pattern.
  - action: construct_output
    inputs: selected_unique_pattern, R, H, W, separator_color
    outputs: output_grid
    steps:
      - Calculate output dimensions: height = R*H + (R+1), width = W+2.
      - Create an empty grid of these dimensions.
      - Fill column 0 and column W+1 with separator_color.
      - Fill rows 0, H+1, 2*(H+1), ..., R*(H+1) with separator_color.
      - For each row `r` from 0 to R-1:
        - Calculate pattern top row index: `row_start = r*(H+1) + 1`.
        - Place the `selected_unique_pattern` into the output grid starting at `(row_start, 1)`.

relationships:
  - The output pattern is derived from a unique pattern within the input.
  - The output grid dimensions depend on the input grid structure (number of rows of blocks R, block size HxW).
  - The separator color remains consistent from input to output.
  - If multiple unique patterns exist, positional priority (top-leftmost) determines the selection.

```

**Natural Language Program**

1.  Analyze the input grid to identify the separator color, the dimensions (H, W) of the internal patterns within blocks (e.g., 5x5), and the number of block rows (R) and columns (C).
2.  Extract all HxW internal patterns from the R*C blocks in the input grid, keeping track of the original row and column index of each block.
3.  Count the frequency of each distinct pattern identified in step 2.
4.  Identify all patterns that occurred exactly once (the unique patterns).
5.  From the set of unique patterns, select the one that came from the block with the lowest row index in the original input grid. If there's a tie in row index, select the one with the lowest column index among the tied rows. This is the "target pattern".
6.  Create a new output grid with R*H + (R+1) rows and W+2 columns.
7.  Fill the first column (index 0) and the last column (index W+1) of the output grid with the separator color.
8.  Fill the horizontal separator rows (indices 0, H+1, 2*(H+1), ..., R*(H+1)) of the output grid with the separator color.
9.  For each block row `r` from 0 to R-1, place the target pattern (identified in step 5) into the output grid, starting at row index `r*(H+1) + 1` and column index 1.
```python
import collections
import numpy as np

"""
Transformation Rule:

1.  Identify the grid structure: Find the separator color (pixel at 0,0), the dimensions (H, W) of the internal patterns within blocks (e.g., 5x5), and the number of block rows (R) and columns (C) in the input grid. Blocks are separated by single-pixel lines of the separator color.
2.  Extract all HxW internal patterns from each block in the input grid, recording the original block row and column index (r, c) for each pattern.
3.  Count the frequency of each distinct pattern.
4.  Identify all patterns that occur exactly once (unique patterns).
5.  Select the unique pattern that originates from the block with the smallest row index 'r'. If there's a tie in row index, select the one with the smallest column index 'c'. This is the 'target pattern'.
6.  Construct the output grid: It will have R rows of blocks, but only 1 column. The total dimensions will be (R*H + R+1) rows and (W+2) columns.
7.  Fill the output grid: Use the separator color for the border lines (first and last columns, and rows 0, H+1, 2*(H+1), ...). Place the 'target pattern' into each of the R block locations in the single column of the output grid.
"""


def find_grid_parameters(input_grid: list[list[int]]) -> tuple[int, int, int, int, int]:
    """
    Analyzes the input grid to find separator color, block dimensions (H, W),
    and grid block count (R, C).
    """
    input_height = len(input_grid)
    input_width = len(input_grid[0])

    # Separator color is assumed to be at (0, 0)
    separator_color = input_grid[0][0]

    # Find block height H
    h = 0
    for r in range(1, input_height):
        if input_grid[r][0] == separator_color:
            h = r - 1
            break
    if h == 0: # Handle case where there's only one row of blocks
         h = input_height - 2


    # Find block width W
    w = 0
    for c in range(1, input_width):
        if input_grid[0][c] == separator_color:
            w = c - 1
            break
    if w == 0: # Handle case where there's only one col of blocks
        w = input_width - 2

    # Calculate number of block rows (R) and columns (C)
    # Add a small epsilon to handle potential float inaccuracies if division was used
    r_blocks = (input_height - 1) // (h + 1)
    c_blocks = (input_width - 1) // (w + 1)

    # Basic validation
    if h <= 0 or w <= 0 or r_blocks <= 0 or c_blocks <= 0:
        raise ValueError("Could not determine valid grid parameters.")
    if input_height != r_blocks * h + (r_blocks + 1) or input_width != c_blocks * w + (c_blocks + 1):
         # If calculated dims don't match grid dims, try alternative H/W determination
         # This handles cases where the first row/col might contain part of a pattern
         h = 0
         for r in range(1, input_height):
             is_separator_row = all(input_grid[r][c] == separator_color for c in range(input_width))
             if is_separator_row:
                 h = r - 1
                 break
         if h == 0 and r_blocks == 1: # Only one row of blocks, height is grid height minus top/bottom separators
             h = input_height - 2


         w = 0
         for c in range(1, input_width):
             is_separator_col = all(input_grid[r][c] == separator_color for r in range(input_height))
             if is_separator_col:
                 w = c - 1
                 break
         if w == 0 and c_blocks == 1: # Only one col of blocks, width is grid width minus left/right separators
             w = input_width - 2

         # Recalculate R and C with potentially corrected H, W
         r_blocks = (input_height - 1) // (h + 1) if h > 0 else 0
         c_blocks = (input_width - 1) // (w + 1) if w > 0 else 0

         # Final check
         if h <= 0 or w <= 0 or r_blocks <= 0 or c_blocks <= 0 or \
            input_height != r_blocks * h + (r_blocks + 1) or \
            input_width != c_blocks * w + (c_blocks + 1):
              print(f"Recalculated H={h}, W={w}, R={r_blocks}, C={c_blocks}")
              print(f"Expected Height: {r_blocks * h + (r_blocks + 1)}, Actual: {input_height}")
              print(f"Expected Width: {c_blocks * w + (c_blocks + 1)}, Actual: {input_width}")
              raise ValueError("Grid parameters inconsistency after recalculation.")


    return separator_color, h, w, r_blocks, c_blocks

def extract_patterns(input_grid: list[list[int]], h: int, w: int, r_blocks: int, c_blocks: int) -> list[tuple[tuple[tuple[int]], tuple[int, int]]]:
    """
    Extracts all HxW internal patterns and their block positions (r, c).
    Returns a list of tuples: ((pattern_tuple), (row_idx, col_idx))
    """
    patterns = []
    for r in range(r_blocks):
        for c in range(c_blocks):
            start_row = r * (h + 1) + 1
            start_col = c * (w + 1) + 1
            pattern = []
            for i in range(h):
                pattern.append(tuple(input_grid[start_row + i][start_col : start_col + w]))
            patterns.append((tuple(pattern), (r, c)))
    return patterns

def find_target_pattern(patterns_with_pos: list[tuple[tuple[tuple[int]], tuple[int, int]]]) -> tuple[tuple[int]]:
    """
    Counts patterns, identifies unique ones, and selects the top-leftmost unique pattern.
    """
    pattern_counts = collections.Counter(p[0] for p in patterns_with_pos)
    unique_patterns = []
    for pattern, pos in patterns_with_pos:
        if pattern_counts[pattern] == 1:
            unique_patterns.append({'pattern': pattern, 'pos': pos})

    if not unique_patterns:
        # Fallback: If no unique pattern, maybe return the most common? Or the first?
        # Based on examples, a unique pattern is expected. Let's stick to the rule.
        # If this occurs in new tests, the rule might need refinement.
         # Let's try returning the top-left most pattern if no unique ones are found.
         if patterns_with_pos:
             # Sort by position (r, then c) and return the first pattern
             patterns_with_pos.sort(key=lambda x: x[1])
             print("Warning: No unique pattern found. Returning top-leftmost pattern.")
             return patterns_with_pos[0][0]
         else:
            raise ValueError("No patterns found in the grid.")


    # Sort unique patterns by position: primary key row (pos[0]), secondary key col (pos[1])
    unique_patterns.sort(key=lambda x: (x['pos'][0], x['pos'][1]))

    return unique_patterns[0]['pattern']


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by finding the top-leftmost unique pattern
    and replicating it in a single column structure with the original separators.
    """

    # 1. Analyze Grid Parameters
    try:
        separator_color, h, w, r_blocks, c_blocks = find_grid_parameters(input_grid)
    except ValueError as e:
        print(f"Error finding grid parameters: {e}")
        # Return input or empty grid as fallback? Returning input for now.
        return input_grid # Or raise error

    # 2. Extract Patterns
    patterns_with_pos = extract_patterns(input_grid, h, w, r_blocks, c_blocks)
    if not patterns_with_pos:
         print("Error: No patterns extracted.")
         return [] # Return empty grid

    # 3. Find Target Pattern
    try:
        target_pattern = find_target_pattern(patterns_with_pos)
    except ValueError as e:
        print(f"Error finding target pattern: {e}")
        return [] # Return empty grid

    # 4. Construct Output Grid
    output_height = r_blocks * h + (r_blocks + 1)
    output_width = w + 2
    # Initialize with separator color
    output_grid = [[separator_color for _ in range(output_width)] for _ in range(output_height)]

    # 5. Place Target Pattern repeatedly
    for r in range(r_blocks):
        start_row = r * (h + 1) + 1
        start_col = 1  # Always place in the first column block area
        for i in range(h):
            for j in range(w):
                # Ensure target_pattern structure matches access needs
                if i < len(target_pattern) and j < len(target_pattern[i]):
                     output_grid[start_row + i][start_col + j] = target_pattern[i][j]
                else:
                    # This case should ideally not happen if H/W match pattern dims
                    print(f"Warning: Pattern dimension mismatch at pattern row {i}, col {j}")


    return output_grid
```
