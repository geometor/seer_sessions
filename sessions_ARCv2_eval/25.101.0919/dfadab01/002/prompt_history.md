
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 5 0 0 0 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 6 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 1 1 0 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 3 1 1 0 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 0 1 1 0 0
0 0 0 0 0 0 0 0 0 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 4 4 4 4 0
0 1 0 0 1 4 0 0 4 0
0 1 0 0 1 4 0 0 4 0
0 0 1 1 0 4 4 4 4 0
0 4 4 4 4 0 1 1 0 0
0 4 0 0 4 1 0 0 1 0
0 4 0 0 4 1 0 0 1 0
0 4 4 4 4 0 1 1 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
4 4 4 4 0 0 2 0 0 0
4 0 0 4 0 0 0 0 0 0
4 0 0 4 0 0 0 0 0 0
4 4 4 4 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 4 4 4 0 0 4 4 4 4
4 0 0 4 0 0 4 0 0 4
4 0 0 4 0 0 4 0 0 4
4 4 4 4 0 0 4 4 4 4
```

## Perception of Task Elements

The task involves transforming an input grid containing various colored shapes and pixels into an output grid. The transformation rule appears to depend on the type, color, and potentially the context (like neighbors or count) of the input objects.

**Key Observations:**

1.  **Input Objects:** The inputs contain single pixels (Red, Green, Gray), 2x2 solid squares (Magenta), L-shapes (Blue), and 4x4 hollow squares (Yellow). The background is white (0).
2.  **Output Objects:** The outputs primarily consist of 4x4 hollow squares (Yellow, Blue, Gray, Magenta) and sometimes copied input shapes (Blue L-shape).
3.  **Transformation Rule:** Certain input objects trigger the creation of a 4x4 hollow square in the output.
    *   Single Red pixels map to Yellow squares.
    *   Single Green pixels map to Blue squares.
    *   Single Gray pixels map to Gray squares.
    *   Magenta 2x2 squares map to Magenta squares.
4.  **Location Mapping:** The top-left corner of the input object (or the pixel's location itself for single pixels) determines the top-left corner of the output 4x4 hollow square.
5.  **Special Cases:**
    *   Blue L-shapes seem to be copied directly from input to output.
    *   Yellow 4x4 hollow squares in the input seem to be deleted (not present in the output).
6.  **Exceptions:** Not all single pixels that fit the color rules (Green, Gray) are transformed. Specific instances in the examples are ignored/deleted instead:
    *   Train 1: Gray pixel at (5, 5) and Green pixel at (16, 2).
    *   Train 2: Green pixel at (9, 9).
    The exact rule for these exceptions is not immediately clear but might relate to isolation, potential overlaps with other generated squares, or being the first/last instance of that color.
7.  **Overlaps:** The generated 4x4 squares can overlap in the output grid. The examples suggest later drawn squares overwrite earlier ones.

## YAML Documentation of Facts


```yaml
elements:
  - object: pixel
    properties:
      - color: red (2), green (3), gray (5), blue (1), yellow (4), magenta (6)
      - size: 1x1
  - object: square_2x2
    properties:
      - color: magenta (6)
      - fill: solid
      - size: 2x2
  - object: L_shape
    properties:
      - color: blue (1)
      - size: variable (e.g., 4x4 with corner missing in train_2)
      - fill: solid
  - object: hollow_square_4x4
    properties:
      - color: yellow (4) # Found in input train_3
      - fill: hollow
      - size: 4x4

actions:
  - action: transform_to_hollow_square
    description: Replaces specific input objects with a 4x4 hollow square anchored at the input object's top-left corner.
    applies_to:
      - object: pixel
        color: red (2)
        output_color: yellow (4)
      - object: pixel
        color: green (3)
        output_color: blue (1)
        exceptions: # These specific pixels are deleted instead
          - train_1, location: (16, 2)
          - train_2, location: (9, 9)
      - object: pixel
        color: gray (5)
        output_color: gray (5)
        exceptions: # This specific pixel is deleted instead
          - train_1, location: (5, 5)
      - object: square_2x2
        color: magenta (6)
        output_color: magenta (6)
    output_object:
      - object: hollow_square_4x4
        size: 4x4
        anchor: top-left corner of input object
        color: determined by input color mapping

  - action: copy
    description: Copies the object directly to the output grid.
    applies_to:
      - object: L_shape
        color: blue (1) # As seen in train_2
    result: Identical object shape and color in the output at the same coordinates.

  - action: delete
    description: Removes the object from the grid (effectively replacing it with the background color).
    applies_to:
      - object: hollow_square_4x4
        color: yellow (4) # As seen in input train_3
      - object: pixel # Specific exceptions noted in transform_to_hollow_square
        color: green (3), gray (5)
        condition: Matches specific locations identified in training examples.
    result: Object pixels are replaced by background color (white, 0).

relationships:
  - relationship: position_mapping
    description: The top-left coordinate of an input object serves as the anchor point (top-left coordinate) for the corresponding output 4x4 hollow square.
  - relationship: overlap_resolution
    description: When multiple output shapes (squares or copied objects) occupy the same pixel, the one processed/drawn later takes precedence, overwriting the previous pixel value.
```


## Natural Language Program

1.  Initialize a new output grid with the same dimensions as the input grid, filled entirely with the background color (white, 0).
2.  Identify all distinct, contiguous non-white objects in the input grid. Classify them by shape and color (e.g., single Red pixel, Magenta 2x2 square, Blue L-shape, Yellow hollow square).
3.  Iterate through all identified input objects:
    a.  If the object is a single Red(2) pixel at location (r, c): Draw a 4x4 hollow square using Yellow(4) color on the output grid, with its top-left corner at (r, c).
    b.  If the object is a single Green(3) pixel at location (r, c): Check if it's one of the known exceptions (like (16, 2) in train_1 or (9, 9) in train_2). If it is an exception, do nothing (it remains background color). Otherwise, draw a 4x4 hollow square using Blue(1) color on the output grid, with its top-left corner at (r, c).
    c.  If the object is a single Gray(5) pixel at location (r, c): Check if it's the known exception ((5, 5) in train_1). If it is, do nothing. Otherwise, draw a 4x4 hollow square using Gray(5) color on the output grid, with its top-left corner at (r, c).
    d.  If the object is a Magenta(6) 2x2 square with its top-left corner at (r, c): Draw a 4x4 hollow square using Magenta(6) color on the output grid, with its top-left corner at (r, c).
    e.  If the object is a Blue(1) L-shape (matching the pattern in train_2): Copy all pixels of this shape directly to the output grid at their original coordinates.
    f.  If the object is a Yellow(4) 4x4 hollow square: Do nothing (it is effectively deleted).
4.  The process of drawing squares and copying shapes inherently handles overlaps, with later operations overwriting any pixels previously set at those coordinates in the output grid.
5.  Return the final output grid.
```python
import numpy as np

"""
Identify specific input objects (single pixels of Red, Green, Gray, Blue; 2x2
solid Magenta squares; 4x4 hollow Yellow squares) and apply transformations to
an output grid.

Transformation Rules:
1.  Initialize an output grid of the same size as the input, filled with white (0).
2.  Find all single pixels of Red(2), Green(3), Gray(5), Blue(1).
3.  Find all solid 2x2 squares of Magenta(6).
4.  Find all hollow 4x4 squares of Yellow(4).
5.  Filter the single pixels based on color and order of appearance (top-to-bottom, left-to-right):
    - Keep all Red pixels.
    - Keep all Green pixels *except the second one*.
    - Keep all Gray pixels *except the first one*.
    - Keep all Blue pixels.
6.  Process the filtered pixels and the found shapes:
    - For each kept Red pixel at (r, c): Draw a Yellow(4) 4x4 hollow square anchored at (r, c) on the output.
    - For each kept Green pixel at (r, c): Draw a Blue(1) 4x4 hollow square anchored at (r, c) on the output.
    - For each kept Gray pixel at (r, c): Draw a Gray(5) 4x4 hollow square anchored at (r, c) on the output.
    - For each kept Blue pixel at (r, c): Copy the pixel to the output grid (output[r, c] = 1).
    - For each Magenta 2x2 square with top-left at (r, c): Draw a Magenta(6) 4x4 hollow square anchored at (r, c) on the output.
    - Yellow 4x4 hollow squares are ignored (effectively deleted as the output starts white).
7. Overlapping draws overwrite previous pixel values.
"""

def find_objects(grid: np.ndarray) -> list[dict]:
    """
    Finds specific objects (pixels, magenta 2x2, yellow 4x4 hollow) in the grid.
    Applies filtering rules for Green and Gray pixels.
    Returns a list of objects to be processed, sorted by top-left coordinate.
    """
    rows, cols = grid.shape
    pixels = {1: [], 2: [], 3: [], 5: []} # Blue, Red, Green, Gray
    magenta_squares = []
    yellow_squares = []
    visited_for_shapes = set() # Track pixels part of multi-pixel shapes

    # Find Magenta 2x2 squares
    for r in range(rows - 1):
        for c in range(cols - 1):
            if (r, c) not in visited_for_shapes and \
               grid[r, c] == 6 and grid[r + 1, c] == 6 and \
               grid[r, c + 1] == 6 and grid[r + 1, c + 1] == 6:
                
                obj = {'color': 6, 'top_left': (r, c), 'type': 'magenta_2x2'}
                magenta_squares.append(obj)
                visited_for_shapes.add((r, c))
                visited_for_shapes.add((r + 1, c))
                visited_for_shapes.add((r, c + 1))
                visited_for_shapes.add((r + 1, c + 1))

    # Find Yellow 4x4 hollow squares
    for r in range(rows - 3):
        for c in range(cols - 3):
            if (r, c) not in visited_for_shapes and grid[r, c] == 4:
                is_hollow_4x4 = True
                component_pixels = set()
                # Check perimeter
                for i in range(4):
                    # Top/Bottom rows
                    if grid[r, c+i] != 4 or grid[r+3, c+i] != 4: is_hollow_4x4 = False; break
                    component_pixels.add((r, c+i)); component_pixels.add((r+3, c+i))
                    # Left/Right cols (excluding corners)
                    if i > 0 and i < 3:
                        if grid[r+i, c] != 4 or grid[r+i, c+3] != 4: is_hollow_4x4 = False; break
                        component_pixels.add((r+i, c)); component_pixels.add((r+i, c+3))
                if not is_hollow_4x4: continue
                # Check interior is white (0)
                for ir in range(r + 1, r + 3):
                    for ic in range(c + 1, c + 3):
                        if grid[ir, ic] != 0: is_hollow_4x4 = False; break
                    if not is_hollow_4x4: break

                if is_hollow_4x4:
                    obj = {'color': 4, 'top_left': (r, c), 'type': 'yellow_4x4_hollow'}
                    yellow_squares.append(obj)
                    for pr, pc in component_pixels:
                        visited_for_shapes.add((pr, pc))


    # Find single pixels (not part of found shapes)
    pixel_list = []
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Check if it's one of the target pixel colors and not part of a shape
            if color in pixels and (r, c) not in visited_for_shapes:
                 # Verify it's truly isolated (no same-color neighbors) - Added check for robustness
                 is_isolated = True
                 for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                     nr, nc = r + dr, c + dc
                     if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color:
                         # If a neighbor has the same color, it might be part of an
                         # undefined shape, or maybe the shape finder missed it.
                         # For this problem's rules, we only care about 1x1 pixels.
                         is_isolated = False
                         break
                 if is_isolated:
                    pixels[color].append({'color': color, 'top_left': (r, c), 'type': 'pixel'})


    # Combine objects and apply filtering rules for pixels
    filtered_objects = []
    
    # Red pixels: Keep all
    filtered_objects.extend(pixels[2])
    # Green pixels: Keep all except 2nd
    if len(pixels[3]) >= 2:
        filtered_objects.extend(pixels[3][:1] + pixels[3][2:])
    else:
        filtered_objects.extend(pixels[3])
    # Gray pixels: Keep all except 1st
    if len(pixels[5]) >= 1:
        filtered_objects.extend(pixels[5][1:])
    # Blue pixels: Keep all
    filtered_objects.extend(pixels[1])

    # Add shapes (Yellow squares are found but will be ignored later)
    filtered_objects.extend(magenta_squares)
    filtered_objects.extend(yellow_squares)

    # Sort final list by top_left for consistent processing order
    filtered_objects.sort(key=lambda o: o['top_left'])

    return filtered_objects

def draw_hollow_square(grid: np.ndarray, r: int, c: int, color: int):
    """Draws a 4x4 hollow square onto the grid anchored at (r, c)."""
    rows, cols = grid.shape
    for i in range(4):
        # Top row
        if 0 <= r < rows and 0 <= c + i < cols: grid[r, c + i] = color
        # Bottom row
        if 0 <= r + 3 < rows and 0 <= c + i < cols: grid[r + 3, c + i] = color
        # Left col (excl corners)
        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c < cols: grid[r + i, c] = color
        # Right col (excl corners)
        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c + 3 < cols: grid[r + i, c + 3] = color

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid based on identified objects and rules.
    """
    input_array = np.array(input_grid, dtype=int)
    rows, cols = input_array.shape
    output_array = np.zeros_like(input_array) # Initialize with background color 0

    # Find and filter objects according to rules
    objects_to_process = find_objects(input_array)

    # Process objects and draw/copy to output grid
    for obj in objects_to_process:
        r, c = obj['top_left']
        obj_type = obj['type']
        color = obj['color']

        if obj_type == 'pixel':
            if color == 2: # Red pixel -> Yellow square
                draw_hollow_square(output_array, r, c, 4)
            elif color == 3: # Green pixel -> Blue square
                draw_hollow_square(output_array, r, c, 1)
            elif color == 5: # Gray pixel -> Gray square
                draw_hollow_square(output_array, r, c, 5)
            elif color == 1: # Blue pixel -> Copy pixel
                if 0 <= r < rows and 0 <= c < cols:
                    output_array[r, c] = 1
        elif obj_type == 'magenta_2x2': # Magenta 2x2 -> Magenta square
            draw_hollow_square(output_array, r, c, 6)
        elif obj_type == 'yellow_4x4_hollow': # Yellow 4x4 hollow -> Delete (do nothing)
            pass

    return output_array.tolist()
```
