{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentify specific input objects (single pixels of Red, Green, Gray, Blue; 2x2\nsolid Magenta squares; 4x4 hollow Yellow squares) and apply transformations to\nan output grid.\n\nTransformation Rules:\n1.  Initialize an output grid of the same size as the input, filled with white (0).\n2.  Find all single pixels of Red(2), Green(3), Gray(5), Blue(1).\n3.  Find all solid 2x2 squares of Magenta(6).\n4.  Find all hollow 4x4 squares of Yellow(4).\n5.  Filter the single pixels based on color and order of appearance (top-to-bottom, left-to-right):\n    - Keep all Red pixels.\n    - Keep all Green pixels *except the second one*.\n    - Keep all Gray pixels *except the first one*.\n    - Keep all Blue pixels.\n6.  Process the filtered pixels and the found shapes:\n    - For each kept Red pixel at (r, c): Draw a Yellow(4) 4x4 hollow square anchored at (r, c) on the output.\n    - For each kept Green pixel at (r, c): Draw a Blue(1) 4x4 hollow square anchored at (r, c) on the output.\n    - For each kept Gray pixel at (r, c): Draw a Gray(5) 4x4 hollow square anchored at (r, c) on the output.\n    - For each kept Blue pixel at (r, c): Copy the pixel to the output grid (output[r, c] = 1).\n    - For each Magenta 2x2 square with top-left at (r, c): Draw a Magenta(6) 4x4 hollow square anchored at (r, c) on the output.\n    - Yellow 4x4 hollow squares are ignored (effectively deleted as the output starts white).\n7. Overlapping draws overwrite previous pixel values.\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds specific objects (pixels, magenta 2x2, yellow 4x4 hollow) in the grid.\n    Applies filtering rules for Green and Gray pixels.\n    Returns a list of objects to be processed, sorted by top-left coordinate.\n    \"\"\"\n    rows, cols = grid.shape\n    pixels = {1: [], 2: [], 3: [], 5: []} # Blue, Red, Green, Gray\n    magenta_squares = []\n    yellow_squares = []\n    visited_for_shapes = set() # Track pixels part of multi-pixel shapes\n\n    # Find Magenta 2x2 squares\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            if (r, c) not in visited_for_shapes and \\\n               grid[r, c] == 6 and grid[r + 1, c] == 6 and \\\n               grid[r, c + 1] == 6 and grid[r + 1, c + 1] == 6:\n                \n                obj = {'color': 6, 'top_left': (r, c), 'type': 'magenta_2x2'}\n                magenta_squares.append(obj)\n                visited_for_shapes.add((r, c))\n                visited_for_shapes.add((r + 1, c))\n                visited_for_shapes.add((r, c + 1))\n                visited_for_shapes.add((r + 1, c + 1))\n\n    # Find Yellow 4x4 hollow squares\n    for r in range(rows - 3):\n        for c in range(cols - 3):\n            if (r, c) not in visited_for_shapes and grid[r, c] == 4:\n                is_hollow_4x4 = True\n                component_pixels = set()\n                # Check perimeter\n                for i in range(4):\n                    # Top/Bottom rows\n                    if grid[r, c+i] != 4 or grid[r+3, c+i] != 4: is_hollow_4x4 = False; break\n                    component_pixels.add((r, c+i)); component_pixels.add((r+3, c+i))\n                    # Left/Right cols (excluding corners)\n                    if i > 0 and i < 3:\n                        if grid[r+i, c] != 4 or grid[r+i, c+3] != 4: is_hollow_4x4 = False; break\n                        component_pixels.add((r+i, c)); component_pixels.add((r+i, c+3))\n                if not is_hollow_4x4: continue\n                # Check interior is white (0)\n                for ir in range(r + 1, r + 3):\n                    for ic in range(c + 1, c + 3):\n                        if grid[ir, ic] != 0: is_hollow_4x4 = False; break\n                    if not is_hollow_4x4: break\n\n                if is_hollow_4x4:\n                    obj = {'color': 4, 'top_left': (r, c), 'type': 'yellow_4x4_hollow'}\n                    yellow_squares.append(obj)\n                    for pr, pc in component_pixels:\n                        visited_for_shapes.add((pr, pc))\n\n\n    # Find single pixels (not part of found shapes)\n    pixel_list = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if it's one of the target pixel colors and not part of a shape\n            if color in pixels and (r, c) not in visited_for_shapes:\n                 # Verify it's truly isolated (no same-color neighbors) - Added check for robustness\n                 is_isolated = True\n                 for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n                     nr, nc = r + dr, c + dc\n                     if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == color:\n                         # If a neighbor has the same color, it might be part of an\n                         # undefined shape, or maybe the shape finder missed it.\n                         # For this problem's rules, we only care about 1x1 pixels.\n                         is_isolated = False\n                         break\n                 if is_isolated:\n                    pixels[color].append({'color': color, 'top_left': (r, c), 'type': 'pixel'})\n\n\n    # Combine objects and apply filtering rules for pixels\n    filtered_objects = []\n    \n    # Red pixels: Keep all\n    filtered_objects.extend(pixels[2])\n    # Green pixels: Keep all except 2nd\n    if len(pixels[3]) >= 2:\n        filtered_objects.extend(pixels[3][:1] + pixels[3][2:])\n    else:\n        filtered_objects.extend(pixels[3])\n    # Gray pixels: Keep all except 1st\n    if len(pixels[5]) >= 1:\n        filtered_objects.extend(pixels[5][1:])\n    # Blue pixels: Keep all\n    filtered_objects.extend(pixels[1])\n\n    # Add shapes (Yellow squares are found but will be ignored later)\n    filtered_objects.extend(magenta_squares)\n    filtered_objects.extend(yellow_squares)\n\n    # Sort final list by top_left for consistent processing order\n    filtered_objects.sort(key=lambda o: o['top_left'])\n\n    return filtered_objects\n\ndef draw_hollow_square(grid: np.ndarray, r: int, c: int, color: int):\n    \"\"\"Draws a 4x4 hollow square onto the grid anchored at (r, c).\"\"\"\n    rows, cols = grid.shape\n    for i in range(4):\n        # Top row\n        if 0 <= r < rows and 0 <= c + i < cols: grid[r, c + i] = color\n        # Bottom row\n        if 0 <= r + 3 < rows and 0 <= c + i < cols: grid[r + 3, c + i] = color\n        # Left col (excl corners)\n        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c < cols: grid[r + i, c] = color\n        # Right col (excl corners)\n        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c + 3 < cols: grid[r + i, c + 3] = color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on identified objects and rules.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    output_array = np.zeros_like(input_array) # Initialize with background color 0\n\n    # Find and filter objects according to rules\n    objects_to_process = find_objects(input_array)\n\n    # Process objects and draw/copy to output grid\n    for obj in objects_to_process:\n        r, c = obj['top_left']\n        obj_type = obj['type']\n        color = obj['color']\n\n        if obj_type == 'pixel':\n            if color == 2: # Red pixel -> Yellow square\n                draw_hollow_square(output_array, r, c, 4)\n            elif color == 3: # Green pixel -> Blue square\n                draw_hollow_square(output_array, r, c, 1)\n            elif color == 5: # Gray pixel -> Gray square\n                draw_hollow_square(output_array, r, c, 5)\n            elif color == 1: # Blue pixel -> Copy pixel\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_array[r, c] = 1\n        elif obj_type == 'magenta_2x2': # Magenta 2x2 -> Magenta square\n            draw_hollow_square(output_array, r, c, 6)\n        elif obj_type == 'yellow_4x4_hollow': # Yellow 4x4 hollow -> Delete (do nothing)\n            pass\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5248,
    "candidates_token_count": 8953,
    "total_token_count": 14201,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 68.745061,
  "retries": 1
}