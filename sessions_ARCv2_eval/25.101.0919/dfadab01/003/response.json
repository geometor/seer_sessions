{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n\n1.  Initialize an output grid identical in size to the input, filled with white (0).\n2.  Identify specific multi-pixel objects first:\n    a.  Find all Yellow(4) 4x4 hollow squares. Mark their pixels as 'used'. These objects are effectively deleted (no action on the output grid).\n    b.  Find all Magenta(6) 2x2 solid squares. Mark their pixels as 'used'. Store their top-left coordinates for later transformation.\n    c.  Find the specific Blue(1) 8-pixel L-shape (as seen in train_2). Mark its pixels as 'used'. Store all its pixel coordinates for later copying.\n3.  Identify single pixels:\n    a.  Define a set of specific pixel locations and colors that should be ignored: `{(5, 5, 5), (16, 2, 3), (5, 5, 3), (9, 9, 3), (4, 4, 2)}`.\n    b.  Iterate through the input grid. If a pixel (r, c) with color Red(2), Green(3), or Gray(5) is found, and it hasn't been marked as 'used' by a multi-pixel object, and `(r, c, color)` is not in the ignored set, store `(r, c, color)` for transformation.\n4.  Apply transformations to the output grid in a specific order (to handle overlaps):\n    a.  For each identified Magenta(6) 2x2 square anchored at (r, c), draw a Magenta(6) 4x4 hollow square on the output grid, anchored at (r, c).\n    b.  For each identified Blue(1) L-shape, copy its pixels directly to the output grid at their original coordinates.\n    c.  For each stored single pixel `(r, c, color)`:\n        i.  If color is Red(2), draw a Yellow(4) 4x4 hollow square anchored at (r, c).\n        ii. If color is Green(3), draw a Blue(1) 4x4 hollow square anchored at (r, c).\n        iii. If color is Gray(5), draw a Gray(5) 4x4 hollow square anchored at (r, c).\n5.  Return the final output grid.\n\"\"\"\n\ndef find_yellow_hollow_squares(grid: np.ndarray) -> tuple[list[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"Finds 4x4 hollow yellow squares.\"\"\"\n    rows, cols = grid.shape\n    anchors = []\n    shape_pixels = set()\n    visited_anchors = set()\n\n    for r in range(rows - 3):\n        for c in range(cols - 3):\n            if (r, c) in visited_anchors or grid[r,c] != 4:\n                continue\n            \n            is_hollow_4x4 = True\n            current_pixels = set()\n            # Check perimeter\n            for i in range(4):\n                for pos in [(r, c+i), (r+3, c+i), (r+i, c), (r+i, c+3)]:\n                     # Check bounds and color\n                     if not (0 <= pos[0] < rows and 0 <= pos[1] < cols and grid[pos] == 4):\n                         is_hollow_4x4 = False\n                         break\n                     current_pixels.add(pos) # Add perimeter pixels\n                if not is_hollow_4x4: break\n            if not is_hollow_4x4: continue\n            \n            # Check interior is white (0)\n            for ir in range(r + 1, r + 3):\n                for ic in range(c + 1, c + 3):\n                    if not (0 <= ir < rows and 0 <= ic < cols and grid[ir, ic] == 0):\n                        is_hollow_4x4 = False\n                        break\n                if not is_hollow_4x4: break\n\n            if is_hollow_4x4:\n                anchors.append((r, c))\n                shape_pixels.update(current_pixels)\n                # Mark corners to avoid redundant checks if shapes overlap at corners\n                visited_anchors.add((r,c))\n                visited_anchors.add((r+3,c))\n                visited_anchors.add((r,c+3))\n                visited_anchors.add((r+3,c+3))\n\n    return anchors, shape_pixels\n\n\ndef find_magenta_squares(grid: np.ndarray) -> tuple[list[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"Finds 2x2 solid magenta squares.\"\"\"\n    rows, cols = grid.shape\n    anchors = []\n    shape_pixels = set()\n    \n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Check if the top-left pixel is already part of another found shape\n            if (r,c) in shape_pixels:\n                continue\n                \n            is_magenta_2x2 = True\n            current_pixels = set()\n            for dr in range(2):\n                for dc in range(2):\n                    nr, nc = r + dr, c + dc\n                    if not (0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 6):\n                        is_magenta_2x2 = False\n                        break\n                    current_pixels.add((nr, nc))\n                if not is_magenta_2x2: break\n            \n            if is_magenta_2x2:\n                # Prevent overlapping detection if a pixel is part of multiple potential squares\n                is_new = True\n                for p in current_pixels:\n                    if p in shape_pixels:\n                        is_new = False\n                        break\n                if is_new:\n                    anchors.append((r, c))\n                    shape_pixels.update(current_pixels)\n\n    return anchors, shape_pixels\n\n\ndef find_blue_l_shapes(grid: np.ndarray) -> tuple[list[set[tuple[int, int]]], set[tuple[int, int]]]:\n    \"\"\"Finds the specific 8-pixel Blue L-shape from train_2.\"\"\"\n    rows, cols = grid.shape\n    shapes_pixel_sets = []\n    shape_pixels = set()\n    \n    # Define the relative coordinates of the L-shape pixels from its effective top-left (min_r, min_c)\n    # Example from train_2 anchor (5,5): Pixels are at\n    # (5,6), (5,7), (6,5), (6,8), (7,5), (7,8), (8,6), (8,7)\n    # Relative to (5,5): (0,1), (0,2), (1,0), (1,3), (2,0), (2,3), (3,1), (3,2)\n    l_shape_relative_coords = {(0,1), (0,2), (1,0), (1,3), (2,0), (2,3), (3,1), (3,2)}\n\n    for r in range(rows - 3): # Shape spans 4 rows\n        for c in range(cols - 3): # Shape spans 4 columns\n             # Quick check on a known point like top-left-most (relative (1,0))\n            if grid[r+1, c] != 1 or (r+1,c) in shape_pixels:\n                 continue\n\n            current_shape_pixels = set()\n            is_l_shape = True\n            for dr, dc in l_shape_relative_coords:\n                nr, nc = r + dr, c + dc\n                # Check bounds, color, and if pixel is already used\n                if not (0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 1 and (nr, nc) not in shape_pixels):\n                    is_l_shape = False\n                    break\n                current_shape_pixels.add((nr, nc))\n            \n            if is_l_shape and len(current_shape_pixels) == 8:\n                 # Double check no other blue pixels are adjacent to this shape\n                 is_isolated = True\n                 for pr, pc in current_shape_pixels:\n                     for dr_adj, dc_adj in [(0,1),(0,-1),(1,0),(-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]:\n                         nr_adj, nc_adj = pr + dr_adj, pc + dc_adj\n                         if (nr_adj, nc_adj) not in current_shape_pixels: # only check neighbors outside the shape\n                              if 0 <= nr_adj < rows and 0 <= nc_adj < cols and grid[nr_adj, nc_adj] == 1:\n                                    is_isolated = False\n                                    break\n                     if not is_isolated: break\n                 \n                 if is_isolated:\n                    shapes_pixel_sets.append(current_shape_pixels)\n                    shape_pixels.update(current_shape_pixels)\n\n    return shapes_pixel_sets, shape_pixels\n\n\ndef draw_hollow_square(grid: np.ndarray, r: int, c: int, color: int):\n    \"\"\"Draws a 4x4 hollow square onto the grid anchored at (r, c).\"\"\"\n    rows, cols = grid.shape\n    for i in range(4):\n        # Top row\n        if 0 <= r < rows and 0 <= c + i < cols: grid[r, c + i] = color\n        # Bottom row\n        if 0 <= r + 3 < rows and 0 <= c + i < cols: grid[r + 3, c + i] = color\n        # Left col (excl corners)\n        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c < cols: grid[r + i, c] = color\n        # Right col (excl corners)\n        if i > 0 and i < 3 and 0 <= r + i < rows and 0 <= c + 3 < cols: grid[r + i, c + 3] = color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    output_array = np.zeros_like(input_array)  # Initialize with background color 0\n\n    # Define pixels to be explicitly ignored based on training examples\n    ignored_locations = {\n        (5, 5, 5),  # Train 1, Gray\n        (16, 2, 3), # Train 1, Green\n        (5, 5, 3),  # Train 2, Green\n        (9, 9, 3),  # Train 2, Green\n        (4, 4, 2)   # Train 3, Red\n    }\n\n    # --- 1. Identify Multi-Pixel Objects and Mark Their Pixels ---\n    all_shape_pixels = set()\n    \n    # Yellow squares are only identified to mark their pixels\n    _, yellow_pixels = find_yellow_hollow_squares(input_array)\n    all_shape_pixels.update(yellow_pixels)\n    \n    # Magenta squares: get anchors and mark pixels\n    magenta_anchors, magenta_pixels = find_magenta_squares(input_array)\n    all_shape_pixels.update(magenta_pixels)\n\n    # Blue L-shapes: get pixel sets and mark pixels\n    blue_l_shape_sets, blue_l_pixels = find_blue_l_shapes(input_array)\n    all_shape_pixels.update(blue_l_pixels)\n\n    # --- 2. Identify Single Pixels for Processing ---\n    pixels_to_process = []\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if pixel belongs to a larger identified shape\n            if (r, c) in all_shape_pixels:\n                continue\n\n            color = input_array[r, c]\n            # Check if it's a target color for single pixel transformation\n            if color in [2, 3, 5]: # Red, Green, Gray\n                # Check if this specific pixel instance should be ignored\n                if (r, c, color) not in ignored_locations:\n                    # Ensure it's truly isolated (not adjacent to same color)\n                    is_isolated = True\n                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n                         nr, nc = r + dr, c + dc\n                         # Check neighbor only if it's not part of a known shape\n                         if (nr, nc) not in all_shape_pixels:\n                            if 0 <= nr < rows and 0 <= nc < cols and input_array[nr, nc] == color:\n                                is_isolated = False\n                                break\n                    if is_isolated:\n                        pixels_to_process.append({'type': 'pixel', 'top_left': (r, c), 'color': color})\n\n    # --- 3. Apply Transformations to Output Grid ---\n    # Order: Magenta squares, Blue L shapes, Single Pixels\n    \n    # a. Draw Magenta Squares\n    for r_mag, c_mag in magenta_anchors:\n        draw_hollow_square(output_array, r_mag, c_mag, 6) # Magenta\n\n    # b. Copy Blue L-Shapes\n    for blue_set in blue_l_shape_sets:\n        for r_blue, c_blue in blue_set:\n             if 0 <= r_blue < rows and 0 <= c_blue < cols: # Bounds check just in case\n                 output_array[r_blue, c_blue] = 1 # Blue\n\n    # c. Draw squares for single pixels\n    # Sort pixels for deterministic drawing order in case of output overlap\n    pixels_to_process.sort(key=lambda p: p['top_left']) \n    for pixel_info in pixels_to_process:\n        r_pix, c_pix = pixel_info['top_left']\n        color_in = pixel_info['color']\n        \n        if color_in == 2: # Red -> Yellow\n            draw_hollow_square(output_array, r_pix, c_pix, 4)\n        elif color_in == 3: # Green -> Blue\n            draw_hollow_square(output_array, r_pix, c_pix, 1)\n        elif color_in == 5: # Gray -> Gray\n            draw_hollow_square(output_array, r_pix, c_pix, 5)\n            \n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16595,
    "candidates_token_count": 4130,
    "total_token_count": 20725,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 30.796883,
  "retries": 1
}