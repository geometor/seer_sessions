
## train_1

**input:**
```
6 6 6 6 6 7 7 7 4 4 4 4
6 6 6 6 6 7 7 7 4 4 4 4
6 6 6 1 6 7 7 7 4 4 4 4
6 6 6 3 1 7 7 7 4 9 9 9
6 6 6 1 6 7 7 7 4 4 4 9
6 6 6 6 6 7 7 7 4 4 4 9
6 6 6 6 6 7 1 7 4 4 4 4
6 6 6 6 6 7 1 1 4 4 4 4
6 6 6 6 6 7 1 7 4 4 4 4
6 6 6 6 6 7 7 7 4 4 4 4
7 7 1 7 7 7 7 7 7 7 7 7
7 1 0 1 7 7 7 7 7 1 1 1
7 7 7 7 7 7 7 7 7 7 1 7
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 3 3 3 7 7 7
7 7 7 7 7 7 7 7 7 7 3 3 3 7 7 7
7 7 7 7 7 7 7 7 7 7 3 3 3 7 7 7
7 7 7 7 7 7 7 7 7 7 3 3 3 7 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 7 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 7 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 7 7 7
0 0 0 0 0 0 0 0 0 0 3 3 3 7 7 7
0 0 0 0 0 0 0 0 0 0 3 3 3 7 7 7
0 0 0 0 0 0 0 0 0 0 3 3 3 7 7 7
0 0 0 0 0 0 0 0 0 0 3 3 3 7 7 7
0 0 0 0 0 0 0 0 0 0 3 3 3 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 1 7 3 3
7 7 7 7 7 7 1 1 3 3
7 7 7 7 7 7 1 7 3 3
8 8 8 3 1 7 7 7 3 1
8 8 8 1 1 7 7 7 1 6
8 1 8 3 1 7 7 7 3 1
8 1 1 3 3 1 9 1 3 3
8 1 8 3 3 7 1 7 3 3
8 8 8 3 3 5 5 5 3 3
8 8 8 3 3 5 5 5 3 3
```


**output:**
```
6 6 6 6 6 6 6 6 7 7
6 6 6 6 6 6 6 6 7 7
6 6 6 6 6 6 6 6 7 7
3 3 3 8 8 6 6 6 7 7
3 3 3 8 8 6 6 6 7 7
3 3 3 8 8 6 6 6 7 7
3 3 3 8 8 6 6 6 7 7
3 3 3 8 8 6 6 6 7 7
3 3 3 8 8 9 9 9 7 7
3 3 3 8 8 9 9 9 7 7
```


## train_3

**input:**
```
6 6 6 3 1 3 3 3 3
6 6 6 1 1 3 3 3 3
6 6 6 3 1 3 3 3 3
6 6 6 4 4 4 4 1 4
6 6 6 4 4 4 1 1 1
6 6 6 4 4 4 4 4 4
6 6 6 6 1 6 4 4 4
6 6 6 6 1 1 4 4 4
6 6 6 6 1 6 4 4 4
5 5 5 4 4 4 4 4 4
9 9 9 8 8 8 8 8 8
9 5 5 8 8 8 1 7 1
9 5 5 8 8 8 8 1 8
5 5 5 4 4 4 4 4 4
```


**output:**
```
5 5 5 5 5 3 3 3 3 3 3 3 3 3
5 5 5 5 5 3 3 3 3 3 3 3 3 3
5 5 5 5 5 3 3 3 3 3 3 3 3 3
7 8 8 8 6 3 3 3 6 6 6 4 4 4
7 8 8 8 6 3 3 3 6 6 6 4 4 4
7 8 8 8 6 3 3 3 6 6 6 4 4 4
7 8 8 8 6 6 6 6 6 6 6 4 4 4
7 8 8 8 6 6 6 6 6 6 6 4 4 4
7 8 8 8 6 6 6 6 6 6 6 4 4 4
```


## train_4

**input:**
```
2 2 2 2 2 1 2 3 3 3
2 2 2 2 2 1 1 3 3 3
2 2 2 2 2 1 2 3 3 3
6 6 6 6 1 6 6 3 1 3
6 6 6 1 1 1 6 1 1 3
1 1 1 6 6 6 6 3 1 3
6 1 6 6 6 6 6 3 3 3
4 4 4 4 4 4 4 3 3 3
4 4 4 4 4 4 4 3 3 3
4 4 4 4 4 4 4 3 3 3
```


**output:**
```
6 6 6 6 6 6 6 2 2 2
6 6 6 6 6 6 6 2 2 2
6 6 6 6 6 6 6 2 2 2
3 3 3 3 3 3 3 2 2 2
3 3 3 3 3 3 3 2 2 2
3 3 3 3 3 3 3 2 2 2
3 3 3 3 3 3 3 2 2 2
6 6 6 6 6 6 6 2 2 2
6 6 6 6 6 6 6 2 2 2
6 6 6 6 6 6 6 2 2 2
```

**Perception of Task Elements**

1.  **Input/Output:** Each task consists of an input grid and an output grid, both composed of pixels with colors 0-9.
2.  **Transformation:** The core task is to understand the rule that transforms the input grid into the output grid.
3.  **Grid Operations:** The transformation involves geometric operations (rotation) and color changes.
4.  **Object Identification:** The input grids contain distinct regions of solid colors, sometimes with smaller "noise" pixels of different colors embedded within or between them. The bottom-most region seems significant.
5.  **Rotation:** Across all examples, the output grid dimensions are the transpose of the input grid dimensions (Height x Width -> Width x Height). This strongly suggests a 90-degree rotation (clockwise or counter-clockwise). Comparing the arrangement of shapes confirms a 90-degree clockwise rotation.
6.  **Color Mapping:** After rotation, the colors of the regions change. This mapping is not fixed pixel-to-pixel based on the original color but depends on the *region* a pixel belonged to in the original input.
7.  **Background Region:** The region touching the bottom edge of the *original* input grid (the "background" region) appears to be treated differently from the other regions ("foreground" regions) sitting above it.
8.  **Foreground Mapping:** Foreground regions seem to map to a new color determined by a specific rule or map (`M`) for that task instance. Noise pixels within a foreground region adopt the mapped color of that region.
9.  **Background Mapping:** Pixels originating from the background region adopt a color based on the foreground region immediately adjacent to them. Specifically, after rotation, the background region (now typically on the right side) seems to take on the color of the region to its left *in the same row* of the output grid. This implies a horizontal propagation of color.

**YAML Fact Document**


```yaml
task_description: Transform an input grid to an output grid by rotating and recoloring based on original regions.

elements:
  - element: grid
    attributes:
      - type: 2D array of integers 0-9 (colors)
      - size: H x W (input), W x H (output)
      - max_size: 30x30

  - element: region
    description: Contiguous block of pixels of the same dominant color in the input grid.
    attributes:
      - color: The dominant color of the region.
      - type:
          - foreground: Regions not touching the bottom edge of the input grid.
          - background: Region(s) touching the bottom edge of the input grid.
      - noise: Some regions contain pixels of different colors.

actions:
  - action: rotate_grid
    input: input_grid
    output: rotated_grid
    details: Rotate 90 degrees clockwise.

  - action: map_colors
    input: original_region_color
    output: output_color
    details: Each foreground region's color maps to a specific output color (Map M). This map is constant within a single example pair but may vary between pairs.

  - action: color_propagation
    input: intermediate_output_grid (with mapped foreground colors and background placeholders)
    output: final_output_grid
    details: Fill background placeholder pixels by copying the color from the nearest non-background pixel to their left in the same row.

relationships:
  - relationship: pixel_origin
    entities: [output_pixel, input_pixel]
    details: Each output pixel corresponds to a specific input pixel after rotation.

  - relationship: region_mapping
    entities: [input_region, output_color]
    details: Foreground input regions determine the color of corresponding areas in the output via Map M.

  - relationship: background_fill
    entities: [output_background_pixel, output_foreground_pixel]
    details: The color of an output pixel originating from the background region is determined by the color of the output pixel to its left in the same row that originated from a foreground region.

processing_steps:
  - step: Identify background region color B based on the bottom row of the input grid.
  - step: Identify foreground regions and their colors C1, C2, ...
  - step: Determine the color map M: {C1:O1, C2:O2, ...} by comparing foreground regions in input and output after accounting for rotation.
  - step: Rotate the input grid 90 degrees clockwise.
  - step: Create an intermediate output grid. For each pixel, find its original color/region. If it's from a foreground region Ci, color the intermediate pixel with M[Ci]. If it's from the background region B, mark it as a placeholder (-1). Noise pixels inherit the mapped color of their region.
  - step: Create the final output grid by filling the background placeholders (-1) by propagating the color from the nearest non-placeholder pixel to the left in the same row.
```


**Natural Language Program**

1.  **Identify Regions:** Analyze the input grid to identify distinct regions based on contiguous blocks of the same color. Distinguish the "background" region(s) (touching the bottom edge of the input) from the "foreground" regions (those above the background). Note the primary color of each region.
2.  **Determine Color Map:** Observe the color changes between the input foreground regions and their corresponding regions in the output grid (accounting for rotation). Define a color map `M` where `M[input_foreground_region_color] = output_color`.
3.  **Rotate:** Rotate the entire input grid 90 degrees clockwise.
4.  **Initial Coloring:** Create a new grid (the size of the rotated grid). Iterate through each pixel `(r, c)` of the rotated grid. Find the color and region type of the corresponding pixel in the *original* input grid.
    *   If the original pixel belonged to a foreground region with color `C`, set the new grid pixel `(r, c)` to `M[C]`. Handle noise pixels by using the map for their encompassing region's color.
    *   If the original pixel belonged to the background region, mark the new grid pixel `(r, c)` as a special placeholder (e.g., -1).
5.  **Propagate Background Color:** Iterate through the new grid, row by row, from left to right (column index `c` from 0 upwards). Keep track of the last non-placeholder color encountered (`last_color`) in the current row.
    *   If the current pixel `(r, c)` is not a placeholder, update `last_color` with its value.
    *   If the current pixel `(r, c)` is a placeholder, change its value to `last_color`. (If the leftmost pixel(s) are placeholders, they need a default behavior, potentially propagating from the right or using a default color, though based on examples, propagation from the left seems sufficient).
6.  **Final Output:** The resulting grid after propagation is the final output.
