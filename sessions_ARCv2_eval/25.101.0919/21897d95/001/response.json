{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nThe transformation involves rotating the input grid 90 degrees clockwise and then recoloring the grid based on the original structure. \n\n1.  **Region Identification**: The input grid is segmented into contiguous regions. Regions touching the bottom edge of the input grid are identified as 'background' regions. All other regions are 'foreground' regions. Within each foreground region, pixels that have a different color from the region's main color are identified as 'noise'.\n2.  **Rotation**: The entire input grid is rotated 90 degrees clockwise.\n3.  **Color Mapping (Foreground)**: A color mapping rule is determined based on the 'noise' pixels within each original foreground region. \n    - If a foreground region contains exactly one unique noise color, all pixels originating from that region (including the noise pixels themselves) are mapped to that noise color in the output grid.\n    - If a foreground region contains no noise or multiple different noise colors, the mapping rule is currently ambiguous based on the provided examples. A fallback or alternative rule would be needed. (For this implementation, we will use the original region color as a fallback, acknowledging this might be incorrect).\n4.  **Placeholder Assignment (Background)**: Pixels in the rotated grid that originated from a background region in the input grid are initially assigned a special placeholder value (e.g., -1).\n5.  **Color Propagation (Background)**: The placeholder values are filled by propagating the color from the nearest non-placeholder pixel to the left within the same row of the rotated grid. If a row starts with placeholders, they will take the color of the first non-placeholder pixel encountered in that row.\n\"\"\"\n\ndef find_regions(grid: np.ndarray) -> tuple[np.ndarray, dict]:\n    \"\"\"\n    Identifies background and foreground regions, their dominant colors, and noise colors.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple containing:\n            - labeled_grid: A grid where each region has a unique integer label.\n            - region_info: A dictionary where keys are region labels and values are\n                           dicts containing {'type': 'bg'/'fg', 'color': dominant_color, 'noise': set_of_noise_colors}.\n    \"\"\"\n    h, w = grid.shape\n    labeled_grid, num_labels = label(grid) # Initial labeling based on identical adjacent colors\n\n    region_info = {}\n    background_labels = set()\n\n    # Identify initial background labels (touching bottom edge)\n    for c in range(w):\n        if labeled_grid[h - 1, c] != 0: # 0 is the background label from scipy.ndimage.label if grid has 0s\n             # Find the actual component label at this position based on value\n             val = grid[h-1, c]\n             temp_labeled_mask, _ = label(grid == val)\n             bg_label_at_pos = temp_labeled_mask[h-1, c]\n             # Map this component label back to the full grid labeling\n             # This is complex because label() doesn't guarantee consistency across calls or values\n             # Let's use a simpler approach: flood fill from bottom edge for background\n\n    # Simpler approach: Find all unique colors touching the bottom edge\n    background_colors = set(grid[h-1, :])\n\n    # Create a mask for all background pixels\n    bg_mask = np.zeros_like(grid, dtype=bool)\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] in background_colors:\n                 # Check connectivity to bottom edge (flood fill conceptually)\n                 # For simplicity here, assume any pixel with a background color *might* be background\n                 # A true flood fill from bottom is more accurate\n                 bg_mask[r,c] = True # Mark potential background\n\n    # Refine bg_mask using connectivity - only keep connected components touching the bottom\n    bg_labeled, num_bg_labels = label(bg_mask)\n    actual_bg_labels = set(bg_labeled[h-1, :])\n    if 0 in actual_bg_labels: # scipy labels background as 0\n        actual_bg_labels.remove(0)\n\n    final_bg_mask = np.isin(bg_labeled, list(actual_bg_labels))\n\n    # Label the grid again, separating bg and fg definitively\n    # We need a robust way to define regions independent of color noise\n    # Let's define regions by contiguous non-background areas first\n    fg_mask = ~final_bg_mask\n    labeled_fg, num_fg_labels = label(fg_mask)\n\n    region_labels = np.zeros_like(grid)\n    region_counter = 1\n    region_data = {}\n\n    # Process foreground regions\n    for i in range(1, num_fg_labels + 1):\n        coords = np.argwhere(labeled_fg == i)\n        if coords.size == 0: continue\n\n        region_pixels = grid[coords[:, 0], coords[:, 1]]\n        dominant_color = np.bincount(region_pixels).argmax()\n        all_colors = set(region_pixels)\n        noise_colors = all_colors - {dominant_color}\n\n        region_labels[coords[:, 0], coords[:, 1]] = region_counter\n        region_data[region_counter] = {'type': 'fg', 'color': dominant_color, 'noise': noise_colors}\n        region_counter += 1\n\n    # Process background region(s) - treat as one type for propagation\n    bg_coords = np.argwhere(final_bg_mask)\n    if bg_coords.size > 0:\n        # Use a special label, e.g., 0 or -1, for background? Let's use 0.\n         region_labels[bg_coords[:, 0], bg_coords[:, 1]] = 0 # Background label\n         # For simplicity, don't store detailed info for background, just label it 0\n         region_data[0] = {'type': 'bg', 'color': -1, 'noise': set()} # Placeholder color/noise\n\n    # Return the grid labeled by our region IDs and the associated data\n    return region_labels, region_data\n\n\ndef apply_color_map(region_color: int, noise_set: set[int]) -> int:\n    \"\"\" Applies the color mapping rule based on noise. \"\"\"\n    if len(noise_set) == 1:\n        # Rule: If exactly one unique noise color, map to that noise color.\n        return list(noise_set)[0]\n    else:\n        # Fallback Rule (Ambiguous): If no noise or multiple noise colors, return original color.\n        # This part is uncertain based on the examples and might need revision.\n        return region_color\n\ndef propagate_background(grid: np.ndarray, placeholder: int = -1) -> np.ndarray:\n    \"\"\" Fills placeholder values by propagating color from the left. \"\"\"\n    output_grid = grid.copy()\n    h, w = output_grid.shape\n    for r in range(h):\n        last_valid_color = -1 # Use -1 to indicate no valid color seen yet in the row\n        # Find the first non-placeholder color to handle rows starting with placeholders\n        first_valid_idx = -1\n        for c in range(w):\n            if output_grid[r, c] != placeholder:\n                first_valid_idx = c\n                last_valid_color = output_grid[r, c]\n                break\n\n        # If the entire row is placeholder, behavior is undefined. Let's leave it placeholder or fill with 0? Fill with 0.\n        if first_valid_idx == -1:\n             output_grid[r, :] = 0\n             continue\n\n        # Propagate from left\n        for c in range(w):\n            if output_grid[r, c] == placeholder:\n                output_grid[r, c] = last_valid_color\n            else:\n                last_valid_color = output_grid[r, c]\n                \n    # Ensure no placeholders remain (e.g., if a row started with them)\n    # The logic above should handle this, but double check.\n    if np.any(output_grid == placeholder):\n        # This case implies a row was *all* placeholders. Replace with a default (e.g., 0).\n         output_grid[output_grid == placeholder] = 0 \n\n    return output_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the rotate, map, and propagate rule.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    h, w = input_array.shape\n    placeholder = -1\n\n    # 1. Identify Regions and Noise in the original grid\n    # Need a robust region finding that handles noise correctly.\n    # The simple approach: assume regions are defined by the dominant color locally.\n    # Let's stick to the structure identified: background vs foreground.\n    \n    # Determine background color(s) from the bottom row of the input\n    background_colors = set(input_array[h - 1, :])\n\n    # Create a map of original coordinates to their region type (fg/bg) and original color\n    original_info = {}\n    for r in range(h):\n        for c in range(w):\n            color = input_array[r, c]\n            # Simple check: is the color one found on the bottom row?\n            # This isn't perfect for identifying the full background region,\n            # but serves to classify pixels for now. A better way involves connectivity.\n            # Let's assume any pixel touching the bottom edge IS background, others are foreground.\n            is_background = (r == h - 1) \n            # A slightly better approach: connected component touching bottom\n            # For now, we'll use the simpler idea: only bottom row is bg source\n            # This doesn't match the propagation logic well.\n            # Let's revert to the idea of \"background COLOR\" vs \"foreground COLOR\" pixels\n            \n            # Redo region finding logic properly\n    labeled_input_grid, region_info = find_regions(input_array)\n\n\n    # 2. Rotate the input grid 90 degrees clockwise\n    rotated_array = np.rot90(input_array, k=-1)\n    rotated_h, rotated_w = rotated_array.shape\n    output_array = np.full((rotated_h, rotated_w), placeholder, dtype=int)\n\n    # 3. Initial Coloring based on original region type and map\n    for r_rot in range(rotated_h):\n        for c_rot in range(rotated_w):\n            # Find corresponding original coordinates\n            # Rotation: (r, c) -> (c, H - 1 - r) for 90 deg clockwise\n            r_orig = rotated_w - 1 - c_rot\n            c_orig = r_rot\n\n            if 0 <= r_orig < h and 0 <= c_orig < w:\n                original_label = labeled_input_grid[r_orig, c_orig]\n                info = region_info.get(original_label)\n\n                if info and info['type'] == 'fg':\n                    # Apply color map based on noise\n                    mapped_color = apply_color_map(info['color'], info['noise'])\n                    output_array[r_rot, c_rot] = mapped_color\n                elif info and info['type'] == 'bg':\n                    # Mark for propagation\n                    output_array[r_rot, c_rot] = placeholder\n                else: # Should not happen if find_regions is correct\n                     output_array[r_rot, c_rot] = 0 # Default fallback\n            else: # Should not happen with numpy rotation\n                 output_array[r_rot, c_rot] = 0\n\n\n    # 4. Propagate color into background placeholders\n    final_output_array = propagate_background(output_array, placeholder)\n\n    # Convert back to list of lists\n    return final_output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4774,
    "candidates_token_count": 7705,
    "total_token_count": 12479,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 76.033874,
  "retries": 1
}