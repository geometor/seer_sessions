{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid according to the following rules:\n\n1.  **Identify Background/Foreground:** \n    - Background pixels belong to connected components (8-way) that both touch the bottom edge of the input grid and consist of colors found on that bottom edge.\n    - Foreground pixels are all pixels that are not background pixels.\n\n2.  **Calculate Output Background Color:**\n    - Find the set of unique colors present in the background mask.\n    - If the set is empty, the output background color is 0.\n    - Otherwise, the output background color is max(0, min(background colors) - 1). \n      (Note: Analysis showed this rule doesn't match all training examples perfectly).\n\n3.  **Identify Structural Foreground Regions and Determine Output Color:**\n    - Structural foreground regions are connected components (8-way) based on the foreground mask (ignoring color for connectivity).\n    - For each structural region:\n        - Find its dominant color (most frequent color within the region).\n        - Find the set of noise colors (other unique colors within the region).\n        - If there's exactly one unique noise color, the entire region maps to that noise color.\n        - Otherwise (zero or multiple noise colors), the entire region maps to its dominant color.\n\n4.  **Rotation and Final Coloring:**\n    - Rotate the input grid 90 degrees clockwise.\n    - Create the output grid.\n    - For each pixel in the output grid, find its corresponding pixel in the original input grid.\n    - If the original pixel was background, assign the calculated output background color.\n    - If the original pixel was foreground, assign the output color determined for its structural region based on the noise rule (Step 3).\n\"\"\"\n\ndef _find_background_mask(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Identifies pixels belonging to connected components that touch the bottom edge\n    and consist of colors present on the bottom edge. Uses 8-way connectivity.\n    \"\"\"\n    h, w = grid.shape\n    if h == 0:\n        return np.zeros((h, w), dtype=bool) # Handle empty grid\n\n    # Get the set of unique colors present on the bottom row\n    bottom_row_colors = set(grid[h - 1, :])\n    if not bottom_row_colors:\n        return np.zeros((h, w), dtype=bool) # Handle empty bottom row\n\n    # Create a mask where pixels have one of the bottom row colors\n    potential_bg_mask = np.isin(grid, list(bottom_row_colors))\n\n    # Label connected components within this potential background mask (8-way)\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool)\n    labeled_potential_bg, num_labels = label(potential_bg_mask, structure=structure)\n\n    # Identify the labels of components that actually touch the bottom row\n    labels_touching_bottom = set(labeled_potential_bg[h - 1, :])\n    if 0 in labels_touching_bottom: # 0 is the label for non-mask areas\n        labels_touching_bottom.remove(0)\n\n    # If no components touch the bottom row, there's no background by this definition\n    if not labels_touching_bottom:\n        return np.zeros((h, w), dtype=bool)\n\n    # The final background mask includes only pixels belonging to those components touching the bottom\n    background_mask = np.isin(labeled_potential_bg, list(labels_touching_bottom))\n    return background_mask\n\ndef _calculate_output_bg_color(grid: np.ndarray, bg_mask: np.ndarray) -> int:\n    \"\"\"\n    Calculates the output background color based on the min input background color - 1 rule.\n    \"\"\"\n    if not np.any(bg_mask):\n        return 0 # Default if no background pixels\n\n    background_colors = grid[bg_mask]\n    if background_colors.size == 0:\n        return 0 # Should be covered by np.any, but safe check\n\n    min_bg_color = np.min(background_colors)\n    output_bg_color = max(0, min_bg_color - 1)\n    return output_bg_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the rotate, map-by-noise, and fill-background rule.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    h, w = input_array.shape\n    fallback_color = 0 # Default color if mapping fails\n\n    # Handle empty input grid\n    if h == 0 or w == 0:\n        return [[] for _ in range(w)] if w > 0 else []\n\n    # --- Step 1: Identify Background/Foreground Masks ---\n    bg_mask = _find_background_mask(input_array)\n    fg_mask = ~bg_mask\n\n    # --- Step 2: Calculate Output Background Color ---\n    output_bg_color = _calculate_output_bg_color(input_array, bg_mask)\n\n    # --- Step 3: Identify Structural FG Regions, Analyze Noise, Determine Output Color ---\n    # Create a grid to store the calculated output color for each input foreground pixel\n    region_output_color_map_grid = np.full((h, w), fallback_color, dtype=int) # Initialize with fallback\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool) # 8-way connectivity\n\n    # Label connected components based on the foreground mask structure\n    labeled_fg_structure, num_fg_regions = label(fg_mask, structure=structure)\n\n    for region_id in range(1, num_fg_regions + 1):\n        # Get mask for the current structural region\n        component_mask = (labeled_fg_structure == region_id)\n        component_pixels = input_array[component_mask]\n\n        if component_pixels.size == 0:\n            continue\n\n        # Find the dominant color within this structural component\n        colors, counts = np.unique(component_pixels, return_counts=True)\n        # Handle tie-breaking for dominant color if needed (e.g., lowest color index)\n        dominant_color = colors[np.argmax(counts)]\n        if len(colors) > 1 and np.sum(counts == counts.max()) > 1:\n             # Tie detected, choose lowest color index among tied max counts\n             tied_colors = colors[counts == counts.max()]\n             dominant_color = min(tied_colors)\n\n\n        # Find noise colors within this structural component\n        noise_colors = set(colors) - {dominant_color}\n\n        # Determine the output color based on the noise rule\n        output_fg_color = fallback_color # Default\n        if len(noise_colors) == 1:\n            output_fg_color = list(noise_colors)[0]\n        else:\n            # Zero or multiple noise colors -> use dominant color\n            output_fg_color = dominant_color\n\n        # Assign this output color to all pixels belonging to this structural region in the map\n        region_output_color_map_grid[component_mask] = output_fg_color\n\n    # --- Step 4: Rotate and Construct Output Grid ---\n    rotated_h, rotated_w = w, h\n    output_array = np.zeros((rotated_h, rotated_w), dtype=int) # Initialize output\n\n    # Loop through each pixel of the *output* grid\n    for r_out in range(rotated_h):\n        for c_out in range(rotated_w):\n            # Calculate corresponding coordinates in the *original* input grid\n            # Clockwise rotation: input (r_in, c_in) -> output (c_in, H_in - 1 - r_in)\n            # Inverse: output (r_out, c_out) -> input (H_in - 1 - c_out, r_out)\n            r_in = h - 1 - c_out\n            c_in = r_out\n\n            # Ensure calculated input coordinates are valid\n            if 0 <= r_in < h and 0 <= c_in < w:\n                # Check if the original pixel was background\n                if bg_mask[r_in, c_in]:\n                    output_array[r_out, c_out] = output_bg_color\n                else:\n                    # Assign the pre-calculated output color for the foreground region\n                    output_array[r_out, c_out] = region_output_color_map_grid[r_in, c_in]\n            else:\n                 # Fallback for out-of-bounds calculation (should not happen)\n                 output_array[r_out, c_out] = fallback_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 59162,
    "candidates_token_count": 2736,
    "total_token_count": 61898,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.774925,
  "retries": 1
}