{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Identify Background/Foreground:** \n    - Background pixels belong to connected components that both touch the bottom edge of the input grid and consist of colors found on that bottom edge.\n    - Foreground pixels are all pixels that are not background pixels.\n\n2.  **Identify Foreground Regions and Determine Output Color:**\n    - Foreground regions are maximal connected components of foreground pixels initially having the same color (the 'dominant color').\n    - For each foreground region, identify any 'noise' pixels within it (pixels of a different color).\n    - If a region has exactly one unique noise color, the entire region (including noise pixels) maps to that single noise color in the output.\n    - Otherwise (zero or multiple noise colors), the entire region maps to its original dominant color in the output.\n\n3.  **Rotation and Initial Coloring:**\n    - Rotate the input grid 90 degrees clockwise.\n    - Create an intermediate grid.\n    - For each pixel in the intermediate grid, find its corresponding pixel in the original input grid.\n    - If the original pixel was background, mark the intermediate pixel with a placeholder value (-1).\n    - If the original pixel was foreground, find the output color determined in Step 2 for its region and place that color in the intermediate grid.\n\n4.  **Background Propagation:**\n    - Fill the placeholder values in the intermediate grid.\n    - For each row, iterate from left to right. Replace any placeholder pixel with the value of the nearest non-placeholder pixel found to its left in the same row.\n    - If a row starts with placeholders, they take the value of the first non-placeholder pixel encountered in that row. If a row consists entirely of placeholders, fill it with a default color (e.g., 0).\n\"\"\"\n\ndef _find_background_mask(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Identifies pixels belonging to connected components that touch the bottom edge\n    and consist of colors present on the bottom edge. Uses 8-way connectivity.\n    \"\"\"\n    h, w = grid.shape\n    if h == 0:\n        return np.zeros((h, w), dtype=bool) # Handle empty grid\n\n    # Get the set of unique colors present on the bottom row\n    bottom_row_colors = set(grid[h - 1, :])\n    if not bottom_row_colors:\n        return np.zeros((h, w), dtype=bool) # Handle empty bottom row\n\n    # Create a mask where pixels have one of the bottom row colors\n    potential_bg_mask = np.isin(grid, list(bottom_row_colors))\n\n    # Label connected components within this potential background mask\n    # Use a structure that defines 8-way connectivity\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool)\n    labeled_potential_bg, num_labels = label(potential_bg_mask, structure=structure)\n\n    # Identify the labels of components that actually touch the bottom row\n    labels_touching_bottom = set(labeled_potential_bg[h - 1, :])\n    if 0 in labels_touching_bottom: # 0 is the label for non-mask areas\n        labels_touching_bottom.remove(0)\n\n    # If no components touch the bottom row, there's no background by this definition\n    if not labels_touching_bottom:\n        return np.zeros((h, w), dtype=bool)\n\n    # The final background mask includes only pixels belonging to those components touching the bottom\n    background_mask = np.isin(labeled_potential_bg, list(labels_touching_bottom))\n    return background_mask\n\ndef _propagate_background(grid: np.ndarray, placeholder: int = -1, default_fill: int = 0) -> np.ndarray:\n    \"\"\"\n    Fills placeholder values by propagating the color from the nearest\n    non-placeholder pixel to the left within the same row.\n    Fills rows that are all placeholders with default_fill.\n    \"\"\"\n    output_grid = grid.copy()\n    h, w = output_grid.shape\n\n    for r in range(h):\n        last_valid_color = -1 # Indicates no valid color seen yet in this row\n        first_valid_found = False\n\n        # Find the first non-placeholder color to handle rows starting with placeholders\n        for c in range(w):\n            if output_grid[r, c] != placeholder:\n                last_valid_color = output_grid[r, c]\n                first_valid_found = True\n                break\n\n        # If the entire row is placeholder, fill with default\n        if not first_valid_found:\n            output_grid[r, :] = default_fill\n            continue # Move to next row\n\n        # Propagate from left\n        current_fill_color = last_valid_color # Start filling with the first valid color found\n        for c in range(w):\n            if output_grid[r, c] == placeholder:\n                output_grid[r, c] = current_fill_color\n            else:\n                # Update the color to propagate when a non-placeholder is encountered\n                current_fill_color = output_grid[r, c]\n\n    return output_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the rotate, map-by-noise, and propagate rule.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    h, w = input_array.shape\n    placeholder = -1\n    fallback_color = 0 # Default color if mapping fails or for all-placeholder rows\n\n    # Handle empty input grid\n    if h == 0 or w == 0:\n        return [[] for _ in range(w)] if w > 0 else []\n\n    # --- Step 1: Identify Background/Foreground Masks ---\n    bg_mask = _find_background_mask(input_array)\n    fg_mask = ~bg_mask\n\n    # --- Step 2 & 3: Identify FG Regions, Analyze Noise, Determine Output Color ---\n    # Create a grid to store the calculated output color for each input foreground pixel\n    # Initialize with a value indicating \"not calculated\" or \"background\"\n    region_output_color_map_grid = np.full((h, w), placeholder, dtype=int)\n    structure = np.array([[1,1,1], [1,1,1], [1,1,1]], dtype=bool) # 8-way connectivity\n\n    # Label connected components *purely based on the foreground mask structure* first\n    # This helps group noise pixels with their surrounding region initially.\n    labeled_fg_structure, num_fg_regions = label(fg_mask, structure=structure)\n\n    for region_id in range(1, num_fg_regions + 1):\n        # Get mask for the current structural region\n        component_mask = (labeled_fg_structure == region_id)\n        component_pixels = input_array[component_mask]\n\n        if component_pixels.size == 0:\n            continue\n\n        # Find the dominant color within this structural component\n        colors, counts = np.unique(component_pixels, return_counts=True)\n        dominant_color = colors[np.argmax(counts)]\n\n        # Find noise colors within this structural component\n        noise_colors = set(colors) - {dominant_color}\n\n        # Determine the output color based on the noise rule\n        output_color = fallback_color # Default if something goes wrong\n        if len(noise_colors) == 1:\n            output_color = list(noise_colors)[0]\n        else:\n            # Zero or multiple noise colors -> use dominant color\n            output_color = dominant_color\n\n        # Assign this output color to all pixels belonging to this structural region\n        region_output_color_map_grid[component_mask] = output_color\n\n\n    # --- Step 4: Rotate and Create Intermediate Grid ---\n    rotated_h, rotated_w = w, h\n    intermediate_grid = np.full((rotated_h, rotated_w), placeholder, dtype=int)\n\n    # Loop through each pixel of the *output* grid\n    for r_out in range(rotated_h):\n        for c_out in range(rotated_w):\n            # Calculate corresponding coordinates in the *original* input grid\n            # Clockwise rotation: input (r_in, c_in) -> output (c_in, H_in - 1 - r_in)\n            # Inverse: output (r_out, c_out) -> input (H_in - 1 - c_out, r_out)\n            r_in = h - 1 - c_out\n            c_in = r_out\n\n            # Ensure calculated input coordinates are valid\n            if 0 <= r_in < h and 0 <= c_in < w:\n                # Check if the original pixel was background\n                if bg_mask[r_in, c_in]:\n                    intermediate_grid[r_out, c_out] = placeholder\n                else:\n                    # Assign the pre-calculated output color for the foreground region\n                    mapped_color = region_output_color_map_grid[r_in, c_in]\n                    # Ensure it's not still the placeholder value if logic was perfect\n                    intermediate_grid[r_out, c_out] = mapped_color if mapped_color != placeholder else fallback_color\n            else:\n                 # Fallback for out-of-bounds calculation (should not happen)\n                 intermediate_grid[r_out, c_out] = fallback_color\n\n    # --- Step 5: Propagate Background Color ---\n    final_output_array = _propagate_background(intermediate_grid, placeholder, fallback_color)\n\n    # Convert the final numpy array back to a list of lists\n    return final_output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40674,
    "candidates_token_count": 3489,
    "total_token_count": 44163,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 28.867861,
  "retries": 1
}