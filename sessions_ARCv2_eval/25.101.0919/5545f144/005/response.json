{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation rule:\n1. Determine the `background_color` (most frequent color) in the input grid.\n2. Identify all full-height, single-color vertical `separator_lines` whose color is not the `background_color`. Record the color and column index for each.\n3. Determine the `primary_separator_color` by finding which non-background color forms the maximum number `N` of `separator_lines`. Break ties by choosing the color whose first `separator_line` appears at the smallest column index.\n4. Get the sorted list of `primary_separator_indices` `[idx_1, idx_2, ..., idx_N]` for the `primary_separator_color`. If no primary separators exist (`N=0`), return the input grid unchanged.\n5. Determine the output grid dimensions: height `H` is the input height, width `W_out` is `idx_1`. Handle cases where `idx_1` is 0 or less (separator at the very edge).\n6. Create the `output_grid` of size `H` x `W_out`, initialized with the `background_color`.\n7. Define the `source_section` as the slice of the input grid containing all rows and columns from `idx_N + 1` up to `idx_N + W_out`. Ensure the column indices do not exceed the input grid width (`W_in`). If `idx_N + 1 >= W_in` or `W_out <= 0`, the source section is empty or invalid for pattern extraction.\n8. Extract unique row patterns from the `source_section`. A pattern is a tuple of pixel values in a row of the source section. Only consider patterns that contain at least one color different from the `background_color`.\n9. For each unique non-background pattern `P` found, record the minimum row index `r_min` (0-based, relative to the start of the source section/grid) where it first appears in the `source_section`.\n10. Determine the target row `target_row` for placing each pattern `P` in the `output_grid`:\n    *   If `N` (the count of primary separators) is exactly 3, then `target_row = r_min + 2`.\n    *   If `N` is not 3 (e.g., N=1 or N=2), then `target_row = r_min`.\n11. For each unique pattern `P` and its corresponding calculated `target_row`: if `0 <= target_row < H`, place the pattern `P` into the `output_grid` at row `target_row`, overwriting the existing background pixels.\n12. Return the final `output_grid` as a list of lists.\n\"\"\"\n\ndef find_most_frequent_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color (pixel value) in the grid.\"\"\"\n    if grid.size == 0:\n        return 0 # Default for empty grid\n    colors, counts = np.unique(grid, return_counts=True)\n    if colors.size == 0:\n         return 0 # Default if grid was just one value repeated\n    return int(colors[np.argmax(counts)])\n\ndef find_separator_lines(grid: np.ndarray, bg_color: int) -> dict[int, list[int]]:\n    \"\"\"\n    Finds all full-height, single-color, non-background vertical lines.\n    Returns a dictionary mapping separator color to a list of column indices.\n    \"\"\"\n    separator_lines = defaultdict(list)\n    if grid.shape[0] == 0: # Handle grids with zero height\n        return separator_lines\n        \n    h, w = grid.shape\n    for c_idx in range(w):\n        col = grid[:, c_idx]\n        # Check if all elements in the column are the same\n        if np.all(col == col[0]):\n            col_color = int(col[0])\n            # Check if it's not the background color\n            if col_color != bg_color:\n                separator_lines[col_color].append(c_idx)\n    return separator_lines\n\ndef find_primary_separator_info(separator_lines: dict[int, list[int]]) -> tuple[int, list[int]]:\n    \"\"\"\n    Determines the primary separator color (most frequent, tie-break by first appearance)\n    and returns the color and its sorted list of column indices.\n    Returns (-1, []) if no separators are found.\n    \"\"\"\n    if not separator_lines:\n        return -1, []\n\n    primary_sep_col = -1\n    max_lines = -1\n    \n    # Iterate through colors sorted by their first appearance index\n    sorted_colors = sorted(separator_lines.keys(), key=lambda color: separator_lines[color][0])\n\n    for color in sorted_colors:\n        indices = separator_lines[color]\n        count = len(indices)\n        \n        # If this color has more lines, it becomes the new primary\n        # Tie-breaking is handled implicitly by the sort order\n        if count > max_lines:\n             max_lines = count\n             primary_sep_col = color\n\n    if primary_sep_col != -1:\n        return primary_sep_col, sorted(separator_lines[primary_sep_col])\n    else:\n        return -1, [] # Should not happen if separator_lines is not empty\n\ndef extract_unique_patterns(section: np.ndarray, bg_color: int) -> dict[tuple, int]:\n    \"\"\"\n    Extracts unique row patterns containing non-background colors from a given grid section.\n    Returns a dictionary mapping tuple(pattern) -> min_row_index (relative to the section's rows).\n    \"\"\"\n    patterns = {}\n    if section.size == 0 or section.shape[1] == 0: # Handle empty or zero-width section\n        return patterns\n        \n    h = section.shape[0]\n    for r in range(h):\n        row_pattern = tuple(section[r, :]) \n        # Check if pattern contains any non-background color\n        if any(pixel != bg_color for pixel in row_pattern):\n            # Store the first row index where this pattern is encountered\n            if row_pattern not in patterns:\n                patterns[row_pattern] = r\n    return patterns\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on vertical separator lines and pattern extraction/placement.\n    \"\"\"\n    # Convert list of lists to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid\n    if input_array.size == 0:\n        return []\n\n    H, W_in = input_array.shape\n\n    # Step 1: Determine background color\n    bg_color = find_most_frequent_color(input_array)\n\n    # Step 2: Find all separator lines\n    separator_lines = find_separator_lines(input_array, bg_color)\n\n    # Step 3: Find primary separator info\n    primary_sep_color, primary_sep_indices = find_primary_separator_info(separator_lines)\n\n    # Step 4: Get count N and handle N=0 case\n    N = len(primary_sep_indices)\n    if N == 0:\n        return input_grid # Return input unchanged if no primary separators\n\n    # Step 5: Determine output dimensions\n    idx_1 = primary_sep_indices[0]\n    W_out = idx_1 # Width is determined by the first separator's position\n    \n    # Handle edge case: separator at column 0 means zero width output\n    if W_out <= 0:\n        return [[] for _ in range(H)] # Return list of empty lists for correct height\n\n    # Step 6: Initialize output grid with background color\n    output_array = np.full((H, W_out), bg_color, dtype=int)\n\n    # Step 7: Define the source section\n    idx_N = primary_sep_indices[-1]\n    source_start_col = idx_N + 1\n    source_end_col = source_start_col + W_out # Theoretical end\n\n    source_section = np.array([[] for _ in range(H)], dtype=int) # Default empty section\n    if source_start_col < W_in:\n        actual_end_col = min(source_end_col, W_in)\n        # Ensure start and end make sense before slicing\n        if actual_end_col > source_start_col:\n             source_section = input_array[:, source_start_col:actual_end_col]\n\n    # Step 8 & 9: Extract unique patterns and their min row index\n    # Ensure source section has the correct width before extracting patterns\n    unique_patterns = {}\n    if source_section.shape[1] == W_out:\n        unique_patterns = extract_unique_patterns(source_section, bg_color)\n\n    # Step 10 & 11: Place patterns into the output grid based on N and r_min\n    for pattern_tuple, r_min in unique_patterns.items():\n        # Determine target row based on N\n        if N == 3:\n            target_row = r_min + 2\n        else: # N != 3 (includes N=1, N=2)\n            target_row = r_min\n            \n        # Check if target row is valid within output grid height\n        if 0 <= target_row < H:\n            # Ensure pattern length matches output width before assignment\n            if len(pattern_tuple) == W_out:\n                output_array[target_row, :] = list(pattern_tuple)\n            # else: log warning or handle mismatch? Silently ignore for now.\n\n    # Step 12: Convert final NumPy array back to list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23961,
    "candidates_token_count": 2796,
    "total_token_count": 26757,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.383444,
  "retries": 1
}