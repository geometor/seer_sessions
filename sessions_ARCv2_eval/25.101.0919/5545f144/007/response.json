{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation rule:\n1. Determine the `background_color` (most frequent color) in the input grid.\n2. Identify all full-height, single-color vertical `separator_lines`. A separator line is a column where all pixels share the same color, and this color is not the `background_color`. Record the color and column index for each separator line found.\n3. Determine the `primary_separator_color`. This is the color that forms the maximum number (`N`) of `separator_lines`. If multiple colors form the maximum number of lines, choose the color whose first separator line appears at the smallest column index (leftmost).\n4. Get the sorted list of column indices `[idx_1, idx_2, ..., idx_N]` where separator lines of the `primary_separator_color` occur.\n5. If no primary separators are found (`N=0`), return the input grid unmodified.\n6. Determine the output grid dimensions: height `H` is the same as the input height; width `W_out` is the index of the first primary separator line (`idx_1`). If `W_out` is 0 or less, return an empty grid of height H.\n7. Create the `output_grid` of size `H` x `W_out`, initialized entirely with the `background_color`.\n8. Define the `source_section` of the input grid: it comprises all rows and the columns from index `idx_N + 1` up to `idx_N + W_out`.\n9. Validate the `source_section`: Check if it exists within the input grid bounds and if its actual width is exactly `W_out`. If not valid, proceed to step 13 (return the background-filled output grid).\n10. Extract unique row patterns from the valid `source_section`. A pattern is considered unique if its sequence of colors has not been encountered before in a lower row index within the source section. Only consider patterns that contain at least one pixel different from the `background_color`.\n11. For each unique non-background pattern `P` identified, record the minimum row index `r_min` (0-based, relative to the grid) where it first appeared in the `source_section`.\n12. Determine the target row `target_row` for placing each unique pattern `P` into the `output_grid`:\n    *   If `N` (the count of primary separators) is exactly 3, then `target_row = r_min + 2`.\n    *   If `N` is not 3 (i.e., `N=1`, `N=2`, or `N>3`), then `target_row = r_min`.\n    *   (Self-Correction Note: This `N!=3` rule is known to produce incorrect results for `train_1` (N=2) and `train_3` (N=1) by including more patterns than expected. The correct rule likely involves filtering the patterns from the source section before placement, but the exact filter is not yet determined.)\n13. For each unique pattern `P` and its corresponding calculated `target_row`: if the `target_row` is a valid row index within the output grid (i.e., `0 <= target_row < H`), place the pattern `P` into the `output_grid` at that row, overwriting the background pixels.\n14. Return the final `output_grid`.\n\"\"\"\n\ndef find_most_frequent_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color (pixel value) in the grid.\"\"\"\n    if grid.size == 0:\n        return 0 # Default for empty grid\n    colors, counts = np.unique(grid, return_counts=True)\n    if colors.size == 0:\n         # This case shouldn't happen if grid.size > 0, but handle defensively\n         return 0 \n    return int(colors[np.argmax(counts)])\n\ndef find_separator_lines(grid: np.ndarray, bg_color: int) -> dict[int, list[int]]:\n    \"\"\"\n    Finds all full-height, single-color, non-background vertical lines.\n    Returns a dictionary mapping separator color to a list of column indices.\n    \"\"\"\n    separator_lines = defaultdict(list)\n    # Return empty if grid has no height\n    if grid.shape[0] == 0: \n        return separator_lines\n        \n    h, w = grid.shape\n    for c_idx in range(w):\n        col = grid[:, c_idx]\n        # Check if all elements in the column are the same\n        if np.all(col == col[0]): \n            col_color = int(col[0])\n            # Check if it's not the background color\n            if col_color != bg_color:\n                separator_lines[col_color].append(c_idx)\n    return separator_lines\n\ndef find_primary_separator_info(separator_lines: dict[int, list[int]]) -> tuple[int, list[int]]:\n    \"\"\"\n    Determines the primary separator color (most frequent, tie-break by first appearance)\n    and returns the color and its sorted list of column indices.\n    Returns (-1, []) if no separators are found.\n    \"\"\"\n    # Return defaults if no separators dictionary provided or it's empty\n    if not separator_lines:\n        return -1, []\n\n    primary_sep_col = -1\n    max_lines = -1\n    \n    # Iterate through colors sorted by their first appearance index for tie-breaking\n    sorted_colors = sorted(separator_lines.keys(), key=lambda color: separator_lines[color][0])\n\n    for color in sorted_colors:\n        indices = separator_lines[color]\n        count = len(indices)\n        \n        # If this color has more lines, it becomes the new primary.\n        # Tie-breaking is handled implicitly by the sort order.\n        if count > max_lines:\n             max_lines = count\n             primary_sep_col = color\n\n    if primary_sep_col != -1:\n        # Return the identified primary color and its sorted indices\n        return primary_sep_col, sorted(separator_lines[primary_sep_col])\n    else:\n         # This case should not be reached if separator_lines was not empty initially\n        return -1, [] \n\ndef extract_unique_patterns(section: np.ndarray, bg_color: int) -> dict[tuple, int]:\n    \"\"\"\n    Extracts unique row patterns containing non-background colors from a given grid section.\n    Returns a dictionary mapping tuple(pattern) -> min_row_index (relative to the section's rows).\n    \"\"\"\n    patterns = {}\n    # Return empty if section is empty or has zero width\n    if section.size == 0 or section.shape[1] == 0: \n        return patterns\n        \n    h = section.shape[0]\n    for r in range(h):\n        # Convert row slice to a tuple for use as dictionary key\n        row_pattern = tuple(section[r, :]) \n        # Check if pattern contains any non-background color\n        if any(pixel != bg_color for pixel in row_pattern):\n            # Store the first row index where this pattern is encountered\n            if row_pattern not in patterns:\n                patterns[row_pattern] = r\n    return patterns\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on vertical separator lines and pattern extraction/placement.\n    \"\"\"\n    # Convert list of lists to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid early\n    if input_array.size == 0:\n        return []\n\n    H, W_in = input_array.shape\n\n    # Step 1: Determine background color\n    bg_color = find_most_frequent_color(input_array)\n\n    # Step 2: Find all separator lines\n    separator_lines = find_separator_lines(input_array, bg_color)\n\n    # Step 3: Find primary separator info\n    primary_sep_color, primary_sep_indices = find_primary_separator_info(separator_lines)\n\n    # Step 4 & 5: Get count N and handle N=0 case (return input)\n    N = len(primary_sep_indices)\n    if N == 0:\n        return input_grid # Return input unchanged if no primary separators\n\n    # Step 6: Determine output dimensions (W_out) and handle edge case (W_out <= 0)\n    idx_1 = primary_sep_indices[0]\n    W_out = idx_1 # Width is determined by the first separator's position\n    \n    # Handle edge case: separator at column 0 means zero width output\n    if W_out <= 0:\n        return [[] for _ in range(H)] # Return list of empty lists for correct height\n\n    # Step 7: Initialize output grid with background color\n    output_array = np.full((H, W_out), bg_color, dtype=int)\n\n    # Step 8 & 9: Define and validate the source section\n    idx_N = primary_sep_indices[-1]\n    source_start_col = idx_N + 1\n    source_end_col = source_start_col + W_out # Theoretical end column (exclusive)\n\n    source_section_valid = False\n    source_section = np.array([[] for _ in range(H)], dtype=int) # Default empty section\n\n    # Check if source section starts within bounds\n    if source_start_col < W_in:\n        actual_end_col = min(source_end_col, W_in)\n        # Check if the slice is non-empty before creating it\n        if actual_end_col > source_start_col:\n             extracted_section = input_array[:, source_start_col:actual_end_col]\n             # Validate if the extracted section has the required width\n             if extracted_section.shape[1] == W_out:\n                 source_section = extracted_section\n                 source_section_valid = True\n\n    # Step 10 & 11: Extract unique patterns if source section is valid\n    unique_patterns = {}\n    if source_section_valid:\n        unique_patterns = extract_unique_patterns(source_section, bg_color)\n\n    # Step 12 & 13: Place patterns into the output grid based on N and r_min\n    for pattern_tuple, r_min in unique_patterns.items():\n        # Determine target row based on N\n        if N == 3:\n            target_row = r_min + 2\n        else: # N != 3 (includes N=1, N=2, N>3)\n            target_row = r_min\n            # Note: This rule is known to be incomplete for N=1, N=2 cases based on examples.\n            \n        # Check if target row is valid within output grid height\n        if 0 <= target_row < H:\n            # Ensure pattern length matches output width before assignment\n            # (Should always match if extracted from valid source section, but check defensively)\n            if len(pattern_tuple) == W_out:\n                output_array[target_row, :] = list(pattern_tuple)\n\n    # Step 14: Convert final NumPy array back to list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40706,
    "candidates_token_count": 2931,
    "total_token_count": 43637,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.381849,
  "retries": 1
}