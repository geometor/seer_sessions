{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation rule:\n1. Determine the background color (most frequent color in the input grid).\n2. Find all full-height, single-color vertical lines (separator lines) whose color is not the background color.\n3. Identify the primary separator color, which is the color that forms the most separator lines. Ties are broken by choosing the color whose first separator line appears earliest (leftmost). Record the column indices of all lines formed by this primary color.\n4. Count the number of primary separator lines (num_primary_lines).\n5. Determine the output grid dimensions: Height H is the same as the input grid height. Width W_out is the column index of the first primary separator line.\n6. Check the count of primary separator lines:\n    a. If num_primary_lines is exactly 3:\n        i. Create an output grid of size H x W_out, initially filled with the background color.\n        ii. Identify the 'last section' of the input grid. This section starts at the column immediately after the last primary separator line and has a width equal to W_out.\n        iii. Extract all unique row patterns (sequences of colors in a row) from this last section that contain at least one non-background color.\n        iv. For each unique pattern found, determine the minimum row index (r_min, 0-based) at which it first appears within the last section.\n        v. Calculate the target row index in the output grid for each pattern as target_row = r_min + 2.\n        vi. If the target_row is a valid row index within the output grid (0 <= target_row < H), place the corresponding pattern into that row of the output grid, overwriting the initial background color.\n    b. Else (if num_primary_lines is not 3):\n        i. The output grid is simply a direct copy of the 'first section' of the input grid, which consists of columns 0 up to (but not including) W_out.\n7. Return the final output grid.\n\"\"\"\n\ndef find_most_frequent_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color (pixel value) in the grid.\"\"\"\n    if grid.size == 0:\n        # Return a default (e.g., 0) or raise error for empty grid\n        return 0 \n    colors, counts = np.unique(grid, return_counts=True)\n    # Handle case where grid contains only one color or is empty after unique\n    if colors.size == 0:\n         return 0 # Or another appropriate default/error\n    return int(colors[np.argmax(counts)])\n\ndef find_separator_lines(grid: np.ndarray, bg_color: int) -> dict[int, list[int]]:\n    \"\"\"\n    Finds all full-height, single-color, non-background vertical lines.\n    Returns a dictionary mapping separator color to a list of column indices.\n    \"\"\"\n    h, w = grid.shape\n    separator_lines = defaultdict(list)\n    if h == 0: # Handle grids with zero height\n        return separator_lines\n        \n    for c_idx in range(w):\n        col = grid[:, c_idx]\n        # Check if column height matches grid height and all elements are the same\n        # np.all implicitly checks size > 0 if comparison is made\n        if np.all(col == col[0]): \n            col_color = int(col[0])\n            # Check if it's not the background color\n            if col_color != bg_color:\n                separator_lines[col_color].append(c_idx)\n    return separator_lines\n\ndef find_primary_separator_info(separator_lines: dict[int, list[int]]) -> tuple[int, list[int]]:\n    \"\"\"\n    Determines the primary separator color (most frequent, tie-break by first appearance)\n    and returns the color and its sorted list of column indices.\n    Returns (-1, []) if no separators are found.\n    \"\"\"\n    if not separator_lines:\n        return -1, [] # No separators found\n\n    primary_sep_col = -1\n    max_lines = -1\n    \n    # Iterate through colors sorted by their first appearance index\n    # This handles the tie-breaking rule correctly.\n    sorted_colors = sorted(separator_lines.keys(), key=lambda color: separator_lines[color][0])\n\n    for color in sorted_colors:\n        indices = separator_lines[color]\n        count = len(indices)\n        \n        # If this color has more lines, it becomes the new primary\n        if count > max_lines:\n             max_lines = count\n             primary_sep_col = color\n        # If counts are equal, the one encountered first (due to sorting) remains primary.\n\n    if primary_sep_col != -1:\n        # Return the primary color and its sorted indices\n        return primary_sep_col, sorted(separator_lines[primary_sep_col])\n    else:\n         # This case should ideally not be reached if separator_lines is not empty\n        return -1, []\n\n\ndef extract_unique_patterns(section: np.ndarray, bg_color: int) -> dict[tuple, int]:\n    \"\"\"\n    Extracts unique row patterns containing non-background colors from a given grid section.\n    Returns a dictionary mapping tuple(pattern) -> min_row_index (relative to the section's rows).\n    \"\"\"\n    patterns = {}\n    if section.size == 0: # Handle empty section\n        return patterns\n        \n    h = section.shape[0]\n    for r in range(h):\n        # Convert row slice to a tuple for use as dictionary key\n        row_pattern = tuple(section[r, :]) \n        # Check if pattern contains any non-background color\n        if any(pixel != bg_color for pixel in row_pattern):\n            # Store the first row index (relative to section) where this pattern is encountered\n            if row_pattern not in patterns:\n                patterns[row_pattern] = r\n    return patterns\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the analysis of vertical separator lines.\n    Either copies the first section or constructs the output from patterns\n    in the last section based on the number of primary separator lines.\n    \"\"\"\n    # Convert list of lists to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid\n    if input_array.size == 0:\n        return []\n\n    H, W_in = input_array.shape\n\n    # Step 1: Determine background color\n    bg_color = find_most_frequent_color(input_array)\n\n    # Step 2: Find all separator lines\n    separator_lines = find_separator_lines(input_array, bg_color)\n\n    # Step 3: Find primary separator info\n    primary_sep_color, primary_sep_indices = find_primary_separator_info(separator_lines)\n\n    # Handle case where no primary separator is found (might indicate input is output, or error)\n    # Assuming based on examples that a primary separator always exists.\n    if primary_sep_color == -1:\n         # If no separators define the structure, maybe return the input?\n         # Or an empty grid if the rule requires structure.\n         # Let's default to returning the input for now if no structure found.\n         return input_grid \n         \n    # Step 4: Count primary separator lines\n    num_primary_lines = len(primary_sep_indices)\n\n    # Step 5: Determine output dimensions\n    first_sep_idx = primary_sep_indices[0]\n    W_out = first_sep_idx # Width is determined by the first separator's position\n    \n    # Handle edge case: separator at column 0 means zero width output\n    if W_out <= 0:\n        return [[] for _ in range(H)] # Return list of empty lists for correct height\n\n    # Step 6 & 7: Apply transformation based on number of primary lines\n\n    # Mode 1: Pattern Transfer (if exactly 3 primary lines)\n    if num_primary_lines == 3:\n        # Initialize output grid with background color\n        output_array = np.full((H, W_out), bg_color, dtype=int)\n        \n        # Identify the last section\n        last_sep_idx = primary_sep_indices[-1]\n        section_start_col = last_sep_idx + 1\n        section_end_col = section_start_col + W_out # Theoretical end based on output width\n\n        # Extract the last section, respecting input grid boundaries\n        if section_start_col < W_in:\n            actual_end_col = min(section_end_col, W_in)\n            last_section = input_array[:, section_start_col:actual_end_col]\n\n            # Proceed only if the extracted section has the expected width\n            if last_section.shape[1] == W_out:\n                 # Find unique patterns and their min row index within the section\n                 unique_patterns = extract_unique_patterns(last_section, bg_color)\n\n                 # Place patterns into the output grid based on r_min + 2 rule\n                 for pattern_tuple, r_min in unique_patterns.items():\n                     target_row = r_min + 2\n                     # Check if target row is valid within output grid height\n                     if 0 <= target_row < H:\n                         output_array[target_row, :] = list(pattern_tuple)\n            # else: The last section was too narrow. Output remains bg_color filled.\n            # This implicitly handles cases where the input isn't wide enough\n            # after the last separator.\n        # else: No columns exist after the last separator. Output remains bg_color filled.\n\n    # Mode 2: Copy First Section (if num_primary_lines is NOT 3)\n    else:\n        # Extract the first section (columns 0 to W_out-1)\n        output_array = input_array[:, 0:W_out]\n\n    # Convert final NumPy array back to list of lists format for the ARC standard\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14143,
    "candidates_token_count": 7150,
    "total_token_count": 21293,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 56.526661,
  "retries": 1
}