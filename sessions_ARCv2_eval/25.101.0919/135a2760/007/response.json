{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nThe transformation rule identifies specific rows in the input grid that contain a \nrepeating horizontal pattern flanked by Red (2) pixels. For each such row, it \nanalyzes the segment between the Red markers to determine the single best *simple* \nrepeating pattern unit. The \"best\" unit is defined as the shortest sub-sequence \n(up to a maximum length of 6) that, when repeated, maximizes the number of matching \npixels with the original segment. This identified pattern unit is then used to \ncompletely reconstruct the segment in the output grid, effectively correcting any \ndeviations from the dominant simple pattern.\n\"\"\"\n\n# Define constants used in the transformation\nPATTERN_MARKER_COLOR = 2\nMAX_PATTERN_SEARCH_LENGTH = 6 # Reduced to 6 to prioritize simpler patterns\n\ndef _find_best_pattern(segment: list[int]) -> list[int] | None:\n    \"\"\"\n    Finds the best *simple* repeating pattern unit for a given segment.\n\n    The \"best\" pattern is the shortest one (up to MAX_PATTERN_SEARCH_LENGTH)\n    that achieves the maximum score, where the score is the number of matches\n    when the pattern is repeated over the entire segment.\n\n    Args:\n        segment: The list of pixel values in the row segment.\n\n    Returns:\n        The best pattern unit (list of ints) or None if the segment is empty.\n    \"\"\"\n    n = len(segment)\n    if n == 0:\n        return None # Return None for empty segments\n\n    best_pattern = None\n    max_score = -1\n    min_len_for_max_score = float('inf')\n\n    # Limit the maximum length of the pattern we search for\n    max_l = min(n, MAX_PATTERN_SEARCH_LENGTH)\n\n    # Iterate through possible pattern lengths (from 1 up to the limit max_l)\n    for length in range(1, max_l + 1):\n        # Iterate through all possible starting positions 'i' for a pattern of this length\n        for i in range(n - length + 1):\n            candidate_pattern = segment[i : i + length]\n\n            # Score the candidate pattern: count matches over the whole segment\n            current_score = 0\n            for j in range(n):\n                # Check if the pixel in the segment matches the expected pixel from the repeating candidate pattern\n                if segment[j] == candidate_pattern[j % length]:\n                    current_score += 1\n\n            # --- Update best pattern selection logic ---\n            # Priority 1: Higher score is always better\n            if current_score > max_score:\n                max_score = current_score\n                best_pattern = candidate_pattern\n                min_len_for_max_score = length\n            # Priority 2: If scores are equal, prefer the shorter pattern length\n            elif current_score == max_score:\n                if length < min_len_for_max_score:\n                    best_pattern = candidate_pattern\n                    min_len_for_max_score = length\n                    # Note: If scores and lengths are still equal, the pattern found\n                    # later in the segment scan (larger 'i') for that length\n                    # will overwrite earlier ones. This is an acceptable tie-breaker.\n\n    return best_pattern\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies rows with patterns flanked by Red(2) pixels and corrects\n    deviations within those patterns based on the best simple repeating unit found.\n    \"\"\"\n    # 1. Initialize Output: Create an exact, independent copy of the input grid.\n    # Using list comprehension for a deep enough copy for lists of lists of ints.\n    output_grid = [row[:] for row in input_grid]\n    height = len(input_grid)\n    if height == 0:\n        return [] # Handle empty grid case\n    width = len(input_grid[0])\n    # Need at least 4 columns for the pattern structure (e.g., Border, Marker, P, Marker, Border)\n    if width < 4:\n        return output_grid # Not enough columns for pattern rows, return copy\n\n    # 2. Iterate Through Rows: Process each row 'r' of the input grid.\n    for r in range(height):\n        # 3. Identify Pattern Rows: Check for Red(2) markers at col 1 and width-2.\n        is_pattern_row = (input_grid[r][1] == PATTERN_MARKER_COLOR and\n                          input_grid[r][width - 2] == PATTERN_MARKER_COLOR)\n\n        # 4. Process Pattern Rows:\n        if is_pattern_row:\n            # a. Extract Segment: Get the sequence between the markers.\n            input_segment = input_grid[r][2 : width - 2]\n\n            # Skip if segment is somehow empty\n            if not input_segment:\n                continue\n\n            # b. Determine Best Simple Repeating Pattern Unit: Analyze the segment.\n            pattern_unit = _find_best_pattern(input_segment)\n\n            # c. Apply Pattern to Output: If a valid pattern unit was found.\n            if pattern_unit:\n                pattern_len = len(pattern_unit)\n                # Iterate through the columns 'c' corresponding to the segment.\n                for c in range(2, width - 2):\n                    # Calculate the index within the repeating pattern unit.\n                    pattern_index = (c - 2) % pattern_len\n                    # Get the expected color from the determined pattern unit.\n                    expected_color = pattern_unit[pattern_index]\n                    # Update the pixel in the output grid with the expected color.\n                    output_grid[r][c] = expected_color\n\n    # 5. Return Result: Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 37212,
    "candidates_token_count": 1445,
    "total_token_count": 38657,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 11.252153,
  "retries": 1
}