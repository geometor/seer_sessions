{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import Counter\n\n\"\"\"\nThe transformation rule identifies specific rows in the input grid that contain a repeating horizontal pattern flanked by a specific color (Red=2). It then determines the intended repeating unit of the pattern within that row, considering a 'frame' color (usually the border color of the grid/section) and a 'pattern' color specific to that row. Finally, it corrects any deviations within the pattern segment of the row in the output grid to strictly follow the identified repeating pattern unit.\n\n1.  **Initialize Output:** Create an exact copy of the input grid.\n2.  **Iterate Rows:** Go through each row `r` of the grid.\n3.  **Identify Pattern Rows:** Check if the row `r` has Red (2) pixels at column 1 and column `width-2`. These define the boundaries of the pattern segment.\n4.  **Process Pattern Rows:** If it is a pattern row:\n    a.  **Extract Segment and Colors:** Get the sequence of pixels between the Red markers (columns 2 to `width-3`). Identify the Frame Color `F` (typically `grid[r][0]`) and the Pattern Color `P` (the other dominant color in the segment, excluding `F`).\n    b.  **Determine Dominant Pattern Unit:** Analyze the segment to find the most likely repeating unit (`PUnit`) composed of `F` and `P`. This is done by testing short potential pattern units (lengths 1 to 6) and selecting the one that matches the most pixels in the segment. If there's a tie in match count, the shortest pattern unit is preferred.\n    c.  **Correct the Segment:** Iterate through the segment columns (2 to `width-3`). For each column `c`, calculate the expected color based on the `PUnit` and the position within the pattern (`(c - 2) % len(PUnit)`). Update the corresponding pixel in the output grid with this expected color.\n5.  **Return Output:** Return the modified grid.\n\"\"\"\n\ndef _determine_pattern_unit(segment: list[int], frame_color: int) -> list[int] | None:\n    \"\"\"\n    Analyzes a segment to find the most likely repeating pattern unit.\n\n    Args:\n        segment: The list of pixel values in the row segment.\n        frame_color: The frame color F.\n\n    Returns:\n        The determined pattern unit (list of ints) or None if no pattern is found.\n    \"\"\"\n    if not segment:\n        return None\n\n    # Find unique colors in the segment, exclude frame_color and potential boundary color (2)\n    # Although boundary color 2 shouldn't be in the segment itself.\n    unique_colors = set(segment)\n    pattern_colors = [c for c in unique_colors if c != frame_color]\n\n    # Expecting frame_color and one pattern_color, maybe more if highly corrupted.\n    # Heuristic: use the first identified pattern color if multiple exist, or just the frame color if none else exist\n    # This part might need refinement if segments can contain >2 colors legitimately.\n    # For now, we assume the pattern is made of frame_color and *at most* one other color.\n\n    best_pattern = None\n    max_score = -1\n    min_len_for_max_score = float('inf')\n\n    # Limit pattern search length to avoid excessive computation and overfitting short segments\n    max_pattern_len = min(len(segment), 6)\n\n    for length in range(1, max_pattern_len + 1):\n        if length > len(segment):\n            continue\n\n        candidate_pattern = segment[:length]\n\n        # Check if the candidate pattern contains only expected colors (F and P)\n        # This check might be too strict if the start of the segment is corrupted.\n        # Let's relax this for now and rely purely on the score.\n        # allowed_colors = {frame_color}\n        # if pattern_colors:\n        #     allowed_colors.add(pattern_colors[0]) # Assuming one main pattern color P\n        # if not all(c in allowed_colors for c in candidate_pattern):\n        #     continue\n\n        # Score the candidate pattern by counting matches\n        score = 0\n        for i, pixel in enumerate(segment):\n            expected_pixel = candidate_pattern[i % length]\n            if pixel == expected_pixel:\n                score += 1\n\n        # Update best pattern if this one is better\n        if score > max_score:\n            max_score = score\n            best_pattern = candidate_pattern\n            min_len_for_max_score = length\n        elif score == max_score:\n            # If scores are equal, prefer the shorter pattern\n            if length < min_len_for_max_score:\n                best_pattern = candidate_pattern\n                min_len_for_max_score = length\n\n    return best_pattern\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies rows with specific patterns flanked by Red(2) pixels and corrects\n    deviations within those patterns based on the most frequent repeating unit.\n    \"\"\"\n    # Initialize output_grid as a deep copy of input_grid\n    output_grid = [row[:] for row in input_grid]\n    height = len(input_grid)\n    if height == 0:\n        return []\n    width = len(input_grid[0])\n    if width < 4: # Need at least 4 columns for pattern rows (F, 2, P..., 2, F)\n        return output_grid\n\n    # Iterate through each row\n    for r in range(height):\n        # Check if the row is a potential pattern row\n        # It needs Red(2) markers at columns 1 and width-2\n        if input_grid[r][1] == 2 and input_grid[r][width - 2] == 2:\n            # Extract the segment between the markers\n            segment = input_grid[r][2 : width - 2]\n            if not segment: # Skip if segment is empty\n                continue\n\n            # Determine the frame color (usually the color in column 0)\n            frame_color = input_grid[r][0] # Assuming frame color is consistent\n\n            # Determine the repeating pattern unit for this segment\n            pattern_unit = _determine_pattern_unit(segment, frame_color)\n\n            # If a pattern unit was successfully determined\n            if pattern_unit:\n                pattern_len = len(pattern_unit)\n                # Correct the segment in the output grid\n                for c in range(2, width - 2):\n                    # Calculate the index within the pattern unit\n                    pattern_index = (c - 2) % pattern_len\n                    # Get the expected color from the pattern unit\n                    expected_color = pattern_unit[pattern_index]\n                    # Update the output grid\n                    output_grid[r][c] = expected_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4764,
    "candidates_token_count": 2617,
    "total_token_count": 7381,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.117608,
  "retries": 1
}