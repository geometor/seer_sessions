
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 3 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 1 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 1 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 4 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 4 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 9 2 4
4 2 9 4 9 4 9 4 9 9 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

## Perception

The task involves modifying pixels within specific rows of the input grid to correct inconsistencies in repeating horizontal patterns. The input and output grids have identical dimensions.

Key visual elements:
1.  **Borders:** The grids often feature outer borders of a specific color (Green=3 in example 1, Yellow=4 in example 2) and inner borders of Red=2.
2.  **Pattern Rows:** Certain rows are designated as "pattern rows". These rows are typically enclosed horizontally by Red=2 pixels (at column 1 and column `width-2`).
3.  **Row Segments:** Within a pattern row, the segment between the Red=2 borders (columns 2 to `width-3`) contains a sequence of pixels.
4.  **Colors:** These segments primarily use two colors:
    *   **Frame Color (F):** The color of the grid's outer border (e.g., Green=3 or Yellow=4).
    *   **Pattern Color (P):** Another color specific to that row's pattern (e.g., Blue=1, Green=3, Azure=8, Maroon=9).
5.  **Repeating Patterns:** The sequence of pixels within the row segment ideally follows a repeating pattern composed of the Frame Color and the Pattern Color (e.g., `1 3 1 3...`, `3 3 4 3 3 4...`, `9 4 9 4...`).
6.  **Anomalies/Deviations:** In the input grid, some row segments contain sequences that deviate from the established repeating pattern (e.g., a `3 3` sequence where `1 3` is expected).
7.  **Correction:** The output grid shows these deviations corrected to conform to the dominant repeating pattern for that row segment. The correction involves changing the color of the deviating pixel(s) to the expected color according to the pattern.

## Facts


```yaml
elements:
  - object: grid
    properties:
      - height: H (variable)
      - width: W (variable)
      - pixels: 2D array of colors (0-9)
  - object: border
    properties:
      - type: outer (frame)
      - color: FrameColor (F) - varies per task/section (e.g., 3, 4)
      - location: typically row 0, row H-1, col 0, col W-1
      - type: inner (segment delimiter)
      - color: Red (2)
      - location: column 1 and column W-2 within specific rows
  - object: row_segment
    properties:
      - row_index: r
      - start_column: 2
      - end_column: W-3
      - content: sequence of pixels
      - associated_frame_color: F (from grid[r][0])
      - associated_pattern_color: P (non-F, non-Red color in the segment)
      - dominant_pattern: PUnit (repeating sequence of F and P)
  - object: pattern_unit
    properties:
      - colors: ordered list of F and P (e.g., [1, 3], [3, 3, 4], [9, 4])
      - length: L

relationships:
  - Grid contains Borders and Row Segments.
  - Inner Borders (Red=2) define the horizontal boundaries of Row Segments.
  - The Outer Border color defines the Frame Color (F) for Row Segments in that grid/section.
  - Each Row Segment has one Pattern Color (P) and follows one Dominant Pattern (PUnit).
  - Pixels within a Row Segment should ideally follow the sequence defined by the PUnit.

actions:
  - identify_pattern_rows: Find rows 'r' where grid[r][1] == Red(2) and grid[r][W-2] == Red(2).
  - identify_colors: For a pattern row 'r', find FrameColor F = grid[r][0] and PatternColor P.
  - determine_pattern_unit: Analyze the pixel sequence in the row segment (cols 2 to W-3) to find the repeating PUnit. This might involve finding the shortest repeating prefix or the most frequent repeating block.
  - scan_and_correct:
      - Iterate through columns 'c' from 2 to W-3 for the pattern row 'r'.
      - Calculate the expected color 'E' based on PUnit and the column index 'c'.
      - Compare input pixel grid[r][c] with 'E'.
      - If grid[r][c] != E, update the output pixel output[r][c] = E.
```


## Natural Language Program

1.  **Initialize Output:** Create an exact copy of the input grid. This copy will be modified and become the output.
2.  **Iterate Rows:** Go through each row `r` of the grid, from top to bottom.
3.  **Identify Pattern Rows:** For the current row `r`, check if it's a "pattern row" by verifying that the pixel at `grid[r][1]` (second column) and the pixel at `grid[r][width-2]` (second-to-last column) are both Red (2).
4.  **Process Pattern Rows:** If row `r` is identified as a pattern row:
    a.  **Extract Segment Info:**
        i.  Determine the Frame Color `F` (usually `grid[r][0]`).
        ii. Determine the Pattern Color `P` (the single color within columns 2 to `width-3` that is not `F` or Red `2`).
        iii. Extract the pixel sequence within the segment (from column 2 to `width-3`).
    b.  **Determine Pattern Unit:** Analyze the extracted sequence to find the repeating unit (`PUnit`) composed of `F` and `P`. This is typically the shortest sequence that repeats to form the majority of the segment (e.g., `[1, 3]`, `[3, 3, 4]`, `[9, 4]`, `[8, 8, 8, 4]`).
    c.  **Correct Segment:** Iterate through each column `c` within the segment (from 2 to `width-3`):
        i.  Calculate the index within the pattern unit: `pattern_index = (c - 2) % length(PUnit)`.
        ii. Determine the *expected* color `E = PUnit[pattern_index]`.
        iii. Get the *actual* color `A = grid[r][c]` from the original input.
        iv. If the actual color `A` is different from the expected color `E`, update the pixel in the *output* grid at `output[r][c]` to the expected color `E`.
5.  **Return Output:** After checking and potentially modifying all rows, return the final output grid.
