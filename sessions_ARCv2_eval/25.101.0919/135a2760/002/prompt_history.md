
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 3 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 2 1 3 1 3 1 3 1 3 1 2 3
3 2 2 2 2 2 2 2 2 2 2 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 4 3 3 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 1 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 4 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 4 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 9 2 4
4 2 9 4 9 4 9 4 9 9 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 3 3 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 2 4
4 2 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 4 1 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 2 4
4 2 8 8 8 4 8 8 8 4 8 8 8 4 8 8 8 4 8 8 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 9 4 2 4
4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

## Perception

The task involves modifying pixels within specific rows of the input grid to correct inconsistencies in repeating horizontal patterns. The input and output grids have identical dimensions.

Key visual elements:
1.  **Borders:** The grids often feature outer borders of a specific color (Green=3 in example 1, Yellow=4 in example 2) and inner borders of Red=2.
2.  **Pattern Rows:** Certain rows are designated as "pattern rows". These rows are typically enclosed horizontally by Red=2 pixels (at column 1 and column `width-2`).
3.  **Row Segments:** Within a pattern row, the segment between the Red=2 borders (columns 2 to `width-3`) contains a sequence of pixels.
4.  **Colors:** These segments primarily use two colors:
    *   **Frame Color (F):** The color of the grid's outer border (e.g., Green=3 or Yellow=4).
    *   **Pattern Color (P):** Another color specific to that row's pattern (e.g., Blue=1, Green=3, Azure=8, Maroon=9).
5.  **Repeating Patterns:** The sequence of pixels within the row segment ideally follows a repeating pattern composed of the Frame Color and the Pattern Color (e.g., `1 3 1 3...`, `3 3 4 3 3 4...`, `9 4 9 4...`).
6.  **Anomalies/Deviations:** In the input grid, some row segments contain sequences that deviate from the established repeating pattern (e.g., a `3 3` sequence where `1 3` is expected).
7.  **Correction:** The output grid shows these deviations corrected to conform to the dominant repeating pattern for that row segment. The correction involves changing the color of the deviating pixel(s) to the expected color according to the pattern.

## Facts


```yaml
elements:
  - object: grid
    properties:
      - height: H (variable)
      - width: W (variable)
      - pixels: 2D array of colors (0-9)
  - object: border
    properties:
      - type: outer (frame)
      - color: FrameColor (F) - varies per task/section (e.g., 3, 4)
      - location: typically row 0, row H-1, col 0, col W-1
      - type: inner (segment delimiter)
      - color: Red (2)
      - location: column 1 and column W-2 within specific rows
  - object: row_segment
    properties:
      - row_index: r
      - start_column: 2
      - end_column: W-3
      - content: sequence of pixels
      - associated_frame_color: F (from grid[r][0])
      - associated_pattern_color: P (non-F, non-Red color in the segment)
      - dominant_pattern: PUnit (repeating sequence of F and P)
  - object: pattern_unit
    properties:
      - colors: ordered list of F and P (e.g., [1, 3], [3, 3, 4], [9, 4])
      - length: L

relationships:
  - Grid contains Borders and Row Segments.
  - Inner Borders (Red=2) define the horizontal boundaries of Row Segments.
  - The Outer Border color defines the Frame Color (F) for Row Segments in that grid/section.
  - Each Row Segment has one Pattern Color (P) and follows one Dominant Pattern (PUnit).
  - Pixels within a Row Segment should ideally follow the sequence defined by the PUnit.

actions:
  - identify_pattern_rows: Find rows 'r' where grid[r][1] == Red(2) and grid[r][W-2] == Red(2).
  - identify_colors: For a pattern row 'r', find FrameColor F = grid[r][0] and PatternColor P.
  - determine_pattern_unit: Analyze the pixel sequence in the row segment (cols 2 to W-3) to find the repeating PUnit. This might involve finding the shortest repeating prefix or the most frequent repeating block.
  - scan_and_correct:
      - Iterate through columns 'c' from 2 to W-3 for the pattern row 'r'.
      - Calculate the expected color 'E' based on PUnit and the column index 'c'.
      - Compare input pixel grid[r][c] with 'E'.
      - If grid[r][c] != E, update the output pixel output[r][c] = E.
```


## Natural Language Program

1.  **Initialize Output:** Create an exact copy of the input grid. This copy will be modified and become the output.
2.  **Iterate Rows:** Go through each row `r` of the grid, from top to bottom.
3.  **Identify Pattern Rows:** For the current row `r`, check if it's a "pattern row" by verifying that the pixel at `grid[r][1]` (second column) and the pixel at `grid[r][width-2]` (second-to-last column) are both Red (2).
4.  **Process Pattern Rows:** If row `r` is identified as a pattern row:
    a.  **Extract Segment Info:**
        i.  Determine the Frame Color `F` (usually `grid[r][0]`).
        ii. Determine the Pattern Color `P` (the single color within columns 2 to `width-3` that is not `F` or Red `2`).
        iii. Extract the pixel sequence within the segment (from column 2 to `width-3`).
    b.  **Determine Pattern Unit:** Analyze the extracted sequence to find the repeating unit (`PUnit`) composed of `F` and `P`. This is typically the shortest sequence that repeats to form the majority of the segment (e.g., `[1, 3]`, `[3, 3, 4]`, `[9, 4]`, `[8, 8, 8, 4]`).
    c.  **Correct Segment:** Iterate through each column `c` within the segment (from 2 to `width-3`):
        i.  Calculate the index within the pattern unit: `pattern_index = (c - 2) % length(PUnit)`.
        ii. Determine the *expected* color `E = PUnit[pattern_index]`.
        iii. Get the *actual* color `A = grid[r][c]` from the original input.
        iv. If the actual color `A` is different from the expected color `E`, update the pixel in the *output* grid at `output[r][c]` to the expected color `E`.
5.  **Return Output:** After checking and potentially modifying all rows, return the final output grid.
```python
import copy
from collections import Counter

"""
The transformation rule identifies specific rows in the input grid that contain a repeating horizontal pattern flanked by a specific color (Red=2). It then determines the intended repeating unit of the pattern within that row, considering a 'frame' color (usually the border color of the grid/section) and a 'pattern' color specific to that row. Finally, it corrects any deviations within the pattern segment of the row in the output grid to strictly follow the identified repeating pattern unit.

1.  **Initialize Output:** Create an exact copy of the input grid.
2.  **Iterate Rows:** Go through each row `r` of the grid.
3.  **Identify Pattern Rows:** Check if the row `r` has Red (2) pixels at column 1 and column `width-2`. These define the boundaries of the pattern segment.
4.  **Process Pattern Rows:** If it is a pattern row:
    a.  **Extract Segment and Colors:** Get the sequence of pixels between the Red markers (columns 2 to `width-3`). Identify the Frame Color `F` (typically `grid[r][0]`) and the Pattern Color `P` (the other dominant color in the segment, excluding `F`).
    b.  **Determine Dominant Pattern Unit:** Analyze the segment to find the most likely repeating unit (`PUnit`) composed of `F` and `P`. This is done by testing short potential pattern units (lengths 1 to 6) and selecting the one that matches the most pixels in the segment. If there's a tie in match count, the shortest pattern unit is preferred.
    c.  **Correct the Segment:** Iterate through the segment columns (2 to `width-3`). For each column `c`, calculate the expected color based on the `PUnit` and the position within the pattern (`(c - 2) % len(PUnit)`). Update the corresponding pixel in the output grid with this expected color.
5.  **Return Output:** Return the modified grid.
"""

def _determine_pattern_unit(segment: list[int], frame_color: int) -> list[int] | None:
    """
    Analyzes a segment to find the most likely repeating pattern unit.

    Args:
        segment: The list of pixel values in the row segment.
        frame_color: The frame color F.

    Returns:
        The determined pattern unit (list of ints) or None if no pattern is found.
    """
    if not segment:
        return None

    # Find unique colors in the segment, exclude frame_color and potential boundary color (2)
    # Although boundary color 2 shouldn't be in the segment itself.
    unique_colors = set(segment)
    pattern_colors = [c for c in unique_colors if c != frame_color]

    # Expecting frame_color and one pattern_color, maybe more if highly corrupted.
    # Heuristic: use the first identified pattern color if multiple exist, or just the frame color if none else exist
    # This part might need refinement if segments can contain >2 colors legitimately.
    # For now, we assume the pattern is made of frame_color and *at most* one other color.

    best_pattern = None
    max_score = -1
    min_len_for_max_score = float('inf')

    # Limit pattern search length to avoid excessive computation and overfitting short segments
    max_pattern_len = min(len(segment), 6)

    for length in range(1, max_pattern_len + 1):
        if length > len(segment):
            continue

        candidate_pattern = segment[:length]

        # Check if the candidate pattern contains only expected colors (F and P)
        # This check might be too strict if the start of the segment is corrupted.
        # Let's relax this for now and rely purely on the score.
        # allowed_colors = {frame_color}
        # if pattern_colors:
        #     allowed_colors.add(pattern_colors[0]) # Assuming one main pattern color P
        # if not all(c in allowed_colors for c in candidate_pattern):
        #     continue

        # Score the candidate pattern by counting matches
        score = 0
        for i, pixel in enumerate(segment):
            expected_pixel = candidate_pattern[i % length]
            if pixel == expected_pixel:
                score += 1

        # Update best pattern if this one is better
        if score > max_score:
            max_score = score
            best_pattern = candidate_pattern
            min_len_for_max_score = length
        elif score == max_score:
            # If scores are equal, prefer the shorter pattern
            if length < min_len_for_max_score:
                best_pattern = candidate_pattern
                min_len_for_max_score = length

    return best_pattern


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies rows with specific patterns flanked by Red(2) pixels and corrects
    deviations within those patterns based on the most frequent repeating unit.
    """
    # Initialize output_grid as a deep copy of input_grid
    output_grid = [row[:] for row in input_grid]
    height = len(input_grid)
    if height == 0:
        return []
    width = len(input_grid[0])
    if width < 4: # Need at least 4 columns for pattern rows (F, 2, P..., 2, F)
        return output_grid

    # Iterate through each row
    for r in range(height):
        # Check if the row is a potential pattern row
        # It needs Red(2) markers at columns 1 and width-2
        if input_grid[r][1] == 2 and input_grid[r][width - 2] == 2:
            # Extract the segment between the markers
            segment = input_grid[r][2 : width - 2]
            if not segment: # Skip if segment is empty
                continue

            # Determine the frame color (usually the color in column 0)
            frame_color = input_grid[r][0] # Assuming frame color is consistent

            # Determine the repeating pattern unit for this segment
            pattern_unit = _determine_pattern_unit(segment, frame_color)

            # If a pattern unit was successfully determined
            if pattern_unit:
                pattern_len = len(pattern_unit)
                # Correct the segment in the output grid
                for c in range(2, width - 2):
                    # Calculate the index within the pattern unit
                    pattern_index = (c - 2) % pattern_len
                    # Get the expected color from the pattern unit
                    expected_color = pattern_unit[pattern_index]
                    # Update the output grid
                    output_grid[r][c] = expected_color

    return output_grid
```
