{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify horizontal bands in the input grid. The top-most band containing multiple colors is the 'source' band. Bands below the source, characterized by a distinct frame color (1-pixel border) and a background color (inner area), are 'target' bands.\n2.  Identify contiguous objects (non-background color) in the source band. Filter out objects completely enclosed within another object.\n3.  Initialize the output grid as a copy of the input grid.\n4.  Clear the source band area in the output grid, filling it with the source band's background color.\n5.  For each target band:\n    a. If the target band's background color is yellow (4): Find all yellow pixels in the original source band and draw them (using the target band's frame color) onto the corresponding locations in the output grid.\n    b. If the target band's background color is NOT yellow:\n        i. Find the primary source object(s) whose color matches the target band's background color.\n        ii. If multiple matching objects exist, select the largest one (by pixel count).\n        iii. If a matching object is found, draw its shape (using the target band's frame color) onto the corresponding locations in the output grid.\n\"\"\"\n\n# Helper function to find connected components (objects) using BFS\ndef find_objects(grid_region, background_color):\n    \"\"\"Finds connected objects of non-background color in a grid region.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid_region.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid_region[r, c] != background_color and (r, c) not in visited:\n                obj_color = grid_region[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-way connectivity ok? Let's try 8-way\n                    # for dr in range(-1, 2):\n                    #    for dc in range(-1, 2):\n                    #        if dr == 0 and dc == 0:\n                    #            continue\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and \\\n                           grid_region[nr, nc] == obj_color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Check 8-way connectivity for merging later if needed, but build with 4-way first.\n                # Re-checking example 1: source object looks 4-way connected.\n                # Example 2: source objects look 4-way connected.\n                # Example 3: source objects look 4-way connected.\n                # Sticking with 4-way connectivity for object definition.\n\n                objects.append({\n                    'color': obj_color,\n                    'coords': obj_coords,\n                    'size': len(obj_coords),\n                    'min_r': min(r for r, c in obj_coords),\n                    'max_r': max(r for r, c in obj_coords),\n                    'min_c': min(c for r, c in obj_coords),\n                    'max_c': max(c for r, c in obj_coords),\n                })\n    return objects\n\n# Helper function to check if an object is enclosed within another\ndef is_enclosed(obj_a, obj_b, grid_region):\n    \"\"\"Check if obj_a is fully enclosed by obj_b using adjacency.\"\"\"\n    # Quick check: B must be larger and contain A's bounding box (approx)\n    if obj_a['size'] >= obj_b['size']:\n        return False\n    if not (obj_b['min_r'] <= obj_a['min_r'] and\n            obj_b['max_r'] >= obj_a['max_r'] and\n            obj_b['min_c'] <= obj_a['min_c'] and\n            obj_b['max_c'] >= obj_a['max_c']):\n        return False\n\n    rows, cols = grid_region.shape\n    # Check every neighbor of every pixel in obj_a\n    for r, c in obj_a['coords']:\n        for dr in range(-1, 2):\n            for dc in range(-1, 2):\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                neighbor_coord = (nr, nc)\n\n                # If neighbor is outside grid, A is not enclosed\n                if not (0 <= nr < rows and 0 <= nc < cols):\n                    return False\n\n                # If neighbor is not part of A and not part of B, A is not enclosed by B\n                if neighbor_coord not in obj_a['coords'] and neighbor_coord not in obj_b['coords']:\n                    return False\n    return True\n\n\n# Helper function to identify bands\ndef identify_bands(grid):\n    \"\"\"Identifies source and target bands based on structure.\"\"\"\n    rows, cols = grid.shape\n    bands = []\n    current_band_start = 0\n    in_band = False\n\n    # Find potential band boundaries (often rows of uniform color, but not always reliable)\n    # Let's simplify: Identify bands by changes in row patterns or uniform rows.\n    # Find the first row with multiple colors - this starts the source band region search\n    source_band_info = None\n    target_bands_info = []\n    \n    first_multi_color_row = -1\n    for r in range(rows):\n        if len(np.unique(grid[r, :])) > 1:\n            first_multi_color_row = r\n            break\n    \n    if first_multi_color_row == -1: # No multi-color rows found\n        return None, []\n\n    # --- Source Band Identification ---\n    # Assume source band starts at first_multi_color_row and extends downwards\n    # until a significant change (e.g., a fully uniform row, or a framed structure starts)\n    # Need a heuristic for source background color. Maybe the most common color?\n    source_start_row = first_multi_color_row\n    source_end_row = source_start_row\n    potential_source_bg = grid[source_start_row, 0] # Guess based on corner? Risky.\n    \n    # Iterate downwards to find the end of the source band.\n    # Look for a uniform row or the start of a framed band.\n    \n    # Let's try finding the background color by checking corners or edges first.\n    # In example 1, source bg is 1. In example 2, source bg is 8. In example 3, source bg is 4.\n    # It seems to be the dominant color in the source band region that is NOT part of the internal objects.\n    # Let's find the extent of the multi-color region first.\n    \n    current_row = first_multi_color_row\n    while current_row < rows and len(np.unique(grid[current_row, :])) > 1:\n         current_row += 1\n    source_end_row = current_row -1 # Last row that had multiple colors (part of source)\n    \n    # Determine source background color within source_start_row to source_end_row\n    source_region_pixels = grid[source_start_row:source_end_row+1, :].flatten()\n    colors, counts = np.unique(source_region_pixels, return_counts=True)\n    source_bg_guess = colors[np.argmax(counts)] # Most frequent color in the region\n    \n    # Refine background color: Find objects first, then bg is most common color NOT in objects?\n    temp_source_region = grid[source_start_row:source_end_row+1, :]\n    temp_objects = find_objects(temp_source_region, -1) # Find all objects initially assuming no bg\n    object_colors = set(obj['color'] for obj in temp_objects)\n    \n    # Find most frequent color in the region that isn't an object color\n    bg_candidate_counts = {}\n    for r in range(source_start_row, source_end_row + 1):\n        for c in range(cols):\n             pixel_color = grid[r,c]\n             if pixel_color not in object_colors:\n                 bg_candidate_counts[pixel_color] = bg_candidate_counts.get(pixel_color, 0) + 1\n\n    if not bg_candidate_counts: # Should not happen if region has >1 color\n         source_bg = source_bg_guess # Fallback\n    else:\n         source_bg = max(bg_candidate_counts, key=bg_candidate_counts.get)\n\n    source_band_info = {\n        'start_row': source_start_row,\n        'end_row': source_end_row,\n        'background_color': source_bg\n    }\n    \n    # --- Target Band Identification ---\n    current_row = source_end_row + 1\n    while current_row < rows:\n        # Skip uniform rows (separators)\n        while current_row < rows and len(np.unique(grid[current_row, :])) == 1:\n            current_row += 1\n        \n        if current_row >= rows:\n            break\n            \n        target_start_row = current_row\n        \n        # Check for frame structure: is grid[r, 0] != grid[r, 1]?\n        frame_color_candidate = grid[target_start_row, 0]\n        background_color_candidate = grid[target_start_row, 1] # Inner color\n        \n        # Verify frame/background consistency for a few rows\n        is_framed_band = True\n        band_end_row = target_start_row\n        while band_end_row < rows:\n            # Check if row pattern is consistent (frame/bg or all frame if width=1/2)\n            row_colors = np.unique(grid[band_end_row, :])\n            \n            # End condition 1: Hit a uniform row that is not the frame color (separator)\n            if len(row_colors) == 1 and row_colors[0] != frame_color_candidate:\n                 band_end_row -= 1 # Previous row was the end\n                 break\n            \n            # End condition 2: Hit a row with a different pattern (start of new band type)\n            if grid[band_end_row, 0] != frame_color_candidate or \\\n               (cols > 1 and grid[band_end_row, 1] != background_color_candidate and grid[band_end_row, 1] != frame_color_candidate) or \\\n               (cols > 1 and grid[band_end_row, -1] != frame_color_candidate) or \\\n               (cols > 2 and grid[band_end_row, -2] != background_color_candidate and grid[band_end_row, -2] != frame_color_candidate):\n                 # Check if it's just the end of the grid\n                 if band_end_row + 1 == rows:\n                    # If the last row matches the pattern, include it\n                    pass\n                 else:\n                    # If pattern breaks mid-grid, end the band here\n                    band_end_row -= 1 # Previous row was the end\n                    break\n\n            # Check corners and inner sample\n            if grid[band_end_row, 0] != frame_color_candidate: is_framed_band=False; break\n            if cols > 1 and grid[band_end_row, -1] != frame_color_candidate: is_framed_band=False; break\n            if cols > 2 and grid[band_end_row, 1] != background_color_candidate:\n                # Allow for case where inner area is filled with frame color temporarily by drawing\n                # Check if the center-ish color matches background\n                center_col = cols // 2\n                if grid[band_end_row, center_col] != background_color_candidate and grid[band_end_row, center_col] != frame_color_candidate:\n                    # If center doesn't match bg OR frame, it's likely a different band type\n                     band_end_row -= 1\n                     break\n\n            band_end_row += 1\n            \n        # Ensure band_end_row didn't go past grid boundary\n        band_end_row = min(band_end_row, rows - 1)\n\n        # Validate that we actually found a framed band\n        if is_framed_band and band_end_row >= target_start_row:\n             # Check inner area to confirm background color if possible\n             inner_region = grid[target_start_row:band_end_row+1, 1:cols-1]\n             if inner_region.size > 0:\n                 inner_colors, inner_counts = np.unique(inner_region, return_counts=True)\n                 # Background should be the most common color unless it's empty\n                 # Or maybe the color present at [start_row, 1]\n                 confirmed_background = grid[target_start_row, 1] # Use the initial candidate\n                 \n                 target_bands_info.append({\n                     'start_row': target_start_row,\n                     'end_row': band_end_row,\n                     'frame_color': frame_color_candidate,\n                     'background_color': confirmed_background\n                 })\n             elif cols <= 2: # Handle thin bands\n                 target_bands_info.append({\n                     'start_row': target_start_row,\n                     'end_row': band_end_row,\n                     'frame_color': frame_color_candidate,\n                     'background_color': background_color_candidate # May be same as frame\n                 })\n\n\n        current_row = band_end_row + 1\n\n    return source_band_info, target_bands_info\n\n\ndef transform(input_grid_in):\n    \"\"\"\n    Transforms the input grid by identifying source/target bands, finding objects\n    in the source, and drawing selected object shapes/pixels into target bands\n    based on color matching rules.\n    \"\"\"\n    input_grid = np.array(input_grid_in, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Bands\n    source_band, target_bands = identify_bands(input_grid)\n\n    if source_band is None:\n        # No source band found, return copy of input\n        return output_grid.tolist()\n\n    # 2. Analyze Source Band\n    source_region = input_grid[source_band['start_row']:source_band['end_row'] + 1, :]\n    all_source_objects = find_objects(source_region, source_band['background_color'])\n\n    # 3. Filter out enclosed objects\n    primary_source_objects = []\n    potential_enclosed = list(range(len(all_source_objects)))\n    \n    for i in range(len(all_source_objects)):\n        is_i_enclosed = False\n        for j in range(len(all_source_objects)):\n            if i == j:\n                continue\n            # Check if object i is enclosed by object j\n            # Need relative coordinates within the source_region for is_enclosed\n            if is_enclosed(all_source_objects[i], all_source_objects[j], source_region):\n                 is_i_enclosed = True\n                 break\n        if not is_i_enclosed:\n            primary_source_objects.append(all_source_objects[i])\n\n    # 4. Clear Source in Output\n    output_grid[source_band['start_row']:source_band['end_row'] + 1, :] = source_band['background_color']\n\n    # 5. Process Target Bands\n    for target in target_bands:\n        target_bg = target['background_color']\n        target_frame = target['frame_color']\n\n        # 5a. Special Yellow Rule\n        if target_bg == 4: # Yellow\n            yellow_coords_in_source = []\n            for r_rel, c_rel in np.argwhere(source_region == 4):\n                r_abs = r_rel + source_band['start_row']\n                c_abs = c_rel # Assuming source starts at col 0\n                yellow_coords_in_source.append((r_abs, c_abs))\n            \n            # Draw these coordinates onto the output grid\n            for r, c in yellow_coords_in_source:\n                 # Check bounds just in case (should match source band location)\n                 if target['start_row'] <= r <= target['end_row'] and 0 <= c < cols:\n                     output_grid[r, c] = target_frame\n\n        # 5b. Standard Processing\n        else:\n            matching_objects = [obj for obj in primary_source_objects if obj['color'] == target_bg]\n\n            if not matching_objects:\n                continue # No matching object found\n\n            # Select the largest object if multiple match\n            selected_object = None\n            if len(matching_objects) == 1:\n                selected_object = matching_objects[0]\n            elif len(matching_objects) > 1:\n                selected_object = max(matching_objects, key=lambda obj: obj['size'])\n\n            # Draw the shape of the selected object\n            if selected_object:\n                for r_rel, c_rel in selected_object['coords']:\n                    # Convert relative source coordinates to absolute grid coordinates\n                    r_abs = r_rel + source_band['start_row']\n                    c_abs = c_rel # Assuming source starts at col 0\n                    \n                    # Check bounds before drawing (should align with target band vertical range, but use absolute coords)\n                    if target['start_row'] <= r_abs <= target['end_row'] and 0 <= c_abs < cols:\n                        output_grid[r_abs, c_abs] = target_frame\n                    # Need to ensure drawing happens *within* the target band space\n                    # The rule implies using the source coordinates directly. Let's stick to that.\n                    if 0 <= r_abs < rows and 0 <= c_abs < cols:\n                         output_grid[r_abs, c_abs] = target_frame\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11350,
    "candidates_token_count": 4421,
    "total_token_count": 15771,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 126.636977,
  "retries": 2
}