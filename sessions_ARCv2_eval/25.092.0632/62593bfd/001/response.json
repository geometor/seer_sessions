{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the background color and all distinct non-background colored objects (connected components).\nDetermines a rearrangement rule based on the background color.\nIf the background is white (0):\n  - Each object is moved to a specific corner based on its color:\n    - Green (3) -> Top-Left\n    - Blue (1) -> Top-Right\n    - Yellow (4) -> Bottom-Left\n    - Red (2) -> Bottom-Right\nIf the background is gray (5):\n  - Each object is moved to one of the four corners based on its original horizontal position (left/right half) and its color.\n  - Objects in the left half:\n    - Blue (1) -> Bottom-Left\n    - Others -> Top-Left\n  - Objects in the right half:\n    - Yellow (4) -> Bottom-Right\n    - Others -> Top-Right\nThe object is placed in the target corner such that its bounding box aligns with that corner.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all connected components (objects) of non-background colors.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with its\n              properties: color, pixels_relative, height, width, min_r, min_c.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                pixels = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search to find all connected pixels of the same color\n                component_pixels = []\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_pixels.append((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and (nr, nc) not in visited:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # Calculate object properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                # Store pixel coordinates relative to the object's top-left corner (min_r, min_c)\n                pixels_relative = [(pr - min_r, pc - min_c) for pr, pc in component_pixels]\n                \n                objects.append({\n                    'color': color,\n                    'pixels_relative': pixels_relative,\n                    'height': height,\n                    'width': width,\n                    'min_r': min_r,\n                    'min_c': min_c,\n                    'max_r': max_r,\n                    'max_c': max_c,\n                })\n    return objects\n\ndef place_object(output_grid, obj, target_corner_name):\n    \"\"\"\n    Places an object onto the output grid at the specified corner.\n\n    Args:\n        output_grid (np.array): The grid to place the object onto.\n        obj (dict): The object dictionary containing color, relative pixels, height, width.\n        target_corner_name (str): 'TL', 'TR', 'BL', or 'BR'.\n    \"\"\"\n    grid_h, grid_w = output_grid.shape\n    obj_h, obj_w = obj['height'], obj['width']\n    obj_color = obj['color']\n    \n    # Determine the top-left coordinate (target_r, target_c) for placing the object\n    if target_corner_name == 'TL':\n        target_r, target_c = 0, 0\n    elif target_corner_name == 'TR':\n        target_r, target_c = 0, grid_w - obj_w\n    elif target_corner_name == 'BL':\n        target_r, target_c = grid_h - obj_h, 0\n    elif target_corner_name == 'BR':\n        target_r, target_c = grid_h - obj_h, grid_w - obj_w\n    else:\n        raise ValueError(\"Invalid target_corner_name\")\n\n    # Place the object's pixels onto the output grid\n    for dr, dc in obj['pixels_relative']:\n        place_r, place_c = target_r + dr, target_c + dc\n        # Ensure placement is within bounds (should be if calculations are correct)\n        if 0 <= place_r < grid_h and 0 <= place_c < grid_w:\n            output_grid[place_r, place_c] = obj_color\n        else:\n             # This might happen if object dimensions are calculated slightly off \n             # or if grid size is very small. Log or handle as needed.\n             print(f\"Warning: Pixel ({place_r}, {place_c}) out of bounds for object placement.\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by rearranging objects based on background color.\n    \"\"\"\n    input_np = np.array(input_grid)\n    rows, cols = input_np.shape\n\n    # Determine background color (assuming it's the color of the top-left pixel or most frequent)\n    # Using top-left is simpler and sufficient for these examples.\n    background_color = input_np[0, 0] \n\n    # Find all non-background objects\n    objects = find_objects(input_np, background_color)\n\n    # Create the output grid filled with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Apply transformation rules based on background color\n    if background_color == 0: # White background rule (Example 1)\n        color_to_corner = {\n            3: 'TL', # Green -> Top-Left\n            1: 'TR', # Blue -> Top-Right\n            4: 'BL', # Yellow -> Bottom-Left\n            2: 'BR'  # Red -> Bottom-Right\n        }\n        for obj in objects:\n            target_corner = color_to_corner.get(obj['color'])\n            if target_corner:\n                place_object(output_grid, obj, target_corner)\n            else:\n                # Handle unexpected colors if necessary, maybe place them at origin?\n                print(f\"Warning: Unhandled color {obj['color']} for background {background_color}\")\n                # place_object(output_grid, obj, 'TL') # Default placement?\n\n    elif background_color == 5: # Gray background rule (Example 2)\n        center_col = cols / 2.0\n        for obj in objects:\n            # Determine if object is in left or right half based on its horizontal center\n            obj_center_c = (obj['min_c'] + obj['max_c']) / 2.0\n            \n            if obj_center_c < center_col: # Left half\n                if obj['color'] == 1: # Blue\n                    target_corner = 'BL'\n                else: # Other colors (Orange, Red)\n                    target_corner = 'TL'\n            else: # Right half\n                if obj['color'] == 4: # Yellow\n                    target_corner = 'BR'\n                else: # Other colors (Green, Maroon)\n                    target_corner = 'TR'\n            \n            place_object(output_grid, obj, target_corner)\n            \n    else:\n        # If background is neither white nor gray, return the input or an empty grid?\n        # For now, let's just return the initialized output grid (background only)\n        print(f\"Warning: Unhandled background color {background_color}\")\n        # Or potentially return input_np if no transformation rule is known\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7064,
    "candidates_token_count": 2032,
    "total_token_count": 9096,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 122.860136,
  "retries": 2
}