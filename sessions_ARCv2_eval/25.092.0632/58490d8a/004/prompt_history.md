
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3
3 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 8 3 3
3 3 3 8 3 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 3 3
3 3 3 3 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 8 3 8 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 4 3 4 3 3 3 3 3 3 3 3 3
0 8 0 0 0 0 0 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 4 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 2 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0
0 8 0 8 0 8 0
0 0 0 0 0 0 0
0 4 0 0 0 0 0
0 0 0 0 0 0 0
0 2 0 2 0 0 0
0 0 0 0 0 0 0
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 2 1 1 1 1 1 1 1 0 8 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 3 3 3 1 0 3 0 0 0 0 0 0 0 0 0 0
1 3 1 1 1 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 4 1 1 1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 4 4 4 1 1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 1 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 4 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 1 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 4 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0
0 1 0 1 0
0 0 0 0 0
0 4 0 0 0
0 0 0 0 0
```

**Perception:**

The input grids are relatively large and contain a dominant background color (green, blue, or azure across the examples). Scattered within this background are various small objects composed of different colors. A key feature in each input grid is a distinct rectangular region composed entirely of white (0) pixels. This white rectangle also contains some non-white pixels within its boundaries.

The output grids are significantly smaller than the input grids. Their background color is consistently white (0). The non-white pixels present in the output grids correspond exactly in color and relative position to the non-white pixels found within the white rectangular region of the input grid. The dimensions of the output grid precisely match the dimensions of the white rectangular region identified in the input.

The core transformation appears to be locating this unique white rectangular subgrid within the larger input grid and extracting it directly to form the output. The surrounding background color and any objects outside this white rectangle in the input are ignored.

**Facts:**


```yaml
task_description: Identify and extract the largest contiguous rectangular area composed of white pixels from the input grid.
grid_properties:
  - input_grid_size: Variable (e.g., 20x22, 23x23, 21x20)
  - output_grid_size: Variable, determined by the size of the identified white rectangle (e.g., 7x7, 7x12, 5x5)
  - dominant_input_background_color: Varies (green, blue, azure), appears irrelevant to the output.
  - output_background_color: Consistently white (0).
objects:
  - type: Contiguous Rectangular Area
    properties:
      - color: white (0)
      - role: Defines the boundaries of the output grid.
      - location: Varies within the input grid.
      - key_feature: Appears to be the largest such rectangle by area in each input.
  - type: Pixels
    properties:
      - color: Various non-white colors (e.g., red, yellow, azure, blue, green)
      - location: Some are scattered outside the white rectangle (ignored), others are located *inside* the white rectangle (preserved).
      - role: Pixels inside the white rectangle are copied to the output grid in their relative positions.
transformation:
  - action: Find all contiguous rectangular regions composed entirely of white (0) pixels in the input grid.
  - action: Select the rectangular region with the largest area (width * height).
  - action: Extract the subgrid defined by the boundaries of the selected white rectangle.
  - result: The extracted subgrid becomes the output grid.
relationships:
  - The output grid is a subgrid of the input grid.
  - The dimensions of the output grid are identical to the dimensions of the largest white (0) rectangular area found in the input.
  - The content of the output grid (including non-white pixels) is identical to the content within the boundaries of the largest white (0) rectangular area in the input.
```


**Natural Language Program:**

1.  Scan the input grid to locate all contiguous rectangular areas where every pixel within the rectangle's boundary is white (color 0).
2.  Calculate the area (width multiplied by height) for each identified white rectangle.
3.  Identify the white rectangle with the maximum area. (Assume there will be only one such rectangle with the maximum area based on the examples).
4.  Determine the top-left corner coordinates (row, column) and the dimensions (height, width) of this largest white rectangle.
5.  Create a new grid with the determined height and width.
6.  Copy the content (all pixel values, including any non-white ones) from the identified rectangular region of the input grid (starting at its top-left corner and spanning its height and width) into the newly created output grid.
7.  The resulting grid is the final output.
```python
"""
Find the largest contiguous rectangular area composed entirely of white pixels (0)
in the input grid. Extract the subgrid corresponding to this area, including any
non-white pixels originally contained within its boundaries. The extracted subgrid
is the output grid.
"""

import numpy as np

def transform(input_grid):
    """
    Identifies the largest all-white (0) rectangular region in the input grid
    and extracts the corresponding subgrid (including any non-white pixels
    originally within that region).

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The extracted subgrid corresponding to the largest
                         all-white rectangular area. Returns an empty list if
                         no white pixels are found.
    """
    np_input = np.array(input_grid, dtype=int)
    height, width = np_input.shape
    max_area = -1
    best_rect_coords = None # Will store (top_r, top_c, rect_height, rect_width)

    # Iterate through all possible top-left corners (r, c)
    for r in range(height):
        for c in range(width):
            # Only consider starting points that are white
            if np_input[r, c] == 0:
                # Iterate through all possible bottom-right corners (r2, c2) for the current top-left
                for r2 in range(r, height):
                    for c2 in range(c, width):
                        # Extract the potential rectangular subgrid defined only by white pixels
                        subgrid_boundary_check = np_input[r:r2+1, c:c2+1]

                        # Check if all pixels within this potential rectangle are white (0)
                        if np.all(subgrid_boundary_check == 0):
                            # Calculate the area of this white rectangle
                            current_height = r2 - r + 1
                            current_width = c2 - c + 1
                            current_area = current_height * current_width

                            # If this rectangle is larger than the best one found so far, update
                            if current_area > max_area:
                                max_area = current_area
                                best_rect_coords = (r, c, current_height, current_width)
                        # Optimization: If we encounter a non-white pixel while expanding
                        # horizontally, we don't need to check wider rectangles starting
                        # from the same row and top-left corner.
                        elif np_input[r2, c2] != 0:
                             break
                    # Optimization: If the first pixel checked in a new row (r2) starting from the
                    # original column (c) is not white, we don't need to check any further down
                    # for this starting column c. (Note: this relies on the horizontal break above)
                    if np_input[r2, c] != 0:
                         break


    # If a largest white rectangle was found
    if best_rect_coords:
        # Extract the actual content (including non-white pixels) from the input grid
        # using the coordinates and dimensions of the largest *all-white* boundary rectangle
        top_r, top_c, rect_height, rect_width = best_rect_coords
        output_grid_np = np_input[top_r : top_r + rect_height, top_c : top_c + rect_width]
        # Convert the NumPy array back to a list of lists for the output
        output_grid = output_grid_np.tolist()
    else:
        # Handle the case where no white pixels (and thus no white rectangles) were found
        # Returning an empty grid might be appropriate, depending on task specification.
        # Based on examples, this case seems unlikely.
        print("Warning: No white rectangular area found.")
        output_grid = [] # Or handle as appropriate

    return output_grid
```
```python
"""
Identifies the largest rectangular area within the input grid that is defined by
a border composed entirely of white (0) pixels. The function then extracts the
subgrid corresponding to this rectangle, including both the white border and
any pixels contained within it (regardless of their color). The extracted
subgrid forms the output grid.
"""

import numpy as np

def _check_white_border(grid_slice):
    """Checks if the border of a given grid slice is all white (0)."""
    height, width = grid_slice.shape
    if height < 2 or width < 2: # Need at least 2x2 for a border
        return False
    # Check top border (row 0)
    if not np.all(grid_slice[0, :] == 0):
        return False
    # Check bottom border (row height-1)
    if not np.all(grid_slice[height-1, :] == 0):
        return False
    # Check left border (col 0)
    if not np.all(grid_slice[:, 0] == 0):
        return False
    # Check right border (col width-1)
    if not np.all(grid_slice[:, width-1] == 0):
        return False
    return True


def transform(input_grid):
    """
    Finds the largest rectangle with an all-white border in the input grid
    and returns the subgrid defined by that rectangle.

    Args:
        input_grid (list[list[int]]): The input grid.

    Returns:
        list[list[int]]: The extracted subgrid corresponding to the largest
                         white-bordered rectangle, or an empty list if none
                         is found.
    """
    np_input = np.array(input_grid, dtype=int)
    height, width = np_input.shape
    max_area = -1
    best_rect_coords = None # Will store (top_r, top_c, bottom_r, bottom_c)

    # Iterate through all possible top-left corners (r1, c1)
    for r1 in range(height):
        for c1 in range(width):
            # Iterate through all possible bottom-right corners (r2, c2)
            # Ensure r2 > r1 and c2 > c1 for a valid rectangle with a border
            for r2 in range(r1 + 1, height):
                for c2 in range(c1 + 1, width):
                    # Extract the potential rectangular subgrid
                    subgrid = np_input[r1:r2+1, c1:c2+1]

                    # Check if this subgrid has an all-white border
                    if _check_white_border(subgrid):
                        # Calculate the area of this rectangle
                        current_height = r2 - r1 + 1
                        current_width = c2 - c1 + 1
                        current_area = current_height * current_width

                        # If this rectangle is larger than the best one found so far, update
                        if current_area > max_area:
                            max_area = current_area
                            # Store the coordinates defining the rectangle in the original grid
                            best_rect_coords = (r1, c1, r2, c2)

    # If a largest white-bordered rectangle was found
    if best_rect_coords:
        # Extract the subgrid from the input using the stored coordinates
        r1, c1, r2, c2 = best_rect_coords
        output_grid_np = np_input[r1 : r2 + 1, c1 : c2 + 1]
        # Convert the NumPy array back to a list of lists for the output
        output_grid = output_grid_np.tolist()
    else:
        # Handle the case where no white-bordered rectangle was found
        # Based on examples, this case seems unlikely. Return empty list.
        print("Warning: No white-bordered rectangular area found.")
        output_grid = []

    return output_grid
```
