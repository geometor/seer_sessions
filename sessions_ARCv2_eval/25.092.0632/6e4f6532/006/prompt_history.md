
## train_1

**input:**
```
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 4 5 5 5 5 5 4 4 5 5 5 5 9 5 5 5 5 5 2 2
1 1 5 5 5 8 8 8 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 8 8 9 8 5 9 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 8 5 9 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 8 8 8 5 5 5 5 4 4 5 5 5 1 5 1 5 5 5 5 2 2
1 1 5 5 5 2 5 2 5 5 5 5 4 4 5 5 5 8 5 8 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 8 8 8 8 8 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 8 9 9 8 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 4 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
```


**output:**
```
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 8 8 8 8 2 5 5 2 2
1 1 5 5 5 5 5 5 8 5 5 5 4 4 5 5 4 8 9 5 8 5 5 5 2 2
1 1 5 5 5 5 5 5 8 8 8 4 4 4 5 5 5 8 8 5 8 2 5 5 2 2
1 1 5 5 5 5 1 8 8 9 5 5 4 4 5 5 5 5 8 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 8 9 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 1 8 8 8 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
1 1 5 5 5 5 5 5 5 5 5 5 4 4 5 5 5 5 5 5 5 5 5 5 2 2
```


## train_2

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 4 8 8 8 8 8 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 4 8 8 9 8 8 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 9 2 2 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 7 7 1 7 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 8 8 1 8 1 1 1 1 1 1 9 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 8 8 1 8 8 3 1 1 1 1 9 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 8 9 8 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 8 8 8 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 9 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 9 2 2 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 8 8 9 8 8 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 8 8 8 8 8 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 8 8 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 8 8 7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 4 8 8 8 8 7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 4 8 9 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 4 8 8 8 8 7 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 7 7
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

*   **Perception:**
    *   The input and output grids have the same dimensions in both examples.
    *   Both examples feature a large background area filled with one dominant color (gray=5 in example 1, blue=1 in example 2).
    *   There are distinct border regions with different colors in both examples (blue/red/yellow in example 1, red/green/yellow/orange in example 2). These border regions remain unchanged between input and output.
    *   Within the main background area, there are scattered pixels and small clusters of various colors.
    *   The transformation specifically affects these scattered pixels/clusters.
    *   Comparing input and output, the key observation is the disappearance or modification of pixels in the vicinity of maroon (9) pixels.
    *   Maroon (9) pixels themselves are removed in the output.
    *   Pixels directly adjacent (horizontally, vertically, and diagonally) to maroon pixels are also removed or changed in the output.
    *   The pixels that are removed/changed are replaced by the dominant background color of the central region (gray=5 in example 1, blue=1 in example 2).
    *   Pixels not adjacent to any maroon pixel remain unchanged.
    *   Calculation confirms that the replacement color in each example corresponds to the most frequent color in the respective input grid.

*   **Facts:**
    
```yaml
    task_type: pattern_modification
    focus: local_neighbor_interaction
    objects:
      - type: grid
        description: Input and output are 2D arrays of pixels.
      - type: pixel
        properties:
          - color: integer from 0-9
          - location: (row, column) coordinates
      - type: background
        description: The most frequent pixel color in the input grid.
        properties:
          - color: 5 (gray) in example 1, 1 (blue) in example 2
      - type: trigger_pixel
        description: Pixels that initiate a change in their neighborhood.
        properties:
          - color: 9 (maroon)
      - type: affected_area
        description: The area around a trigger_pixel that gets modified.
        properties:
          - shape: 3x3 square centered on the trigger_pixel
          - includes: the trigger_pixel itself and its 8 direct and diagonal neighbors

    actions:
      - name: identify_background_color
        input: input_grid
        output: background_color (most frequent color)
      - name: identify_trigger_pixels
        input: input_grid
        output: list_of_trigger_coordinates
      - name: identify_affected_pixels
        input: list_of_trigger_coordinates, grid_dimensions
        output: set_of_affected_coordinates (including trigger pixels and valid neighbors)
      - name: modify_grid
        input: input_grid, set_of_affected_coordinates, background_color
        output: output_grid (copy of input grid with affected pixels changed to background color)

    relationships:
      - type: adjacency
        description: Pixels are considered adjacent if they touch horizontally, vertically, or diagonally.
      - type: replacement
        description: Pixels within the affected_area are replaced by the background_color.
    ```


*   **Natural Language Program:**
    1.  Determine the most frequent pixel color in the input grid; this will be the 'replacement color'.
    2.  Initialize the output grid as a copy of the input grid.
    3.  Identify the locations (row, column) of all maroon (9) pixels in the input grid.
    4.  Create a list of all coordinates that need to be changed:
        *   For each identified maroon pixel location `(r, c)`:
            *   Add the location `(r, c)` itself to the list.
            *   Add the locations of its 8 neighbors (i.e., `(r-1, c-1)`, `(r-1, c)`, `(r-1, c+1)`, `(r, c-1)`, `(r, c+1)`, `(r+1, c-1)`, `(r+1, c)`, `(r+1, c+1)`) to the list, making sure these coordinates are within the bounds of the grid.
    5.  Remove duplicate coordinates from the list of coordinates to be changed (e.g., by converting to a set and back).
    6.  For each coordinate `(r_change, c_change)` in the final list:
        *   Update the pixel value at `(r_change, c_change)` in the output grid to the 'replacement color' determined in step 1.
    7.  Return the modified output grid.
```python
"""
Transformation Rule:
1. Determine the most frequent pixel color in the input grid (the 'background color').
2. Identify all pixels with the color maroon (9).
3. For each maroon pixel, identify its location and the locations of its 8 immediate neighbors (horizontal, vertical, and diagonal).
4. Create a set of all these identified locations (the maroon pixel itself and its valid neighbors within the grid boundaries).
5. Create the output grid by copying the input grid.
6. For every location in the set identified in step 4, change the corresponding pixel in the output grid to the 'background color' determined in step 1.
"""

import numpy as np
from collections import Counter

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    
    Args:
        input_grid (list of lists): The input grid represented as a 2D list.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    # 1. Determine the most frequent pixel color (background color)
    pixels = grid.flatten()
    background_color = Counter(pixels).most_common(1)[0][0]

    # 2. Initialize the output grid as a copy of the input grid
    output_grid = grid.copy()

    # 3. Identify the locations of all maroon (9) pixels
    maroon_coords = np.argwhere(grid == 9)

    # 4. Create a set of all coordinates to be changed
    affected_coords = set()
    for r, c in maroon_coords:
        # Add the maroon pixel itself
        affected_coords.add((r, c))
        # Iterate through its 8 neighbors
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                # Skip the center pixel itself (already added)
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                # Check if the neighbor is within grid bounds
                if 0 <= nr < rows and 0 <= nc < cols:
                    affected_coords.add((nr, nc))

    # 5. & 6. Modify the output grid: change affected pixels to background color
    for r_change, c_change in affected_coords:
        output_grid[r_change, c_change] = background_color

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
```python
"""
Transformation Rule:
1. Determine the most frequent pixel color in the input grid (the 'background color').
2. Identify all pixels with the color maroon (9).
3. Define the 'affected area' as the union of all 3x3 neighborhoods centered on each maroon pixel. A neighborhood includes the center pixel and its 8 direct and diagonal neighbors.
4. Create the output grid by copying the input grid.
5. Replace all pixels within the 'affected area' (coordinates identified in step 3) in the output grid with the 'background color' determined in step 1.
"""

import numpy as np
from collections import Counter

def transform(input_grid):
    """
    Applies the transformation rule to the input grid. Finds all maroon (9)
    pixels, determines the background color (most frequent pixel), and replaces
    the 3x3 neighborhood around each maroon pixel (including the maroon pixel itself)
    with the background color. The neighborhoods are combined (union).

    Args:
        input_grid (list of lists): The input grid represented as a 2D list.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to numpy array for easier manipulation and calculations
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    # 1. Determine the most frequent pixel color (background color)
    # Flatten the grid to get a list of all pixel values
    pixels = grid.flatten()
    # Count occurrences of each color and find the most common one
    if not pixels.size: # Handle empty grid case
        return input_grid # Or potentially raise an error or return empty list
    background_color = Counter(pixels).most_common(1)[0][0]

    # 4. Create the output grid by copying the input grid
    # We will modify this copy
    output_grid = grid.copy()

    # 2. Identify the locations of all maroon (9) pixels
    maroon_coords = np.argwhere(grid == 9)

    # 3. Define the 'affected area' as the union of all 3x3 neighborhoods
    # Use a set to automatically handle the union (duplicates)
    affected_coords = set()
    for r, c in maroon_coords:
        # Iterate through the 3x3 neighborhood centered at (r, c)
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                # Calculate the neighbor's coordinates
                nr, nc = r + dr, c + dc
                # Check if the neighbor coordinates are within the grid bounds
                if 0 <= nr < rows and 0 <= nc < cols:
                    # Add valid coordinates to the set
                    affected_coords.add((nr, nc))

    # 5. Replace all pixels within the 'affected area' with the 'background color'
    for r_change, c_change in affected_coords:
        output_grid[r_change, c_change] = background_color

    # Convert the final numpy array back to a list of lists for the expected output format
    return output_grid.tolist()
```
```python
"""
Transformation Rule:
1. Determine the most frequent pixel color in the input grid (the 'background color').
2. Identify the locations of all pixels with the color maroon (9).
3. Create the output grid by copying the input grid.
4. Change the color of only the pixels at the identified maroon locations to the background color in the output grid.
"""

import numpy as np
from collections import Counter

def transform(input_grid):
    """
    Applies the transformation rule to the input grid. Finds the most frequent
    color, identifies all maroon (9) pixels, and replaces only those maroon
    pixels with the most frequent color.

    Args:
        input_grid (list of lists): The input grid represented as a 2D list.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to numpy array for easier manipulation and calculations
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    # 1. Determine the most frequent pixel color (background color)
    # Flatten the grid to get a list of all pixel values
    pixels = grid.flatten()
    # Handle empty grid case to avoid errors
    if not pixels.size: 
        return input_grid 
    # Count occurrences of each color and find the most common one
    background_color = Counter(pixels).most_common(1)[0][0]

    # 3. Create the output grid by copying the input grid
    # We will modify this copy
    output_grid = grid.copy()

    # 2. Identify the locations of all maroon (9) pixels
    # np.argwhere returns a list of [row, col] for matching elements
    maroon_coords = np.argwhere(grid == 9)

    # 4. Change only the maroon pixels to the background color
    # Iterate through the coordinates found in the previous step
    for r, c in maroon_coords:
        # Update the pixel value at the specific location in the output grid
        output_grid[r, c] = background_color

    # Convert the final numpy array back to a list of lists for the expected output format
    return output_grid.tolist()
```
