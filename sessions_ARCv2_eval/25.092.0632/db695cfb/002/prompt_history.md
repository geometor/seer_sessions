
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 6 5 5
5 1 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 6 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 6 5 5 5 5 5
5 5 5 5 5 5 5 1 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 6 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 5 5 5 6 5 5 5
5 5 5 5 5 5 5 6 5 5 5 5
5 5 5 5 5 5 6 5 5 6 5 5
5 1 5 5 5 6 5 5 5 5 5 6
5 5 1 5 6 5 5 5 5 5 6 5
5 5 5 6 5 5 5 5 5 6 5 5
5 5 6 5 1 5 5 5 6 5 5 5
5 6 5 5 5 1 5 6 5 5 5 5
6 5 5 5 5 5 6 5 5 5 5 5
5 5 5 5 5 6 5 1 5 5 5 5
5 5 5 5 6 5 5 5 5 5 5 5
5 5 5 6 5 5 5 5 5 5 5 5
5 5 6 5 5 5 5 5 5 5 5 5
5 6 5 5 6 5 5 5 5 5 5 5
6 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 6 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 6 8 8 8 8 8 8 8 8 8
8 8 6 8 8 8 1 8 8 8 8
8 8 8 6 8 1 8 8 8 8 8
8 8 8 8 6 8 8 8 8 8 8
8 8 8 1 8 6 8 8 8 8 8
8 8 1 8 8 8 6 8 8 8 8
8 1 8 8 8 8 8 6 8 8 8
8 8 8 8 8 8 8 8 6 8 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 6 4 4 4 4
4 1 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 1 4 4 4 4
4 4 4 4 4 4 1 4 4 4 4 4
4 4 4 4 4 1 4 4 4 4 4 4
4 4 4 4 1 4 4 4 4 4 4 4
4 4 4 1 4 4 4 4 4 4 4 4
4 4 1 4 4 4 4 6 4 4 4 4
4 1 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 6 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 6 8 8 8 8 8 8
8 6 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 6 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 6 8 8 8 8 8 8 8
8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 1 8 8 6
8 8 8 8 1 8 8 8 8 8 8 8 8 8 6 8
8 8 8 8 8 1 8 8 8 8 8 8 8 6 8 8
8 8 8 8 8 8 1 8 8 8 8 8 6 8 8 8
8 8 8 8 8 8 8 1 8 8 8 6 8 8 8 8
8 8 8 8 8 8 8 8 1 8 6 8 8 8 8 8
8 8 8 8 8 8 8 8 8 6 8 8 8 8 8 8
8 6 8 8 8 8 8 8 6 8 1 8 8 8 8 8
8 8 8 8 8 8 8 6 8 8 8 1 8 8 8 8
8 8 8 8 8 8 6 8 8 8 8 8 8 8 8 8
8 8 8 8 8 6 8 8 8 8 8 8 8 8 8 8
8 8 8 1 6 8 8 8 8 8 8 8 8 6 8 8
```


## train_5

**input:**
```
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 1 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 1 4 4
4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4
4 1 4 4 4 4 4 4 4
4 4 1 4 4 4 4 4 4
4 4 4 1 4 4 4 4 4
4 4 4 4 1 4 4 4 4
4 4 4 4 4 1 4 4 4
4 4 4 4 4 4 1 4 4
4 4 4 4 4 4 4 4 4
```

**Perception of Elements:**

1.  **Grid Structure:** All examples involve a 2D grid of pixels with varying dimensions.
2.  **Colors:** The primary colors involved are a single background color (which varies between examples: gray-5, azure-8, yellow-4), blue (1), and magenta (6).
3.  **Input Composition:** The input grids consist of a uniform background color, one or more isolated blue pixels (1), and zero or more isolated magenta pixels (6).
4.  **Output Composition:** The output grids retain the original background color, the original blue pixels, and the original magenta pixels (if any were present in the input). Additionally, new blue pixels appear in the output.
5.  **Transformation Pattern:** The transformation involves adding new blue pixels that form straight line segments connecting certain key points.
    *   If magenta pixels are present in the input, lines are drawn from each magenta pixel to every blue pixel.
    *   If no magenta pixels are present in the input, lines are drawn between every pair of blue pixels.
    *   The pixels along these lines (excluding the endpoints) are colored blue. Where lines overlap, the pixel remains blue.

**YAML Facts:**


```yaml
task_description: Draw lines between specified points and color the path pixels blue.

elements:
  - object: grid
    description: A 2D array of pixels.
  - object: pixel
    properties:
      - color: Represents a value from 0-9 mapped to specific colors.
      - position: (row, column) coordinates within the grid.

identified_objects:
  - object: background_pixel
    description: The most frequent pixel color in the input grid. Remains unchanged in the output.
    properties:
      - color: Varies per example (gray-5, azure-8, yellow-4).
  - object: blue_pixel
    description: Represents target points or connection points.
    properties:
      - color: blue (1)
      - count: One or more in the input.
      - role: Endpoint for line drawing. Remains blue in the output.
  - object: magenta_pixel
    description: Represents source points for line drawing.
    properties:
      - color: magenta (6)
      - count: Zero or more in the input.
      - role: Starting point for line drawing when present. Remains magenta in the output.
  - object: path_pixel
    description: Pixels lying on the straight line between designated start and end points, excluding the endpoints themselves.
    properties:
      - color: Initially the background color.
      - role: Becomes blue (1) in the output grid as part of the transformation.

relationships_and_actions:
  - action: identify_pixels
    actor: system
    inputs:
      - input_grid
    outputs:
      - background_color
      - list_of_blue_pixel_locations
      - list_of_magenta_pixel_locations
  - action: conditional_line_drawing
    description: Based on the presence of magenta pixels, determine which pairs of points to connect.
    condition: magenta_pixels_exist
    if_true:
      action: draw_lines
      parameters:
        start_points: list_of_magenta_pixel_locations
        end_points: list_of_blue_pixel_locations
        line_pairs: Each magenta pixel connects to every blue pixel.
    if_false:
      action: draw_lines
      parameters:
        start_points: list_of_blue_pixel_locations
        end_points: list_of_blue_pixel_locations
        line_pairs: Every blue pixel connects to every other blue pixel (all unique pairs).
  - action: draw_lines
    description: For each specified pair of start and end points, calculate the intermediate pixels forming a straight line between them.
    actor: system
    inputs:
      - start_point_location
      - end_point_location
    outputs:
      - list_of_path_pixel_locations (excluding start and end)
    details: Uses a line drawing algorithm (e.g., Bresenham's) to find integer coordinates along the path.
  - action: color_pixels
    description: Change the color of the identified path pixels to blue.
    actor: system
    inputs:
      - output_grid (initially a copy of input_grid)
      - list_of_all_path_pixel_locations
    outputs:
      - modified_output_grid
    details: Sets the color of pixels at the specified locations to blue (1). Existing blue or magenta pixels are not changed by this step if they happen to fall on a path calculation (though path pixels exclude endpoints).
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the output grid.
2.  Identify the coordinates of all blue pixels (color 1) in the input grid.
3.  Identify the coordinates of all magenta pixels (color 6) in the input grid.
4.  Check if any magenta pixels were found.
5.  **If magenta pixels exist:**
    *   For each magenta pixel location:
        *   For each blue pixel location:
            *   Calculate the sequence of pixels that form a straight line between the magenta pixel location (start) and the blue pixel location (end). Use an algorithm like Bresenham's line algorithm.
            *   For each pixel in this sequence, *excluding* the start (magenta) and end (blue) pixels themselves:
                *   Change the color of the corresponding pixel in the output grid to blue (1).
6.  **If no magenta pixels exist:**
    *   Consider all unique pairs of blue pixel locations.
    *   For each pair of blue pixel locations (point A, point B):
        *   Calculate the sequence of pixels that form a straight line between point A (start) and point B (end).
        *   For each pixel in this sequence, *excluding* the start (point A) and end (point B) pixels themselves:
            *   Change the color of the corresponding pixel in the output grid to blue (1).
7.  Return the modified output grid.
```python
import numpy as np
from typing import List, Tuple

"""
Transformation Rule:

1. Identify the locations of all blue (1) pixels and magenta (6) pixels in the input grid.
2. Create a copy of the input grid for the output.
3. Determine the line drawing mode:
    a. If magenta pixels exist, draw lines from each magenta pixel to every blue pixel.
    b. If no magenta pixels exist, draw lines between every unique pair of blue pixels.
4. For each line segment determined in step 3:
    a. Calculate the integer coordinates of all pixels lying on the straight line connecting the start and end points of the segment.
    b. For each calculated pixel coordinate *except* the start and end points themselves:
        i. Change the color of the corresponding pixel in the output grid to blue (1).
5. Return the modified output grid.
"""

def find_pixels_by_color(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:
    """Finds all pixels of a specific color in the grid."""
    rows, cols = np.where(grid == color)
    return list(zip(rows, cols))

def bresenham_line(r1: int, c1: int, r2: int, c2: int) -> List[Tuple[int, int]]:
    """
    Generates the integer coordinates of pixels forming a line between (r1, c1) and (r2, c2)
    using a Bresenham-like algorithm suitable for grid coordinates.
    Includes both start and end points.
    """
    points = []
    dr = abs(r2 - r1)
    dc = abs(c2 - c1)
    sr = 1 if r1 < r2 else -1
    sc = 1 if c1 < c2 else -1
    err = dr - dc

    r, c = r1, c1

    while True:
        points.append((r, c))
        if r == r2 and c == c2:
            break
        e2 = 2 * err
        if e2 > -dc:
            err -= dc
            r += sr
        if e2 < dr:
            err += dr
            c += sc
            
    # Ensure the exact endpoint is included if the loop terminates slightly early due to integer math
    # Although the standard Bresenham should handle this, double-check for grid contexts.
    # The standard implementation above correctly includes endpoints.
            
    return points

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the line drawing transformation based on blue and magenta pixels.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)

    # Find the locations of blue and magenta pixels
    blue_pixels = find_pixels_by_color(input_grid, 1)
    magenta_pixels = find_pixels_by_color(input_grid, 6)

    # Determine line drawing pairs
    line_pairs = []
    if magenta_pixels:
        # Mode 1: Connect each magenta to every blue
        for m_pos in magenta_pixels:
            for b_pos in blue_pixels:
                line_pairs.append((m_pos, b_pos))
    elif len(blue_pixels) > 1:
        # Mode 2: Connect every unique pair of blue pixels
        for i in range(len(blue_pixels)):
            for j in range(i + 1, len(blue_pixels)):
                line_pairs.append((blue_pixels[i], blue_pixels[j]))

    # Draw the lines by coloring intermediate path pixels blue
    for start_pos, end_pos in line_pairs:
        r1, c1 = start_pos
        r2, c2 = end_pos

        # Get all points on the line segment
        line_points = bresenham_line(r1, c1, r2, c2)

        # Color the intermediate points blue (skip start and end points)
        if len(line_points) > 2:  # Ensure there are intermediate points
            for r, c in line_points[1:-1]:
                # Only change background pixels, don't overwrite existing blue/magenta points
                # Although the description implies coloring regardless, example 1 output shows
                # a blue path pixel overlapping where an input blue pixel was, remaining blue.
                # The safest interpretation is to just set the path pixels to blue.
                # If a path pixel happens to be where an original blue/magenta pixel was,
                # setting it to blue again doesn't change anything important.
                output_grid[r, c] = 1

    return output_grid
```
