
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 0 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 0 0 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 7 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 7 7 7 7 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 7 7 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 7 7 7 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 7 7 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 2 0 0 2 2 0 0 2 0 0 2 2 0 2 0 0 2 0
0 0 2 0 0 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 4 4 2 0 0 0 0 0 2 4 4 2 0
0 0 2 4 4 2 2 4 4 2 0 0 2 2 0 2 4 4 2 0
0 0 2 4 4 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


## train_4

**input:**
```
0 0 2 2 0 0 0 0
0 2 0 0 2 0 0 0
0 2 0 0 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```


**output:**
```
0 0 2 2 0 0 0 0
0 2 4 4 2 0 0 0
0 2 4 4 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```

**Perception of Task Elements:**

The task involves identifying specific regions within the input grid and modifying their color based on a global property of the grid.

1.  **Input Grid Analysis:** The input grids contain various shapes and patterns formed by different colored pixels against a white background (color 0). Key colors observed are blue (2), green (3), yellow (4), gray (5), and orange (7). Other colors like blue (1) are also present but seem less critical to the core transformation.
2.  **Output Grid Analysis:** The output grids are largely identical to the input grids, except that certain areas of white pixels (0) have been filled with a specific color.
3.  **Identifying the Transformation Trigger:** In each example, there is exactly one pixel with a "special" color: orange (7) in `train_1` and yellow (4) in `train_2`, `train_3`, and `train_4`. This special color becomes the "fill color" in the output.
4.  **Identifying the Target Regions:** The regions that get filled are areas composed entirely of white pixels (0). These white regions appear to be completely enclosed or surrounded by non-white pixels. The shape and color of the enclosing pixels do not determine the fill color, only that they are non-white.
5.  **Defining "Enclosed":** A white region seems to be considered "enclosed" if it does not touch the boundary of the grid and all paths leading out of the region must cross a non-white pixel. This suggests using 4-connectivity (up, down, left, right neighbours) to define regions and their boundaries.
6.  **Transformation Rule:** The core transformation is to find the unique special color pixel (orange 7 or yellow 4) in the input, identify all fully enclosed white regions, and change the color of all pixels within these enclosed regions to the special color.

**YAML Facts:**


```yaml
task_description: Fill enclosed white regions with a special color found elsewhere in the grid.
elements:
  - element: grid
    description: A 2D array of pixels with colors 0-9.
  - element: background
    color: 0 (white)
    role: Fills most of the grid, some areas are targeted for filling.
  - element: boundary_pixels
    color: Any non-white color (1-9)
    role: Form shapes and enclose regions of white pixels. Specific color doesn't matter for enclosure, only that it's non-white.
  - element: enclosed_regions
    description: Contiguous areas of white pixels (0) fully surrounded by non-white pixels. These regions do not touch the grid borders.
    property: target_for_filling
  - element: special_pixel
    description: A single pixel in the input grid with a specific color.
    color: 4 (yellow) or 7 (orange)
    role: Determines the color used to fill the enclosed regions. There is exactly one such pixel per input grid.
    property: fill_color
relationships:
  - type: enclosure
    subject: boundary_pixels
    object: enclosed_regions
    description: Non-white pixels form a boundary completely surrounding a region of white pixels (using 4-connectivity).
  - type: color_source
    subject: special_pixel
    object: enclosed_regions
    description: The color of the special_pixel is used as the new color for the pixels within the enclosed_regions in the output.
actions:
  - action: find_special_pixel
    input: input_grid
    output: fill_color (color 4 or 7)
    description: Locate the unique pixel with color 4 or 7.
  - action: identify_enclosed_regions
    input: input_grid
    output: list_of_enclosed_regions (coordinates of white pixels in each region)
    description: Find all contiguous regions of white pixels that are fully surrounded by non-white pixels and do not touch the grid border.
  - action: fill_regions
    input: input_grid, fill_color, list_of_enclosed_regions
    output: output_grid
    description: Create the output grid by copying the input grid and changing the color of all pixels within the identified enclosed regions to the fill_color.
```


**Natural Language Program:**

1.  Examine the input grid to find the single pixel whose color is either yellow (4) or orange (7). Store this color as the `fill_color`.
2.  Create a copy of the input grid to serve as the basis for the output grid.
3.  Identify all contiguous regions of white (0) pixels in the input grid.
4.  For each identified white region:
    a.  Check if the region is fully enclosed. A region is fully enclosed if none of its pixels are located on the border rows or columns of the grid, AND all pixels immediately adjacent (up, down, left, right) to the pixels of the white region are non-white pixels. (Alternatively, perform a flood fill starting from all white pixels on the grid border; any white pixel *not* reached by this fill belongs to an enclosed region).
    b.  If a white region is determined to be fully enclosed, change the color of all pixels belonging to that region in the copied grid to the `fill_color` identified in step 1.
5.  The modified copied grid is the final output grid.
```python
import numpy as np
from collections import deque

"""
Fill enclosed white regions (color 0) with a special color (4 or 7) found elsewhere in the grid.
An enclosed region is a contiguous area of white pixels that does not touch the grid border and is entirely surrounded by non-white pixels.
The special color (fill_color) is determined by finding the single pixel in the input grid with color 4 (yellow) or 7 (orange).
"""

def find_special_color(grid):
    """Finds the unique pixel with color 4 or 7."""
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 4 or grid[r, c] == 7:
                return grid[r, c]
    # Should not happen based on problem description, but return a default if needed
    return 0 

def find_enclosed_white_pixels(grid):
    """
    Identifies coordinates of white pixels belonging to enclosed regions.
    Uses a flood fill (BFS) starting from border white pixels. 
    Any white pixel NOT visited by this fill is considered enclosed.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    q = deque()

    # Add all border white pixels to the queue and mark as visited
    for r in range(rows):
        if grid[r, 0] == 0 and not visited[r, 0]:
            q.append((r, 0))
            visited[r, 0] = True
        if grid[r, cols - 1] == 0 and not visited[r, cols - 1]:
            q.append((r, cols - 1))
            visited[r, cols - 1] = True
    for c in range(cols):
        if grid[0, c] == 0 and not visited[0, c]:
            q.append((0, c))
            visited[0, c] = True
        if grid[rows - 1, c] == 0 and not visited[rows - 1, c]:
            q.append((rows - 1, c))
            visited[rows - 1, c] = True

    # Perform BFS (flood fill) from border white pixels
    while q:
        r, c = q.popleft()
        
        # Check 4 neighbours (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            
            # Check bounds and if neighbour is white and not visited
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == 0 and not visited[nr, nc]:
                visited[nr, nc] = True
                q.append((nr, nc))

    # Collect coordinates of white pixels NOT visited
    enclosed_pixels = []
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 0 and not visited[r, c]:
                enclosed_pixels.append((r, c))
                
    return enclosed_pixels

def transform(input_grid):
    """
    Transforms the input grid by finding enclosed white regions and filling them
    with a special color (4 or 7) present elsewhere in the grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_np)
    
    # 1. Find the special fill color (4 or 7)
    fill_color = find_special_color(input_np)
    
    # If no special color is found, return the original grid (shouldn't happen based on examples)
    if fill_color == 0: 
         return output_grid.tolist() # Convert back to list of lists

    # 2. Identify all white pixels belonging to enclosed regions
    enclosed_pixels = find_enclosed_white_pixels(input_np)
    
    # 3. Fill the identified enclosed pixels with the fill_color
    for r, c in enclosed_pixels:
        output_grid[r, c] = fill_color
        
    # Convert the result back to a list of lists for the required output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions of white pixels (color 0) that are fully enclosed 
within a boundary composed of a single non-white color and do not touch the grid border. 
These enclosed regions are then filled with a special color (either 4 or 7) 
which is determined by finding the unique pixel of that color elsewhere in the input grid.

Transformation Steps:
1. Find the unique special 'fill_color' (4 or 7) in the input grid.
2. Create a copy of the input grid for the output.
3. Identify all white pixels (0) that are not connected to the grid border via a path of white pixels.
4. Group these border-disconnected white pixels into contiguous regions (components).
5. For each such region:
    a. Find all non-white pixels immediately adjacent (up, down, left, right) to the region.
    b. Check if all these adjacent non-white pixels have the exact same color.
    c. If the boundary color is uniform, fill all pixels within this white region in the output grid with the 'fill_color'.
6. Return the modified output grid.
"""

def find_special_color(grid):
    """Finds the unique pixel with color 4 or 7."""
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 4 or grid[r, c] == 7:
                return grid[r, c]
    # Fallback, though examples suggest one will always be present
    return None 

def find_enclosed_regions_with_uniform_boundary(grid):
    """
    Identifies components of white pixels not connected to the border, 
    and checks if their immediate non-white boundary is of a single uniform color.
    Returns a list of components (each component is a list of (r, c) tuples) 
    that satisfy the uniform boundary condition.
    """
    rows, cols = grid.shape
    # visited_border_bfs marks white pixels connected to the border
    visited_border_bfs = np.zeros_like(grid, dtype=bool)
    # visited_component_bfs marks pixels visited during component finding
    visited_component_bfs = np.zeros_like(grid, dtype=bool) 
    
    q_border = deque()

    # 1. Perform BFS from border white pixels to mark reachable ones
    for r in range(rows):
        if grid[r, 0] == 0 and not visited_border_bfs[r, 0]:
            q_border.append((r, 0))
            visited_border_bfs[r, 0] = True
            visited_component_bfs[r, 0] = True # Also mark as visited for component search
        if grid[r, cols - 1] == 0 and not visited_border_bfs[r, cols - 1]:
            q_border.append((r, cols - 1))
            visited_border_bfs[r, cols - 1] = True
            visited_component_bfs[r, cols - 1] = True
    for c in range(cols):
        if grid[0, c] == 0 and not visited_border_bfs[0, c]:
            q_border.append((0, c))
            visited_border_bfs[0, c] = True
            visited_component_bfs[0, c] = True
        if grid[rows - 1, c] == 0 and not visited_border_bfs[rows - 1, c]:
            q_border.append((rows - 1, c))
            visited_border_bfs[rows - 1, c] = True
            visited_component_bfs[rows - 1, c] = True
            
    while q_border:
        r, c = q_border.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr, nc] == 0 and not visited_border_bfs[nr, nc]:
                visited_border_bfs[nr, nc] = True
                visited_component_bfs[nr, nc] = True # Mark as visited
                q_border.append((nr, nc))

    valid_regions = []
    
    # 2. Find components of remaining (unvisited) white pixels
    for r in range(rows):
        for c in range(cols):
            # If it's a white pixel AND wasn't visited by border BFS (hence not connected to border) 
            # AND hasn't been visited by a component search yet
            if grid[r, c] == 0 and not visited_border_bfs[r, c] and not visited_component_bfs[r, c]:
                
                current_component = []
                q_component = deque([(r, c)])
                visited_component_bfs[r, c] = True
                boundary_pixels = set()
                
                # BFS to find the full component
                while q_component:
                    curr_r, curr_c = q_component.popleft()
                    current_component.append((curr_r, curr_c))
                    
                    # Explore neighbors to grow component AND find boundary pixels
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        
                        if 0 <= nr < rows and 0 <= nc < cols:
                            # If neighbor is white and part of the potential enclosed region
                            if grid[nr, nc] == 0 and not visited_border_bfs[nr, nc] and not visited_component_bfs[nr, nc]:
                                visited_component_bfs[nr, nc] = True
                                q_component.append((nr, nc))
                            # If neighbor is non-white, it's a boundary pixel
                            elif grid[nr, nc] != 0:
                                boundary_pixels.add((nr, nc))
                        # Note: Pixels on the border that are non-white could be boundary pixels
                        # The initial border BFS handles white pixels on the border.

                # 3. Check if the boundary of this component is uniform
                boundary_color = None
                is_uniform = True
                if not boundary_pixels: # Should not happen for a truly enclosed region
                    is_uniform = False
                else:
                    for br, bc in boundary_pixels:
                        current_b_color = grid[br, bc]
                        if boundary_color is None:
                            boundary_color = current_b_color
                        elif boundary_color != current_b_color:
                            is_uniform = False
                            break # Non-uniform boundary found
                            
                # 4. If boundary is uniform, add component to list
                if is_uniform:
                    valid_regions.append(current_component)

    return valid_regions


def transform(input_grid):
    """
    Transforms the input grid by filling enclosed white regions (having a uniform 
    non-white boundary) with the special color (4 or 7).
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_np)
    
    # 1. Find the special fill color (4 or 7)
    fill_color = find_special_color(input_np)
    
    # If no special color is found, return the original grid
    if fill_color is None: 
         return output_grid.tolist() # Convert back to list of lists

    # 2. Identify all white regions enclosed by a uniform boundary color
    regions_to_fill = find_enclosed_regions_with_uniform_boundary(input_np)
    
    # 3. Fill the identified regions with the fill_color
    for region in regions_to_fill:
        for r, c in region:
            output_grid[r, c] = fill_color
            
    # Convert the result back to a list of lists for the required output format
    return output_grid.tolist()
```
