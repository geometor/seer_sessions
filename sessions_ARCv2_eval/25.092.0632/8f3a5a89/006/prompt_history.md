
## train_1

**input:**
```
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
6 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
6 7 7 7 7 7 1 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 1 1 8 8 8 8
8 8 8 8 1 1 8 8 8 8
8 8 8 8 1 1 8 8 8 1
8 8 8 8 8 8 8 8 8 1
1 8 8 8 8 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8
6 8 8 8 8 1 1 8 8 8
```


**output:**
```
7 7 7 7 1 1 7 7 7 7
7 8 8 7 1 1 7 8 7 7
7 8 8 7 1 1 7 8 7 1
7 7 8 7 7 7 7 8 7 1
1 7 8 8 8 8 8 8 7 1
7 7 8 8 8 8 8 8 7 7
7 8 8 8 8 8 8 8 8 7
7 8 8 8 8 7 7 7 8 7
7 8 8 8 7 7 1 7 8 7
6 7 7 7 7 1 1 7 7 7
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 1 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
6 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 1 7 7 7 7 7 7 7
7 8 8 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
7 7 8 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 7 7 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 1 7 7 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 1 1 7 7 8 8 8 8 8 8 7 7 7 8 8 8 8 8 7
1 1 1 1 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
1 1 1 1 1 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
1 1 1 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
7 7 7 7 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
6 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 1 1 1
```

**Perception**

The task involves transforming an input grid into an output grid of the same dimensions. The input grids consist primarily of a gray (8) background, with scattered blue (1) pixels and a single magenta (6) pixel consistently located in the bottom-left corner.

The transformation rule centers on changing the color of specific gray pixels based on their proximity to blue pixels. The blue pixels themselves, as well as the magenta pixel, remain unchanged in the output grid. Gray pixels that are adjacent (horizontally, vertically, or diagonally) to at least one blue pixel are changed to orange (7) in the output. All other gray pixels remain gray. The magenta pixel does not influence the color change of adjacent gray pixels unless those pixels are also adjacent to a blue pixel.

**Facts**


```yaml
grid_properties:
  - Input and output grids have identical dimensions.
colors:
  - Gray (8): Background color in the input. Some remain gray, others change.
  - Blue (1): 'Active' objects in the input. Remain unchanged in the output. Trigger color changes in adjacent gray pixels.
  - Magenta (6): A single 'marker' pixel in the input (bottom-left). Remains unchanged in the output. Does not directly trigger color changes.
  - Orange (7): A new color appearing only in the output. Replaces certain gray pixels.
objects:
  - Background: The set of gray (8) pixels.
  - Blue Pixels: Individual blue (1) pixels or contiguous groups of them.
  - Magenta Marker: The single magenta (6) pixel.
relationships:
  - Adjacency: The core relationship is the adjacency (including diagonals) between gray pixels and blue pixels.
transformation:
  - Rule: A gray pixel changes to orange if and only if it is adjacent (8 neighbors) to at least one blue pixel.
  - Preservation: Blue pixels and the magenta pixel retain their color and position. Gray pixels not adjacent to any blue pixel also retain their color and position.
```


**Natural Language Program**

1.  Create a new grid (the output grid) with the same dimensions as the input grid.
2.  Iterate through each cell (pixel) of the input grid, identified by its row and column index.
3.  For the current cell:
    a.  Get the color of the pixel in the input grid.
    b.  If the input pixel's color is gray (8):
        i.  Examine the 8 neighboring pixels (horizontally, vertically, and diagonally adjacent) in the *input* grid. Be careful to handle boundary conditions (neighbors outside the grid do not exist).
        ii. Check if any of these valid neighbors have the color blue (1).
        iii. If at least one neighbor is blue (1), set the color of the corresponding cell in the output grid to orange (7).
        iv. If no neighbor is blue (1), set the color of the corresponding cell in the output grid to gray (8).
    c.  If the input pixel's color is *not* gray (8) (i.e., it is blue (1) or magenta (6)), copy its color directly to the corresponding cell in the output grid.
4.  Return the completed output grid.
```python
import numpy as np

"""
Transforms an input grid based on the adjacency of gray pixels to blue pixels.

1. Creates an output grid of the same dimensions as the input grid.
2. Iterates through each pixel of the input grid.
3. If the input pixel is gray (8):
    a. Checks its 8 adjacent neighbors (including diagonals) in the input grid.
    b. If any neighbor is blue (1), the corresponding pixel in the output grid is set to orange (7).
    c. Otherwise (no blue neighbors), the corresponding pixel in the output grid remains gray (8).
4. If the input pixel is not gray (i.e., blue (1) or magenta (6)), its color is copied directly to the output grid.
5. Returns the transformed output grid.
"""

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (list of lists or np.ndarray): The input grid.

    Returns:
        np.ndarray: The transformed output grid.
    """
    # Convert input to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape

    # Initialize the output grid as a copy of the input grid.
    # This handles the preservation of non-gray pixels.
    output_array = np.copy(input_array)

    # Define relative coordinates for the 8 neighbors (including diagonals)
    neighbors = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Iterate through each cell of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current pixel in the input grid is gray (8)
            if input_array[r, c] == 8:
                found_blue_neighbor = False
                # Examine the 8 neighbors
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    # Check if the neighbor coordinates are within the grid boundaries
                    if 0 <= nr < height and 0 <= nc < width:
                        # Check if the neighbor in the *input* grid is blue (1)
                        if input_array[nr, nc] == 1:
                            found_blue_neighbor = True
                            break # No need to check other neighbors if one blue is found
                
                # If a blue neighbor was found, change the output pixel to orange (7)
                if found_blue_neighbor:
                    output_array[r, c] = 7
                # Otherwise, the output pixel remains gray (8) (already set by the copy)

            # If the input pixel is not gray (1 or 6), its value is already correctly copied
            # to the output_array, so no action is needed here.

    return output_array.tolist() # Return as list of lists as per ARC standard format
```
```python
import numpy as np
from collections import deque

"""
Transforms an input grid by flood-filling gray areas (8) with orange (7) 
starting from gray pixels adjacent to blue pixels (1).

1.  Initialize an output grid as a copy of the input grid. This preserves the 
    original positions and colors of non-gray pixels (blue=1, magenta=6).
2.  Identify all gray (8) pixels in the input grid that are directly adjacent 
    (horizontally, vertically, or diagonally) to at least one blue (1) pixel.
3.  Use these identified adjacent gray pixels as starting points (seeds) for a 
    flood-fill (specifically, Breadth-First Search - BFS).
4.  Maintain a queue for the BFS and a way to track visited/processed pixels 
    to avoid redundant work and infinite loops (can use the output grid itself).
5.  Start the BFS:
    a.  Add all seed gray pixel coordinates to the queue.
    b.  Mark these seed pixels as orange (7) in the output grid immediately.
6.  While the queue is not empty:
    a.  Dequeue a pixel coordinate (r, c).
    b.  Examine its 8 neighbors (nr, nc) in the input grid.
    c.  For each valid neighbor (within grid bounds):
        i.  If the neighbor is gray (8) in the *input* grid AND its corresponding 
            pixel in the *output* grid is still gray (8) (meaning it hasn't 
            been processed/queued yet):
            -   Set the neighbor's pixel in the output grid to orange (7).
            -   Enqueue the neighbor's coordinates (nr, nc).
7.  Once the queue is empty, the flood fill is complete. All gray pixels reachable 
    from a blue pixel via a path of gray pixels will have been turned orange.
8.  Return the final output grid.
"""

def transform(input_grid):
    """
    Applies the flood-fill transformation rule to the input grid.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape

    # Initialize the output grid as a copy of the input grid.
    output_array = np.copy(input_array)

    # Define relative coordinates for the 8 neighbors (including diagonals)
    neighbors = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Use a queue for the Breadth-First Search (BFS) flood fill
    queue = deque()

    # Find initial seed gray pixels adjacent to blue pixels and add them to the queue
    for r in range(height):
        for c in range(width):
            # Only consider gray pixels in the input
            if input_array[r, c] == 8:
                is_adjacent_to_blue = False
                # Check neighbors in the input array
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_array[nr, nc] == 1:
                        is_adjacent_to_blue = True
                        break
                
                # If adjacent to blue and not already processed (which it won't be yet)
                if is_adjacent_to_blue:
                    # Mark as orange in the output and add to queue
                    output_array[r, c] = 7 
                    queue.append((r, c))

    # Perform the BFS flood fill
    while queue:
        r, c = queue.popleft()

        # Explore neighbors of the current pixel (which is now orange)
        for dr, dc in neighbors:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor was originally gray in the input AND
                # is still gray in the output (meaning it hasn't been visited/colored orange yet)
                if input_array[nr, nc] == 8 and output_array[nr, nc] == 8:
                    # Color the neighbor orange in the output
                    output_array[nr, nc] = 7
                    # Add the neighbor to the queue to process its neighbors later
                    queue.append((nr, nc))

    # Return the transformed grid as a list of lists
    return output_array.tolist()
```
```python
import numpy as np

"""
Transforms an input grid based on the direct adjacency of gray pixels to blue pixels.

1. Creates an output grid initialized as a copy of the input grid. This ensures 
   non-gray pixels (blue=1, magenta=6) are preserved in their original positions.
2. Iterates through each pixel of the input grid.
3. If the input pixel at position (r, c) is gray (8):
    a. Checks its 8 adjacent neighbors (including diagonals) in the *input* grid.
    b. If any of these neighbors is blue (1), the corresponding pixel at (r, c) 
       in the *output* grid is set to orange (7).
    c. If none of the neighbors are blue, the pixel at (r, c) in the output 
       grid remains gray (8) (as it was initialized).
4. If the input pixel is not gray, its value in the output grid remains unchanged 
   from the initial copy.
5. Returns the transformed output grid.
"""

def transform(input_grid):
    """
    Applies the adjacency transformation rule to the input grid.

    Args:
        input_grid (list of lists or np.ndarray): The input grid.

    Returns:
        list of lists: The transformed output grid.
    """
    # Convert input to a NumPy array for easier manipulation
    input_array = np.array(input_grid, dtype=int)
    height, width = input_array.shape

    # Initialize the output grid as a copy of the input grid.
    # This handles the preservation of non-gray pixels (1 and 6).
    output_array = np.copy(input_array)

    # Define relative coordinates for the 8 neighbors (including diagonals)
    neighbors = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1)
    ]

    # Iterate through each cell of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current pixel in the *input* grid is gray (8)
            if input_array[r, c] == 8:
                found_blue_neighbor = False
                # Examine the 8 neighbors in the *input* grid
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    # Check if the neighbor coordinates are within the grid boundaries
                    if 0 <= nr < height and 0 <= nc < width:
                        # Check if the neighbor in the *input* grid is blue (1)
                        if input_array[nr, nc] == 1:
                            found_blue_neighbor = True
                            break # Stop checking neighbors once a blue one is found

                # If a blue neighbor was found in the input grid, 
                # change the corresponding pixel in the *output* grid to orange (7)
                if found_blue_neighbor:
                    output_array[r, c] = 7
                # Otherwise, the output pixel remains gray (8), which is already set by the initial copy.

    # Convert the result back to a list of lists for the standard ARC format
    return output_array.tolist()
```
