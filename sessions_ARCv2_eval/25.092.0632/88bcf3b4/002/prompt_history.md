
## train_1

**input:**
```
0 0 0 0 0 0 0
0 0 0 0 0 2 0
0 0 0 0 0 0 0
0 0 0 4 4 8 0
0 0 0 4 0 8 0
0 0 4 4 0 8 0
0 4 0 0 0 8 0
```


**output:**
```
0 0 0 0 0 4 0
0 0 0 0 4 2 0
0 0 0 0 4 0 0
0 0 0 0 4 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
```


## train_2

**input:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 3 3 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


**output:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 7 3 7 7 7 7 7 7 7
7 7 7 7 7 3 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


## train_3

**input:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 7 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 7 7 1 1 1 1
1 1 1 1 1 1 2 1 7 7 7 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 8 8 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


**output:**
```
0 0 0 8 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 8 3 0 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 9 0 6 0 0 0
9 9 9 0 0 6 0 0 0
9 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 9 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Grid Structure:** The input and output are both 2D grids of colored pixels. The size of the grid remains the same between input and output for each example.
2.  **Background Color:** Each grid has a dominant background color (white/0 in ex 1, 4, 5; orange/7 in ex 2; blue/1 in ex 3). This background color remains largely unchanged in the output, except where specific transformations occur.
3.  **Objects:** Within the grid, there are distinct "objects" composed of contiguous pixels of non-background colors. In all examples, there appear to be exactly three distinct non-background colors present in the input grid.
4.  **Color Roles:** By comparing inputs and outputs, it seems the three non-background colors play specific roles based on their numerical value (color index):
    *   **Target Color:** The color with the highest numerical index among the three non-background colors. Pixels of this color remain unchanged and seem to influence the transformation.
    *   **Unaffected Color:** The color with the middle numerical index. Pixels of this color remain completely unchanged in the output.
    *   **Source Color:** The color with the lowest numerical index. Pixels of this color are the ones that undergo transformation.
5.  **Transformation Rule:** The core transformation operates on the pixels of the Source color.
    *   If a pixel with the Source color is adjacent (horizontally, vertically, or diagonally) to *any* pixel with the Target color in the input grid, its color changes to the Target color in the output grid.
    *   If a pixel with the Source color is *not* adjacent to any pixel with the Target color, its color changes to the Background color in the output grid.
6.  **Consistency:** This pattern holds across all five training examples. The identification of Source, Target, and Unaffected colors based on their numerical index (min, max, mid) and the subsequent adjacency-based transformation rule correctly predicts the output from the input.

**Facts**


```yaml
Task: Modify pixels of one color based on adjacency to pixels of another color.

Input_Grid:
  Properties:
    - Contains a single Background_Color (most frequent color).
    - Contains exactly three distinct Non_Background_Colors.
  Objects:
    - Pixels forming contiguous areas.

Color_Roles:
  - Identify the three Non_Background_Colors present in the input.
  - Target_Color: The Non_Background_Color with the highest numerical index.
  - Unaffected_Color: The Non_Background_Color with the middle numerical index.
  - Source_Color: The Non_Background_Color with the lowest numerical index.

Transformation:
  Action: Modify pixels based on color role and adjacency.
  Rule:
    - Iterate through each pixel (cell) in the input grid.
    - If the pixel color is Source_Color:
      - Check the 8 neighboring pixels (including diagonals).
      - Condition: If any neighbor has the Target_Color.
        - Result_True: Change the pixel's color to Target_Color in the output grid.
        - Result_False: Change the pixel's color to Background_Color in the output grid.
    - Else (pixel color is Target_Color, Unaffected_Color, or Background_Color):
      - Result: Keep the original pixel color in the output grid.

Output_Grid:
  Properties:
    - Same dimensions as Input_Grid.
    - Contains pixels modified according to the Transformation Rule.
    - Pixels originally of Target_Color or Unaffected_Color remain unchanged.
    - Background largely remains, potentially expanding into areas previously occupied by Source_Color pixels.
```


**Natural Language Program**

1.  Create a copy of the input grid to serve as the initial state of the output grid.
2.  Identify the background color by finding the most frequent color in the input grid.
3.  Identify all unique non-background colors present in the input grid. There should be exactly three.
4.  Sort these three non-background colors numerically by their color index.
5.  Assign roles based on the sorted order:
    *   `Source_Color`: The color with the lowest index.
    *   `Unaffected_Color`: The color with the middle index.
    *   `Target_Color`: The color with the highest index.
6.  Iterate through each cell (pixel) of the *input* grid, examining its coordinates (row, column) and color.
7.  If the color of the current cell in the *input* grid is equal to the `Source_Color`:
    *   Initialize a flag `is_adjacent_to_target` to `False`.
    *   Examine the 8 neighbors (up, down, left, right, and diagonals) of the current cell in the *input* grid.
    *   For each valid neighbor:
        *   If the neighbor's color in the *input* grid is equal to the `Target_Color`, set `is_adjacent_to_target` to `True` and stop checking neighbors for this cell.
    *   Based on the flag:
        *   If `is_adjacent_to_target` is `True`, update the color of the cell at the same (row, column) in the *output* grid to `Target_Color`.
        *   If `is_adjacent_to_target` is `False`, update the color of the cell at the same (row, column) in the *output* grid to the `Background_Color`.
8.  (Implicitly) If the color of the current cell in the *input* grid was *not* the `Source_Color`, its color in the *output* grid remains unchanged (as per the initial copy).
9.  Return the final modified output grid.
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid based on color adjacency rules.

1. Identifies the background color (most frequent) and the three unique non-background colors.
2. Sorts the non-background colors numerically:
    - Lowest index = Source_Color
    - Middle index = Unaffected_Color
    - Highest index = Target_Color
3. Iterates through each pixel of the input grid.
4. If a pixel has the Source_Color:
    - Checks its 8 neighbors (including diagonals) in the input grid.
    - If any neighbor has the Target_Color, the corresponding pixel in the output grid is set to Target_Color.
    - Otherwise (no Target_Color neighbors), the output pixel is set to the Background_Color.
5. Pixels with colors other than Source_Color (Background, Unaffected, Target) retain their original color in the output grid.
"""

def get_colors(grid):
    """Identifies background and non-background colors."""
    unique_colors, counts = np.unique(grid, return_counts=True)
    background_color = unique_colors[np.argmax(counts)]
    non_background_colors = sorted([color for color in unique_colors if color != background_color])
    if len(non_background_colors) != 3:
        # This case might indicate an issue with the problem assumption or the specific input
        # For robustness, handle it, perhaps by returning None or raising an error
        # Or, if it's possible only a subset exist, adapt logic. Assuming 3 based on examples.
        print(f"Warning: Expected 3 non-background colors, found {len(non_background_colors)}: {non_background_colors}")
        # Decide on handling: maybe return placeholders or raise error?
        # Returning placeholders for now to avoid crashing during tests if input deviates.
        source, unaffected, target = (None, None, None)
        if len(non_background_colors) > 0: source = non_background_colors[0]
        if len(non_background_colors) > 1: unaffected = non_background_colors[1]
        if len(non_background_colors) > 2: target = non_background_colors[2]
        return background_color, source, unaffected, target
        
    source_color = non_background_colors[0]
    unaffected_color = non_background_colors[1]
    target_color = non_background_colors[2]
    
    return background_color, source_color, unaffected_color, target_color

def is_valid(r, c, rows, cols):
    """Checks if coordinates are within grid bounds."""
    return 0 <= r < rows and 0 <= c < cols

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape
    
    # initialize output_grid as a copy of the input
    output_grid = np.copy(input_np)

    # 1. Identify colors and roles
    background_color, source_color, unaffected_color, target_color = get_colors(input_np)

    # Handle cases where exactly 3 non-background colors might not be found
    if source_color is None or target_color is None:
         # If crucial colors are missing, maybe return the input unchanged or handle error
         print("Error: Could not determine Source or Target color. Returning input.")
         return input_grid # Or output_grid which is currently a copy

    # 3. Iterate through each pixel of the *input* grid
    for r in range(rows):
        for c in range(cols):
            # 4. Check if the current pixel has the Source_Color
            if input_np[r, c] == source_color:
                is_adjacent_to_target = False
                # Check 8 neighbors
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        if dr == 0 and dc == 0:
                            continue # Skip the cell itself
                        
                        nr, nc = r + dr, c + dc
                        
                        # Check if neighbor is valid and has the Target_Color
                        if is_valid(nr, nc, rows, cols) and input_np[nr, nc] == target_color:
                            is_adjacent_to_target = True
                            break # Found one, no need to check further
                    if is_adjacent_to_target:
                        break # Exit outer loop too
                
                # Update the output grid based on adjacency check
                if is_adjacent_to_target:
                    output_grid[r, c] = target_color
                else:
                    output_grid[r, c] = background_color
            
            # 5. Else (pixel is Background, Unaffected, or Target):
            # No action needed as output_grid started as a copy.

    # Convert back to list of lists if necessary for ARC standard
    return output_grid.tolist()
```
