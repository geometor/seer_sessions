
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 6 4 4 4 6 5 2 4 4 4 2 5 4 4 3 4 4 5 4 4 4 4 4 5
5 4 4 4 6 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 4 4 4 4 5
5 4 4 6 4 4 5 4 4 2 4 4 5 3 3 3 3 3 5 4 4 4 4 4 5
5 4 6 4 4 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 4 4 4 4 5
5 6 4 4 4 4 5 2 4 4 4 2 5 4 4 3 4 4 5 4 4 4 4 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 6 4 4 4 6 5 2 4 4 4 2 5 4 4 3 4 4 5 2 4 4 4 2 5
5 4 4 4 6 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 2 4 2 4 5
5 4 4 6 4 4 5 4 4 2 4 4 5 3 3 3 3 3 5 4 4 2 3 3 5
5 4 6 4 4 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 2 3 4 4 5
5 6 4 4 4 4 5 2 4 4 4 2 5 4 4 3 4 4 5 2 4 3 4 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 8 8 8 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 8 8 8 8 1
1 4 8 4 8 8 1 8 8 2 8 8 1 3 3 3 3 3 1 8 8 8 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 8 8 8 8 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 8 8 8 8 8 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 2 8 3 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 2 3 8 8 1
1 4 8 4 8 8 1 8 8 2 8 8 1 3 3 3 3 3 1 8 8 2 3 3 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 2 3 8 8 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 2 8 3 8 8 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 7 9 9 9 9 6 9 9 9 4 4 6 9 1 9 1 9 6 9 9 9 9 9 6
6 9 7 9 9 9 6 9 9 9 4 4 6 1 9 1 9 1 6 9 9 9 9 9 6
6 9 9 7 9 9 6 9 9 9 9 9 6 9 1 9 1 9 6 9 9 9 9 9 6
6 9 9 9 7 9 6 4 4 9 9 9 6 1 9 1 9 1 6 9 9 9 9 9 6
6 7 9 9 9 7 6 4 4 9 9 9 6 9 1 9 1 9 6 9 9 9 9 9 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 7 9 9 9 9 6 9 9 9 4 4 6 9 1 9 1 9 6 9 1 9 1 9 6
6 9 7 9 9 9 6 9 9 9 4 4 6 1 9 1 9 1 6 9 9 1 9 1 6
6 9 9 7 9 9 6 9 9 9 9 9 6 9 1 9 1 9 6 9 9 9 1 9 6
6 9 9 9 7 9 6 4 4 9 9 9 6 1 9 1 9 1 6 4 4 9 9 1 6
6 7 9 9 9 7 6 4 4 9 9 9 6 9 1 9 1 9 6 4 4 9 9 9 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


## train_4

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 1 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 0 0 0 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 0 0 0 4
4 1 1 1 1 1 4 0 0 2 0 0 4 3 3 3 3 3 4 0 0 0 0 0 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 0 0 0 4
4 0 0 0 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 0 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 1 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 2 0 0 0 2 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 2 0 2 0 4
4 1 1 1 1 1 4 0 0 2 0 0 4 3 3 3 3 3 4 3 3 2 3 3 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 3 0 0 4
4 0 0 0 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 3 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this ARC task.

**Perception**

1.  **Grid Structure:** The input and output grids maintain the same dimensions and share a common border color that frames the grid and divides the interior into four distinct rectangular regions or panels.
2.  **Regions:** There are consistently four panels arranged horizontally, separated by single columns of the border color. Let's label them Panel 1, Panel 2, Panel 3, and Panel 4 from left to right.
3.  **Background Color:** Within the panels (excluding the border), there's a predominant background color (e.g., yellow in example 1, azure in example 2).
4.  **Patterns:** Each panel (except sometimes Panel 4 in the input) contains a pattern made of non-background colors. These patterns seem to be the key objects being manipulated.
5.  **Transformation Focus:** Comparing input and output grids, Panels 1, 2, and 3 appear unchanged. The transformation exclusively affects Panel 4.
6.  **Panel 4 Transformation:** The pattern in Panel 4 of the output seems to be a composite derived from the patterns in Panel 2 and Panel 3 of the input. Specifically, it looks like the pattern from Panel 2 is overlaid with the pattern from Panel 3. Where the patterns overlap (i.e., both Panel 2 and Panel 3 have a non-background pixel at the same relative position), the color from Panel 3's pattern seems to take precedence in the output Panel 4 (observed in example 4).
7.  **Consistency:** This pattern of copying Panels 1-3 and combining the patterns of Panels 2 and 3 to create Panel 4 holds across all training examples, regardless of the specific colors used for the border, background, or patterns.

**Facts**


```yaml
# Overall Grid Structure
grid:
  properties:
    - dimensions_preserved: True # Input and output grids have the same height and width
    - has_border: True # A consistent color forms a 1-pixel border around the grid and vertical separators
    - border_color: variable # Changes between examples (gray, blue, magenta, yellow)
    - separator_columns: True # Columns of the border color divide the inner area
    - num_regions: 4 # The separators create four distinct rectangular regions/panels

# Regions/Panels (Panel 1, 2, 3, 4 from left-to-right)
regions:
  properties:
    - background_color: consistent_within_task # A single color acts as the background within all panels for a given task (yellow, azure, maroon, white)
    - contain_patterns: True # Panels contain distinct shapes/patterns made of non-background colors
  relationships:
    - panel_1_output: identical_to_input
    - panel_2_output: identical_to_input
    - panel_3_output: identical_to_input
    - panel_4_output: derived_from_input_panels

# Patterns (Non-background pixels within a region)
patterns:
  properties:
    - color: variable
    - shape: variable
  actions:
    - extract_pattern_2: Identify non-background pixels in input Panel 2 relative to Panel 2's origin.
    - extract_pattern_3: Identify non-background pixels in input Panel 3 relative to Panel 3's origin.
    - apply_pattern_2_to_panel_4: Place extracted Pattern 2 onto output Panel 4 (relative to Panel 4's origin) over the background color.
    - apply_pattern_3_to_panel_4: Place extracted Pattern 3 onto output Panel 4 (relative to Panel 4's origin), overwriting any existing pixels (including those from Pattern 2).

# Transformation Summary
transformation:
  description: Copy Panels 1, 2, and 3. Construct Panel 4 by overlaying the pattern from Panel 2 and then the pattern from Panel 3 onto the background color within the bounds of Panel 4.
  panel_4_rule: Output_Panel4 = Background + Pattern2 + Pattern3 (Pattern3 overwrites Pattern2 on overlap)

```


**Natural Language Program**

1.  Create the output grid as an exact copy of the input grid initially.
2.  Identify the border color (the color of the single-pixel frame and vertical separators).
3.  Identify the four rectangular regions separated by the border color columns. Determine their boundaries (top-left and bottom-right corners). Let these be Region 1, Region 2, Region 3, and Region 4 from left to right.
4.  Determine the primary background color found within the regions (ignoring the border color and pattern colors).
5.  Isolate the pattern from Region 2: Create a list of `(relative_row, relative_col, color)` tuples for all pixels within Region 2 whose color is *not* the background color. `relative_row` and `relative_col` are offsets from the top-left corner of Region 2.
6.  Isolate the pattern from Region 3: Create a similar list of `(relative_row, relative_col, color)` tuples for all pixels within Region 3 whose color is *not* the background color.
7.  Get the top-left corner coordinates `(r4_start, c4_start)` of Region 4.
8.  Clear Region 4 in the output grid: Iterate through all cells within the bounds of Region 4 in the output grid and set their color to the background color.
9.  Apply the pattern from Region 2 to Region 4: Iterate through the list created in step 5. For each `(rel_r, rel_c, color)`, set the pixel at `(r4_start + rel_r, c4_start + rel_c)` in the output grid to `color`.
10. Apply the pattern from Region 3 to Region 4: Iterate through the list created in step 6. For each `(rel_r, rel_c, color)`, set the pixel at `(r4_start + rel_r, c4_start + rel_c)` in the output grid to `color`. This step overwrites any pixels previously set by step 9 if the relative coordinates match.
11. The modified grid is the final output.
```python
import numpy as np
from typing import Tuple, List, Dict

"""
Identify the border color and use it to find the vertical separator columns, defining four distinct rectangular regions (panels) within the grid. 
Determine the background color prevalent within these regions.
Keep Panels 1, 2, and 3 unchanged from the input.
For Panel 4 in the output:
1. Determine the boundaries of input Panel 2, Panel 3, and Panel 4.
2. Extract the non-background "pattern" pixels (and their relative coordinates) from input Panel 2.
3. Extract the non-background "pattern" pixels (and their relative coordinates) from input Panel 3.
4. Clear Panel 4 in the output grid by filling it with the background color.
5. Apply the extracted pattern from Panel 2 onto Panel 4 in the output grid, using the relative coordinates.
6. Apply the extracted pattern from Panel 3 onto Panel 4 in the output grid, using the relative coordinates, overwriting any pixels previously placed by the pattern from Panel 2.
"""

def find_regions(grid: np.ndarray) -> Tuple[int, List[Tuple[int, int, int, int]]]:
    """
    Identifies the border color and the boundaries of the four regions.

    Args:
        grid: The input numpy array representing the grid.

    Returns:
        A tuple containing:
            - border_color: The integer color value of the border/separators.
            - regions: A list of four tuples, each representing a region's
                       boundaries as (row_start, row_end, col_start, col_end).
                       row_end and col_end are exclusive.
    """
    height, width = grid.shape
    border_color = grid[0, 0]

    # Find separator columns (columns consisting entirely of the border color)
    separator_cols = [c for c in range(1, width - 1) if np.all(grid[:, c] == border_color)]

    if len(separator_cols) != 3:
        # Fallback or error handling if exactly 3 separators aren't found
        # This might indicate a different grid structure than expected.
        # For now, assume the structure is consistent.
        # Let's try a simple division if separators aren't clear
        # Note: This fallback might not work for all edge cases.
        print(f"Warning: Expected 3 separator columns, found {len(separator_cols)}. Attempting simple division.")
        col_splits = np.linspace(0, width, 5, dtype=int)
        separator_cols = list(col_splits[1:4])
        if len(separator_cols) != 3:
             raise ValueError("Could not reliably determine region separators.")


    regions = []
    row_start, row_end = 1, height - 1
    col_starts = [1, separator_cols[0] + 1, separator_cols[1] + 1, separator_cols[2] + 1]
    col_ends = [separator_cols[0], separator_cols[1], separator_cols[2], width - 1]

    for i in range(4):
        regions.append((row_start, row_end, col_starts[i], col_ends[i]))

    return border_color, regions

def get_background_color(grid: np.ndarray, regions: List[Tuple[int, int, int, int]], border_color: int) -> int:
    """
    Determines the background color within the regions.

    Args:
        grid: The input numpy array.
        regions: List of region boundaries.
        border_color: The color of the border/separators.

    Returns:
        The integer color value of the background.
    """
    # Look inside the first region for a non-border color
    r_start, r_end, c_start, c_end = regions[0]
    for r in range(r_start, r_end):
        for c in range(c_start, c_end):
            if grid[r, c] != border_color:
                return grid[r, c]
    # Fallback if first region is empty or only border color (shouldn't happen based on examples)
    # Check other regions
    for i in range(1, 4):
        r_start, r_end, c_start, c_end = regions[i]
        for r in range(r_start, r_end):
            for c in range(c_start, c_end):
                 if grid[r, c] != border_color:
                     return grid[r, c]
    # If all else fails (e.g., empty grid inside border), return a default (like 0)
    # but this indicates an unexpected input format.
    print("Warning: Could not determine background color reliably.")
    return 0 # Defaulting to white/0

def extract_pattern(grid: np.ndarray, region_bounds: Tuple[int, int, int, int], background_color: int) -> List[Tuple[int, int, int]]:
    """
    Extracts non-background pixels (pattern) from a specified region.

    Args:
        grid: The input numpy array.
        region_bounds: The (row_start, row_end, col_start, col_end) of the region.
        background_color: The background color to ignore.

    Returns:
        A list of tuples: (relative_row, relative_col, color) for pattern pixels.
    """
    r_start, r_end, c_start, c_end = region_bounds
    pattern = []
    for r in range(r_start, r_end):
        for c in range(c_start, c_end):
            color = grid[r, c]
            if color != background_color:
                relative_r = r - r_start
                relative_c = c - c_start
                pattern.append((relative_r, relative_c, color))
    return pattern

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the transformation rule: copies panels 1-3, and constructs panel 4
    by overlaying the patterns from panel 2 and then panel 3 onto the background.
    """
    input_grid_np = np.array(input_grid, dtype=int)
    output_grid_np = np.copy(input_grid_np)

    # 1. Identify border, regions, and background color
    try:
        border_color, regions = find_regions(input_grid_np)
    except ValueError as e:
         print(f"Error finding regions: {e}. Returning input grid.")
         return input_grid # Return original if structure is wrong
    if not regions or len(regions) != 4:
         print(f"Error: Found {len(regions)} regions, expected 4. Returning input grid.")
         return input_grid # Return original if structure is wrong

    background_color = get_background_color(input_grid_np, regions, border_color)

    # 2. Define region boundaries (using 0-based indexing from find_regions)
    region1_bounds = regions[0]
    region2_bounds = regions[1]
    region3_bounds = regions[2]
    region4_bounds = regions[3]

    # 3. Extract patterns from Panel 2 and Panel 3
    pattern2 = extract_pattern(input_grid_np, region2_bounds, background_color)
    pattern3 = extract_pattern(input_grid_np, region3_bounds, background_color)

    # 4. Get Panel 4 details
    r4_start, r4_end, c4_start, c4_end = region4_bounds

    # 5. Clear Panel 4 in the output grid (fill with background)
    output_grid_np[r4_start:r4_end, c4_start:c4_end] = background_color

    # 6. Apply Pattern 2 to Panel 4
    for rel_r, rel_c, color in pattern2:
        # Check bounds to prevent index errors if patterns are unexpectedly large
        if r4_start + rel_r < r4_end and c4_start + rel_c < c4_end:
            output_grid_np[r4_start + rel_r, c4_start + rel_c] = color

    # 7. Apply Pattern 3 to Panel 4 (overwrites Pattern 2 where applicable)
    for rel_r, rel_c, color in pattern3:
         # Check bounds
         if r4_start + rel_r < r4_end and c4_start + rel_c < c4_end:
            output_grid_np[r4_start + rel_r, c4_start + rel_c] = color

    # Convert back to list of lists for the expected output format
    output_grid = output_grid_np.tolist()
    return output_grid
```
