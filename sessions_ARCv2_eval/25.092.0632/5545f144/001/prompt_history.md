
## train_1

**input:**
```
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 1 1 3 1 4 1 1 1 1 1 1
1 1 1 4 1 4 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 4 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 4 1 4 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 4 1 1 4 1 3 1 1 1 4 1 1 4 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 4 1 4
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1
1 4 1 1 1 1 1 1
4 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 3 0 0 3 0 2 0 3 0 0 3 0 2 0 0 0 3 3 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 3 3 3 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 3 3
0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 3 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
3 3 3 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 3 3 3
0 0 0 0 3 0
0 0 0 0 0 0
```


## train_3

**input:**
```
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 6 5 5 6 5 5 5 6 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 6 5 6 5 5 6 5 5 6 5 4 5 5 6 5 6 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 5 5 6 5 5 5 5 5 5 4 5 5 6 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 6 5 6 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
```

**Perception of Task Elements**

1.  **Input/Output Grids:** Each task consists of an input grid and a corresponding output grid.
2.  **Dimensions:** The height of the output grid is always the same as the height of the input grid. The width of the output grid is less than or equal to the width of the input grid.
3.  **Colors:** The grids use a palette of colors (0-9). Each example features a dominant background color (blue in #1, white in #2, gray in #5) and other foreground colors.
4.  **Vertical Lines:** A key feature in the input grids is the presence of one or more solid vertical lines. These lines span the full height of the grid and consist of a single color distinct from the background color. In example #1, the lines are green (3); in #2, they are red (2); in #3, there's one yellow (4) line.
5.  **Transformation:** The transformation appears to be a cropping operation based on the location of the *first* (leftmost) vertical line marker. The output grid consists of all columns from the input grid *before* this marker line. The marker line itself is excluded.
6.  **Marker Line Definition:** A column acts as a marker if all its cells have the same color, and this color is different from the color of the cell at the top-left corner `(0, 0)` of the input grid (which seems to represent the background in these examples).

**YAML Facts**


```yaml
task_description: Crop the input grid horizontally based on the position of the first vertical line marker.

definitions:
  - name: vertical_line_marker
    description: A column in the grid where all cells have the same color, and this color is different from the color of the cell at position (0, 0) in the input grid.

input_grid:
  properties:
    - height: H
    - width: W
    - contains_pixels: Yes
    - contains_vertical_line_markers: Yes, at least one in examples.

output_grid:
  properties:
    - height: H (same as input)
    - width: W_out (where W_out is the column index of the first vertical_line_marker)
    - content: A subgrid of the input grid.

transformation:
  action: Identify the first vertical_line_marker
  details:
    - Iterate through columns from left (index 0) to right.
    - The first column that meets the criteria for vertical_line_marker determines the crop point.
    - Let the index of this first marker column be `C_marker`.
  action: Crop the input grid
  details:
    - Select all rows (0 to H-1).
    - Select columns from index 0 up to (but not including) `C_marker`.
    - The resulting subgrid is the output.

relationship:
  - The output grid is the portion of the input grid to the left of the first identified vertical_line_marker.
  - The height remains unchanged.
```


**Natural Language Program**

1.  Accept the input grid.
2.  Determine the height (H) and width (W) of the input grid.
3.  Identify the color of the top-left pixel (at row 0, column 0), call it `background_color_ref`.
4.  Initialize a variable `marker_column_index` to -1 (or some indicator that no marker has been found yet).
5.  Iterate through each column index `c` from 0 to W-1:
    a.  Check if the column `c` is a vertical line marker:
        i.  Get the color of the first pixel in the column, `column_color = grid[0][c]`.
        ii. If `column_color` is the same as `background_color_ref`, this column cannot be a marker; continue to the next column `c+1`.
        iii. Assume the column is a marker (`is_marker = True`).
        iv. Iterate through each row index `r` from 1 to H-1:
            1.  If the color `grid[r][c]` is different from `column_color`, set `is_marker = False` and break this inner loop (checking rows).
        v.  If `is_marker` is still `True` after checking all rows, then column `c` is the first vertical line marker found. Set `marker_column_index = c` and break the outer loop (checking columns).
6.  If no marker column was found (`marker_column_index` is still -1), handle this case (e.g., return the original grid or an empty grid, though examples suggest a marker always exists). Based on the examples, assume `marker_column_index` will be found and hold a value between 0 and W-1.
7.  Create the output grid by taking a slice of the input grid: select all rows (from 0 to H-1) and columns from 0 up to (but not including) `marker_column_index`.
8.  Return the created output grid.
