{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify distinct colored shapes (frames) separated by a background/noise color. \nGroup these frames into two equal sets based on spatial arrangement (e.g., top half vs. bottom half after sorting). \nDesignate one set as 'Targets' and the other as 'Sources'. The Target set is typically the one whose frames contain pixels of the noise color within their bounding boxes.\nPair Target frames with Source frames based on their relative order within their respective groups (e.g., first Target with first Source, etc.). \nFor each Target frame, create a modified version by taking its bounding box area from the input grid and replacing only the pixels matching the noise color with the solid color of its paired Source frame. \nAssemble these modified Target frames into the output grid, preserving their original relative spatial arrangement.\n\"\"\"\n\n# --- Helper Function: Find Objects ---\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n    Uses Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'coords' (set of (r, c) tuples),\n              'bbox' (min_r, max_r, min_c, max_c), and 'size'. Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n        \n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if len(coords) > 0:\n                    objects.append({\n                        'color': color,\n                        'coords': coords,\n                        'bbox': (min_r, max_r, min_c, max_c),\n                        'size': len(coords)\n                    })\n    return objects\n\n# --- Helper Function: Determine Noise Color ---\ndef determine_noise_color(grid, objects):\n    \"\"\"\n    Determines the noise/background color using heuristics.\n    Primary heuristic: The color most frequently appearing *inside* the bounding boxes \n                      of other major objects, but not part of the object itself.\n    Fallback heuristic: The most frequent color overall, excluding the color of the largest object.\n\n    Args:\n        grid (np.array): The input grid.\n        objects (list): List of objects found by find_objects.\n\n    Returns:\n        int: The determined noise color. Returns -1 if unable to determine (e.g., empty grid).\n    \"\"\"\n    if grid.size == 0 or not objects:\n        return -1 \n\n    counts_inside_others = {}\n    # Consider objects larger than a small threshold to avoid noise pixels forming tiny 'objects'\n    significant_objects = [obj for obj in objects if obj['size'] > 2] \n    if not significant_objects: # If only tiny objects, fallback might be needed\n        significant_objects = objects # Use all if no large ones\n\n    for obj in significant_objects:\n        min_r, max_r, min_c, max_c = obj['bbox']\n        obj_color = obj['color']\n        # Check pixels *within* bbox but *not* part of the object itself\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if (r, c) not in obj['coords']:\n                    pixel_color = grid[r, c]\n                    # Ensure this 'inside' pixel isn't part of another significant object\n                    is_part_of_other_sig_obj = False\n                    for other_obj in significant_objects:\n                        if other_obj != obj and (r, c) in other_obj['coords']:\n                            is_part_of_other_sig_obj = True\n                            break\n                    if not is_part_of_other_sig_obj:\n                         counts_inside_others[pixel_color] = counts_inside_others.get(pixel_color, 0) + 1\n\n    if counts_inside_others:\n        # The color most frequently found *inside* other objects is likely the noise\n        noise_color = max(counts_inside_others, key=counts_inside_others.get)\n        # print(f\"Noise color identified as {noise_color} via 'inside' heuristic.\")\n        return noise_color\n    else:\n        # Fallback: most frequent color overall, trying to exclude the largest object's color\n        colors, counts = np.unique(grid, return_counts=True)\n        \n        largest_obj_color = -1\n        if objects:\n             # Sort by size to find the largest object\n             sorted_objects = sorted(objects, key=lambda o: o['size'], reverse=True)\n             if sorted_objects:\n                 largest_obj_color = sorted_objects[0]['color']\n        \n        sorted_indices = np.argsort(counts)[::-1]\n        \n        # Iterate through frequencies, pick the first one that isn't the largest object's color\n        for idx in sorted_indices:\n            potential_noise_color = colors[idx]\n            if potential_noise_color != largest_obj_color:\n                # print(f\"Noise color identified as {potential_noise_color} via fallback heuristic (most frequent excluding largest).\")\n                return potential_noise_color\n        \n        # If all colors belong to the largest object or only one color exists\n        if len(sorted_indices) > 0:\n            # print(f\"Noise color defaulted to most frequent overall: {colors[sorted_indices[0]]}.\")\n            return colors[sorted_indices[0]] # Return most frequent if exclusion failed\n        else:\n            return -1 # Should not happen if grid is not empty\n\n\n# --- Main Transformation Function ---\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the specified rules.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return []\n\n    # 1. Find all distinct objects\n    all_objects = find_objects(grid)\n    if not all_objects: \n        return grid.tolist() # Return original if no objects found\n\n    # 2. Determine the noise color\n    noise_color = determine_noise_color(grid, all_objects)\n    if noise_color == -1: # If noise color couldn't be determined\n         return grid.tolist() \n\n    # 3. Filter out noise objects and get primary shapes\n    shapes = [obj for obj in all_objects if obj['color'] != noise_color]\n    if not shapes or len(shapes) % 2 != 0: # Need an even number of shapes for pairing\n        # print(f\"Warning: Found {len(shapes)} non-noise shapes. Cannot form pairs.\")\n        return grid.tolist() \n\n    # 4. Group shapes into two equal sets based on spatial order\n    shapes.sort(key=lambda o: (o['bbox'][0], o['bbox'][2])) # Sort primarily by row, then column\n    mid_point = len(shapes) // 2\n    group1 = shapes[:mid_point]\n    group2 = shapes[mid_point:]\n\n    # 5. Identify Target group (likely contains noise within bounding boxes)\n    #    Check if any shape in group1 has noise inside its bbox (but not part of itself)\n    group1_is_target = False\n    for obj in group1:\n        min_r, max_r, min_c, max_c = obj['bbox']\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if grid[r, c] == noise_color and (r, c) not in obj['coords']:\n                    # Check if this noise pixel belongs to another non-noise shape in the grid\n                    part_of_other_shape = False\n                    for other_shape in shapes:\n                         if other_shape != obj and (r,c) in other_shape['coords']:\n                             part_of_other_shape = True\n                             break\n                    if not part_of_other_shape:\n                         group1_is_target = True\n                         break # Found noise belonging to the background within this bbox\n            if group1_is_target: break\n    \n    if group1_is_target:\n        targets = group1\n        sources = group2\n    else:\n        # Assume group2 must be the target if group1 isn't (based on problem structure)\n        # Could add a similar check for group2 for robustness, but let's assume complementarity\n        targets = group2\n        sources = group1\n        \n    # Ensure sorting within groups remains consistent for pairing\n    targets.sort(key=lambda o: (o['bbox'][0], o['bbox'][2]))\n    sources.sort(key=lambda o: (o['bbox'][0], o['bbox'][2]))\n\n    # 6. Modify Target Frames by replacing noise with corresponding source color\n    modified_targets_data = []\n    for i in range(len(targets)):\n        target = targets[i]\n        # Handle potential index error if source group is smaller (shouldn't happen with checks)\n        if i >= len(sources): \n             # print(f\"Warning: Mismatch in target/source count during pairing.\")\n             continue # Skip this target if no corresponding source\n        source = sources[i]\n        \n        min_r, max_r, min_c, max_c = target['bbox']\n        filler_color = source['color']\n\n        # Extract subgrid based on target's bounding box from the *original* grid\n        subgrid_original = grid[min_r:max_r+1, min_c:max_c+1]\n        modified_subgrid = subgrid_original.copy()\n\n        # Replace ONLY noise pixels within this subgrid copy\n        noise_mask = (modified_subgrid == noise_color)\n        modified_subgrid[noise_mask] = filler_color\n\n        modified_targets_data.append({\n            'bbox': target['bbox'], # Store original bbox for layout calculation\n            'subgrid': modified_subgrid\n        })\n\n    # 7. Assemble Output Grid using modified target subgrids\n    if not modified_targets_data:\n        # print(\"Warning: No modified target data generated.\")\n        return grid.tolist() # Return original if modification failed\n\n    # Calculate relative positions and final grid size based on target bboxes\n    min_target_r = min(t['bbox'][0] for t in modified_targets_data)\n    min_target_c = min(t['bbox'][2] for t in modified_targets_data)\n\n    max_output_r = 0\n    max_output_c = 0\n    output_layout = []\n\n    for data in modified_targets_data:\n        bbox = data['bbox']\n        subgrid = data['subgrid']\n        h, w = subgrid.shape\n        # Position relative to the top-leftmost target's origin\n        rel_r = bbox[0] - min_target_r\n        rel_c = bbox[2] - min_target_c\n\n        output_layout.append({\n            'rel_r': rel_r,\n            'rel_c': rel_c,\n            'subgrid': subgrid,\n            'h': h,\n            'w': w\n        })\n        # Update max dimensions needed for the output grid\n        max_output_r = max(max_output_r, rel_r + h)\n        max_output_c = max(max_output_c, rel_c + w)\n\n    # Create and populate the output grid. Initialize with a neutral color (e.g., 0=white)\n    # This assumes 0 is not a critical part of the final patterns themselves.\n    # A safer but more complex init might involve analyzing output colors.\n    output_grid = np.zeros((max_output_r, max_output_c), dtype=int) \n\n    for layout_info in output_layout:\n        r, c = layout_info['rel_r'], layout_info['rel_c']\n        h, w = layout_info['h'], layout_info['w']\n        subgrid = layout_info['subgrid']\n        # Place the modified subgrid onto the output grid\n        output_grid[r:r+h, c:c+w] = subgrid\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19370,
    "candidates_token_count": 3182,
    "total_token_count": 22552,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.75387,
  "retries": 1
}