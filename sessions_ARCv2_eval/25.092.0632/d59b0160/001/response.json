{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a specific anchor object (a 1x4 horizontal line of green (3) pixels, typically at row 3, cols 0-3). \nFinds all other distinct objects (contiguous non-background pixels) in the input grid. \nDetermines which objects are adjacent (sharing a side or corner) to the anchor object.\nCreates an output grid by copying the input grid. \nRemoves objects (replaces their pixels with the background color orange (7)) if they are *not* adjacent to the anchor object. \nPreserves the anchor object and all objects adjacent to it.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore when finding objects.\n\n    Returns:\n        list: A list where each element is a tuple containing:\n              - color (int): The color of the object.\n              - coords (set): A set of (row, col) tuples representing the object's pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               (nr, nc) not in visited and \\\n                               grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                obj_coords.add((nr, nc))\n                                q.append((nr, nc))\n                objects.append({'color': color, 'coords': obj_coords})\n    return objects\n\ndef get_neighbor_coords(coords, max_row, max_col):\n    \"\"\"\n    Gets all unique neighboring coordinates (including diagonals) for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n        max_row (int): Maximum row index.\n        max_col (int): Maximum column index.\n\n    Returns:\n        set: A set of unique (row, col) tuples representing neighbors.\n    \"\"\"\n    neighbors = set()\n    for r, c in coords:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < max_row and 0 <= nc < max_col:\n                    neighbors.add((nr, nc))\n    # Remove the original coordinates themselves if they ended up in neighbors\n    neighbors = neighbors - coords\n    return neighbors\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on object adjacency to a specific anchor object.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: The transformed 2D output grid.\n    \"\"\"\n    # Constants\n    background_color = 7\n    anchor_color = 3\n    rows, cols = input_grid.shape\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Find all objects in the grid\n    all_objects = find_objects(input_grid, background_color)\n\n    # Identify the anchor object(s) - assuming there might be multiple parts or instances\n    anchor_objects = [obj for obj in all_objects if obj['color'] == anchor_color]\n    \n    # Combine all coordinates of the anchor object parts into one set\n    anchor_coords = set()\n    for obj in anchor_objects:\n        anchor_coords.update(obj['coords'])\n        \n    # If no anchor object found, return the original grid (or handle as error)\n    if not anchor_coords:\n        # Based on examples, anchor is always present. If not, returning input might be safest.\n        return output_grid \n\n    # Find the adjacency zone around the anchor object\n    # This includes all pixels directly neighboring any pixel of the anchor object\n    anchor_adjacency_zone = get_neighbor_coords(anchor_coords, rows, cols)\n    # Also include the anchor coordinates themselves in the 'keep' zone\n    keep_zone = anchor_coords.union(anchor_adjacency_zone)\n\n\n    # Identify objects to keep and remove\n    objects_to_remove = []\n    for obj in all_objects:\n        # Skip the anchor object itself\n        if obj['color'] == anchor_color:\n            continue\n\n        # Check if any part of the object touches the adjacency zone OR is part of the anchor\n        is_adjacent = False\n        for coord in obj['coords']:\n            if coord in keep_zone: \n                is_adjacent = True\n                break\n        \n        if not is_adjacent:\n            objects_to_remove.append(obj)\n\n    # Modify the output grid by removing non-adjacent objects\n    for obj in objects_to_remove:\n        for r, c in obj['coords']:\n            output_grid[r, c] = background_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4802,
    "candidates_token_count": 1353,
    "total_token_count": 6155,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.758617,
  "retries": 1
}