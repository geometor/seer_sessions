{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the background color (most frequent).\nIdentify a 'template' object located on the bottom row: determine its color (template_color) and shape (template_shape).\nIdentify the 'main' object color (most frequent non-background, non-template color).\nDefine a 'replacement' color based on the template color (yellow=4 maps to green=3).\nInitialize the output grid as a copy of the input.\nIterate through all possible locations in the grid that could contain the template_shape:\n1. If an area matches the template_shape and consists entirely of the main_color, replace that area in the output with the replacement_color.\n2. If an area matches the template_shape and consists entirely of the template_color (i.e., it's the original template instance), replace that area in the output with the replacement_color.\n3. If an area matches the template_shape, consists entirely of the background_color, AND is edge-adjacent to any pixel of the main_color in the input grid, fill that area in the output with the template_color.\nPixels not modified by these rules retain their original color from the input grid.\n\"\"\"\n\ndef find_objects(grid, target_color):\n    \"\"\"Finds connected components of a specific color.\"\"\"\n    if grid.size == 0:\n        return []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                bounding_box = (min_r, min_c, max_r, max_c)\n                objects.append({'pixels': obj_pixels, 'bbox': bounding_box, 'color': target_color})\n    return objects\n\ndef get_shape_from_bbox(bbox):\n    \"\"\"Calculates height and width from bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return (max_r - min_r + 1, max_c - min_c + 1)\n\ndef check_area_color(grid, r, c, shape_h, shape_w, color):\n    \"\"\"Checks if the specified area in the grid is uniformly of the given color.\"\"\"\n    height, width = grid.shape\n    if r + shape_h > height or c + shape_w > width:\n        return False # Shape out of bounds\n    return np.all(grid[r:r+shape_h, c:c+shape_w] == color)\n\ndef check_adjacency(grid, r, c, shape_h, shape_w, adjacent_color):\n    \"\"\"Checks if any pixel within the r,c area is edge-adjacent to adjacent_color outside the area.\"\"\"\n    height, width = grid.shape\n    for i in range(shape_h):\n        for j in range(shape_w):\n            row, col = r + i, c + j\n            # Check neighbors (N, S, E, W)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = row + dr, col + dc\n                # Check if neighbor is within grid bounds\n                if 0 <= nr < height and 0 <= nc < width:\n                    # Check if neighbor is OUTSIDE the shape area\n                    is_outside = not (0 <= nr - r < shape_h and 0 <= nc - c < shape_w)\n                    if is_outside and grid[nr, nc] == adjacent_color:\n                        return True\n    return False\n\ndef fill_area(grid, r, c, shape_h, shape_w, color):\n    \"\"\"Fills the specified area in the grid with the given color.\"\"\"\n    grid[r:r+shape_h, c:c+shape_w] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on identifying a template object\n    on the bottom row and replacing/filling based on its shape and color relationships.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    output_array = np.copy(input_array)\n\n    # 1. Identify Background Color\n    colors, counts = np.unique(input_array, return_counts=True)\n    if not colors.size: return [] # Handle empty grid case\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Identify Template Object\n    template_object = None\n    template_color = -1\n    template_shape = None\n    template_bbox = None\n    \n    # Find non-background objects touching the bottom row\n    potential_template_colors = [c for c in colors if c != background_color]\n    found_template = False\n    for color in potential_template_colors:\n        objects = find_objects(input_array, color)\n        for obj in objects:\n            min_r, min_c, max_r, max_c = obj['bbox']\n            # Check if the object is entirely on the bottom row\n            # Or more robustly, check if *any* part is on the bottom row and it's unique there\n            # Let's assume the unique non-background object fully contained in the bottom row\n            is_on_bottom_row = True\n            for r_pix, c_pix in obj['pixels']:\n                if r_pix != height - 1:\n                    is_on_bottom_row = False\n                    break\n            \n            if is_on_bottom_row:\n                 # Simple check: find first object completely on bottom row\n                 # More complex logic might be needed if multiple objects fit this\n                 template_object = obj\n                 template_color = color\n                 template_bbox = obj['bbox']\n                 template_shape = get_shape_from_bbox(template_bbox)\n                 found_template = True\n                 break # Assume first one found is the template\n        if found_template:\n            break\n\n    if not found_template:\n        # Fallback or error handling if no template found\n        # Maybe look for the smallest non-background object? Or unique color?\n        # For now, assume template is always found as per examples\n        # A reasonable fallback might be to return input if structure isn't matched\n        return input_grid \n\n    # 3. Identify Main Object Color\n    main_color_candidates = {}\n    for r in range(height):\n        for c in range(width):\n            color = input_array[r, c]\n            if color != background_color and color != template_color:\n                main_color_candidates[color] = main_color_candidates.get(color, 0) + 1\n    \n    if not main_color_candidates:\n         # No main color found (maybe only background and template exist)\n         # Or maybe the template IS the main color in some cases?\n         # Let's assume a main color distinct from template exists based on examples.\n         # Return input if no clear main color.\n         return input_grid \n\n    main_color = max(main_color_candidates, key=main_color_candidates.get)\n\n\n    # 4. Determine Replacement Color (Specific mapping: yellow -> green)\n    replacement_color = -1\n    if template_color == 4: # Yellow\n        replacement_color = 3 # Green\n    else:\n        # Define behavior for other template colors if needed\n        # Default to template color itself? Or an error?\n        # Given examples, let's stick to the 4->3 mapping.\n        # If template isn't yellow, maybe no replacement happens.\n        # Let's assume the rule only applies if template is yellow.\n        if template_color != 4:\n             return input_grid # Or apply different logic\n\n    # 5. Iterate and Apply Rules\n    template_h, template_w = template_shape\n    \n    # Keep track of areas modified by rules 1, 2, 3 to avoid overwriting them later\n    # when copying non-modified main object parts. However, the current logic\n    # initializes output as a copy, so we only overwrite based on rules.\n\n    for r in range(height - template_h + 1):\n        for c in range(width - template_w + 1):\n            # Rule 1: Main Object Match -> Replace with replacement_color\n            if check_area_color(input_array, r, c, template_h, template_w, main_color):\n                fill_area(output_array, r, c, template_h, template_w, replacement_color)\n\n            # Rule 2: Template Object Match -> Replace with replacement_color\n            # This specifically targets the original template instance(s)\n            elif check_area_color(input_array, r, c, template_h, template_w, template_color):\n                 fill_area(output_array, r, c, template_h, template_w, replacement_color)\n\n            # Rule 3: Adjacent Background Match -> Fill with template_color\n            elif check_area_color(input_array, r, c, template_h, template_w, background_color):\n                if check_adjacency(input_array, r, c, template_h, template_w, main_color):\n                    fill_area(output_array, r, c, template_h, template_w, template_color) # Fill with original template color\n\n    # No explicit step 8 needed as we started with a copy and selectively overwrote.\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7885,
    "candidates_token_count": 2468,
    "total_token_count": 10353,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.790792,
  "retries": 1
}