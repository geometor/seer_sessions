{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nIdentifies the background color (most frequent color) in the input grid.\nFinds all distinct connected objects composed of non-background colors.\nAnalyzes these objects to find a unique 'anchor' color that appears exactly once in precisely two different objects.\nIdentifies these two objects as the 'base' and 'overlay' objects based on the position of their anchor pixels (top-to-bottom, left-to-right).\nCalculates the coordinate offset needed to align the overlay object's anchor pixel onto the base object's anchor pixel.\nDetermines the minimal bounding box required to contain the composite shape formed by placing the base object and then overlaying the offset overlay object.\nCreates an output grid of the calculated bounding box size, initialized with the background color.\nDraws the base object onto the output grid relative to the bounding box origin.\nDraws the overlay object onto the output grid, shifted by the calculated offset and relative to the bounding box origin, overwriting any existing pixels.\nReturns the resulting output grid.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"Finds connected components of non-background colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    color = grid[row, col]\n                    obj_pixels.append((row, col, color))\n                    \n                    # Explore 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] != background_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                if obj_pixels:\n                    objects.append(obj_pixels)\n    return objects\n\ndef find_anchor_color_and_objects(objects):\n    \"\"\"\n    Finds the anchor color (appears exactly once in exactly two objects) \n    and returns the color and the two objects.\n    \"\"\"\n    color_locations = defaultdict(list) # color -> list of (obj_index, count, anchor_coord)\n    \n    for i, obj in enumerate(objects):\n        counts = Counter(pixel[2] for pixel in obj)\n        for color, count in counts.items():\n            anchor_coord = None\n            if count == 1:\n                 # Find the coordinate of this unique color instance within the object\n                 for r, c,clr in obj:\n                     if clr == color:\n                         anchor_coord = (r,c)\n                         break\n            color_locations[color].append({'obj_index': i, 'count': count, 'anchor_coord': anchor_coord})\n\n    anchor_color = -1\n    selected_obj_indices = []\n    anchor_coords = []\n\n    for color, locations in color_locations.items():\n        objects_with_one_instance = [loc for loc in locations if loc['count'] == 1]\n        if len(objects_with_one_instance) == 2:\n            anchor_color = color\n            selected_obj_indices = [loc['obj_index'] for loc in objects_with_one_instance]\n            # Ensure anchor coordinates are extracted in the correct order corresponding to obj_indices\n            anchor_coords = [loc['anchor_coord'] for loc in objects_with_one_instance]\n            break\n            \n    if anchor_color == -1:\n        return None, None, None # Should not happen based on examples\n\n    obj1 = objects[selected_obj_indices[0]]\n    obj2 = objects[selected_obj_indices[1]]\n    anchor1 = anchor_coords[0]\n    anchor2 = anchor_coords[1]\n\n    # Determine base and overlay based on anchor coordinates (row first, then col)\n    if anchor1[0] < anchor2[0] or (anchor1[0] == anchor2[0] and anchor1[1] < anchor2[1]):\n        base_obj = obj1\n        overlay_obj = obj2\n        base_anchor_coord = anchor1\n        overlay_anchor_coord = anchor2\n    else:\n        base_obj = obj2\n        overlay_obj = obj1\n        base_anchor_coord = anchor2\n        overlay_anchor_coord = anchor1\n        \n    return anchor_color, base_obj, overlay_obj, base_anchor_coord, overlay_anchor_coord\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object overlay transformation based on anchor pixels.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify the background color\n    colors, counts = np.unique(grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find all distinct objects\n    objects = find_objects(grid, background_color)\n    if not objects:\n        return grid.tolist() # Or handle error\n\n    # 3. Find the anchor color and the two selected objects\n    anchor_result = find_anchor_color_and_objects(objects)\n    if not anchor_result or anchor_result[0] is None:\n         # Fallback or error handling if anchor logic doesn't apply\n         print(\"Warning: Could not find unique anchor color/objects.\")\n         # As a simple fallback, return the input or an empty grid maybe?\n         # For now, let's assume the examples guarantee finding anchors.\n         return input_grid # Return original if pattern not found\n\n    anchor_color, base_obj, overlay_obj, base_anchor_coord, overlay_anchor_coord = anchor_result\n\n    # 4. Calculate the alignment offset\n    offset_row = base_anchor_coord[0] - overlay_anchor_coord[0]\n    offset_col = base_anchor_coord[1] - overlay_anchor_coord[1]\n\n    # 5. Determine the combined bounding box\n    all_pixels_coords = []\n    # Add base object coords\n    for r, c, _ in base_obj:\n        all_pixels_coords.append((r, c))\n    # Add overlay object coords shifted by offset\n    for r, c, _ in overlay_obj:\n        all_pixels_coords.append((r + offset_row, c + offset_col))\n\n    if not all_pixels_coords:\n        return [[]] # Handle empty object case\n\n    min_r = min(r for r, c in all_pixels_coords)\n    max_r = max(r for r, c in all_pixels_coords)\n    min_c = min(c for r, c in all_pixels_coords)\n    max_c = max(c for r, c in all_pixels_coords)\n\n    # 6. Create the output grid\n    output_height = max_r - min_r + 1\n    output_width = max_c - min_c + 1\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    # 7. Draw the base object\n    for r, c, color in base_obj:\n        out_r = r - min_r\n        out_c = c - min_c\n        output_grid[out_r, out_c] = color\n\n    # 8. Draw the overlay object (shifted and overwriting)\n    for r, c, color in overlay_obj:\n        shifted_r = r + offset_row\n        shifted_c = c + offset_col\n        out_r = shifted_r - min_r\n        out_c = shifted_c - min_c\n        # Ensure the pixel is within the calculated bounds (should be, but safety check)\n        if 0 <= out_r < output_height and 0 <= out_c < output_width:\n             output_grid[out_r, out_c] = color\n        else:\n             # This case might indicate an issue in bounding box calculation if it occurs\n             print(f\"Warning: Overlay pixel ({shifted_r}, {shifted_c}) -> ({out_r}, {out_c}) outside output bounds ({output_height}x{output_width})\")\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 7997,
            "end_index": 8332,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5364,
    "candidates_token_count": 2031,
    "total_token_count": 7395,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.419609,
  "retries": 1
}