
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 9 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 1 8 8 2 8 2 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 4 1 1 1 2 2 2 3 2 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 1 8 8 2 8 2 3 3 3 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 9 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 8 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 1 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 1 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 1 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 8 9 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 2 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
6 8 9 8 8 8 8 8 8 8 8 8
6 1 1 1 8 8 2 8 2 3 3 3
6 1 4 1 1 1 2 2 2 3 2 3
6 1 1 1 8 8 2 8 2 3 3 3
6 8 9 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 4 4 4
4 4 4 4 4 4 4 4 4 4 8 1 1 1 3 3 1 4 4 4
4 1 1 1 4 4 4 4 4 4 8 4 4 1 4 4 1 4 4 4
4 1 2 1 4 4 4 4 4 4 8 1 1 1 3 3 1 4 4 4
4 1 1 1 4 4 4 4 4 4 4 4 4 1 1 1 1 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 1 1 1 4 4 4 4 4 4 4 5 3 5 4 4
4 4 4 4 4 1 2 1 3 3 3 3 3 3 3 3 5 3 4 4
4 4 4 4 4 1 1 1 4 4 4 4 4 4 4 5 3 5 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 6 6 6 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 5 3 5 6 6 8 4 4 4 4 4 4 4 4 4 4 4 4
4 4 3 5 3 6 6 8 4 4 4 4 4 4 4 4 4 4 4 4
4 4 5 3 5 6 6 8 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 6 6 6 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 6 6 6 4 4 4 4 1 1 1 1
1 1 1 4 4 4 4 4 4 4 5 3 5 6 6 8 1 1 1 3 3 1
1 2 1 3 3 3 3 3 3 3 3 5 3 6 6 8 4 4 1 4 4 1
1 1 1 4 4 4 4 4 4 4 5 3 5 6 6 8 1 1 1 3 3 1
4 4 4 4 4 4 4 4 4 4 4 6 6 6 4 4 4 4 1 1 1 1
```

Okay, let's analyze the provided examples to understand the transformation.

**Perception**

1.  **Input Structure:** Each input grid consists of a large, uniform background color (azure `8` in train\_1, yellow `4` in train\_2) with several smaller, distinct objects embedded within it. These objects are composed of contiguous pixels of various non-background colors.
2.  **Output Structure:** The output grid is significantly smaller than the input grid and appears to be a composite derived from specific objects found in the input. The background color of the output matches the background color of the input.
3.  **Key Transformation Elements:**
    *   **Object Selection:** Not all objects from the input are used in the output. A specific selection criterion seems to be applied.
    *   **Anchor Points:** In both examples, the selected objects share a unique characteristic: they each contain exactly one pixel of a specific "anchor" color (`maroon` (9) in train\_1, `azure` (8) in train\_2). This anchor color appears only in these two selected objects in the entire input grid.
    *   **Composition/Overlay:** The two selected objects are combined. One object appears to act as a "base," and the other is "overlaid" onto it. The alignment for this overlay is based on the relative positions of their respective anchor pixels. The overlaid object's pixels replace the base object's pixels and background pixels at the corresponding aligned locations.
    *   **Output Bounding Box:** The output grid represents the minimal bounding box containing the combined/overlaid shape, including any necessary background pixels that fall within this box after the overlay operation.

**Facts**


```yaml
task_description: Compose two specific objects from the input grid based on aligning unique anchor pixels.

definitions:
  background_color: The most frequent color in the input grid.
  object: A contiguous group of pixels with non-background colors.
  anchor_color: A color C such that exactly two distinct objects in the input grid each contain exactly one pixel of color C.
  anchor_pixel: The single pixel of the anchor_color within an object.
  selected_objects: The two objects containing the anchor_pixel.
  base_object: The selected_object whose anchor_pixel appears first in the grid (scan top-to-bottom, then left-to-right).
  overlay_object: The selected_object whose anchor_pixel appears second in the grid.

transformation:
  - step: Identify the background_color.
  - step: Find all distinct objects in the input grid.
  - step: Determine the anchor_color by checking color frequencies within objects.
  - step: Identify the two selected_objects containing the anchor_pixel.
  - step: Identify the base_object and the overlay_object based on the position of their anchor_pixels.
  - step: Determine the coordinates of the anchor_pixel within the base_object (relative_anchor_base) and the overlay_object (relative_anchor_overlay).
  - step: Determine the absolute coordinates of the anchor_pixels in the input grid (absolute_anchor_base, absolute_anchor_overlay).
  - step: Calculate the alignment offset needed to place the overlay_object's anchor onto the base_object's anchor. offset = absolute_anchor_base - absolute_anchor_overlay.
  - step: Determine the bounding box required to contain both the base_object and the overlay_object when aligned by their anchors.
  - step: Create an output grid of the calculated bounding box size, initialized with the background_color.
  - step: Draw the base_object onto the output grid at its relative position.
  - step: Draw the overlay_object onto the output grid, shifted by the calculated offset. Pixels from the overlay_object overwrite any pixels already present at those locations in the output grid.
  - step: The final output grid is the result of these drawing operations.

example_1:
  background_color: 8 (azure)
  anchor_color: 9 (maroon)
  selected_objects_positions: # Top-left corner of bounding boxes
    - Object 1 (Base): row=6, col=6
    - Object 2 (Overlay): row=11, col=20
  absolute_anchor_base: (6, 6)
  absolute_anchor_overlay: (11, 21)
  output_size: 5x12

example_2:
  background_color: 4 (yellow)
  anchor_color: 8 (azure)
  selected_objects_positions: # Top-left corner of bounding boxes
    - Object 1 (Base): row=2, col=10
    - Object 2 (Overlay): row=24, col=2
  absolute_anchor_base: (2, 10) # Actually (2+1, 10+0) = (3, 10) within its 4x7 box? Check needed. Let's use absolute grid coords. Input anchor coords: (3,10) and (25,7)
  absolute_anchor_base (revised): (3, 10)
  absolute_anchor_overlay (revised): (25, 7)
  output_size: 5x21
```


*(Self-correction during YAML generation: Realized using absolute coordinates for anchors might be simpler for calculating offset and final bounds).*

**Natural Language Program**

1.  Identify the background color by finding the most frequent pixel value in the input grid.
2.  Segment the input grid into distinct objects, where each object is a connected component of non-background colored pixels.
3.  Analyze the color composition of each object. Find the unique color (`anchor_color`) that appears exactly once in precisely two different objects.
4.  Identify these two objects as the `selected_objects`.
5.  Locate the coordinates of the single `anchor_pixel` within each of the `selected_objects`.
6.  Determine which `selected_object` is the `base_object` and which is the `overlay_object`. The `base_object` is the one whose `anchor_pixel` has the smaller row index, or the smaller column index if the row indices are equal.
7.  Calculate the coordinate offset required to align the `overlay_object`'s `anchor_pixel` with the `base_object`'s `anchor_pixel`. This is `offset = anchor_coord_base - anchor_coord_overlay`.
8.  Construct the composite shape: Imagine placing the `base_object` on an infinite grid. Then, place the `overlay_object` onto the same grid, shifted by the calculated `offset`. Pixels from the `overlay_object` overwrite any pixels (from the `base_object` or the background) at the overlapping coordinates.
9.  Determine the minimum bounding box that encloses all non-background pixels of this composite shape.
10. Create the output grid with the dimensions of this bounding box.
11. Fill the output grid by copying the pixels (including the background color within the composite shape's structure) from the relevant portion of the conceptual composite grid created in step 8.
```python
import numpy as np
from collections import Counter, defaultdict

"""
Identifies the background color (most frequent color) in the input grid.
Finds all distinct connected objects composed of non-background colors.
Analyzes these objects to find a unique 'anchor' color that appears exactly once in precisely two different objects.
Identifies these two objects as the 'base' and 'overlay' objects based on the position of their anchor pixels (top-to-bottom, left-to-right).
Calculates the coordinate offset needed to align the overlay object's anchor pixel onto the base object's anchor pixel.
Determines the minimal bounding box required to contain the composite shape formed by placing the base object and then overlaying the offset overlay object.
Creates an output grid of the calculated bounding box size, initialized with the background color.
Draws the base object onto the output grid relative to the bounding box origin.
Draws the overlay object onto the output grid, shifted by the calculated offset and relative to the bounding box origin, overwriting any existing pixels.
Returns the resulting output grid.
"""

def find_objects(grid, background_color):
    """Finds connected components of non-background colors."""
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != background_color and not visited[r, c]:
                obj_pixels = []
                q = [(r, c)]
                visited[r, c] = True
                while q:
                    row, col = q.pop(0)
                    color = grid[row, col]
                    obj_pixels.append((row, col, color))
                    
                    # Explore 8 neighbors
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue
                            nr, nc = row + dr, col + dc
                            if 0 <= nr < rows and 0 <= nc < cols and \
                               grid[nr, nc] != background_color and not visited[nr, nc]:
                                visited[nr, nc] = True
                                q.append((nr, nc))
                if obj_pixels:
                    objects.append(obj_pixels)
    return objects

def find_anchor_color_and_objects(objects):
    """
    Finds the anchor color (appears exactly once in exactly two objects) 
    and returns the color and the two objects.
    """
    color_locations = defaultdict(list) # color -> list of (obj_index, count, anchor_coord)
    
    for i, obj in enumerate(objects):
        counts = Counter(pixel[2] for pixel in obj)
        for color, count in counts.items():
            anchor_coord = None
            if count == 1:
                 # Find the coordinate of this unique color instance within the object
                 for r, c,clr in obj:
                     if clr == color:
                         anchor_coord = (r,c)
                         break
            color_locations[color].append({'obj_index': i, 'count': count, 'anchor_coord': anchor_coord})

    anchor_color = -1
    selected_obj_indices = []
    anchor_coords = []

    for color, locations in color_locations.items():
        objects_with_one_instance = [loc for loc in locations if loc['count'] == 1]
        if len(objects_with_one_instance) == 2:
            anchor_color = color
            selected_obj_indices = [loc['obj_index'] for loc in objects_with_one_instance]
            # Ensure anchor coordinates are extracted in the correct order corresponding to obj_indices
            anchor_coords = [loc['anchor_coord'] for loc in objects_with_one_instance]
            break
            
    if anchor_color == -1:
        return None, None, None # Should not happen based on examples

    obj1 = objects[selected_obj_indices[0]]
    obj2 = objects[selected_obj_indices[1]]
    anchor1 = anchor_coords[0]
    anchor2 = anchor_coords[1]

    # Determine base and overlay based on anchor coordinates (row first, then col)
    if anchor1[0] < anchor2[0] or (anchor1[0] == anchor2[0] and anchor1[1] < anchor2[1]):
        base_obj = obj1
        overlay_obj = obj2
        base_anchor_coord = anchor1
        overlay_anchor_coord = anchor2
    else:
        base_obj = obj2
        overlay_obj = obj1
        base_anchor_coord = anchor2
        overlay_anchor_coord = anchor1
        
    return anchor_color, base_obj, overlay_obj, base_anchor_coord, overlay_anchor_coord

def transform(input_grid):
    """
    Applies the object overlay transformation based on anchor pixels.
    """
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape

    # 1. Identify the background color
    colors, counts = np.unique(grid, return_counts=True)
    background_color = colors[np.argmax(counts)]

    # 2. Find all distinct objects
    objects = find_objects(grid, background_color)
    if not objects:
        return grid.tolist() # Or handle error

    # 3. Find the anchor color and the two selected objects
    anchor_result = find_anchor_color_and_objects(objects)
    if not anchor_result or anchor_result[0] is None:
         # Fallback or error handling if anchor logic doesn't apply
         print("Warning: Could not find unique anchor color/objects.")
         # As a simple fallback, return the input or an empty grid maybe?
         # For now, let's assume the examples guarantee finding anchors.
         return input_grid # Return original if pattern not found

    anchor_color, base_obj, overlay_obj, base_anchor_coord, overlay_anchor_coord = anchor_result

    # 4. Calculate the alignment offset
    offset_row = base_anchor_coord[0] - overlay_anchor_coord[0]
    offset_col = base_anchor_coord[1] - overlay_anchor_coord[1]

    # 5. Determine the combined bounding box
    all_pixels_coords = []
    # Add base object coords
    for r, c, _ in base_obj:
        all_pixels_coords.append((r, c))
    # Add overlay object coords shifted by offset
    for r, c, _ in overlay_obj:
        all_pixels_coords.append((r + offset_row, c + offset_col))

    if not all_pixels_coords:
        return [[]] # Handle empty object case

    min_r = min(r for r, c in all_pixels_coords)
    max_r = max(r for r, c in all_pixels_coords)
    min_c = min(c for r, c in all_pixels_coords)
    max_c = max(c for r, c in all_pixels_coords)

    # 6. Create the output grid
    output_height = max_r - min_r + 1
    output_width = max_c - min_c + 1
    output_grid = np.full((output_height, output_width), background_color, dtype=int)

    # 7. Draw the base object
    for r, c, color in base_obj:
        out_r = r - min_r
        out_c = c - min_c
        output_grid[out_r, out_c] = color

    # 8. Draw the overlay object (shifted and overwriting)
    for r, c, color in overlay_obj:
        shifted_r = r + offset_row
        shifted_c = c + offset_col
        out_r = shifted_r - min_r
        out_c = shifted_c - min_c
        # Ensure the pixel is within the calculated bounds (should be, but safety check)
        if 0 <= out_r < output_height and 0 <= out_c < output_width:
             output_grid[out_r, out_c] = color
        else:
             # This case might indicate an issue in bounding box calculation if it occurs
             print(f"Warning: Overlay pixel ({shifted_r}, {shifted_c}) -> ({out_r}, {out_c}) outside output bounds ({output_height}x{output_width})")


    return output_grid.tolist()
```
