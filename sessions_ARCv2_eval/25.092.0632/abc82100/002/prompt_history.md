
## train_1

**input:**
```
1 2 8 8 8
0 0 0 0 1
0 0 0 1 0
0 0 0 1 0
0 0 0 0 1
```


**output:**
```
0 0 0 0 0
0 0 0 0 2
0 0 0 2 2
0 0 0 2 2
0 0 0 0 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 0 6 0 6 0 6 0 6 0 6 0 6 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 2 0 8 0 8 0 0 0 0 0 0 0 4 0
0 0 0 0 7 0 0 0 0 0 0 0 0 0 0
0 8 0 0 6 0 0 8 0 0 0 0 0 0 0
8 0 4 2 0 4 2 0 8 0 0 0 0 0 0
0 8 0 0 7 0 0 8 0 0 0 0 0 2 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0
0 7 0 8 0 8 0 7 0 7 0 7 0 0 0
0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 7 0 7 0 7 0 7 0 7 0 7 0 7 0
7 0 7 0 7 0 7 0 7 0 7 0 7 0 7
0 4 0 0 0 0 0 0 0 0 0 0 0 2 0
4 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 4 0 0 0 0 0 0 0 0 0 0 0 2 0
4 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 4 0 0 0 0 0 0 0 0 0 0 0 2 0
4 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 4 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 4 0
0 0 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 4 0
6 0 6 0 0 0 6 0 6 0 6 0 6 0 0
0 6 0 0 0 0 0 6 0 6 0 6 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 4 0 0 0 0 0 0 0 8 0 0 0 4 0 0 0 4 0 0
0 0 0 0 0 0 0 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 4 0 0 0 8 0 0 0 8 0 0 0 4 0 0 0 0
0 0 0 0 0 0 8 0 0 0 0 0 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 8 0 8 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0
1 0 0 0 1 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 8 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0
```


**output:**
```
0 2 0 2 0 2 0 0 0 0 0 2 0 2 0 2 0 2 0 2
0 0 2 0 2 0 0 0 0 0 2 0 0 0 2 0 2 0 0 0
0 2 0 2 0 2 0 0 0 0 0 2 0 2 0 2 0 2 0 2
2 0 2 0 0 0 2 0 0 0 0 0 2 0 2 0 2 0 2 0
0 2 0 0 0 2 0 0 0 0 0 0 0 2 0 0 0 2 0 0
0 0 2 0 2 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0
0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 7 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 0 7 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
1 1 1 1 1 2 0 0
0 0 0 0 0 2 0 0
0 0 0 0 0 2 0 0
0 2 1 8 0 2 0 0
0 0 0 0 0 2 0 0
0 0 8 0 0 2 0 0
0 0 2 0 0 2 0 0
0 0 1 0 0 2 0 0
```


**output:**
```
2 2 2 2 2 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 1 0 0
```

Okay, let's analyze the provided examples.

**Perception**

The task involves transforming input grids based on the colors present and their arrangements. Across the examples, the color azure (8) seems to play a significant but varying role. Sometimes it's removed, sometimes its shape is preserved but recolored, and sometimes it triggers a pattern replacement. The transformations range from simple color swaps/removals on a pixel-wise basis to shape preservation/recoloring based on global properties (like single pixels) and complex pattern replacements centered on specific input colors. There appear to be distinct modes of operation, potentially triggered by the specific collection of colors present in the input or the existence of unique features like single-pixel objects.

1.  **Example 1:** The largest object (azure L-shape) has its color changed to the color of the unique single-pixel object (red). All other non-white objects are removed.
2.  **Example 2:** Azure pixels are removed. A color swap occurs between pairs: red (2) swaps with yellow (4), and magenta (6) swaps with orange (7). This is a pixel-wise operation for the swapping colors.
3.  **Example 3:** Azure pixels, along with yellow (4) and blue (1) pixels, trigger the placement of 3x3 patterns in the output. Blue triggers an orange pattern, while yellow and azure trigger a red pattern. Original red (2) and orange (7) pixels are removed without triggering patterns.
4.  **Example 4:** Azure pixels are removed. A color swap occurs between blue (1) and red (2). This is a pixel-wise operation.

The core logic seems conditional, depending heavily on the set of colors present and potentially the count/color of single-pixel objects.

**Facts**


```python
import numpy as np
from collections import deque

"""
Identify the transformation rule based on the set of unique non-white colors present in the input grid.

1.  **Pattern Replacement Rule (Example 3):**
    - Trigger: If the unique non-white colors are exactly {Blue(1), Red(2), Yellow(4), Orange(7), Azure(8)}.
    - Action: Initialize an output grid with white(0). For each Blue pixel in the input, draw an Orange '+' pattern `[[0, 7, 0], [7, 0, 7], [0, 7, 0]]` centered at its location in the output. For each Yellow or Azure pixel, draw a Red '+' pattern `[[0, 2, 0], [2, 0, 2], [0, 2, 0]]` centered at its location. Input Red and Orange pixels are ignored. Patterns overwrite previous values if they overlap.

2.  **Largest Object Recolor Rule (Example 1):**
    - Trigger: If the unique non-white colors are exactly {Blue(1), Red(2), Azure(8)} AND there exists at least one single-pixel non-white object in the input grid.
    - Action: Find all single-pixel non-white objects. Determine the minimum color value among these single pixels (`min_single_color`). Find the largest connected non-white object in the input grid. Initialize an output grid with white(0). Color the pixels corresponding to the largest object's shape with `min_single_color`.

3.  **Pixel Swap Rule (Examples 2 & 4):**
    - Trigger: If the unique non-white colors match specific sets not covered by rules 1 or 2.
    - Sub-Rule (Example 4): If colors are {Blue(1), Red(2), Azure(8)} and no single-pixel objects exist.
        - Action: Create an output grid by replacing Azure(8) with White(0), swapping Blue(1) with Red(2), and keeping other colors unchanged.
    - Sub-Rule (Example 2): If colors are {Red(2), Yellow(4), Magenta(6), Orange(7), Azure(8)}.
        - Action: Create an output grid by replacing Azure(8) with White(0), swapping Red(2) with Yellow(4), swapping Magenta(6) with Orange(7), and keeping other colors unchanged.

4.  **Default Rule:** If none of the above conditions are met, return the input grid unchanged.

Helper functions are used to find objects, identify single pixels, find the largest object, and apply patterns.
"""

def find_objects(grid, colors=None, connectivity=1):
    """
    Finds connected objects of specified colors in the grid.
    Uses Breadth-First Search (BFS).
    Connectivity: 1 for 4-way (N, S, E, W), 2 for 8-way (includes diagonals).
    """
    if colors is None:
        # Find objects of any non-background (0) color
        colors = set(np.unique(grid)) - {0}
    if not colors:
        return []

    rows, cols = grid.shape
    visited = np.zeros((rows, cols), dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            if color in colors and not visited[r, c]:
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                obj_color = color

                while q:
                    row, col = q.popleft()
                    obj_coords.add((row, col))

                    # Define neighbors based on connectivity
                    if connectivity == 1:
                        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]
                    else: # connectivity == 2 (8-way)
                         neighbors = [
                            (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1),
                            (row - 1, col - 1), (row - 1, col + 1), (row + 1, col - 1), (row + 1, col + 1)
                         ]
                         
                    for nr, nc in neighbors:
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == obj_color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                objects.append({'color': obj_color, 'coords': obj_coords})
    return objects

def get_single_pixel_objects(grid):
    """Identifies non-zero pixels with no non-zero neighbors (4-way)."""
    objects = find_objects(grid, connectivity=1)
    single_pixel_objects = [obj for obj in objects if len(obj['coords']) == 1]
    return single_pixel_objects
    # Alternative direct check:
    # rows, cols = grid.shape
    # single_pixels = []
    # for r in range(rows):
    #     for c in range(cols):
    #         color = grid[r, c]
    #         if color != 0:
    #             is_single = True
    #             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
    #                 nr, nc = r + dr, c + dc
    #                 if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] != 0:
    #                     is_single = False
    #                     break
    #             if is_single:
    #                 single_pixels.append({'color': color, 'coords': {(r, c)}})
    # return single_pixels


def find_largest_object(grid, ignore_color=0):
    """Finds the largest connected object (most pixels) ignoring a specific color."""
    valid_colors = set(np.unique(grid)) - {ignore_color}
    if not valid_colors:
      return None # No non-ignored objects

    objects = find_objects(grid, colors=valid_colors, connectivity=1)
    if not objects:
        return None

    largest_obj = max(objects, key=lambda obj: len(obj['coords']))
    return largest_obj

def apply_pattern(output_grid, center_r, center_c, pattern):
    """Applies a 3x3 pattern centered at (center_r, center_c) on the output grid."""
    rows, cols = output_grid.shape
    pattern_rows, pattern_cols = pattern.shape
    
    # Calculate pattern offsets from center (assuming 3x3)
    offset_r = pattern_rows // 2
    offset_c = pattern_cols // 2

    for pr in range(pattern_rows):
        for pc in range(pattern_cols):
            pattern_val = pattern[pr, pc]
            if pattern_val == 0: # Skip background color in pattern
                continue

            # Calculate target coordinates in the output grid
            target_r = center_r + (pr - offset_r)
            target_c = center_c + (pc - offset_c)

            # Check boundaries
            if 0 <= target_r < rows and 0 <= target_c < cols:
                output_grid[target_r, target_c] = pattern_val

def transform(input_grid):
    """
    Transforms the input grid based on the rules derived from examples.
    """
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape
    
    # Determine unique non-white colors
    original_colors = set(np.unique(input_np)) - {0}

    # Rule 1 Check: Pattern Replacement (Example 3)
    if original_colors == {1, 2, 4, 7, 8}:
        output_grid = np.zeros_like(input_np)
        # Define patterns (Orange '+' for Blue, Red '+' for Yellow/Azure)
        p_orange = np.array([[0, 7, 0], [7, 0, 7], [0, 7, 0]])
        p_red = np.array([[0, 2, 0], [2, 0, 2], [0, 2, 0]])
        
        # Apply patterns - process yellow/azure first, then blue to ensure blue overwrites correctly if needed?
        # The order shouldn't matter if patterns don't overlap center points. Let's stick to input order.
        for r in range(rows):
            for c in range(cols):
                color = input_np[r, c]
                if color == 1: # Blue
                    apply_pattern(output_grid, r, c, p_orange)
                elif color == 4 or color == 8: # Yellow or Azure
                     apply_pattern(output_grid, r, c, p_red)
        return output_grid.tolist()

    # Rule 2 Check: Largest Object Recolor (Example 1)
    if original_colors == {1, 2, 8}:
        single_pixels = get_single_pixel_objects(input_np)
        if single_pixels:
            # Find minimum color among single pixels
            min_single_color = min(obj['color'] for obj in single_pixels)
            
            # Find largest object
            largest_obj = find_largest_object(input_np, ignore_color=0)
            
            output_grid = np.zeros_like(input_np)
            if largest_obj:
                 for r, c in largest_obj['coords']:
                     output_grid[r, c] = min_single_color
            return output_grid.tolist()
        else:
            # Condition for Rule 3 Sub-Rule (Example 4) - colors {1, 2, 8} but NO single pixels
            output_grid = np.copy(input_np)
            # Apply mapping: 8->0, 1->2, 2->1
            swap_map = {0:0, 1:2, 2:1, 3:3, 4:4, 5:5, 6:6, 7:7, 8:0, 9:9}
            vectorized_map = np.vectorize(swap_map.get)
            output_grid = vectorized_map(input_np)
            return output_grid.tolist()


    # Rule 3 Check: Pixel Swap (Example 2)
    if original_colors == {2, 4, 6, 7, 8}:
        output_grid = np.copy(input_np)
         # Apply mapping: 8->0, 2->4, 4->2, 6->7, 7->6
        swap_map = {0:0, 1:1, 2:4, 3:3, 4:2, 5:5, 6:7, 7:6, 8:0, 9:9}
        vectorized_map = np.vectorize(swap_map.get)
        output_grid = vectorized_map(input_np)
        return output_grid.tolist()

    # Default Rule: No matching rule found, return input unchanged
    return input_grid
```
