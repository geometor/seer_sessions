
## train_1

**input:**
```
8 8 8 8 8 8 8 8 3 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 2 1 2 1 2 1
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 3 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8
8 3 3 3 3 3 3 3 3 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 2 2 2 2 2 2 2
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
3 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8
```


**output:**
```
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 3 8 2 8 8 8 8 8 3 3 3 3 3 3 3
8 8 8 8 3 8 2 8 8 8 8 8 3 8 8 8 8 8 8
8 8 8 8 3 8 2 8 8 8 8 8 3 8 8 8 8 8 8
8 8 8 8 3 8 2 8 8 8 8 8 3 8 8 8 8 8 8
8 8 8 8 3 8 8 8 8 8 8 8 3 8 8 8 2 8 8
8 8 8 8 3 3 3 3 3 3 3 3 3 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8
```


## train_3

**input:**
```
8 8 8 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 2 1 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
2 2 2 2 2 2 2 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 3 3 3 3 3 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
2 2 2 2 2 2 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
3 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8
```


**output:**
```
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 8 8 2 8 8 8 8 8 8 3 3 3 3 3 3 3
8 8 3 8 8 2 8 8 8 8 8 8 3 8 8 8 8 8 8
8 8 3 8 8 8 8 8 8 8 8 8 3 8 2 8 8 8 8
8 8 3 8 8 8 8 8 8 8 8 8 3 8 2 8 8 8 8
8 8 3 3 3 3 3 3 3 3 3 3 3 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8
```

Okay, let's break down this task.

**Perception of Elements:**

1.  **Background Color:** The predominant color in all input and output grids is azure (8). This serves as the background.
2.  **Key Input Colors:** The significant colors in the input grids, besides the background, are green (3), blue (1), and red (2).
3.  **Green Pixel:** In each input example, there is exactly one green (3) pixel. Its position varies.
4.  **Blue/Red Patterns:** The input grids contain patterns (often lines or segments) composed of blue (1) and red (2) pixels.
5.  **Output Transformation 1 (Color Change):** Comparing inputs and outputs, all blue (1) pixels in the input are changed to red (2) in the output. Original red (2) pixels remain red (2).
6.  **Output Transformation 2 (Green Extension):** The single green (3) pixel from the input remains in the output. Additionally, new green (3) pixels appear in the output, forming lines extending horizontally and vertically from the original green pixel's location.
7.  **Extension Rule:** These green lines extend outwards from the original green pixel, overwriting the background azure (8) pixels. The extension stops just *before* hitting a red (2) pixel (either an original red pixel or a blue pixel that was transformed to red) or the boundary of the grid. The red pixels act as barriers.

**YAML Facts:**


```yaml
task_description: "Change all blue pixels to red. Then, find the single green pixel and extend green lines horizontally and vertically from it, stopping at grid boundaries or red pixels."
grid_properties:
  background_color: 8 # azure
objects:
  - id: origin_marker
    color: 3 # green
    count: 1
    role: Starting point for line extension. Preserved in output.
  - id: barrier_pixels
    color: 2 # red
    role: Obstacles for green line extension. Preserved in output.
  - id: transformable_pixels
    color: 1 # blue
    role: Changed to red (2) in the output, becoming barrier_pixels.
  - id: background_pixels
    color: 8 # azure
    role: Can be overwritten by extending green lines. Otherwise preserved.
actions:
  - name: color_transformation
    input_color: 1 # blue
    output_color: 2 # red
    target: all blue pixels
  - name: line_extension
    origin: origin_marker (green pixel)
    extension_color: 3 # green
    directions: [up, down, left, right]
    overwrite_target: background_pixels (azure)
    stop_conditions:
      - grid_boundary
      - encounter barrier_pixels (red, including transformed blue)
```


**Natural Language Program:**

1.  Create a copy of the input grid to serve as the working output grid.
2.  Iterate through every cell of the working output grid. If a cell contains blue (1), change its value to red (2).
3.  Locate the coordinates (row `r`, column `c`) of the single green (3) pixel in the original input grid.
4.  **Extend Upwards:** Starting from the cell directly above the green pixel (`r-1`, `c`), move upwards row by row towards row 0. For each cell encountered:
    *   If the cell is outside the grid boundaries or contains red (2), stop extending upwards.
    *   If the cell contains azure (8), change it to green (3) in the working output grid and continue upwards.
5.  **Extend Downwards:** Starting from the cell directly below the green pixel (`r+1`, `c`), move downwards row by row towards the bottom boundary. For each cell encountered:
    *   If the cell is outside the grid boundaries or contains red (2), stop extending downwards.
    *   If the cell contains azure (8), change it to green (3) in the working output grid and continue downwards.
6.  **Extend Leftwards:** Starting from the cell directly to the left of the green pixel (`r`, `c-1`), move leftwards column by column towards column 0. For each cell encountered:
    *   If the cell is outside the grid boundaries or contains red (2), stop extending leftwards.
    *   If the cell contains azure (8), change it to green (3) in the working output grid and continue leftwards.
7.  **Extend Rightwards:** Starting from the cell directly to the right of the green pixel (`r`, `c+1`), move rightwards column by column towards the right boundary. For each cell encountered:
    *   If the cell is outside the grid boundaries or contains red (2), stop extending rightwards.
    *   If the cell contains azure (8), change it to green (3) in the working output grid and continue rightwards.
8.  Return the final working output grid.
```python
import numpy as np

def find_color_coordinates(grid, color):
    """Finds the coordinates of the first pixel with the specified color."""
    coords = np.argwhere(grid == color)
    if len(coords) > 0:
        return coords[0] # Return the first coordinate found (row, col)
    return None

def transform(input_grid):
    """
    Transforms the input grid by first changing all blue (1) pixels to red (2).
    Then, it finds the single green (3) pixel and extends green lines horizontally
    and vertically from it. These lines stop when they hit a grid boundary or
    a red (2) pixel (including those originally blue).
    """
    # Convert input to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)
    output_grid = grid_np.copy()
    height, width = output_grid.shape

    # --- Step 1: Color Transformation (Blue to Red) ---
    # Change all blue (1) pixels to red (2)
    output_grid[output_grid == 1] = 2

    # --- Step 2: Find the Green Pixel ---
    green_coord = find_color_coordinates(grid_np, 3) # Use original grid to find the green pixel
    if green_coord is None:
        # Should not happen based on examples, but good practice to handle
        return output_grid.tolist() 
    
    start_r, start_c = green_coord

    # --- Step 3: Line Extension ---
    
    # Extend Upwards (decrementing row)
    for r in range(start_r - 1, -1, -1):
        if output_grid[r, start_c] == 2: # Stop if red barrier
            break
        if output_grid[r, start_c] == 8: # Overwrite azure background
             output_grid[r, start_c] = 3
        # If it's another color (not red or azure), we also stop (implicit)
        # If it's already green (e.g., from another extension path), leave it.
        elif output_grid[r, start_c] != 3:
            break
            
    # Extend Downwards (incrementing row)
    for r in range(start_r + 1, height):
        if output_grid[r, start_c] == 2: # Stop if red barrier
            break
        if output_grid[r, start_c] == 8: # Overwrite azure background
             output_grid[r, start_c] = 3
        elif output_grid[r, start_c] != 3:
            break
            
    # Extend Leftwards (decrementing column)
    for c in range(start_c - 1, -1, -1):
        if output_grid[start_r, c] == 2: # Stop if red barrier
            break
        if output_grid[start_r, c] == 8: # Overwrite azure background
             output_grid[start_r, c] = 3
        elif output_grid[start_r, c] != 3:
            break

    # Extend Rightwards (incrementing column)
    for c in range(start_c + 1, width):
        if output_grid[start_r, c] == 2: # Stop if red barrier
            break
        if output_grid[start_r, c] == 8: # Overwrite azure background
             output_grid[start_r, c] = 3
        elif output_grid[start_r, c] != 3:
            break

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
