{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on its background color.\n\n1. Determine the dominant background color.\n\n2. If the background is Yellow (4):\n   a. Swap Green (3) and Azure (8), BUT with a modification for Azure blocks:\n      - Original Green pixels become Azure.\n      - For original Azure blocks:\n        - Pixels at the minimum row index within the block become Red (2).\n        - Other pixels within the block become Green (3).\n   b. Red (2) pixels change to Azure (8) if they are adjacent (including diagonals)\n      to an original Green pixel OR adjacent to another Red pixel that is also changing to Azure. This change propagates.\n\n3. If the background is Green (3):\n   a. Find the single Magenta (6) trigger pixel and change it to Green (3).\n   b. Find all Yellow (4) pixels.\n   c. Identify the Yellow pixel with the minimum row index (tie-break with min column index).\n   d. Change this target Yellow pixel to Magenta (6).\n   e. Change the pixel in the top row (row 0) in the same column as the target Yellow pixel to Magenta (6).\n   f. For all *other* Yellow pixels:\n      - If the Yellow pixel was isolated (no Yellow neighbors in the input), it remains Yellow.\n      - If the Yellow pixel had Yellow neighbors (part of a block in the input), it changes to Green (3).\n\n4. If the background is neither Yellow nor Green, return the input grid unchanged.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Determines the most frequent color in the grid, assuming it's the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_pixels(grid, color):\n    \"\"\"Finds the coordinates (row, col) of all pixels with the given color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets neighbor coordinates for a pixel (r, c).\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonals if connectivity is 4\n            if connectivity == 4 and abs(dr) + abs(dc) > 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_contiguous_blocks(grid, color):\n    \"\"\"Finds connected components (blocks) of a given color using BFS.\"\"\"\n    height, width = grid.shape\n    visited = set()\n    blocks = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and (r, c) not in visited:\n                block = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n                block.append((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    # Use 8-connectivity for finding blocks\n                    for nr, nc in get_neighbors(row, col, height, width, connectivity=8):\n                         if grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            block.append((nr, nc))\n                if block:\n                    blocks.append(block)\n    return blocks\n\ndef is_isolated(r, c, grid, color):\n    \"\"\"Checks if a pixel (r, c) of a given color has any neighbors of the same color.\"\"\"\n    height, width = grid.shape\n    for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n        if grid[nr, nc] == color:\n            return False\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules based on the background color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # 1. Determine background color\n    background_color = get_background_color(input_np)\n\n    if background_color == 4: # Yellow background case\n        original_green_locs = find_pixels(input_np, 3)\n        original_red_locs = find_pixels(input_np, 2)\n        original_azure_blocks = find_contiguous_blocks(input_np, 8)\n\n        # 2a. Change original Green pixels to Azure\n        for r, c in original_green_locs:\n            output_np[r, c] = 8\n\n        # 2a. Process original Azure blocks\n        for block in original_azure_blocks:\n            if not block: continue\n            min_row = min(r for r, c in block)\n            min_row_pixels = [(r, c) for r, c in block if r == min_row]\n            \n            for r, c in block:\n                if (r, c) in min_row_pixels:\n                    output_np[r, c] = 2 # Min row pixels become Red\n                else:\n                    output_np[r, c] = 3 # Other pixels become Green\n\n        # 2b. Propagating Red to Azure change\n        red_to_change = set()\n        red_locs_set = set(original_red_locs)\n        original_green_locs_set = set(original_green_locs)\n        \n        # Initial set: Reds adjacent to original Greens\n        for r, c in original_red_locs:\n             for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                 if (nr, nc) in original_green_locs_set:\n                     red_to_change.add((r, c))\n                     break # No need to check other neighbors for this red pixel\n\n        # Propagation loop\n        while True:\n            added_new = False\n            newly_added = set()\n            \n            # Check reds NOT yet marked for change\n            candidates = red_locs_set - red_to_change\n            \n            for r, c in candidates:\n                 # Check if adjacent to a red ALREADY marked for change\n                 is_adjacent_to_changing_red = False\n                 for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                     if (nr, nc) in red_to_change:\n                         is_adjacent_to_changing_red = True\n                         break\n                 if is_adjacent_to_changing_red:\n                     newly_added.add((r, c))\n                     added_new = True\n            \n            if not added_new:\n                break # No more propagation\n            \n            red_to_change.update(newly_added) # Add newly found reds to the set\n\n        # Apply the change for all identified Red pixels\n        for r, c in red_to_change:\n            output_np[r, c] = 8\n\n    elif background_color == 3: # Green background case\n        magenta_locs = find_pixels(input_np, 6)\n        yellow_locs = find_pixels(input_np, 4)\n        yellow_locs_set = set(yellow_locs)\n        \n        # 3a. Change trigger Magenta to Green\n        if magenta_locs:\n            trigger_loc = magenta_locs[0] # Assume single trigger\n            output_np[trigger_loc[0], trigger_loc[1]] = 3\n\n        if yellow_locs:\n            # 3c. Find target Yellow (min row, then min col)\n            target_yellow = min(yellow_locs, key=lambda x: (x[0], x[1]))\n            target_r, target_c = target_yellow\n\n            # 3d. Change target Yellow to Magenta\n            output_np[target_r, target_c] = 6\n            \n            # 3e. Change top row pixel in target column to Magenta\n            output_np[0, target_c] = 6\n\n            # 3f. Process other Yellow pixels\n            for r, c in yellow_locs:\n                if (r, c) == target_yellow:\n                    continue # Skip the target pixel itself\n                \n                # Check for yellow neighbors in the *input* grid\n                has_yellow_neighbor = False\n                for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                    if (nr, nc) in yellow_locs_set: # Check against original yellow locations\n                         has_yellow_neighbor = True\n                         break\n                \n                if has_yellow_neighbor:\n                    # Part of a block -> change to Green\n                    output_np[r, c] = 3\n                else:\n                    # Isolated -> remains Yellow (no change needed as output started as copy)\n                    pass\n\n    # 4. If background is neither Yellow nor Green, output_np remains a copy of input_np\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14170,
    "candidates_token_count": 2198,
    "total_token_count": 16368,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.098957,
  "retries": 1
}