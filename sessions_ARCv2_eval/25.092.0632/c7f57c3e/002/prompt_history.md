
## train_1

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 2 1 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 8 8 8 4 4 4
4 4 4 4 1 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 1 2 1 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 2 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 1 1 2 2 1 1 4 4 4 4
4 4 4 4 4 4 4 4 1 1 2 2 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 4 4 4 4 4 4
4 4 4 4 4 4 4 4 3 3 3 3 3 3 4 4 4 4
4 4 4 4 4 4 4 4 3 3 3 3 3 3 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 1 2 1 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 2 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 4 4 4
4 4 4 4 1 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 1 2 1 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 8 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 8 8 8 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 1 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 1 1 2 2 1 1 4 4 4 4
4 4 4 4 4 4 4 4 1 1 2 2 1 1 4 4 4 4
4 4 4 4 4 4 4 4 4 4 8 8 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 8 8 4 4 4 4 4 4
4 4 4 4 4 4 4 4 8 8 8 8 8 8 4 4 4 4
4 4 4 4 4 4 4 4 8 8 8 8 8 8 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 3 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 3 3
3 3 3 6 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 1 3 1 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 2 3 3 3 3 3 3 4 4 3 3 3 3 3 3
3 3 1 3 1 3 3 3 3 3 4 4 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 6 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 6 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 6 6 3 3 3 3 3 3
3 3 3 3 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 3 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 3 3
3 3 3 3 3 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 1 3 1 3 3 3 1 1 3 3 1 1 3 3 3 3
3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 1 3 1 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

Okay, let's analyze the provided training examples.

**Perception**

1.  **Grid Structure:** Both examples involve transforming an 18x18 grid of pixels.
2.  **Background Color:** The background color differs between the two examples. Example 1 has a Yellow (4) background, while Example 2 has a Green (3) background. This difference seems crucial as the transformation rules appear distinct.
3.  **Objects/Pixels of Interest:** Both grids contain distinct "objects" or scattered pixels of various colors, different from the background.
4.  **Color Changes (Example 1 - Yellow Background):**
    *   Green (3) pixels seem to swap places/colors with Azure (8) pixels. All original Green pixels become Azure, and all original Azure pixels become Green.
    *   Some Red (2) pixels also change color to Azure (8). These changed Red pixels appear to be those adjacent (including diagonals) to the *original* locations of the Green pixels. Other Red pixels remain unchanged.
    *   Blue (1) and Yellow (4) pixels remain unchanged.
5.  **Color Changes (Example 2 - Green Background):**
    *   There is initially a single Magenta (6) pixel.
    *   There are several Yellow (4) pixels.
    *   In the output, all original Yellow (4) pixels become Magenta (6).
    *   The original Magenta (6) pixel disappears (becomes the background Green (3)).
    *   A new Magenta (6) pixel appears at the top edge (row 0) of the grid, in the same column as the Yellow (4) pixel that had the lowest row index in the input grid.
    *   Blue (1), Red (2), and Green (3) pixels (other than the background replacement for the original Magenta) remain unchanged.

6.  **Transformation Logic:** The core logic appears conditional on the background color. Different rules apply depending on whether the background is Yellow or Green.

**Facts**


```yaml
task_context:
  grid_size: [18, 18]
  background_color_dependent_rules: true

example_1:
  background_color: Yellow (4)
  involved_colors: [Yellow (4), Blue (1), Red (2), Green (3), Azure (8)]
  transformations:
    - action: swap_colors
      color_1: Green (3)
      color_2: Azure (8)
      scope: all_pixels
    - action: change_color
      target_color: Red (2)
      new_color: Azure (8)
      condition: pixel_is_adjacent_to_original_green_location
      scope: specific_red_pixels
  unaffected_colors: [Blue (1), Yellow (4)] # Except background

example_2:
  background_color: Green (3)
  involved_colors: [Green (3), Blue (1), Red (2), Yellow (4), Magenta (6)]
  properties:
    trigger_pixel: Magenta (6) # Assumed unique
    target_pixels: Yellow (4)
  transformations:
    - action: identify_trigger
      color: Magenta (6)
    - action: identify_targets
      color: Yellow (4)
    - action: find_min_row_target
      pixels: target_pixels
      result: min_row_target_location
    - action: change_color
      target_color: Yellow (4)
      new_color: Magenta (6)
      scope: all_target_pixels
    - action: change_color
      target_location: original_trigger_location
      new_color: Green (3) # Background color
      scope: single_pixel
    - action: add_pixel
      color: Magenta (6)
      location: [0, min_row_target_location.column]
      scope: single_pixel
  unaffected_colors: [Blue (1), Red (2), Green (3)] # Except background fills

```


**Natural Language Program**

1.  Determine the dominant background color of the input grid.
2.  **If the background color is Yellow (4):**
    a.  Find the locations of all Green (3) pixels and all Azure (8) pixels in the input grid. Keep track of the original Green pixel locations.
    b.  Create the output grid by copying the input grid.
    c.  Change all pixels at the original Green locations to Azure (8) in the output grid.
    d.  Change all pixels at the original Azure locations to Green (3) in the output grid.
    e.  Iterate through all Red (2) pixels in the input grid.
    f.  For each Red (2) pixel, check if it is adjacent (sharing a side or corner) to any of the *original* Green pixel locations identified in step 2a.
    g.  If a Red (2) pixel is adjacent to an original Green location, change its color to Azure (8) in the output grid.
3.  **If the background color is Green (3):**
    a.  Find the location of the single Magenta (6) pixel (the trigger).
    b.  Find the locations of all Yellow (4) pixels (the targets).
    c.  Identify the target Yellow (4) pixel location that has the minimum row index. Record its column index.
    d.  Create the output grid by copying the input grid.
    e.  Change the color of all pixels at the target Yellow (4) locations to Magenta (6) in the output grid.
    f.  Change the color of the pixel at the original Magenta (6) trigger location to the background color Green (3) in the output grid.
    g.  Change the color of the pixel at row 0 and the recorded column index (from step 3c) to Magenta (6) in the output grid.
4.  Return the modified output grid.
```python
import numpy as np
from collections import Counter

"""
This program transforms an input grid based on its background color.

1. Determine the dominant background color of the input grid.

2. If the background color is Yellow (4):
   a. Find all Green (3) and Azure (8) pixel locations. Store original Green locations separately.
   b. Create a copy of the input grid.
   c. Change pixels at original Green locations to Azure (8) in the output.
   d. Change pixels at original Azure locations to Green (3) in the output.
   e. Find all Red (2) pixel locations.
   f. For each Red pixel, check if it's adjacent (including diagonals) to any *original* Green location.
   g. If adjacent, change the Red pixel's color to Azure (8) in the output.

3. If the background color is Green (3):
   a. Find the location of the (assumed single) Magenta (6) pixel.
   b. Find the locations of all Yellow (4) pixels.
   c. Identify the Yellow pixel location with the minimum row index. Record its column index.
   d. Create a copy of the input grid.
   e. Change all Yellow pixels to Magenta (6) in the output.
   f. Change the original Magenta pixel to Green (3) in the output.
   g. Change the pixel at row 0 and the recorded column index (from step 3c) to Magenta (6) in the output.

4. If the background color is neither Yellow nor Green, return the input grid unchanged.
"""

def get_background_color(grid):
    """Determines the most frequent color in the grid, assuming it's the background."""
    colors, counts = np.unique(grid, return_counts=True)
    return colors[np.argmax(counts)]

def find_pixels(grid, color):
    """Finds the coordinates (row, col) of all pixels with the given color."""
    rows, cols = np.where(grid == color)
    return list(zip(rows, cols))

def get_neighbors(r, c, height, width):
    """Gets the 8 neighbor coordinates (including diagonals) for a pixel (r, c)."""
    neighbors = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                neighbors.append((nr, nc))
    return neighbors

def is_adjacent(r, c, target_locations, height, width):
    """Checks if pixel (r, c) is adjacent to any location in target_locations."""
    neighbors = get_neighbors(r, c, height, width)
    target_set = set(target_locations)
    for neighbor in neighbors:
        if neighbor in target_set:
            return True
    return False

def transform(input_grid):
    """
    Applies the transformation rules based on the background color.
    """
    input_np = np.array(input_grid, dtype=int)
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # 1. Determine background color
    background_color = get_background_color(input_np)

    if background_color == 4: # Yellow background case
        # 2a. Find Green (3) and Azure (8) locations
        original_green_locs = find_pixels(input_np, 3)
        original_azure_locs = find_pixels(input_np, 8)
        
        # 2c. Change original Green to Azure
        for r, c in original_green_locs:
            output_np[r, c] = 8
            
        # 2d. Change original Azure to Green
        for r, c in original_azure_locs:
            output_np[r, c] = 3
            
        # 2e. Find Red (2) locations
        red_locs = find_pixels(input_np, 2)
        
        # 2f & 2g. Check adjacency for Red pixels and change if needed
        for r, c in red_locs:
            if is_adjacent(r, c, original_green_locs, height, width):
                output_np[r, c] = 8

    elif background_color == 3: # Green background case
        # 3a. Find Magenta (6) location (assume one)
        magenta_locs = find_pixels(input_np, 6)
        if not magenta_locs: 
             return output_np.tolist() # No trigger, return copy
        original_magenta_loc = magenta_locs[0] # Assume first one if multiple (though examples show one)
        
        # 3b. Find Yellow (4) locations
        yellow_locs = find_pixels(input_np, 4)
        
        min_row_yellow_col = -1
        if yellow_locs:
            # 3c. Find Yellow pixel with min row index and get its column
            min_row = height # Initialize with value larger than any possible row index
            for r, c in yellow_locs:
                if r < min_row:
                    min_row = r
                    min_row_yellow_col = c
                elif r == min_row: # If multiple in the same min row, take the smallest col? (not specified, taking first found)
                     pass # Keep the first one found in this row

            # 3e. Change Yellow to Magenta
            for r, c in yellow_locs:
                output_np[r, c] = 6
        
        # 3f. Change original Magenta to Green (background)
        output_np[original_magenta_loc[0], original_magenta_loc[1]] = 3
        
        # 3g. Add Magenta at top row based on min_row_yellow_col
        if min_row_yellow_col != -1: # Check if any yellow pixels were found
             output_np[0, min_row_yellow_col] = 6

    # 4. If background is neither Yellow nor Green, output_np remains a copy of input_np

    return output_np.tolist()
```
