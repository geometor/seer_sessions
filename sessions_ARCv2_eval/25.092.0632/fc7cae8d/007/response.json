{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Define the background color as white (0).\n2. Define the \"inner grid\" as the input grid excluding the 1-pixel border (top/bottom rows, left/right columns). Handle grids smaller than 3x3 where an inner grid doesn't exist.\n3. Identify the 'target_color' by finding the most frequent non-background color within the inner grid. If no inner grid exists or it contains only background pixels, handle this case (e.g., potentially fall back to finding the largest overall object, or return a default).\n4. Find all contiguous components of non-background pixels in the *entire* original grid using 8-way adjacency (horizontal, vertical, and diagonal connections).\n5. Filter these components to keep only those containing at least one pixel of the identified 'target_color'.\n6. If no components contain the target color, handle this case (return default).\n7. Select the component from the filtered list that has the largest size (number of pixels). This is the 'target_component'.\n8. Determine the minimum bounding box (min_row, min_col, max_row, max_col) that encloses the 'target_component'.\n9. Extract the subgrid corresponding to this bounding box from the original input grid.\n10. Return the extracted subgrid.\n\"\"\"\n\n# Imports\nimport numpy as np\nfrom collections import deque\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"\n    Finds all connected components of non-background pixels in a grid using 8-way adjacency.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list: A list of components, where each component is a list of \n              (row, col) tuples representing the coordinates of the pixels \n              in that component. Returns an empty list if no non-background pixels exist.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not background and not visited yet, start a search\n            if grid[r, c] != background_color and (r, c) not in visited:\n                current_component = []\n                q = deque([(r, c)]) # Queue for BFS\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_component.append((curr_r, curr_c))\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # If neighbor is valid, not background, and not visited\n                                if grid[nr, nc] != background_color and (nr, nc) not in visited:\n                                    visited.add((nr, nc))\n                                    q.append((nr, nc))\n                \n                if current_component:\n                    components.append(current_component)\n                    \n    return components\n\ndef get_dominant_inner_color(grid, background_color=0):\n    \"\"\"\n    Finds the most frequent non-background color in the inner part of the grid (excluding the 1-pixel border).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        int or None: The most frequent color, or None if no non-background\n                     colors exist in the inner grid or grid is too small (< 3x3).\n    \"\"\"\n    height, width = grid.shape\n    # Inner grid requires at least 3x3 dimensions\n    if height < 3 or width < 3:\n        return None \n        \n    inner_grid = grid[1:-1, 1:-1]\n    # Find unique colors and their counts, excluding the background color\n    colors, counts = np.unique(inner_grid[inner_grid != background_color], return_counts=True)\n    \n    if len(colors) == 0:\n        return None # No non-background colors found in the inner grid\n        \n    # Return the color with the highest count\n    dominant_color_index = np.argmax(counts)\n    return colors[dominant_color_index]\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box for a given component.\n\n    Args:\n        component (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n    \n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    \n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    \n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts the largest connected component containing the dominant inner color from the input grid.\n    \"\"\"\n    # Convert input list-of-lists to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    background_color = 0\n\n    # Handle grids too small to have an inner area\n    if height < 3 or width < 3:\n         # If the grid is too small, we can't determine an inner dominant color.\n         # Fallback: Find the largest overall non-background component.\n         all_components_small = find_connected_components(input_grid_np, background_color)\n         if not all_components_small:\n             return [[background_color]] # Return background if grid is empty or all background\n         largest_component_small = max(all_components_small, key=len)\n         bounding_box_small = get_bounding_box(largest_component_small)\n         if bounding_box_small is None:\n             return [[background_color]]\n         min_r, min_c, max_r, max_c = bounding_box_small\n         output_grid_np = input_grid_np[min_r : max_r + 1, min_c : max_c + 1]\n         return output_grid_np.tolist()\n\n\n    # Find the dominant non-background color in the inner grid\n    target_color = get_dominant_inner_color(input_grid_np, background_color)\n\n    # If no dominant inner color found (e.g., inner grid is all background), \n    # fallback to finding the largest overall non-background component.\n    if target_color is None:\n        all_components_fallback = find_connected_components(input_grid_np, background_color)\n        if not all_components_fallback:\n            return [[background_color]] # Return background if grid is empty or all background\n        target_component = max(all_components_fallback, key=len)\n    else:\n        # Find all connected components in the *entire* grid\n        all_components = find_connected_components(input_grid_np, background_color)\n        \n        # Filter components to keep only those containing the target_color\n        target_color_components = []\n        for component in all_components:\n            # Check if any pixel in this component matches the target_color\n            has_target_color = False\n            for r, c in component:\n                if input_grid_np[r, c] == target_color:\n                    has_target_color = True\n                    break\n            if has_target_color:\n                target_color_components.append(component)\n\n        # Handle case where no components contain the target color (might happen if target color only existed as single pixels)\n        # Fallback to largest overall component in this case too.\n        if not target_color_components:\n             all_components_fallback_2 = find_connected_components(input_grid_np, background_color)\n             if not all_components_fallback_2:\n                 return [[background_color]]\n             target_component = max(all_components_fallback_2, key=len)\n        else:\n             # Find the largest component among the filtered ones\n             target_component = max(target_color_components, key=len)\n\n    # Get the bounding box of the final target component\n    bounding_box = get_bounding_box(target_component)\n    if bounding_box is None: # Should only happen if target_component was somehow empty\n        return [[background_color]] \n    min_row, min_col, max_row, max_col = bounding_box\n\n    # Extract the subgrid defined by the bounding box\n    output_grid_np = input_grid_np[min_row : max_row + 1, min_col : max_col + 1]\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16202,
    "candidates_token_count": 2179,
    "total_token_count": 18381,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.681355,
  "retries": 1
}