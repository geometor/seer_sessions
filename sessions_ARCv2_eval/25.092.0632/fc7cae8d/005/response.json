{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1. Define the background color as white (0).\n2. Define the \"inner grid\" as the input grid excluding the 1-pixel border (top/bottom rows, left/right columns).\n3. Identify the 'target_color' by finding the most frequent non-background color within the inner grid.\n4. Find all contiguous components of non-background pixels in the *entire* original grid using 8-way adjacency.\n5. Filter these components to keep only those containing at least one pixel of the 'target_color'.\n6. Select the component from the filtered list that has the largest size (number of pixels). This is the 'target_component'.\n7. Determine the minimum bounding box of the 'target_component'.\n8. Extract the subgrid corresponding to this bounding box from the original input grid.\n\"\"\"\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"\n    Finds all connected components of non-background pixels in a grid using 8-way adjacency.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list: A list of components, where each component is a list of \n              (row, col) tuples representing the coordinates of the pixels \n              in that component. Returns an empty list if no non-background pixels exist.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not background and not visited yet, start a search\n            if grid[r, c] != background_color and (r, c) not in visited:\n                current_component = []\n                q = [(r, c)] # Queue for BFS\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    current_component.append((curr_r, curr_c))\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # If neighbor is valid, not background, and not visited\n                                if grid[nr, nc] != background_color and (nr, nc) not in visited:\n                                    visited.add((nr, nc))\n                                    q.append((nr, nc))\n                \n                if current_component:\n                    components.append(current_component)\n                    \n    return components\n\ndef get_dominant_inner_color(grid, background_color=0):\n    \"\"\"\n    Finds the most frequent non-background color in the inner part of the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        int or None: The most frequent color, or None if no non-background\n                     colors exist in the inner grid or grid is too small.\n    \"\"\"\n    height, width = grid.shape\n    # Inner grid requires at least 3x3 dimensions\n    if height < 3 or width < 3:\n        return None \n        \n    inner_grid = grid[1:-1, 1:-1]\n    colors, counts = np.unique(inner_grid[inner_grid != background_color], return_counts=True)\n    \n    if len(colors) == 0:\n        return None # No non-background colors found in the inner grid\n        \n    dominant_color_index = np.argmax(counts)\n    return colors[dominant_color_index]\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box for a given component.\n\n    Args:\n        component (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n    \n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    \n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    \n    return min_row, min_col, max_row, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts the largest connected component containing the dominant inner color.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    background_color = 0\n\n    # 1. Handle grids too small to have an inner area\n    if height < 3 or width < 3:\n         # Default behavior might need adjustment based on task specifics for small grids\n         # Returning a 1x1 background grid is a safe placeholder\n         return [[background_color]]\n\n    # 2. Find the dominant non-background color in the inner grid\n    target_color = get_dominant_inner_color(input_grid_np, background_color)\n\n    # 3. If no dominant color found (e.g., inner grid is all background), handle appropriately\n    if target_color is None:\n        # Could return empty, background, or maybe find largest overall component if required\n        # Returning 1x1 background for now\n        return [[background_color]] \n\n    # 4. Find all connected components in the *entire* grid\n    all_components = find_connected_components(input_grid_np, background_color)\n    \n    # 5. Filter components to keep only those containing the target_color\n    target_color_components = []\n    for component in all_components:\n        # Check if any pixel in this component matches the target_color\n        component_colors = {input_grid_np[r, c] for r, c in component}\n        if target_color in component_colors:\n            target_color_components.append(component)\n\n    # 6. Handle case where no components contain the target color\n    if not target_color_components:\n         # This case seems unlikely given the problem structure, but handle defensively\n         return [[background_color]]\n\n    # 7. Find the largest component among the filtered ones\n    target_component = max(target_color_components, key=len)\n\n    # 8. Get the bounding box of the target component\n    bounding_box = get_bounding_box(target_component)\n    if bounding_box is None: # Should not happen if target_component is valid\n        return [[background_color]] \n    min_row, min_col, max_row, max_col = bounding_box\n\n    # 9. Extract the subgrid defined by the bounding box\n    output_grid_np = input_grid_np[min_row : max_row + 1, min_col : max_col + 1]\n\n    # 10. Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20564,
    "candidates_token_count": 1706,
    "total_token_count": 22270,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.139527,
  "retries": 1
}