{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\n1. Define the background color as white (0).\n2. Scan the input grid to identify all contiguous groups (components) of pixels whose color is not the background color (white). Use 8-way adjacency (including diagonals).\n3. Filter these components: Remove any component where any of its pixels are located on the absolute outer border of the input grid (row 0, last row, column 0, or last column).\n4. From the remaining (\"internal\") components, select the one with the largest size (number of pixels). \n5. Determine the minimum bounding box of the selected largest internal component.\n6. Create a new output grid whose dimensions match the height and width of the bounding box.\n7. Copy the pixels from the input grid within the calculated bounding box into the new output grid, preserving their relative positions.\n\"\"\"\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"\n    Finds all connected components of non-background pixels in a grid using 8-way adjacency.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list: A list of components, where each component is a list of \n              (row, col) tuples representing the coordinates of the pixels \n              in that component. Returns an empty list if no non-background pixels exist.\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not background and not visited yet, start a search\n            if grid[r, c] != background_color and (r, c) not in visited:\n                current_component = []\n                q = [(r, c)] # Queue for BFS\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.pop(0)\n                    current_component.append((curr_r, curr_c))\n\n                    # Check all 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # If neighbor is valid, not background, and not visited\n                                if grid[nr, nc] != background_color and (nr, nc) not in visited:\n                                    visited.add((nr, nc))\n                                    q.append((nr, nc))\n                \n                if current_component:\n                    components.append(current_component)\n                    \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the bounding box for a given component.\n\n    Args:\n        component (list): A list of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if component is empty.\n    \"\"\"\n    if not component:\n        return None\n    \n    rows = [r for r, c in component]\n    cols = [c for r, c in component]\n    \n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    \n    return min_row, min_col, max_row, max_col\n\ndef is_on_border(r, c, height, width):\n    \"\"\"Checks if a coordinate is on the absolute border of the grid.\"\"\"\n    return r == 0 or r == height - 1 or c == 0 or c == width - 1\n\ndef transform(input_grid):\n    \"\"\"\n    Extracts the largest contiguous non-background, non-border object from the input grid.\n\n    Args:\n        input_grid (list[list[int]]): The 2D input grid.\n\n    Returns:\n        list[list[int]]: The extracted subgrid containing the largest internal object.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    height, width = input_grid_np.shape\n    background_color = 0\n\n    # 1. Find all connected components of non-background pixels\n    all_components = find_connected_components(input_grid_np, background_color)\n\n    # 2. Filter out components touching the border\n    internal_components = []\n    for component in all_components:\n        touches_border = False\n        for r, c in component:\n            if is_on_border(r, c, height, width):\n                touches_border = True\n                break\n        if not touches_border:\n            internal_components.append(component)\n\n    # Handle case where there are no internal non-background objects\n    if not internal_components:\n        # Based on examples, this seems unlikely for valid inputs.\n        # If it happens, returning a minimal grid might be appropriate.\n        # Let's return a 1x1 white grid.\n        return [[background_color]] \n\n    # 3. Find the largest internal component based on the number of pixels\n    largest_internal_component = max(internal_components, key=len)\n\n    # 4. Determine the bounding box of the largest internal component\n    min_row, min_col, max_row, max_col = get_bounding_box(largest_internal_component)\n\n    # 5. Extract the subgrid defined by the bounding box\n    output_grid_np = input_grid_np[min_row : max_row + 1, min_col : max_col + 1]\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13302,
    "candidates_token_count": 1356,
    "total_token_count": 14658,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.503818,
  "retries": 1
}