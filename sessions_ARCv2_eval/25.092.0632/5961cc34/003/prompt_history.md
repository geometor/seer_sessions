
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 3 3 8 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 3 1 1 1 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

*   **Perception:** The task involves transforming input grids containing various colored objects into output grids. The input grids feature a consistent background color (azure, 8). There are distinct objects primarily composed of blue (1) and green (3) pixels, which seem to define key shapes or patterns ("pattern objects"). Additionally, near the bottom of the input grids, there are marker pixels: a single yellow (4) pixel and one or more red (2) pixels directly below it in the same column. The output grids consist solely of the azure background and red (2) pixels forming specific shapes. The transformation logic appears to depend on the number of distinct "pattern objects" found in the input.

*   **YAML Facts:**
    
```yaml
    task_context:
      background_color: 8 (azure)
      output_color: 2 (red)
      pattern_colors: [1 (blue), 3 (green)]
      marker_colors: [4 (yellow), 2 (red)]
      grid_dimensions: variable

    observations:
      - element: pattern_objects
        description: Connected components composed of pattern_colors (blue or green). Considered connected if pixels share an edge (not diagonal). Blue and Green pixels connect to each other.
        properties:
          - count: The number of distinct pattern_objects in the input grid.
          - bounding_box: The smallest rectangle enclosing all pixels of a single pattern_object.
        relationship: The transformation rule depends on the 'count' property.

      - element: marker_objects
        description: A vertical structure near the bottom, consisting of a single yellow (4) pixel with one or more red (2) pixels directly below it in the same column.
        properties:
          - column_index: The column where the marker_objects reside.
          - target_color: The color of the red pixels in the marker (always red, 2).
        relationship: Used only when the count of pattern_objects is exactly 1 to determine the output column. Implicitly confirms the output color is red (2).

      - element: output_grid
        description: The result of the transformation.
        properties:
          - dimensions: Same as the input grid.
          - background: Same as input background (azure, 8).
          - foreground: Pixels colored with the target_color (red, 2).
        relationship:
          - If pattern_object count is 1: Foreground is a single vertical line of red (2) spanning the full height of the grid in the column specified by marker_objects.column_index.
          - If pattern_object count is > 1: Foreground is the union of the bounding_boxes of all pattern_objects, filled with red (2).

    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, then change all non-background (non-azure) pixels to the background color (azure, 8).
    2.  Identify all distinct connected components where connectivity includes pixels colored blue (1) or green (3). Treat blue and green pixels equivalently for finding components. Count these components ("pattern objects").
    3.  **If** the number of pattern objects is exactly 1:
        a.  Find the column index containing the yellow (4) marker pixel.
        b.  Fill the entire identified column in the output grid with red (2).
    4.  **Else if** the number of pattern objects is greater than 1:
        a.  For each identified pattern object, determine its minimum bounding box (minimum row, minimum column, maximum row, maximum column).
        b.  Iterate through all cells within the union of these bounding boxes. For each cell (row, col) that falls within *any* of the calculated bounding boxes, set the corresponding cell in the output grid to red (2).
    5.  Return the final output grid.
```python
import numpy as np
from collections import deque

"""
Transforms an input grid based on the number and location of connected components 
formed by blue (1) and green (3) pixels ("pattern objects").

1. Initialize the output grid as a copy of the input grid, then set all 
   non-background (non-azure, 8) pixels to the background color (azure, 8).
2. Find all connected components consisting of blue (1) or green (3) pixels. 
   Connectivity is defined by adjacent (non-diagonal) cells. Blue and green 
   pixels are considered connected to each other. Count these components.
3. If exactly one component is found:
   a. Locate the column index of the single yellow (4) marker pixel.
   b. Fill this entire column in the output grid with red (2).
4. If more than one component is found:
   a. For each component, determine its minimum bounding box.
   b. Calculate the union of all these bounding boxes.
   c. Fill all cells within the union of the bounding boxes in the output 
      grid with red (2).
5. Return the modified output grid.
"""

def find_connected_components(grid, target_colors):
    """
    Finds all connected components of specified colors in the grid.
    Uses Breadth-First Search (BFS).
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] in target_colors and not visited[r, c]:
                # Start BFS for a new component
                component = set()
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    component.add((row, col))
                    
                    # Check neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] in target_colors and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                components.append(component)
                
    return components

def get_bounding_box(component):
    """Calculates the bounding box of a component."""
    if not component:
        return None # Or raise an error
    
    min_r = min(r for r, c in component)
    min_c = min(c for r, c in component)
    max_r = max(r for r, c in component)
    max_c = max(c for r, c in component)
    return min_r, min_c, max_r, max_c

def transform(input_grid):
    """
    Applies the transformation rule based on pattern object count.
    """
    # Define colors
    background_color = 8
    pattern_colors = {1, 3} # Blue and Green
    marker_color_yellow = 4
    output_color = 2 # Red

    # Initialize output_grid as a copy of input, then clear non-background
    output_grid = np.copy(input_grid)
    output_grid[output_grid != background_color] = background_color
    
    rows, cols = input_grid.shape

    # Find pattern objects (connected components of blue or green)
    pattern_objects = find_connected_components(input_grid, pattern_colors)
    num_pattern_objects = len(pattern_objects)

    # Case 1: Exactly one pattern object
    if num_pattern_objects == 1:
        # Find the column of the yellow marker
        marker_col = -1
        yellow_locations = np.where(input_grid == marker_color_yellow)
        if len(yellow_locations[1]) > 0: # Check if yellow marker exists
             marker_col = yellow_locations[1][0] # Assume only one yellow marker
        
        # Check if marker was found (robustness)
        if marker_col != -1:
            # Fill the marker column with the output color
            output_grid[:, marker_col] = output_color
        else:
            # Fallback or error handling if no yellow marker found, 
            # although the problem description implies it will be there.
            # For now, leave the grid as background if marker is missing.
            pass 

    # Case 2: More than one pattern object
    elif num_pattern_objects > 1:
        # Calculate the union of bounding boxes
        min_union_r, min_union_c = rows, cols
        max_union_r, max_union_c = -1, -1
        found_box = False

        for component in pattern_objects:
            bbox = get_bounding_box(component)
            if bbox:
                found_box = True
                min_r, min_c, max_r, max_c = bbox
                min_union_r = min(min_union_r, min_r)
                min_union_c = min(min_union_c, min_c)
                max_union_r = max(max_union_r, max_r)
                max_union_c = max(max_union_c, max_c)

        # Fill the union of bounding boxes if any boxes were found
        if found_box:
            for r in range(min_union_r, max_union_r + 1):
                for c in range(min_union_c, max_union_c + 1):
                     # Check bounds just in case something weird happened with initialization
                    if 0 <= r < rows and 0 <= c < cols:
                        output_grid[r, c] = output_color
                        
    # Case 3: Zero pattern objects (implicitly handled, output grid remains background)
    # No specific action needed as output grid is already initialized to background.

    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Transforms an input grid based on the number and location of connected components 
formed by blue (1) and green (3) pixels ("pattern objects").

1. Initialize the output grid as a copy of the input grid, then set all 
   non-background (non-azure, 8) pixels to the background color (azure, 8).
2. Find all connected components consisting of blue (1) or green (3) pixels. 
   Connectivity is defined by adjacent (non-diagonal) cells. Blue and green 
   pixels are considered connected to each other. Count these components.
3. If exactly one component is found:
   a. Locate the column index of the single yellow (4) marker pixel.
   b. Fill this entire column in the output grid with red (2).
4. If more than one component is found:
   a. For each component, determine its minimum bounding box.
   b. Calculate the union of all these bounding boxes.
   c. Fill all cells within the union of the bounding boxes in the output 
      grid with red (2).
5. Return the modified output grid.
"""

def find_connected_components(grid, target_colors):
    """
    Finds all connected components of specified colors in the grid.
    Uses Breadth-First Search (BFS).
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    components = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] in target_colors and not visited[r, c]:
                # Start BFS for a new component
                component = set()
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    component.add((row, col))
                    
                    # Check neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] in target_colors and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                
                components.append(component)
                
    return components

def get_bounding_box(component):
    """Calculates the bounding box of a component."""
    if not component:
        return None # Or raise an error
    
    min_r = min(r for r, c in component)
    min_c = min(c for r, c in component)
    max_r = max(r for r, c in component)
    max_c = max(c for r, c in component)
    return min_r, min_c, max_r, max_c

def transform(input_grid):
    """
    Applies the transformation rule based on pattern object count.
    """
    # Define colors
    background_color = 8
    pattern_colors = {1, 3} # Blue and Green
    marker_color_yellow = 4
    output_color = 2 # Red

    # Initialize output_grid as a copy of input, then clear non-background
    output_grid = np.copy(input_grid)
    output_grid[output_grid != background_color] = background_color
    
    rows, cols = input_grid.shape

    # Find pattern objects (connected components of blue or green)
    pattern_objects = find_connected_components(input_grid, pattern_colors)
    num_pattern_objects = len(pattern_objects)

    # Case 1: Exactly one pattern object
    if num_pattern_objects == 1:
        # Find the column of the yellow marker
        marker_col = -1
        yellow_locations = np.where(input_grid == marker_color_yellow)
        if len(yellow_locations[1]) > 0: # Check if yellow marker exists
             marker_col = yellow_locations[1][0] # Assume only one yellow marker
        
        # Check if marker was found (robustness)
        if marker_col != -1:
            # Fill the marker column with the output color
            output_grid[:, marker_col] = output_color
        else:
            # Fallback or error handling if no yellow marker found, 
            # although the problem description implies it will be there.
            # For now, leave the grid as background if marker is missing.
            pass 

    # Case 2: More than one pattern object
    elif num_pattern_objects > 1:
        # Calculate the union of bounding boxes
        min_union_r, min_union_c = rows, cols
        max_union_r, max_union_c = -1, -1
        found_box = False

        for component in pattern_objects:
            bbox = get_bounding_box(component)
            if bbox:
                found_box = True
                min_r, min_c, max_r, max_c = bbox
                min_union_r = min(min_union_r, min_r)
                min_union_c = min(min_union_c, min_c)
                max_union_r = max(max_union_r, max_r)
                max_union_c = max(max_union_c, max_c)

        # Fill the union of bounding boxes if any boxes were found
        if found_box:
            for r in range(min_union_r, max_union_r + 1):
                for c in range(min_union_c, max_union_c + 1):
                     # Check bounds just in case something weird happened with initialization
                    if 0 <= r < rows and 0 <= c < cols:
                        output_grid[r, c] = output_color
                        
    # Case 3: Zero pattern objects (implicitly handled, output grid remains background)
    # No specific action needed as output grid is already initialized to background.

    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0

## Example 2:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 3 3 8 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 242
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 84.17391304347825

## Example 3:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 195
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 77.07509881422925

## Example 4:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 3 1 1 1 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 150
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 59.288537549407096
*   **General Assessment:**
    The initial analysis correctly identified the two main transformation scenarios based on the count of "pattern objects" (connected blue/green components). The logic for the single-object case (fill marker column) worked correctly, as shown by Example 1 passing. However, the logic for the multi-object case failed in Examples 2, 3, and 4. The error stems from calculating the *union* of the bounding boxes of all pattern objects and filling that single large rectangle. The expected outputs clearly show that the bounding box of *each individual* pattern object should be filled separately.

*   **Strategy for Resolution:**
    Modify the logic for the multi-object case. Instead of calculating the union bounding box, iterate through each identified pattern object, calculate its individual bounding box, and fill that specific rectangular area in the output grid with the output color (red, 2).

*   **Metrics and Analysis:**

    *   **Example 1:**
        *   Pattern Objects Count: 1
        *   Yellow Marker Column: 8
        *   Result: Correct (Filled column 8 red).
    *   **Example 2:**
        *   Pattern Objects Count: 4 (Two "plus" shapes, two "L" shapes)
        *   Yellow Marker Column: 10
        *   Current Incorrect Logic: Calculated the union bounding box covering rows 3-16 and columns 2-21 and filled it red.
        *   Expected Logic: Fill the individual bounding boxes of the four objects.
        *   Result: Incorrect (Filled a large union box instead of four smaller boxes).
    *   **Example 3:**
        *   Pattern Objects Count: 3 (Two "plus" shapes, one rotated "T" shape)
        *   Yellow Marker Column: 16
        *   Current Incorrect Logic: Calculated the union bounding box covering rows 2-17 and columns 2-20 and filled it red.
        *   Expected Logic: Fill the individual bounding boxes of the three objects.
        *   Result: Incorrect (Filled a large union box instead of three smaller boxes).
    *   **Example 4:**
        *   Pattern Objects Count: 2 (One "plus" shape, one rotated "T" shape)
        *   Yellow Marker Column: 5
        *   Current Incorrect Logic: Calculated the union bounding box covering rows 3-14 and columns 2-16 and filled it red.
        *   Expected Logic: Fill the individual bounding boxes of the two objects.
        *   Result: Incorrect (Filled a large union box instead of two smaller boxes).

*   **YAML Facts:**
    
```yaml
    task_context:
      background_color: 8 (azure)
      output_color: 2 (red)
      pattern_colors: [1 (blue), 3 (green)]
      marker_colors: [4 (yellow), 2 (red)] # Red markers below yellow seem irrelevant to the transformation logic itself but confirm the output color.
      grid_dimensions: variable

    observations:
      - element: pattern_objects
        description: Connected components composed of pattern_colors (blue or green). Considered connected if pixels share an edge (not diagonal). Blue and Green pixels connect to each other within the same component.
        properties:
          - count: The number of distinct pattern_objects in the input grid.
          - bounding_box: The smallest rectangle enclosing all pixels of a single pattern_object.
        relationship: The transformation rule depends on the 'count' property.

      - element: marker_objects
        description: A single yellow (4) pixel usually located near the bottom of the grid.
        properties:
          - column_index: The column where the yellow (4) marker pixel resides.
          - target_color: Implied by red pixels below yellow marker, corresponds to output_color (red, 2).
        relationship: Used only when the count of pattern_objects is exactly 1 to determine the output column.

      - element: output_grid
        description: The result of the transformation.
        properties:
          - dimensions: Same as the input grid.
          - background: Same as input background (azure, 8).
          - foreground: Pixels colored with the target_color (red, 2).
        relationship:
          - If pattern_object count is 1: Foreground is a single vertical line of red (2) spanning the full height of the grid in the column specified by the yellow marker_object's column_index.
          - If pattern_object count is > 1: For each individual pattern_object, its bounding_box is calculated, and that rectangular area is filled with red (2) in the output grid. The final output is the combination of all these filled individual bounding boxes.

    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, then change all non-background (non-azure) pixels to the background color (azure, 8).
    2.  Identify all distinct connected components ("pattern objects") where connectivity includes adjacent (non-diagonal) pixels colored blue (1) or green (3). Treat blue and green pixels equivalently for finding components. Count these components.
    3.  **If** the number of pattern objects is exactly 1:
        a.  Find the column index containing the yellow (4) marker pixel.
        b.  Fill the entire identified column in the output grid with red (2).
    4.  **Else if** the number of pattern objects is greater than 1:
        a.  For **each** identified pattern object:
            i.  Determine its minimum bounding box (minimum row, minimum column, maximum row, maximum column).
            ii. Iterate through all cells within this *individual* bounding box and set the corresponding cell in the output grid to red (2).
    5.  Return the final output grid.
