{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the number and location of connected components \nformed by blue (1) and green (3) pixels (\"pattern objects\").\n\n1. Initialize the output grid with the background color (azure, 8).\n2. Find all connected components consisting of blue (1) or green (3) pixels. \n   Connectivity is defined by adjacent (non-diagonal) cells. Blue and green \n   pixels are considered connected to each other. Count these components.\n3. If exactly one component is found:\n   a. Locate the column index of the single yellow (4) marker pixel.\n   b. If the marker is found, fill this entire column in the output grid with red (2).\n4. If more than one component is found:\n   a. For each individual pattern object:\n      i. Determine its minimum bounding box.\n      ii. Fill the area within that specific bounding box in the output grid with red (2).\n5. If zero pattern objects are found, the output grid remains the background color.\n6. Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_connected_components(grid, target_colors):\n    \"\"\"\n    Finds all connected components of specified colors in the grid.\n    Uses Breadth-First Search (BFS). Adjacent means sharing an edge (not diagonal).\n    \n    Args:\n        grid (np.array): The input grid.\n        target_colors (set): A set of integer color values to consider part of components.\n        \n    Returns:\n        list: A list of sets, where each set contains the (row, col) tuples of a component.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell has a target color and hasn't been visited yet, start a new search\n            if grid[r, c] in target_colors and not visited[r, c]:\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                # Perform BFS\n                while q:\n                    row, col = q.popleft()\n                    component.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if the neighbor is within bounds, has a target color, and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] in target_colors and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the found component to the list if it's not empty\n                if component:\n                    components.append(component)\n                \n    return components\n\ndef get_bounding_box(component):\n    \"\"\"\n    Calculates the minimum bounding box (min_row, min_col, max_row, max_col) \n    for a given component.\n    \n    Args:\n        component (set): A set of (row, col) tuples representing a component.\n        \n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if the component is empty.\n    \"\"\"\n    if not component:\n        return None \n    \n    # Find the min/max row and column indices from the component's coordinates\n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    # Define colors used in the task\n    background_color = 8  # azure\n    pattern_colors = {1, 3} # Blue and Green\n    marker_color_yellow = 4 # Yellow\n    output_color = 2      # Red\n\n    rows, cols = input_grid.shape\n    # Initialize output_grid with the background color\n    output_grid = np.full_like(input_grid, background_color)\n    \n    # Find pattern objects (connected components of blue or green)\n    pattern_objects = find_connected_components(input_grid, pattern_colors)\n    num_pattern_objects = len(pattern_objects)\n\n    # Case 1: Exactly one pattern object\n    if num_pattern_objects == 1:\n        # Find the column of the yellow marker\n        marker_col = -1\n        yellow_locations = np.where(input_grid == marker_color_yellow)\n        # Ensure a yellow marker was actually found\n        if len(yellow_locations[1]) > 0: \n             marker_col = yellow_locations[1][0] # Assume only one yellow marker column is relevant\n        \n        # If a valid marker column was found, fill it\n        if marker_col != -1:\n            output_grid[:, marker_col] = output_color\n        # else: If no yellow marker found, the output grid remains background (as initialized)\n            \n    # Case 2: More than one pattern object\n    elif num_pattern_objects > 1:\n        # Iterate through each found pattern object\n        for component in pattern_objects:\n            # Get the bounding box for the current component\n            bbox = get_bounding_box(component)\n            if bbox:\n                min_r, min_c, max_r, max_c = bbox\n                # Fill the rectangular area defined by the bounding box with the output color\n                # Use slicing for efficient filling\n                output_grid[min_r:max_r+1, min_c:max_c+1] = output_color\n                        \n    # Case 3: Zero pattern objects \n    # No specific action needed as output_grid is already initialized to background.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32116,
    "candidates_token_count": 1430,
    "total_token_count": 33546,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.439934,
  "retries": 1
}