{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid based on the number of distinct contiguous shapes formed by \nthe value 0 in the input grid. The grid also contains a background value (6) \nand a single vertical marker line (5).\n\nTransformation Rules:\n\nCase A: Exactly 2 Shapes of 0s Found\n    1. Replace all input 0s with 6s in the output grid. Preserve other values.\n    2. Find the two shapes (Shape 1 and Shape 2) and their bounding boxes (Bbox).\n       Shape 1 is the one with the smaller minimum row index (r_min).\n       Bbox = (r_min, c_min, r_max, c_max).\n    3. Calculate the coordinates for a single output rectangle of 2s:\n        - rect_height = (Bbox2.r_max - Bbox2.r_min + 1)\n        - top = Bbox1.r_max - rect_height + 1\n        - bottom = Bbox1.r_max\n        - left = Bbox2.r_min + 1\n        - right = Bbox2.r_max + 1\n    4. Fill this calculated rectangle in the output grid with the value 2.\n\nCase B: Number of 0-Shapes is Not 2\n    1. Perform a block shift: Replace original 0 locations with 6, then draw the \n       0s shifted one column to the right in the output grid.\n    2. Find the marker column index `marker_col`.\n    3. Check if any row in the *input* grid contains a \"long\" pattern \n       (0, 6, 6+, 0) - i.e., a 0, followed by two or more 6s, followed by a 0.\n    \n    Subcase B1 (Long pattern exists):\n        - Find all rows `r` in the *input* grid that contain *any* (0, 6+, 0) pattern.\n        - For each such row `r`: Fill the output grid row `r` from column \n          `marker_col + 1` to `width - 1` with 2s.\n\n    Subcase B2 (Only short (0, 6, 0) patterns exist):\n        - Find all rows `r` in the *input* grid that contain the (0, 6, 0) pattern \n          starting at column `c > 0`.\n        - For each such row `r`: Check if any 0 involved in such a pattern instance \n          belongs to the same shape as any 0 in row `r+1`.\n        - If vertically connected: Fill the output grid row `r` from column \n          `marker_col + 1` to `width - 1` with 2s.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_marker_col(grid: list[list[int]], marker_value: int = 5) -> int:\n    \"\"\"Finds the column index of the first occurrence of the marker value.\"\"\"\n    height = len(grid)\n    if height == 0: return -1\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == marker_value:\n                return c\n    return -1 \n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets valid 4-directional neighbors within grid bounds.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_shapes_and_map(grid: list[list[int]], value: int) -> tuple[list[set[tuple[int, int]]], dict[tuple[int, int], int]]:\n    \"\"\"Finds distinct contiguous shapes of a given value using BFS and maps coords to shape IDs.\"\"\"\n    height = len(grid)\n    if height == 0: return [], {}\n    width = len(grid[0])\n    \n    grid_np = np.array(grid) \n    visited = set()\n    shapes = []\n    coord_to_shape_id = {}\n    shape_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid_np[r, c] == value and (r, c) not in visited:\n                shape_id_counter += 1\n                current_shape = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_shape.add((curr_r, curr_c))\n                    coord_to_shape_id[(curr_r, curr_c)] = shape_id_counter\n                    \n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        # Check grid_np for value, not visited set\n                        if grid_np[nr, nc] == value and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_shape:\n                    shapes.append(current_shape)\n                    \n    return shapes, coord_to_shape_id\n\ndef get_bounding_box(shape_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a shape.\"\"\"\n    if not shape_coords:\n        return (-1, -1, -1, -1) \n        \n    min_r = min(r for r, c in shape_coords)\n    min_c = min(c for r, c in shape_coords)\n    max_r = max(r for r, c in shape_coords)\n    max_c = max(c for r, c in shape_coords)\n    return min_r, min_c, max_r, max_c\n\ndef pattern_long_exists(grid: list[list[int]]) -> bool:\n    \"\"\"Checks if any row contains (0, 6, 6+, 0).\"\"\"\n    height = len(grid)\n    if height == 0: return False\n    width = len(grid[0])\n    grid_np = np.array(grid)\n\n    for r in range(height):\n        row = grid_np[r, :]\n        for i in range(width):\n            if row[i] == 0:\n                # Search for the next 0 at least 3 positions away\n                for j in range(i + 3, width): \n                    if row[j] == 0:\n                        # Check if all elements between i and j are 6\n                        if np.all(row[i + 1 : j] == 6):\n                            return True\n    return False\n    \ndef pattern_06plus0_rows(grid: list[list[int]]) -> list[int]:\n    \"\"\"Finds rows containing the pattern (0, 6+, 0).\"\"\"\n    pattern_rows = []\n    height = len(grid)\n    if height == 0: return []\n    width = len(grid[0])\n    grid_np = np.array(grid)\n    \n    for r in range(height):\n        row = grid_np[r,:]\n        found_in_row = False\n        for i in range(width):\n            if row[i] == 0:\n                for j in range(i + 2, width): \n                    if row[j] == 0:\n                        if i + 1 < j and np.all(row[i + 1 : j] == 6):\n                             pattern_rows.append(r)\n                             found_in_row = True\n                             break # Found a pattern in this row, move to next row\n                if found_in_row: break # Optimization\n    return sorted(list(set(pattern_rows))) # Unique rows\n\ndef pattern_060_rows_and_indices_c_gt_0(grid: list[list[int]]) -> dict[int, list[int]]:\n    \"\"\"Finds rows containing (0, 6, 0) starting at c > 0, returns {row: [indices]}.\"\"\"\n    pattern_data = {}\n    height = len(grid)\n    if height == 0: return {}\n    width = len(grid[0])\n    \n    for r in range(height):\n        row_indices = []\n        if width < 3: continue\n        # Start check from c=1\n        for c in range(1, width - 2):\n            if grid[r][c] == 0 and grid[r][c+1] == 6 and grid[r][c+2] == 0:\n                row_indices.append(c)\n        if row_indices:\n            pattern_data[r] = sorted(list(set(row_indices)))\n    return pattern_data\n\ndef check_vertical_connectivity(r: int, c_indices: list[int], height: int, width: int, coord_to_shape_id: dict) -> bool:\n    \"\"\"Checks if any 0 at (r, c) or (r, c+2) for c in c_indices (where c > 0) \n       is connected to a 0 in row r+1.\"\"\"\n    if r + 1 >= height or not c_indices:\n        return False \n\n    connected = False\n    # Iterate through all pattern instances starting at c>0 in this row\n    for c_start in c_indices: \n        # Coordinates of the two 0s in this specific pattern instance\n        coords_in_pattern = []\n        # Ensure coordinates are valid before adding\n        if 0 <= c_start < width: coords_in_pattern.append((r, c_start))\n        if 0 <= c_start + 2 < width: coords_in_pattern.append((r, c_start+2))\n        \n        # Check connectivity for either 0 in this pattern instance\n        for R_PAT, C_PAT in coords_in_pattern:\n            if (R_PAT, C_PAT) in coord_to_shape_id:\n                shape_id = coord_to_shape_id[(R_PAT, C_PAT)]\n                # Check all cells in row r+1 for the same shape ID\n                for c_below in range(width):\n                    coord_below = (r + 1, c_below)\n                    if coord_below in coord_to_shape_id and coord_to_shape_id[coord_below] == shape_id:\n                        connected = True\n                        break # Found connection for this pattern instance's 0\n            if connected: break # Stop checking 0s within this pattern instance if connected\n        if connected: break # Stop checking pattern instances in row r if connected\n        \n    return connected\n\ndef shift_blocks_right(grid: list[list[int]], shapes: list[set[tuple[int, int]]]):\n    \"\"\"Modifies the grid by shifting 0-shapes right by one column.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    \n    # Step 1: Collect all original 0 coordinates\n    original_zero_coords = set().union(*shapes)\n    \n    # Step 2: Replace original 0s with 6s\n    for r, c in original_zero_coords:\n        if 0 <= r < height and 0 <= c < width:\n             grid[r][c] = 6\n             \n    # Step 3: Place 0s shifted one column to the right\n    for r, c in original_zero_coords:\n        if 0 <= r < height and c + 1 < width: # Check bounds for shift\n             grid[r][c + 1] = 0\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \n    # --- Analyze Input ---\n    height = len(input_grid)\n    if height == 0: return []\n    width = len(input_grid[0])\n    \n    shapes, coord_to_shape_id = find_shapes_and_map(input_grid, 0)\n    num_shapes = len(shapes)\n    marker_col = find_marker_col(input_grid, 5)\n    \n    # --- Initialize Output Grid ---\n    output_grid = copy.deepcopy(input_grid)\n\n    # --- Case A: Exactly 2 Shapes ---\n    if num_shapes == 2:\n        # Replace all original 0s with 6\n        for r in range(height):\n            for c in range(width):\n                if output_grid[r][c] == 0:\n                    output_grid[r][c] = 6\n                    \n        # Calculate bounding boxes\n        bboxes = [get_bounding_box(s) for s in shapes]\n        \n        # Sort shapes by min_row to identify Shape 1 and Shape 2\n        if bboxes[0][0] <= bboxes[1][0]:\n            bbox1 = bboxes[0] # r1_min, c1_min, r1_max, c1_max\n            bbox2 = bboxes[1] # r2_min, c2_min, r2_max, c2_max\n        else:\n            bbox1 = bboxes[1]\n            bbox2 = bboxes[0]\n            \n        r1_min, c1_min, r1_max, c1_max = bbox1\n        r2_min, c2_min, r2_max, c2_max = bbox2\n\n        # Check if bboxes are valid before calculating dims\n        if r1_min != -1 and r2_min != -1:\n            # Calculate output rectangle coordinates based on refined rule\n            rect_height = (r2_max - r2_min + 1)\n            top_row = r1_max - rect_height + 1\n            bottom_row = r1_max\n            left_col = r2_min + 1\n            right_col = r2_max + 1\n            \n            # Fill the output rectangle with 2s\n            for r in range(top_row, bottom_row + 1):\n                for c in range(left_col, right_col + 1):\n                    if 0 <= r < height and 0 <= c < width: # Check bounds\n                        output_grid[r][c] = 2\n\n    # --- Case B: Not Exactly 2 Shapes ---\n    else:\n        # Perform the block shift (modifies output_grid)\n        shift_blocks_right(output_grid, shapes)\n        \n        # Determine subcase: long pattern exists in *input*?\n        has_long = pattern_long_exists(input_grid)\n\n        if has_long:\n            # Subcase B1: Long pattern exists\n            rows_to_fill = pattern_06plus0_rows(input_grid)\n            for r in rows_to_fill:\n                # Fill row r from marker_col + 1 to end\n                for c in range(marker_col + 1, width):\n                     if 0 <= r < height and 0 <= c < width: # Bounds check (r,c already in bounds)\n                         output_grid[r][c] = 2\n        else:\n            # Subcase B2: Only short (0, 6, 0) patterns potentially relevant\n            # Find rows with (0,6,0) starting at c > 0 in the *input* grid\n            pattern_060_data = pattern_060_rows_and_indices_c_gt_0(input_grid)\n            rows_to_fill = []\n            for r, c_indices in pattern_060_data.items():\n                # Check vertical connectivity for this row using input grid shapes/map\n                is_connected = check_vertical_connectivity(r, c_indices, height, width, coord_to_shape_id)\n                if is_connected:\n                    rows_to_fill.append(r)\n            \n            # Fill eligible rows\n            for r in rows_to_fill:\n                 # Fill row r from marker_col + 1 to end\n                for c in range(marker_col + 1, width):\n                     if 0 <= r < height and 0 <= c < width: # Bounds check\n                         output_grid[r][c] = 2\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 44051,
    "candidates_token_count": 4628,
    "total_token_count": 48679,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.947897,
  "retries": 1
}