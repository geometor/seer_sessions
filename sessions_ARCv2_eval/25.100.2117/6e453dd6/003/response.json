{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid based on the presence or absence of a specific horizontal \npattern `(0, 6+, 0)` (a 0, followed by one or more 6s, followed by a 0) \nwithin any row of the input grid. The grid also contains a background value (6) \nand a single vertical marker line (5).\n\nTransformation Rules:\n\nCase 1: Pattern (0, 6+, 0) is Present\n    - All 0s in the input grid are shifted one column to the right in the output grid.\n    - The original locations of the input 0s are filled with the background value 6.\n    - For every row in the *input* grid that contained the (0, 6+, 0) pattern, \n      the corresponding row in the *output* grid has cells filled with 2s, \n      starting from the column immediately to the right of the marker line (5) \n      and extending to the right edge of the grid.\n\nCase 2: Pattern (0, 6+, 0) is Absent\n    - All 0s in the input grid are replaced by the background value 6.\n    - The input grid is expected to contain exactly two distinct contiguous shapes \n      formed by 0s.\n    - The bounding boxes of these two input shapes are determined.\n    - A single rectangular area is filled with 2s in the output grid. The \n      coordinates of this rectangle are derived from a combination of the \n      min/max row/col indices of the two input shapes' bounding boxes:\n        - top_row = shape1.min_col\n        - bottom_row = shape1.max_row\n        - left_col = shape2.min_row + 1\n        - right_col = shape2.max_row + 1\n      (Where shape1 is the shape with the smaller min_row index).\n\nThe marker line (5) is always preserved in its original position.\n\"\"\"\n\ndef find_marker_col(grid: list[list[int]], marker_value: int) -> int:\n    \"\"\"Finds the column index of the first occurrence of the marker value.\"\"\"\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == marker_value:\n                return c\n    return -1 # Should not happen based on problem description\n\ndef pattern_06plus0(row: list[int]) -> bool:\n    \"\"\"Checks if a row contains the pattern (0, 6+, 0).\"\"\"\n    n = len(row)\n    for i in range(n):\n        if row[i] == 0:\n            for j in range(i + 2, n): # Need at least one 6 in between\n                if row[j] == 0:\n                    # Check if all elements between i and j are 6\n                    all_sixes = True\n                    for k in range(i + 1, j):\n                        if row[k] != 6:\n                            all_sixes = False\n                            break\n                    if all_sixes:\n                        return True\n            # Optimization: if we found a 0 at i, we don't need to re-check\n            # pairs starting before the next 0 found after the inner loop.\n            # But simpler implementation is fine for typical grid sizes.\n    return False\n\ndef check_pattern_in_grid(grid: list[list[int]]) -> bool:\n    \"\"\"Checks if the (0, 6+, 0) pattern exists in any row of the grid.\"\"\"\n    for row in grid:\n        if pattern_06plus0(row):\n            return True\n    return False\n\ndef find_all_coords(grid: list[list[int]], value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds coordinates of all cells with a specific value.\"\"\"\n    coords = []\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == value:\n                coords.append((r, c))\n    return coords\n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets valid 4-directional neighbors within grid bounds.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_shapes(grid: list[list[int]], value: int) -> list[set[tuple[int, int]]]:\n    \"\"\"Finds distinct contiguous shapes of a given value using BFS.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    shapes = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == value and (r, c) not in visited:\n                # Start BFS for a new shape\n                current_shape = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_shape.add((curr_r, curr_c))\n                    \n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        if grid[nr][nc] == value and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_shape:\n                    shapes.append(current_shape)\n                    \n    return shapes\n\ndef get_bounding_box(shape_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a shape.\"\"\"\n    if not shape_coords:\n        return (-1, -1, -1, -1) # Or raise error\n        \n    min_r = min(r for r, c in shape_coords)\n    min_c = min(c for r, c in shape_coords)\n    max_r = max(r for r, c in shape_coords)\n    max_c = max(c for r, c in shape_coords)\n    return min_r, min_c, max_r, max_c\n\n# --------------------------------------------------------------------------\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules based on the (0, 6+, 0) pattern.\n    \"\"\"\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # --- Initialization and Analysis ---\n    output_grid = copy.deepcopy(input_grid)\n    marker_col = find_marker_col(input_grid, 5)\n    pattern_found = check_pattern_in_grid(input_grid)\n    zero_coords = find_all_coords(input_grid, 0)\n    \n    # --- Case 1: Pattern (0, 6+, 0) Found ---\n    if pattern_found:\n        # Step 1: Replace original 0s with 6s\n        for r, c in zero_coords:\n            if 0 <= r < height and 0 <= c < width:\n                 output_grid[r][c] = 6\n                 \n        # Step 2: Place 0s shifted one column to the right\n        for r, c in zero_coords:\n            if 0 <= r < height and c + 1 < width: # Check bounds for shift\n                 output_grid[r][c + 1] = 0\n                 \n        # Step 3: Draw horizontal lines of 2s for rows containing the pattern\n        for r_in in range(height):\n            if pattern_06plus0(input_grid[r_in]): # Check original input row\n                for c_out in range(marker_col + 1, width):\n                     if 0 <= r_in < height and 0 <= c_out < width: # Bounds check\n                         output_grid[r_in][c_out] = 2\n                         \n    # --- Case 2: Pattern (0, 6+, 0) Not Found ---\n    else:\n        # Step 1: Replace all 0s with 6s\n        for r, c in zero_coords:\n             if 0 <= r < height and 0 <= c < width:\n                 output_grid[r][c] = 6\n                 \n        # Step 2: Find the two shapes of 0s in the *original* input\n        # Use the pre-calculated zero_coords to potentially speed up find_shapes,\n        # but using the standard find_shapes on the input grid is more robust.\n        shapes = find_shapes(input_grid, 0)\n        \n        # Assuming exactly two shapes exist if pattern is not found\n        if len(shapes) == 2:\n            # Step 3: Calculate bounding boxes\n            bboxes = [get_bounding_box(s) for s in shapes]\n            \n            # Step 4: Sort shapes by min_row to identify Shape 1 and Shape 2\n            # Shape 1 has the smaller min_row\n            if bboxes[0][0] <= bboxes[1][0]:\n                bbox1 = bboxes[0] # r1_min, c1_min, r1_max, c1_max\n                bbox2 = bboxes[1] # r2_min, c2_min, r2_max, c2_max\n            else:\n                bbox1 = bboxes[1]\n                bbox2 = bboxes[0]\n                \n            # Step 5: Calculate output rectangle coordinates\n            r1_min, c1_min, r1_max, c1_max = bbox1\n            r2_min, c2_min, r2_max, c2_max = bbox2\n            \n            top_row = c1_min\n            bottom_row = r1_max\n            left_col = r2_min + 1\n            right_col = r2_max + 1\n            \n            # Step 6: Fill the output rectangle with 2s\n            for r in range(top_row, bottom_row + 1):\n                for c in range(left_col, right_col + 1):\n                    if 0 <= r < height and 0 <= c < width: # Check bounds\n                        output_grid[r][c] = 2\n        # else: handle cases with not exactly 2 shapes if necessary\n        # (e.g., return the grid with 0s replaced by 6s)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8558,
    "candidates_token_count": 3573,
    "total_token_count": 12131,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.84888,
  "retries": 1
}