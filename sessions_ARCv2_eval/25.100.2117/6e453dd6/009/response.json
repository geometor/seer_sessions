{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid based on prioritized conditions applied to the input grid. \nThe transformation always involves shifting blocks of 0s one column to the right. \nThe placement of the output value '2' depends on which condition is met first:\n\n1. Condition B1 (Long Pattern): If the input grid contains any row with the pattern (0, 6, 6+, 0).\n2. Condition A (2 Shapes with Short Patterns): If Condition B1 is false, and the input has exactly two 0-shapes, and both shapes contain the (0, 6, 0) pattern.\n3. Condition B2 (Connectivity Check): If neither B1 nor A is met.\n\nTransformation Details:\n\nUniversal Step: Block Shift\n    - Initialize output grid from input.\n    - Find all 0-shapes (contiguous blocks of 0s) in the input.\n    - In the output grid, replace the original locations of these 0s with 6.\n    - In the output grid, place 0s at the locations corresponding to the original 0s shifted one column right (respecting grid boundaries).\n\n'2' Placement Rules (applied to the shifted grid):\n\n- If Condition B1 Met:\n    - Find all rows `r` in the *input* grid containing any (0, 6+, 0) pattern.\n    - For each such unique row `r`, fill the output grid cells `output_grid[r][c]` with 2 for columns `c` from `marker_col + 1` to `width - 1`.\n\n- If Condition A Met:\n    - Identify the top shape (Shape1, smaller min_row) and bottom shape (Shape2). Get their bounding boxes (Bbox1, Bbox2).\n    - Find the row indices (`R2_rows`) within Shape2 (in the input grid) that contain the (0, 6, 0) pattern.\n    - Fill Block 1: `output_grid[r][c] = 2` for `r` from 4 to `Bbox1.rmax` and `c` from `marker_col + 1` to `marker_col + 4`.\n    - Fill Block 2: `output_grid[r][c] = 2` for `r` from `min(R2_rows)` to `Bbox2.rmax` and `c` from `marker_col + 1` to `marker_col + 4`. (Handle case where R2_rows is empty?). Assume R2_rows will not be empty if condition A is met.\n\n- If Condition B2 Met:\n    - Find all rows `r` in the *input* grid containing the (0, 6, 0) pattern starting at column `c > 0`.\n    - Check if these pattern instances are vertically connected (any 0 in the pattern at `r` belongs to the same shape as any 0 at `r+1`).\n    - Identify the unique set of connected rows `r`.\n    - For each such unique row `r`, fill the output grid cells `output_grid[r][c]` with 2 for columns `c` from `marker_col + 1` to `width - 1`.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_marker_col(grid: list[list[int]], marker_value: int = 5) -> int:\n    \"\"\"Finds the column index of the first occurrence of the marker value.\"\"\"\n    height = len(grid)\n    if height == 0: return -1\n    width = len(grid[0]) if height > 0 else 0\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == marker_value:\n                return c\n    return -1 \n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets valid 4-directional neighbors within grid bounds.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_shapes_and_map(grid: list[list[int]], value: int) -> tuple[list[set[tuple[int, int]]], dict[tuple[int, int], int]]:\n    \"\"\"Finds distinct contiguous shapes of a given value using BFS and maps coords to shape IDs.\"\"\"\n    height = len(grid)\n    if height == 0: return [], {}\n    width = len(grid[0]) if height > 0 else 0\n    \n    grid_np = np.array(grid) \n    visited = set()\n    shapes = []\n    coord_to_shape_id = {}\n    shape_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid_np[r, c] == value and (r, c) not in visited:\n                shape_id_counter += 1\n                current_shape = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_shape.add((curr_r, curr_c))\n                    coord_to_shape_id[(curr_r, curr_c)] = shape_id_counter\n                    \n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        # Check grid_np for value, not visited set\n                        if grid_np[nr, nc] == value and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_shape:\n                    shapes.append(current_shape)\n                    \n    return shapes, coord_to_shape_id\n\ndef get_bounding_box(shape_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a shape.\"\"\"\n    if not shape_coords:\n        return (-1, -1, -1, -1) \n        \n    min_r = min(r for r, c in shape_coords)\n    min_c = min(c for r, c in shape_coords)\n    max_r = max(r for r, c in shape_coords)\n    max_c = max(c for r, c in shape_coords)\n    return min_r, min_c, max_r, max_c\n\ndef pattern_long_exists(grid: list[list[int]]) -> bool:\n    \"\"\"Checks if any row contains (0, 6, 6+, 0).\"\"\"\n    height = len(grid)\n    if height == 0: return False\n    width = len(grid[0]) if height > 0 else 0\n    grid_np = np.array(grid)\n\n    for r in range(height):\n        row = grid_np[r, :]\n        for i in range(width):\n            if row[i] == 0:\n                # Search for the next 0 at least 3 positions away\n                for j in range(i + 3, width): \n                    if row[j] == 0:\n                        # Check if all elements between i and j are 6\n                        if i + 1 < j and np.all(row[i + 1 : j] == 6):\n                            return True\n    return False\n    \ndef pattern_06plus0_rows(grid: list[list[int]]) -> list[int]:\n    \"\"\"Finds rows containing the pattern (0, 6+, 0).\"\"\"\n    pattern_rows = set()\n    height = len(grid)\n    if height == 0: return []\n    width = len(grid[0]) if height > 0 else 0\n    grid_np = np.array(grid)\n    \n    for r in range(height):\n        row = grid_np[r,:]\n        found_in_row = False\n        for i in range(width):\n            if row[i] == 0:\n                for j in range(i + 2, width): \n                    if row[j] == 0:\n                        if i + 1 < j and np.all(row[i + 1 : j] == 6):\n                             pattern_rows.add(r)\n                             found_in_row = True\n                             break # Found a pattern in this row, move to next row\n                if found_in_row: break # Optimization\n    return sorted(list(pattern_rows)) # Unique rows\n\ndef pattern_060_indices_in_row(row_list: list[int]) -> list[int]:\n    \"\"\"Finds starting column indices of (0, 6, 0) patterns in a single row list.\"\"\"\n    indices = []\n    n = len(row_list)\n    if n < 3: return indices\n    for c in range(n - 2):\n        if row_list[c] == 0 and row_list[c+1] == 6 and row_list[c+2] == 0:\n            indices.append(c)\n    return indices\n\ndef shape_contains_060(shape_coords: set[tuple[int,int]], grid: list[list[int]]) -> bool:\n    \"\"\"Checks if a shape contains any (0, 6, 0) pattern within its rows.\"\"\"\n    if not shape_coords: return False\n    rows_in_shape = set(r for r,c in shape_coords)\n    height = len(grid)\n    \n    for r in rows_in_shape:\n        if 0 <= r < height: # Ensure row index is valid\n             indices = pattern_060_indices_in_row(grid[r])\n             for c_start in indices:\n                 # Check if both 0s of the pattern are within the shape coordinates\n                 if (r, c_start) in shape_coords and (r, c_start + 2) in shape_coords:\n                     return True # Found one instance\n    return False # No instance found\n\ndef get_rows_with_060_in_shape(shape_coords: set[tuple[int,int]], grid: list[list[int]]) -> list[int]:\n    \"\"\"Finds row indices within a shape that contain a (0, 6, 0) pattern using only shape coordinates.\"\"\"\n    rows = set()\n    if not shape_coords: return []\n    shape_rows = sorted(list(set(r for r,c in shape_coords)))\n    height = len(grid)\n    \n    for r in shape_rows:\n         if 0 <= r < height: # Ensure row index is valid\n             indices = pattern_060_indices_in_row(grid[r])\n             for c_start in indices:\n                 # Check if both 0s of the pattern are part of this shape\n                 if (r, c_start) in shape_coords and (r, c_start + 2) in shape_coords:\n                     rows.add(r)\n                     break # Move to next row once found in this one\n    return sorted(list(rows))\n\n\ndef pattern_060_rows_and_indices_c_gt_0(grid: list[list[int]]) -> dict[int, list[int]]:\n    \"\"\"Finds rows containing (0, 6, 0) starting at c > 0, returns {row: [indices]}.\"\"\"\n    pattern_data = {}\n    height = len(grid)\n    if height == 0: return {}\n    width = len(grid[0]) if height > 0 else 0\n    \n    for r in range(height):\n        row_indices = []\n        if width < 3: continue\n        # Start check from c=1\n        for c in range(1, width - 2):\n            if grid[r][c] == 0 and grid[r][c+1] == 6 and grid[r][c+2] == 0:\n                row_indices.append(c)\n        if row_indices:\n            pattern_data[r] = sorted(list(set(row_indices)))\n    return pattern_data\n\ndef check_vertical_connectivity(r: int, c_indices: list[int], height: int, width: int, coord_to_shape_id: dict) -> bool:\n    \"\"\"Checks if any 0 at (r, c) or (r, c+2) for c in c_indices (where c > 0) \n       is connected to a 0 in row r+1.\"\"\"\n    if r + 1 >= height or not c_indices:\n        return False \n\n    connected = False\n    # Iterate through all pattern instances starting at c>0 in this row\n    for c_start in c_indices: \n        # Coordinates of the two 0s in this specific pattern instance\n        coords_in_pattern = []\n        # Ensure coordinates are valid before adding\n        if 0 <= c_start < width: coords_in_pattern.append((r, c_start))\n        if 0 <= c_start + 2 < width: coords_in_pattern.append((r, c_start+2))\n        \n        # Check connectivity for either 0 in this pattern instance\n        for R_PAT, C_PAT in coords_in_pattern:\n            if (R_PAT, C_PAT) in coord_to_shape_id:\n                shape_id = coord_to_shape_id[(R_PAT, C_PAT)]\n                # Check all cells in row r+1 for the same shape ID\n                for c_below in range(width):\n                    coord_below = (r + 1, c_below)\n                    # Check if coord_below has a shape ID and if it matches\n                    if coord_below in coord_to_shape_id and coord_to_shape_id[coord_below] == shape_id:\n                        connected = True\n                        break # Found connection for this pattern instance's 0\n            if connected: break # Stop checking 0s within this pattern instance if connected\n        if connected: break # Stop checking pattern instances in row r if connected\n        \n    return connected\n\ndef apply_shift_blocks_right(grid: list[list[int]], shapes: list[set[tuple[int, int]]]):\n    \"\"\"Modifies the grid IN-PLACE by shifting 0-shapes right by one column.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    \n    # Step 1: Collect all original 0 coordinates\n    original_zero_coords = set().union(*shapes) if shapes else set()\n    \n    # Step 2: Replace original 0s with 6s\n    for r, c in original_zero_coords:\n        if 0 <= r < height and 0 <= c < width:\n             grid[r][c] = 6\n             \n    # Step 3: Place 0s shifted one column to the right\n    for r, c in original_zero_coords:\n        if 0 <= r < height and c + 1 < width: # Check bounds for shift\n             grid[r][c + 1] = 0\n\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \n    # --- Analyze Input ---\n    height = len(input_grid)\n    if height == 0: return []\n    width = len(input_grid[0]) if height > 0 else 0\n    if width == 0: return copy.deepcopy(input_grid) # Handle empty rows\n    \n    shapes, coord_to_shape_id = find_shapes_and_map(input_grid, 0)\n    num_shapes = len(shapes)\n    marker_col = find_marker_col(input_grid, 5)\n    if marker_col == -1: marker_col = width # Handle case where marker isn't found? Set to edge?\n\n    # --- Initialize Output Grid & Apply Block Shift ---\n    output_grid = copy.deepcopy(input_grid)\n    apply_shift_blocks_right(output_grid, shapes) # Modifies output_grid in place\n\n    # --- Determine and Apply '2' Placement Rule (Prioritized) ---\n\n    # Condition B1: Check for long pattern in INPUT grid\n    has_long = pattern_long_exists(input_grid)\n    if has_long:\n        rows_to_fill = pattern_06plus0_rows(input_grid)\n        for r in rows_to_fill:\n            # Fill row r from marker_col + 1 to end\n            for c in range(marker_col + 1, width):\n                if 0 <= r < height and 0 <= c < width: # Bounds check\n                    output_grid[r][c] = 2\n    \n    # Condition A: Check if B1 is false, num_shapes is 2, and both shapes contain (0,6,0) in INPUT grid\n    elif num_shapes == 2 and shape_contains_060(shapes[0], input_grid) and shape_contains_060(shapes[1], input_grid):\n        # Sort shapes by min_row to identify Shape 1 (top) and Shape 2 (bottom)\n        bboxes = [get_bounding_box(s) for s in shapes]\n        s1_coords, s2_coords = (shapes[0], shapes[1]) if bboxes[0][0] <= bboxes[1][0] else (shapes[1], shapes[0])\n        bbox1 = get_bounding_box(s1_coords)\n        bbox2 = get_bounding_box(s2_coords)\n        \n        r1_min, c1_min, r1_max, c1_max = bbox1\n        r2_min, c2_min, r2_max, c2_max = bbox2\n\n        # Find rows in Shape 2 (input grid) that contain the pattern\n        rows_with_060_shape2 = get_rows_with_060_in_shape(s2_coords, input_grid)\n        \n        # Check if bboxes and rows list are valid before proceeding\n        if r1_min != -1 and r2_min != -1:\n            # Fill Block 1\n            # Start row is fixed at 4 based on Example 1 observation\n            start_row_block1 = 4 \n            end_row_block1 = r1_max\n            start_col_block1 = marker_col + 1\n            end_col_block1 = marker_col + 4 # Inclusive range? Yes, seems to be 4 wide.\n            \n            for r in range(start_row_block1, end_row_block1 + 1):\n                for c in range(start_col_block1, end_col_block1 + 1):\n                    if 0 <= r < height and 0 <= c < width: # Check bounds\n                        output_grid[r][c] = 2\n                        \n            # Fill Block 2 (Only if rows_with_060_shape2 is not empty)\n            if rows_with_060_shape2:\n                start_row_block2 = min(rows_with_060_shape2)\n                end_row_block2 = r2_max\n                # Columns are the same as block 1\n                start_col_block2 = marker_col + 1\n                end_col_block2 = marker_col + 4\n                \n                for r in range(start_row_block2, end_row_block2 + 1):\n                    for c in range(start_col_block2, end_col_block2 + 1):\n                        if 0 <= r < height and 0 <= c < width: # Check bounds\n                            output_grid[r][c] = 2\n\n    # Condition B2: Default case if B1 and A are false\n    else:\n        # Find rows with (0,6,0) starting at c > 0 in the *input* grid\n        pattern_060_data = pattern_060_rows_and_indices_c_gt_0(input_grid)\n        connected_rows_to_fill = []\n        for r, c_indices in pattern_060_data.items():\n            # Check vertical connectivity using input grid shapes/map\n            is_connected = check_vertical_connectivity(r, c_indices, height, width, coord_to_shape_id)\n            if is_connected:\n                connected_rows_to_fill.append(r)\n        \n        # Fill eligible rows\n        for r in connected_rows_to_fill:\n            # Fill row r from marker_col + 1 to end\n            for c in range(marker_col + 1, width):\n                if 0 <= r < height and 0 <= c < width: # Bounds check\n                    output_grid[r][c] = 2\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 63360,
    "candidates_token_count": 5784,
    "total_token_count": 69144,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 36.018231,
  "retries": 1
}