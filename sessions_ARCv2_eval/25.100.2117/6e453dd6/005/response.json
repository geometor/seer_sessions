{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid based on the number of distinct contiguous shapes formed by \nthe value 0 in the input grid. The grid also contains a background value (6) \nand a single vertical marker line (5).\n\nTransformation Rules:\n\nCase A: Exactly 2 Shapes of 0s Found (e.g., train_1)\n    1. Replace all input 0s with 6s in the output grid. Preserve other values.\n    2. Find the two shapes (Shape 1 and Shape 2) and their bounding boxes (Bbox).\n       Shape 1 is the one with the smaller minimum row index (r_min).\n       Bbox = (r_min, c_min, r_max, c_max).\n    3. Calculate the coordinates for a single output rectangle of 2s:\n        - height = (Bbox2.r_max - Bbox2.r_min + 1)\n        - top = Bbox1.r_max - height + 1\n        - bottom = Bbox1.r_max\n        - left = Bbox2.r_min + 1\n        - right = Bbox2.r_max + 1\n    4. Fill this calculated rectangle in the output grid with the value 2.\n\nCase B: Number of 0-Shapes is Not 2 (e.g., train_2, train_3)\n    1. Create the base output grid by replacing all input 0s with 6s. Preserve others.\n    2. Find the original coordinates of all input 0s.\n    3. Shift these 0s one column to the right, placing 0s in the output grid \n       at the new coordinates (r, c+1), checking bounds.\n    4. Find the marker column index `marker_col`.\n    5. Check if any row in the *input* grid contains a \"long\" pattern \n       (0, 6, 6+, 0) - i.e., a 0, followed by two or more 6s, followed by a 0.\n    \n    Subcase B1 (Long pattern exists - e.g., train_3):\n        - Find all rows `r` in the *input* grid that contain *any* (0, 6+, 0) pattern.\n        - For each such row `r`:\n            - Calculate columns: `left = marker_col + 1`, `right = width - 1`.\n            - Fill the output grid row `r` from `left` to `right` with 2s.\n\n    Subcase B2 (Only short (0, 6, 0) patterns exist - e.g., train_2):\n        - Find a map of input 0 coordinates to their shape IDs.\n        - Find all rows `r` in the *input* grid that contain the (0, 6, 0) pattern.\n        - For each such row `r`:\n            - Check if any 0 involved in a (0, 6, 0) pattern instance in row `r` \n              belongs to the same shape as any 0 in row `r+1`.\n            - If vertically connected:\n                - Calculate columns: `left = marker_col + 2`, `right = marker_col + 4`.\n                - Fill the output grid in row `r` from `left` to `right` with 2s.\n                - Fill the output grid in row `r+1` from `left` to `right` with 2s \n                  (checking bounds).\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_marker_col(grid: list[list[int]], marker_value: int = 5) -> int:\n    \"\"\"Finds the column index of the first occurrence of the marker value.\"\"\"\n    height = len(grid)\n    if height == 0: return -1\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == marker_value:\n                return c\n    return -1 # Should not happen based on problem description\n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets valid 4-directional neighbors within grid bounds.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef find_shapes_and_map(grid: list[list[int]], value: int) -> tuple[list[set[tuple[int, int]]], dict[tuple[int, int], int]]:\n    \"\"\"Finds distinct contiguous shapes of a given value using BFS and maps coords to shape IDs.\"\"\"\n    height = len(grid)\n    if height == 0: return [], {}\n    width = len(grid[0])\n    \n    grid_np = np.array(grid) # Use numpy for efficient access if large\n    visited = set()\n    shapes = []\n    coord_to_shape_id = {}\n    shape_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid_np[r, c] == value and (r, c) not in visited:\n                shape_id_counter += 1\n                current_shape = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_shape.add((curr_r, curr_c))\n                    coord_to_shape_id[(curr_r, curr_c)] = shape_id_counter\n                    \n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        if grid_np[nr, nc] == value and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_shape:\n                    shapes.append(current_shape)\n                    \n    return shapes, coord_to_shape_id\n\ndef get_bounding_box(shape_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a shape.\"\"\"\n    if not shape_coords:\n        return (-1, -1, -1, -1) \n        \n    min_r = min(r for r, c in shape_coords)\n    min_c = min(c for r, c in shape_coords)\n    max_r = max(r for r, c in shape_coords)\n    max_c = max(c for r, c in shape_coords)\n    return min_r, min_c, max_r, max_c\n\ndef find_all_coords(grid: list[list[int]], value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds coordinates of all cells with a specific value.\"\"\"\n    coords = []\n    height = len(grid)\n    if height == 0: return []\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == value:\n                coords.append((r, c))\n    return coords\n\ndef pattern_06plus0_rows(grid: list[list[int]]) -> list[int]:\n    \"\"\"Finds rows containing the pattern (0, 6+, 0).\"\"\"\n    pattern_rows = []\n    height = len(grid)\n    if height == 0: return []\n    width = len(grid[0])\n    grid_np = np.array(grid)\n    \n    for r in range(height):\n        row = grid_np[r,:]\n        found_in_row = False\n        for i in range(width):\n            if row[i] == 0:\n                for j in range(i + 2, width): \n                    if row[j] == 0:\n                        if i + 1 < j and np.all(row[i + 1 : j] == 6):\n                             pattern_rows.append(r)\n                             found_in_row = True\n                             break # Found a pattern in this row, move to next row\n                if found_in_row: break # Optimization\n    return sorted(list(set(pattern_rows))) # Unique rows\n\ndef pattern_long_exists(grid: list[list[int]]) -> bool:\n    \"\"\"Checks if any row contains (0, 6, 6+, 0).\"\"\"\n    height = len(grid)\n    if height == 0: return False\n    width = len(grid[0])\n    grid_np = np.array(grid)\n\n    for r in range(height):\n        row = grid_np[r, :]\n        for i in range(width):\n            if row[i] == 0:\n                # Search for the next 0 at least 3 positions away (needs >=2 sixes)\n                for j in range(i + 3, width): \n                    if row[j] == 0:\n                        # Check if all elements between i and j are 6\n                        if np.all(row[i + 1 : j] == 6):\n                            return True\n                        # Optimization: If non-6 found, no need to check further j for this i? Maybe...\n                        # if not np.all(row[i + 1 : j] == 6): break # Probably not safe\n    return False\n\ndef pattern_060_rows_and_indices(grid: list[list[int]]) -> dict[int, list[int]]:\n    \"\"\"Finds rows containing (0, 6, 0) and the starting column indices.\"\"\"\n    pattern_data = {}\n    height = len(grid)\n    if height == 0: return {}\n    width = len(grid[0])\n    \n    for r in range(height):\n        row_indices = []\n        if width < 3: continue\n        for c in range(width - 2):\n            if grid[r][c] == 0 and grid[r][c+1] == 6 and grid[r][c+2] == 0:\n                row_indices.append(c)\n        if row_indices:\n            pattern_data[r] = row_indices\n    return pattern_data\n\ndef check_vertical_connectivity(r: int, c_indices: list[int], height: int, width: int, coord_to_shape_id: dict) -> bool:\n    \"\"\"Checks if any 0 at (r, c) or (r, c+2) for c in c_indices is connected to a 0 in row r+1.\"\"\"\n    if r + 1 >= height:\n        return False # Cannot connect below if it's the last row\n\n    connected = False\n    for c_start in c_indices:\n        # Coordinates of the two 0s in the pattern (r, c_start) and (r, c_start+2)\n        coords_in_pattern = []\n        if 0 <= c_start < width: coords_in_pattern.append((r, c_start))\n        if 0 <= c_start + 2 < width: coords_in_pattern.append((r, c_start+2))\n        \n        for R_PAT, C_PAT in coords_in_pattern:\n            if (R_PAT, C_PAT) in coord_to_shape_id:\n                shape_id = coord_to_shape_id[(R_PAT, C_PAT)]\n                # Check all cells in row r+1 for the same shape ID\n                for c_below in range(width):\n                    coord_below = (r + 1, c_below)\n                    if coord_below in coord_to_shape_id and coord_to_shape_id[coord_below] == shape_id:\n                        connected = True\n                        break # Found connection for this pattern instance\n            if connected: break # Found connection for this pattern instance\n        if connected: break # Found connection for this row\n    return connected\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules based on the number of 0-shapes.\n    \"\"\"\n    height = len(input_grid)\n    if height == 0: return []\n    width = len(input_grid[0])\n    \n    # --- Analyze Input ---\n    shapes, coord_to_shape_id = find_shapes_and_map(input_grid, 0)\n    num_shapes = len(shapes)\n    marker_col = find_marker_col(input_grid, 5)\n    original_zero_coords = find_all_coords(input_grid, 0)\n\n    # --- Initialize Output Grid (common step: replace 0s with 6s) ---\n    output_grid = copy.deepcopy(input_grid)\n    for r, c in original_zero_coords:\n        output_grid[r][c] = 6\n\n    # --- Case A: Exactly 2 Shapes ---\n    if num_shapes == 2:\n        # Calculate bounding boxes\n        bboxes = [get_bounding_box(s) for s in shapes]\n        \n        # Sort shapes by min_row to identify Shape 1 and Shape 2\n        # Shape 1 has the smaller min_row\n        if bboxes[0][0] <= bboxes[1][0]:\n            bbox1 = bboxes[0] # r1_min, c1_min, r1_max, c1_max\n            bbox2 = bboxes[1] # r2_min, c2_min, r2_max, c2_max\n        else:\n            bbox1 = bboxes[1]\n            bbox2 = bboxes[0]\n            \n        r1_min, c1_min, r1_max, c1_max = bbox1\n        r2_min, c2_min, r2_max, c2_max = bbox2\n\n        # Check if bboxes are valid before calculating dims\n        if r1_min != -1 and r2_min != -1:\n            # Calculate output rectangle coordinates based on refined rule\n            h = (r2_max - r2_min + 1)\n            top = r1_max - h + 1\n            bottom = r1_max\n            left = r2_min + 1\n            right = r2_max + 1\n            \n            # Fill the output rectangle with 2s\n            for r in range(top, bottom + 1):\n                for c in range(left, right + 1):\n                    if 0 <= r < height and 0 <= c < width: # Check bounds\n                        output_grid[r][c] = 2\n                        \n    # --- Case B: Not Exactly 2 Shapes ---\n    else:\n        # Shift original 0s right by 1 (modifies output_grid further)\n        for r, c in original_zero_coords:\n            if c + 1 < width: # Check bounds for shift\n                 output_grid[r][c + 1] = 0\n\n        # Determine subcase: long pattern exists?\n        has_long = pattern_long_exists(input_grid)\n\n        if has_long:\n            # Subcase B1: Long pattern exists\n            rows_with_pattern = pattern_06plus0_rows(input_grid)\n            for r in rows_with_pattern:\n                left = marker_col + 1\n                right = width - 1 # Inclusive\n                for c in range(left, right + 1):\n                     if 0 <= r < height and 0 <= c < width: # Check bounds\n                         output_grid[r][c] = 2\n        else:\n            # Subcase B2: Only short (0, 6, 0) patterns\n            pattern_060_data = pattern_060_rows_and_indices(input_grid)\n            for r, c_indices in pattern_060_data.items():\n                # Check vertical connectivity for this row\n                is_connected = check_vertical_connectivity(r, c_indices, height, width, coord_to_shape_id)\n                \n                if is_connected:\n                    left = marker_col + 2\n                    right = marker_col + 4 # Inclusive\n                    \n                    # Fill row r\n                    for c in range(left, right + 1):\n                        if 0 <= r < height and 0 <= c < width:\n                            output_grid[r][c] = 2\n                            \n                    # Fill row r+1\n                    r_below = r + 1\n                    if r_below < height:\n                         for c in range(left, right + 1):\n                            if 0 <= c < width: # Row bound already checked\n                                output_grid[r_below][c] = 2\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24881,
    "candidates_token_count": 7221,
    "total_token_count": 32102,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 47.326648,
  "retries": 1
}