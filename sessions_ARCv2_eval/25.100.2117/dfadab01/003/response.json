{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nTransforms an input grid based on specific digit patterns and locations:\n\n1.  Finds all occurrences of digit '2' and draws a 4x4 hollow square using '4' at each location in the output.\n2.  Finds all top-left corners (r, c) of 2x2 blocks filled with '6' and draws a 2x2 block of '6' at (r-1, c-1) in the output.\n3.  Finds all top-left corners (r, c) of 4x4 hollow squares filled with '1' and draws a 4x4 hollow square of '1' at (r, c+1) in the output.\n4.  Identifies \"FiveThreeRectangles\" formed by '5's in the top row and '3's in the bottom row. For each rectangle defined by corners (r1, c1), (r1, c2), (r2, c1), (r2, c2), it draws four 2x2 blocks of '6' in the output at locations (r1, c1), (r1, c2), (r2-3, c1), and (r2-3, c2). It tracks the '3's used in these rectangles.\n5.  Processes remaining '3's (not part of FiveThreeRectangles). If vertical pairs exist, it finds the pair with the lowest bottom '3' and draws a 4x4 hollow square of '1' at that bottom '3's location. If no vertical pairs exist, it finds the topmost, then leftmost '3' and draws the '1' square there. Only one '1' square is drawn based on this rule.\n6.  Overlapping patterns are overlaid; non-zero digits overwrite zeros.\n\"\"\"\n\n# Helper function to check grid boundaries\ndef is_valid(r, c, height, width):\n    return 0 <= r < height and 0 <= c < width\n\n# Helper function to draw a filled block\ndef draw_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int):\n    height, width = grid.shape\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if is_valid(i, j, height, width):\n                grid[i, j] = value\n\n# Helper function to draw a hollow square\ndef draw_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int):\n    height, width = grid.shape\n    # Draw top and bottom edges\n    for j in range(c, c + size):\n        if is_valid(r, j, height, width):\n            grid[r, j] = value\n        if is_valid(r + size - 1, j, height, width):\n            grid[r + size - 1, j] = value\n    # Draw side edges (excluding corners already drawn)\n    for i in range(r + 1, r + size - 1):\n        if is_valid(i, c, height, width):\n            grid[i, c] = value\n        if is_valid(i, c + size - 1, height, width):\n            grid[i, c + size - 1] = value\n\n# Helper function to check for a specific block pattern\ndef is_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int) -> bool:\n    height, width = grid.shape\n    if not (is_valid(r, c, height, width) and is_valid(r + h - 1, c + w - 1, height, width)):\n        return False\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if grid[i, j] != value:\n                return False\n    return True\n\n# Helper function to check for a hollow square pattern\ndef is_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int) -> bool:\n    height, width = grid.shape\n    if not (is_valid(r, c, height, width) and is_valid(r + size - 1, c + size - 1, height, width)):\n        return False\n    # Check corners\n    if grid[r, c] != value or \\\n       grid[r, c + size - 1] != value or \\\n       grid[r + size - 1, c] != value or \\\n       grid[r + size - 1, c + size - 1] != value:\n           return False\n    # Check edges\n    for j in range(c + 1, c + size - 1): # Top and bottom edges\n        if grid[r, j] != value or grid[r + size - 1, j] != value:\n            return False\n    for i in range(r + 1, r + size - 1): # Left and right edges\n        if grid[i, c] != value or grid[i, c + size - 1] != value:\n            return False\n    # Check interior (should be background or different value, assuming 0 for now)\n    for i in range(r + 1, r + size - 1):\n        for j in range(c + 1, c + size - 1):\n            if grid[i, j] == value: # Should not be the perimeter value\n                 return False\n    return True\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    output_array = np.zeros_like(input_array)\n    \n    three_locations: List[Tuple[int, int]] = []\n    five_locations: List[Tuple[int, int]] = []\n    used_threes_in_rectangle: Set[Tuple[int, int]] = set()\n\n    # --- Find initial locations of relevant digits ---\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 3:\n                three_locations.append((r, c))\n            elif input_array[r, c] == 5:\n                five_locations.append((r, c))\n\n    # --- Rule 4: FiveThreeRectangles -> Four 2x2 '6' blocks ---\n    # Iterate through pairs of '5's to find potential top edges\n    for i in range(len(five_locations)):\n        for j in range(i + 1, len(five_locations)):\n            r1_1, c1_1 = five_locations[i]\n            r1_2, c1_2 = five_locations[j]\n\n            # Check if they form a horizontal top edge (same row)\n            if r1_1 == r1_2:\n                r1 = r1_1\n                c1 = min(c1_1, c1_2)\n                c2 = max(c1_1, c1_2)\n\n                # Now look for pairs of '3's forming the bottom edge\n                for k in range(len(three_locations)):\n                    for l in range(k + 1, len(three_locations)):\n                        r2_1, c2_1 = three_locations[k]\n                        r2_2, c2_2 = three_locations[l]\n\n                        # Check if they form the bottom edge corresponding to the top edge\n                        if r2_1 == r2_2 and r2_1 > r1 and \\\n                           min(c2_1, c2_2) == c1 and max(c2_1, c2_2) == c2:\n                            r2 = r2_1\n                            # Found a FiveThreeRectangle!\n                            # Mark the '3's as used\n                            used_threes_in_rectangle.add(three_locations[k])\n                            used_threes_in_rectangle.add(three_locations[l])\n                            \n                            # Draw the four 2x2 blocks of '6'\n                            draw_block(output_array, r1, c1, 2, 2, 6)\n                            draw_block(output_array, r1, c2, 2, 2, 6)\n                            draw_block(output_array, r2 - 3, c1, 2, 2, 6)\n                            draw_block(output_array, r2 - 3, c2, 2, 2, 6)\n\n\n    # --- Rule 1: '2' -> 4x4 hollow '4' square ---\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 2:\n                draw_hollow_square(output_array, r, c, 4, 4)\n\n    # --- Rule 2: 2x2 '6' block -> shifted 2x2 '6' block ---\n    for r in range(height - 1):\n        for c in range(width - 1):\n            if is_block(input_array, r, c, 2, 2, 6):\n                draw_block(output_array, r - 1, c - 1, 2, 2, 6)\n\n    # --- Rule 3: 4x4 hollow '1' square -> shifted 4x4 hollow '1' square ---\n    for r in range(height - 3):\n        for c in range(width - 3):\n             if is_hollow_square(input_array, r, c, 4, 1):\n                 draw_hollow_square(output_array, r, c + 1, 4, 1)\n\n\n    # --- Rule 5: Conditional '3' -> 4x4 hollow '1' square ---\n    eligible_threes = [loc for loc in three_locations if loc not in used_threes_in_rectangle]\n    trigger_location = None\n\n    if eligible_threes:\n        vertical_pairs = []\n        # Find vertical pairs among eligible '3's\n        eligible_threes.sort() # Sort by row, then col\n        for i in range(len(eligible_threes)):\n            for j in range(i + 1, len(eligible_threes)):\n                r_a, c_a = eligible_threes[i]\n                r_b, c_b = eligible_threes[j]\n                if c_a == c_b and r_a < r_b:\n                    vertical_pairs.append(((r_a, c_a), (r_b, c_b)))\n\n        if vertical_pairs:\n            # Find the pair with the minimum bottom row index (r_b)\n            vertical_pairs.sort(key=lambda pair: pair[1][0]) # Sort by r_b\n            trigger_location = vertical_pairs[0][1] # Location of the bottom '3'\n        else:\n            # No vertical pairs, find the topmost, then leftmost eligible '3'\n            # Already sorted by row, then col\n            trigger_location = eligible_threes[0]\n\n    # Draw the '1' square if a trigger location was found\n    if trigger_location:\n        r_trigger, c_trigger = trigger_location\n        draw_hollow_square(output_array, r_trigger, c_trigger, 4, 1)\n\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9951,
    "candidates_token_count": 3168,
    "total_token_count": 13119,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.023372,
  "retries": 1
}