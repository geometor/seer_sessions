{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nTransforms an input grid based on specific digit patterns and locations, following a defined order of operations:\n\n1.  **Rule 4 (FiveThreeRectangle):** Identifies rectangles formed by '5's in the top row and '3's in the bottom row. For each rectangle defined by corners (r1, c1), (r1, c2), (r2, c1), (r2, c2), it draws four 2x2 blocks of '6' in the output at locations (r1, c1), (r1, c2), (r2-3, c1), and (r2-3, c2). Tracks the '3's used.\n2.  **Rule 1 (TwoMarker):** Finds all occurrences of digit '2' and draws a 4x4 hollow square using '4' at each location (r, c) in the output, anchored at (r, c).\n3.  **Rule 2 (SixBlock):** Finds all top-left corners (r, c) of 2x2 blocks filled with '6' and draws a 2x2 block of '6' at (r-1, c-1) in the output.\n4.  **Rule 3 (OneSquare):** Finds all top-left corners (r, c) of perfect 4x4 hollow squares filled with '1' (perimeter is '1', interior is not '1') and draws a 4x4 hollow square of '1' at (r, c+1) in the output.\n5.  **Rule 5 (TriggerOneSquareFromThree):** Processes remaining '3's (not part of FiveThreeRectangles). If vertical pairs exist among these '3's, it finds the pair with the lowest bottom '3' (minimum r_b) and draws a 4x4 hollow square of '1' at that bottom '3's location. If no vertical pairs exist, it finds the topmost, then leftmost remaining '3' and draws the '1' square there. Only one '1' square is drawn based on this rule per grid.\n6.  Overlapping patterns are overlaid based on the rule application order; non-zero digits overwrite zeros. Boundary checks are applied.\n\"\"\"\n\n# ============================================\n# Helper Functions\n# ============================================\n\ndef _is_valid(r: int, c: int, height: int, width: int) -> bool:\n    \"\"\"Checks if coordinates (r, c) are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef _draw_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int):\n    \"\"\"Draws a solid h x w block with top-left at (r, c) using 'value'.\"\"\"\n    height, width = grid.shape\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if _is_valid(i, j, height, width):\n                grid[i, j] = value\n\ndef _draw_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int):\n    \"\"\"Draws a hollow square of 'size' x 'size' with top-left at (r, c) using 'value'.\"\"\"\n    height, width = grid.shape\n    # Draw top and bottom edges\n    for j in range(c, c + size):\n        if _is_valid(r, j, height, width):\n            grid[r, j] = value\n        if _is_valid(r + size - 1, j, height, width):\n            # Avoid double drawing the bottom-left corner if size=1\n            if size > 1 or i == r :\n                 grid[r + size - 1, j] = value\n            \n    # Draw side edges (excluding corners already drawn if size > 1)\n    for i in range(r + 1, r + size - 1):\n        if _is_valid(i, c, height, width):\n            grid[i, c] = value\n        if _is_valid(i, c + size - 1, height, width):\n            grid[i, c + size - 1] = value\n\ndef _is_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int) -> bool:\n    \"\"\"Checks if an h x w block of 'value' exists with top-left at (r, c).\"\"\"\n    height, width = grid.shape\n    # Check if the entire block fits within the grid\n    if not (_is_valid(r, c, height, width) and _is_valid(r + h - 1, c + w - 1, height, width)):\n        return False\n    # Check if all cells within the block have the specified value\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if grid[i, j] != value:\n                return False\n    return True\n\ndef _is_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int) -> bool:\n    \"\"\"Checks if a perfect hollow 'size' x 'size' square of 'value' exists with top-left at (r, c).\"\"\"\n    height, width = grid.shape\n    # Check if the square fits within the grid\n    if not (_is_valid(r, c, height, width) and _is_valid(r + size - 1, c + size - 1, height, width)):\n        return False\n        \n    # Check perimeter cells have the correct value\n    for j in range(c, c + size): # Top edge\n        if not _is_valid(r, j, height, width) or grid[r, j] != value: return False\n    for j in range(c, c + size): # Bottom edge\n        if not _is_valid(r+size-1, j, height, width) or grid[r+size-1, j] != value: return False\n    for i in range(r + 1, r + size - 1): # Left edge (excl corners)\n        if not _is_valid(i, c, height, width) or grid[i, c] != value: return False\n    for i in range(r + 1, r + size - 1): # Right edge (excl corners)\n        if not _is_valid(i, c+size-1, height, width) or grid[i, c+size-1] != value: return False\n        \n    # Check interior cells do NOT have the perimeter value (size > 2)\n    if size > 2:\n        for i in range(r + 1, r + size - 1):\n            for j in range(c + 1, c + size - 1):\n                # Boundary check for interior cell (should always be valid if perimeter is)\n                if not _is_valid(i, j, height, width): return False \n                if grid[i, j] == value: # Interior cell must NOT match the perimeter value\n                    return False\n    return True\n\n# ============================================\n# Main Transformation Function\n# ============================================\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a series of transformations to the input grid based on detected patterns.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    # Initialize output grid with zeros\n    output_array = np.zeros_like(input_array)\n\n    # --- Pre-scan: Find initial locations of '3's and '5's ---\n    three_locations: List[Tuple[int, int]] = []\n    five_locations: List[Tuple[int, int]] = []\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 3:\n                three_locations.append((r, c))\n            elif input_array[r, c] == 5:\n                five_locations.append((r, c))\n    \n    used_threes_in_rectangle: Set[Tuple[int, int]] = set()\n\n    # --- Rule 4: FiveThreeRectangle -> Four 2x2 '6' blocks ---\n    # Iterate through pairs of '5's to find potential top edges\n    five_loc_set = set(five_locations) # Faster lookups\n    three_loc_set = set(three_locations) # Faster lookups\n\n    processed_rectangles = set() # Avoid processing same rectangle multiple times\n\n    for r1, c1 in five_locations:\n        # Look for a '5' to the right in the same row\n        for c2 in range(c1 + 1, width):\n             p2 = (r1, c2)\n             if p2 in five_loc_set:\n                 # Found potential top edge (r1, c1) to (r1, c2)\n                 # Look for corresponding bottom edge '3's\n                 for r2 in range(r1 + 1, height):\n                     p3 = (r2, c1)\n                     p4 = (r2, c2)\n                     if p3 in three_loc_set and p4 in three_loc_set:\n                         # Found a FiveThreeRectangle!\n                         rect_key = tuple(sorted([ (r1,c1), p2, p3, p4]))\n                         if rect_key not in processed_rectangles:\n                             processed_rectangles.add(rect_key)\n                             \n                             # Mark the '3's as used\n                             used_threes_in_rectangle.add(p3)\n                             used_threes_in_rectangle.add(p4)\n                             \n                             # Draw the four 2x2 blocks of '6'\n                             _draw_block(output_array, r1, c1, 2, 2, 6)\n                             _draw_block(output_array, r1, c2, 2, 2, 6)\n                             _draw_block(output_array, r2 - 3, c1, 2, 2, 6) # Corrected\n                             _draw_block(output_array, r2 - 3, c2, 2, 2, 6) # Corrected\n                         # Found the matching bottom row, no need to check further down for this top edge\n                         break \n\n    # --- Rule 1: '2' -> 4x4 hollow '4' square ---\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 2:\n                _draw_hollow_square(output_array, r, c, 4, 4)\n\n    # --- Rule 2: 2x2 '6' block -> shifted 2x2 '6' block ---\n    for r in range(height - 1): # Check potential top-left corners\n        for c in range(width - 1):\n            if _is_block(input_array, r, c, 2, 2, 6):\n                _draw_block(output_array, r - 1, c - 1, 2, 2, 6)\n\n    # --- Rule 3: 4x4 hollow '1' square -> shifted 4x4 hollow '1' square ---\n    for r in range(height - 3): # Check potential top-left corners\n        for c in range(width - 3):\n             if _is_hollow_square(input_array, r, c, 4, 1):\n                 _draw_hollow_square(output_array, r, c + 1, 4, 1)\n\n    # --- Rule 5: Conditional '3' -> 4x4 hollow '1' square ---\n    eligible_threes = [loc for loc in three_locations if loc not in used_threes_in_rectangle]\n    trigger_location: Optional[Tuple[int, int]] = None\n\n    if eligible_threes:\n        # Sort for consistent tie-breaking (topmost, then leftmost)\n        eligible_threes.sort() \n        eligible_set = set(eligible_threes) \n        \n        min_rb = float('inf')\n        best_pair_bottom_loc: Optional[Tuple[int, int]] = None\n\n        # Check for vertical pairs and find the one with the minimum bottom row (r_b)\n        processed_cols = set()\n        for r_a, c_a in eligible_threes:\n            if c_a in processed_cols: continue # Already found lowest pair for this column\n\n            # Look downwards for another eligible '3' in the same column\n            for r_b in range(r_a + 1, height):\n                 lower_loc = (r_b, c_a)\n                 if lower_loc in eligible_set:\n                      # Found a vertical pair ((r_a, c_a), lower_loc)\n                      if r_b < min_rb:\n                          min_rb = r_b\n                          best_pair_bottom_loc = lower_loc\n                      # Mark column as processed since we found the first (and thus lowest r_b) pair starting from the top for this column\n                      processed_cols.add(c_a)\n                      break # Move to next eligible '3' in the sorted list\n\n        if best_pair_bottom_loc:\n            # Found vertical pairs, use the bottom location of the pair with the overall minimum r_b\n            trigger_location = best_pair_bottom_loc \n        else:\n            # No vertical pairs found, use the topmost, then leftmost eligible '3'\n            # eligible_threes is already sorted, so the first element is the one.\n            trigger_location = eligible_threes[0]\n\n    # Draw the '1' square if a trigger location was determined\n    if trigger_location:\n        r_trigger, c_trigger = trigger_location\n        _draw_hollow_square(output_array, r_trigger, c_trigger, 4, 1)\n\n    # Convert the result back to a standard list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40891,
    "candidates_token_count": 4000,
    "total_token_count": 44891,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 25.593259,
  "retries": 1
}