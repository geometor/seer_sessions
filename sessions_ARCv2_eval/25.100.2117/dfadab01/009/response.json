{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nTransforms an input grid based on specific digit patterns and locations, following a defined order of operations:\n\n1.  **Rule 4 (FiveThreeRectangle):** Identifies rectangles formed by '5's in the top row and '3's in the bottom row. For each rectangle defined by corners (r1, c1), (r1, c2), (r2, c1), (r2, c2), it draws four 2x2 blocks of '6' in the output at locations (r1, c1), (r1, c2), (r2-3, c1), and (r2-3, c2). Tracks the '3's used.\n2.  **Rule 1 (TwoMarker):** Finds all occurrences of digit '2' and draws a 4x4 hollow square using '4' at each location (r, c) in the output, anchored at (r, c).\n3.  **Rule 2 (SixBlock):** Finds all top-left corners (r, c) of 2x2 blocks filled with '6' and draws a 2x2 block of '6' at (r-1, c-1) in the output.\n4.  **Rule 3 (OneSquare):** Finds all top-left corners (r, c) of perfect 4x4 hollow squares filled with '1' (perimeter is '1', interior is not '1') and draws a 4x4 hollow square of '1' at (r, c+1) in the output.\n5.  **Rule 5 (TriggerOneSquareFromThree):** Processes remaining '3's (not part of FiveThreeRectangles). If vertical pairs exist among these '3's, it finds the pair with the lowest bottom '3' (minimum r_b) and draws a 4x4 hollow square of '1' at that bottom '3's location. If no vertical pairs exist, it finds the topmost, then leftmost remaining '3' and draws the '1' square there. Only one '1' square is drawn based on this rule per grid.\n6.  Overlapping patterns are overlaid based on the rule application order; non-zero digits overwrite zeros. Boundary checks are applied.\n\"\"\"\n\n# ============================================\n# Helper Functions\n# ============================================\n\ndef _is_valid(r: int, c: int, height: int, width: int) -> bool:\n    \"\"\"Checks if coordinates (r, c) are within grid bounds.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef _draw_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int):\n    \"\"\"Draws a solid h x w block with top-left at (r, c) using 'value'.\"\"\"\n    height, width = grid.shape\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if _is_valid(i, j, height, width):\n                grid[i, j] = value\n\ndef _draw_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int):\n    \"\"\"Draws a hollow square of 'size' x 'size' with top-left at (r, c) using 'value'.\"\"\"\n    height, width = grid.shape\n    # Draw top and bottom edges\n    for j in range(c, c + size):\n        if _is_valid(r, j, height, width):\n            grid[r, j] = value\n        if _is_valid(r + size - 1, j, height, width):\n             grid[r + size - 1, j] = value\n            \n    # Draw side edges (excluding corners already drawn if size > 1)\n    for i in range(r + 1, r + size - 1):\n        if _is_valid(i, c, height, width):\n            grid[i, c] = value\n        if _is_valid(i, c + size - 1, height, width):\n            grid[i, c + size - 1] = value\n\ndef _is_block(grid: np.ndarray, r: int, c: int, h: int, w: int, value: int) -> bool:\n    \"\"\"Checks if an h x w block of 'value' exists with top-left at (r, c).\"\"\"\n    height, width = grid.shape\n    # Check if the entire block fits within the grid\n    if not (_is_valid(r, c, height, width) and _is_valid(r + h - 1, c + w - 1, height, width)):\n        return False\n    # Check if all cells within the block have the specified value\n    for i in range(r, r + h):\n        for j in range(c, c + w):\n            if grid[i, j] != value:\n                return False\n    return True\n\ndef _is_hollow_square(grid: np.ndarray, r: int, c: int, size: int, value: int) -> bool:\n    \"\"\"Checks if a perfect hollow 'size' x 'size' square of 'value' exists with top-left at (r, c).\"\"\"\n    height, width = grid.shape\n    # Check if the square fits within the grid\n    if not (_is_valid(r, c, height, width) and _is_valid(r + size - 1, c + size - 1, height, width)):\n        return False\n        \n    # Check perimeter cells have the correct value\n    for j in range(c, c + size): # Top edge\n        if not _is_valid(r, j, height, width) or grid[r, j] != value: return False\n    for j in range(c, c + size): # Bottom edge\n        if not _is_valid(r+size-1, j, height, width) or grid[r+size-1, j] != value: return False\n    for i in range(r + 1, r + size - 1): # Left edge (excl corners)\n        if not _is_valid(i, c, height, width) or grid[i, c] != value: return False\n    for i in range(r + 1, r + size - 1): # Right edge (excl corners)\n        if not _is_valid(i, c+size-1, height, width) or grid[i, c+size-1] != value: return False\n        \n    # Check interior cells do NOT have the perimeter value (size > 2)\n    if size > 2:\n        for i in range(r + 1, r + size - 1):\n            for j in range(c + 1, c + size - 1):\n                # Boundary check for interior cell (should always be valid if perimeter is)\n                if not _is_valid(i, j, height, width): return False \n                if grid[i, j] == value: # Interior cell must NOT match the perimeter value\n                    return False\n    # Handle edge case for size 2 squares where interior check isn't needed\n    elif size == 2:\n        pass # Already checked perimeter\n    # Squares of size < 2 are not considered hollow in the typical sense\n    elif size < 2:\n        return False # Or handle as per specific requirements for size 1\n\n    return True\n\n# ============================================\n# Main Transformation Function\n# ============================================\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies a series of transformations to the input grid based on detected patterns.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output grid with zeros\n    output_array = np.zeros_like(input_array)\n\n    # Pre-scan: Find initial locations of '3's and '5's for efficiency\n    three_locations: List[Tuple[int, int]] = []\n    five_locations: List[Tuple[int, int]] = []\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 3:\n                three_locations.append((r, c))\n            elif input_array[r, c] == 5:\n                five_locations.append((r, c))\n    \n    # Keep track of '3's used in the FiveThreeRectangle rule\n    used_threes_in_rectangle: Set[Tuple[int, int]] = set()\n\n    # --- Apply Rule 4: FiveThreeRectangle -> Four 2x2 '6' blocks ---\n    five_loc_set = set(five_locations) # Use sets for faster lookups\n    three_loc_set = set(three_locations)\n    processed_rectangles = set() # Avoid processing the same rectangle multiple times\n\n    # Iterate through potential top-left '5' corners\n    for r1, c1 in five_locations:\n        # Look for a '5' to the right in the same row (potential P2)\n        for c2 in range(c1 + 1, width):\n             p2 = (r1, c2)\n             if p2 in five_loc_set:\n                 # Found potential top edge (r1, c1) to (r1, c2)\n                 # Look downwards for corresponding bottom edge '3's (P3 and P4)\n                 for r2 in range(r1 + 1, height):\n                     p3 = (r2, c1)\n                     p4 = (r2, c2)\n                     if p3 in three_loc_set and p4 in three_loc_set:\n                         # Found a valid FiveThreeRectangle\n                         # Use a canonical key for the rectangle to handle detection order\n                         rect_key = tuple(sorted([(r1,c1), p2, p3, p4])) \n                         if rect_key not in processed_rectangles:\n                             processed_rectangles.add(rect_key)\n                             \n                             # Mark the involved '3's as used for Rule 5\n                             used_threes_in_rectangle.add(p3)\n                             used_threes_in_rectangle.add(p4)\n                             \n                             # Draw the four required 2x2 blocks of '6's\n                             _draw_block(output_array, r1, c1, 2, 2, 6)\n                             _draw_block(output_array, r1, c2, 2, 2, 6)\n                             _draw_block(output_array, r2 - 3, c1, 2, 2, 6) # Corrected offset\n                             _draw_block(output_array, r2 - 3, c2, 2, 2, 6) # Corrected offset\n                         # Found the correct bottom row for this top edge, stop searching lower\n                         break \n\n    # --- Apply Rule 1: '2' -> 4x4 hollow '4' square ---\n    # Iterate through all cells to find '2's\n    for r in range(height):\n        for c in range(width):\n            if input_array[r, c] == 2:\n                # Draw the hollow square anchored at the '2's position\n                _draw_hollow_square(output_array, r, c, 4, 4)\n\n    # --- Apply Rule 2: 2x2 '6' block -> shifted 2x2 '6' block ---\n    # Iterate through possible top-left corners of 2x2 blocks\n    for r in range(height - 1): \n        for c in range(width - 1):\n            # Check if a 2x2 block of '6's exists here\n            if _is_block(input_array, r, c, 2, 2, 6):\n                # Draw the shifted block in the output\n                _draw_block(output_array, r - 1, c - 1, 2, 2, 6)\n\n    # --- Apply Rule 3: 4x4 hollow '1' square -> shifted 4x4 hollow '1' square ---\n    # Iterate through possible top-left corners of 4x4 squares\n    for r in range(height - 3): \n        for c in range(width - 3):\n             # Check if a perfect hollow 4x4 square of '1's exists here\n             if _is_hollow_square(input_array, r, c, 4, 1):\n                 # Draw the shifted hollow square in the output\n                 _draw_hollow_square(output_array, r, c + 1, 4, 1)\n\n    # --- Apply Rule 5: Conditional '3' -> single 4x4 hollow '1' square ---\n    # Filter '3' locations to exclude those used in Rule 4\n    eligible_threes = [loc for loc in three_locations if loc not in used_threes_in_rectangle]\n    trigger_location: Optional[Tuple[int, int]] = None # Stores the single location for the '1' square\n\n    if eligible_threes:\n        # Sort eligible '3's for consistent tie-breaking (topmost, then leftmost)\n        eligible_threes.sort() \n        eligible_set = set(eligible_threes) # Use set for efficient checking of vertical pairs\n        \n        min_rb = float('inf') # Track the minimum bottom-row index found in any vertical pair\n        best_pair_bottom_loc: Optional[Tuple[int, int]] = None # Track the location of the bottom '3' in the best pair\n\n        # Check for vertical pairs among eligible '3's\n        processed_cols = set() # Avoid re-checking columns where a pair was already found\n        for r_a, c_a in eligible_threes:\n            # Skip if we've already found the defining vertical pair for this column\n            if c_a in processed_cols: continue \n\n            # Look downwards from the current '3' for another eligible '3' in the same column\n            for r_b in range(r_a + 1, height):\n                 lower_loc = (r_b, c_a)\n                 if lower_loc in eligible_set:\n                      # Found a vertical pair: ((r_a, c_a), lower_loc)\n                      # Check if this pair's bottom '3' is the lowest found so far\n                      if r_b < min_rb:\n                          min_rb = r_b\n                          best_pair_bottom_loc = lower_loc\n                      # Mark column as processed; we only care about the pair starting with the topmost '3' in the column\n                      processed_cols.add(c_a) \n                      break # Move to the next eligible '3' in the sorted list\n\n        # Determine the trigger location based on whether a vertical pair was found\n        if best_pair_bottom_loc:\n            # Case 1: Vertical pair(s) exist. Use the bottom location of the pair with the overall minimum r_b.\n            trigger_location = best_pair_bottom_loc \n        else:\n            # Case 2: No vertical pairs found. Use the topmost, then leftmost eligible '3'.\n            # Since eligible_threes is sorted, the first element is the correct one.\n            trigger_location = eligible_threes[0]\n\n    # Draw the single '1' square if a trigger location was determined\n    if trigger_location:\n        r_trigger, c_trigger = trigger_location\n        _draw_hollow_square(output_array, r_trigger, c_trigger, 4, 1)\n\n    # Convert the final numpy array back to a standard list of lists for the return value\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 51884,
    "candidates_token_count": 3812,
    "total_token_count": 55696,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.753056,
  "retries": 1
}