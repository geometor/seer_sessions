{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nReorganizes an input grid based on the configuration of separator lines ('6')\nand the resulting partitioning or quadrant structure. Uses '7' as background.\nOperates in one of three modes: Split Vertical, Split Horizontal, or Extract Quadrant.\n\n1.  **Analyze Grid Structure:**\n    *   Find horizontal ('6' rows) and vertical ('6' columns) separators.\n    *   Count distinct pattern regions (connected components != 6 and != 7).\n2.  **Determine Transformation Mode:**\n    *   **Split Vertical:** If ONLY vertical separators exist AND they perfectly partition the grid width (cols = num_patterns * 5 + num_v_sep).\n    *   **Split Horizontal:** If ONLY horizontal separators exist, len(h_sep) > 1, AND they perfectly partition the grid height (rows = num_patterns * 5 + num_h_sep).\n    *   **Extract Quadrant:** If exactly one H and one V separator exist, num_patterns is a perfect square (e.g., 4), AND grid dimensions fit (rows = cols = sqrt(num_patterns) * 5 + 1).\n3.  **Execute Transformation:**\n    *   **Split Vertical:** Extract subgrids (L-to-R), stack vertically with H-separators.\n    *   **Split Horizontal:** Extract subgrids, reverse order (B-to-T), concatenate horizontally with V-separators.\n    *   **Extract Quadrant:** Extract 5x5 quadrants (TL, TR, BL, BR), stack vertically in TL, BR, TR, BL order with H-separators.\n4.  **Output:** Return the transformed grid as a list of lists, or empty list if no mode applies.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_horizontal_separators(grid_np: np.ndarray) -> list[int]:\n    \"\"\"Finds indices of rows composed entirely of 6.\"\"\"\n    separator_digit = 6\n    rows, _ = grid_np.shape\n    return [r for r in range(rows) if np.all(grid_np[r, :] == separator_digit)]\n\ndef find_vertical_separators(grid_np: np.ndarray) -> list[int]:\n    \"\"\"Finds indices of columns composed entirely of 6.\"\"\"\n    separator_digit = 6\n    _, cols = grid_np.shape\n    return [c for c in range(cols) if np.all(grid_np[:, c] == separator_digit)]\n\ndef count_patterns(grid_np: np.ndarray) -> int:\n    \"\"\"Counts distinct connected regions of non-background (7) and non-separator (6) digits.\"\"\"\n    background_digit = 7\n    separator_digit = 6\n    mask = (grid_np != background_digit) & (grid_np != separator_digit)\n    _, num_features = label(mask)\n    return num_features\n\ndef check_partitioning(grid_shape: tuple[int, int], separator_indices: list[int], num_patterns: int, axis: int) -> bool:\n    \"\"\"Checks if separators perfectly partition the grid along the given axis (0 for H, 1 for V), assuming 5x5 patterns.\"\"\"\n    if num_patterns == 0: return False # Cannot partition if no patterns\n    rows, cols = grid_shape\n    pattern_dim_size = 5\n    num_separators = len(separator_indices)\n    if axis == 0: # Horizontal separators, check rows\n        expected_rows = num_patterns * pattern_dim_size + num_separators\n        return rows == expected_rows\n    else: # Vertical separators, check columns\n        expected_cols = num_patterns * pattern_dim_size + num_separators\n        return cols == expected_cols\n\ndef check_quadrant_conditions(grid_shape: tuple[int, int], h_sep: list[int], v_sep: list[int], num_patterns: int) -> bool:\n    \"\"\"Checks conditions for Extract Quadrant mode.\"\"\"\n    rows, cols = grid_shape\n    pattern_dim_size = 5\n    # Expect exactly 1 H sep and 1 V sep\n    if len(h_sep) != 1 or len(v_sep) != 1:\n        return False\n    # Expect num_patterns to be a non-zero perfect square (e.g., 4)\n    if num_patterns == 0: return False\n    num_patterns_sqrt = np.sqrt(num_patterns)\n    if num_patterns_sqrt != int(num_patterns_sqrt):\n        return False\n    # Check grid dimensions match expectation: sqrt(patterns)*5 + 1\n    expected_dim = int(num_patterns_sqrt) * pattern_dim_size + 1\n    return rows == expected_dim and cols == expected_dim\n\ndef get_subgrids(grid_np: np.ndarray, separator_indices: list[int], axis: int) -> list[np.ndarray]:\n    \"\"\"Extracts subgrids based on separator indices along a given axis.\"\"\"\n    subgrids = []\n    start = 0\n    for idx in separator_indices:\n        if axis == 0: # Horizontal separators -> split rows\n            subgrid = grid_np[start:idx, :]\n        else: # Vertical separators -> split columns\n            subgrid = grid_np[:, start:idx]\n        if subgrid.size > 0: # Avoid empty subgrids\n            subgrids.append(subgrid)\n        start = idx + 1\n    # Add the last subgrid\n    if axis == 0:\n        subgrid = grid_np[start:, :]\n    else:\n        subgrid = grid_np[:, start:]\n    if subgrid.size > 0:\n        subgrids.append(subgrid)\n    return subgrids\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Handle empty input\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert to numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    separator_digit = 6\n    pattern_dim_size = 5 # Assumed size for patterns/quadrants\n\n    # --- 1. Analyze Grid Structure ---\n    h_separators = find_horizontal_separators(grid_np)\n    v_separators = find_vertical_separators(grid_np)\n    num_patterns = count_patterns(grid_np)\n\n    # --- 2. Determine Transformation Mode ---\n    mode = 'unknown'\n    partitions_h = check_partitioning(grid_np.shape, h_separators, num_patterns, axis=0)\n    partitions_v = check_partitioning(grid_np.shape, v_separators, num_patterns, axis=1)\n    quadrant_conditions = check_quadrant_conditions(grid_np.shape, h_separators, v_separators, num_patterns)\n\n    if v_separators and not h_separators and partitions_v:\n        mode = 'split_vertical'\n    elif h_separators and not v_separators and len(h_separators) > 1 and partitions_h:\n        # Original logic required > 1 H separator for this mode based on examples\n        mode = 'split_horizontal'\n    elif quadrant_conditions:\n        mode = 'extract_quadrant'\n\n    # --- 3. Execute Transformation ---\n    output_grid_np = None\n\n    # ** Mode 1: Split Vertical **\n    if mode == 'split_vertical':\n        subgrids = get_subgrids(grid_np, v_separators, axis=1)\n        if subgrids:\n            output_parts = []\n            separator_row = np.full((1, subgrids[0].shape[1]), separator_digit, dtype=int)\n            for i, subgrid in enumerate(subgrids):\n                output_parts.append(subgrid)\n                if i < len(subgrids) - 1:\n                    output_parts.append(separator_row)\n            if output_parts:\n                output_grid_np = np.vstack(output_parts)\n\n    # ** Mode 2: Split Horizontal **\n    elif mode == 'split_horizontal':\n        subgrids = get_subgrids(grid_np, h_separators, axis=0)\n        subgrids.reverse() # Order bottom-to-top\n        if subgrids:\n            output_parts = []\n            separator_col = np.full((subgrids[0].shape[0], 1), separator_digit, dtype=int)\n            for i, subgrid in enumerate(subgrids):\n                output_parts.append(subgrid)\n                if i < len(subgrids) - 1:\n                    output_parts.append(separator_col)\n            if output_parts:\n                output_grid_np = np.hstack(output_parts)\n\n    # ** Mode 3: Extract Quadrant **\n    elif mode == 'extract_quadrant':\n        h_idx = h_separators[0]\n        v_idx = v_separators[0]\n\n        # Extract the four quadrants (assuming 5x5 based on conditions check)\n        quad_tl = grid_np[0:h_idx, 0:v_idx]\n        quad_tr = grid_np[0:h_idx, v_idx+1:cols]\n        quad_bl = grid_np[h_idx+1:rows, 0:v_idx]\n        quad_br = grid_np[h_idx+1:rows, v_idx+1:cols]\n\n        # Define the separator row (width should match quadrant width)\n        separator_row = np.full((1, pattern_dim_size), separator_digit, dtype=int)\n\n        # Stack in TL, BR, TR, BL order\n        output_parts = [quad_tl, separator_row, quad_br, separator_row, quad_tr, separator_row, quad_bl]\n        output_grid_np = np.vstack(output_parts)\n\n    # --- 4. Final Output ---\n    if output_grid_np is None:\n        return [] # Return empty list if mode was 'unknown' or execution failed\n    else:\n        return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24840,
    "candidates_token_count": 2792,
    "total_token_count": 27632,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.590646,
  "retries": 1
}