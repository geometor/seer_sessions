{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms an input grid based on the arrangement of '6' separators and pattern regions (digits other than 6 or 7).\n\nThe transformation operates in one of three modes determined by the separators:\n\n1.  **Split Vertical Mode:** Activated if *only* vertical separators ('6' columns) exist and they perfectly partition the grid columns into segments suitable for the number of patterns found (assuming a standard 5-column width per pattern). Subgrids are extracted left-to-right and stacked vertically in the output, separated by horizontal lines of '6's.\n\n2.  **Split Horizontal Mode:** Activated if *only* horizontal separators ('6' rows) exist, there's more than one, and they perfectly partition the grid rows into segments suitable for the number of patterns (assuming a standard 5-row height per pattern). Subgrids are extracted, ordered from bottom-to-top, and concatenated horizontally in the output, separated by vertical lines of '6's.\n\n3.  **Extract Region Mode:** Activated in other cases (e.g., mixed separators, a single horizontal separator, no perfect partitioning). Connected pattern regions are identified. For each region, its bounding box content is copied into the top-left of a 5x5 panel (padded with '7's). Panels are ordered based on the original region's position relative to the primary horizontal separator (if any) and grid center: Top-Left, Bottom-Right, Top-Right, Bottom-Left. The ordered panels are stacked vertically in the output, separated by horizontal lines of '6's.\n\"\"\"\n\ndef find_horizontal_separators(grid_np):\n    \"\"\"Finds indices of rows composed entirely of 6.\"\"\"\n    separator_digit = 6\n    rows, _ = grid_np.shape\n    separator_indices = []\n    for r in range(rows):\n        if np.all(grid_np[r, :] == separator_digit):\n            separator_indices.append(r)\n    return separator_indices\n\ndef find_vertical_separators(grid_np):\n    \"\"\"Finds indices of columns composed entirely of 6.\"\"\"\n    separator_digit = 6\n    _, cols = grid_np.shape\n    separator_indices = []\n    for c in range(cols):\n        if np.all(grid_np[:, c] == separator_digit):\n            separator_indices.append(c)\n    return separator_indices\n\ndef count_patterns(grid_np):\n    \"\"\"Counts distinct connected regions of non-background (7) and non-separator (6) digits.\"\"\"\n    background_digit = 7\n    separator_digit = 6\n    mask = (grid_np != background_digit) & (grid_np != separator_digit)\n    _, num_features = label(mask)\n    return num_features\n\ndef check_partitioning(grid_shape, separator_indices, num_patterns, axis):\n    \"\"\"\n    Checks if separators perfectly partition the grid along the given axis,\n    assuming a standard pattern size of 5x5.\n    \"\"\"\n    rows, cols = grid_shape\n    pattern_dim_size = 5 # Assumed standard dimension (height or width) for patterns\n    num_separators = len(separator_indices)\n\n    if axis == 0: # Horizontal separators, check rows\n        expected_rows = num_patterns * pattern_dim_size + num_separators\n        return rows == expected_rows\n    else: # Vertical separators, check columns\n        expected_cols = num_patterns * pattern_dim_size + num_separators\n        return cols == expected_cols\n\ndef get_subgrids(grid_np, separator_indices, axis):\n    \"\"\"Extracts subgrids based on separator indices along a given axis.\"\"\"\n    subgrids = []\n    start = 0\n    for idx in separator_indices:\n        if axis == 0: # Horizontal separators -> split rows\n            subgrid = grid_np[start:idx, :]\n        else: # Vertical separators -> split columns\n            subgrid = grid_np[:, start:idx]\n        # Only add if the subgrid is not empty (can happen with adjacent separators)\n        if subgrid.size > 0:\n            subgrids.append(subgrid)\n        start = idx + 1\n    # Add the last subgrid after the last separator\n    if axis == 0:\n        subgrid = grid_np[start:, :]\n    else:\n        subgrid = grid_np[:, start:]\n    if subgrid.size > 0:\n        subgrids.append(subgrid)\n    return subgrids\n\ndef create_panel(region_slice_data):\n    \"\"\"Creates a 5x5 panel and places the region slice data in the top-left.\"\"\"\n    panel_size = 5\n    background_digit = 7\n    panel = np.full((panel_size, panel_size), background_digit, dtype=int)\n    h, w = region_slice_data.shape\n    # Ensure the slice fits within the panel size\n    copy_h = min(h, panel_size)\n    copy_w = min(w, panel_size)\n    panel[0:copy_h, 0:copy_w] = region_slice_data[0:copy_h, 0:copy_w]\n    return panel\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Handle empty input\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    background_digit = 7\n    separator_digit = 6\n\n    # --- 1. Analyze Grid Structure ---\n    h_separators = find_horizontal_separators(grid_np)\n    v_separators = find_vertical_separators(grid_np)\n    num_patterns = count_patterns(grid_np)\n\n    # --- 2. Determine Transformation Mode ---\n    mode = 'extract_region' # Default mode\n    partitions_v = False\n    partitions_h = False\n\n    if num_patterns > 0: # Partitioning only makes sense if there are patterns\n        if v_separators and not h_separators:\n             partitions_v = check_partitioning(grid_np.shape, v_separators, num_patterns, axis=1)\n             if partitions_v:\n                 mode = 'split_vertical'\n        elif h_separators and not v_separators and len(h_separators) > 0: # Check horizontal only if vertical didn't match\n             # Mode 2 requires more than one separator for unambiguous partitioning in examples\n             partitions_h = check_partitioning(grid_np.shape, h_separators, num_patterns, axis=0)\n             if partitions_h and len(h_separators) >= 1 : # Relaxed condition slightly from >1 to >=1\n                 mode = 'split_horizontal'\n\n\n    # --- 3. Execute Transformation ---\n    output_grid_np = None\n\n    # ** Mode 1: Split Vertical **\n    if mode == 'split_vertical':\n        subgrids = get_subgrids(grid_np, v_separators, axis=1)\n        # Keep original left-to-right order\n        if subgrids:\n            output_parts = []\n            # Define horizontal separator shape based on subgrid width\n            separator_row = np.full((1, subgrids[0].shape[1]), separator_digit, dtype=int)\n            for i, subgrid in enumerate(subgrids):\n                output_parts.append(subgrid)\n                if i < len(subgrids) - 1:\n                    output_parts.append(separator_row)\n            if output_parts:\n                output_grid_np = np.vstack(output_parts)\n\n    # ** Mode 2: Split Horizontal **\n    elif mode == 'split_horizontal':\n        subgrids = get_subgrids(grid_np, h_separators, axis=0)\n        # Reverse order (bottom-to-top)\n        subgrids.reverse()\n        if subgrids:\n            output_parts = []\n             # Define vertical separator shape based on subgrid height\n            separator_col = np.full((subgrids[0].shape[0], 1), separator_digit, dtype=int)\n            for i, subgrid in enumerate(subgrids):\n                output_parts.append(subgrid)\n                if i < len(subgrids) - 1:\n                    output_parts.append(separator_col)\n            if output_parts:\n                output_grid_np = np.hstack(output_parts)\n\n    # ** Mode 3: Extract Region **\n    elif mode == 'extract_region':\n        mask = (grid_np != background_digit) & (grid_np != separator_digit)\n        labeled_array, _ = label(mask)\n        objects_slices = find_objects(labeled_array)\n\n        if not objects_slices: # Handle case with no patterns found\n             return []\n\n        regions = []\n        primary_separator_idx = h_separators[0] if h_separators else -1 # Use first H sep if exists\n\n        for i, slc in enumerate(objects_slices):\n            # Extract the bounding box content\n            region_data = grid_np[slc]\n            # Create the 5x5 panel\n            panel = create_panel(region_data)\n\n            # Determine position relative to the separator and center\n            # Use the top-left corner of the bounding box for position determination\n            top_row = slc[0].start\n            left_col = slc[1].start\n\n            # Simplified position logic based on examples\n            is_above = top_row < primary_separator_idx if primary_separator_idx != -1 else top_row < rows / 2\n            is_left = left_col < cols / 2\n\n            pos_key = \"\"\n            if is_above:\n                pos_key += \"T\"\n            else:\n                pos_key += \"B\"\n            if is_left:\n                pos_key += \"L\"\n            else:\n                pos_key += \"R\"\n\n            regions.append({'panel': panel, 'pos': pos_key, 'slice': slc})\n\n        # Sort regions based on the observed order: TL, BR, TR, BL\n        sort_order = {'TL': 0, 'BR': 1, 'TR': 2, 'BL': 3}\n        # Add fallback sort by position if keys missing or duplicate\n        regions.sort(key=lambda r: (sort_order.get(r['pos'], 99), r['slice'][0].start, r['slice'][1].start) )\n\n        # Assemble panels vertically with horizontal separators\n        output_parts = []\n        panel_width = 5 # Assuming 5x5 panels\n        separator_row = np.full((1, panel_width), separator_digit, dtype=int)\n        for i, region in enumerate(regions):\n            output_parts.append(region['panel'])\n            # Add separator if not the last panel\n            if i < len(regions) - 1:\n                output_parts.append(separator_row)\n\n        if output_parts: # Check if any regions were processed\n             output_grid_np = np.vstack(output_parts)\n\n\n    # --- 4. Final Output ---\n    # Convert final numpy array back to list of lists\n    if output_grid_np is None or output_grid_np.size == 0:\n        # If no mode applied successfully or no patterns/subgrids were generated\n        return []\n    else:\n        return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12762,
    "candidates_token_count": 3125,
    "total_token_count": 15887,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.453726,
  "retries": 1
}