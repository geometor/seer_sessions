{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies non-white contiguous objects (\"patterns\") in the input grid. For each \npattern, it determines its bounding box, dimensions (Height H, Width W), and \ncolumn span (C_start, C_end). It then searches the grid *below* the pattern's \nbounding box, within the same column span, for the topmost rectangular area of \nthe exact same dimensions (H x W) that consists entirely of white pixels (0) \n(\"canvas\"). If such a canvas is found, the pixel data from the pattern's \nbounding box is copied onto the canvas location in the output grid. \nThe rest of the grid remains unchanged.\n\"\"\"\n\ndef get_non_white_objects(grid_np):\n    \"\"\"\n    Finds contiguous non-white objects and their properties using numpy and loops.\n    \n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n\n    Returns:\n        list: A list of dictionaries, each representing a non-white object \n              with its properties (color, bbox, height, width, data, etc.).\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid_np, dtype=bool)\n    rows, cols = grid_np.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            # Process only non-white pixels that haven't been visited\n            if not visited[r, c] and grid_np[r, c] != 0:\n                color = grid_np[r, c]\n                q = [(r, c)] # Use list as queue for BFS\n                visited[r, c] = True\n                component_pixels = [(r, c)]\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                head = 0\n                while head < len(q):\n                    row, col = q[head]\n                    head += 1\n\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (non-diagonal adjacency)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and same color\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_pixels.append((nr, nc))\n\n                # Calculate properties of the found object\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                bbox = (min_r, min_c, max_r, max_c)\n                # Extract object data from its bounding box in the original grid\n                obj_data = grid_np[min_r:max_r+1, min_c:max_c+1]\n\n                objects.append({\n                    'color': color, # The specific color of this object\n                    'bbox': bbox,\n                    'height': height,\n                    'width': width,\n                    'data': obj_data, # Pixel data within the bounding box\n                    'num_pixels': len(component_pixels)\n                })\n                \n    # Sort objects primarily by starting row, then by starting column for deterministic processing\n    objects.sort(key=lambda obj: (obj['bbox'][0], obj['bbox'][1]))\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying non-white pattern bounding boxes onto \n    corresponding white canvas areas located below them.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy()\n    rows, cols = input_np.shape\n    \n    # Find all non-white \"pattern\" objects\n    pattern_objects = get_non_white_objects(input_np)\n    \n    # Keep track of canvas areas that have been filled to avoid overwriting\n    # Store the tuple (r_start, c_start, r_end, c_end) of the canvas bbox\n    filled_canvas_bboxes = set() \n\n    # Iterate through each found pattern object\n    for pattern in pattern_objects:\n        pr_s, pc_s, pr_e, pc_e = pattern['bbox']\n        H = pattern['height']\n        W = pattern['width']\n        pattern_data = pattern['data'] # Data within the pattern's bbox\n        \n        # Search for the topmost matching white canvas below the pattern\n        found_canvas = False\n        for cr_s in range(pr_e + 1, rows - H + 1): # Start search below pattern end row\n            # Canvas column span must match pattern's column span\n            cc_s = pc_s \n            cr_e = cr_s + H - 1\n            ce_e = cc_s + W - 1\n\n            # Ensure the potential canvas location is within grid bounds (width check)\n            if ce_e >= cols:\n                continue # Cannot fit width-wise\n\n            # Define the potential canvas bounding box\n            canvas_bbox = (cr_s, cc_s, cr_e, ce_e)\n\n            # Check if this potential canvas area has already been filled\n            if canvas_bbox in filled_canvas_bboxes:\n                continue\n\n            # Extract the subgrid for the potential canvas area\n            potential_canvas_area = input_np[cr_s:cr_e+1, cc_s:ce_e+1]\n\n            # Check if the area is entirely white (all zeros)\n            if np.all(potential_canvas_area == 0):\n                # Found the topmost matching canvas for this pattern\n                \n                # Perform the replacement in the output grid\n                output_np[cr_s:cr_e+1, cc_s:ce_e+1] = pattern_data\n                \n                # Mark this canvas area as filled\n                filled_canvas_bboxes.add(canvas_bbox)\n                \n                # Stop searching for canvases for this pattern, move to the next pattern\n                found_canvas = True\n                break \n                \n        # If no canvas was found for this pattern, continue to the next pattern object\n\n    # Convert the final numpy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12005,
    "candidates_token_count": 1582,
    "total_token_count": 13587,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.304504,
  "retries": null
}