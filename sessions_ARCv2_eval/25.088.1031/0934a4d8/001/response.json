{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport sys\n\n# Helper function to find the unique solid rectangular block of a given color\ndef find_unique_solid_block(grid, color):\n    \"\"\"\n    Finds the bounding box of the unique solid rectangular block of a given color.\n    \n    Args:\n        grid (np.array): The input grid.\n        color (int): The target color.\n        \n    Returns:\n        tuple: (r_min, r_max, c_min, c_max) coordinates of the block, inclusive.\n        Returns None if no such block is found, or if it's not unique, \n        not solid, or not rectangular.\n    \"\"\"\n    h, w = grid.shape\n    # Find all locations of the target color\n    locations = np.argwhere(grid == color)\n    if locations.shape[0] == 0:\n        return None # Color not present\n\n    visited = np.zeros_like(grid, dtype=bool)\n    found_blocks = []\n\n    # Iterate through potential starting points of blocks\n    for r_init, c_init in locations:\n        if visited[r_init, c_init]:\n            continue\n\n        # Use Breadth-First Search (BFS) to find all connected pixels of the same color\n        q = [(r_init, c_init)]\n        visited[r_init, c_init] = True\n        block_pixels = set([(r_init, c_init)])\n        \n        # Efficient queue implementation using list index\n        head = 0\n        while head < len(q):\n            r, c = q[head]\n            head += 1\n            \n            # Explore 4 neighbors (up, down, left, right)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Check bounds and if neighbor is the target color and not visited\n                if 0 <= nr < h and 0 <= nc < w and \\\n                   grid[nr, nc] == color and not visited[nr, nc]:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n                    block_pixels.add((nr, nc))\n\n        # After BFS, determine the bounding box of the found connected component\n        if not block_pixels: continue # Should not happen if locations is not empty\n        \n        min_r = min(r for r, c in block_pixels)\n        max_r = max(r for r, c in block_pixels)\n        min_c = min(c for r, c in block_pixels)\n        max_c = max(c for r, c in block_pixels)\n\n        # Check if this component forms a solid rectangle\n        # Calculate expected number of pixels in the bounding box\n        block_h = max_r - min_r + 1\n        block_w = max_c - min_c + 1\n        expected_pixels = block_h * block_w\n        \n        # If the number of pixels found by BFS equals the number of pixels in the bounding box, it's a solid rectangle\n        is_solid_rectangle = (len(block_pixels) == expected_pixels)\n\n        if is_solid_rectangle:\n            found_blocks.append((min_r, max_r, min_c, max_c))\n\n    # The task logic relies on finding exactly one such block\n    if len(found_blocks) == 1:\n        return found_blocks[0]\n    else:\n        # Handle cases where the assumption fails (0 or >1 blocks found)\n        if len(found_blocks) == 0:\n             # This case means the color exists but not in a solid rectangular shape\n             print(f\"Warning: No solid rectangular block of color {color} found.\", file=sys.stderr)\n        else:\n             # This case means multiple solid rectangular blocks were found\n             print(f\"Warning: Found {len(found_blocks)} solid rectangular blocks of color {color}. Expected 1.\", file=sys.stderr)\n        return None # Indicate failure to find the required unique block\n\n\n# Define the color constant\nAZURE = 8\n\n\"\"\"\nTransformation Rule Description:\n1. Locate the unique, solid, rectangular block composed entirely of azure pixels (color 8) within the input grid.\n2. Determine the column range (start and end columns) spanned by this azure block.\n3. Identify the row index of the top edge of the azure block (`r_top`).\n4. Select three specific rows from the input grid based on their position relative to `r_top`:\n   - The row 2 positions above the azure block (`r_top - 2`).\n   - The row 8 positions above the azure block (`r_top - 8`).\n   - The row 9 positions above the azure block (`r_top - 9`).\n5. Extract segments (slices) from these three selected rows. Each segment uses the column range determined in step 2.\n6. Construct the output grid by stacking these three row segments vertically. The order of stacking is:\n   - Top row: Segment from `r_top - 2`.\n   - Middle row: Segment from `r_top - 8`.\n   - Bottom row: Segment from `r_top - 9`.\n7. If the unique solid azure block cannot be found, or if the calculated row indices fall outside the grid boundaries, the transformation fails (indicated by returning a minimal grid).\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the specified rule based on a unique azure block.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid. \n                         Returns [[0]] if the transformation rule cannot be applied.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    input_array = np.array(input_grid, dtype=int)\n    h, w = input_array.shape\n\n    # 1. Find the unique solid rectangular block of azure (8)\n    block_coords = find_unique_solid_block(input_array, AZURE)\n\n    # 7. Handle failure case: block not found or not unique/solid/rectangular\n    if block_coords is None:\n        print(f\"Error: Could not find the required unique solid azure block.\", file=sys.stderr)\n        # Return a 1x1 black grid as an error indicator, common in ARC viewers.\n        return [[0]] \n\n    # Extract block coordinates\n    r_min, r_max, c_min, c_max = block_coords\n    # 3. Identify top row index\n    r_top = r_min \n\n    # 4. Define the target row indices relative to the block's top row\n    row_idx_1 = r_top - 2\n    row_idx_2 = r_top - 8\n    row_idx_3 = r_top - 9\n\n    target_rows = [row_idx_1, row_idx_2, row_idx_3]\n    \n    # 7. Handle failure case: Check if target rows are within grid bounds\n    if not (0 <= row_idx_1 < h and 0 <= row_idx_2 < h and 0 <= row_idx_3 < h):\n        print(f\"Error: Target row indices {target_rows} calculated relative to azure block are out of bounds (grid height {h}).\", file=sys.stderr)\n        return [[0]] # Return error grid\n\n    # 5. Extract the row slices using the block's column range (step 2 implied here)\n    try:\n        slice1 = input_array[row_idx_1, c_min : c_max + 1]\n        slice2 = input_array[row_idx_2, c_min : c_max + 1]\n        slice3 = input_array[row_idx_3, c_min : c_max + 1]\n    except IndexError:\n        # This catch is a safeguard, though bounds checks should prevent it.\n        print(f\"Error: Failed to extract slices using azure block columns {c_min}-{c_max} from rows {target_rows}.\", file=sys.stderr)\n        return [[0]] # Return error grid\n\n    # 6. Construct the output grid by stacking the slices in the specified order\n    output_array = np.vstack([slice1, slice2, slice3])\n\n    # Convert the resulting numpy array back to a list of lists format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16731,
    "candidates_token_count": 1992,
    "total_token_count": 18723,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 59.873036,
  "retries": null
}