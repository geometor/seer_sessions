{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis program transforms an input grid based on identifying and processing specific objects within it.\n\nThe core logic observed, particularly from the second training example, involves:\n1. Identifying all contiguous regions (objects) of non-background ('8') cells.\n2. Filtering these objects to select those containing specific colors (e.g., both '3' and '9').\n3. Calculating the geometric center of each selected object.\n4. Determining a bounding box that encloses all these centers.\n5. Creating an output grid filled with the background color ('8').\n6. Populating the calculated bounding box in the output grid:\n    a. Setting the border cells of the box to a specific color (e.g., '3').\n    b. Filling the interior cells with a default color (e.g., '9').\n    c. Overlaying specific colors (e.g., '3') from the selected input objects onto the interior of the output box. The position of these overlaid colors is determined by mapping the cell's position relative to its input object's center to a corresponding position relative to the center of the output bounding box.\n\nNote: The logic for the first training example appears different (selection based on size/enclosure, different border/fill colors, potential color transformations within the object) and is not fully captured by this implementation. This code prioritizes the clearer pattern from the second example.\n\"\"\"\n\nimport numpy as np\nfrom skimage.measure import label, regionprops\nfrom collections import namedtuple\nimport math\n\n# Define structure for object properties\n# Bbox is (min_row, min_col, max_row_inclusive, max_col_inclusive)\nObject = namedtuple(\"Object\", [\"label\", \"coords\", \"colors\", \"bbox\", \"center\", \"size\"])\n\ndef find_objects(grid: np.ndarray, background_color: int) -> list[Object]:\n    \"\"\"\n    Identifies connected regions (objects) of non-background colors in the grid.\n\n    Args:\n        grid: The input numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        A list of Object namedtuples, each containing properties of an object.\n            - label: Unique integer ID for the object.\n            - coords: Nx2 numpy array of (row, col) coordinates.\n            - colors: Set of unique non-background colors in the object.\n            - bbox: Tuple (min_row, min_col, max_row_incl, max_col_incl).\n            - center: Tuple (center_row, center_col) - float coordinates.\n            - size: Integer number of pixels in the object.\n    \"\"\"\n    mask = grid != background_color\n    # Use connectivity=1 for 4-way neighbors (up, down, left, right)\n    labeled_grid, num_labels = label(mask, connectivity=1, background=0, return_num=True)\n\n    objects = []\n    # Use regionprops for efficient calculation of properties\n    # Pass grid itself to intensity_image to access original values if needed\n    props = regionprops(labeled_grid, intensity_image=grid)\n\n    for region in props:\n        # region.label is the label number\n        coords = region.coords # Nx2 array of (row, col)\n        if not coords.size > 0: continue # Skip empty regions if any\n\n        # Extract colors present in the object using the coordinates\n        colors_present = set(grid[coords[:, 0], coords[:, 1]])\n        # Remove background color if present (though mask should prevent this)\n        colors_present.discard(background_color)\n\n        if not colors_present: continue # Skip if somehow only background was included\n\n        # Bbox: (min_row, min_col, max_row, max_col) - Note: max is *exclusive* in skimage\n        min_r, min_c, max_r_excl, max_c_excl = region.bbox\n        # Convert to inclusive bbox for easier use later\n        bbox_inclusive = (min_r, min_c, max_r_excl - 1, max_c_excl - 1)\n\n        # Center: (centroid-0, centroid-1) -> (row, col)\n        center_r, center_c = region.centroid\n\n        # Size: number of pixels\n        size = region.area\n\n        objects.append(Object(\n            label=region.label,\n            coords=coords,\n            colors=colors_present,\n            bbox=bbox_inclusive,\n            center=(center_r, center_c),\n            size=size\n        ))\n\n    return objects\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the rules primarily derived from train_2.\n    Finds objects containing both 3 and 9, calculates bbox of their centers,\n    and populates this box with border 3, fill 9, overlaying 3s from inputs.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    background_color = 8 # Deduced from examples\n    output_grid = np.full_like(input_grid, background_color)\n\n    # 1. Find all non-background objects\n    objects = find_objects(input_grid, background_color)\n    if not objects:\n        return output_grid.tolist() # Return background if no objects found\n\n    # 2. Filter objects: Select objects containing both 3 and 9 (train_2 logic)\n    required_colors = {3, 9}\n    border_color = 3\n    fill_color = 9\n    overlay_color = 3 # The color from input objects to overlay\n    selected_objects = [obj for obj in objects if required_colors.issubset(obj.colors)]\n\n    # If the primary filtering logic (train_2) doesn't yield results,\n    # return the background grid, as the alternative (train_1) logic is unclear.\n    if not selected_objects:\n        # print(\"No objects found matching criteria {3, 9}. Returning background.\")\n        return output_grid.tolist()\n\n    # 3. Determine the output bounding box based on centers of selected objects\n    centers = [obj.center for obj in selected_objects]\n    if not centers:\n        # This case should not happen if selected_objects is not empty, but check anyway\n        return output_grid.tolist()\n\n    center_rows = [r for r, c in centers]\n    center_cols = [c for r, c in centers]\n\n    # Determine bounds by rounding the min/max of center coordinates\n    # Using math.floor/math.ceil might be slightly more robust than round()\n    # Let's use rounding as per initial thought process.\n    min_r_bbox = int(round(min(center_rows)))\n    max_r_bbox = int(round(max(center_rows)))\n    min_c_bbox = int(round(min(center_cols)))\n    max_c_bbox = int(round(max(center_cols)))\n\n    # Ensure bbox coordinates are within grid dimensions\n    min_r_bbox = max(0, min_r_bbox)\n    min_c_bbox = max(0, min_c_bbox)\n    max_r_bbox = min(height - 1, max_r_bbox)\n    max_c_bbox = min(width - 1, max_c_bbox)\n\n    # Handle degenerate cases where bbox might be invalid after rounding/clipping\n    if min_r_bbox > max_r_bbox or min_c_bbox > max_c_bbox:\n        # print(\"Degenerate bounding box calculated. Returning background.\")\n        return output_grid.tolist()\n\n    # 4. Populate the output bounding box\n    # Calculate the geometric center of the output bounding box\n    out_center_r = (min_r_bbox + max_r_bbox) / 2.0\n    out_center_c = (min_c_bbox + max_c_bbox) / 2.0\n\n    # Fill border and interior first\n    for r in range(min_r_bbox, max_r_bbox + 1):\n        for c in range(min_c_bbox, max_c_bbox + 1):\n            is_border = (r == min_r_bbox or r == max_r_bbox or\n                         c == min_c_bbox or c == max_c_bbox)\n            if is_border:\n                output_grid[r, c] = border_color\n            else:\n                output_grid[r, c] = fill_color\n\n    # Overlay the 'overlay_color' from selected input objects\n    for obj in selected_objects:\n        obj_center_r, obj_center_c = obj.center\n        # Iterate through coordinates of the current object\n        for r_in, c_in in obj.coords:\n            # Check if this cell in the input object has the color to be overlaid\n            if input_grid[r_in, c_in] == overlay_color:\n                # Calculate position relative to the input object's center\n                delta_r = r_in - obj_center_r\n                delta_c = c_in - obj_center_c\n\n                # Calculate target position in the output grid relative to the output box center\n                r_out = int(round(out_center_r + delta_r))\n                c_out = int(round(out_center_c + delta_c))\n\n                # Check if the target position is strictly *inside* the output bbox (not on the border)\n                # and also within the overall grid bounds (safety check)\n                if (min_r_bbox < r_out < max_r_bbox and\n                    min_c_bbox < c_out < max_c_bbox and\n                    0 <= r_out < height and 0 <= c_out < width):\n                     output_grid[r_out, c_out] = overlay_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2837,
    "candidates_token_count": 8236,
    "total_token_count": 11073,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 70.97768,
  "retries": 1
}