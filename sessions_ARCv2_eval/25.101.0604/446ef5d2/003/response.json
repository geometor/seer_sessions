{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis program transforms an input grid based on identifying and processing specific objects within it. \nThe transformation logic depends on the types of objects found in the input grid.\n\nGeneral Workflow:\n1. Identify all connected regions (objects) of non-background ('8') cells using 4-way connectivity.\n2. Determine the transformation case based on the colors present in the identified objects:\n   - Case A (Train 2 Pattern): If objects containing both colors '3' and '9' exist.\n   - Case B (Train 1 Pattern): If Case A doesn't apply, but objects containing color '0' exist.\n   - Default Case: If neither Case A nor B applies (return background grid).\n3. Select the relevant object(s) based on the determined case:\n   - Case A: Select all objects containing both '3' and '9'.\n   - Case B: Select the largest object containing '0'.\n4. Determine the bounding box for the single output object based on the selected object(s) and the case:\n   - Case A: Calculate the bounding box enclosing the geometric centers of the selected objects (using rounding for coordinates). Note: This might not perfectly match train_2's output bbox, suggesting a more complex calculation might be needed.\n   - Case B: Use the bounding box of the single selected object. Note: Train_1 output suggests potential shifting/resizing not captured here.\n5. Create the output grid, initialized with the background color ('8').\n6. Populate the determined output bounding box in the output grid based on the case:\n   - Case A: Draw border with '3', fill interior with '9', then overlay '3's from input objects based on relative positions mapped between input object centers and the output box center.\n   - Case B: Draw border with '7', then copy the content of the selected input object into the output box interior, mapping based on relative positions between the input object center and the output box center.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque, namedtuple\nimport math\n\n# Define structure for object properties\n# Bbox is (min_row, min_col, max_row_inclusive, max_col_inclusive)\nObject = namedtuple(\"Object\", [\"label\", \"coords\", \"colors\", \"bbox\", \"center\", \"size\"])\n\ndef find_objects(grid: np.ndarray, background_color: int) -> list[Object]:\n    \"\"\"\n    Identifies connected regions (objects) of non-background colors using BFS.\n\n    Args:\n        grid: The input numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        A list of Object namedtuples.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    label_counter = 1\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new object\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_coords = []\n                current_colors = set()\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    current_coords.append((row, col))\n                    current_colors.add(grid[row, col])\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore 4-way neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if (0 <= nr < height and 0 <= nc < width and\n                                not visited[nr, nc] and\n                                grid[nr, nc] != background_color):\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if current_coords:\n                    coords_array = np.array(current_coords)\n                    # Calculate geometric center (centroid)\n                    center_r = np.mean(coords_array[:, 0])\n                    center_c = np.mean(coords_array[:, 1])\n                    \n                    objects.append(Object(\n                        label=label_counter,\n                        coords=coords_array,\n                        colors=current_colors,\n                        bbox=(min_r, min_c, max_r, max_c),\n                        center=(center_r, center_c),\n                        size=len(current_coords)\n                    ))\n                    label_counter += 1\n    return objects\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on object identification and rule-based processing.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    background_color = 8\n    output_grid = np.full_like(input_grid, background_color)\n\n    # 1. Find all non-background objects\n    objects = find_objects(input_grid, background_color)\n    if not objects:\n        return output_grid.tolist()\n\n    # 2. Determine transformation case and select objects\n    selected_objects = []\n    case = None\n    \n    # Check for Case A (Train 2 pattern: objects with {3, 9})\n    case_a_candidates = [obj for obj in objects if {3, 9}.issubset(obj.colors)]\n    if case_a_candidates:\n        selected_objects = case_a_candidates\n        case = 'A'\n    else:\n        # Check for Case B (Train 1 pattern: objects with '0')\n        case_b_candidates = [obj for obj in objects if 0 in obj.colors]\n        if case_b_candidates:\n            # Select the largest object containing '0'\n            selected_objects = [max(case_b_candidates, key=lambda obj: obj.size)]\n            case = 'B'\n\n    # If no relevant objects found for known cases\n    if not selected_objects or case is None:\n        return output_grid.tolist()\n\n    # 3. Determine the output bounding box\n    min_r_bbox, min_c_bbox, max_r_bbox, max_c_bbox = -1, -1, -1, -1\n\n    if case == 'A':\n        # Case A: Bbox from centers of multiple objects\n        centers = [obj.center for obj in selected_objects]\n        if not centers: return output_grid.tolist() # Should not happen if selected_objects is not empty\n        \n        center_rows = [r for r, c in centers]\n        center_cols = [c for r, c in centers]\n        \n        # Calculate bbox by rounding min/max center coordinates\n        # Note: This might not perfectly match the observed output bbox for train_2\n        min_r_bbox = int(round(min(center_rows)))\n        max_r_bbox = int(round(max(center_rows)))\n        min_c_bbox = int(round(min(center_cols)))\n        max_c_bbox = int(round(max(center_cols)))\n        \n    elif case == 'B':\n        # Case B: Bbox from the single selected object\n        # Note: Train_1 output suggests potential shifts/resizes not accounted for here.\n        single_obj = selected_objects[0]\n        min_r_bbox, min_c_bbox, max_r_bbox, max_c_bbox = single_obj.bbox\n\n    # Ensure bbox coordinates are valid and within grid dimensions\n    if min_r_bbox == -1: # Check if bbox was determined\n         return output_grid.tolist()\n         \n    min_r_bbox = max(0, min_r_bbox)\n    min_c_bbox = max(0, min_c_bbox)\n    max_r_bbox = min(height - 1, max_r_bbox)\n    max_c_bbox = min(width - 1, max_c_bbox)\n\n    # Handle degenerate cases where bbox might be invalid\n    if min_r_bbox > max_r_bbox or min_c_bbox > max_c_bbox:\n        return output_grid.tolist()\n\n    # 4. Calculate output box center (needed for relative positioning)\n    out_center_r = (min_r_bbox + max_r_bbox) / 2.0\n    out_center_c = (min_c_bbox + max_c_bbox) / 2.0\n\n    # 5. Populate the output bounding box\n    if case == 'A':\n        border_color = 3\n        fill_color = 9\n        overlay_color = 3\n        \n        # Fill border and interior first\n        for r in range(min_r_bbox, max_r_bbox + 1):\n            for c in range(min_c_bbox, max_c_bbox + 1):\n                is_border = (r == min_r_bbox or r == max_r_bbox or\n                             c == min_c_bbox or c == max_c_bbox)\n                output_grid[r, c] = border_color if is_border else fill_color\n\n        # Overlay the 'overlay_color' from selected input objects\n        for obj in selected_objects:\n            obj_center_r, obj_center_c = obj.center\n            for r_in, c_in in obj.coords:\n                if input_grid[r_in, c_in] == overlay_color:\n                    delta_r = r_in - obj_center_r\n                    delta_c = c_in - obj_center_c\n                    r_out = int(round(out_center_r + delta_r))\n                    c_out = int(round(out_center_c + delta_c))\n\n                    # Check if target is strictly *inside* the output bbox and within grid bounds\n                    if (min_r_bbox < r_out < max_r_bbox and\n                        min_c_bbox < c_out < max_c_bbox and\n                        0 <= r_out < height and 0 <= c_out < width):\n                         output_grid[r_out, c_out] = overlay_color\n\n    elif case == 'B':\n        border_color = 7\n        single_obj = selected_objects[0]\n        obj_center_r, obj_center_c = single_obj.center\n\n        # Draw border\n        for r in range(min_r_bbox, max_r_bbox + 1):\n             for c in range(min_c_bbox, max_c_bbox + 1):\n                 is_border = (r == min_r_bbox or r == max_r_bbox or\n                              c == min_c_bbox or c == max_c_bbox)\n                 if is_border:\n                     output_grid[r,c] = border_color\n                 # Leave interior as background for now, will be filled by copy\n\n        # Copy content from input object to output interior based on relative center positions\n        for r_in, c_in in single_obj.coords:\n            input_color = input_grid[r_in, c_in]\n            delta_r = r_in - obj_center_r\n            delta_c = c_in - obj_center_c\n            r_out = int(round(out_center_r + delta_r))\n            c_out = int(round(out_center_c + delta_c))\n            \n            # Check if target is strictly *inside* the output bbox and within grid bounds\n            if (min_r_bbox < r_out < max_r_bbox and\n                min_c_bbox < c_out < max_c_bbox and\n                0 <= r_out < height and 0 <= c_out < width):\n                 output_grid[r_out, c_out] = input_color # Copy original color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9473,
    "candidates_token_count": 4777,
    "total_token_count": 14250,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 36.971665,
  "retries": 1
}