{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\nimport math\n\n\"\"\"\nTransforms an input grid based on interactions within multi-color connected components. \nThe logic primarily models behavior seen in Training Examples 2 and 3, with specific handling based on max_color and min_color.\n\n1. Identifies connected components (8-way adjacency) of non-zero cells.\n2. For components with multiple distinct non-zero colors:\n    a. Determines the minimum (`min_color`) and maximum (`max_color`) colors.\n    b. **Removal & Propagation Column Logic (Conditional):**\n        i. If `max_color` is 7 AND `min_color` > 3 (like Example 3): \n           - Removes *all* cells with color 7 within the component.\n           - Identifies the median column among all columns where a 7 was removed for vertical propagation.\n        ii. If `max_color` is not 7 (like Example 2):\n           - Finds interface cells (adjacent to a different non-zero color within the component).\n           - Removes only those interface cells that have the `max_color`.\n           - Identifies all columns where any `max_color` interface cell was removed for vertical propagation. (Known Issue: May select too many columns).\n        iii. If `max_color` is 7 AND `min_color` <= 3 (like Example 1):\n           - This case represents an anomaly observed in Example 1 where the rules differ (interface 7s removed, horizontal modification). \n           - The current code does *not* implement the specific rules for this anomaly and will likely produce incorrect results for such cases. It defaults to the \"max_color is not 7\" removal logic but skips propagation.\n    c. **Vertical Propagation Logic (Applies to Cases i and ii):** \n       For each identified propagation column, finds the minimum row (`min_row_col`) the component occupied in that column. Then, fills the contiguous block of background (0) cells in the *input* grid located directly above this position (ending at `min_row_col - 1`) with the `max_color` in the *output* grid.\n3. Components with only one non-zero color are left unchanged.\n\"\"\"\n\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_components(grid: list[list[int]]) -> list[tuple[set[tuple[int, int]], set[int]]]:\n    \"\"\"\n    Finds all connected components of non-zero cells using BFS.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - A set of (row, col) coordinates belonging to the component.\n        - A set of unique non-zero colors present in the component.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-zero cell\n            if grid[r][c] != 0 and (r, c) not in visited:\n                component_cells = set()\n                component_colors = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_cells.add((curr_r, curr_c))\n                    component_colors.add(grid[curr_r][curr_c])\n\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(curr_r, curr_c, rows, cols):\n                        if grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Ensure only non-zero colors are stored and component is not empty\n                component_colors.discard(0)\n                if component_colors: # Only add components with actual colors\n                    components.append((component_cells, component_colors))\n    return components\n\ndef find_interface_cells(grid: list[list[int]], component_cells: set[tuple[int, int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Identifies interface cells within a component. An interface cell is adjacent\n    (8-way) to another cell *within the same component* that has a *different non-zero* color.\n\n    Args:\n        grid: The input grid.\n        component_cells: Set of (row, col) coordinates for the component.\n\n    Returns:\n        A set of (row, col) coordinates of all interface cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    interface_cells = set()\n    \n    # Pre-fetch colors for faster lookup within the component\n    component_data = {cell: grid[cell[0]][cell[1]] for cell in component_cells}\n    \n    for r, c in component_cells:\n        cell_color = component_data.get((r, c), 0) # Use .get for safety\n        # Skip background cells if they somehow got included\n        if cell_color == 0: continue \n            \n        is_interface = False\n        # Check neighbors\n        for nr, nc in get_neighbors(r, c, rows, cols):\n            # Check if neighbor is in the same component\n            if (nr, nc) in component_data: \n                neighbor_color = component_data[(nr, nc)]\n                # Check if neighbor has a different non-zero color\n                if neighbor_color != 0 and neighbor_color != cell_color:\n                    is_interface = True\n                    break # Found an interface neighbor, no need to check further\n        if is_interface:\n            interface_cells.add((r, c))\n            \n    return interface_cells\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Initialize output_grid as a deep copy to avoid modifying the input\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n\n    # Find all connected components of non-zero cells\n    components = find_components(input_grid)\n\n    # Process each component\n    for component_cells, component_colors in components:\n        \n        # Skip components with only one non-zero color\n        if len(component_colors) <= 1:\n            continue\n\n        # Determine min and max colors for this multi-color component\n        min_color = min(component_colors)\n        max_color = max(component_colors)\n\n        # Calculate minimum row for each column within the component for later propagation reference\n        min_row_in_col = collections.defaultdict(lambda: rows)\n        for r_comp, c_comp in component_cells:\n            min_row_in_col[c_comp] = min(min_row_in_col[c_comp], r_comp)\n\n        # Initialize set to store columns where propagation should occur\n        propagation_columns = set()\n        perform_propagation = True # Flag to control propagation step\n\n        # --- Removal Step & Propagation Column Determination (Conditional Logic) ---\n        \n        # Case A: max_color is 7 AND min_color > 3 (like Example 3)\n        if max_color == 7 and min_color > 3:\n            cells_to_remove = set()\n            removed_cols_list = []\n            # Identify all cells with color 7 in this component\n            for r_comp, c_comp in component_cells:\n                if input_grid[r_comp][c_comp] == 7:\n                    cells_to_remove.add((r_comp, c_comp))\n                    removed_cols_list.append(c_comp) # Track columns containing removed 7s\n            \n            # Remove the identified cells in the output grid\n            for r_rem, c_rem in cells_to_remove:\n                output_grid[r_rem][c_rem] = 0\n\n            # Determine propagation column (median of unique columns where 7s were removed)\n            if removed_cols_list:\n                unique_sorted_cols = sorted(list(set(removed_cols_list)))\n                median_index = math.floor(len(unique_sorted_cols) / 2) \n                if median_index < len(unique_sorted_cols): \n                    propagation_columns.add(unique_sorted_cols[median_index])\n            else: # If no 7s were actually found (edge case), don't propagate\n                 perform_propagation = False \n\n        # Case C: max_color is 7 AND min_color <= 3 (Anomaly like Example 1)\n        elif max_color == 7 and min_color <= 3:\n             # This case follows different rules (remove interface 7s, horizontal changes)\n             # Implementing the removal part similar to Case B for now, but skipping propagation.\n             interface_cells = find_interface_cells(input_grid, component_cells)\n             cells_to_remove = set()\n             for r_int, c_int in interface_cells:\n                 if input_grid[r_int][c_int] == max_color: # Remove interface 7s\n                     cells_to_remove.add((r_int, c_int))\n             for r_rem, c_rem in cells_to_remove:\n                 output_grid[r_rem][c_rem] = 0\n             perform_propagation = False # Skip vertical propagation for this anomalous case\n\n        # Case B: max_color is not 7 (like Example 2)\n        else: \n            interface_cells = find_interface_cells(input_grid, component_cells)\n            cells_to_remove = set()\n            # Identify interface cells that have the max_color\n            for r_int, c_int in interface_cells:\n                if input_grid[r_int][c_int] == max_color:\n                    cells_to_remove.add((r_int, c_int))\n                    # Add the column of *any* removed max_color interface cell for propagation\n                    propagation_columns.add(c_int) \n            # Remove the identified cells in the output grid\n            for r_rem, c_rem in cells_to_remove:\n                 output_grid[r_rem][c_rem] = 0\n            \n            if not propagation_columns: # If no max interface cells were removed, don't propagate\n                perform_propagation = False\n\n\n        # --- Vertical Propagation Step (Only if perform_propagation is True) ---\n        if perform_propagation:\n            for c_prop in propagation_columns:\n                # Get the minimum row the component occupied in this column\n                min_row_col = min_row_in_col.get(c_prop, rows) # Use .get for safety\n                if min_row_col == rows: continue # Skip if component wasn't actually in this column\n\n                # Trace upwards from the cell just above the component's top in this column\n                fill_cells = []\n                r_trace = min_row_col - 1\n                # Use the *input_grid* to find the block of 0s\n                while r_trace >= 0 and input_grid[r_trace][c_prop] == 0:\n                    fill_cells.append((r_trace, c_prop))\n                    r_trace -= 1\n                \n                # Fill the identified block in the *output_grid* with the component's max_color\n                for r_fill, c_fill in fill_cells:\n                     # Check bounds again just in case\n                     if 0 <= r_fill < rows and 0 <= c_fill < cols:\n                         output_grid[r_fill][c_fill] = max_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32004,
    "candidates_token_count": 3024,
    "total_token_count": 35028,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.053539,
  "retries": 1
}