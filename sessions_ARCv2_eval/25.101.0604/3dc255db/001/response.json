{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\n\"\"\"\nProcesses a grid of integers based on connected components of non-zero cells.\n\n1. Identifies connected components (8-way adjacency) of non-zero cells.\n2. For components containing multiple distinct non-zero colors:\n   a. Finds the minimum (min_color) and maximum (max_color) colors within the component.\n   b. Identifies \"interface cells\": cells within the component adjacent (8-way) to another cell of a different non-zero color within the same component.\n   c. Identifies interface cells that have the max_color and notes their columns.\n   d. Removes (sets to 0) all interface cells in the output grid.\n   e. For each column that contained a max_color interface cell:\n      i. Finds the minimum row index (min_row_col) of the original component in that column.\n      ii. Identifies the contiguous block of background cells (0) in the input grid directly above the component's top edge in that column (i.e., ending at row min_row_col - 1).\n      iii. Fills this block with the max_color in the output grid.\n3. Components with only a single non-zero color remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_components(grid: list[list[int]]) -> list[tuple[set[tuple[int, int]], set[int]]]:\n    \"\"\"\n    Finds all connected components of non-zero cells using BFS.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - A set of (row, col) coordinates belonging to the component.\n        - A set of unique non-zero colors present in the component.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                component_cells = set()\n                component_colors = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_cells.add((curr_r, curr_c))\n                    component_colors.add(grid[curr_r][curr_c])\n\n                    for nr, nc in get_neighbors(curr_r, curr_c, rows, cols):\n                        if grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                components.append((component_cells, component_colors))\n    return components\n\ndef find_interface_cells(grid: list[list[int]], component_cells: set[tuple[int, int]]) -> tuple[set[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"\n    Identifies interface cells within a component.\n\n    Args:\n        grid: The input grid.\n        component_cells: Set of (row, col) coordinates for the component.\n\n    Returns:\n        A tuple containing:\n        - A set of (row, col) coordinates of all interface cells.\n        - A set of (row, col) coordinates of interface cells with the max_color.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    interface_cells = set()\n    \n    component_data = {cell: grid[cell[0]][cell[1]] for cell in component_cells}\n    \n    for r, c in component_cells:\n        cell_color = component_data[(r, c)]\n        is_interface = False\n        for nr, nc in get_neighbors(r, c, rows, cols):\n            if (nr, nc) in component_data: # Check if neighbor is in the same component\n                neighbor_color = component_data[(nr, nc)]\n                if neighbor_color != 0 and neighbor_color != cell_color:\n                    is_interface = True\n                    break\n        if is_interface:\n            interface_cells.add((r, c))\n            \n    return interface_cells\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on multi-color component interactions.\n    \"\"\"\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n\n    # Find all connected components\n    components = find_components(input_grid)\n\n    # Process each component\n    for component_cells, component_colors in components:\n        # Skip components with only one color (or background only, though find_components shouldn't return those)\n        if len(component_colors) <= 1:\n            continue\n\n        # Calculate min and max color for the multi-color component\n        min_color = min(component_colors)\n        max_color = max(component_colors)\n        \n        # Find interface cells within this component\n        interface_cells = find_interface_cells(input_grid, component_cells)\n\n        # Identify interface cells with max_color and their columns\n        interface_max_cells = set()\n        propagate_cols = set()\n        for r_int, c_int in interface_cells:\n            if input_grid[r_int][c_int] == max_color:\n                interface_max_cells.add((r_int, c_int))\n                propagate_cols.add(c_int)\n\n        # Removal Step: Set all interface cells to 0 in the output grid\n        for r_int, c_int in interface_cells:\n            output_grid[r_int][c_int] = 0\n\n        # Propagation Step:\n        for c_prop in propagate_cols:\n            # Find the minimum row for this component in this column\n            min_row_col = rows # Initialize higher than possible\n            for r_comp, c_comp in component_cells:\n                if c_comp == c_prop:\n                    min_row_col = min(min_row_col, r_comp)\n            \n            # If no component cell was found in this column (shouldn't happen if it's in propagate_cols, but safety check)\n            if min_row_col == rows:\n                continue \n\n            # Trace upwards from min_row_col - 1 in the *input* grid to find the block of 0s\n            fill_cells = []\n            r_trace = min_row_col - 1\n            while r_trace >= 0 and input_grid[r_trace][c_prop] == 0:\n                fill_cells.append((r_trace, c_prop))\n                r_trace -= 1\n            \n            # Fill the identified block in the *output* grid with max_color\n            for r_fill, c_fill in fill_cells:\n                 output_grid[r_fill][c_fill] = max_color\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3917,
    "candidates_token_count": 2950,
    "total_token_count": 6867,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.207527,
  "retries": 1
}