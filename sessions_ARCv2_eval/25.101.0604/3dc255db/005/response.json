{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\nimport math\n\n\"\"\"\nTransforms an input grid based on interactions within multi-color connected components, primarily modeling the behavior observed in Training Examples 2 and 3.\n\n1. Identifies connected components (8-way adjacency) of non-zero cells.\n2. For components with multiple distinct non-zero colors:\n    a. Determines the maximum color (`max_color`).\n    b. **Removal Logic:**\n        i. If `max_color` is 7: Removes *all* cells with color 7 within the component.\n        ii. If `max_color` is not 7: Finds interface cells (adjacent to a different non-zero color within the component) and removes only those interface cells that have the `max_color`.\n    c. **Propagation Column Identification Logic:**\n        i. If `max_color` was 7: Identifies the median column among all columns where a 7 was removed.\n        ii. If `max_color` was not 7: Identifies all columns where any `max_color` interface cell was removed.\n    d. **Propagation Logic:** For each identified propagation column, finds the minimum row (`min_row_col`) the component occupied in that column. Then, fills the contiguous block of background (0) cells in the *input* grid located directly above this position (ending at `min_row_col - 1`) with the `max_color` in the *output* grid.\n3. Components with only one non-zero color are left unchanged.\n4. Note: This logic does not account for the different transformation observed in Training Example 1.\n\"\"\"\n\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_components(grid: list[list[int]]) -> list[tuple[set[tuple[int, int]], set[int]]]:\n    \"\"\"\n    Finds all connected components of non-zero cells using BFS.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - A set of (row, col) coordinates belonging to the component.\n        - A set of unique non-zero colors present in the component.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-zero cell\n            if grid[r][c] != 0 and (r, c) not in visited:\n                component_cells = set()\n                component_colors = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_cells.add((curr_r, curr_c))\n                    component_colors.add(grid[curr_r][curr_c])\n\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(curr_r, curr_c, rows, cols):\n                        if grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Ensure only non-zero colors are stored and component is not empty\n                component_colors.discard(0)\n                if component_colors: # Only add components with actual colors\n                    components.append((component_cells, component_colors))\n    return components\n\ndef find_interface_cells(grid: list[list[int]], component_cells: set[tuple[int, int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Identifies interface cells within a component. An interface cell is adjacent\n    (8-way) to another cell *within the same component* that has a *different non-zero* color.\n\n    Args:\n        grid: The input grid.\n        component_cells: Set of (row, col) coordinates for the component.\n\n    Returns:\n        A set of (row, col) coordinates of all interface cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    interface_cells = set()\n    \n    # Pre-fetch colors for faster lookup within the component\n    component_data = {cell: grid[cell[0]][cell[1]] for cell in component_cells}\n    \n    for r, c in component_cells:\n        cell_color = component_data.get((r, c), 0) # Use .get for safety\n        # Skip background cells if they somehow got included\n        if cell_color == 0: continue \n            \n        is_interface = False\n        # Check neighbors\n        for nr, nc in get_neighbors(r, c, rows, cols):\n            # Check if neighbor is in the same component\n            if (nr, nc) in component_data: \n                neighbor_color = component_data[(nr, nc)]\n                # Check if neighbor has a different non-zero color\n                if neighbor_color != 0 and neighbor_color != cell_color:\n                    is_interface = True\n                    break # Found an interface neighbor, no need to check further\n        if is_interface:\n            interface_cells.add((r, c))\n            \n    return interface_cells\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Initialize output_grid as a deep copy to avoid modifying the input\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n\n    # Find all connected components of non-zero cells\n    components = find_components(input_grid)\n\n    # Process each component\n    for component_cells, component_colors in components:\n        \n        # Skip components with only one non-zero color\n        if len(component_colors) <= 1:\n            continue\n\n        # Determine max color for this multi-color component\n        max_color = max(component_colors)\n\n        # Calculate minimum row for each column within the component for later propagation reference\n        min_row_in_col = collections.defaultdict(lambda: rows)\n        for r_comp, c_comp in component_cells:\n            min_row_in_col[c_comp] = min(min_row_in_col[c_comp], r_comp)\n\n        # Initialize set to store columns where propagation should occur\n        propagation_columns = set()\n        \n        # --- Removal Step ---\n        if max_color == 7:\n            # Case 1: Max color is 7 - remove all 7s\n            cells_to_remove = set()\n            removed_cols_list = []\n            # Identify all cells with color 7 in this component\n            for r_comp, c_comp in component_cells:\n                if input_grid[r_comp][c_comp] == 7:\n                    cells_to_remove.add((r_comp, c_comp))\n                    removed_cols_list.append(c_comp) # Track columns containing removed 7s\n            \n            # Remove the identified cells in the output grid\n            for r_rem, c_rem in cells_to_remove:\n                output_grid[r_rem][c_rem] = 0\n\n            # Determine propagation column (median of unique columns where 7s were removed)\n            if removed_cols_list:\n                unique_sorted_cols = sorted(list(set(removed_cols_list)))\n                # Calculate median index (floor for even counts)\n                median_index = math.floor(len(unique_sorted_cols) / 2) \n                # Check if index is valid before accessing\n                if median_index < len(unique_sorted_cols): \n                    propagation_columns.add(unique_sorted_cols[median_index])\n\n        else:\n            # Case 2: Max color is not 7 - remove max_color interface cells\n            interface_cells = find_interface_cells(input_grid, component_cells)\n            cells_to_remove = set()\n\n            # Identify interface cells that have the max_color\n            for r_int, c_int in interface_cells:\n                if input_grid[r_int][c_int] == max_color:\n                    cells_to_remove.add((r_int, c_int))\n                    # Add the column of *any* removed max_color interface cell for propagation\n                    propagation_columns.add(c_int) \n\n            # Remove the identified cells in the output grid\n            for r_rem, c_rem in cells_to_remove:\n                 output_grid[r_rem][c_rem] = 0\n\n        # --- Propagation Step ---\n        # Perform propagation for each identified column\n        for c_prop in propagation_columns:\n            # Get the minimum row the component occupied in this column\n            min_row_col = min_row_in_col.get(c_prop, rows) # Use .get for safety\n            if min_row_col == rows: continue # Skip if component wasn't actually in this column\n\n            # Trace upwards from the cell just above the component's top in this column\n            fill_cells = []\n            r_trace = min_row_col - 1\n            # Use the *input_grid* to find the block of 0s\n            while r_trace >= 0 and input_grid[r_trace][c_prop] == 0:\n                fill_cells.append((r_trace, c_prop))\n                r_trace -= 1\n            \n            # Fill the identified block in the *output_grid* with the component's max_color\n            for r_fill, c_fill in fill_cells:\n                 # Check bounds again just in case (though should be fine)\n                 if 0 <= r_fill < rows and 0 <= c_fill < cols:\n                     output_grid[r_fill][c_fill] = max_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21690,
    "candidates_token_count": 2954,
    "total_token_count": 24644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.971085,
  "retries": 1
}