{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms a grid based on the location of horizontal '7 7 7' patterns, applying rules in a specific order of precedence.\n\n1.  Identifies all horizontal sequences of '7 7 7' in the input grid.\n2.  Applies transformation rules in the following priority order:\n    a.  Core Rule (Priority 1): The outer '7's of the pattern are changed to '8', and the center '7' is changed to '6'. Cells modified by this rule are finalized.\n    b.  Vertical Neighbor Rule (Priority 2): If an *input* cell value is '8' AND it is vertically adjacent to the *center* '7' of a pattern (identified in step 1) AND the cell was not modified by the Core Rule, it is changed to '6'. Cells modified by this rule are finalized.\n    c.  Adjacent Neighbor Rule (Priority 3): If a cell is orthogonally or diagonally adjacent to any *outer* '7' of a pattern (identified in step 1) AND the cell was not modified by previous rules, it is changed to '3'. Cells modified by this rule are finalized.\n    d.  Copy Rule (Priority 4): Any cell not modified by the above rules retains its original input value.\nNote: This implementation uses a simplified Adjacent Neighbor Rule (Priority 3) which is known to have discrepancies with the target output, particularly regarding preservation of original 8s and 3s.\n\"\"\"\n\ndef find_777_patterns(grid: list[list[int]]) -> tuple[set[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"\n    Finds the locations of the center and outer cells of all '7 7 7' patterns.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing two sets:\n        - center_locations: Set of (row, col) tuples for the middle '7'.\n        - outer_locations: Set of (row, col) tuples for the left and right '7's.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    center_locations = set()\n    outer_locations = set()\n\n    for r in range(height):\n        for c in range(1, width - 1):\n            # Check for the '7 7 7' pattern horizontally\n            if grid[r][c-1] == 7 and grid[r][c] == 7 and grid[r][c+1] == 7:\n                center_locations.add((r, c))\n                outer_locations.add((r, c - 1))\n                outer_locations.add((r, c + 1))\n    return center_locations, outer_locations\n\ndef get_neighbors(r: int, c: int, height: int, width: int, diagonal: bool = True) -> list[tuple[int, int]]:\n    \"\"\"\n    Gets valid neighbor coordinates for a given cell.\n\n    Args:\n        r: Row index of the cell.\n        c: Column index of the cell.\n        height: Grid height.\n        width: Grid width.\n        diagonal: Whether to include diagonal neighbors (default True).\n\n    Returns:\n        A list of valid (row, col) neighbor coordinates.\n    \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            # Skip the cell itself\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonals if diagonal is False\n            if not diagonal and abs(dr) + abs(dc) > 1:\n                continue\n\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Applies the transformation rules to the input grid.\"\"\"\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # --- Identify patterns ---\n    center_7_locations, outer_7_locations = find_777_patterns(input_grid)\n\n    # Keep track of cells modified by higher priority rules\n    modified_cells = set()\n\n    # --- Priority 1: Apply Core Rule ---\n    # Iterate through center locations, update grid, mark as modified\n    for r, c in center_7_locations:\n        output_grid[r][c] = 6\n        modified_cells.add((r, c))\n    # Iterate through outer locations, update grid, mark as modified\n    for r, c in outer_7_locations:\n        output_grid[r][c] = 8\n        modified_cells.add((r, c))\n\n    # --- Priority 2: Apply Vertical Neighbor Rule ---\n    # Iterate through all grid cells\n    for r in range(height):\n        for c in range(width):\n            # Check if cell was already modified by a higher priority rule\n            if (r, c) in modified_cells:\n                continue\n\n            # Check condition: Input value is 8\n            if input_grid[r][c] == 8:\n                is_vert_neighbor_to_center = False\n                # Check cell above (if exists)\n                if r > 0 and (r - 1, c) in center_7_locations:\n                    is_vert_neighbor_to_center = True\n                # Check cell below (if exists)\n                if not is_vert_neighbor_to_center and r < height - 1 and (r + 1, c) in center_7_locations:\n                    is_vert_neighbor_to_center = True\n\n                # Apply rule if condition met\n                if is_vert_neighbor_to_center:\n                    output_grid[r][c] = 6\n                    modified_cells.add((r, c))\n\n    # --- Priority 3: Apply Adjacent Neighbor Rule ---\n    # Iterate through all grid cells\n    for r in range(height):\n        for c in range(width):\n            # Check if cell was already modified by a higher priority rule\n            if (r, c) in modified_cells:\n                continue\n\n            # Check condition: Is adjacent to any outer 7 location\n            is_adjacent_to_outer_7 = False\n            # Get all 8 neighbors (orthogonal and diagonal)\n            neighbors = get_neighbors(r, c, height, width, diagonal=True)\n            for nr, nc in neighbors:\n                if (nr, nc) in outer_7_locations:\n                    is_adjacent_to_outer_7 = True\n                    break # Found one, no need to check others\n\n            # Apply rule if condition met\n            if is_adjacent_to_outer_7:\n                output_grid[r][c] = 3\n                modified_cells.add((r, c))\n\n    # --- Priority 4: Copy Rule (Implicit) ---\n    # Cells not added to modified_cells retain their initial value from the deep copy.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20364,
    "candidates_token_count": 1925,
    "total_token_count": 22289,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.905484,
  "retries": 1
}