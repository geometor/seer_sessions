{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms a grid based on the location of horizontal '7 7 7' patterns, applying rules in a specific order of precedence.\n\n1.  Identifies all horizontal sequences of '7 7 7' in the input grid.\n2.  Applies transformation rules in the following priority order:\n    a.  Core Rule: The outer '7's of the pattern are changed to '8', and the center '7' is changed to '6'. Cells modified by this rule are finalized.\n    b.  Vertical Neighbor Rule: If an *input* cell value is '8' AND it is vertically adjacent to the *center* '7' of a pattern (identified in step 1) AND the cell was not modified by the Core Rule, it is changed to '6'. Cells modified by this rule are finalized.\n    c.  Adjacent Neighbor Rule: If an *input* cell value is *not* '0' AND it is orthogonally or diagonally adjacent to any *outer* '7' of a pattern (identified in step 1) AND the cell was not modified by previous rules, it is changed to '3'. Cells modified by this rule are finalized.\n    d.  Copy Rule: Any cell not modified by the above rules retains its original input value.\n\"\"\"\n\ndef find_777_patterns(grid: list[list[int]]) -> tuple[set[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"\n    Finds the locations of the center and outer cells of all '7 7 7' patterns.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing two sets:\n        - center_locations: Set of (row, col) tuples for the middle '7'.\n        - outer_locations: Set of (row, col) tuples for the left and right '7's.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    center_locations = set()\n    outer_locations = set()\n\n    for r in range(height):\n        for c in range(1, width - 1):\n            # Check for the '7 7 7' pattern horizontally\n            if grid[r][c-1] == 7 and grid[r][c] == 7 and grid[r][c+1] == 7:\n                center_locations.add((r, c))\n                outer_locations.add((r, c - 1))\n                outer_locations.add((r, c + 1))\n    return center_locations, outer_locations\n\ndef get_neighbors(r: int, c: int, height: int, width: int, diagonal: bool = True) -> list[tuple[int, int]]:\n    \"\"\"\n    Gets valid neighbor coordinates for a given cell.\n\n    Args:\n        r: Row index of the cell.\n        c: Column index of the cell.\n        height: Grid height.\n        width: Grid width.\n        diagonal: Whether to include diagonal neighbors (default True).\n\n    Returns:\n        A list of valid (row, col) neighbor coordinates.\n    \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            # Skip the cell itself\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonals if diagonal is False\n            if not diagonal and abs(dr) + abs(dc) > 1:\n                continue\n            \n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid with precedence.\n    \"\"\"\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find all '7 7 7' patterns based on the input grid\n    center_7_locations, outer_7_locations = find_777_patterns(input_grid)\n\n    # Keep track of cells modified by higher priority rules\n    modified_cells = set()\n\n    # --- Priority 1: Apply Core Rule ---\n    # Change center 7s to 6\n    for r, c in center_7_locations:\n        output_grid[r][c] = 6\n        modified_cells.add((r, c))\n    # Change outer 7s to 8\n    for r, c in outer_7_locations:\n        output_grid[r][c] = 8\n        modified_cells.add((r, c))\n\n    # --- Priority 2: Apply Vertical Neighbor Rule ---\n    for r in range(height):\n        for c in range(width):\n            # Check if cell was already modified\n            if (r, c) in modified_cells:\n                continue\n            \n            # Check if input value is 8\n            if input_grid[r][c] == 8:\n                # Check cell above for being a center 7 location\n                if r > 0 and (r - 1, c) in center_7_locations:\n                    output_grid[r][c] = 6\n                    modified_cells.add((r, c))\n                    continue # Cell modified, move to next cell\n                # Check cell below for being a center 7 location\n                if r < height - 1 and (r + 1, c) in center_7_locations:\n                    output_grid[r][c] = 6\n                    modified_cells.add((r, c))\n                    # continue # No need for continue here as it's the last check in this block\n\n    # --- Priority 3: Apply Adjacent Neighbor Rule ---\n    for r in range(height):\n        for c in range(width):\n            # Check if cell was already modified by higher priority rules\n            if (r, c) in modified_cells:\n                continue\n\n            # Check if input value is NOT 0\n            if input_grid[r][c] != 0:\n                # Check if any neighbor is an outer 7 location\n                is_adjacent_to_outer_7 = False\n                neighbors = get_neighbors(r, c, height, width, diagonal=True)\n                for nr, nc in neighbors:\n                    if (nr, nc) in outer_7_locations:\n                        is_adjacent_to_outer_7 = True\n                        break # Found one adjacent outer 7, no need to check further\n                \n                # If adjacent, change to 3 and mark as modified\n                if is_adjacent_to_outer_7:\n                    output_grid[r][c] = 3\n                    modified_cells.add((r, c))\n\n    # --- Priority 4: Copy Rule (Implicit) ---\n    # Cells not in modified_cells retain their original value from the initial copy.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12147,
    "candidates_token_count": 2108,
    "total_token_count": 14255,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.592789,
  "retries": 1
}