{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms a grid based on the location of horizontal '7 7 7' patterns.\n\n1.  Identifies all horizontal sequences of '7 7 7' in the input grid.\n2.  Modifies the grid based on proximity to these patterns:\n    a.  The outer '7's of the pattern are changed to '8'.\n    b.  The center '7' of the pattern is changed to '6'.\n    c.  Input '8's vertically adjacent to the center '7' of a pattern are changed to '6'.\n    d.  Any cell (regardless of initial value) orthogonally or diagonally adjacent \n        to the *outer* '7's of a pattern is changed to '3'.\n3.  Handles precedence:\n    a.  The core '7 7 7' transformation (to '8 6 8') takes highest priority.\n    b.  If a cell qualifies for both the vertical '6' change (Rule 2c) and the \n        adjacent '3' change (Rule 2d):\n        i.  If the adjacent '3' change was triggered by an outer '7' in the *same row* \n            (i.e., horizontally adjacent), the vertical '6' change takes precedence.\n        ii. Otherwise (triggered by diagonal or different row outer '7'), the adjacent '3' \n            change takes precedence.\n    c.  If a cell qualifies for only one of Rule 2c or 2d, that rule is applied.\n    d.  If a cell is not affected by any rule, its value remains unchanged.\n\"\"\"\n\ndef find_777_patterns(grid: list[list[int]]) -> tuple[set[tuple[int, int]], set[tuple[int, int]]]:\n    \"\"\"\n    Finds the locations of the center and outer cells of all '7 7 7' patterns.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing two sets:\n        - center_locations: Set of (row, col) tuples for the middle '7'.\n        - outer_locations: Set of (row, col) tuples for the left and right '7's.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    center_locations = set()\n    outer_locations = set()\n\n    for r in range(height):\n        for c in range(1, width - 1):\n            if grid[r][c-1] == 7 and grid[r][c] == 7 and grid[r][c+1] == 7:\n                center_locations.add((r, c))\n                outer_locations.add((r, c - 1))\n                outer_locations.add((r, c + 1))\n    return center_locations, outer_locations\n\ndef get_neighbors(r: int, c: int, height: int, width: int, diagonal: bool = True) -> list[tuple[int, int]]:\n    \"\"\"\n    Gets valid neighbor coordinates for a given cell.\n\n    Args:\n        r: Row index of the cell.\n        c: Column index of the cell.\n        height: Grid height.\n        width: Grid width.\n        diagonal: Whether to include diagonal neighbors.\n\n    Returns:\n        A list of valid (row, col) neighbor coordinates.\n    \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not diagonal and abs(dr) + abs(dc) > 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid: The 2D list representing the input grid.\n\n    Returns:\n        The 2D list representing the transformed output grid.\n    \"\"\"\n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find all '7 7 7' patterns\n    center_7_locations, outer_7_locations = find_777_patterns(input_grid)\n\n    # --- Stage 1: Apply Core Rule (Highest Priority) ---\n    modified_by_core = set()\n    # Change center 7s to 6\n    for r, c in center_7_locations:\n        output_grid[r][c] = 6\n        modified_by_core.add((r, c))\n    # Change outer 7s to 8\n    for r, c in outer_7_locations:\n        output_grid[r][c] = 8\n        modified_by_core.add((r, c))\n\n    # --- Stage 2: Identify Potential Changes for Other Rules ---\n    potential_vertical_6_locations = set()\n    # Map locations potentially changed to 3 to whether the trigger was horizontal\n    potential_adjacent_3_info = {} # (r, c) -> bool (True if same-row trigger)\n\n    for r in range(height):\n        for c in range(width):\n            # Check for Vertical 6 Rule\n            if input_grid[r][c] == 8:\n                # Check cell above\n                if r > 0 and (r - 1, c) in center_7_locations:\n                    potential_vertical_6_locations.add((r, c))\n                # Check cell below\n                if r < height - 1 and (r + 1, c) in center_7_locations:\n                    potential_vertical_6_locations.add((r, c))\n\n            # Check for Adjacent 3 Rule\n            is_adjacent_to_outer_7 = False\n            triggered_by_same_row = False\n            neighbors = get_neighbors(r, c, height, width, diagonal=True)\n            for nr, nc in neighbors:\n                if (nr, nc) in outer_7_locations:\n                    is_adjacent_to_outer_7 = True\n                    if nr == r: # Triggering outer 7 is in the same row\n                        triggered_by_same_row = True\n                        # We only need one same-row trigger to mark it True\n                        # break # Optimization removed: need to check all neighbors for potential_adjacent_3_info population\n\n            if is_adjacent_to_outer_7:\n                 # Store whether *any* same-row trigger occurred for this cell\n                 if (r,c) not in potential_adjacent_3_info:\n                     potential_adjacent_3_info[(r,c)] = triggered_by_same_row\n                 elif not potential_adjacent_3_info[(r,c)]: # Only upgrade to True if currently False\n                     potential_adjacent_3_info[(r,c)] = triggered_by_same_row\n\n\n    # --- Stage 3: Apply Remaining Rules with Precedence ---\n    for r in range(height):\n        for c in range(width):\n            # Skip cells already modified by the core rule\n            if (r, c) in modified_by_core:\n                continue\n\n            is_potential_vertical_6 = (r, c) in potential_vertical_6_locations\n            is_potential_adjacent_3 = (r, c) in potential_adjacent_3_info\n\n            if is_potential_vertical_6 and is_potential_adjacent_3:\n                # Conflict: Apply precedence logic\n                triggered_by_same_row_adj = potential_adjacent_3_info[(r, c)]\n                if triggered_by_same_row_adj:\n                    # Vertical 6 wins if Adjacent 3 was triggered by same-row outer 7\n                    output_grid[r][c] = 6\n                else:\n                    # Adjacent 3 wins otherwise\n                    output_grid[r][c] = 3\n            elif is_potential_vertical_6:\n                # Only Vertical 6 applies\n                output_grid[r][c] = 6\n            elif is_potential_adjacent_3:\n                # Only Adjacent 3 applies\n                output_grid[r][c] = 3\n            # Else: No rules apply, keep the original value (already copied)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3592,
    "candidates_token_count": 3359,
    "total_token_count": 6951,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.274291,
  "retries": 1
}