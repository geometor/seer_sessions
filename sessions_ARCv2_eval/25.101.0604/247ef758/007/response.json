{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nTransforms an input grid based on identifying a vertical axis column and applying rules row-by-row.\n\n1.  Initialize an `output_grid` with the same dimensions as the `input_grid`, filled with zeros.\n2.  Handle edge case: If the input grid height `H` is 0 or width `W` is 0, return an empty grid.\n3.  Identify the `axis_column` index (`axis_col`) and the shared `axis_value` by finding the first column where all middle rows (1 to H-2) share the same single non-zero value. Use fallbacks if no such column exists or H < 3.\n4.  Define the rule sets for modifying the `right_zone` (columns `axis_col + 2` to `W-2`) based on the `axis_value`:\n    *   If `axis_value` is 2: Selector 4 draws [4,4,4] at cols 8-10; Selector 7 draws [7,7,7] at cols 9-11. Others noop.\n    *   If `axis_value` is 3: Selector 4 copies input[0,7]->output[r,7] and input[0,11]->output[r,11]; Selector 7 draws [7,7,7,7,0,7,7,7] centered; Selector 5 draws [5,0,5] centered. Others noop.\n    *   If `axis_value` is 1: Selector 3 draws [3,3,3] centered; Selector 6 draws [6,0,6,6] right-aligned. Others noop.\n    *   Otherwise: Empty rule set (noop for all).\n5.  For each row `r` from 0 to H-1:\n    a.  Clear the left zone (`output_grid[r, 0:axis_col] = 0`).\n    b.  Copy the axis column value (`input_grid[r, axis_col]` to `output_grid[r, axis_col]`).\n    c.  Copy the value column value (`input_grid[r, axis_col+1]` to `output_grid[r, axis_col+1]`) and determine the `selector_color` C.\n    d.  Copy the last column value (`input_grid[r, W-1]` to `output_grid[r, W-1]`).\n    e.  Apply the rule for `C` based on `axis_value` to the right zone columns (`axis_col + 2` to `W-2`) of the output grid.\n6.  Return the `output_grid`.\n\"\"\"\n\ndef find_axis_column(grid: np.ndarray) -> tuple[int, int]:\n    \"\"\"\n    Finds the index of the vertical axis column and its common non-zero value.\n    The axis column is the first column 'j' such that grid[r, j]\n    has the same non-zero value for all middle rows r (1 to H-2).\n    Includes fallbacks for edge cases.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        A tuple (axis_col_index, axis_value).\n        Returns (0, 0) if no clear axis is found or grid is too small.\n    \"\"\"\n    H, W = grid.shape\n    axis_value = 0\n\n    # Handle grids too small to have middle rows (H<=2)\n    if H <= 2:\n        for j in range(W):\n             if np.any(grid[:, j] != 0):\n                 axis_val_candidate = 0\n                 if H > 0 and 0 <= j < W: axis_val_candidate = grid[0, j]\n                 # Prioritize value from row 1 if row 0 is 0 and H>1\n                 if H > 1 and 0 <= j < W and axis_val_candidate == 0: axis_val_candidate = grid[1, j]\n                 return j, axis_val_candidate\n        return 0, 0 # Grid is all zeros or empty\n\n    middle_rows = grid[1:H-1, :]\n\n    # Primary rule: Find first column with a single, non-zero value repeated\n    for j in range(W):\n        if j >= middle_rows.shape[1]: continue\n        col = middle_rows[:, j]\n        unique_vals = np.unique(col)\n        if len(unique_vals) == 1 and unique_vals[0] != 0:\n             return j, unique_vals[0] # Found axis column and value\n\n    # Fallback if primary rule fails: first col with any non-zero in middle rows\n    axis_col_fallback = 0\n    axis_value_fallback = 0\n    found_fallback = False\n    for j in range(W):\n        if j >= middle_rows.shape[1]: continue\n        if np.any(middle_rows[:, j] != 0):\n            axis_col_fallback = j\n            # Use the value from the first middle row as the fallback axis value\n            axis_value_fallback = middle_rows[0, j] if middle_rows.shape[0] > 0 else 0\n            found_fallback = True\n            break\n    if found_fallback:\n        return axis_col_fallback, axis_value_fallback\n\n    # Absolute fallback: return 0, 0 if no clear axis found\n    return 0, 0\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules row-by-row to the input grid.\n    \"\"\"\n    # Convert input to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    H, W = input_grid.shape\n\n    # Handle edge cases: empty grid\n    if H == 0 or W == 0:\n        return []\n\n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_grid)\n\n    # Identify axis column and value using middle rows (handles H<=2 via fallbacks)\n    axis_col, axis_value = find_axis_column(input_grid)\n\n    # Define rules based on the axis value (task context)\n    # Rules apply to the 'right_zone' (cols axis_col + 2 to W - 2)\n    rules = {}\n    if axis_value == 2: # Task 1 context (train_1)\n        rules = {\n            # Use absolute fixed columns for drawing\n            4: ('draw_fixed', [4,4,4], 8),  # Draw at col 8, 9, 10\n            7: ('draw_fixed', [7,7,7], 9),  # Draw at col 9, 10, 11\n            6: ('noop',),                   # Noop (last col handled separately)\n            3: ('noop',)                    # Noop (last col handled separately)\n        }\n    elif axis_value == 3: # Task 2 context (train_2)\n        rules = {\n             # Copy specific indices from input row 0\n            4: ('copy_indices_specific', 0, {7: 7, 11: 11}),\n            7: ('draw_aligned', [7,7,7,7, 0, 7,7,7], 'center'), # Draw aligned in right_zone\n            5: ('draw_aligned', [5, 0, 5], 'center'),          # Draw aligned in right_zone\n            3: ('noop',)\n        }\n    elif axis_value == 1: # Task 3 context (train_3)\n         rules = {\n            3: ('draw_aligned', [3,3,3], 'center'),           # Draw aligned in right_zone\n            6: ('draw_aligned', [6, 0, 6, 6], 'right'),      # Draw aligned in right_zone\n            2: ('noop',),                                    # Conditional rule disproven\n            1: ('noop',)\n        }\n\n    # Process ALL rows (0 to H-1)\n    for r in range(H):\n        # --- Part A: Clear Left Zone ---\n        if axis_col > 0:\n            output_grid[r, 0:axis_col] = 0\n\n        # --- Part B: Copy Axis Column ---\n        if 0 <= axis_col < W:\n            output_grid[r, axis_col] = input_grid[r, axis_col]\n\n        # --- Part C: Copy Value Column & Get Selector ---\n        selector_color = 0 # Default\n        value_col = axis_col + 1\n        if value_col < W:\n             output_grid[r, value_col] = input_grid[r, value_col]\n             selector_color = input_grid[r, value_col]\n        #else:\n             # If no value column, selector remains 0, rules likely won't match\n\n        # --- Part D: Copy Last Column ---\n        if W > 0:\n             # Ensure last col index is valid before copying\n             last_col_idx = W - 1\n             if 0 <= last_col_idx < W :\n                 output_grid[r, last_col_idx] = input_grid[r, last_col_idx]\n\n\n        # --- Part E: Apply Rules to the Right Zone ---\n        if selector_color in rules:\n            action = rules[selector_color]\n            rule_type = action[0]\n\n            # Define the 'right_zone' where these rules apply (cols axis_col + 2 up to, but not including, the last col)\n            right_zone_start_col = axis_col + 2\n            right_zone_end_col = W - 1 # Exclusive index (ends at W-2)\n            right_zone_width = right_zone_end_col - right_zone_start_col\n\n            # Proceed only if the right zone exists (width > 0)\n            if right_zone_width <= 0: continue\n\n            # Execute action based on rule type\n            if rule_type == 'draw_aligned':\n                _, pattern, alignment = action\n                pattern_arr = np.array(pattern)\n                pattern_width = len(pattern_arr)\n\n                if pattern_width > right_zone_width: continue # Pattern too wide\n\n                start_offset = 0 # Default for left alignment\n                if alignment == 'center':\n                    start_offset = (right_zone_width - pattern_width) // 2\n                elif alignment == 'right':\n                    start_offset = right_zone_width - pattern_width\n\n                # Calculate absolute draw column indices within the output grid\n                draw_start_col = right_zone_start_col + start_offset\n                # Ensure drawing doesn't go past the defined right zone end or grid bounds\n                draw_end_col = min(draw_start_col + pattern_width, right_zone_end_col, W)\n                pattern_len_to_draw = draw_end_col - draw_start_col\n\n                if pattern_len_to_draw > 0:\n                   output_grid[r, draw_start_col:draw_end_col] = pattern_arr[:pattern_len_to_draw]\n\n            elif rule_type == 'draw_fixed':\n                 _, pattern, start_col_abs = action\n                 pattern_arr = np.array(pattern)\n                 pattern_width = len(pattern_arr)\n\n                 # Calculate absolute end column\n                 end_col_abs = start_col_abs + pattern_width\n\n                 # Check if the draw region is valid within grid bounds\n                 if start_col_abs >= W or start_col_abs < 0: continue # Start is out of bounds\n\n                 # Clip end column to grid width\n                 draw_end_col = min(end_col_abs, W)\n                 # Calculate actual length to draw\n                 pattern_len_to_draw = draw_end_col - start_col_abs\n\n                 if pattern_len_to_draw > 0:\n                      output_grid[r, start_col_abs:draw_end_col] = pattern_arr[:pattern_len_to_draw]\n\n\n            elif rule_type == 'copy_indices_specific':\n                _, source_row_idx, index_map = action # index_map is {source_col: target_col}\n                for source_col, target_col in index_map.items():\n                    # Check validity for source row/col and target col\n                    # Also ensure target column is within the defined right_zone\n                    if 0 <= source_row_idx < H and 0 <= source_col < W and \\\n                       right_zone_start_col <= target_col < right_zone_end_col:\n                           # Check target column is within overall grid bounds (redundant but safe)\n                           if 0 <= target_col < W:\n                               output_grid[r, target_col] = input_grid[source_row_idx, source_col]\n\n            # 'noop' requires no action\n\n    # Convert final numpy array grid back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 37881,
    "candidates_token_count": 3761,
    "total_token_count": 41642,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.868324,
  "retries": 1
}