{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the unique 'noisy' shape (a connected component containing \n   multiple colors, using 4-directional connectivity).\n2. Determining the 'border' color (most frequent color within the noisy shape, \n   using max color value as tie-breaker).\n3. Extracting the 'noise' pixels (those differing from the border color) into \n   a minimal bounding box grid ('noise_grid').\n4. Calculating a scaling factor based on the noisy shape's bounding box width: \n   Scale = Width - 1.\n5. Determining the output grid dimensions by scaling the 'noise_grid' \n   dimensions by the 'Scale' factor.\n6. Rendering the output grid: Each output pixel (r_out, c_out) takes the color \n   of the noise grid pixel at (r_out // Scale, c_out // Scale), effectively \n   scaling up each noise pixel into a block.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _find_noisy_component_details(grid: np.ndarray):\n    \"\"\"\n    Finds the single noisy component, extracts its noise grid, and determines \n    the component width needed for scaling.\n\n    A component is a 4-directionally connected group of non-zero cells.\n    A component is noisy if it contains more than one distinct color.\n    The 'border color' is the most frequent color (max color tie-breaker).\n    'Noise pixels' are cells in the noisy component whose color is not the \n    border color.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        tuple: (noise_grid, H_noise, W_noise, W_comp)\n               - noise_grid: NumPy array of the noise pattern.\n               - H_noise: Height of the noise grid.\n               - W_noise: Width of the noise grid.\n               - W_comp: Width of the noisy component's bounding box.\n        Returns (None, None, None, None) if no noisy component is found or \n        if a valid noise pattern cannot be extracted.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    noisy_component_found = None # Store details of the noisy component when found\n\n    # Iterate through each cell to find potential starting points for components\n    for r_start in range(rows):\n        for c_start in range(cols):\n            # Start BFS if cell is non-zero and hasn't been visited yet\n            if grid[r_start, c_start] != 0 and not visited[r_start, c_start]:\n                component_cells = {}  # Stores {(r, c): color} for the current component\n                q = deque([(r_start, c_start)]) # Queue for BFS\n                processed_in_component = set([(r_start, c_start)]) # Track cells processed in *this* component search\n                \n                # Store initial cell info\n                start_color = grid[r_start, c_start]\n                component_cells[(r_start, c_start)] = start_color\n                colors_in_component = {start_color} # Set of unique colors in component\n                visited[r_start, c_start] = True # Mark globally visited\n\n                # Initialize component bounding box coordinates\n                min_r_comp, max_r_comp = r_start, r_start\n                min_c_comp, max_c_comp = c_start, c_start\n\n                # --- Perform BFS to find all connected non-zero cells ---\n                while q:\n                    row, col = q.popleft()\n\n                    # Update component bounding box\n                    min_r_comp = min(min_r_comp, row)\n                    max_r_comp = max(max_r_comp, row)\n                    min_c_comp = min(min_c_comp, col)\n                    max_c_comp = max(max_c_comp, col)\n\n                    # Explore 4 orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check neighbor validity: within bounds, non-zero, and not already processed for this component\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in processed_in_component:\n                            \n                            visited[nr, nc] = True # Mark globally visited\n                            processed_in_component.add((nr, nc)) # Mark processed for this specific component BFS\n                            q.append((nr, nc)) # Add to queue for further exploration\n\n                            # Store neighbor cell info\n                            cell_color = grid[nr, nc]\n                            component_cells[(nr, nc)] = cell_color\n                            colors_in_component.add(cell_color)\n                # --- Component fully explored ---\n                \n                # Check if this component is the noisy one\n                if len(colors_in_component) > 1:\n                    # Found the noisy component (assuming only one exists per task)\n                    noisy_component_found = {\n                        'cells': component_cells,\n                        'min_r': min_r_comp, 'max_r': max_r_comp,\n                        'min_c': min_c_comp, 'max_c': max_c_comp\n                    }\n                    break # Exit inner loop once found\n            # If found in inner loop, exit outer loop too\n            if noisy_component_found:\n                break\n\n    # If no noisy component was identified after checking all cells\n    if not noisy_component_found:\n        return None, None, None, None \n\n    # Calculate component width from its bounding box\n    W_comp = noisy_component_found['max_c'] - noisy_component_found['min_c'] + 1\n\n    # Determine border color (most frequent, tie-break with max color value)\n    color_counts = Counter(noisy_component_found['cells'].values())\n    # Check if counter is valid (should be if noisy_component_found is set)\n    if not color_counts: \n        return None, None, None, None \n    border_color = max(color_counts, key=lambda k: (color_counts[k], k))\n\n    # Extract noise pixels (those not matching border color) into a dict with absolute coordinates\n    noise_pixels_abs = {}\n    for (r_n, c_n), color in noisy_component_found['cells'].items():\n        if color != border_color:\n            noise_pixels_abs[(r_n, c_n)] = color\n\n    # If no noise pixels were found (e.g., if all non-border colors were filtered out somehow)\n    if not noise_pixels_abs:\n        return None, None, None, None\n\n    # Determine noise bounding box from the absolute coordinates of noise pixels\n    noise_coords = list(noise_pixels_abs.keys())\n    min_r_noise = min(r for r, c in noise_coords)\n    max_r_noise = max(r for r, c in noise_coords)\n    min_c_noise = min(c for r, c in noise_coords)\n    max_c_noise = max(c for r, c in noise_coords)\n\n    # Calculate noise grid dimensions\n    H_noise = max_r_noise - min_r_noise + 1\n    W_noise = max_c_noise - min_c_noise + 1\n\n    # Create the relative noise grid (initialized to 0)\n    noise_grid = np.zeros((H_noise, W_noise), dtype=int)\n    # Populate the noise grid using relative coordinates\n    for (r_abs, c_abs), color in noise_pixels_abs.items():\n        noise_grid[r_abs - min_r_noise, c_abs - min_c_noise] = color\n\n    # Return the noise grid and its dimensions, plus the component width\n    return noise_grid, H_noise, W_noise, W_comp\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # Step 1-4: Find noisy component, determine border color, extract noise grid, get component width\n    noise_grid, H_noise, W_noise, W_comp = _find_noisy_component_details(input_array)\n\n    # Handle case where no valid noisy component or noise pattern was found\n    if noise_grid is None:\n        # Return empty list as per common ARC error handling for unapplicable rules\n        return [] \n\n    # Step 5a: Calculate Scale factor\n    Scale = W_comp - 1\n    \n    # Validate scale factor (must be positive)\n    if Scale <= 0:\n        # If component width is 1 or less, scale is invalid. Return empty.\n        return [] \n\n    # Step 5b: Calculate Output Grid Size\n    H_out = H_noise * Scale\n    W_out = W_noise * Scale\n\n    # Step 6: Render Output Grid using direct mapping (upscaling)\n    output_grid = np.zeros((H_out, W_out), dtype=int)\n\n    # Iterate through each pixel coordinate (r_out, c_out) of the output grid\n    for r_out in range(H_out):\n        for c_out in range(W_out):\n            # Determine the corresponding source pixel coordinates in the noise_grid\n            # using integer division (floor division)\n            nr = r_out // Scale \n            nc = c_out // Scale\n            \n            # Assign the color from the source noise pixel to the output pixel\n            # Boundary check is implicitly handled because 0 <= r_out < H_out and 0 <= c_out < W_out\n            # guarantees 0 <= nr < H_noise and 0 <= nc < W_noise\n            output_grid[r_out, c_out] = noise_grid[nr, nc]\n\n    # Step 7: Return the completed output grid as a list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24823,
    "candidates_token_count": 2964,
    "total_token_count": 27787,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.599458,
  "retries": 1
}