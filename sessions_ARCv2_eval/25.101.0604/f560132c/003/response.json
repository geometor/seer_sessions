{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms the input grid by identifying a unique 'noisy' shape (a connected \ncomponent containing multiple colors), extracting the 'noise' pixels (those \ndiffering from the shape's most frequent 'border' color) into a minimal \n'noise_grid', determining a scaling factor based on the noisy shape's \nbounding box width (Scale = Width - 1), scaling the 'noise_grid' dimensions \nby this factor to get the output size, and then rendering the output grid. \nEach output pixel's color is the maximum color value among the four noise \ngrid cells corresponding to the corners surrounding the output pixel's scaled \nlocation in the noise grid space (treating out-of-bounds lookups as 0).\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _get_val_safe(grid: np.ndarray, r: int, c: int) -> int:\n    \"\"\"\n    Safely gets a value from a grid using integer indices, returning 0 for \n    out-of-bounds coordinates.\n    \"\"\"\n    H, W = grid.shape\n    if 0 <= r < H and 0 <= c < W:\n        return int(grid[r, c])\n    return 0\n\ndef _find_noisy_component_details(grid: np.ndarray):\n    \"\"\"\n    Finds the single noisy component, extracts its noise grid, and determines \n    the component width needed for scaling.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        tuple: (noise_grid, H_noise, W_noise, W_comp)\n               - noise_grid: NumPy array of the noise pattern.\n               - H_noise: Height of the noise grid.\n               - W_noise: Width of the noise grid.\n               - W_comp: Width of the noisy component's bounding box.\n        Returns (None, None, None, None) if no noisy component is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    noisy_component_found = None\n\n    for r_start in range(rows):\n        for c_start in range(cols):\n            if grid[r_start, c_start] != 0 and not visited[r_start, c_start]:\n                component_cells = {}  # {(r, c): color}\n                q = deque([(r_start, c_start)])\n                processed_in_component = set([(r_start, c_start)])\n                \n                start_color = grid[r_start, c_start]\n                component_cells[(r_start, c_start)] = start_color\n                colors_in_component = {start_color}\n                visited[r_start, c_start] = True\n\n                min_r_comp, max_r_comp = r_start, r_start\n                min_c_comp, max_c_comp = c_start, c_start\n\n                # BFS to find component extent and colors\n                while q:\n                    row, col = q.popleft()\n\n                    min_r_comp = min(min_r_comp, row)\n                    max_r_comp = max(max_r_comp, row)\n                    min_c_comp = min(min_c_comp, col)\n                    max_c_comp = max(max_c_comp, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in processed_in_component:\n                            \n                            visited[nr, nc] = True\n                            processed_in_component.add((nr, nc))\n                            q.append((nr, nc))\n\n                            cell_color = grid[nr, nc]\n                            component_cells[(nr, nc)] = cell_color\n                            colors_in_component.add(cell_color)\n                \n                # Check if this component is noisy\n                if len(colors_in_component) > 1:\n                    # Found the noisy component (assuming only one exists)\n                    noisy_component_found = {\n                        'cells': component_cells,\n                        'min_r': min_r_comp, 'max_r': max_r_comp,\n                        'min_c': min_c_comp, 'max_c': max_c_comp\n                    }\n                    break # Stop searching once the noisy component is found\n            if noisy_component_found:\n                break # Stop outer loop as well\n\n    if not noisy_component_found:\n        return None, None, None, None # Indicate failure\n\n    # Calculate component width\n    W_comp = noisy_component_found['max_c'] - noisy_component_found['min_c'] + 1\n\n    # Determine border color (most frequent, tie-break with max color value)\n    color_counts = Counter(noisy_component_found['cells'].values())\n    if not color_counts: # Should not happen if noisy_component_found is set\n        return None, None, None, None \n    border_color = max(color_counts, key=lambda k: (color_counts[k], k))\n\n    # Extract noise pixels (absolute coordinates)\n    noise_pixels_abs = {}\n    for (r_n, c_n), color in noisy_component_found['cells'].items():\n        if color != border_color:\n            noise_pixels_abs[(r_n, c_n)] = color\n\n    if not noise_pixels_abs:\n         # This case might occur if multiple colors exist but only one is non-border\n         # Or if the most frequent color calculation had unexpected behaviour.\n         # Depending on exact problem constraints, might need different handling.\n         # For now, treat as failure if no distinct noise pixels found.\n        return None, None, None, None\n\n    # Determine noise bounding box\n    noise_coords = list(noise_pixels_abs.keys())\n    min_r_noise = min(r for r, c in noise_coords)\n    max_r_noise = max(r for r, c in noise_coords)\n    min_c_noise = min(c for r, c in noise_coords)\n    max_c_noise = max(c for r, c in noise_coords)\n\n    H_noise = max_r_noise - min_r_noise + 1\n    W_noise = max_c_noise - min_c_noise + 1\n\n    # Create relative noise grid\n    noise_grid = np.zeros((H_noise, W_noise), dtype=int)\n    for (r_abs, c_abs), color in noise_pixels_abs.items():\n        noise_grid[r_abs - min_r_noise, c_abs - min_c_noise] = color\n\n    return noise_grid, H_noise, W_noise, W_comp\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation pipeline to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # Step 1-4: Find noisy component, determine border color, extract noise grid, get component width\n    noise_grid, H_noise, W_noise, W_comp = _find_noisy_component_details(input_array)\n\n    if noise_grid is None:\n        # Handle case where no noisy component or valid noise pattern was found\n        # Based on ARC tasks, often implies returning an empty grid or raising error\n        # Returning empty grid for now.\n        # raise ValueError(\"Could not find a valid noisy component or noise pattern.\")\n        return [] # Or potentially handle based on specific problem context if needed\n\n    # Step 5a: Calculate Scale\n    Scale = W_comp - 1\n    if Scale <= 0:\n        # Scale must be positive. If W_comp is 1, this fails.\n        # Again, handle based on assumptions/problem constraints.\n        # raise ValueError(f\"Invalid calculated scale ({Scale}) from component width {W_comp}.\")\n        return [] # Return empty for now\n\n    # Step 5b: Calculate Output Size\n    H_out = H_noise * Scale\n    W_out = W_noise * Scale\n\n    # Step 6: Render Output Grid\n    output_grid = np.zeros((H_out, W_out), dtype=int)\n\n    for r_out in range(H_out):\n        for c_out in range(W_out):\n            # Map output pixel to fractional coordinates in noise grid space\n            r_f = r_out / Scale\n            c_f = c_out / Scale\n\n            # Identify the four reference points (integer coords) in noise grid\n            # Note: using int() conversion after floor/ceil for _get_val_safe\n            nr_tl = math.floor(r_f)\n            nc_tl = math.floor(c_f)\n            nr_tr = math.floor(r_f)\n            nc_tr = math.ceil(c_f)\n            nr_bl = math.ceil(r_f)\n            nc_bl = math.floor(c_f)\n            nr_br = math.ceil(r_f)\n            nc_br = math.ceil(c_f)\n\n            # Get values safely from noise grid (0 if out-of-bounds)\n            val_tl = _get_val_safe(noise_grid, int(nr_tl), int(nc_tl))\n            val_tr = _get_val_safe(noise_grid, int(nr_tr), int(nc_tr))\n            val_bl = _get_val_safe(noise_grid, int(nr_bl), int(nc_bl))\n            val_br = _get_val_safe(noise_grid, int(nr_br), int(nc_br))\n\n            # Assign the maximum value to the output pixel\n            output_grid[r_out, c_out] = max(val_tl, val_tr, val_bl, val_br)\n\n    # Step 7: Return Output as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15367,
    "candidates_token_count": 3066,
    "total_token_count": 18433,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.856277,
  "retries": 1
}