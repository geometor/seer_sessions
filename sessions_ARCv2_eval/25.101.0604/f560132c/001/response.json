{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid according to the following process:\n1. Identify the unique 'noisy' shape (a connected component containing multiple colors).\n   The 'border' color is the most frequent color in the component.\n2. Extract the 'noise' pixels (those differing from the shape's border color)\n   into a minimal bounding box grid ('noise_grid').\n3. Determine the scale factor by calculating the width of the bounding box\n   of the entire noisy component found in step 1.\n4. Determine the output grid size by scaling the noise_grid dimensions by the scale factor.\n5. Render the output grid: For each output pixel (r_out, c_out), map it to fractional\n   coordinates (r_f, c_f) in the noise_grid space. Find the maximum color value among\n   the four noise grid cells whose coordinates are derived using floor and ceil\n   of (r_f, c_f): (floor(r_f), floor(c_f)), (floor(r_f), ceil(c_f)),\n   (ceil(r_f), floor(c_f)), (ceil(r_f), ceil(c_f)). Out-of-bounds lookups return 0.\n\"\"\"\n\n\n# --- Helper Functions ---\n\ndef _get_val_safe(grid: np.ndarray, r: float, c: float) -> int:\n    \"\"\"\n    Safely gets a value from a grid using integer indices derived from r, c,\n    returning 0 for out-of-bounds. r and c are expected to be results from\n    math.floor or math.ceil.\n    \"\"\"\n    # Convert float results from floor/ceil to integer indices\n    r_idx = int(r)\n    c_idx = int(c)\n    H, W = grid.shape\n    # Check if the integer indices are within the grid bounds\n    if 0 <= r_idx < H and 0 <= c_idx < W:\n        # Return the value as a standard Python integer\n        return int(grid[r_idx, c_idx])\n    # Return 0 if indices are out of bounds\n    return 0\n\ndef _find_noise_grid_and_scale(grid: np.ndarray):\n    \"\"\"\n    Finds the single noisy component in the grid, extracts its noise pixels\n    into a minimal bounding box grid, and determines the scaling factor based\n    on the width of the noisy component's bounding box.\n\n    A component is a 4-directionally connected group of non-zero cells.\n    A component is noisy if it contains more than one distinct color.\n    The 'border color' is the most frequent color within the noisy component.\n    'Noise pixels' are cells in the noisy component whose color is not the border color.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        tuple: (noise_grid, scale) where noise_grid is a NumPy array containing\n               the noise pixels relative to their bounding box, and scale is an\n               integer calculated as the width of the noisy component's bounding box.\n        Returns (None, None) if no noisy component is found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool) # Tracks visited cells globally across component searches\n\n    # Iterate through each cell to find potential starting points for components\n    for r_start in range(rows):\n        for c_start in range(cols):\n            # Start BFS if cell is non-zero and hasn't been visited yet\n            if grid[r_start, c_start] != 0 and not visited[r_start, c_start]:\n                component_cells = {}  # Stores {(r, c): color} for the current component\n                q = deque([(r_start, c_start)]) # Queue for BFS\n                processed_in_component = set([(r_start, c_start)]) # Track cells processed in *this* component search\n\n                # Store initial cell info\n                start_color = grid[r_start, c_start]\n                component_cells[(r_start, c_start)] = start_color\n                colors_in_component = {start_color} # Set of unique colors in component\n                visited[r_start, c_start] = True # Mark globally visited\n\n                # Initialize component bounding box coordinates\n                min_r_comp, max_r_comp = r_start, r_start\n                min_c_comp, max_c_comp = c_start, c_start\n\n                # --- Perform BFS to find all connected non-zero cells ---\n                while q:\n                    row, col = q.popleft()\n\n                    # Update component bounding box as we explore\n                    min_r_comp = min(min_r_comp, row)\n                    max_r_comp = max(max_r_comp, row)\n                    min_c_comp = min(min_c_comp, col)\n                    max_c_comp = max(max_c_comp, col)\n\n                    # Explore 4 orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n\n                        # Check neighbor validity: within bounds, non-zero, and not already processed for this component\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in processed_in_component:\n\n                            visited[nr, nc] = True # Mark globally visited\n                            processed_in_component.add((nr, nc)) # Mark processed for this specific component BFS\n                            q.append((nr, nc)) # Add to queue for further exploration\n\n                            # Store neighbor cell info\n                            cell_color = grid[nr, nc]\n                            component_cells[(nr, nc)] = cell_color\n                            colors_in_component.add(cell_color)\n                # --- Component fully explored ---\n\n                # Analyze if it's the noisy component (contains more than one color)\n                if len(colors_in_component) > 1:\n                    # Assumption: Only one such component exists per problem statement.\n                    \n                    # Safety check: Ensure component_cells is not empty\n                    if not component_cells: continue \n\n                    # --- Identify Border Color ---\n                    # Find the most frequent color (border color)\n                    color_counts = {}\n                    for color in component_cells.values():\n                        color_counts[color] = color_counts.get(color, 0) + 1\n                    \n                    if not color_counts: continue # Safety check\n\n                    # Determine border color (handle ties by taking max count, then max color value for determinism)\n                    border_color = max(color_counts, key=lambda k: (color_counts[k], k))\n\n                    # --- Extract Noise Pixels ---\n                    # Noise pixels have absolute coordinates initially\n                    noise_pixels_abs = {}\n                    for (r_n, c_n), color in component_cells.items():\n                        if color != border_color:\n                            noise_pixels_abs[(r_n, c_n)] = color\n\n                    # Proceed only if noise pixels were actually found\n                    if noise_pixels_abs:\n                        # --- Determine Scale ---\n                        # Hypothesis: Scale is the width of the component's bounding box\n                        W_comp = max_c_comp - min_c_comp + 1\n                        scale = W_comp # Scaling factor\n\n                        # Basic validation for calculated scale\n                        if scale <= 0:\n                             raise ValueError(f\"Calculated non-positive scale: {scale}\")\n\n                        # --- Create the Relative Noise Grid ---\n                        noise_coords = list(noise_pixels_abs.keys())\n                        # Find bounding box of noise pixels\n                        min_r_noise = min(r for r, c in noise_coords)\n                        max_r_noise = max(r for r, c in noise_coords)\n                        min_c_noise = min(c for r, c in noise_coords)\n                        max_c_noise = max(c for r, c in noise_coords)\n                        \n                        # Calculate noise grid dimensions\n                        H_noise = max_r_noise - min_r_noise + 1\n                        W_noise = max_c_noise - min_c_noise + 1\n                        \n                        # Basic validation for noise grid dimensions\n                        if H_noise <= 0 or W_noise <= 0:\n                            raise ValueError(f\"Calculated non-positive noise grid dimensions: H={H_noise}, W={W_noise}\")\n\n                        # Initialize relative noise grid\n                        noise_grid_rel = np.zeros((H_noise, W_noise), dtype=int)\n                        # Populate relative noise grid\n                        for (r_abs, c_abs), color in noise_pixels_abs.items():\n                            # Map absolute noise coordinates to relative coordinates within the noise grid\n                            noise_grid_rel[r_abs - min_r_noise, c_abs - min_c_noise] = color\n\n                        # Return the extracted noise grid and the calculated scale factor\n                        return noise_grid_rel, scale\n\n    # If the loops complete without finding and returning a noisy component\n    return None, None\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation pipeline: find noisy component, extract noise grid,\n    determine scale from component width, upscale noise grid using max-of-4-neighbors rule.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n\n    Raises:\n        ValueError: If no noisy component is found, or if calculated scale or\n                    noise grid dimensions are invalid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # Step 1, 2, 3: Find the noise grid and the scaling factor\n    noise_grid, scale = _find_noise_grid_and_scale(input_array)\n\n    # Validate results from the helper function\n    if noise_grid is None:\n        raise ValueError(\"No noisy component found in the input grid.\")\n    # Scale is already validated in the helper, but check again just in case\n    if scale is None or scale <= 0:\n        raise ValueError(f\"Invalid scale determined: {scale}\")\n    # Ensure noise grid is not empty\n    if noise_grid.size == 0:\n         raise ValueError(\"Empty noise grid extracted.\")\n\n    H_noise, W_noise = noise_grid.shape\n\n    # Step 4: Determine Output Grid Size based on noise grid dimensions and scale\n    H_out = H_noise * scale\n    W_out = W_noise * scale\n\n    # Step 5: Render the Output Grid\n    output_grid = np.zeros((H_out, W_out), dtype=int)\n\n    # Iterate through each pixel coordinate (r_out, c_out) of the output grid\n    for r_out in range(H_out):\n        for c_out in range(W_out):\n            # Map output pixel coordinates to fractional coordinates (r_f, c_f) in the noise_grid space\n            # These represent the top-left corner of the corresponding area in the noise grid\n            r_f = r_out / scale\n            c_f = c_out / scale\n\n            # Identify the four reference points in the noise grid using floor/ceil of the fractional coordinates\n            # These correspond to the grid points surrounding the mapped location (r_f, c_f)\n            nr_tl = math.floor(r_f) # Top-left row index\n            nc_tl = math.floor(c_f) # Top-left col index\n            nr_tr = math.floor(r_f) # Top-right row index (same as tl)\n            nc_tr = math.ceil(c_f)  # Top-right col index\n            nr_bl = math.ceil(r_f)  # Bottom-left row index\n            nc_bl = math.floor(c_f) # Bottom-left col index (same as tl)\n            nr_br = math.ceil(r_f)  # Bottom-right row index (same as bl)\n            nc_br = math.ceil(c_f)  # Bottom-right col index (same as tr)\n\n            # Get values from the noise grid for these four reference points\n            # _get_val_safe handles out-of-bounds checks by returning 0\n            val_tl = _get_val_safe(noise_grid, nr_tl, nc_tl)\n            val_tr = _get_val_safe(noise_grid, nr_tr, nc_tr)\n            val_bl = _get_val_safe(noise_grid, nr_bl, nc_bl)\n            val_br = _get_val_safe(noise_grid, nr_br, nc_br)\n\n            # Assign the maximum of these four values to the current output grid pixel\n            output_grid[r_out, c_out] = max(val_tl, val_tr, val_bl, val_br)\n\n    # Convert the final NumPy array output grid back to a list of lists for the required return format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3929,
    "candidates_token_count": 26023,
    "total_token_count": 29952,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 188.832431,
  "retries": 1
}