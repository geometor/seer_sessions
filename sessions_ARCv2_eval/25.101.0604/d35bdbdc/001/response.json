{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nThe transformation identifies specific 3x3 patterns (\"Framed Objects\") in the input grid.\nA Framed Object consists of a non-zero center cell (color C2) surrounded by 8 cells of the same, different, non-zero color (C1).\nBased on the specific pair of (C1, C2), the object is either:\n1. Modified: The center cell C2 is changed to a new color C3, while the frame C1 remains.\n2. Removed: The entire 3x3 object (frame C1 and center C2) is replaced with the background color 0.\nCells not part of any identified Framed Object remain unchanged. Removals take precedence over modifications if coordinates overlap (though this specific rule set doesn't seem to create overlaps between removed frames and modified centers).\n\nModification Rules (Frame C1, Center C2) -> New Center C3:\n- (3, 4) -> 2\n- (6, 1) -> 3\n- (8, 3) -> 2\n- (1, 4) -> 8\n- (1, 2) -> 9\n- (7, 4) -> 3\n\nRemoval Rules (Frame C1, Center C2):\n- (1, 3)\n- (2, 6)\n- (3, 2)\n- (4, 8)\n- (4, 3)\n- (3, 6)\n- (2, 9)\n\"\"\"\n\n# Define the modification and removal rules based on (frame_color, center_color) pairs\nMODIFICATION_RULES = {\n    (3, 4): 2,\n    (6, 1): 3,\n    (8, 3): 2,\n    (1, 4): 8,\n    (1, 2): 9,\n    (7, 4): 3,\n}\n\nREMOVAL_RULES = {\n    (1, 3),\n    (2, 6),\n    (3, 2),\n    (4, 8),\n    (4, 3),\n    (3, 6),\n    (2, 9),\n}\n\ndef _is_framed_object(grid: list[list[int]], r: int, c: int) -> tuple[bool, int | None, int | None]:\n    \"\"\"\n    Checks if the cell at (r, c) is the center of a valid Framed Object.\n    A Framed Object has a non-zero center (C2) and 8 surrounding cells\n    of the same, different, non-zero color (C1).\n\n    Returns:\n        tuple[bool, int | None, int | None]: (is_object, frame_color, center_color)\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n\n    # Center must be within bounds allowing for a 3x3 neighborhood\n    if not (0 < r < height - 1 and 0 < c < width - 1):\n        return False, None, None\n\n    center_color = grid[r][c]\n    # Center color must be non-zero\n    if center_color == 0:\n        return False, None, None\n\n    frame_color = -1 # Use -1 to indicate frame color not yet determined\n\n    # Check the 8 neighbors\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center cell itself\n            if dr == 0 and dc == 0:\n                continue\n\n            nr, nc = r + dr, c + dc\n            neighbor_color = grid[nr][nc]\n\n            # Frame cells must be non-zero\n            if neighbor_color == 0:\n                return False, None, None\n\n            # Initialize frame_color with the first neighbor's color\n            if frame_color == -1:\n                frame_color = neighbor_color\n            # Check if subsequent neighbors match the established frame_color\n            elif neighbor_color != frame_color:\n                return False, None, None\n\n    # After checking all neighbors:\n    # Ensure a valid frame color was found (should be non-zero and consistent)\n    if frame_color == -1 or frame_color == 0:\n         return False, None, None # Should not happen if neighbors loop worked, but defensive\n\n    # Frame color must be different from center color\n    if frame_color == center_color:\n        return False, None, None\n\n    # If all checks pass, it's a valid framed object\n    return True, frame_color, center_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies transformations to a grid based on identifying and processing\n    specific 3x3 \"Framed Objects\".\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # Store planned modifications and removals to apply them correctly later\n    modifications_to_apply = [] # List of tuples: (r, c, new_color)\n    coords_to_remove = set()    # Set of tuples: (r, c) for cells to be set to 0\n\n    # Iterate through potential center cells of 3x3 objects\n    for r in range(1, height - 1):\n        for c in range(1, width - 1):\n            # Check if the current cell is the center of a framed object\n            is_object, frame_color, center_color = _is_framed_object(input_grid, r, c)\n\n            if is_object:\n                # We have found a valid framed object with frame C1 and center C2\n                rule_key = (frame_color, center_color)\n\n                # Check if this object type should be removed\n                if rule_key in REMOVAL_RULES:\n                    # Add all 9 coordinates of the 3x3 object to the removal set\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            coords_to_remove.add((r + dr, c + dc))\n                # Check if this object type's center should be modified\n                elif rule_key in MODIFICATION_RULES:\n                    new_center_color = MODIFICATION_RULES[rule_key]\n                    # Add the modification instruction\n                    modifications_to_apply.append((r, c, new_center_color))\n\n    # Apply removals first\n    for rr, cc in coords_to_remove:\n        # Check bounds just in case, though logic should ensure they are valid\n        if 0 <= rr < height and 0 <= cc < width:\n             output_grid[rr][cc] = 0\n\n    # Apply modifications, ensuring the cell wasn't part of a removed object\n    for r_mod, c_mod, new_color in modifications_to_apply:\n        if (r_mod, c_mod) not in coords_to_remove:\n            # Check bounds just in case\n             if 0 <= r_mod < height and 0 <= c_mod < width:\n                output_grid[r_mod][c_mod] = new_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3200,
    "candidates_token_count": 3210,
    "total_token_count": 6410,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.80174,
  "retries": 1
}