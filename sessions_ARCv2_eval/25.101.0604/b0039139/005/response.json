{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport sys # for maxint\n\n\"\"\"\nTransforms an input grid based on identifying a pattern color (PC) with the \nminimum bounding box area, identifying the two most frequent remaining colors \n(C1, C2), creating a motif based on the PC's shape using C1 and C2, and then \narranging/tiling this motif according to specific rules based on the input \nstyle (presence of multiple separator rows) or PC and motif width (Pw).\n\n1.  Identify PC: Color (not 0, 1) with minimum bounding box area. Tie-break: smallest color value.\n2.  Extract PatternMask: Binary mask (Ph x Pw) from PC's bounding box (1 where PC is, 0 otherwise).\n3.  Identify C1, C2: Two most frequent colors (not 0, 1, PC). C1 > C2 freq. Tie-break: smallest color value.\n4.  Generate Motif: Ph x Pw grid. PatternMask 1 -> C1, 0 -> C2.\n5.  Determine Output Structure (Ho, Wo, Tiling Method):\n    - Check for \"Train_1 Style\" (multiple full rows of 1s).\n    - If Train_1 Style:\n        - Ho = 2*Ph + 1, Wo = Pw.\n        - Tiling: Special Vertical Stacking (Motif[0], Motif[1], [C2]*Wo, Motif[0], Motif[1]). Requires Ph >= 2.\n    - Else (Default Style):\n        - Ho = Ph.\n        - If PC == 3 and Pw == 5 (Rule A):\n            - Wo = Pw * PC.\n            - Tiling: Simple Horizontal (Motif repeated PC times).\n        - Else (Rule B):\n            - Wo = Pw * max(1, PC - 1) + max(0, PC - 2). Accounts for PC=2 case (Wo=Pw).\n            - Tiling: Complex Horizontal (Motif repeated PC-1 times, interspersed with PC-2 columns of C2).\n6.  Construct Output: Apply the determined tiling/stacking method.\n\"\"\"\n\n\ndef find_bounding_box(grid: np.ndarray, value: int) -> tuple[int, int, int, int, int, int, int] | None:\n    \"\"\"Finds the minimal bounding box coordinates, dimensions, and area for a given value.\"\"\"\n    coords = np.argwhere(grid == value)\n    if coords.size == 0:\n        return None\n    min_row, min_col = coords.min(axis=0)\n    max_row, max_col = coords.max(axis=0)\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    area = height * width\n    return min_row, max_row, min_col, max_col, height, width, area\n\ndef get_frequencies(grid: np.ndarray, exclude_colors: set[int]) -> Counter:\n    \"\"\"Counts frequencies of colors, excluding 0, 1, and specified colors.\"\"\"\n    colors = grid.flatten()\n    filtered_colors = [c for c in colors if c != 0 and c != 1 and c not in exclude_colors]\n    return Counter(filtered_colors)\n\ndef create_pattern_mask(grid: np.ndarray, value: int, bbox: tuple) -> np.ndarray:\n    \"\"\"Creates a binary mask from the grid based on a value within its bbox.\"\"\"\n    min_r, max_r, min_c, max_c, _, _, _ = bbox\n    subgrid = grid[min_r:max_r+1, min_c:max_c+1]\n    return (subgrid == value).astype(int)\n\ndef create_motif(mask: np.ndarray, c1: int, c2: int) -> np.ndarray:\n    \"\"\"Creates the motif grid based on the mask: 1->C1, 0->C2.\"\"\"\n    ph, pw = mask.shape\n    motif = np.full((ph, pw), c2, dtype=int) # Initialize with C2\n    motif[mask == 1] = c1                   # Set C1 where mask is 1\n    return motif\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return []\n\n    # --- 1. Identify Pattern Color (PC) ---\n    all_colors = np.unique(grid)\n    foreground_colors = [c for c in all_colors if c != 0 and c != 1]\n    if not foreground_colors:\n        return [] # No non-background/separator colors\n\n    min_area = sys.maxsize\n    pc = -1\n    pc_bbox = None\n\n    # Iterate through sorted colors to handle area ties with lower color value\n    for color in sorted(foreground_colors):\n        bbox_info = find_bounding_box(grid, color)\n        if bbox_info:\n            area = bbox_info[6]\n            if area < min_area:\n                min_area = area\n                pc = color\n                pc_bbox = bbox_info\n\n    if pc == -1 or pc_bbox is None:\n        # This should not happen if foreground_colors is not empty and they exist in grid\n        print(\"Error: Could not determine Pattern Color or its bounding box.\")\n        return []\n\n    # --- 2. Extract Pattern Mask ---\n    pattern_mask = create_pattern_mask(grid, pc, pc_bbox)\n    ph, pw = pattern_mask.shape\n    if ph == 0 or pw == 0:\n         print(\"Error: Pattern mask has zero dimension.\")\n         return [] # Cannot proceed with empty pattern\n\n    # --- 3. Identify Output Colors (C1, C2) ---\n    freqs = get_frequencies(grid, exclude_colors={pc})\n    # Sort by frequency (desc), then by color value (asc) for tie-breaking\n    sorted_freqs = sorted(freqs.items(), key=lambda item: (-item[1], item[0]))\n\n    if len(sorted_freqs) == 0:\n        print(f\"Error: Only Pattern Color {pc} found. Cannot determine C1/C2.\")\n        return []\n\n    c1 = sorted_freqs[0][0]\n    # If only one other color exists, use it for both C1 and C2 (or just C2=C1)\n    c2 = sorted_freqs[1][0] if len(sorted_freqs) > 1 else c1\n\n    # --- 4. Generate Motif ---\n    motif = create_motif(pattern_mask, c1, c2)\n\n    # --- 5. Determine Output Structure (Ho, Wo, Tiling Method) ---\n    ho, wo = 0, 0\n    tiling_method = None # 'special_vertical', 'simple_horizontal', 'complex_horizontal'\n\n    # Check for Train_1 Style\n    is_train1_style = False\n    if grid.shape[0] > 1: # Need at least 2 rows to have multiple separator rows\n        sep_rows = np.all(grid == 1, axis=1)\n        if np.sum(sep_rows) > 1:\n            is_train1_style = True\n\n    if is_train1_style:\n        if ph < 2:\n            print(\"Error: Train 1 style requires pattern height >= 2.\")\n            return [] # Cannot apply vertical stacking rule\n        ho = 2 * ph + 1\n        wo = pw\n        tiling_method = 'special_vertical'\n    else:\n        # Default Style\n        ho = ph\n        if pc == 3 and pw == 5: # Rule A\n            wo = pw * pc\n            tiling_method = 'simple_horizontal'\n        else: # Rule B (covers PC=2 implicitly)\n            # Calculate width based on PC and Pw\n            # Formula ensures Wo=Pw if PC=2, Wo=Pw*2+1 if PC=3, Wo=Pw*3+2 if PC=4 etc.\n            wo = pw * max(1, pc - 1) + max(0, pc - 2)\n            tiling_method = 'complex_horizontal'\n\n    if ho <= 0 or wo <= 0:\n        print(f\"Error: Calculated non-positive output dimensions Ho={ho}, Wo={wo}.\")\n        return []\n\n    # --- 6. Construct Output Grid ---\n    output_grid = np.array([[]]) # Initialize\n\n    try:\n        if tiling_method == 'special_vertical':\n            # Check motif compatibility\n            if motif.shape[0] >= 2 and motif.shape[1] == wo:\n                 output_grid = np.vstack((\n                     motif[0:1, :],        # First row of motif\n                     motif[1:2, :],        # Second row of motif\n                     np.full((1, wo), c2), # Row of C2\n                     motif[0:1, :],        # First row again\n                     motif[1:2, :]         # Second row again\n                 ))\n            else:\n                  print(f\"Error: Motif shape {motif.shape} incompatible with Train 1 stacking (requires >=2 rows, width {wo}).\")\n                  output_grid = np.full((ho, wo), -1, dtype=int) # Error placeholder\n\n        elif tiling_method == 'simple_horizontal':\n            # Repeat the motif PC times horizontally\n            if pc > 0:\n                 output_grid = np.hstack([motif] * pc)\n            else:\n                 output_grid = np.zeros((ho, wo), dtype=int) # Should not happen if wo > 0\n\n        elif tiling_method == 'complex_horizontal':\n            if pc < 2: # Should not happen based on Wo calculation, but safety check\n                 print(f\"Error: PC={pc} invalid for complex horizontal tiling.\")\n                 output_grid = np.full((ho, wo), -1, dtype=int)\n            elif pc == 2: # Special case of the formula: Wo=Pw, output is just the motif\n                 output_grid = motif\n            else: # PC >= 3\n                 num_motifs = pc - 1\n                 num_c2_cols = pc - 2\n                 c2_col = np.full((ho, 1), c2, dtype=int) # Create a column of C2\n                 \n                 parts_to_stack = []\n                 for i in range(num_motifs):\n                     parts_to_stack.append(motif)\n                     if i < num_c2_cols: # Add C2 column after all but the last motif\n                         parts_to_stack.append(c2_col)\n                 \n                 if parts_to_stack: # Ensure there's something to stack\n                     output_grid = np.hstack(parts_to_stack)\n                 else: # Should not happen if pc >= 2\n                     output_grid = np.zeros((ho, wo), dtype=int)\n\n\n    except Exception as e:\n         print(f\"Error during output construction ({tiling_method}): {e}\")\n         output_grid = np.full((ho, wo), -1, dtype=int) # Error placeholder\n\n    # Final validation of output shape\n    if output_grid.shape != (ho, wo):\n        print(f\"Error: Final grid shape {output_grid.shape} does not match target {(ho, wo)}. Check construction logic.\")\n        # Attempt to return a correctly shaped error grid if possible\n        output_grid = np.full((ho, wo), -1, dtype=int)\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22862,
    "candidates_token_count": 3585,
    "total_token_count": 26447,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 28.235677,
  "retries": 1
}