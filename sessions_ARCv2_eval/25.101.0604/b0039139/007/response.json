{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport sys # for maxint\n\n\"\"\"\nTransforms an input grid based on identifying a pattern color (PC) with the \nminimum bounding box area, identifying the two most frequent remaining colors \n(C1, C2), creating a base motif based on the PC's shape (1->C1, 0->C2), \nmodifying the first row of this motif (C2->C1), and then arranging/tiling \nthis modified motif according to specific rules based on the input style \n(presence of multiple separator rows) or PC and motif width (Pw).\n\n1.  Identify PC: Color (not 0, 1) with minimum bounding box area. Tie-break: smallest color value.\n2.  Extract PatternMask: Binary mask (Ph x Pw) from PC's bounding box (1 where PC is, 0 otherwise).\n3.  Identify C1, C2: Two most frequent colors (not 0, 1, PC). C1 > C2 freq. Tie-break: smallest color value.\n4.  Generate Base Motif: Ph x Pw grid. PatternMask 1 -> C1, 0 -> C2.\n5.  Generate Modified Motif: In the first row of the Base Motif, change C2 -> C1.\n6.  Determine Output Structure (Ho, Wo, Tiling Method):\n    - Check for \"Train_1 Style\" (multiple full rows of 1s).\n    - If Train_1 Style:\n        - Ho = 2*Ph + 1, Wo = Pw. Requires Ph >= 2.\n        - Tiling: Special Vertical Stacking (uses Modified Motif).\n    - Else (Default Style):\n        - Ho = Ph.\n        - If PC == 3 and Pw == 5 (Rule A):\n            - Wo = Pw * PC.\n            - Tiling: Simple Horizontal (Modified Motif repeated PC times).\n        - Else (Rule B):\n            - Wo = Pw * max(1, PC - 1) + max(0, PC - 2). Accounts for PC=2 case (Wo=Pw).\n            - Tiling: Complex Horizontal (Modified Motif repeated PC-1 times, interspersed with PC-2 columns of C2).\n7.  Construct Output: Apply the determined tiling/stacking method using the Modified Motif.\n\"\"\"\n\n\ndef find_bounding_box(grid: np.ndarray, value: int) -> tuple[int, int, int, int, int, int, int] | None:\n    \"\"\"Finds the minimal bounding box coordinates, dimensions, and area for a given value.\"\"\"\n    coords = np.argwhere(grid == value)\n    if coords.size == 0:\n        return None\n    min_row, min_col = coords.min(axis=0)\n    max_row, max_col = coords.max(axis=0)\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    area = height * width\n    return min_row, max_row, min_col, max_col, height, width, area\n\ndef get_frequencies(grid: np.ndarray, exclude_colors: set[int]) -> Counter:\n    \"\"\"Counts frequencies of colors, excluding 0, 1, and specified colors.\"\"\"\n    colors = grid.flatten()\n    filtered_colors = [c for c in colors if c != 0 and c != 1 and c not in exclude_colors]\n    return Counter(filtered_colors)\n\ndef create_pattern_mask(grid: np.ndarray, value: int, bbox: tuple) -> np.ndarray:\n    \"\"\"Creates a binary mask from the grid based on a value within its bbox.\"\"\"\n    min_r, max_r, min_c, max_c, _, _, _ = bbox\n    subgrid = grid[min_r:max_r+1, min_c:max_c+1]\n    return (subgrid == value).astype(int)\n\ndef create_base_motif(mask: np.ndarray, c1: int, c2: int) -> np.ndarray:\n    \"\"\"Creates the base motif grid based on the mask: 1->C1, 0->C2.\"\"\"\n    ph, pw = mask.shape\n    motif = np.full((ph, pw), c2, dtype=int) # Initialize with C2\n    motif[mask == 1] = c1                   # Set C1 where mask is 1\n    return motif\n\ndef create_modified_motif(base_motif: np.ndarray, c1: int, c2: int) -> np.ndarray:\n    \"\"\"Modifies the first row of the base motif by changing C2 to C1.\"\"\"\n    modified = base_motif.copy()\n    if modified.shape[0] > 0: # Ensure motif is not empty\n        modified[0, modified[0] == c2] = c1\n    return modified\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # --- Initialize ---\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return []\n\n    # --- 1. Identify Pattern Color (PC) ---\n    # Find color (not 0, 1) with the smallest bounding box area.\n    # Tie-break using the smallest color value.\n    all_colors = np.unique(grid)\n    foreground_colors = [c for c in all_colors if c != 0 and c != 1]\n    if not foreground_colors:\n        return [] # No pattern possible\n\n    min_area = sys.maxsize\n    pc = -1\n    pc_bbox = None\n\n    for color in sorted(foreground_colors): # Sort for tie-breaking\n        bbox_info = find_bounding_box(grid, color)\n        if bbox_info:\n            area = bbox_info[6]\n            if area < min_area:\n                min_area = area\n                pc = color\n                pc_bbox = bbox_info\n\n    if pc == -1 or pc_bbox is None:\n        print(\"Error: Could not determine Pattern Color or its bounding box.\")\n        return []\n\n    # --- 2. Extract Pattern Mask ---\n    # Create a binary mask (Ph x Pw) from PC's bounding box.\n    pattern_mask = create_pattern_mask(grid, pc, pc_bbox)\n    ph, pw = pattern_mask.shape\n    if ph == 0 or pw == 0:\n         print(\"Error: Pattern mask has zero dimension.\")\n         return []\n\n    # --- 3. Identify Output Colors (C1, C2) ---\n    # Find the two most frequent colors (excluding 0, 1, PC).\n    # C1 > C2 frequency. Tie-break using the smallest color value.\n    freqs = get_frequencies(grid, exclude_colors={pc})\n    # Sort by frequency (desc), then by color value (asc) for tie-breaking\n    sorted_freqs = sorted(freqs.items(), key=lambda item: (-item[1], item[0]))\n\n    if len(sorted_freqs) == 0:\n        print(f\"Error: Only Pattern Color {pc} found. Cannot determine C1/C2.\")\n        return []\n\n    c1 = sorted_freqs[0][0]\n    c2 = sorted_freqs[1][0] if len(sorted_freqs) > 1 else c1 # Use C1 if only one other color\n\n    # --- 4. Generate Base Motif ---\n    # Create Ph x Pw grid mapping PatternMask 1 to C1, 0 to C2.\n    base_motif = create_base_motif(pattern_mask, c1, c2)\n\n    # --- 5. Generate Modified Motif ---\n    # Apply Rule M (Row 0: C2 -> C1) to Base Motif.\n    modified_motif = create_modified_motif(base_motif, c1, c2)\n\n    # --- 6. Determine Output Structure (Ho, Wo, Tiling Method) ---\n    ho, wo = 0, 0\n    tiling_method = None\n\n    # Check for Train_1 Style (multiple full rows of 1s)\n    is_train1_style = False\n    if grid.shape[0] > 1:\n        sep_rows = np.all(grid == 1, axis=1)\n        if np.sum(sep_rows) > 1:\n            is_train1_style = True\n\n    if is_train1_style:\n        # Requires pattern height >= 2 for the specific stacking logic\n        if ph < 2:\n            print(\"Error: Train 1 style requires pattern height >= 2.\")\n            return []\n        ho = 2 * ph + 1\n        wo = pw\n        tiling_method = 'special_vertical'\n    else:\n        # Default Style\n        ho = ph\n        if pc == 3 and pw == 5: # Rule A specific case\n            wo = pw * pc\n            tiling_method = 'simple_horizontal'\n        else: # Rule B for all other default cases\n            # Formula covers PC=2 (Wo=Pw), PC=3 (Wo=2*Pw+1), PC=4 (Wo=3*Pw+2), etc.\n            wo = pw * max(1, pc - 1) + max(0, pc - 2)\n            tiling_method = 'complex_horizontal'\n\n    # Validate calculated dimensions\n    if ho <= 0 or wo <= 0:\n        print(f\"Error: Calculated non-positive output dimensions Ho={ho}, Wo={wo}.\")\n        return []\n\n    # --- 7. Construct Output Grid ---\n    # Apply the determined tiling/stacking method using the Modified Motif.\n    output_grid = np.array([[]]) # Initialize\n\n    try:\n        if tiling_method == 'special_vertical':\n            # Stack rows: ModMotif[0], ModMotif[1], [C2]*Wo, ModMotif[0], ModMotif[1]\n            if modified_motif.shape[0] >= 2 and modified_motif.shape[1] == wo:\n                 output_grid = np.vstack((\n                     modified_motif[0:1, :],        # First row of modified motif\n                     modified_motif[1:2, :],        # Second row of modified motif\n                     np.full((1, wo), c2),          # Row of C2\n                     modified_motif[0:1, :],        # First row again\n                     modified_motif[1:2, :]         # Second row again\n                 ))\n            else:\n                  print(f\"Error: Motif shape {modified_motif.shape} incompatible with Train 1 stacking (requires >=2 rows, width {wo}).\")\n                  output_grid = np.full((ho, wo), -1, dtype=int) # Error placeholder\n\n        elif tiling_method == 'simple_horizontal':\n            # Repeat the Modified Motif PC times horizontally.\n            if pc > 0:\n                 output_grid = np.hstack([modified_motif] * pc)\n            else:\n                 output_grid = np.zeros((ho, wo), dtype=int) # Should not happen\n\n        elif tiling_method == 'complex_horizontal':\n            # Stack Modified Motif PC-1 times, interspersed with PC-2 columns of C2.\n            if pc < 2: # Should not happen based on Wo calculation\n                 print(f\"Error: PC={pc} invalid for complex horizontal tiling.\")\n                 output_grid = np.full((ho, wo), -1, dtype=int)\n            elif pc == 2: # Special case: output is just the modified motif\n                 output_grid = modified_motif\n            else: # PC >= 3\n                 num_motifs = pc - 1\n                 num_c2_cols = pc - 2\n                 c2_col = np.full((ho, 1), c2, dtype=int) # Column vector of C2\n\n                 parts_to_stack = []\n                 for i in range(num_motifs):\n                     parts_to_stack.append(modified_motif)\n                     if i < num_c2_cols: # Add C2 column between motifs\n                         parts_to_stack.append(c2_col)\n\n                 if parts_to_stack:\n                     output_grid = np.hstack(parts_to_stack)\n                 else: # Should not happen\n                     output_grid = np.zeros((ho, wo), dtype=int)\n\n    except Exception as e:\n         print(f\"Error during output construction ({tiling_method}): {e}\")\n         output_grid = np.full((ho, wo), -1, dtype=int) # Error placeholder\n\n    # Final validation of output shape\n    if output_grid.shape != (ho, wo):\n        print(f\"Error: Final grid shape {output_grid.shape} does not match target {(ho, wo)}. Check construction logic.\")\n        output_grid = np.full((ho, wo), -1, dtype=int)\n\n    # --- Return ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32652,
    "candidates_token_count": 3754,
    "total_token_count": 36406,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.82071,
  "retries": 1
}