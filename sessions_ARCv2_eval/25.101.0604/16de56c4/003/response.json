{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransforms a 2D grid based on patterns in its rows, governed by the structure of the last non-zero row.\n\n1.  Find the last row in the input grid containing non-zero elements (the 'reference row').\n2.  Check if this reference row contains any non-zero elements at adjacent column indices (c and c+1).\n3.  If YES (adjacent non-zeros exist), apply 'Mode A' (Independent Row Transformation):\n    - Transform each row independently.\n    - For a row:\n        - Find non-zero cells nz = [(c, v), ...].\n        - If len(nz) < 2, keep the row as is.\n        - Otherwise, find c_min, c_max, V (last value), step (diff between first two cols), all_same_value.\n        - Copy the input row to output_row.\n        - If all_same_value and step == 1: fill output_row from c_min to end with V.\n        - Else if step == 1: fill output_row from c_min to c_max with V.\n        - Else (step > 1): fill output_row[c] = V for c = c_min, c_min + step, ..., up to c_max.\n4.  If NO (no adjacent non-zeros in reference row), apply 'Mode B' (Reference Row Overlay):\n    - For each input row:\n        - If the input row is all zeros, the output row is all zeros.\n        - Otherwise:\n            - Start with a copy of the reference row as the output_row.\n            - Find non-zero cells (c, v) in the input row.\n            - For each (c, v), set output_row[c] = v.\n\"\"\"\n\ndef find_reference_info(grid: list[list[int]]) -> tuple[int | None, list[int] | None, list[tuple[int, int]] | None]:\n    \"\"\"Finds the index, data, and sorted non-zero elements of the last row containing non-zeros.\"\"\"\n    ref_row_index = None\n    ref_row_data = None\n    ref_nz = None\n    for r in range(len(grid) - 1, -1, -1):\n        row = grid[r]\n        nz = sorted([(c, val) for c, val in enumerate(row) if val != 0])\n        if nz:\n            ref_row_index = r\n            ref_row_data = list(row) # Store a copy\n            ref_nz = nz\n            break\n    return ref_row_index, ref_row_data, ref_nz\n\ndef check_adjacency(nz_list: list[tuple[int, int]]) -> bool:\n    \"\"\"Checks if any adjacent elements in the sorted non-zero list have consecutive column indices.\"\"\"\n    if not nz_list or len(nz_list) < 2:\n        return False\n    for i in range(len(nz_list) - 1):\n        if nz_list[i][0] + 1 == nz_list[i+1][0]:\n            return True\n    return False\n\ndef transform_row_independent(row: list[int]) -> list[int]:\n    \"\"\"Applies the row-independent transformation logic (Mode A).\"\"\"\n    # Find non-zero elements, sorted by column\n    nz = sorted([(c, val) for c, val in enumerate(row) if val != 0])\n    \n    # Handle rows with 0 or 1 non-zero element: return unchanged copy\n    if len(nz) < 2:\n        return list(row) \n\n    # Get properties for rows with >= 2 non-zero elements\n    c_min = nz[0][0]\n    c_max = nz[-1][0]\n    V = nz[-1][1] # Value of the *last* non-zero element\n    step = nz[1][0] - nz[0][0] # Difference between first two non-zero columns\n    all_same_value = len(set(val for c, val in nz)) == 1\n    \n    output_row = list(row) # Start with a copy of the input row\n    row_width = len(row)\n\n    # Apply filling logic based on conditions\n    if all_same_value and step == 1:\n        # Fill from c_min to the end of the row if adjacent and all same value\n        for c in range(c_min, row_width):\n            output_row[c] = V\n    elif step == 1:\n        # Fill from c_min to c_max (inclusive) if adjacent but different values\n        for c in range(c_min, c_max + 1):\n            output_row[c] = V\n    elif step > 1:\n        # Fill every step-th column starting from c_min, up to c_max\n        c = c_min\n        while c <= c_max: # Corrected boundary condition\n            output_row[c] = V\n            c += step\n            \n    return output_row\n\ndef transform_reference_overlay_grid(input_grid: list[list[int]], reference_row: list[int]) -> list[list[int]]:\n    \"\"\"Applies the reference row overlay transformation logic (Mode B).\"\"\"\n    output_grid = []\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0]) if num_rows > 0 else 0\n    \n    for r in range(num_rows):\n        current_row = input_grid[r]\n        current_nz = [(c, val) for c, val in enumerate(current_row) if val != 0]\n        \n        # If the input row is all zeros, the output row is all zeros\n        if not current_nz:\n            output_grid.append([0] * num_cols) \n        else:\n            # Start with a copy of the reference row\n            output_row = list(reference_row)\n            # Overlay non-zeros from the current input row\n            for c, val in current_nz:\n                 # Ensure column index is valid (safety check)\n                 if 0 <= c < len(output_row):\n                    output_row[c] = val\n            output_grid.append(output_row)\n            \n    return output_grid\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on patterns in the last non-zero row.\n    Chooses between two transformation types: \n    - Mode A: Independent row transformation (if last non-zero row has adjacent non-zeros).\n    - Mode B: Reference row overlay (if last non-zero row has no adjacent non-zeros).\n    \"\"\"\n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n        \n    # Find the last non-zero row, its data, and its non-zero elements\n    ref_row_index, ref_row_data, ref_nz = find_reference_info(input_grid)\n\n    # If no non-zero elements exist anywhere in the grid, return a copy\n    if ref_row_index is None:\n        return [list(row) for row in input_grid] \n\n    # Determine the transformation mode by checking adjacency in the reference row\n    has_adjacent = check_adjacency(ref_nz)\n\n    # Apply Mode A (Independent Row Transformation)\n    if has_adjacent:\n        output_grid = []\n        for r in range(len(input_grid)):\n             output_grid.append(transform_row_independent(input_grid[r]))\n        return output_grid\n        \n    # Apply Mode B (Reference Row Overlay)\n    else:\n        # Pass the actual data of the reference row\n        return transform_reference_overlay_grid(input_grid, ref_row_data)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14266,
    "candidates_token_count": 2260,
    "total_token_count": 16526,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.71021,
  "retries": 1
}