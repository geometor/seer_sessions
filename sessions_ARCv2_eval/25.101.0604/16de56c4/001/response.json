{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nThe transformation rule depends on the pattern of non-zero elements in the last non-zero row of the input grid.\n\n1. Find the last row in the input grid that contains any non-zero elements. Call this the 'reference row'.\n2. Examine the non-zero elements in this reference row.\n3. Check if any two *adjacent* non-zero elements in the reference row (when sorted by column index) have *consecutive* column indices.\n\n4. **If YES (adjacent non-zeros exist in the reference row):**\n   - The transformation is applied *independently* to each row.\n   - For a given row:\n     - Find all non-zero cells, sorted by column index: nz = [(c1, v1), (c2, v2), ...].\n     - If no non-zero cells exist (len(nz) == 0), the row remains unchanged.\n     - If only one non-zero cell exists (len(nz) == 1), the row remains unchanged.\n     - If multiple non-zero cells exist (len(nz) > 1):\n       - Determine the column of the first non-zero cell (c_min).\n       - Determine the value of the *last* non-zero cell (V).\n       - Calculate the difference in column indices between the first two non-zero cells (step = nz[1][0] - nz[0][0]).\n       - Check if all non-zero cells in this row have the same value (all_same_value).\n       - Initialize the output row as a copy of the input row.\n       - Apply filling logic based on conditions:\n         - If `all_same_value` is True AND `step == 1`: Fill the output row from column `c_min` to the *end of the row* with value `V`.\n         - Else if `step == 1`: Fill the output row from column `c_min` to the column of the *last* non-zero cell (`c_max`) (inclusive) with value `V`.\n         - Else (`step > 1`): Starting from column `c_min`, fill every `step`-th column with value `V`, continuing as long as the column index is within the row bounds.\n\n5. **If NO (no adjacent non-zeros exist in the reference row):**\n   - The transformation uses the reference row as a base pattern.\n   - For each row in the input grid:\n     - If the input row contains no non-zero elements, the output row is identical (all zeros).\n     - If the input row *does* contain non-zero elements:\n       - Start with a copy of the reference row.\n       - Overwrite the values in this copied reference row at the column indices corresponding to the non-zero elements of the *original input row*, using the values from the original input row. The resulting row is the output row.\n\n\"\"\"\n\ndef find_reference_info(grid: list[list[int]]) -> tuple[int | None, list[tuple[int, int]] | None]:\n    \"\"\"Finds the index and sorted non-zero elements of the last row containing non-zeros.\"\"\"\n    ref_row_index = None\n    ref_nz = None\n    for r in range(len(grid) - 1, -1, -1):\n        nz = sorted([(c, val) for c, val in enumerate(grid[r]) if val != 0])\n        if nz:\n            ref_row_index = r\n            ref_nz = nz\n            break\n    return ref_row_index, ref_nz\n\ndef check_adjacency(nz_list: list[tuple[int, int]]) -> bool:\n    \"\"\"Checks if any adjacent elements in the sorted non-zero list have consecutive column indices.\"\"\"\n    if not nz_list or len(nz_list) < 2:\n        return False\n    for i in range(len(nz_list) - 1):\n        if nz_list[i][0] + 1 == nz_list[i+1][0]:\n            return True\n    return False\n\ndef transform_row_independent(row: list[int]) -> list[int]:\n    \"\"\"Applies the row-independent transformation logic (Type 1).\"\"\"\n    nz = sorted([(c, val) for c, val in enumerate(row) if val != 0])\n    \n    # Handle rows with 0 or 1 non-zero element\n    if len(nz) < 2:\n        return list(row) # Return a copy\n\n    # Get properties for rows with >= 2 non-zero elements\n    c_min = nz[0][0]\n    c_max = nz[-1][0]\n    V = nz[-1][1] # Value of the *last* non-zero element\n    step = nz[1][0] - nz[0][0]\n    all_same_value = len(set(val for c, val in nz)) == 1\n    \n    output_row = list(row) # Start with a copy\n    row_width = len(row)\n\n    # Apply filling logic based on conditions\n    if all_same_value and step == 1:\n        # Fill from c_min to the end of the row\n        for c in range(c_min, row_width):\n            output_row[c] = V\n    elif step == 1:\n        # Fill from c_min to c_max (inclusive)\n        for c in range(c_min, c_max + 1):\n            output_row[c] = V\n    elif step > 1:\n        # Fill every step-th column starting from c_min\n        c = c_min\n        while c < row_width:\n            output_row[c] = V\n            c += step\n            \n    return output_row\n\ndef transform_reference_overlay(input_grid: list[list[int]], ref_row_index: int) -> list[list[int]]:\n    \"\"\"Applies the reference row overlay transformation logic (Type 2).\"\"\"\n    output_grid = []\n    reference_row = input_grid[ref_row_index]\n    num_rows = len(input_grid)\n    \n    for r in range(num_rows):\n        current_row = input_grid[r]\n        current_nz = [(c, val) for c, val in enumerate(current_row) if val != 0]\n        \n        if not current_nz:\n            # If the input row is all zeros, the output is all zeros\n            output_grid.append(list(current_row)) \n        else:\n            # Start with reference row, overlay current non-zeros\n            output_row = list(reference_row)\n            for c, val in current_nz:\n                output_row[c] = val\n            output_grid.append(output_row)\n            \n    return output_grid\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on patterns in the last non-zero row.\n    Chooses between two transformation types: row-independent or reference-row-overlay.\n    \"\"\"\n    # Find the last non-zero row and its non-zero elements\n    ref_row_index, ref_nz = find_reference_info(input_grid)\n\n    # If no non-zero elements exist anywhere in the grid, return a copy\n    if ref_row_index is None:\n        return [list(row) for row in input_grid] \n\n    # Check if the reference row has adjacent non-zero elements\n    has_adjacent = check_adjacency(ref_nz)\n\n    # Apply Transformation Type 1 (Row Independent)\n    if has_adjacent:\n        output_grid = []\n        for r in range(len(input_grid)):\n             output_grid.append(transform_row_independent(input_grid[r]))\n        return output_grid\n    # Apply Transformation Type 2 (Reference Row Overlay)\n    else:\n        return transform_reference_overlay(input_grid, ref_row_index)\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3296,
    "candidates_token_count": 11991,
    "total_token_count": 15287,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 87.984881,
  "retries": 1
}