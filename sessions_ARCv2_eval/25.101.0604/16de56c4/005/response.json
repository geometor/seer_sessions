{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransforms a 2D grid based on patterns in its rows, with the transformation mode \ndetermined by the adjacency of non-zero elements in the last non-zero row.\n\n1.  Find the last row containing non-zero elements (the 'reference row').\n2.  Check if this reference row contains adjacent non-zero elements (at columns c and c+1).\n3.  Mode A (Adjacent found): Transform each row independently based on its non-zero pattern.\n    - Find non-zero cells `nz`, first/last columns (`c_min`, `c_max`), last value (`V`), \n      step between first two non-zeros, and if all non-zeros have the same value (`all_same_value`).\n    - If fewer than 2 non-zeros, row is unchanged.\n    - Apply filling:\n        - If step=1 and all_same_value: Fill from c_min to end with V.\n        - If step=1 and not all_same_value: Fill from c_min to c_max with V.\n        - If step>1 and all_same_value: Fill every 'step' column from c_min to end with V.\n        - If step>1 and not all_same_value: Fill every 'step' column from c_min up to c_max with V.\n4.  Mode B (No adjacent found): Transform each row using the reference row as a base overlay.\n    - Initialize output row with zeros.\n    - Place non-zero elements from the reference row onto the output row.\n    - Place non-zero elements from the current input row onto the output row, overwriting reference values if necessary.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_reference_info(grid: list[list[int]]) -> tuple[int | None, list[int] | None, list[tuple[int, int]] | None]:\n    \"\"\"\n    Finds the index, data, and sorted non-zero elements (col, val) \n    of the last row containing non-zeros.\n    Returns (None, None, None) if the grid is empty or all zeros.\n    \"\"\"\n    ref_row_index = None\n    ref_row_data = None\n    ref_nz = None\n    for r in range(len(grid) - 1, -1, -1):\n        row = grid[r]\n        nz = sorted([(c, val) for c, val in enumerate(row) if val != 0])\n        if nz:\n            ref_row_index = r\n            ref_row_data = list(row) # Store a copy\n            ref_nz = nz\n            break\n    return ref_row_index, ref_row_data, ref_nz\n\ndef check_adjacency(nz_list: list[tuple[int, int]]) -> bool:\n    \"\"\"\n    Checks if any two consecutive elements in the sorted non-zero list \n    have column indices that differ by exactly 1.\n    \"\"\"\n    if not nz_list or len(nz_list) < 2:\n        return False\n    for i in range(len(nz_list) - 1):\n        if nz_list[i][0] + 1 == nz_list[i+1][0]:\n            return True\n    return False\n\ndef transform_independent_row(input_row: list[int]) -> list[int]:\n    \"\"\"Applies the row-independent transformation logic (Mode A).\"\"\"\n    nz = sorted([(c, val) for c, val in enumerate(input_row) if val != 0])\n    row_width = len(input_row)\n    output_row = list(input_row) # Start with a copy\n\n    # If less than 2 non-zeros, no transformation needed for this row\n    if len(nz) < 2:\n        return output_row\n\n    # Get properties for rows with >= 2 non-zero elements\n    c_min = nz[0][0]\n    c_max = nz[-1][0]\n    V = nz[-1][1] # Value of the *last* non-zero element\n    step = nz[1][0] - nz[0][0] # Difference between first two non-zero columns\n    all_same_value = len(set(val for c, val in nz)) == 1\n\n    # Apply filling logic based on step and value uniformity\n    if step == 1:\n        if all_same_value:\n            # Fill from c_min to the end of the row\n            for c in range(c_min, row_width):\n                output_row[c] = V\n        else:\n            # Fill from c_min to c_max (inclusive)\n            for c in range(c_min, c_max + 1):\n                output_row[c] = V\n    elif step > 1:\n        c = c_min\n        if all_same_value:\n            # Fill every step-th column from c_min to end of row\n            while c < row_width:\n                output_row[c] = V\n                c += step\n        else:\n            # Fill every step-th column from c_min up to c_max\n            while c <= c_max:\n                output_row[c] = V\n                c += step\n                \n    return output_row\n\ndef transform_reference_overlay_row(input_row: list[int], reference_row_nz: list[tuple[int,int]], width: int) -> list[int]:\n    \"\"\"Applies the reference row overlay transformation logic (Mode B).\"\"\"\n    output_row = [0] * width # Start with a row of zeros\n\n    # Apply non-zeros from the reference row first\n    for c, v in reference_row_nz:\n        if 0 <= c < width:\n            output_row[c] = v\n\n    # Overlay non-zeros from the current input row\n    current_nz = [(c, val) for c, val in enumerate(input_row) if val != 0]\n    for c, v in current_nz:\n        if 0 <= c < width:\n            output_row[c] = v\n            \n    return output_row\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid based on the adjacency rule of the last non-zero row.\n    \"\"\"\n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n        \n    output_grid = []\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0])\n\n    # Find the reference row information\n    ref_row_index, ref_row_data, ref_nz = find_reference_info(input_grid)\n\n    # If no non-zero elements exist anywhere in the grid, return a copy\n    if ref_row_index is None:\n        return [list(row) for row in input_grid] \n\n    # Determine the transformation mode based on adjacency in the reference row\n    mode_a = check_adjacency(ref_nz)\n\n    # Perform transformations row by row based on the determined mode\n    if mode_a:\n        # Mode A: Independent Row Transformation\n        for r in range(num_rows):\n            output_grid.append(transform_independent_row(input_grid[r]))\n    else:\n        # Mode B: Reference Row Overlay\n        # Get the non-zero elements from the reference row data\n        reference_nz_for_overlay = [(c, v) for c, v in enumerate(ref_row_data) if v != 0]\n        for r in range(num_rows):\n            output_grid.append(transform_reference_overlay_row(input_grid[r], reference_nz_for_overlay, num_cols))\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25028,
    "candidates_token_count": 2157,
    "total_token_count": 27185,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.720777,
  "retries": 1
}