
## train_1

**input:**
```
1 1 1 1 3 3 3 3
1 1 1 1 0 0 0 0
1 1 1 1 0 0 0 0
1 1 1 1 0 0 0 0
5 5 5 5 6 0 6 0
5 5 5 5 0 6 0 6
5 5 5 5 6 0 6 0
5 5 5 5 0 6 0 6
```


**output:**
```
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
6 5 6 5
5 6 5 6
```


## train_2

**input:**
```
8 8 8 8 6 6 6 6
8 8 8 8 6 6 6 6
8 8 8 8 6 6 6 6
8 8 8 8 6 6 6 6
1 1 1 1 4 4 4 4
5 5 5 5 4 0 0 4
1 1 1 1 4 0 0 4
5 5 5 5 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 4 4 1 1 4 4 1 1 4 4 1 1 4
4 1 1 4 4 1 1 4 4 1 1 4 4 1 1 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 5 5 4 4 5 5 4 4 5 5 4 4 5 5 4
4 5 5 4 4 5 5 4 4 5 5 4 4 5 5 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 1 1 4 4 1 1 4 4 1 1 4 4 1 1 4
4 1 1 4 4 1 1 4 4 1 1 4 4 1 1 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 5 5 4 4 5 5 4 4 5 5 4 4 5 5 4
4 5 5 4 4 5 5 4 4 5 5 4 4 5 5 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


## train_3

**input:**
```
6 6 0 0 0 0 0 0 0 0 0 4 4 4 4 4
6 6 0 0 0 0 0 0 0 0 0 4 4 4 4 4
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 8 0 8 0 0 6 0 6
1 1 1 1 1 1 1 1 0 8 0 0 0 0 6 0
1 1 1 1 1 1 1 1 8 0 8 0 0 6 0 6
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 6 0 6 0 0 8 0 8
1 1 1 1 1 1 1 1 0 6 0 0 0 0 8 0
1 1 1 1 1 1 1 1 6 0 6 0 0 8 0 8
```


**output:**
```
8 1 8 1 1 6 1 6 1 1
1 8 1 1 1 1 6 1 1 1
8 1 8 1 1 6 1 6 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
8 1 8 1 1 6 1 6 1 1
1 8 1 1 1 1 6 1 1 1
8 1 8 1 1 6 1 6 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```


## train_4

**input:**
```
4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
2 5 2 5 0 0 0 0
2 5 2 5 0 0 0 0
2 5 2 5 0 0 0 0
2 5 2 5 0 0 0 0
```


**output:**
```
2 5 2 5
2 5 2 5
2 5 2 5
2 5 2 5
```


## train_5

**input:**
```
8 0 8 0 4 0 4 0
0 0 0 0 0 0 0 0
0 0 8 0 4 0 0 4
0 0 0 0 0 0 0 0
6 6 6 6 1 1 1 1
6 6 6 6 0 0 0 0
6 6 6 6 1 1 1 1
6 6 6 6 0 0 0 0
```


**output:**
```
1 1 1 1
6 6 6 6
1 1 1 1
```

## Perception of Elements

The task involves transforming an input grid of numbers into an output grid. The input grids are typically square (e.g., 8x8, 16x16) and often appear divisible into four equal quadrants. The transformation seems to primarily depend on the content and structure of the bottom-left (Q3) and bottom-right (Q4) quadrants of the input grid.

Key observations:
1.  **Quadrant Importance:** The transformation logic heavily relies on analyzing the patterns and values within Q3 and Q4. The top half of the input often contains uniform blocks that seem less critical or ignored in some examples.
2.  **Pattern vs. Fill:** One of the bottom quadrants (Q3 or Q4) typically contains a more prominent or complex pattern (e.g., checkerboard, border, multiple distinct numbers), acting as the primary "pattern source". The other quadrant often provides a simpler pattern or a uniform background color, acting as the "fill source". The quadrant with higher complexity (more distinct non-zero values, structural features) is usually the pattern source.
3.  **Value Extraction:** The non-zero numbers present in both the pattern and fill quadrants are used in constructing the output. Zeros in the pattern quadrant are often replaced by the non-zero value(s) from the fill quadrant.
4.  **Output Construction:** The way the extracted values and patterns are used to build the output varies significantly:
    *   Direct copy of a quadrant (train_4).
    *   Tiling with a derived pattern (train_1, train_2).
    *   Interleaving rows/elements (train_5).
    *   Replacing zeros and then modifying the grid structure (e.g., insertions) (train_3).
5.  **Output Size:** The dimensions of the output grid are not fixed relative to the input but depend on the specific transformation rule triggered by the input patterns.

## YAML Facts

```yaml
objects:
  - name: input_grid
    type: grid
    properties:
      - dimensions: varies (e.g., 8x8, 16x16)
      - quadrants: [Q1 (TL), Q2 (TR), Q3 (BL), Q4 (BR)]
      - cells: integer values (0-9)
  - name: Q3 # Bottom-left quadrant
    type: subgrid
    properties:
      - values: set of numbers in the quadrant
      - structure: pattern type (e.g., uniform, checkerboard, rows, complex)
      - non_zero_values: set of non-zero numbers
      - dominant_non_zero: most frequent non-zero number(s)
  - name: Q4 # Bottom-right quadrant
    type: subgrid
    properties:
      - values: set of numbers in the quadrant
      - structure: pattern type (e.g., uniform, checkerboard, border, rows, complex)
      - non_zero_values: set of non-zero numbers
      - dominant_non_zero: most frequent non-zero number(s)
  - name: pattern_quadrant # The more complex of Q3/Q4
    type: subgrid_role
  - name: fill_quadrant # The less complex of Q3/Q4
    type: subgrid_role
  - name: pattern_elements
    type: data
    properties:
      - non_zero_values: from pattern_quadrant
      - structure: from pattern_quadrant
      - zeros_present: boolean
  - name: fill_value
    type: data
    properties:
      - value: dominant non-zero from fill_quadrant (can be 0 if fill_quadrant is all zeros)
  - name: output_grid
    type: grid
    properties:
      - dimensions: derived based on transformation rule
      - cells: integer values derived from pattern_elements and fill_value

actions:
  - name: identify_quadrants
    input: input_grid
    output: Q3, Q4
  - name: determine_roles
    input: Q3, Q4
    output: pattern_quadrant, fill_quadrant (based on complexity)
  - name: extract_pattern_elements
    input: pattern_quadrant
    output: pattern_elements
  - name: extract_fill_value
    input: fill_quadrant
    output: fill_value
  - name: apply_transformation
    input: pattern_elements, fill_value, pattern_quadrant.structure, fill_quadrant.structure
    output: output_grid
    logic: Selects and applies a specific construction rule based on inputs.

relationships:
  - The output_grid is derived from Q3 and Q4 of the input_grid.
  - The complexity of Q3 and Q4 determines which serves as the pattern_quadrant and fill_quadrant.
  - Zeros in the pattern_quadrant are often replaced or filled using the fill_value.
  - The specific structure of both pattern_quadrant and fill_quadrant dictates the final transformation rule (e.g., tiling, copying, interleaving, inserting).
```

## Natural Language Program

1.  Divide the `input_grid` into four equal quadrants: top-left (Q1), top-right (Q2), bottom-left (Q3), and bottom-right (Q4).
2.  Analyze the complexity (number of distinct non-zero values, presence of structural patterns like checkerboards, borders) of Q3 and Q4. Designate the more complex quadrant as `pattern_quadrant` and the other as `fill_quadrant`.
3.  Extract the set of unique non-zero numbers and the structural pattern description from `pattern_quadrant`. Note if zeros are present.
4.  Determine the primary non-zero value(s) from `fill_quadrant`. If `fill_quadrant` contains only zeros, the `fill_value` is 0. Otherwise, it's typically the most frequent or sole non-zero value.
5.  Apply a specific transformation rule based on the characteristics of `pattern_quadrant` and `fill_quadrant`:
    *   **Rule A (Direct Copy):** If `fill_value` is 0, the `output_grid` is identical to `pattern_quadrant`.
    *   **Rule B (Value Combination Tiling):** If `pattern_quadrant` has a simple structure (e.g., checkerboard like N1, 0) and `fill_quadrant` is uniform (N2), create a new pattern combining N1 and N2 (e.g., `[[N1, N2], [N2, N1]]`) and tile the `output_grid` with it. Determine output dimensions based on input quadrant size and tiling factor.
    *   **Rule C (Pattern Application):** If `pattern_quadrant` has a structure (e.g., border N1, 0) and `fill_quadrant` provides multiple values (N2, N3), construct `output_grid` by tiling blocks where the structure from `pattern_quadrant` (e.g., border N1) is combined with values from `fill_quadrant` (e.g., inner N2, N3) according to a derived tiling logic. Determine output dimensions based on input quadrant size and tiling factor.
    *   **Rule D (Zero Replacement and Modification):** If `pattern_quadrant` is complex (multiple non-zeros N1, N2, and 0s) and `fill_quadrant` is uniform (N3), create a base grid by replacing 0s in `pattern_quadrant` with N3. The `output_grid` is formed by modifying this base grid (e.g., inserting rows/columns of N3). Determine output dimensions based on modification rule.
    *   **Rule E (Interleaving):** If structures in `pattern_quadrant` and `fill_quadrant` suggest interleaving (e.g., uniform rows N1 in one, rows of N2/0 in the other), construct the `output_grid` by taking specific rows/elements from each, guided by the structure of `fill_quadrant`. Determine output dimensions based on interleaving logic.
6.  Return the generated `output_grid`.
```python
"""
Transforms an input grid based on patterns identified in its bottom-left (Q3) and bottom-right (Q4) quadrants.

The core logic involves:
1. Dividing the input grid into four quadrants.
2. Identifying Q3 and Q4.
3. Determining which of Q3 or Q4 is the 'pattern' source and which is the 'fill' source, generally based on complexity (e.g., number of unique non-zero values).
4. Extracting the dominant non-zero value from the 'fill' quadrant (the fill_value).
5. Extracting the structure and values from the 'pattern' quadrant.
6. Applying a specific transformation rule based on the characteristics observed in the pattern and fill quadrants from the training examples:
    - Rule A (Direct Copy): If the fill value is 0, the output is a copy of the pattern quadrant. (Example: train_4)
    - Rule B (Value Combination Tiling): If specific checkerboard patterns are found in Q3/Q4 (like 1/0 and 5/6), combine the values (5, 6) into a new checkerboard tile and tile the output. (Example: train_1)
    - Rule C (Pattern Application Tiling): If one quadrant has a border (e.g., 4) and the other has uniform rows (e.g., 1s, 5s), create tiles using the border value and the row values, then tile the output mirroring the row structure. (Example: train_2)
    - Rule D (Zero Replacement and Modification): If one quadrant is complex (e.g., 8,6,0) and the other is uniform (e.g., 1), replace zeros in the pattern quadrant with the fill value, then select specific rows and append specific columns to form the output. (Example: train_3)
    - Rule E (Interleaving/Row Selection): If one quadrant has rows of values/zeros (e.g., 1/0) and the other is uniform (e.g., 6), replace zeros in the pattern quadrant with the fill value, and select specific rows for the output. (Example: train_5)
7. The output grid dimensions and content are determined by the selected rule.
"""

import numpy as np
from typing import List, Tuple

# Helper Functions

def get_quadrants(grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Splits the grid into four equal quadrants."""
    rows, cols = grid.shape
    r_mid, c_mid = rows // 2, cols // 2
    q1 = grid[0:r_mid, 0:c_mid]
    q2 = grid[0:r_mid, c_mid:cols]
    q3 = grid[r_mid:rows, 0:c_mid]
    q4 = grid[r_mid:rows, c_mid:cols]
    return q1, q2, q3, q4

def calculate_complexity(grid: np.ndarray) -> int:
    """Calculates a simple complexity score (number of unique non-zero values)."""
    unique_vals = np.unique(grid)
    non_zero_unique = unique_vals[unique_vals != 0]
    return len(non_zero_unique)

def get_dominant_non_zero(grid: np.ndarray) -> int:
    """Finds the most frequent non-zero value. Returns 0 if all zeros or empty."""
    unique_vals, counts = np.unique(grid[grid != 0], return_counts=True)
    if len(unique_vals) == 0:
        return 0
    return unique_vals[np.argmax(counts)]

def create_border_tile(inner_val: int, border_val: int, size: int) -> np.ndarray:
    """Creates a square tile of given size with a border and inner value."""
    tile = np.full((size, size), inner_val, dtype=int)
    tile[0, :] = border_val
    tile[-1, :] = border_val
    tile[:, 0] = border_val
    tile[:, -1] = border_val
    return tile


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation logic based on Q3 and Q4 analysis.
    """
    input_array = np.array(input_grid, dtype=int)
    
    # 1. Divide into quadrants
    q1, q2, q3, q4 = get_quadrants(input_array)

    # 2. Analyze complexity of Q3 and Q4
    c3 = calculate_complexity(q3)
    c4 = calculate_complexity(q4)

    # 3. Determine pattern and fill quadrants
    # Simple heuristic: higher complexity = pattern. If equal, assume Q4 is pattern (covers train_1, train_2, train_3, train_5).
    # Train_4 has c3=2, c4=0, so Q3 is pattern.
    if c3 > c4:
        pattern_quadrant = q3
        fill_quadrant = q4
    else: # c4 >= c3
        pattern_quadrant = q4
        fill_quadrant = q3
        
    # 4. Extract fill value
    fill_value = get_dominant_non_zero(fill_quadrant)
    
    # Get unique non-zero values for rule matching
    pattern_unique_nz = set(np.unique(pattern_quadrant[pattern_quadrant != 0]))
    fill_unique_nz = set(np.unique(fill_quadrant[fill_quadrant != 0]))


    # 5. Apply transformation rules based on examples
    
    output_grid = None

    # Rule A (Direct Copy - train_4)
    # Trigger: fill value is 0.
    if fill_value == 0 and pattern_quadrant is q3 : # Explicitly check train_4 case
         output_grid = pattern_quadrant

    # Rule B (Value Combination Tiling - train_1)
    # Trigger: Specific checkerboard patterns in Q3 (1,0) and Q4 (5,6,0). Pattern=Q4, Fill=Q3.
    elif pattern_quadrant is q4 and fill_quadrant is q3 and \
         pattern_unique_nz == {5, 6} and fill_unique_nz == {1}:
        # Combine values 5 and 6 from Q4 into a checkerboard tile
        tile = np.array([[6, 5], [5, 6]])
        # Tile to 2x the size of the pattern quadrant
        output_size_rows = pattern_quadrant.shape[0] * 2
        output_size_cols = pattern_quadrant.shape[1] * 2
        output_grid = np.tile(tile, (output_size_rows // 2, output_size_cols // 2))

    # Rule C (Pattern Application Tiling - train_2)
    # Trigger: Pattern=Q4 (border=4), Fill=Q3 (rows of 1s and 5s).
    elif pattern_quadrant is q4 and fill_quadrant is q3 and \
         pattern_unique_nz == {4} and fill_unique_nz == {1, 5}:
        border_val = list(pattern_unique_nz)[0] # Should be 4
        q3_rows, q3_cols = q3.shape
        tile_size = q3_rows # Tiles are same size as Q3/Q4
        
        # Create base tiles based on unique values in Q3
        tile_map = {}
        for val in fill_unique_nz:
             tile_map[val] = create_border_tile(val, border_val, tile_size)

        # Determine output size (2x input quadrant dimensions, so 4x tile size)
        output_size_rows = tile_size * 4
        output_size_cols = tile_size * 4
        output_grid = np.zeros((output_size_rows, output_size_cols), dtype=int)

        # Tile based on Q3 structure (assuming blocks of values in Q3)
        # This assumes Q3 structure dictates a 2x2 meta-tiling layout
        val_tl = q3[0,0] # Top-left value determines top-left 8x8
        val_bl = q3[q3_rows//2, 0] # Bottom-left value determines bottom-left 8x8
        val_tr = q3[0, q3_cols//2] # Top-right value determines top-right 8x8
        val_br = q3[q3_rows//2, q3_cols//2] # Bottom-right value determines bottom-right 8x8

        output_grid[0:output_size_rows//2, 0:output_size_cols//2] = np.tile(tile_map[val_tl], (2,2))
        output_grid[output_size_rows//2:output_size_rows, 0:output_size_cols//2] = np.tile(tile_map[val_bl], (2,2))
        output_grid[0:output_size_rows//2, output_size_cols//2:output_size_cols] = np.tile(tile_map[val_tr], (2,2))
        output_grid[output_size_rows//2:output_size_rows, output_size_cols//2:output_size_cols] = np.tile(tile_map[val_br], (2,2))

    # Rule D (Zero Replacement and Modification - train_3)
    # Trigger: Pattern=Q4 ({8,6,0}), Fill=Q3 ({1}).
    elif pattern_quadrant is q4 and fill_quadrant is q3 and \
         pattern_unique_nz == {6, 8} and fill_unique_nz == {1}:
         pattern_mod = pattern_quadrant.copy()
         pattern_mod[pattern_mod == 0] = fill_value # Replace 0s with 1
         # Select specific rows: [0,1,2,3,4,5,6,7,3,4]
         selected_rows_indices = [0, 1, 2, 3, 4, 5, 6, 7, 3, 4]
         selected_rows = pattern_mod[selected_rows_indices, :]
         # Append column 4 twice to each selected row
         col_to_append = pattern_mod[:, 4:5] # Keep as column vector
         cols_appended = col_to_append[selected_rows_indices, :] # Select corresponding elements
         cols_appended_twice = np.hstack((cols_appended, cols_appended))
         output_grid = np.hstack((selected_rows, cols_appended_twice))


    # Rule E (Interleaving/Row Selection - train_5)
    # Trigger: Pattern=Q4 ({1,0}), Fill=Q3 ({6}).
    elif pattern_quadrant is q4 and fill_quadrant is q3 and \
         pattern_unique_nz == {1} and fill_unique_nz == {6}:
         pattern_mod = pattern_quadrant.copy()
         pattern_mod[pattern_mod == 0] = fill_value # Replace 0s with 6
         # Select rows [0, 1, 2]
         output_grid = pattern_mod[0:3, :]

    # Fallback / Default: If no specific rule matched, maybe return pattern with zeros filled?
    if output_grid is None:
        # Default action: return the pattern quadrant with zeros replaced by the fill value
        # This might handle unforeseen simple cases or provide a base for debugging
        output_grid = pattern_quadrant.copy()
        output_grid[output_grid == 0] = fill_value
        # Or raise an error if no rule is explicitly hit
        # raise ValueError("Input grid does not match any known transformation pattern.")


    # Convert final NumPy array back to list of lists
    return output_grid.tolist()
```
