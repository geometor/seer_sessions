{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\n\"\"\"\nIdentifies non-zero shapes (8-way connected components) and zero components (4-way connected components) in the input grid.\nDetermines if a zero component constitutes a \"hole\" within a single, unique non-zero shape instance by checking if all of the zero component's non-zero orthogonal neighbors belong exclusively to that single shape instance.\nIf a zero component is identified as a hole, a fill color (F) is determined based on the enclosing shape's color (C) and the colors of other shapes present in the grid, according to specific rules:\n- C=3 -> F=3\n- C=7 -> F=7\n- C=8 -> F=1\n- C=2 -> F=7\n- C=4 -> Depends on the minimum border color (min_obd) of *other* distinct shape instances:\n    - If min_obd=5 -> F=5\n    - If min_obd=3 -> F=6\n    - Otherwise -> F=None (no fill)\n- Other C (e.g., 5) -> F=None (no fill)\nIf a fill color F is determined, all cells within the identified hole (the zero component) are updated to F in the output grid. Cells that are not part of such a fillable hole remain unchanged.\n\"\"\"\n\n\ndef _find_shapes(grid: list[list[int]]) -> tuple[list[dict], dict[tuple[int, int], int]]:\n    \"\"\"\n    Finds all connected components of identical non-zero digits (8-way adjacency).\n    Assigns a unique integer ID to each shape.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing:\n        - A list of dictionaries, where each dictionary represents a shape\n          and contains 'color' (the digit), 'cells' (a set of (row, col) tuples),\n          and 'id' (a unique integer).\n        - A dictionary mapping each cell (r, c) belonging to a shape to its shape ID.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    shapes = []\n    cell_to_shape_id_map = {}\n    next_shape_id = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                color = grid[r][c]\n                shape_cells = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                shape_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8-way neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               (nr, nc) not in visited and grid[nr][nc] == color:\n                                visited.add((nr, nc))\n                                shape_cells.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # Assign unique ID and create shape object\n                current_shape_id = next_shape_id\n                current_shape = {'color': color, 'cells': shape_cells, 'id': current_shape_id} \n                shapes.append(current_shape)\n                for cell in shape_cells:\n                    cell_to_shape_id_map[cell] = current_shape_id # Map cell to the shape ID\n                next_shape_id += 1 # Increment ID for the next shape\n                    \n    return shapes, cell_to_shape_id_map\n\ndef _find_zero_components(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of zero-valued cells (4-way adjacency).\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) tuples\n        of cells belonging to a single connected component of zeros.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited_zeros = set()\n    zero_components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 0 and (r, c) not in visited_zeros:\n                component_cells = set()\n                q = collections.deque([(r, c)])\n                visited_zeros.add((r, c))\n                component_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4-way neighbors (orthogonal only)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] == 0 and (nr, nc) not in visited_zeros:\n                            visited_zeros.add((nr, nc))\n                            component_cells.add((nr, nc))\n                            q.append((nr, nc))\n                if component_cells: # Only add if component has cells\n                    zero_components.append(component_cells)\n                \n    return zero_components\n\ndef _determine_fill_color(enclosing_shape: dict, all_shapes: list[dict]) -> int | None:\n    \"\"\"\n    Determines the fill color based on the enclosing shape's color and other shapes present.\n\n    Args:\n        enclosing_shape: The shape dictionary ({'color', 'cells', 'id'}) enclosing the hole.\n        all_shapes: A list of all shape dictionaries found in the grid.\n\n    Returns:\n        The fill color (int) or None if no fill should occur.\n    \"\"\"\n    shape_color = enclosing_shape['color']\n    shape_id = enclosing_shape['id']\n    \n    # Rules based directly on enclosing shape color\n    if shape_color == 3:\n        return 3\n    if shape_color == 7:\n        return 7\n    if shape_color == 8:\n        return 1\n    if shape_color == 2:\n        return 7\n        \n    # Rule for C=4 depends on other shapes\n    if shape_color == 4:\n        other_border_colors = set()\n        for shape in all_shapes:\n            # Compare using the unique shape ID\n            if shape['id'] != shape_id: \n                 other_border_colors.add(shape['color'])\n\n        if not other_border_colors:\n            return None # No other shapes\n\n        min_obd = min(other_border_colors)\n        if min_obd == 5:\n            return 5\n        if min_obd == 3:\n            return 6\n        else:\n            return None # Min other border color is not 5 or 3\n            \n    # Default case (includes C=5 and any other unspecified colors)\n    return None\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n        \n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # Step 1: Identify all non-zero shapes (8-way) and create a cell -> shape ID map\n    all_shapes, cell_to_shape_id_map = _find_shapes(input_grid)\n    if not all_shapes: # No shapes, no holes possible, return copy\n        return output_grid \n\n    # Step 1b: Create a lookup map from shape ID to shape object for convenience\n    shape_lookup = {shape['id']: shape for shape in all_shapes}\n\n    # Step 2: Find all connected components of zeros (4-way)\n    zero_components = _find_zero_components(input_grid)\n    \n    # Step 3: Process each zero component to see if it's a hole\n    for zero_comp_cells in zero_components:\n        neighbor_shape_ids = set() # Store unique IDs of neighboring shapes\n        \n        # Step 3a: Find all unique non-zero orthogonal neighbors and their shape IDs\n        for rz, cz in zero_comp_cells:\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal neighbors\n                nr, nc = rz + dr, cz + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_pos = (nr, nc)\n                    # Check if the neighbor is non-zero and belongs to a shape\n                    if neighbor_pos in cell_to_shape_id_map:\n                        neighbor_shape_ids.add(cell_to_shape_id_map[neighbor_pos])\n        \n        # Step 3b: Check if it's a hole (all non-zero neighbors belong to exactly one shape ID)\n        if len(neighbor_shape_ids) == 1:\n            enclosing_shape_id = list(neighbor_shape_ids)[0] # Get the single enclosing shape ID\n            enclosing_shape = shape_lookup[enclosing_shape_id] # Get the shape object\n            \n            # Step 4: Determine the fill color based on the enclosing shape and context\n            fill_color = _determine_fill_color(enclosing_shape, all_shapes)\n\n            # Step 5: Apply the fill color to the output grid if determined\n            if fill_color is not None:\n                for r_fill, c_fill in zero_comp_cells:\n                     # Check if the cell is still 0 (safety, might be filled by another hole's logic if overlaps occurred, though unlikely with this definition)\n                     if output_grid[r_fill][c_fill] == 0:\n                          output_grid[r_fill][c_fill] = fill_color\n\n    # Step 6: Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 29929,
    "candidates_token_count": 2860,
    "total_token_count": 32789,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.450583,
  "retries": 1
}