{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\n\"\"\"\nIdentifies non-zero shapes (8-way connected components) and zero components (4-way connected components).\nDetermines if a zero component is a \"hole\" within a single shape instance by checking if all its non-zero orthogonal neighbors belong exclusively to that shape.\nIf a zero component is identified as a hole, a fill color (F) is determined based on the enclosing shape's color (C) and the colors of other shapes present:\n- C=3 -> F=3\n- C=7 -> F=7\n- C=8 -> F=1\n- C=2 -> F=7\n- C=4 -> Depends on the minimum border color (min_obd) of *other* shapes:\n    - If min_obd=5 -> F=5\n    - If min_obd=3 -> F=6\n    - Otherwise -> F=None (no fill)\n- Other C (e.g., 5) -> F=None (no fill)\nIf a fill color F is determined, all cells within the hole (the zero component) are updated to F in the output grid. Other cells remain unchanged.\n\"\"\"\n\n\ndef _find_shapes(grid: list[list[int]]) -> tuple[list[dict], dict[tuple[int, int], dict]]:\n    \"\"\"\n    Finds all connected components of identical non-zero digits (8-way adjacency).\n    Assigns a unique object reference as an ID to each shape.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing:\n        - A list of dictionaries, where each dictionary represents a shape\n          and contains 'color' (the digit) and 'cells' (a set of (row, col) tuples).\n          The dictionary object itself serves as the unique ID.\n        - A dictionary mapping each cell (r, c) belonging to a shape to its shape object.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    shapes = []\n    cell_to_shape_map = {}\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                color = grid[r][c]\n                shape_cells = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                shape_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8-way neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               (nr, nc) not in visited and grid[nr][nc] == color:\n                                visited.add((nr, nc))\n                                shape_cells.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # The dictionary object itself acts as a unique ID\n                current_shape = {'color': color, 'cells': shape_cells} \n                shapes.append(current_shape)\n                for cell in shape_cells:\n                    cell_to_shape_map[cell] = current_shape # Map cell to the shape object\n                    \n    return shapes, cell_to_shape_map\n\ndef _find_zero_components(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of zero-valued cells (4-way adjacency).\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) tuples\n        of cells belonging to a single connected component of zeros.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited_zeros = set()\n    zero_components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 0 and (r, c) not in visited_zeros:\n                component_cells = set()\n                q = collections.deque([(r, c)])\n                visited_zeros.add((r, c))\n                component_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4-way neighbors (orthogonal only)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] == 0 and (nr, nc) not in visited_zeros:\n                            visited_zeros.add((nr, nc))\n                            component_cells.add((nr, nc))\n                            q.append((nr, nc))\n                zero_components.append(component_cells)\n                \n    return zero_components\n\ndef _determine_fill_color(enclosing_shape: dict, all_shapes: list[dict]) -> int | None:\n    \"\"\"\n    Determines the fill color based on the enclosing shape's color and other shapes present.\n\n    Args:\n        enclosing_shape: The shape dictionary enclosing the current hole.\n        all_shapes: A list of all shape dictionaries found in the grid.\n\n    Returns:\n        The fill color (int) or None if no fill should occur.\n    \"\"\"\n    shape_color = enclosing_shape['color']\n    \n    # Rules based directly on enclosing shape color\n    if shape_color == 3:\n        return 3\n    if shape_color == 7:\n        return 7\n    if shape_color == 8:\n        return 1\n    if shape_color == 2:\n        return 7\n        \n    # Rule for C=4 depends on other shapes\n    if shape_color == 4:\n        other_border_colors = set()\n        for shape in all_shapes:\n            # Compare using the shape object reference (unique ID)\n            if shape is not enclosing_shape: \n                 other_border_colors.add(shape['color'])\n\n        if not other_border_colors:\n            return None # No other shapes\n\n        min_obd = min(other_border_colors)\n        if min_obd == 5:\n            return 5\n        if min_obd == 3:\n            return 6\n        else:\n            return None # Min other border color is not 5 or 3\n            \n    # Default case (includes C=5 and any other unspecified colors)\n    return None\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n        \n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # 1. Identify all non-zero shapes (8-way) and create a cell -> shape map\n    all_shapes, cell_to_shape_map = _find_shapes(input_grid)\n    if not all_shapes: # No shapes, no holes possible\n        return output_grid \n\n    # 2. Find all connected components of zeros (4-way)\n    zero_components = _find_zero_components(input_grid)\n    \n    # 3. Process each zero component to see if it's a hole\n    for zero_comp_cells in zero_components:\n        neighbor_shapes = set()\n        has_zero_neighbor = False # Flag if component touches other zeros (or boundary implicitly) - may not be needed with explicit shape check\n        \n        # 3a. Find all unique non-zero orthogonal neighbors and their shapes\n        non_zero_neighbors = set()\n        for rz, cz in zero_comp_cells:\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = rz + dr, cz + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_val = input_grid[nr][nc]\n                    neighbor_pos = (nr, nc)\n                    if neighbor_val != 0:\n                        non_zero_neighbors.add(neighbor_pos)\n                    #elif neighbor_pos not in zero_comp_cells: # Optional check if needed\n                    #    has_zero_neighbor = True \n                else:\n                    # Touches boundary - might imply not a hole, but let shape check decide\n                    pass \n        \n        if not non_zero_neighbors: # Isolated zero component surrounded by zeros (or only boundary)\n             continue\n\n        # 3b. Get the shape instances corresponding to the non-zero neighbors\n        for r_neigh, c_neigh in non_zero_neighbors:\n             if (r_neigh, c_neigh) in cell_to_shape_map:\n                  neighbor_shapes.add(cell_to_shape_map[(r_neigh, c_neigh)])\n        \n        # 3c. Check if it's a hole (all non-zero neighbors belong to exactly one shape)\n        if len(neighbor_shapes) == 1:\n            enclosing_shape = list(neighbor_shapes)[0] # Get the single enclosing shape object\n            \n            # 4. Determine the fill color based on the enclosing shape and context\n            fill_color = _determine_fill_color(enclosing_shape, all_shapes)\n\n            # 5. Apply the fill color to the output grid if determined\n            if fill_color is not None:\n                for r_fill, c_fill in zero_comp_cells:\n                     # Check if the cell is still 0 (safety, shouldn't be needed if logic is sound)\n                     if output_grid[r_fill][c_fill] == 0:\n                          output_grid[r_fill][c_fill] = fill_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22616,
    "candidates_token_count": 2853,
    "total_token_count": 25469,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.494427,
  "retries": 1
}