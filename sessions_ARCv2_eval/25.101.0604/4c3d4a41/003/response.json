{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms a 2D grid based on the following rules:\n1. Defines a Frame Color (5) and a Background Color (0). Any other color is a Content Color.\n2. Identifies the \"Main Frame\": the largest connected component of Frame Color cells in the input grid that touches at least one edge.\n3. Initializes an output grid of the same dimensions.\n4. Determines the color of each cell in the output grid based on the input grid and the Main Frame:\n    a. If a cell is part of the Main Frame, its output color is Frame Color.\n    b. If an input cell has Frame Color but is *not* part of the Main Frame:\n        i. Check the color below it in the input grid.\n        ii. If the color below is a Content Color, the output color is the color below.\n        iii. Otherwise, the output color is Background Color.\n    c. If an input cell has a Content Color:\n        i. Look down the column from the cell below it.\n        ii. If Background Color (0) is found *before* Frame Color (5) (or the grid bottom is reached), the output color is Frame Color.\n        iii. Otherwise (Frame Color is found first or neither is found), the output color is the original Content Color.\n    d. If an input cell has Background Color and is not part of the Main Frame, its output color is Background Color.\n\"\"\"\n\ndef find_main_frame_mask(grid: np.ndarray, frame_color: int) -> np.ndarray:\n    \"\"\"\n    Identifies the largest connected component of frame_color cells\n    that touches any edge of the grid.\n    Returns a boolean mask where True indicates a cell is part of the main frame.\n    \"\"\"\n    H, W = grid.shape\n    # Create a binary mask where frame_color cells are True\n    binary_mask = (grid == frame_color)\n    \n    # Label connected components\n    labeled_array, num_features = label(binary_mask)\n    \n    if num_features == 0:\n        return np.zeros_like(grid, dtype=bool) # No frame color cells found\n\n    largest_edge_component_label = 0\n    max_size = -1\n\n    # Iterate through each component label (1 to num_features)\n    for i in range(1, num_features + 1):\n        component_mask = (labeled_array == i)\n        component_size = np.sum(component_mask)\n        \n        # Check if this component touches any edge\n        touches_edge = False\n        # Get coordinates where the component exists\n        coords = np.argwhere(component_mask)\n        # Check if any coordinate touches an edge\n        if np.any(coords[:, 0] == 0) or np.any(coords[:, 0] == H - 1) or \\\n           np.any(coords[:, 1] == 0) or np.any(coords[:, 1] == W - 1):\n            touches_edge = True\n        \n        # If it touches an edge and is larger than the current max, update\n        if touches_edge and component_size > max_size:\n            max_size = component_size\n            largest_edge_component_label = i\n            \n    # If no component touching an edge was found, return an empty mask\n    if largest_edge_component_label == 0:\n         return np.zeros_like(grid, dtype=bool)\n\n    # Create the final mask for the largest edge-touching component\n    main_frame_mask = (labeled_array == largest_edge_component_label)\n    \n    return main_frame_mask\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_arr = np.array(input_grid, dtype=int)\n    H, W = input_arr.shape\n    \n    # Initialize output grid with zeros (Background Color)\n    # We will fill it based on rules, rather than copying and modifying.\n    output_arr = np.zeros_like(input_arr)\n    \n    FRAME_COLOR = 5\n    BACKGROUND_COLOR = 0\n\n    # 1. Identify the Main Frame\n    main_frame_mask = find_main_frame_mask(input_arr, FRAME_COLOR)\n\n    # 2. Process Each Cell based on input_arr and main_frame_mask\n    for r in range(H):\n        for c in range(W):\n            input_color = input_arr[r, c]\n            is_main_frame = main_frame_mask[r, c]\n\n            # Rule 4a: Check Main Frame\n            if is_main_frame:\n                output_arr[r, c] = FRAME_COLOR\n                continue # Skip other rules if it's part of the main frame\n\n            # Rule 4b: Check Non-Frame 5\n            if input_color == FRAME_COLOR: # Already know it's not main_frame\n                color_below = BACKGROUND_COLOR # Default if out of bounds\n                if r + 1 < H:\n                    color_below = input_arr[r + 1, c]\n                \n                # Check if color_below is a Content Color\n                is_content_below = (color_below != BACKGROUND_COLOR and color_below != FRAME_COLOR)\n                \n                if is_content_below:\n                    output_arr[r, c] = color_below # Rule 4b.ii\n                else:\n                    output_arr[r, c] = BACKGROUND_COLOR # Rule 4b.iii\n                continue # Processed this cell\n\n            # Rule 4c: Check Content Color\n            is_content_color = (input_color != BACKGROUND_COLOR and input_color != FRAME_COLOR)\n            if is_content_color:\n                found_zero_first = False\n                # Look down the column from r+1\n                for r_look in range(r + 1, H):\n                    look_color = input_arr[r_look, c]\n                    if look_color == BACKGROUND_COLOR:\n                        found_zero_first = True # Rule 4c.iii\n                        break\n                    if look_color == FRAME_COLOR:\n                        found_zero_first = False # Rule 4c.iv (part 1)\n                        break\n                # If loop finishes without break, it means boundary reached before 0 or 5 found\n                else: # This else belongs to the for loop (no-break case)\n                    found_zero_first = True # Rule 4c.iii (boundary case)\n\n                if found_zero_first:\n                    output_arr[r, c] = FRAME_COLOR\n                else:\n                    output_arr[r, c] = input_color # Rule 4c.iv (part 2)\n                continue # Processed this cell\n            \n            # Rule 4d: Check Background Color (and not main frame)\n            if input_color == BACKGROUND_COLOR: # Already know it's not main_frame\n                 output_arr[r, c] = BACKGROUND_COLOR\n                 continue # Processed this cell\n\n    # Convert the result back to a list of lists\n    output_grid = output_arr.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10821,
    "candidates_token_count": 2149,
    "total_token_count": 12970,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.218439,
  "retries": 1
}