{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 2D grid based on the following rules:\n1. Defines a Frame Color (5) and a Background Color (0). Any other color is a Content Color.\n2. Identifies the \"Main Frame\": the largest connected component of Frame Color cells in the input grid that touches at least one edge.\n3. Initializes an output grid of the same dimensions.\n4. Determines the color of each cell (r, c) in the output grid based on the input grid and the Main Frame mask:\n    a. Main Frame Cell: If the cell is part of the Main Frame, the output color is Frame Color.\n    b. Background Cell: If the cell is not part of the Main Frame and its input color is Background Color, the output color is Background Color.\n    c. Non-Frame 5 Cell: If the cell is not part of the Main Frame and its input color is Frame Color:\n        i. Check the color directly below in the input grid (I_bel1). Treat out-of-bounds as Background Color.\n        ii. If I_bel1 is a Content Color, the output color is I_bel1.\n        iii. Otherwise (I_bel1 is Frame or Background), the output color is Background Color.\n    d. Content Color Cell (C): If the cell is not part of the Main Frame and its input color C is a Content Color:\n        i. Check if it's the top of a vertical stack of C's (r=0 or cell above is different).\n        ii. If it is the top, the output color is C.\n        iii. If it is not the top:\n            1. Find the height h of the stack of C's downwards.\n            2. Get the terminating color T at (r+h, c) (treat out-of-bounds as Background Color).\n            3. If T is Background Color or Frame Color, the output color is Frame Color.\n            4. Otherwise (T is a Content Color), the output color is C.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef find_main_frame_mask(grid: np.ndarray, frame_color: int) -> np.ndarray:\n    \"\"\"\n    Identifies the largest connected component of frame_color cells\n    that touches any edge of the grid.\n    Returns a boolean mask where True indicates a cell is part of the main frame.\n    Uses 8-connectivity.\n    \"\"\"\n    H, W = grid.shape\n    # Create a binary mask where frame_color cells are True\n    binary_mask = (grid == frame_color)\n    \n    # Label connected components using 8-connectivity (default for label)\n    labeled_array, num_features = label(binary_mask)\n    \n    if num_features == 0:\n        return np.zeros_like(grid, dtype=bool) # No frame color cells found\n\n    largest_edge_component_label = 0\n    max_size = -1\n\n    # Iterate through each component label (1 to num_features)\n    for i in range(1, num_features + 1):\n        component_mask = (labeled_array == i)\n        component_size = np.sum(component_mask)\n        \n        # Check if this component touches any edge\n        touches_edge = False\n        # Get coordinates where the component exists\n        coords = np.argwhere(component_mask)\n        # Check if any coordinate touches an edge\n        if coords.size > 0: # Ensure component is not empty\n             if np.any(coords[:, 0] == 0) or np.any(coords[:, 0] == H - 1) or \\\n                np.any(coords[:, 1] == 0) or np.any(coords[:, 1] == W - 1):\n                 touches_edge = True\n        \n        # If it touches an edge and is larger than the current max, update\n        if touches_edge and component_size > max_size:\n            max_size = component_size\n            largest_edge_component_label = i\n            \n    # If no component touching an edge was found, return an empty mask\n    if largest_edge_component_label == 0:\n         # This might happen if the only '5's are internal and don't touch edges.\n         # Based on examples, we expect a frame touching edges.\n         return np.zeros_like(grid, dtype=bool) \n\n    # Create the final mask for the largest edge-touching component\n    main_frame_mask = (labeled_array == largest_edge_component_label)\n    \n    return main_frame_mask\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"Applies the transformation rules to the input grid.\"\"\"\n    \n    # --- Initialization ---\n    input_arr = np.array(input_grid, dtype=int)\n    H, W = input_arr.shape\n    output_arr = np.full_like(input_arr, -1) # Initialize with temporary value\n    \n    FRAME_COLOR = 5\n    BACKGROUND_COLOR = 0\n\n    # --- Step 1: Identify the Main Frame ---\n    main_frame_mask = find_main_frame_mask(input_arr, FRAME_COLOR)\n\n    # --- Step 2: Determine Output for Each Cell ---\n    for r in range(H):\n        for c in range(W):\n            # --- Rule 4a: Main Frame Cell ---\n            if main_frame_mask[r, c]:\n                output_arr[r, c] = FRAME_COLOR\n                continue\n\n            input_color = input_arr[r, c]\n\n            # --- Rule 4b: Background Cell (not main frame) ---\n            if input_color == BACKGROUND_COLOR:\n                output_arr[r, c] = BACKGROUND_COLOR\n                continue\n\n            # --- Rule 4c: Non-Frame 5 Cell (not main frame) ---\n            if input_color == FRAME_COLOR:\n                color_below_in = BACKGROUND_COLOR # Default if out of bounds\n                if r + 1 < H:\n                    color_below_in = input_arr[r + 1, c]\n                \n                # Check if color_below is a Content Color\n                is_content_below = (color_below_in != BACKGROUND_COLOR and color_below_in != FRAME_COLOR)\n                \n                if is_content_below:\n                    output_arr[r, c] = color_below_in # Rule 4c.ii\n                else:\n                    output_arr[r, c] = BACKGROUND_COLOR # Rule 4c.iii\n                continue\n\n            # --- Rule 4d: Content Color Cell (not main frame) ---\n            # This handles the remaining case: input_color is a Content Color (C)\n            C = input_color \n            \n            # Check if top of stack\n            is_top_of_stack = (r == 0 or input_arr[r - 1, c] != C)\n\n            if is_top_of_stack: # Rule 4d.ii\n                output_arr[r, c] = C\n            else: # Rule 4d.iii - Not top of stack\n                # Find stack height h downwards\n                h = 0\n                while True:\n                    check_r = r + h\n                    if check_r < H and input_arr[check_r, c] == C:\n                        h += 1\n                    else:\n                        break \n                \n                # Get terminating color T\n                term_r = r + h\n                terminating_color = BACKGROUND_COLOR # Default if out of bounds\n                if term_r < H:\n                    terminating_color = input_arr[term_r, c]\n\n                # Apply rule based on terminating color\n                if terminating_color == BACKGROUND_COLOR or terminating_color == FRAME_COLOR:\n                    output_arr[r, c] = FRAME_COLOR # Rule 4d.iii.3\n                else: # Terminating color is a Content Color\n                    output_arr[r, c] = C # Rule 4d.iii.4\n\n    # --- Finalization ---\n    # Sanity check if any cell remained unassigned\n    if np.any(output_arr == -1):\n        raise ValueError(\"Error: Not all cells were assigned an output color.\")\n        \n    output_grid = output_arr.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27093,
    "candidates_token_count": 2353,
    "total_token_count": 29446,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.328781,
  "retries": 1
}