{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms a 2D grid based on the following rules:\n1. Defines a Frame Color (5) and a Background Color (0).\n2. Identifies the \"Main Frame\": the largest connected component of Frame Color cells that touches any edge of the grid.\n3. Initializes the output grid as a copy of the input grid.\n4. Modifies cells that have the Frame Color in the input but are *not* part of the Main Frame (\"Non-Frame 5s\"):\n    a. If the cell directly below a Non-Frame 5 in the input grid contains a \"content color\" (neither Frame Color nor Background Color), the Non-Frame 5 cell in the output grid takes the color of the cell below.\n    b. Otherwise (if the cell below is Frame Color or Background Color, or if it's the last row), the Non-Frame 5 cell in the output grid becomes Background Color.\n5. Modifies cells that contain a \"content color\" in the input grid:\n    a. If the cell directly below such a cell in the input grid is Background Color, the content color cell in the output grid becomes Frame Color.\n6. Cells belonging to the Main Frame and cells not otherwise modified retain their original color.\n\"\"\"\n\ndef find_main_frame_mask(grid: np.ndarray, frame_color: int) -> np.ndarray:\n    \"\"\"\n    Identifies the largest connected component of frame_color cells\n    that touches any edge of the grid.\n    Returns a boolean mask where True indicates a cell is part of the main frame.\n    \"\"\"\n    H, W = grid.shape\n    # Create a binary mask where frame_color cells are True\n    binary_mask = (grid == frame_color)\n    \n    # Label connected components\n    labeled_array, num_features = label(binary_mask)\n    \n    if num_features == 0:\n        return np.zeros_like(grid, dtype=bool) # No frame color cells found\n\n    # Find the locations of each labeled component\n    component_slices = find_objects(labeled_array)\n    \n    largest_edge_component_label = 0\n    max_size = -1\n\n    for i in range(1, num_features + 1):\n        component_mask = (labeled_array == i)\n        component_size = np.sum(component_mask)\n        \n        # Check if this component touches any edge\n        touches_edge = False\n        coords = np.argwhere(component_mask)\n        for r, c in coords:\n            if r == 0 or r == H - 1 or c == 0 or c == W - 1:\n                touches_edge = True\n                break\n        \n        # If it touches an edge and is larger than the current max, update\n        if touches_edge and component_size > max_size:\n            max_size = component_size\n            largest_edge_component_label = i\n            \n    if largest_edge_component_label == 0:\n         # Fallback: if no component touches the edge, maybe it's just the largest? \n         # Or maybe there's no 'main frame' according to the definition.\n         # Let's stick to the definition: if none touch edge, return empty mask.\n         # Revisit if tests fail.\n         # Alternative: Find largest overall component if none touch edge?\n         # Let's check if any component exists first. If so, maybe pick the largest regardless of edge.\n         # Re-evaluating: The examples clearly show a large frame, usually touching edges.\n         # If no component touches the edge, assume there's no main frame by this definition.\n         return np.zeros_like(grid, dtype=bool)\n\n\n    # Create the final mask for the largest edge-touching component\n    main_frame_mask = (labeled_array == largest_edge_component_label)\n    \n    return main_frame_mask\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_arr = np.array(input_grid, dtype=int)\n    H, W = input_arr.shape\n    \n    # Initialize output grid as a copy of the input\n    output_arr = np.copy(input_arr)\n    \n    FRAME_COLOR = 5\n    BACKGROUND_COLOR = 0\n\n    # 1. Identify the Main Frame\n    main_frame_mask = find_main_frame_mask(input_arr, FRAME_COLOR)\n\n    # 2. Process Non-Frame 5s\n    for r in range(H):\n        for c in range(W):\n            # Check if the current cell is a '5' but NOT part of the main frame\n            if input_arr[r, c] == FRAME_COLOR and not main_frame_mask[r, c]:\n                # Check the cell below\n                if r + 1 < H:\n                    v_below = input_arr[r + 1, c]\n                    # Rule 4a: If below is content color, propagate up\n                    if v_below != BACKGROUND_COLOR and v_below != FRAME_COLOR:\n                        output_arr[r, c] = v_below\n                    # Rule 4b: Otherwise, set to background\n                    else:\n                        output_arr[r, c] = BACKGROUND_COLOR\n                else:\n                    # Rule 4b (boundary case): Last row, set to background\n                    output_arr[r, c] = BACKGROUND_COLOR\n\n    # 3. Process Content Colors (check input, modify output)\n    # Note: We iterate up to H-2 because we look at the cell below (r+1)\n    for r in range(H - 1):\n        for c in range(W):\n            current_color = input_arr[r, c]\n            # Check if it's a content color\n            if current_color != BACKGROUND_COLOR and current_color != FRAME_COLOR:\n                v_below = input_arr[r + 1, c]\n                # Rule 5a: If cell below is background, change current cell to Frame Color\n                if v_below == BACKGROUND_COLOR:\n                    output_arr[r, c] = FRAME_COLOR\n                    \n    # Convert the result back to a list of lists\n    output_grid = output_arr.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3444,
    "candidates_token_count": 2906,
    "total_token_count": 6350,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.671353,
  "retries": 1
}