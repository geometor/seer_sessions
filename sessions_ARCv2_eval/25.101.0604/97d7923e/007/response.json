{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the global smallest non-zero integer (R) and the global largest \n   non-zero integer (T) in the input grid.\n2. Initialize an output grid as a copy of the input. Get the number of rows.\n3. Process each column independently:\n    a. Check if the global minimum (R) exists in the current column.\n    b. If R exists (Primary Rule):\n        i. Find the row index of the first R (`first_r_row`).\n        ii. Check blocking condition: if `first_r_row >= rows // 2`, skip this column.\n        iii. Find the row index of the first T below `first_r_row` (`first_t_below_r_row`). If none, skip.\n        iv. Determine start row: `start_row = first_t_below_r_row + 4` if `first_r_row == 1`, else `start_row = first_t_below_r_row`.\n        v. Apply replacements: From `start_row` downwards, change T to R in the output grid.\n    c. If R does NOT exist (Secondary Rule):\n        i. Find the local minimum non-zero (`min_l`) and maximum non-zero (`max_l`) in the column.\n        ii. If `min_l` and `max_l` exist and are different:\n            * Find first `min_l`, last `min_l`, and first `max_l`.\n            * If `first_min_l < first_max_l < last_min_l`, replace all `max_l` with `min_l` in the column in the output grid.\n4. Return the modified output grid.\n\"\"\"\n\ndef find_global_key_values(grid: np.ndarray) -> tuple[int | None, int | None]:\n    \"\"\"Finds the global smallest (R) and largest (T) non-zero values.\"\"\"\n    non_zeros = grid[grid > 0]\n    if non_zeros.size == 0:\n        return None, None\n    min_val = np.min(non_zeros)\n    max_val = np.max(non_zeros)\n    return min_val, max_val\n\ndef find_local_key_values(column: np.ndarray) -> tuple[int | None, int | None]:\n    \"\"\"Finds the local smallest and largest non-zero values in a column.\"\"\"\n    non_zeros = column[column > 0]\n    if non_zeros.size == 0:\n        return None, None\n    min_val = np.min(non_zeros)\n    max_val = np.max(non_zeros)\n    # Return None, None if only one unique non-zero value exists locally\n    if min_val == max_val:\n        return None, None\n    return min_val, max_val\n\ndef find_first_occurrence(arr: np.ndarray, value: int, start_row: int = 0) -> int | None:\n    \"\"\"Finds the row index of the first occurrence of 'value' starting from 'start_row'.\"\"\"\n    indices = np.where(arr[start_row:] == value)[0]\n    if len(indices) > 0:\n        return indices[0] + start_row\n    return None\n\ndef find_last_occurrence(arr: np.ndarray, value: int) -> int | None:\n    \"\"\"Finds the row index of the last occurrence of 'value'.\"\"\"\n    indices = np.where(arr == value)[0]\n    if len(indices) > 0:\n        return indices[-1]\n    return None\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify Global Key Values (R and T)\n    r_val_global, t_val_global = find_global_key_values(input_np)\n\n    # 2. Initialize Output grid and get dimensions\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # If no global R or T, or they are the same, secondary rule might still apply,\n    # but primary rule won't. We don't return early.\n\n    # 3. Process Each Column\n    for j in range(cols):\n        col_data = input_np[:, j]\n        \n        # 3a. Check if Global R exists in the column\n        r_present = r_val_global is not None and np.any(col_data == r_val_global)\n\n        if r_present and r_val_global is not None and t_val_global is not None and r_val_global != t_val_global:\n            # 3b. Apply Primary Rule\n            \n            # i. Find First R\n            first_r_row = find_first_occurrence(col_data, r_val_global)\n            # This check is redundant due to r_present, but good practice\n            if first_r_row is None: \n                continue \n\n            # ii. Check Blocking Condition\n            block_threshold = rows // 2\n            if first_r_row >= block_threshold:\n                continue\n\n            # iii. Find First T Below R\n            first_t_below_r_row = find_first_occurrence(col_data, t_val_global, start_row=first_r_row + 1)\n            if first_t_below_r_row is None:\n                continue\n\n            # iv. Determine Replacement Start Row\n            start_row: int\n            if first_r_row == 1:\n                start_row = first_t_below_r_row + 4 # Updated rule for first_r_row == 1\n            else:\n                start_row = first_t_below_r_row\n\n            # v. Apply Replacements\n            if start_row < rows:\n                for i in range(start_row, rows):\n                    if input_np[i, j] == t_val_global:\n                        output_np[i, j] = r_val_global\n        \n        elif not r_present:\n            # 3c. Apply Secondary Rule (Global R not in column)\n            \n            # i. Find Local Min/Max\n            min_l, max_l = find_local_key_values(col_data)\n\n            # ii. Check if valid local keys exist\n            if min_l is not None and max_l is not None:\n                # Find first min_l, last min_l, first max_l\n                first_min_l_row = find_first_occurrence(col_data, min_l)\n                last_min_l_row = find_last_occurrence(col_data, min_l)\n                first_max_l_row = find_first_occurrence(col_data, max_l)\n\n                # Check trigger condition: indices exist and are ordered correctly\n                if (first_min_l_row is not None and \n                    last_min_l_row is not None and \n                    first_max_l_row is not None and\n                    first_min_l_row < first_max_l_row and \n                    last_min_l_row > first_max_l_row):\n                    \n                    # Apply replacement: change all max_l to min_l\n                    for i in range(rows):\n                        if input_np[i, j] == max_l:\n                            output_np[i, j] = min_l\n                            \n    # 4. Return Result\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23585,
    "candidates_token_count": 2499,
    "total_token_count": 26084,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.871898,
  "retries": 1
}