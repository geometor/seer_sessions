{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying the core area containing non-background pixels (digits other than 8).\n2. Finding all connected non-background objects within this core area using 4-way connectivity.\n3. Extracting the bounding box subgrid for each object from the core grid.\n4. Determining the maximum width among all extracted object subgrids.\n5. Sorting the extracted subgrids based on their original top-left position within the core grid (top-to-bottom, then left-to-right).\n6. Padding each subgrid symmetrically with the background color (8) to match the calculated maximum width.\n7. Stacking the padded subgrids vertically in their sorted order to create the output grid.\n\nNote: This implementation is based on the pattern observed in examples train_2, \ntrain_3, and train_4, where the output width matches the maximum width of the \nobjects found in the core grid. Example train_1 appears to follow a different \nwidth determination or padding rule (output width 6 vs max object width 2) and \nmay not be handled correctly by this code.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _find_core_grid(grid_np: np.ndarray, background_color: int) -> np.ndarray | None:\n    \"\"\"\n    Finds the smallest bounding box containing all non-background cells\n    and returns that subgrid.\n\n    Args:\n        grid_np: The input grid as a numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        The core grid as a numpy array, or None if no non-background cells are found.\n    \"\"\"\n    non_bg_coords = np.argwhere(grid_np != background_color)\n    if non_bg_coords.size == 0:\n        return None  # No non-background cells found\n\n    min_r, min_c = non_bg_coords.min(axis=0)\n    max_r, max_c = non_bg_coords.max(axis=0)\n\n    core_grid = grid_np[min_r:max_r + 1, min_c:max_c + 1]\n    return core_grid\n\n\ndef _find_objects_in_core(core_grid_np: np.ndarray, background_color: int) -> list[dict]:\n    \"\"\"\n    Finds all connected components (objects) of non-background pixels within the core grid.\n\n    Args:\n        core_grid_np: The core grid (subgrid containing non-background pixels) as a numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its 'bounds' (min_r, max_r, min_c, max_c) relative to the core grid\n        and 'top_left' coordinate (min_r, min_c) relative to the core grid for sorting.\n    \"\"\"\n    if core_grid_np is None or core_grid_np.size == 0:\n        return []\n        \n    rows, cols = core_grid_np.shape\n    visited = np.zeros_like(core_grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a non-background cell that hasn't been visited\n            if core_grid_np[r, c] != background_color and not visited[r, c]:\n                component_pixels = [] # Store coordinates (r, c) of pixels in this component relative to core grid\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n\n                    # Explore neighbors (4-way connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds within core_grid and if the neighbor is part of the object and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           core_grid_np[nr, nc] != background_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if component_pixels:\n                    # Calculate bounding box relative to the core grid\n                    obj_min_r = min(px[0] for px in component_pixels)\n                    obj_max_r = max(px[0] for px in component_pixels)\n                    obj_min_c = min(px[1] for px in component_pixels)\n                    obj_max_c = max(px[1] for px in component_pixels)\n                    \n                    objects.append({\n                        'bounds': (obj_min_r, obj_max_r, obj_min_c, obj_max_c),\n                        'top_left': (obj_min_r, obj_min_c) # Use top-left relative to core grid for sorting\n                    })\n\n    # Sort objects based on their top-left corner within the core grid\n    objects.sort(key=lambda obj: obj['top_left'])\n    return objects\n\n\ndef _extract_subgrid_from_core(core_grid_np: np.ndarray, bounds: tuple) -> np.ndarray:\n    \"\"\"\n    Extracts the rectangular subgrid defined by the bounds from the core grid.\n    \"\"\"\n    min_r, max_r, min_c, max_c = bounds\n    return core_grid_np[min_r:max_r+1, min_c:max_c+1]\n\n\ndef _pad_subgrid(subgrid_np: np.ndarray, target_width: int, background_color: int) -> np.ndarray:\n    \"\"\"\n    Pads a subgrid with the background color to reach the target width.\n    Padding is applied symmetrically (left and right). Handles empty/invalid inputs.\n    \"\"\"\n    # Handle cases where subgrid might be None or empty after extraction\n    if subgrid_np is None or subgrid_np.size == 0:\n        # Cannot pad an empty array, maybe return an empty array of target width?\n        # For this task, returning an empty array seems safer if extraction failed.\n         return np.array([[]], dtype=int) if subgrid_np is None else subgrid_np\n\n    # Ensure subgrid is 2D for shape access\n    if subgrid_np.ndim == 1:\n         subgrid_np = subgrid_np.reshape(1, -1) # Reshape 1D array to 2D row vector\n         \n    current_height, current_width = subgrid_np.shape\n\n    if current_width == target_width:\n        return subgrid_np # No padding needed\n    elif current_width > target_width:\n         # This case should ideally not happen if target_width is the max width\n         # But if it does, return original or handle as error. Returning original for now.\n         print(f\"Warning: Subgrid width {current_width} > target width {target_width}. Returning original.\")\n         return subgrid_np\n\n    # Calculate padding amounts\n    padding_needed = target_width - current_width\n    left_padding = padding_needed // 2\n    right_padding = padding_needed - left_padding\n\n    # Create padding arrays filled with the background color\n    # Use subgrid_np.dtype to ensure type consistency\n    left_pad_arr = np.full((current_height, left_padding), background_color, dtype=subgrid_np.dtype)\n    right_pad_arr = np.full((current_height, right_padding), background_color, dtype=subgrid_np.dtype)\n\n    # Concatenate horizontally: left_padding + subgrid + right_padding\n    padded_subgrid = np.concatenate((left_pad_arr, subgrid_np, right_pad_arr), axis=1)\n    return padded_subgrid\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert input to numpy array\n    input_np = np.array(input_grid, dtype=int)\n    background_color = 8\n\n    # --- Step 1: Identify the Core Grid ---\n    core_grid_np = _find_core_grid(input_np, background_color)\n\n    # If no core grid found (e.g., input is all background), return empty\n    if core_grid_np is None:\n        return []\n\n    # --- Step 2: Find Objects within the Core Grid ---\n    # Objects are returned sorted by their top-left position within the core grid.\n    objects = _find_objects_in_core(core_grid_np, background_color)\n\n    # If no objects found within the core grid, return empty\n    if not objects:\n        return [] \n\n    # --- Step 3: Extract the Subgrid for Each Object from the Core Grid ---\n    extracted_subgrids = []\n    for obj in objects:\n        subgrid = _extract_subgrid_from_core(core_grid_np, obj['bounds'])\n        extracted_subgrids.append(subgrid)\n\n    # Filter out potentially empty subgrids if extraction somehow failed for an object\n    extracted_subgrids = [sg for sg in extracted_subgrids if sg.size > 0]\n    if not extracted_subgrids:\n        return []\n\n    # --- Step 4: Determine the Target Width (Max Width among Extracted Subgrids) ---\n    max_width = 0\n    for subgrid in extracted_subgrids:\n        width = subgrid.shape[1] if subgrid.ndim == 2 else (subgrid.size if subgrid.ndim == 1 else 0)\n        max_width = max(max_width, width)\n        \n    # If max_width is still 0 (e.g., all objects were somehow empty points), return empty\n    if max_width == 0:\n        return []\n\n    # --- Step 5: Pad Each Extracted Subgrid to the Maximum Width ---\n    # The order is preserved from the sorted objects list.\n    padded_subgrids = []\n    for subgrid in extracted_subgrids:\n        padded = _pad_subgrid(subgrid, max_width, background_color)\n        # Check if padding resulted in a valid (non-empty) grid before adding\n        if padded.size > 0:\n            padded_subgrids.append(padded)\n            \n    # If no valid padded subgrids remain, return empty\n    if not padded_subgrids:\n        return []\n\n    # --- Step 6: Concatenate Padded Subgrids Vertically ---\n    # Use numpy's vstack for efficient vertical stacking\n    output_np = np.vstack(padded_subgrids)\n\n    # --- Step 7: Convert Final Numpy Array Back to List of Lists ---\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15223,
    "candidates_token_count": 3587,
    "total_token_count": 18810,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.31364,
  "retries": 1
}