{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components (objects) of digits other than 8 (background) in the input grid.\nCalculates the bounding box for each object and extracts the corresponding subgrid from the original input grid.\nDetermines the maximum width among all extracted object subgrids.\nSorts the subgrids based on the top-left coordinate of their original bounding box (top-to-bottom, then left-to-right).\nPads each subgrid symmetrically with the background color (8) to match the maximum width.\nStacks the padded subgrids vertically in their sorted order to create the output grid.\n\nNote: This logic is derived primarily from examples train_2, train_3, and train_4. \nExample train_1 appears to follow a different padding or width determination rule \nand may not be handled correctly by this implementation, as its output width (6) \ndoes not match the maximum width of its input objects (2).\n\"\"\"\n\n# Helper function to find connected components (objects) of non-background pixels using BFS\ndef _find_objects(grid_np: np.ndarray, background_color: int) -> list[dict]:\n    \"\"\"\n    Finds all connected components of non-background pixels.\n\n    Args:\n        grid_np: The input grid as a numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its 'bounds' (min_r, max_r, min_c, max_c) and\n        'top_left' coordinate (min_r, min_c) for sorting.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if we find a non-background cell that hasn't been visited\n            if grid_np[r, c] != background_color and not visited[r, c]:\n                component_pixels = [] # Store coordinates (r, c) of pixels in this component\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col))\n\n                    # Explore neighbors (4-way connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is part of the object and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid_np[nr, nc] != background_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if component_pixels:\n                    # Calculate bounding box after finding all pixels for the component\n                    obj_min_r = min(px[0] for px in component_pixels)\n                    obj_max_r = max(px[0] for px in component_pixels)\n                    obj_min_c = min(px[1] for px in component_pixels)\n                    obj_max_c = max(px[1] for px in component_pixels)\n                    \n                    objects.append({\n                        'bounds': (obj_min_r, obj_max_r, obj_min_c, obj_max_c),\n                        'top_left': (obj_min_r, obj_min_c) # Use top-left for sorting\n                    })\n\n    # Sort objects based on their top-left corner (top-to-bottom, then left-to-right)\n    objects.sort(key=lambda obj: obj['top_left'])\n    return objects\n\n# Helper function to extract the subgrid based on bounding box\ndef _extract_subgrid(grid_np: np.ndarray, bounds: tuple) -> np.ndarray:\n    \"\"\"\n    Extracts the rectangular subgrid defined by the bounds from the grid.\n    \"\"\"\n    min_r, max_r, min_c, max_c = bounds\n    # Slice the numpy array to get the subgrid\n    return grid_np[min_r:max_r+1, min_c:max_c+1]\n\n# Helper function to pad a subgrid symmetrically to a target width\ndef _pad_subgrid(subgrid_np: np.ndarray, target_width: int, background_color: int) -> np.ndarray:\n    \"\"\"\n    Pads a subgrid with the background color to reach the target width.\n    Padding is applied symmetrically (left and right).\n    \"\"\"\n    if subgrid_np is None or subgrid_np.size == 0:\n        # Return an empty array or handle as error if needed\n        return np.array([[]], dtype=int) \n        \n    current_height, current_width = subgrid_np.shape\n\n    if current_width == target_width:\n        return subgrid_np # No padding needed\n    elif current_width > target_width:\n         # This case should not happen if target_width is the max width found\n         # Return original subgrid if it does\n         return subgrid_np\n\n    # Calculate padding amounts\n    padding_needed = target_width - current_width\n    left_padding = padding_needed // 2\n    right_padding = padding_needed - left_padding\n\n    # Create padding arrays filled with the background color\n    left_pad_arr = np.full((current_height, left_padding), background_color, dtype=subgrid_np.dtype)\n    right_pad_arr = np.full((current_height, right_padding), background_color, dtype=subgrid_np.dtype)\n\n    # Concatenate horizontally: left_padding + subgrid + right_padding\n    padded_subgrid = np.concatenate((left_pad_arr, subgrid_np, right_pad_arr), axis=1)\n    return padded_subgrid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by extracting non-background objects, padding them\n    to a uniform width (based on the widest object), and stacking them vertically.\n    \"\"\"\n    \n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    background_color = 8\n\n    # --- Step 1: Find all non-background objects and their bounding boxes ---\n    # Objects are returned sorted by their top-left position.\n    objects = _find_objects(input_np, background_color)\n\n    # Handle case where no objects are found\n    if not objects:\n        return [] \n\n    # --- Step 2: Extract the subgrid for each object ---\n    extracted_subgrids = []\n    for obj in objects:\n        subgrid = _extract_subgrid(input_np, obj['bounds'])\n        extracted_subgrids.append(subgrid)\n\n    # --- Step 3: Determine the target width (max width among all extracted subgrids) ---\n    if not extracted_subgrids:\n         return [] # Should be caught by object check, but defensive programming\n    \n    max_width = 0\n    for subgrid in extracted_subgrids:\n        # Check if subgrid is valid and has 2 dimensions before accessing shape[1]\n        if subgrid is not None and subgrid.ndim == 2 and subgrid.shape[1] > 0:\n             max_width = max(max_width, subgrid.shape[1])\n        # Consider 1D arrays or single elements if they could occur (width 1)\n        elif subgrid is not None and subgrid.size > 0:\n             max_width = max(max_width, 1) # Width is 1 for a 1D array or single element\n\n    # If max_width remains 0 (e.g., all objects were empty?), return empty\n    if max_width == 0:\n        return []\n\n    # --- Step 4: Pad each extracted subgrid to the determined maximum width ---\n    # The order of subgrids matches the sorted order of objects found earlier.\n    padded_subgrids = []\n    for subgrid in extracted_subgrids:\n         # Ensure subgrid is valid before padding\n         if subgrid is not None and subgrid.size > 0:\n            padded = _pad_subgrid(subgrid, max_width, background_color)\n            padded_subgrids.append(padded)\n\n    # --- Step 5: Concatenate padded subgrids vertically to form the output grid ---\n    if not padded_subgrids:\n        return [] # No valid subgrids to stack\n\n    # Use numpy's vstack for vertical concatenation\n    output_np = np.vstack(padded_subgrids)\n\n    # --- Step 6: Convert the final numpy array back to a list of lists ---\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3680,
    "candidates_token_count": 7516,
    "total_token_count": 11196,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 57.943309,
  "retries": 1
}