
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 6 6 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 5 0 0 0 0 5 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 0 0 0 0 0 3 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
6 6 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 6 6 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 0 0 4 0 4 0 0 4 0 0 0
0 0 0 0 0 0 0 0 4 4 4 4 0 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 6 6 0 0 0 6 6 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 1 1 0 0 0 0 0 6 6 0 0 0 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0
0 0 0 1 1 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 3 1 1 0 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 1 0 0 1 0
0 0 0 0 0 0 1 1 0 0
0 0 0 0 0 0 0 0 0 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 4 4 4 4 0
0 1 0 0 1 4 0 0 4 0
0 1 0 0 1 4 0 0 4 0
0 0 1 1 0 4 4 4 4 0
0 4 4 4 4 0 1 1 0 0
0 4 0 0 4 1 0 0 1 0
0 4 0 0 4 1 0 0 1 0
0 4 4 4 4 0 1 1 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
4 4 4 4 0 0 2 0 0 0
4 0 0 4 0 0 0 0 0 0
4 0 0 4 0 0 0 0 0 0
4 4 4 4 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 0 0 4
0 0 0 0 0 0 4 4 4 4
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
4 4 4 4 0 0 4 4 4 4
4 0 0 4 0 0 4 0 0 4
4 0 0 4 0 0 4 0 0 4
4 4 4 4 0 0 4 4 4 4
```

**Perception**

The core transformation logic involves identifying specific types of objects or pixels in the input grid and applying distinct rules based on their color and shape.

1.  **Pixel-to-Shape Transformation:** Single pixels of specific colors (red and green) expand into larger, hollow square shapes of different colors (yellow and blue, respectively). This transformation is conditional on the resulting shape fitting entirely within the grid boundaries.
2.  **Object Manipulation:** Certain predefined objects undergo specific transformations: 2x2 magenta squares are shifted diagonally up-left, while 4x4 hollow blue squares are copied directly to the output in the same position.
3.  **Filtering/Removal:** Any input pixel or object that does not match the criteria for transformation (Cases 1 & 2) is effectively removed, resulting in white (0) pixels in the corresponding output locations. This includes single pixels of colors other than red or green (e.g., gray), single red/green pixels whose expanded shape would go out of bounds, and larger objects of colors/shapes not explicitly handled (e.g., the 4x4 hollow yellow square in `train_3`).
4.  **Output Construction:** The output grid is built by applying these transformations and copying/shifting rules onto an initially white grid. The transformations from different input elements can potentially overlap in the output grid. The order of application doesn't seem to matter based on the examples, as the transformed/copied objects don't overlap destructively.

**Facts**


```yaml
task_context:
  grid_size: variable, input and output grids have the same dimensions.
  colors_used_input: [white(0), blue(1), red(2), green(3), yellow(4), gray(5), magenta(6)]
  colors_used_output: [white(0), blue(1), yellow(4), magenta(6)] # Note: Gray(5), Red(2), Green(3) disappear or transform
objects:
  - type: single_pixel
    properties:
      - color: red(2)
      - location: (r, c)
    actions:
      - condition: A 4x4 square anchored at (r, c) fits within grid boundaries.
      - transformation: Replace with a 4x4 hollow square of yellow(4) anchored at (r, c) in the output.
      - else: Remove (becomes white(0)).
  - type: single_pixel
    properties:
      - color: green(3)
      - location: (r, c)
    actions:
      - condition: A 4x4 square anchored at (r, c) fits within grid boundaries.
      - transformation: Replace with a 4x4 hollow square of blue(1) anchored at (r, c) in the output.
      - else: Remove (becomes white(0)).
  - type: single_pixel
    properties:
      - color: any color other than red(2) or green(3) (e.g., gray(5))
    actions:
      - transformation: Remove (becomes white(0)).
  - type: square_2x2
    properties:
      - color: magenta(6)
      - top_left_corner: (r, c)
    actions:
      - condition: r > 0 and c > 0
      - transformation: Draw a 2x2 magenta(6) square anchored at (r-1, c-1) in the output.
      - else: Remove? (Although not seen in examples, assume removal if shift goes out of bounds).
  - type: hollow_square_4x4
    properties:
      - color: blue(1)
      - top_left_corner: (r, c)
    actions:
      - transformation: Draw a 4x4 hollow blue(1) square anchored at (r, c) in the output.
  - type: any_other_object # e.g., hollow_square_4x4 of yellow(4)
    properties:
      - shape: not a single pixel, not 2x2 magenta, not 4x4 hollow blue
    actions:
      - transformation: Remove (becomes white(0)).
relationships:
  - Transformation depends on both the color and shape/size of the input object/pixel.
  - Positional constraints (fitting within bounds, specific shifts) are crucial.
  - Input objects that don't meet specific criteria are discarded.
```


**Natural Language Program**

1.  Create a new output grid with the same dimensions as the input grid, initialized with all white (0) pixels.
2.  Identify all distinct objects (contiguous blocks of the same non-white color) in the input grid.
3.  For each identified object:
    a.  **Check for Single Red Pixel:** If the object consists of a single pixel of red (2) located at `(row, col)`:
        i.  Determine if a 4x4 square starting at `(row, col)` would fit entirely within the grid boundaries (i.e., `row + 3 < grid_height` and `col + 3 < grid_width`).
        ii. If it fits, draw a 4x4 hollow square using yellow (4) onto the output grid, with its top-left corner at `(row, col)`.
    b.  **Check for Single Green Pixel:** If the object consists of a single pixel of green (3) located at `(row, col)`:
        i.  Determine if a 4x4 square starting at `(row, col)` would fit entirely within the grid boundaries.
        ii. If it fits, draw a 4x4 hollow square using blue (1) onto the output grid, with its top-left corner at `(row, col)`.
    c.  **Check for 2x2 Magenta Square:** If the object is a 2x2 square of magenta (6) with its top-left corner at `(row, col)`:
        i.  Determine if the target top-left position `(row-1, col-1)` is valid (i.e., `row > 0` and `col > 0`).
        ii. If valid, draw a 2x2 square of magenta (6) onto the output grid, with its top-left corner at `(row-1, col-1)`.
    d.  **Check for 4x4 Hollow Blue Square:** If the object is a 4x4 hollow square of blue (1) with its top-left corner at `(row, col)`:
        i.  Draw a 4x4 hollow square of blue (1) onto the output grid, with its top-left corner at `(row, col)`.
    e.  **Ignore Other Objects:** If the object does not match any of the conditions in steps 3a, 3b, 3c, or 3d, do nothing with it (it effectively gets removed as the output grid started white).
4.  Return the final output grid.
```python
import numpy as np

"""
The transformation rule identifies specific patterns or pixels in the input grid and applies transformations to generate the output grid.

1.  **Initialization:** Create an output grid of the same dimensions as the input, filled with white (0).
2.  **Pattern Detection and Transformation:** Iterate through the input grid to find specific patterns or pixels and apply corresponding rules:
    *   **Single Red Pixel (2):** If a red pixel is found at (r, c), check if a 4x4 area starting at (r, c) fits within the grid. If yes, draw a 4x4 hollow square of yellow (4) at (r, c) on the output grid.
    *   **Single Green Pixel (3):** If a green pixel is found at (r, c), check if a 4x4 area starting at (r, c) fits within the grid. If yes, draw a 4x4 hollow square of blue (1) at (r, c) on the output grid.
    *   **2x2 Magenta Square (6):** If a 2x2 solid square of magenta is found with its top-left corner at (r, c), check if it can be shifted up-left (i.e., r > 0 and c > 0). If yes, draw a 2x2 solid square of magenta (6) at (r-1, c-1) on the output grid.
    *   **4x4 Hollow Blue Square (1):** If a 4x4 hollow square of blue is found with its top-left corner at (r, c), draw an identical 4x4 hollow square of blue (1) at (r, c) on the output grid.
3.  **Default:** Any input pixels or patterns not matching the above rules are ignored, leaving the corresponding output pixels as white (0).
4.  **Overlapping:** Transformations are drawn onto the output grid. If transformations overlap, the later drawing operations overwrite earlier ones (though the specific order of pattern checks here aims to avoid problematic overlaps based on examples).
"""

def draw_hollow_square(grid, r, c, size, color):
    """Draws the perimeter of a square on the grid."""
    height, width = grid.shape
    # Ensure drawing stays within bounds (although bounds are checked before calling)
    if r + size <= height and c + size <= width:
        # Top row
        grid[r, c:c+size] = color
        # Bottom row
        grid[r+size-1, c:c+size] = color
        # Left column (excluding corners)
        grid[r+1:r+size-1, c] = color
        # Right column (excluding corners)
        grid[r+1:r+size-1, c+size-1] = color

def draw_solid_square(grid, r, c, size, color):
    """Draws a filled square on the grid."""
    height, width = grid.shape
     # Ensure drawing stays within bounds
    if r >= 0 and c >= 0 and r + size <= height and c + size <= width:
        grid[r:r+size, c:c+size] = color

def is_hollow_square(grid, r, c, size, color):
    """Checks if a hollow square of given size and color exists at (r, c)."""
    height, width = grid.shape
    # Check bounds for the square itself
    if r + size > height or c + size > width:
        return False
    
    # Check top row
    if not np.all(grid[r, c:c+size] == color):
        return False
    # Check bottom row
    if not np.all(grid[r+size-1, c:c+size] == color):
        return False
    # Check left column (excluding corners)
    if size > 1 and not np.all(grid[r+1:r+size-1, c] == color):
        return False
    # Check right column (excluding corners)
    if size > 1 and not np.all(grid[r+1:r+size-1, c+size-1] == color):
        return False
    # Check interior (should be white=0)
    if size > 2 and not np.all(grid[r+1:r+size-1, c+1:c+size-1] == 0):
        return False
        
    return True

def is_solid_square(grid, r, c, size, color):
    """Checks if a solid square of given size and color exists at (r, c)."""
    height, width = grid.shape
    if r + size > height or c + size > width:
        return False
    return np.all(grid[r:r+size, c:c+size] == color)


def transform(input_grid):
    """
    Applies the transformation rules to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_np = np.zeros_like(input_np)

    # Iterate through each cell as a potential top-left corner or single pixel location
    for r in range(height):
        for c in range(width):
            
            # Rule: Check for 4x4 Hollow Blue Square (1)
            # We check this first as it's a larger specific pattern
            if input_np[r, c] == 1 and is_hollow_square(input_np, r, c, 4, 1):
                # Draw the same square in the output
                draw_hollow_square(output_np, r, c, 4, 1)
                # Potentially mark checked cells to avoid re-processing?
                # For now, rely on the fact that checks are specific enough.

            # Rule: Check for 2x2 Magenta Square (6)
            elif input_np[r, c] == 6 and is_solid_square(input_np, r, c, 2, 6):
                 # Check if the shifted position is valid
                if r > 0 and c > 0:
                    # Draw the shifted square in the output
                    draw_solid_square(output_np, r-1, c-1, 2, 6)

            # Rule: Check for Single Red Pixel (2)
            elif input_np[r, c] == 2:
                # Check if a 4x4 expansion fits within bounds
                if r + 3 < height and c + 3 < width:
                    # Draw 4x4 hollow yellow square
                    draw_hollow_square(output_np, r, c, 4, 4) # 4 is yellow

            # Rule: Check for Single Green Pixel (3)
            elif input_np[r, c] == 3:
                 # Check if a 4x4 expansion fits within bounds
                if r + 3 < height and c + 3 < width:
                     # Draw 4x4 hollow blue square
                    draw_hollow_square(output_np, r, c, 4, 1) # 1 is blue

            # Other pixels/patterns are implicitly ignored as output starts white

    return output_np.tolist()

```
