{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by filling areas within distinct vertical regions. \nRegions are defined by vertical magenta (6) lines or grid edges.\nWithin each region, find connected components (8-way adjacency) of orange (7) and red (2) pixels.\nIf a component contains at least one red (2) pixel, change all orange (7) pixels in that component to magenta (6).\nMagenta (6) pixels act as impassable barriers for connectivity, both the region dividers and potentially others.\n\"\"\"\n\ndef find_regions(input_grid, boundary_color):\n    \"\"\"\n    Identifies vertical regions separated by columns containing the boundary color.\n\n    Args:\n        input_grid (np.array): The input grid.\n        boundary_color (int): The color value acting as a vertical boundary.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a region\n              as (start_col, end_col) inclusive.\n    \"\"\"\n    height, width = input_grid.shape\n    boundary_cols = np.where(np.any(input_grid == boundary_color, axis=0))[0]\n    boundary_cols = sorted(list(set(boundary_cols))) # Get unique sorted indices\n\n    regions = []\n    start_col = 0\n    for b_col in boundary_cols:\n        # Add region before the boundary column, if it's valid\n        if start_col < b_col:\n            regions.append((start_col, b_col - 1))\n        # Next region starts after the boundary column\n        start_col = b_col + 1\n        \n    # Add the last region after the final boundary column (or the whole grid if no boundaries)\n    if start_col < width:\n        regions.append((start_col, width - 1))\n        \n    # Handle case where grid is empty or only boundary columns exist\n    if not regions and width > 0 and not boundary_cols:\n         regions.append((0, width - 1))\n    elif not regions and width > 0 and len(boundary_cols) == width:\n         # Grid is entirely boundary columns, no processable regions\n         pass\n\n\n    return regions\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the region-based connected component fill transformation.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Define colors\n    orange = 7\n    red = 2\n    magenta = 6\n    boundary_color = magenta # Magenta defines regions\n\n    # Get grid dimensions\n    height, width = input_grid.shape\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Keep track of visited cells globally across all regions\n    visited = np.zeros((height, width), dtype=bool)\n\n    # 1. Identify Regions\n    regions = find_regions(input_grid, boundary_color)\n\n    # 2. Process Each Region\n    for start_col, end_col in regions:\n        # Iterate through each cell within the current region\n        for r in range(height):\n            for c in range(start_col, end_col + 1):\n                # 3. Start Component Search within Region if applicable\n                # Check if cell is orange or red AND not visited\n                if not visited[r, c] and (input_grid[r, c] == orange or input_grid[r, c] == red):\n                    \n                    # Initialize for BFS\n                    component_pixels = []  # Store coordinates (r, c) of cells in this component\n                    found_source = False   # Flag: does this component contain a red pixel?\n                    queue = deque([(r, c)]) # BFS queue\n                    \n                    # Mark starting cell as visited\n                    visited[r, c] = True\n\n                    # Perform BFS\n                    while queue:\n                        curr_r, curr_c = queue.popleft()\n                        \n                        # Add to current component list\n                        component_pixels.append((curr_r, curr_c))\n                        \n                        # Check if it's a source color\n                        if input_grid[curr_r, curr_c] == red:\n                            found_source = True\n                            \n                        # Explore 8-way neighbors\n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                if dr == 0 and dc == 0:\n                                    continue # Skip self\n                                    \n                                nr, nc = curr_r + dr, curr_c + dc\n                                \n                                # Check neighbor validity for BFS expansion:\n                                # - Within grid bounds?\n                                # - Within current region's column bounds?\n                                # - Not visited yet?\n                                # - Not a boundary/blocking color (magenta)?\n                                # - Is an orange or red cell (part of potential component)?\n                                if (0 <= nr < height and \n                                    start_col <= nc <= end_col and # Check region bounds\n                                    not visited[nr, nc] and\n                                    input_grid[nr, nc] != magenta and \n                                    (input_grid[nr, nc] == orange or input_grid[nr, nc] == red)):\n                                    \n                                    visited[nr, nc] = True\n                                    queue.append((nr, nc))\n\n                    # 4. Conditional Fill within Region\n                    # After BFS for this component is done, check if a source was found\n                    if found_source:\n                        # If yes, change all orange pixels in this component to magenta\n                        for comp_r, comp_c in component_pixels:\n                            if input_grid[comp_r, comp_c] == orange:\n                                output_grid[comp_r, comp_c] = magenta\n                                \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16077,
    "candidates_token_count": 1366,
    "total_token_count": 17443,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.258373,
  "retries": 1
}