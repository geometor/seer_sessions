
## train_1

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 7 7 7 7 7 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 2 2 2 2 2 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 6 6 6 6 6 7 7 7 6 6 6 6
7 7 6 2 2 2 6 7 7 7 6 2 2 2
6 6 6 6 6 6 6 7 7 7 6 7 7 7
2 2 2 2 2 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 6 6 6 6 6 6 6
7 7 7 7 7 6 6 2 2 2 2 2 2 2
7 6 6 6 6 6 6 6 7 7 7 7 7 7
7 6 2 2 2 2 2 6 7 7 7 7 7 7
7 6 7 7 6 6 6 6 6 6 6 6 7 7
7 6 7 7 6 2 2 2 2 2 2 6 7 7
7 6 7 7 6 7 7 7 7 7 7 6 7 7
```


## train_2

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 2 2 2 2 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 6 6 6 6 7
7 7 7 7 6 7 7 7 6 2 2 2 2
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
6 6 6 6 6 6 7 7 6 7 7 7 7
6 2 2 2 2 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 6 6 6 6 6 6 7 7 7 7
6 7 7 6 2 2 2 2 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
```


## train_3

**input:**
```
7 7 6 7 7 7 7 2 2
7 7 6 7 7 7 7 2 7
7 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 7 7 7
```


**output:**
```
7 7 6 7 7 7 7 2 2
6 6 6 6 6 7 7 2 7
6 2 2 2 6 7 7 7 7
6 7 7 7 6 7 7 7 7
6 7 6 6 6 6 6 6 7
6 7 6 2 2 2 2 6 7
6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 6 6 7
```


## train_4

**input:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 7 7
7 7 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
2 2 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
```


**output:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 6 7
7 7 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
7 6 7 7 7
7 6 7 7 7
6 6 6 6 7
2 2 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
```


## train_5

**input:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 7 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6 6
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 6 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 6 6 6 6 6 6 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7 6 7
```


## train_6

**input:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2 2 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 7 7 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
7 7 7 6 6 6 6 6 6 6 6 6 6 6 7 7
7 7 7 6 2 2 2 2 2 2 2 2 2 6 7 7
7 7 7 6 7 7 7 7 7 7 7 7 7 6 7 7
6 6 6 6 6 6 6 6 6 6 6 7 7 6 7 7
2 2 2 2 2 2 2 2 2 2 6 7 7 6 7 7
7 7 7 7 7 7 7 7 7 7 6 7 7 6 7 7
7 7 7 7 7 7 6 6 6 6 6 6 6 6 6 6
7 7 7 7 7 7 6 2 2 2 2 2 2 2 2 6
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 6
7 7 7 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 7 6 2 2 2 2 2 2 2 2 2 2 6 6
7 7 7 6 7 7 7 7 7 7 7 7 7 7 6 6
```

*   **Perception:** The task involves transforming an input grid containing orange (7), red (2), and magenta (6) pixels into an output grid. The orange pixels form the background. Vertical magenta lines act as fixed dividers. Red pixels appear as distinct objects within the regions defined by the magenta lines or grid edges. The transformation involves changing some orange pixels to magenta. The change seems related to the proximity or connectivity of orange pixels to red pixels within the regions bounded by the existing magenta lines.

*   **YAML Facts:**
    
```yaml
    task_description: Fill regions based on connectivity to source objects.
    elements:
      - type: background
        color: orange (7)
        role: Fillable area
      - type: boundary
        color: magenta (6)
        shape: Vertical lines
        role: Fixed barriers dividing the grid into regions. Cannot be crossed by the fill.
      - type: source
        color: red (2)
        shape: Irregular, often rectangular blocks
        role: Initiates the fill process within a region. Remains unchanged.
      - type: fill_target
        color: orange (7)
        role: Pixels eligible to be filled.
      - type: fill_color
        color: magenta (6)
        role: The color used to fill target pixels.
    regions:
      definition: Areas separated by boundary (magenta) lines or grid edges.
      scope: Fill operations are contained within these regions.
    transformation:
      type: Conditional Fill / Connected Components Coloring
      input_elements: background (orange), boundary (magenta), source (red)
      output_elements: background (orange), boundary (magenta), source (red), filled_area (magenta)
      rule: Identify connected components consisting of source (red) and target (orange) pixels, using 8-way adjacency (including diagonals). Components are bounded by boundary (magenta) pixels. If a component contains at least one source (red) pixel, change all target (orange) pixels within that component to the fill color (magenta).
    relationships:
      - relation: connectivity
        elements: [source (red), target (orange)]
        constraints: Must be within the same region (not crossing boundary). Uses 8-way adjacency.
      - relation: boundary_constraint
        elements: [boundary (magenta)]
        effect: Blocks fill propagation. Defines regions.
    invariants:
      - Original boundary (magenta) pixels remain unchanged.
      - Original source (red) pixels remain unchanged.
      - Orange pixels not connected (via orange/red paths) to a red source within their region remain unchanged.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as an identical copy of the input grid.
    2.  Identify the locations of all "boundary" pixels (magenta, 6) and "source" pixels (red, 2).
    3.  Find all connected components formed by "source" (red, 2) and "target" (orange, 7) pixels. Connectivity is defined by 8-way adjacency (including diagonals). Components cannot cross "boundary" (magenta, 6) pixels.
    4.  Iterate through each identified connected component.
    5.  For a given component, check if it contains at least one "source" (red, 2) pixel.
    6.  If the component contains a "source" pixel, iterate through all pixels within that component.
    7.  For each pixel in the component, if its original color was "target" (orange, 7), change its color in the output grid to the "fill" color (magenta, 6).
    8.  Return the final output grid.
```python
import numpy as np
from collections import deque

"""
Identifies connected components consisting of source (red, 2) and target (orange, 7) pixels, using 8-way adjacency (including diagonals). 
Components are bounded by boundary (magenta, 6) pixels. 
If a component contains at least one source (red, 2) pixel, change all target (orange, 7) pixels within that component to the fill color (magenta, 6).
"""

def transform(input_grid):
    """
    Transforms the input grid based on connected components and source pixels.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Define colors
    orange = 7
    red = 2
    magenta = 6
    
    # Get grid dimensions
    height, width = input_grid.shape
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    
    # Keep track of visited cells to avoid processing the same component multiple times
    visited = np.zeros((height, width), dtype=bool)

    # Iterate through each cell in the grid
    for r in range(height):
        for c in range(width):
            # Start a search if we find an unvisited orange or red cell
            if not visited[r, c] and (input_grid[r, c] == orange or input_grid[r, c] == red):
                
                # Initialize structures for Breadth-First Search (BFS)
                component_pixels = []  # Store coordinates of cells in the current component
                found_source = False  # Flag to track if a red source is found in the component
                queue = deque([(r, c)]) # Queue for BFS
                
                # Mark the starting cell as visited
                visited[r, c] = True

                # Perform BFS to find the connected component
                while queue:
                    curr_r, curr_c = queue.popleft()
                    
                    # Add current cell to the component list
                    component_pixels.append((curr_r, curr_c))
                    
                    # Check if the current cell is a red source
                    if input_grid[curr_r, curr_c] == red:
                        found_source = True
                        
                    # Explore 8-way neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue # Skip the cell itself
                                
                            nr, nc = curr_r + dr, curr_c + dc
                            
                            # Check if neighbor is within grid bounds
                            if 0 <= nr < height and 0 <= nc < width:
                                # Check if neighbor is not visited and is not a boundary (magenta)
                                if not visited[nr, nc] and input_grid[nr, nc] != magenta:
                                     # Check if neighbor is part of the component (orange or red)
                                     if input_grid[nr, nc] == orange or input_grid[nr, nc] == red:
                                        visited[nr, nc] = True
                                        queue.append((nr, nc))

                # After exploring the entire component, check if a red source was found
                if found_source:
                    # If a source was found, change all orange cells in this component to magenta
                    for comp_r, comp_c in component_pixels:
                        if input_grid[comp_r, comp_c] == orange:
                            output_grid[comp_r, comp_c] = magenta
                            
    return output_grid
```
```python
import numpy as np
from collections import deque

"""
Transforms the input grid by filling areas within distinct vertical regions. 
Regions are defined by vertical magenta (6) lines or grid edges.
Within each region, find connected components (8-way adjacency) of orange (7) and red (2) pixels.
If a component contains at least one red (2) pixel, change all orange (7) pixels in that component to magenta (6).
Magenta (6) pixels act as impassable barriers for connectivity, both the region dividers and potentially others.
"""

def find_regions(input_grid, boundary_color):
    """
    Identifies vertical regions separated by columns containing the boundary color.

    Args:
        input_grid (np.array): The input grid.
        boundary_color (int): The color value acting as a vertical boundary.

    Returns:
        list: A list of tuples, where each tuple represents a region
              as (start_col, end_col) inclusive.
    """
    height, width = input_grid.shape
    boundary_cols = np.where(np.any(input_grid == boundary_color, axis=0))[0]
    boundary_cols = sorted(list(set(boundary_cols))) # Get unique sorted indices

    regions = []
    start_col = 0
    for b_col in boundary_cols:
        # Add region before the boundary column, if it's valid
        if start_col < b_col:
            regions.append((start_col, b_col - 1))
        # Next region starts after the boundary column
        start_col = b_col + 1
        
    # Add the last region after the final boundary column (or the whole grid if no boundaries)
    if start_col < width:
        regions.append((start_col, width - 1))
        
    # Handle case where grid is empty or only boundary columns exist
    if not regions and width > 0 and not boundary_cols:
         regions.append((0, width - 1))
    elif not regions and width > 0 and len(boundary_cols) == width:
         # Grid is entirely boundary columns, no processable regions
         pass


    return regions

def transform(input_grid):
    """
    Applies the region-based connected component fill transformation.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Define colors
    orange = 7
    red = 2
    magenta = 6
    boundary_color = magenta # Magenta defines regions

    # Get grid dimensions
    height, width = input_grid.shape
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    
    # Keep track of visited cells globally across all regions
    visited = np.zeros((height, width), dtype=bool)

    # 1. Identify Regions
    regions = find_regions(input_grid, boundary_color)

    # 2. Process Each Region
    for start_col, end_col in regions:
        # Iterate through each cell within the current region
        for r in range(height):
            for c in range(start_col, end_col + 1):
                # 3. Start Component Search within Region if applicable
                # Check if cell is orange or red AND not visited
                if not visited[r, c] and (input_grid[r, c] == orange or input_grid[r, c] == red):
                    
                    # Initialize for BFS
                    component_pixels = []  # Store coordinates (r, c) of cells in this component
                    found_source = False   # Flag: does this component contain a red pixel?
                    queue = deque([(r, c)]) # BFS queue
                    
                    # Mark starting cell as visited
                    visited[r, c] = True

                    # Perform BFS
                    while queue:
                        curr_r, curr_c = queue.popleft()
                        
                        # Add to current component list
                        component_pixels.append((curr_r, curr_c))
                        
                        # Check if it's a source color
                        if input_grid[curr_r, curr_c] == red:
                            found_source = True
                            
                        # Explore 8-way neighbors
                        for dr in [-1, 0, 1]:
                            for dc in [-1, 0, 1]:
                                if dr == 0 and dc == 0:
                                    continue # Skip self
                                    
                                nr, nc = curr_r + dr, curr_c + dc
                                
                                # Check neighbor validity for BFS expansion:
                                # - Within grid bounds?
                                # - Within current region's column bounds?
                                # - Not visited yet?
                                # - Not a boundary/blocking color (magenta)?
                                # - Is an orange or red cell (part of potential component)?
                                if (0 <= nr < height and 
                                    start_col <= nc <= end_col and # Check region bounds
                                    not visited[nr, nc] and
                                    input_grid[nr, nc] != magenta and 
                                    (input_grid[nr, nc] == orange or input_grid[nr, nc] == red)):
                                    
                                    visited[nr, nc] = True
                                    queue.append((nr, nc))

                    # 4. Conditional Fill within Region
                    # After BFS for this component is done, check if a source was found
                    if found_source:
                        # If yes, change all orange pixels in this component to magenta
                        for comp_r, comp_c in component_pixels:
                            if input_grid[comp_r, comp_c] == orange:
                                output_grid[comp_r, comp_c] = magenta
                                
    return output_grid
```
```python
"""
Transforms the input grid by filling connected areas of orange pixels (7) with magenta (6) 
if the area is connected (8-way adjacency) to a red pixel (2). Existing magenta pixels (6) 
act as impassable barriers, blocking connectivity. Original red pixels and original magenta 
pixels remain unchanged.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Applies the conditional connected components fill transformation.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the transformed output grid.
    """
    # Define colors
    orange = 7
    red = 2
    magenta = 6
    
    # Get grid dimensions
    height, width = input_grid.shape
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    
    # Keep track of visited cells to avoid processing the same component multiple times
    visited = np.zeros((height, width), dtype=bool)

    # Iterate through each cell in the grid
    for r in range(height):
        for c in range(width):
            # Start a search if we find an unvisited orange or red cell (potential component start)
            # Also ensure the cell itself is not a magenta barrier
            if not visited[r, c] and (input_grid[r, c] == orange or input_grid[r, c] == red):
                
                # Initialize structures for Breadth-First Search (BFS)
                component_pixels = []  # Store coordinates of cells in the current component
                found_source = False  # Flag to track if a red source is found in the component
                queue = deque([(r, c)]) # Queue for BFS
                
                # Mark the starting cell as visited immediately
                visited[r, c] = True

                # Perform BFS to find the connected component
                while queue:
                    curr_r, curr_c = queue.popleft()
                    
                    # Add current cell to the component list
                    component_pixels.append((curr_r, curr_c))
                    
                    # Check if the current cell is a red source
                    if input_grid[curr_r, curr_c] == red:
                        found_source = True
                        
                    # Explore 8-way neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            # Skip the cell itself
                            if dr == 0 and dc == 0:
                                continue 
                                
                            nr, nc = curr_r + dr, curr_c + dc
                            
                            # Check neighbor validity:
                            # 1. Within grid bounds?
                            if 0 <= nr < height and 0 <= nc < width:
                                # 2. Not visited yet?
                                if not visited[nr, nc]:
                                    # 3. Not a barrier (magenta)?
                                    if input_grid[nr, nc] != magenta:
                                        # 4. Part of the potential component (orange or red)? 
                                        #    (This is implicitly handled by checking it's not magenta,
                                        #     as those are the only other possibilities besides orange/red
                                        #     that we start the BFS from). We could explicitly check:
                                        #     if input_grid[nr, nc] == orange or input_grid[nr, nc] == red:
                                        # But simply checking it's not magenta is sufficient here.
                                        
                                        # Mark valid neighbor as visited and add to queue
                                        visited[nr, nc] = True
                                        queue.append((nr, nc))

                # After exploring the entire component, check if a red source was found within it
                if found_source:
                    # If a source was found, change all orange cells *in this component* to magenta
                    for comp_r, comp_c in component_pixels:
                        # Check the original color in the input grid
                        if input_grid[comp_r, comp_c] == orange:
                            output_grid[comp_r, comp_c] = magenta
                            
    # Return the modified grid
    return output_grid
```
