
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

Okay, let's analyze the task examples.

**Perception of the Elements:**

1.  **Colors:** The primary colors involved in the transformation are Red (2), White (0), and Blue (1). Green (3) acts as a background or neutral color, remaining unchanged in all examples.
2.  **Objects:** The transformation seems to focus on contiguous blocks (objects) of Red, White, and Blue pixels. These objects vary in size (1x1, 2x2, 3x3) across examples.
3.  **Transformation Type:** The core operation is a pixel-wise color change applied to Red, White, and/or Blue pixels. The specific changes depend on a condition related to the input grid's composition.
4.  **Conditional Logic:** There appear to be two distinct transformation rules. The rule applied depends on the number of distinct objects of each color (Red, White, Blue) present in the input.
    *   In examples 2 and 3, there is exactly one distinct object of Red, one of White, and one of Blue. In these cases, White pixels become Blue, and Blue pixels become White, while Red pixels remain unchanged.
    *   In examples 1 and 4, the condition of having exactly one object of each color (Red, White, Blue) is *not* met (specifically, there isn't one distinct Blue object separate from other blue structures). In these cases, Red pixels become White, White pixels become Blue, and Blue pixels remain unchanged.

**YAML Fact Documentation:**


```yaml
Task: Conditional Color Transformation

Input_Features:
  - Grid: 2D array of pixels (0-9).
  - Colors:
      - Active: Red (2), White (0), Blue (1)
      - Background: Green (3) (and potentially others, though only Green appears here)
  - Objects: Contiguous blocks of a single active color (Red, White, or Blue).
  - Object_Counts: The number of distinct, isolated objects found for each active color.

Output_Features:
  - Grid: Transformed 2D array of pixels.

Transformation:
  - Type: Pixel-wise color substitution based on a global condition.
  - Condition: Check if the number of distinct Red objects = 1 AND the number of distinct White objects = 1 AND the number of distinct Blue objects = 1.
  - Rules:
      - If Condition is True:
          - Red (2) -> Red (2)
          - White (0) -> Blue (1)
          - Blue (1) -> White (0)
          - Other_Colors -> Other_Colors (e.g., Green (3) -> Green (3))
      - If Condition is False:
          - Red (2) -> White (0)
          - White (0) -> Blue (1)
          - Blue (1) -> Blue (1)
          - Other_Colors -> Other_Colors (e.g., Green (3) -> Green (3))
  - Scope: Applies to all pixels in the grid.
```


**Natural Language Program:**

1.  Analyze the input grid to identify all distinct, contiguous objects composed solely of Red (2), White (0), or Blue (1) pixels. Consider Green (3) pixels as background or separators.
2.  Count the number of these distinct objects for each color: `num_red_objects`, `num_white_objects`, `num_blue_objects`.
3.  Evaluate the condition: `is_condition_met = (num_red_objects == 1) AND (num_white_objects == 1) AND (num_blue_objects == 1)`.
4.  Create a new output grid, initially identical to the input grid.
5.  Iterate through each pixel `(row, col)` of the input grid:
    a.  Get the `input_color` at `(row, col)`.
    b.  If `is_condition_met` is True:
        i.  If `input_color` is White (0), set the output grid pixel at `(row, col)` to Blue (1).
        ii. If `input_color` is Blue (1), set the output grid pixel at `(row, col)` to White (0).
        iii. If `input_color` is Red (2) or any other color, keep the color unchanged in the output grid.
    c.  If `is_condition_met` is False:
        i.  If `input_color` is Red (2), set the output grid pixel at `(row, col)` to White (0).
        ii. If `input_color` is White (0), set the output grid pixel at `(row, col)` to Blue (1).
        iii. If `input_color` is Blue (1) or any other color, keep the color unchanged in the output grid.
6.  Return the completed output grid.
```python
import numpy as np
from scipy.ndimage import label, generate_binary_structure

"""
This transformation operates based on the number of distinct, contiguous objects 
of Red (2), White (0), and Blue (1) colors found in the input grid. 
Green (3) is treated as a background/separator color.

1. Identify and count the number of distinct objects for Red, White, and Blue.
2. Check if there is exactly one object of each color (Red=1, White=1, Blue=1).
3. If the condition (one of each) is TRUE:
    - Change all White pixels (0) to Blue (1).
    - Change all Blue pixels (1) to White (0).
    - Keep Red pixels (2) and all other colors unchanged.
4. If the condition is FALSE:
    - Change all Red pixels (2) to White (0).
    - Change all White pixels (0) to Blue (1).
    - Keep Blue pixels (1) and all other colors unchanged.
"""

def find_objects(grid, color):
    """
    Finds and counts the number of distinct contiguous objects of a specific color.
    
    Args:
        grid (np.array): The input grid.
        color (int): The color value to find objects for.
        
    Returns:
        int: The number of distinct objects of the specified color.
    """
    # Create a binary mask where True indicates the target color
    mask = (grid == color)
    # Define connectivity (8-connectivity allows diagonal connections)
    structure = generate_binary_structure(2, 2) 
    # Label connected components in the mask
    labeled_array, num_features = label(mask, structure=structure)
    # Return the count of distinct objects found
    return num_features

def transform(input_grid):
    """
    Applies a conditional color transformation based on the counts of Red, White, 
    and Blue objects in the input grid.

    Args:
        input_grid (list[list[int]]): A 2D list representing the input grid.

    Returns:
        list[list[int]]: A 2D list representing the transformed output grid.
    """
    # Convert input list of lists to a NumPy array for efficient processing
    input_np = np.array(input_grid, dtype=int)
    
    # Count the number of distinct objects for Red, White, and Blue
    num_red_objects = find_objects(input_np, 2) # Red color = 2
    num_white_objects = find_objects(input_np, 0) # White color = 0
    num_blue_objects = find_objects(input_np, 1) # Blue color = 1
    
    # Check if the condition (exactly one object of each color) is met
    is_condition_met = (num_red_objects == 1 and 
                        num_white_objects == 1 and 
                        num_blue_objects == 1)
                        
    # Create a copy of the input grid to modify for the output
    output_grid = np.copy(input_np)
    
    # Apply the transformation rules based on the condition
    if is_condition_met:
        # Condition is TRUE: White -> Blue, Blue -> White
        # Find pixels that are White (0) in the input
        white_pixels = (input_np == 0)
        # Find pixels that are Blue (1) in the input
        blue_pixels = (input_np == 1)
        
        # Change White pixels to Blue in the output grid
        output_grid[white_pixels] = 1 
        # Change Blue pixels to White in the output grid
        output_grid[blue_pixels] = 0 
        # Red and other colors remain unchanged as they were copied initially
    else:
        # Condition is FALSE: Red -> White, White -> Blue
        # Find pixels that are Red (2) in the input
        red_pixels = (input_np == 2)
        # Find pixels that are White (0) in the input
        white_pixels = (input_np == 0)
        
        # Change Red pixels to White in the output grid
        output_grid[red_pixels] = 0
        # Change White pixels to Blue in the output grid
        output_grid[white_pixels] = 1
        # Blue and other colors remain unchanged as they were copied initially
        
    # Convert the final NumPy array back to a list of lists for the output
    return output_grid.tolist()
```
