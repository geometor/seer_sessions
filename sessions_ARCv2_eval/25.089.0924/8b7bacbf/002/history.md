
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 0 0 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 0 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 0 0 0 0 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 0 0 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 3 0 0 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 0 0 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 5 7 7 5 0
2 0 0 2 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 1 5 5 1 0
0 2 2 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 1 0 0 0 1 0
0 0 0 0 1 1 1 1 1 2 2 1 0 0 0 0 2 7 2 2 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 7 7 7 7 2 0 1 0
0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 2 7 7 2 2 0 1 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 1 0
0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 0 2 2 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 3 7 7 3 0 0 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 0 0 1 3 3 1 1 1 2 7 7 2 0 0 0 0 0 0 1 0
0 0 0 1 1 1 0 0 0 0 0 2 7 7 7 2 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 2 7 7 2 0 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 2 0 0 2 2 0 0 2 0 0 2 2 0 2 0 0 2 0
0 0 2 0 0 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 2 2 0 0
0 0 0 2 2 0 2 4 4 2 0 0 0 0 0 2 4 4 2 0
0 0 2 4 4 2 2 4 4 2 0 0 2 2 0 2 4 4 2 0
0 0 2 4 4 2 1 2 2 0 0 2 0 0 2 0 2 2 1 0
0 0 0 2 2 1 1 1 0 0 0 2 0 0 2 0 0 1 0 0
0 0 0 1 0 0 0 0 1 1 0 0 2 2 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 2 2 0
1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 0 0
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 0 0 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 0 0 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2
0 0 2 2 0 0 0 0 0 0 0 2 2 0 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 2 4 4
0 2 0 0 2 0 0 0 0 0 2 0 0 2 0 0 0 3 2 2
0 1 2 2 1 1 1 1 1 1 1 2 2 1 0 0 0 3 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 0 0
0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 3 0
1 1 0 0 0 0 0 2 2 1 1 1 0 0 0 0 2 2 3 0
0 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
1 1 0 0 0 0 2 0 0 2 0 0 0 0 0 2 4 4 2 0
0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 1 0 0 0 0 0 0 3 3 2 2 3 0 0 0 0
0 0 2 2 1 0 0 0 0 0 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 3 3 0 2 4 4 2 0 0 0 0
0 2 0 0 2 0 0 0 3 4 3 0 0 2 2 0 0 0 0 0
```


## train_4

**input:**
```
0 0 2 2 0 0 0 0
0 2 0 0 2 0 0 0
0 2 0 0 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```


**output:**
```
0 0 2 2 0 0 0 0
0 2 4 4 2 0 0 0
0 2 4 4 2 0 0 0
0 0 2 2 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 1
0 0 0 0 0 0 1 4
```

Okay, let's break down this task.

**Perception:**

1.  **Input/Output Structure:** Both input and output are grids of colored pixels. The overall size and most pixel colors remain the same between input and output.
2.  **Key Change:** The core transformation involves filling certain white (0) areas within the grid with a specific color.
3.  **Identifying the Fill Color:** In each example, there appears to be a single, unique pixel of a non-white color that dictates the fill color. This pixel seems "isolated" in that it doesn't have any neighbors (including diagonals) of the same color.
    *   Train 1: Orange (7) pixel at the bottom right determines the fill color.
    *   Train 2: Yellow (4) pixel at the bottom left determines the fill color.
    *   Train 3: Yellow (4) pixel enclosed within a green object determines the fill color.
    *   Train 4: Yellow (4) pixel at the bottom right determines the fill color.
4.  **Identifying Areas to Fill:** The areas being filled are contiguous regions of white (0) pixels that are completely enclosed or surrounded by non-white pixels. These look like the "insides" of shapes or loops.
5.  **No Other Changes:** Pixels that are not part of these enclosed white regions, and are not the isolated source pixel, retain their original color from the input. The non-white pixels forming the boundaries of the filled areas also remain unchanged.

**Facts:**


```yaml
task_elements:
  - element: grid
    description: A 2D array of pixels with colors 0-9.
  - element: background
    value: 0 (white)
  - element: objects
    description: Contiguous areas of non-white pixels.
    properties:
      - color: The specific color (1-9) of the object's pixels.
      - shape: Some objects form closed loops or shapes that enclose areas.
  - element: enclosed_regions
    description: Contiguous areas of white pixels completely surrounded by non-white pixels.
  - element: isolated_pixel
    description: A single non-white pixel in the input grid that has no neighbors (including diagonals) of the same color. There is exactly one such pixel per input grid.
    properties:
      - color: The color of this isolated pixel. This color determines the fill color for the enclosed regions.
  - element: transformation
    description: Filling specific areas of the grid.
    action:
      type: fill
      target: enclosed_regions (white pixels)
      color_source: isolated_pixel's color
relationships:
  - type: enclosure
    subject: non-white pixels (objects)
    object: enclosed_regions (white pixels)
    description: Non-white pixels form boundaries that surround and define the enclosed white regions.
  - type: color_determination
    subject: isolated_pixel
    object: fill action
    description: The color of the single isolated pixel dictates the color used to fill the enclosed white regions.
```


**Natural Language Program:**

1.  Scan the input grid to find the single, isolated non-white pixel. A pixel is isolated if none of its eight neighbours (horizontal, vertical, and diagonal) share the same color. Record the color of this isolated pixel; this is the `fill_color`.
2.  Identify all connected regions of white (0) pixels within the input grid.
3.  For each identified white region, check if it is completely enclosed by non-white pixels. A region is enclosed if none of its constituent white pixels are adjacent (horizontally or vertically) to the grid's border or to another white pixel that eventually connects to the border.
4.  Create the output grid as a copy of the input grid.
5.  For every white pixel identified as part of a completely enclosed region in step 3, change its color in the output grid to the `fill_color` determined in step 1.
6.  All other pixels in the output grid retain their original colors from the input grid.
```python
import numpy as np

"""
Transforms the input grid by finding a single "isolated" non-white pixel and using its color to fill any completely enclosed white (0) regions.

1. Find the isolated pixel: Scan the grid for a non-white pixel that has no neighbors (including diagonals) of the same color. Extract its color as the fill_color.
2. Identify enclosed white regions: Find all contiguous areas of white pixels that are not connected to the grid border.
3. Fill enclosed regions: Create a copy of the input grid. Change the color of all pixels within the identified enclosed white regions to the fill_color.
4. Return the modified grid.
"""

def find_isolated_pixel_color(grid):
    """
    Finds the color of the single non-white pixel in the grid
    that has no neighbors (including diagonals) of the same color.
    """
    height, width = grid.shape
    for r in range(height):
        for c in range(width):
            color = grid[r, c]
            # Only check non-white pixels
            if color != 0:
                is_isolated = True
                # Check 8 neighbors
                for dr in range(-1, 2):
                    for dc in range(-1, 2):
                        # Skip the pixel itself
                        if dr == 0 and dc == 0:
                            continue
                        nr, nc = r + dr, c + dc
                        # Check boundaries
                        if 0 <= nr < height and 0 <= nc < width:
                            if grid[nr, nc] == color:
                                is_isolated = False
                                break  # Found a neighbor of the same color
                    if not is_isolated:
                        break  # No need to check more neighbors for this pixel
                
                # If after checking all neighbors, none had the same color, it's isolated
                if is_isolated:
                    return color
    # Should theoretically always find one based on problem description
    return -1 # Indicate error or unexpected state

def find_enclosed_white_regions(grid):
    """
    Identifies the coordinates of all white pixels (0) that belong to
    regions completely enclosed by non-white pixels.
    Uses a flood fill from the border to mark reachable white pixels.
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    enclosed_coords = set()
    
    # Queue for BFS - stores (row, col)
    queue = []

    # 1. Initialize queue with all border white pixels
    for r in range(height):
        if grid[r, 0] == 0 and not visited[r, 0]:
            queue.append((r, 0))
            visited[r, 0] = True
        if grid[r, width - 1] == 0 and not visited[r, width - 1]:
            queue.append((r, width - 1))
            visited[r, width - 1] = True
    for c in range(1, width - 1): # Avoid corners already added
        if grid[0, c] == 0 and not visited[0, c]:
            queue.append((0, c))
            visited[0, c] = True
        if grid[height - 1, c] == 0 and not visited[height - 1, c]:
            queue.append((height - 1, c))
            visited[height - 1, c] = True
            
    # 2. Perform BFS to find all white pixels reachable from the border
    while queue:
        r, c = queue.pop(0)
        
        # Check 4 neighbors (horizontal and vertical)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            
            # Check boundaries
            if 0 <= nr < height and 0 <= nc < width:
                # If it's a white pixel and not visited yet
                if grid[nr, nc] == 0 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    queue.append((nr, nc))

    # 3. Identify enclosed white pixels
    # Any white pixel that was *not* visited must be enclosed
    for r in range(height):
        for c in range(width):
            if grid[r, c] == 0 and not visited[r, c]:
                enclosed_coords.add((r, c))
                
    return enclosed_coords

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    """
    input_grid_np = np.array(input_grid)
    
    # Find the color to use for filling
    fill_color = find_isolated_pixel_color(input_grid_np)
    
    if fill_color == -1:
         # Handle case where isolated pixel wasn't found (shouldn't happen per task examples)
         print("Warning: Could not find isolated pixel.")
         return input_grid # Return original grid or handle error appropriately

    # Find the coordinates of white pixels in enclosed regions
    enclosed_pixel_coords = find_enclosed_white_regions(input_grid_np)
    
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid_np)
    
    # Fill the enclosed regions with the fill_color
    for r, c in enclosed_pixel_coords:
        output_grid[r, c] = fill_color
        
    # Convert back to list of lists if necessary for the framework
    return output_grid.tolist()
```
