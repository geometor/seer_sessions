
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

*   **Perception:** The input grid always contains a single non-white pixel at the top-left corner (0,0). The rest of the grid contains a white background (0) and several distinct geometric shapes composed of various colors. The output grid is the same size as the input. The transformation involves potentially shifting all colored pixels *except* the one at (0,0) based on the color of the pixel at (0,0). If the pixel at (0,0) is maroon (9), no shift occurs, and the output is identical to the input. If the pixel at (0,0) is a different color, all other non-white pixels are shifted down and to the right by a specific amount determined by that color. Pixels shifted beyond the grid boundaries are discarded. The background remains white, and the top-left pixel remains unchanged in the output.

*   **Facts:**
    
```yaml
    elements:
      - role: indicator
        location: top-left corner (0,0)
        property: color
        description: A single pixel whose color determines the transformation rule.
      - role: objects
        location: Rest of the grid (excluding (0,0))
        property: color (non-white)
        description: Contiguous blocks or individual pixels of non-white colors forming shapes.
      - role: background
        location: Grid cells not occupied by the indicator or objects.
        property: color (white, 0)
        description: The default empty space in the grid.
      - role: grid
        property: dimensions (height, width)
        description: The 2D canvas for the elements. Output grid has the same dimensions as the input.

    actions:
      - name: read_indicator
        input: input grid
        output: indicator color C
        description: Get the color value of the pixel at input[0,0].
      - name: determine_shift
        input: indicator color C
        output: shift vector (dy, dx)
        description: >
          Based on the indicator color C, determine the vertical (dy) and horizontal (dx) shift amount using a specific mapping:
          - If C is 9 (maroon), shift is (0, 0).
          - If C is 4 (yellow), shift is (3, 1).
          - If C is 6 (magenta), shift is (2, 2).
          - If C is 7 (orange), shift is (5, 3).
          - (Other colors not seen in examples, assume a default or error if needed, but likely covered by these cases).
      - name: apply_shift
        input: input grid, shift vector (dy, dx)
        output: output grid
        description: >
          Create a new grid of the same size as the input, initialized with white (0).
          Copy the indicator pixel input[0,0] to output[0,0].
          For every other pixel input[r, c] (where r > 0 or c > 0):
            If input[r, c] is not white (0):
              Calculate the new coordinates (nr, nc) = (r + dy, c + dx).
              If (nr, nc) is within the grid boundaries, set output[nr, nc] = input[r, c].

    relationships:
      - type: control
        element1: indicator color
        element2: shift vector (dy, dx)
        description: The color of the indicator pixel directly controls the magnitude and direction of the shift applied to the objects.
      - type: transformation
        element1: objects (in input)
        element2: objects (in output)
        action: apply_shift
        description: Objects in the output grid are the result of shifting the objects from the input grid, constrained by the grid boundaries.
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid, filled entirely with white (0) pixels, preserving the original dimensions.
    2.  Read the color `C` of the pixel at the top-left corner `(0,0)` of the input grid.
    3.  Determine the vertical shift `dy` and horizontal shift `dx` based on the color `C`:
        *   If `C` is 9 (maroon), set `dy = 0` and `dx = 0`.
        *   If `C` is 4 (yellow), set `dy = 3` and `dx = 1`.
        *   If `C` is 6 (magenta), set `dy = 2` and `dx = 2`.
        *   If `C` is 7 (orange), set `dy = 5` and `dx = 3`.
    4.  Copy the color `C` from `input[0,0]` to `output[0,0]`.
    5.  Iterate through each pixel `(r, c)` of the input grid, starting from row 0, column 1, and then from row 1, column 0 onwards (i.e., skipping the already processed `(0,0)` pixel).
    6.  For each pixel `(r, c)`, get its color `pixel_color = input[r, c]`.
    7.  If `pixel_color` is not white (0):
        a.  Calculate the target coordinates: `new_row = r + dy`, `new_col = c + dx`.
        b.  Check if the target coordinates `(new_row, new_col)` are within the bounds of the grid dimensions.
        c.  If the target coordinates are within bounds, set the color of the pixel at `output[new_row, new_col]` to `pixel_color`.
    8.  Return the final output grid.
