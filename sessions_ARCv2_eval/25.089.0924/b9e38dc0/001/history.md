
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's analyze the task based on the provided examples.

**Perception of Elements:**

1.  **Grid Structure:** All examples involve a 2D grid of colored pixels. The output grid always has the same dimensions as the input grid.
2.  **Colors:** Each task uses a distinct set of colors. There's typically a dominant background color.
3.  **Objects/Regions:** We can perceive distinct regions or objects formed by contiguous pixels of the same color. In Example 1, there's a green outline. In Example 2, scattered gray pixels. In Example 3, scattered maroon, magenta, azure, and green pixels.
4.  **Transformation:** The core transformation appears to be a 'fill' operation. A specific region of the background color is replaced with another color.
5.  **Key Colors:** In each example, three types of colors seem crucial:
    *   **Background Color:** The color that fills most of the grid initially and is the target for replacement (Blue 1 in Ex1, White 0 in Ex2, Orange 7 in Ex3). This appears to be the most frequent color in the input.
    *   **Seed/Fill Color:** The color that initiates the fill and is used to replace the background color (Maroon 9 in Ex1, Yellow 4 in Ex2, Green 3 in Ex3). This color often appears uniquely or in a small, distinct group in the input.
    *   **Boundary Color(s):** Colors that are neither background nor seed, and act as barriers to the fill operation (Green 3 & Gray 5 in Ex1, Gray 5 in Ex2, Maroon 9, Magenta 6, Azure 8 in Ex3).
6.  **Fill Mechanism:** The fill seems to originate from or be triggered by the 'seed' pixel(s). It spreads into the adjacent 'background' colored pixels. The spread stops when it hits a 'boundary' color pixel or the grid edge. This strongly suggests a flood fill algorithm targeting the connected component of the background color that touches the seed pixel(s).

**YAML Facts:**


```yaml
task_description: Identify a background color, a seed color/pixel(s), and boundary colors, then flood fill the connected area of the background color adjacent to the seed(s) with the seed color.

definitions:
  - name: background_color
    description: The most frequent color in the input grid. This color is targeted for replacement.
  - name: seed_pixel(s)
    description: One or more pixels of a specific color that initiate the fill. Often a color appearing infrequently or uniquely in the input.
  - name: fill_color
    description: The color used to replace the background color during the fill. This is the same color as the seed_pixel(s).
  - name: boundary_colors
    description: All colors present in the input grid that are neither the background_color nor the fill_color. These colors block the flood fill.
  - name: target_fill_area
    description: The connected component (4-way adjacency) of background_color pixels that are adjacent to any seed_pixel.

transformation_steps:
  - step: 1
    action: identify_colors
    inputs: input_grid
    outputs: background_color, seed_pixel(s), fill_color, boundary_colors
    details: >
      background_color = most frequent color.
      seed_pixel(s)/fill_color = identify the color/pixels initiating the fill based on input/output comparison (often infrequent color becoming fill color).
      boundary_colors = all other colors present.
  - step: 2
    action: find_initial_fill_pixels
    inputs: input_grid, seed_pixel(s), background_color
    outputs: initial_queue
    details: Find all pixels with background_color that are cardinally adjacent to any seed_pixel.
  - step: 3
    action: flood_fill
    inputs: input_grid (for boundaries), initial_queue, background_color, fill_color, boundary_colors
    outputs: modified_grid
    details: >
      Initialize output grid as copy of input.
      Use a queue/stack starting with initial_queue.
      Iteratively change background_color pixels in the queue to fill_color in the output grid.
      Add adjacent background_color neighbors (that are not boundaries and not already visited/queued) to the queue.
      Stop when the queue is empty.
  - step: 4
    action: final_output
    inputs: modified_grid
    outputs: output_grid

examples:
  - example: 1
    background_color: 1 (blue)
    seed_pixel(s): (4, 8) with color 9 (maroon)
    fill_color: 9 (maroon)
    boundary_colors: [3 (green), 5 (gray)]
    target_fill_area: Connected component of blue pixels adjacent to (4, 8), bounded by green/gray.
  - example: 2
    background_color: 0 (white)
    seed_pixel(s): (4, 12) with color 4 (yellow)
    fill_color: 4 (yellow)
    boundary_colors: [5 (gray)]
    target_fill_area: Connected component of white pixels adjacent to (4, 12), bounded by gray.
  - example: 3
    background_color: 7 (orange)
    seed_pixel(s): Multiple locations with color 3 (green) e.g., (10, 9), (11, 7), (11, 8), (11, 9), (12, 7), (12, 8).
    fill_color: 3 (green)
    boundary_colors: [9 (maroon), 6 (magenta), 8 (azure)]
    target_fill_area: Connected component(s) of orange pixels adjacent to any initial green pixel, bounded by maroon/magenta/azure.

```


**Natural Language Program:**

1.  Identify the `background_color`, which is the most common color in the input grid.
2.  Identify the `seed_pixel(s)` and the `fill_color`. The `fill_color` is the color that replaces the `background_color` in the output; locate the pixel(s) with this `fill_color` in the input grid â€“ these are the `seed_pixel(s)`. (In these examples, the seed color appears infrequently in the input).
3.  Identify the `boundary_colors` which are all colors present in the input grid that are neither the `background_color` nor the `fill_color`.
4.  Create a copy of the input grid, which will become the output grid.
5.  Initialize a queue or list of pixels to process. Add all pixels adjacent (up, down, left, right) to any `seed_pixel` *if* that adjacent pixel's color in the input grid is the `background_color`. Keep track of pixels added to the queue to avoid duplicates.
6.  While the queue is not empty:
    a.  Remove a pixel location `(r, c)` from the queue.
    b.  Change the color of the pixel at `(r, c)` in the output grid to the `fill_color`.
    c.  Examine the four cardinal neighbors `(nr, nc)` of `(r, c)`.
    d.  For each neighbor `(nr, nc)`: If it is within the grid bounds, its color in the *input* grid is the `background_color`, and it has not been previously added to the queue, add `(nr, nc)` to the queue and mark it as added.
7.  Return the modified output grid.
