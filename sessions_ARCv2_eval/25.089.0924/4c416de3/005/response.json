{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom scipy.ndimage import label\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background color (BGC) as the most frequent color in the grid, \n   preferring non-white colors if multiple have the same max frequency.\n2. Find all distinct contiguous regions of white (0) pixels using connected components labeling.\n3. For each white region:\n    a. Determine its bounding box (minimum and maximum row and column indices: r_min, c_min, r_max, c_max).\n    b. Identify the four potential 'corner anchor' pixels located diagonally outside the bounding box:\n       - Top-Left (TL): (r_min - 1, c_min - 1)\n       - Top-Right (TR): (r_min - 1, c_max + 1)\n       - Bottom-Left (BL): (r_max + 1, c_min - 1)\n       - Bottom-Right (BR): (r_max + 1, c_max + 1)\n    c. Validate these corner anchors: They must be within the grid boundaries and have the background color (BGC). Keep track of valid anchors.\n    d. Find all 'color pixels' associated with the current white region. A color pixel is associated if:\n       - It is not white (0) and not the BGC.\n       - It is either located within the bounding box of the white region OR is cardinally adjacent (up, down, left, right) to any white pixel belonging to the region.\n    e. Assign a color to each valid corner anchor based on proximity to the associated color pixels:\n       - For each associated color pixel, calculate its Euclidean distance to each valid corner anchor.\n       - For each corner anchor, determine which associated color pixel is closest to it.\n       - Assign the color of this closest color pixel to the corner anchor. Ties are broken by the order in which color pixels are processed (the last closest pixel encountered determines the color).\n    f. For each corner anchor that received a color assignment, paint a 2x2 block in the output grid using that assigned color. The top-left coordinate of the 2x2 block depends on the corner anchor type:\n        - TL anchor at (ar, ac) paints block starting at (ar, ac + 1)\n        - TR anchor at (ar, ac) paints block starting at (ar, ac - 1)\n        - BL anchor at (ar, ac) paints block starting at (ar - 1, ac + 1)\n        - BR anchor at (ar, ac) paints block starting at (ar - 1, ac - 1)\n       Ensure the painting stays within grid bounds.\n4. Initialize the output grid as a copy of the input grid. The painting of 2x2 blocks modifies this copy. Pixels not part of these painted blocks retain their original color.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Finds the most frequent color in the grid.\n    Prefers non-white if counts are equal.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    \n    # If only one color exists, it's the background\n    if len(colors) == 1:\n        return colors[0]\n\n    # Separate white and non-white counts\n    white_count = 0\n    non_white_colors = []\n    non_white_counts = []\n    for color, count in zip(colors, counts):\n        if color == 0:\n            white_count = count\n        else:\n            non_white_colors.append(color)\n            non_white_counts.append(count)\n\n    # Find the most frequent non-white color\n    if non_white_counts:\n        max_non_white_count = max(non_white_counts)\n        most_frequent_non_white = [\n            non_white_colors[i] for i, count in enumerate(non_white_counts) if count == max_non_white_count\n        ]\n        # If the most frequent non-white count is >= white count, return one of them (e.g., the first)\n        if max_non_white_count >= white_count:\n             # Return the smallest color value among most frequent non-white in case of ties\n            return min(most_frequent_non_white)\n        else:\n            # White is strictly most frequent\n            return 0\n    else:\n        # Only white exists\n        return 0\n\n\ndef get_bounding_box(coords: list[tuple[int, int]]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef euclidean_distance(p1: tuple[int, int], p2: tuple[int, int]) -> float:\n    \"\"\"Calculates Euclidean distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef get_associated_color_pixels(grid: np.ndarray, \n                                region_coords_set: set[tuple[int, int]], \n                                bbox: tuple[int, int, int, int], \n                                bgc: int) -> list[tuple[tuple[int, int], int]]:\n    \"\"\"\n    Finds color pixels (non-white, non-BGC) associated with a white region.\n    Association means within the bounding box or cardinally adjacent to the region's white pixels.\n    \"\"\"\n    height, width = grid.shape\n    r_min, c_min, r_max, c_max = bbox\n    associated_pixels = []\n    processed_coords = set()  # Avoid duplicates\n\n    # 1. Check inside bounding box (inclusive)\n    # Iterate using numpy slicing for potential efficiency if needed, but direct iteration is clearer here.\n    for r in range(r_min, r_max + 1):\n        for c in range(c_min, c_max + 1):\n            coord = (r, c)\n             # Ensure coord is valid (though bbox should guarantee this unless 1x1 region)\n            if 0 <= r < height and 0 <= c < width:\n                color = grid[r, c]\n                # Check if it's a color pixel (not white, not BGC)\n                if color != 0 and color != bgc:\n                    if coord not in processed_coords:\n                        associated_pixels.append((coord, color))\n                        processed_coords.add(coord)\n\n    # 2. Check cardinal adjacency to white pixels in the region\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # R, L, D, U\n    for wr, wc in region_coords_set:\n        for dr, dc in directions:\n            nr, nc = wr + dr, wc + dc\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                coord = (nr, nc)\n                # Check if already processed (could be inside bbox too)\n                if coord not in processed_coords:\n                    color = grid[nr, nc]\n                    # Check if it's a color pixel\n                    if color != 0 and color != bgc:\n                        associated_pixels.append((coord, color))\n                        processed_coords.add(coord)\n                        \n    return associated_pixels\n\ndef paint_block(grid: np.ndarray, start_r: int, start_c: int, color: int):\n    \"\"\"Paints a 2x2 block starting at (start_r, start_c), checking bounds.\"\"\"\n    height, width = grid.shape\n    for r_offset in range(2):\n        for c_offset in range(2):\n            paint_r, paint_c = start_r + r_offset, start_c + c_offset\n            # Check bounds before painting\n            if 0 <= paint_r < height and 0 <= paint_c < width:\n                grid[paint_r, paint_c] = color\n\n\n# === Main Transform Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on white regions, corner anchors, \n    and closest associated color pixels, painting 2x2 blocks.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array) # Initialize output grid\n    height, width = input_array.shape\n\n    # 1. Identify background color\n    bgc = find_background_color(input_array)\n\n    # 2. Find white regions using connected components labeling\n    # structure defines connectivity (4-connectivity: cardinal directions)\n    structure = np.array([[0,1,0], [1,1,1], [0,1,0]], dtype=bool) \n    white_mask = (input_array == 0)\n    labeled_array, num_labels = label(white_mask, structure=structure)\n\n    # 3. Process each distinct white region\n    for i in range(1, num_labels + 1):\n        # Get coordinates of all pixels in the current region\n        region_coords = list(zip(*np.where(labeled_array == i)))\n        if not region_coords:\n            continue # Skip if region is empty (shouldn't happen with label)\n            \n        region_coords_set = set(region_coords)\n\n        # a. Calculate bounding box\n        bbox = get_bounding_box(region_coords)\n        if bbox is None: continue # Should also not happen if region_coords not empty\n        r_min, c_min, r_max, c_max = bbox\n\n        # b. & c. Identify and validate corner anchor pixels\n        potential_anchors = {\n            \"TL\": (r_min - 1, c_min - 1),\n            \"TR\": (r_min - 1, c_max + 1),\n            \"BL\": (r_max + 1, c_min - 1),\n            \"BR\": (r_max + 1, c_max + 1)\n        }\n        valid_anchors = {}\n        for name, (ar, ac) in potential_anchors.items():\n            # Check bounds and if the anchor pixel has the background color\n            if 0 <= ar < height and 0 <= ac < width and input_array[ar, ac] == bgc:\n                valid_anchors[name] = (ar, ac)\n\n        # If no valid anchors found for this region, skip to the next region\n        if not valid_anchors: \n             continue\n\n        # d. Find associated color pixels (non-white, non-BGC) for this region\n        color_pixels = get_associated_color_pixels(input_array, region_coords_set, bbox, bgc)\n        \n        # If no associated color pixels found, skip to the next region\n        if not color_pixels: \n            continue\n\n        # e. Assign colors to anchors based on closest color pixel\n        # Initialize assignments with infinite distance and no color\n        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_anchors}\n        \n        # Iterate through each associated color pixel\n        for pixel_coord, color in color_pixels:\n            # Compare its distance to each valid anchor\n            for name, anchor_coord in valid_anchors.items():\n                d = euclidean_distance(pixel_coord, anchor_coord)\n                # If this pixel is closer than the current closest, update the assignment\n                # Using '<=' implicitly handles ties by favoring the last processed pixel\n                if d <= assignments[name]['dist']: \n                    assignments[name]['dist'] = d\n                    assignments[name]['color'] = color\n\n        # f. Paint 2x2 blocks based on assignments\n        for name, anchor_coord in valid_anchors.items():\n            assigned_color = assignments[name]['color']\n            # Only paint if a color was actually assigned (dist wasn't infinity)\n            if assigned_color is not None:\n                ar, ac = anchor_coord\n                start_r, start_c = -1, -1 # Initialize invalid start coords\n\n                # Determine the top-left corner of the 2x2 block based on anchor type\n                if name == \"TL\":\n                    start_r, start_c = ar, ac + 1\n                elif name == \"TR\":\n                    start_r, start_c = ar, ac - 1\n                elif name == \"BL\":\n                    start_r, start_c = ar - 1, ac + 1\n                elif name == \"BR\":\n                    start_r, start_c = ar - 1, ac - 1\n\n                # Paint the 2x2 block using the helper function (handles bounds)\n                if start_r != -1: # Check if start coords were set\n                    paint_block(output_array, start_r, start_c, assigned_color)\n\n    # Convert the final NumPy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22027,
    "candidates_token_count": 3110,
    "total_token_count": 25137,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.940896,
  "retries": 1
}