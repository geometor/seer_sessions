{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom scipy.ndimage import label\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background color (BGC) as the most frequent color in the grid, \n   preferring non-white colors if multiple have the same max frequency.\n2. Find all distinct contiguous regions of white (0) pixels using connected components labeling (4-connectivity).\n3. For each white region:\n    a. Determine its bounding box (minimum and maximum row and column indices: r_min, c_min, r_max, c_max).\n    b. Identify the four potential 'corner anchor' pixels located diagonally outside the bounding box:\n       - Top-Left (TL): (r_min - 1, c_min - 1)\n       - Top-Right (TR): (r_min - 1, c_max + 1)\n       - Bottom-Left (BL): (r_max + 1, c_min - 1)\n       - Bottom-Right (BR): (r_max + 1, c_max + 1)\n    c. Validate these corner anchors: They must be within the grid boundaries and have the background color (BGC). Keep track of valid anchors.\n    d. Find all 'color pixels' associated with the current white region. A color pixel is associated if:\n       - It is not white (0) and not the BGC.\n       - It is either located within the bounding box of the white region OR is cardinally adjacent (up, down, left, right) to any white pixel belonging to the region.\n    e. If both valid anchors and associated color pixels exist for the region:\n       - Assign a color to each valid corner anchor based on proximity to the associated color pixels:\n         - For each associated color pixel, calculate its Euclidean distance to each valid corner anchor.\n         - For each corner anchor, determine which associated color pixel is closest to it.\n         - Assign the color of this closest color pixel to the corner anchor. Ties are broken by the order in which color pixels are processed (the last closest pixel encountered determines the color).\n    f. For each corner anchor that received a color assignment:\n       - Determine the top-left coordinate of the 2x2 block to paint based on the corner anchor type:\n         - TL anchor at (ar, ac) paints block starting at (ar, ac + 1)\n         - TR anchor at (ar, ac) paints block starting at (ar, ac - 1)\n         - BL anchor at (ar, ac) paints block starting at (ar - 1, ac + 1)\n         - BR anchor at (ar, ac) paints block starting at (ar - 1, ac - 1)\n       - Paint the corresponding 2x2 block in the output grid using that assigned color, ensuring the painting stays within grid bounds.\n4. Initialize the output grid as a copy of the input grid. The painting of 2x2 blocks modifies this copy. Pixels not part of these painted blocks retain their original color. Return the modified grid as a list of lists.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Finds the most frequent color in the grid.\n    Prefers non-white if counts are equal or non-white is most frequent.\n    \"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    \n    if len(colors) == 1:\n        return colors[0] # Only one color exists\n\n    # Separate counts for white (0) and non-white colors\n    white_count = 0\n    non_white_colors = []\n    non_white_counts = []\n    for color, count in zip(colors, counts):\n        if color == 0:\n            white_count = count\n        else:\n            non_white_colors.append(color)\n            non_white_counts.append(count)\n\n    # Determine the background color based on frequency\n    if non_white_counts:\n        max_non_white_count = max(non_white_counts)\n        # If the most frequent non-white color is more or equally frequent than white\n        if max_non_white_count >= white_count:\n            # Find all non-white colors with the maximum frequency\n            most_frequent_non_white = [\n                non_white_colors[i] for i, count in enumerate(non_white_counts) if count == max_non_white_count\n            ]\n            # In case of ties among non-white colors, return the smallest color value\n            return min(most_frequent_non_white)\n        else:\n            # White is strictly the most frequent color\n            return 0\n    else:\n        # Only white color exists in the grid\n        return 0\n\n\ndef get_bounding_box(coords: list[tuple[int, int]]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef euclidean_distance(p1: tuple[int, int], p2: tuple[int, int]) -> float:\n    \"\"\"Calculates Euclidean distance between two points (r1, c1) and (r2, c2).\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef get_associated_color_pixels(grid: np.ndarray, \n                                region_coords_set: set[tuple[int, int]], \n                                bbox: tuple[int, int, int, int], \n                                bgc: int) -> list[tuple[tuple[int, int], int]]:\n    \"\"\"\n    Finds color pixels (non-white, non-BGC) associated with a white region.\n    Association means within the bounding box or cardinally adjacent to the region's white pixels.\n    Returns a list of tuples: ((row, col), color).\n    \"\"\"\n    height, width = grid.shape\n    r_min, c_min, r_max, c_max = bbox\n    associated_pixels = []\n    processed_coords = set()  # To avoid adding the same pixel twice\n\n    # Define cardinal directions for adjacency check\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up\n\n    # 1. Check pixels within the bounding box (inclusive)\n    for r in range(r_min, r_max + 1):\n        for c in range(c_min, c_max + 1):\n            coord = (r, c)\n            # Check grid bounds (though should be within if bbox is correct)\n            if 0 <= r < height and 0 <= c < width:\n                color = grid[r, c]\n                # Check if it's a color pixel (not white, not BGC)\n                if color != 0 and color != bgc:\n                    if coord not in processed_coords:\n                        associated_pixels.append((coord, color))\n                        processed_coords.add(coord)\n\n    # 2. Check pixels cardinally adjacent to the white region pixels\n    for wr, wc in region_coords_set:\n        for dr, dc in directions:\n            nr, nc = wr + dr, wc + dc\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                coord = (nr, nc)\n                # Check if already processed (might be adjacent AND inside bbox)\n                if coord not in processed_coords:\n                    color = grid[nr, nc]\n                    # Check if it's a color pixel\n                    if color != 0 and color != bgc:\n                        associated_pixels.append((coord, color))\n                        processed_coords.add(coord)\n                        \n    return associated_pixels\n\ndef paint_block(grid: np.ndarray, start_r: int, start_c: int, color: int):\n    \"\"\"Paints a 2x2 block starting at (start_r, start_c), checking grid bounds.\"\"\"\n    height, width = grid.shape\n    for r_offset in range(2):\n        for c_offset in range(2):\n            paint_r, paint_c = start_r + r_offset, start_c + c_offset\n            # Check bounds before painting\n            if 0 <= paint_r < height and 0 <= paint_c < width:\n                grid[paint_r, paint_c] = color\n\n\n# === Main Transform Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on white regions, corner anchors, \n    and closest associated color pixels, painting 2x2 blocks.\n    \"\"\"\n    # Convert input list of lists to NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Create a copy to modify, which will become the output grid\n    output_array = np.copy(input_array) \n    height, width = input_array.shape\n\n    # Step 1: Identify background color\n    bgc = find_background_color(input_array)\n\n    # Step 2: Find white regions using connected components labeling\n    # Define 4-connectivity (cardinal directions only)\n    structure = np.array([[0,1,0], [1,1,1], [0,1,0]], dtype=bool) \n    white_mask = (input_array == 0)\n    # Label connected components (regions) of white pixels\n    labeled_array, num_labels = label(white_mask, structure=structure)\n\n    # Step 3: Process each distinct white region\n    for i in range(1, num_labels + 1): # Iterate through each label (region)\n        # Get coordinates of all pixels belonging to the current region\n        region_coords = list(zip(*np.where(labeled_array == i)))\n        if not region_coords:\n            continue # Skip if region is somehow empty\n            \n        # Store coordinates in a set for efficient lookup later\n        region_coords_set = set(region_coords)\n\n        # Step 3a: Calculate bounding box for the current region\n        bbox = get_bounding_box(region_coords)\n        if bbox is None: continue # Skip if bounding box calculation fails\n        r_min, c_min, r_max, c_max = bbox\n\n        # Step 3b & 3c: Identify and validate potential corner anchor pixels\n        potential_anchors = {\n            \"TL\": (r_min - 1, c_min - 1), # Top-Left\n            \"TR\": (r_min - 1, c_max + 1), # Top-Right\n            \"BL\": (r_max + 1, c_min - 1), # Bottom-Left\n            \"BR\": (r_max + 1, c_max + 1)  # Bottom-Right\n        }\n        valid_anchors = {} # Dictionary to store valid anchors {name: (row, col)}\n        for name, (ar, ac) in potential_anchors.items():\n            # Validate: Check if anchor is within grid bounds AND has background color\n            if 0 <= ar < height and 0 <= ac < width and input_array[ar, ac] == bgc:\n                valid_anchors[name] = (ar, ac)\n\n        # If no valid anchors were found for this region, move to the next region\n        if not valid_anchors: \n             continue\n\n        # Step 3d: Find all associated color pixels for this region\n        color_pixels = get_associated_color_pixels(input_array, region_coords_set, bbox, bgc)\n        \n        # If no associated color pixels were found, move to the next region\n        if not color_pixels: \n            continue\n\n        # Step 3e: Assign colors to valid anchors based on closest color pixel\n        # Initialize assignments: store closest distance and corresponding color for each anchor\n        assignments = {name: {'dist': float('inf'), 'color': None} for name in valid_anchors}\n        \n        # Iterate through each found associated color pixel\n        for pixel_coord, color in color_pixels:\n            # Compare its distance to each valid anchor point\n            for name, anchor_coord in valid_anchors.items():\n                d = euclidean_distance(pixel_coord, anchor_coord)\n                # If this pixel is closer than or equally close to the current closest, update the assignment\n                # '<=' handles ties by favoring the pixel processed later\n                if d <= assignments[name]['dist']: \n                    assignments[name]['dist'] = d\n                    assignments[name]['color'] = color\n\n        # Step 3f: Paint 2x2 blocks in the output grid based on assignments\n        for name, anchor_coord in valid_anchors.items():\n            assigned_color = assignments[name]['color']\n            # Check if a color was successfully assigned to this anchor\n            if assigned_color is not None:\n                ar, ac = anchor_coord # Anchor coordinates\n                start_r, start_c = -1, -1 # Initialize invalid block start coordinates\n\n                # Determine the top-left corner (start_r, start_c) of the 2x2 block based on anchor type\n                if name == \"TL\":\n                    start_r, start_c = ar, ac + 1\n                elif name == \"TR\":\n                    start_r, start_c = ar, ac - 1\n                elif name == \"BL\":\n                    start_r, start_c = ar - 1, ac + 1\n                elif name == \"BR\":\n                    start_r, start_c = ar - 1, ac - 1\n\n                # If valid start coordinates were determined, paint the block\n                if start_r != -1: \n                    paint_block(output_array, start_r, start_c, assigned_color)\n\n    # Convert the final NumPy array back to a standard Python list of lists for the return value\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 26135,
    "candidates_token_count": 3282,
    "total_token_count": 29417,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.469945,
  "retries": 1
}