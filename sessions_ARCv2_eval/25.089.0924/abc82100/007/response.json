{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on a hierarchical set of rules:\n\n1.  Vertical Red Line Rule: If a contiguous vertical line of Red (2) pixels exists spanning the grid's height at column 'c':\n    - Create a new white (0) output grid.\n    - Fill the area in the output grid to the left of the line (columns < c) with Red (2).\n    - Fill the column 'c' in the output grid with Blue (1).\n    - Leave the area to the right (columns > c) as white (0).\n    This rule takes precedence over all others.\n\n2.  Azure Presence Rule: If no vertical Red line is found, check if Azure (8) is present in the input grid.\n    - If Azure (8) is NOT present: Return a copy of the input grid.\n    - If Azure (8) IS present:\n        a. Count the frequency of all non-white (0) and non-azure (8) colors.\n        b. If no such colors exist (only white and/or azure present): Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n        c. If other colors exist, find the Most Frequent Color (MFC) among them. If counts are tied, the color with the lower numerical value is chosen.\n        d. Apply transformation based on MFC:\n            - If MFC is Blue (1):\n                i. Find all contiguous Blue (1) objects using 8-way adjacency (including diagonals).\n                ii. Identify the largest Blue object by pixel count.\n                iii. Create a new output grid filled entirely with white (0).\n                iv. Draw the shape of the largest Blue object onto the output grid using Red (2).\n            - If MFC is Magenta (6):\n                i. Create an intermediate grid, initially filled with white (0).\n                ii. Populate the intermediate grid based on the input grid: Input Magenta(6)->Output Orange(7), Input Orange(7)->Output Magenta(6), Input Red(2)->Output Yellow(4), Input Yellow(4)->Output Red(2). All other input colors result in white(0).\n                iii. Initialize the final output grid as a copy of this intermediate grid.\n                iv. Iterate through the *intermediate grid* rows 0 to height-2. For each pixel (r, c):\n                   - If intermediate(r, c) is Orange(7) AND intermediate(r+1, c) is white(0), set *final output*(r+1, c) to Orange(7).\n                   - If intermediate(r, c) is Magenta(6) AND intermediate(r+1, c) is white(0), set *final output*(r+1, c) to Magenta(6).\n            - If MFC is Yellow (4):\n                i. Initialize the output grid filled entirely with white (0).\n                ii. Iterate through the input grid (r, c):\n                   - If input(r, c) is Yellow(4): Set output(r, c) = Red(2).\n                   - If input(r, c) is Blue(1): Set output(r, c) = Orange(7).\n                   (All other input colors result in white(0)).\n            - If MFC is any other color: (Fallback based on observed Azure removal) Create the output grid by copying the input grid and changing all Azure(8) pixels to white(0).\n\n3.  Default Rule: If no vertical Red line is found AND Azure (8) is not present, return the input grid unchanged (handled by step 2).\n\"\"\"\n\n\ndef find_objects(grid, color, adjacency=8):\n    \"\"\"Finds all contiguous objects of a given color using specified adjacency.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    # Define neighbor offsets based on adjacency\n    if adjacency == 8:\n        neighbor_deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else: # Default to 4-way\n        neighbor_deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Iterate through each pixel\n    for r in range(height):\n        for c in range(width):\n            # If pixel matches color and hasn't been visited, start BFS\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    # Check neighbors\n                    for dr, dc in neighbor_deltas:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor matches color and is unvisited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                # Add found object coordinates to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef find_vertical_line_column(grid, color):\n    \"\"\"Checks for a vertical line of a specific color spanning the full height\n       and returns its column index, or None if not found.\"\"\"\n    height, width = grid.shape\n    if height == 0: return None # Handle empty grid\n\n    # Check each column\n    for c in range(width):\n        is_line = True\n        # Check each row in the current column\n        for r in range(height):\n            if grid[r, c] != color:\n                is_line = False\n                break\n        # If all pixels in the column match the color, return the column index\n        if is_line:\n            return c\n    return None # No full vertical line found\n\ndef get_color_counts(grid):\n    \"\"\"Counts the frequency of non-white (0) and non-azure (8) colors.\"\"\"\n    counts = Counter()\n    if grid.size == 0: return counts # Handle empty grid\n    # Iterate through all pixels\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            # Count only if not white and not azure\n            if color != 0 and color != 8:\n                counts[color] += 1\n    return counts\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the presence of a vertical red line\n    or the most frequent color alongside azure.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    if height == 0 or width == 0: # Handle empty input\n        return []\n\n    # 1. Check for Vertical Red Line (Rule 1)\n    red_line_col = find_vertical_line_column(input_grid_np, 2)\n    if red_line_col is not None:\n        # Initialize output grid as white\n        output_grid = np.zeros_like(input_grid_np)\n        # Fill left side with Red (2)\n        if red_line_col > 0:\n            output_grid[:, :red_line_col] = 2\n        # Change line itself to Blue (1)\n        output_grid[:, red_line_col] = 1\n        # Right side remains white (0) - already initialized\n        return output_grid.tolist()\n\n    # 2. Check for Azure (8) (Rule 2)\n    if 8 not in input_grid_np:\n        # If no Azure, return input unchanged\n        return input_grid_np.tolist()\n    else:\n        # Azure is present, proceed with Azure rules\n        color_counts = get_color_counts(input_grid_np)\n\n        # 2.b Handle cases where only white and/or azure exist\n        if not color_counts:\n             # Change Azure to white and return\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n        # 2.c Find MFC (highest count, lowest color value tie-breaker)\n        mfc = -1\n        max_count = -1\n        # Iterate through sorted colors (keys) to handle tie-breaking correctly\n        # Colors are 1-9 excluding 8. Sorting ensures lower number wins tie.\n        for color in sorted(color_counts.keys()):\n            count = color_counts[color]\n            if count > max_count:\n                max_count = count\n                mfc = color\n        # If count == max_count, the lower color value (already processed due to sort) remains mfc.\n\n        # Check if a valid MFC was found\n        if mfc == -1:\n             # Fallback: should not happen, but safest to just clear azure\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n\n        # 2.d Apply transformation based on MFC\n\n        # MFC is Blue (1)\n        if mfc == 1:\n            # Find largest blue object using 8-way adjacency\n            blue_objects = find_objects(input_grid_np, 1, adjacency=8)\n            if not blue_objects:\n                # Fallback if no blue objects found despite MFC being blue\n                 output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n                 return output_grid.tolist()\n\n            # Find the object with the maximum number of pixels\n            largest_blue_object = max(blue_objects, key=len)\n            # Initialize output grid as white\n            output_grid = np.zeros_like(input_grid_np)\n            # Draw the largest blue object's shape in Red\n            for r, c in largest_blue_object:\n                if 0 <= r < height and 0 <= c < width: # Boundary check just in case\n                    output_grid[r, c] = 2\n            return output_grid.tolist()\n\n        # MFC is Magenta (6)\n        elif mfc == 6:\n            # Create intermediate grid with initial swaps\n            intermediate_grid = np.zeros_like(input_grid_np)\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    if color == 6: intermediate_grid[r, c] = 7 # Magenta -> Orange\n                    elif color == 7: intermediate_grid[r, c] = 6 # Orange -> Magenta\n                    elif color == 2: intermediate_grid[r, c] = 4 # Red -> Yellow\n                    elif color == 4: intermediate_grid[r, c] = 2 # Yellow -> Red\n                    # Other colors (0, 1, 3, 5, 8, 9) result in 0\n\n            # Copy intermediate to final output grid for modification\n            output_grid = np.array(intermediate_grid)\n\n            # Apply row duplication logic based on *intermediate* grid's state\n            for r in range(height - 1): # Iterate up to second to last row\n                for c in range(width):\n                    intermediate_color = intermediate_grid[r, c]\n                    below_intermediate_color = intermediate_grid[r + 1, c]\n\n                    # Check condition for Orange drop-down effect\n                    if intermediate_color == 7 and below_intermediate_color == 0:\n                        output_grid[r + 1, c] = 7 # Color below Orange in final output\n                    # Check condition for Magenta drop-down effect\n                    elif intermediate_color == 6 and below_intermediate_color == 0:\n                        output_grid[r + 1, c] = 6 # Color below Magenta in final output\n\n            return output_grid.tolist()\n\n        # MFC is Yellow (4)\n        elif mfc == 4:\n            # Initialize output grid as white\n            output_grid = np.zeros_like(input_grid_np)\n            for r in range(height):\n                for c in range(width):\n                    color = input_grid_np[r, c]\n                    # Yellow -> Red (pixel-wise)\n                    if color == 4:\n                         output_grid[r, c] = 2\n                    # Blue -> Orange (pixel-wise)\n                    elif color == 1:\n                         output_grid[r, c] = 7\n                    # Other colors (including Azure, Red, Orange etc.) remain white (0)\n            return output_grid.tolist()\n\n        # MFC is any other color (Fallback)\n        else:\n             # Default action for other MFCs: just remove Azure\n             output_grid = np.where(input_grid_np == 8, 0, input_grid_np)\n             return output_grid.tolist()\n\n    # Fallback return (should not be reached ideally)\n    return input_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22283,
    "candidates_token_count": 3073,
    "total_token_count": 25356,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.992801,
  "retries": 1
}