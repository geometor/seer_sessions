
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 4 4 1 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 4 4 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 5 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 5 5 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 5 1 1 1 1 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 8 8 1 8 8 1 1
1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 1 1 1 4 4 1 2 1 4 4
1 1 1 1 1 1 3 1 1 1 1 1 4 4 2 4 4 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 2 4 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 4 2 4 1 1
1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 5 5 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 5 2 5 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 5 5 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 5 1 1 1 1 8 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 8 8 1 8 8 1 1
1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1
1 1 1 1 1 1 1 1 1 1 1 8 8 1 8 8 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 4 4 4 8 8 8 1 1 2 8 8 8 8
8 8 8 8 2 4 8 4 8 8 8 8 1 2 8 8 8 8
8 8 8 8 2 4 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 4 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 4 4 4 2 4 4 4 8 8 8 1 1 2 1 1 8 8
8 4 8 4 2 4 8 4 8 8 8 8 1 2 1 8 8 8
8 4 4 4 2 4 4 4 8 8 8 8 8 8 8 8 8 8
8 8 8 4 2 4 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's break down this task.

## Perception of Elements

1.  **Grid Structure:** Both examples use 18x18 grids.
2.  **Background Color:** In example 1, the predominant color is white (1). In example 2, it's azure (8). This seems to be the background color which is mostly unaffected.
3.  **Key Color:** Red (2) pixels appear to be significant. They exist as single pixels, horizontal lines, or vertical lines.
4.  **Other Objects:** Various small shapes composed of other colors (blue, green, yellow, gray, azure) exist in the grid.
5.  **Transformation:** The core transformation seems to involve reflection. Objects adjacent to red pixels/lines are mirrored across those red elements.
6.  **Reflection Axis:**
    *   If the red element is a horizontal line, the reflection is vertical across the row of the line.
    *   If the red element is a vertical line, the reflection is horizontal across the column of the line.
    *   If the red element is a single pixel, the reflection appears to be horizontal across the column of the pixel in the provided examples.
7.  **Persistence:** The original objects and the red "mirror" elements remain in the output grid. The reflection creates a *copy* of the adjacent object.
8.  **Overlap:** The reflected copies are added to the grid. It appears they only overwrite the background color, not other existing colored pixels from the input.

## YAML Facts


```yaml
Grid Properties:
  - Dimensions: 18x18 (for both examples)
  - Background Color:
      - Example 1: White (1) - most frequent color, not red.
      - Example 2: Azure (8) - most frequent color, not red.

Objects:
  - Type: Red Elements
    - Color: Red (2)
    - Shapes Observed:
        - Single Pixel (Point)
        - Horizontal Line (contiguous red pixels in a row)
        - Vertical Line (contiguous red pixels in a column)
    - Role: Act as reflection axes/points ("mirrors"). Persist in output.
  - Type: Mirrored Objects
    - Color: Any color except Red (2) and the determined Background Color.
    - Property: Must be adjacent (sharing an edge) to a Red Element.
    - Role: These objects are copied and reflected. Persist in output.
  - Type: Background
    - Color: White (1) or Azure (8) in examples.
    - Role: Fills empty space. Can be overwritten by reflected object copies.

Relationships:
  - Adjacency: Mirrored Objects are located directly next to (sharing an edge with) Red Elements.
  - Symmetry Trigger: The presence of a Red Element adjacent to a Mirrored Object triggers a reflection.

Actions:
  - Identification: Locate Red Elements and potential Mirrored Objects. Determine Background Color.
  - Reflection:
    - Type: Geometric Mirroring.
    - Axis Determination:
        - Horizontal Red Line: Reflect vertically across the line's row.
        - Vertical Red Line or Single Red Pixel: Reflect horizontally across the line's/pixel's column.
    - Process: For each pixel of a Mirrored Object adjacent to a Red Element, calculate its reflected position based on the Red Element's type and location.
  - Copying: The reflection process creates a copy of the Mirrored Object's pixels.
  - Addition: The reflected pixels are added to the output grid, typically overwriting only Background Color pixels at the target location. Original input pixels are preserved.
```


## Natural Language Program

1.  Create the output grid by making an exact copy of the input grid.
2.  Determine the background color by finding the most frequent color in the input grid that is not red (2).
3.  Iterate through every pixel `(r, c)` of the input grid.
4.  If the color `clr` of the pixel `input[r, c]` is *not* red (2) and *not* the background color:
    a. Check all 4 cardinal neighbors (up, down, left, right) of `(r, c)`.
    b. For each neighbor `(nr, nc)` that contains a red (2) pixel:
        i.  Determine the orientation of the red structure at `(nr, nc)`. Check if `input[nr, nc-1]` or `input[nr, nc+1]` is also red. If yes, classify the red structure as "horizontal". Otherwise, classify it as "vertical/point".
        ii. If the red structure is classified as "horizontal":
            *   Calculate the reflected position: `reflected_pos = (nr + (nr - r), c)`. This reflects pixel `(r, c)` vertically across the row `nr`.
        iii. If the red structure is classified as "vertical/point":
            *   Calculate the reflected position: `reflected_pos = (r, nc + (nc - c))`. This reflects pixel `(r, c)` horizontally across the column `nc`.
        iv. If the calculated `reflected_pos` is within the grid boundaries *and* the current color at `output[reflected_pos]` is the background color, update the output grid by setting `output[reflected_pos] = clr`.
5.  After checking all pixels `(r, c)` and processing reflections for their adjacent red neighbors, return the modified output grid.
```python
import numpy as np
from collections import Counter

"""
Transformation Rule Description:

1.  Identify the background color: This is the most frequent color in the input grid, excluding red (color 2).
2.  Create an output grid initialized as a copy of the input grid.
3.  Iterate through each pixel `(r, c)` of the input grid.
4.  If the pixel's color `clr` is not red (2) and not the background color, check its cardinal neighbors (up, down, left, right).
5.  If a neighbor `(nr, nc)` contains a red pixel (color 2):
    a.  Determine the reflection axis based on the relative position of the red neighbor:
        - If the red neighbor is directly above or below the current pixel (`c == nc`), the reflection is vertical across the row `nr`.
        - If the red neighbor is directly to the left or right of the current pixel (`r == nr`), the reflection is horizontal across the column `nc`.
    b.  Calculate the coordinates `(rr, rc)` of the reflected pixel.
        - Vertical reflection: `rr = nr + (nr - r)`, `rc = c`
        - Horizontal reflection: `rr = r`, `rc = nc + (nc - c)`
    c.  Check if the calculated reflected coordinates `(rr, rc)` are within the grid boundaries.
    d.  If the reflected coordinates are valid *and* the pixel at `output_grid[rr, rc]` currently holds the background color, update that pixel in the output grid with the original pixel's color `clr`.
6.  Return the modified output grid.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid, excluding red (2)."""
    counts = Counter(grid.flatten())
    # Remove red color if present
    if 2 in counts:
        del counts[2]
    # If grid only contains red or is empty after removing red
    if not counts:
        # Default to white (0) or handle as error, assuming a background exists
        # Based on examples, let's check if black (0) exists, else pick any non-red
        if 0 in Counter(grid.flatten()): return 0
        for color in grid.flatten():
            if color != 2: return color
        return 0 # Should not happen in valid ARC tasks with background
    # Return the most common color among the remaining ones
    return counts.most_common(1)[0][0]

def is_within_bounds(grid, r, c):
    """Checks if coordinates (r, c) are within the grid boundaries."""
    height, width = grid.shape
    return 0 <= r < height and 0 <= c < width

def transform(input_grid):
    """
    Applies the reflection transformation based on adjacent red pixels.
    """
    # Ensure input is a numpy array
    input_grid_np = np.array(input_grid, dtype=int)
    height, width = input_grid_np.shape

    # 1. Create the output grid as a copy
    output_grid = np.copy(input_grid_np)

    # 2. Determine the background color
    background_color = find_background_color(input_grid_np)

    # 3. Iterate through each pixel of the input grid
    for r in range(height):
        for c in range(width):
            clr = input_grid_np[r, c]

            # 4. Check if the pixel is neither red nor background
            if clr != 2 and clr != background_color:
                # Check cardinal neighbors
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc

                    # Check if neighbor is within bounds
                    if is_within_bounds(input_grid_np, nr, nc):
                        # 5. Check if neighbor is red
                        if input_grid_np[nr, nc] == 2:
                            reflected_pos = None
                            # 5a. Determine reflection axis and calculate reflected position
                            if c == nc:  # Red neighbor is above or below -> Vertical reflection
                                rr = nr + (nr - r)
                                rc = c
                                reflected_pos = (rr, rc)
                            elif r == nr:  # Red neighbor is left or right -> Horizontal reflection
                                rr = r
                                rc = nc + (nc - c)
                                reflected_pos = (rr, rc)

                            # 5c & 5d. Check bounds and update output if background
                            if reflected_pos:
                                rr, rc = reflected_pos
                                if is_within_bounds(output_grid, rr, rc) and output_grid[rr, rc] == background_color:
                                    output_grid[rr, rc] = clr

    # 6. Return the modified grid
    return output_grid.tolist() # Return as list of lists per ARC standard

```
```python
import numpy as np
from collections import Counter
import copy

"""
Transformation Rule Description:

1.  Initialize the output grid as a copy of the input grid.
2.  Determine the background color: This is the most frequent color in the input grid, excluding red (color 2). If only red exists or no dominant color excluding red, choose a default (e.g., 0) or the most frequent of the remaining colors.
3.  Iterate through each pixel `(r, c)` of the input grid.
4.  If the pixel's color `clr` is not red (2) and not the background color:
    a.  Check its 4 cardinal neighbors (up, down, left, right).
    b.  For each neighbor `(nr, nc)` that contains a red pixel (color 2):
        i.   Determine the orientation of the red structure at `(nr, nc)`. Check if the red pixel at `(nr, nc)` has red neighbors horizontally (`(nr, nc-1)` or `(nr, nc+1)`). If yes, classify the red structure locally as "horizontal". Otherwise, classify it as "vertical/point".
        ii.  If the red structure is classified as "horizontal":
             *   Calculate the reflected position `(rr, rc)` by reflecting vertically across the row `nr`: `rr = nr + (nr - r)`, `rc = c`.
        iii. If the red structure is classified as "vertical/point":
             *   Calculate the reflected position `(rr, rc)` by reflecting horizontally across the column `nc`: `rr = r`, `rc = nc + (nc - c)`.
        iv.  Check if the calculated reflected coordinates `(rr, rc)` are within the grid boundaries.
        v.   If the reflected coordinates are valid *and* the pixel at `output_grid[rr, rc]` currently holds the background color, update that pixel in the output grid with the original pixel's color `clr`.
5.  Return the modified output grid.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid, excluding red (2)."""
    counts = Counter(grid.flatten())
    if 2 in counts:
        del counts[2] # Exclude red
    
    if not counts:
        # Handle cases where grid is all red or empty after removing red
        # Check if 0 is present, often a default background
        all_counts = Counter(grid.flatten())
        if 0 in all_counts: return 0
        # If no 0, return the most frequent color overall (if grid not empty)
        if grid.size > 0:
            return Counter(grid.flatten()).most_common(1)[0][0]
        return 0 # Default fallback

    # Return the most common color among the remaining ones
    return counts.most_common(1)[0][0]

def is_within_bounds(grid_shape, r, c):
    """Checks if coordinates (r, c) are within the grid boundaries."""
    height, width = grid_shape
    return 0 <= r < height and 0 <= c < width

def transform(input_grid):
    """
    Applies the reflection transformation based on adjacent red pixels,
    considering the orientation of the red structure.
    """
    # Ensure input is a numpy array
    input_grid_np = np.array(input_grid, dtype=int)
    height, width = input_grid_np.shape
    grid_shape = (height, width)

    # 1. Initialize output_grid as a copy
    output_grid = np.copy(input_grid_np)

    # 2. Determine the background color
    background_color = find_background_color(input_grid_np)

    # 3. Iterate through each pixel of the input grid
    for r in range(height):
        for c in range(width):
            clr = input_grid_np[r, c]

            # 4. Check if the pixel is neither red nor background
            if clr != 2 and clr != background_color:
                # a. Check cardinal neighbors
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc

                    # Check if neighbor is within bounds
                    if is_within_bounds(grid_shape, nr, nc):
                        # b. Check if neighbor is red
                        if input_grid_np[nr, nc] == 2:
                            
                            # i. Determine Red Orientation at (nr, nc)
                            is_horizontal = False
                            # Check left neighbor
                            if nc > 0 and input_grid_np[nr, nc - 1] == 2:
                                is_horizontal = True
                            # Check right neighbor
                            if not is_horizontal and nc < width - 1 and input_grid_np[nr, nc + 1] == 2:
                                is_horizontal = True

                            reflected_pos = None
                            # ii/iii. Calculate Reflected Position (rr, rc)
                            if is_horizontal:
                                # Reflect vertically across row nr
                                rr = nr + (nr - r)
                                rc = c
                                reflected_pos = (rr, rc)
                            else: # Vertical Line or Single Point
                                # Reflect horizontally across column nc
                                rr = r
                                rc = nc + (nc - c)
                                reflected_pos = (rr, rc)

                            # iv/v. Check bounds and update output if background
                            if reflected_pos:
                                rr, rc = reflected_pos
                                if is_within_bounds(grid_shape, rr, rc) and output_grid[rr, rc] == background_color:
                                    output_grid[rr, rc] = clr

    # 6. Return the modified grid as a list of lists
    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter, deque

"""
Transformation Rule Description:

1.  Initialize the output grid as an identical copy of the input grid.
2.  Determine the background color: This is the most frequent color in the input grid, excluding red (color 2).
3.  Identify all distinct contiguous groups (objects) of pixels in the input grid using a method like Breadth-First Search (BFS). Store each object's color and the set of its pixel coordinates.
4.  Separate the identified objects into two categories: 'red_objects' (color 2) and 'reflectable_objects' (neither red nor background color).
5.  Classify each 'red_object' based on its shape:
    - 'H' (Horizontal Line): Height is 1, Width > 1.
    - 'V' (Vertical Line): Width is 1, Height > 1.
    - 'P' (Point): Height is 1, Width is 1.
    (Height/Width calculated from the min/max row/column of the object's pixels).
6.  Create a mapping from red pixel coordinates to the classified red object they belong to.
7.  Iterate through each 'reflectable_object'.
8.  For each reflectable object, check if any of its pixels are cardinally adjacent to any pixel belonging to a 'red_object'.
9.  If a reflectable object pixel `(r, c)` is adjacent to a red pixel `(nr, nc)`:
    a.  Identify the specific red object associated with `(nr, nc)` using the mapping created earlier. Get its classification ('H', 'V', or 'P').
    b.  Determine the reflection type based on the classification: Vertical for 'H', Horizontal for 'V' or 'P'.
    c.  Iterate through *all* pixels `(orig_r, orig_c)` of the current reflectable object.
    d.  Calculate the reflected coordinates `(rr, rc)` based on the reflection type and the coordinates of the *adjacent red pixel* `(nr, nc)` that triggered the reflection:
        *   Vertical Reflection (across row `nr`): `rr = nr + (nr - orig_r)`, `rc = orig_c`.
        *   Horizontal Reflection (across col `nc`): `rr = orig_r`, `rc = nc + (nc - orig_c)`.
    e.  Check if the calculated `(rr, rc)` is within the grid boundaries.
    f.  If `(rr, rc)` is within bounds AND the pixel at `output_grid[rr, rc]` currently holds the background color, update `output_grid[rr, rc]` with the color of the reflectable object.
    g. Once a reflection is triggered and processed for a reflectable object (due to adjacency with *one* red pixel), stop checking its other pixels for adjacency and move to the next reflectable object. (Assumption: An object is reflected only once based on its first detected adjacency).
10. Return the modified output grid as a list of lists.
"""

def find_background_color(grid):
    """Finds the most frequent color in the grid, excluding red (2)."""
    counts = Counter(grid.flatten())
    if 2 in counts:
        del counts[2] # Exclude red

    if not counts:
        all_counts = Counter(grid.flatten())
        if 0 in all_counts: return 0
        if grid.size > 0:
            # Find most frequent among all if no non-red exists or only red exists
            non_red_counts = Counter(c for c in grid.flatten() if c != 2)
            if non_red_counts:
                return non_red_counts.most_common(1)[0][0]
            # If truly only red, pick an arbitrary background like 0, though ARC tasks usually have backgrounds.
            return 0
        return 0 # Default fallback for empty grid

    return counts.most_common(1)[0][0]

def is_within_bounds(grid_shape, r, c):
    """Checks if coordinates (r, c) are within the grid boundaries."""
    height, width = grid_shape
    return 0 <= r < height and 0 <= c < width

def find_connected_components(grid):
    """Finds all contiguous objects (connected components) in the grid."""
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(height):
        for c in range(width):
            if not visited[r, c]:
                color = grid[r, c]
                component_pixels = set()
                q = deque([(r, c)])
                visited[r, c] = True
                component_pixels.add((r, c))

                while q:
                    row, col = q.popleft()
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if is_within_bounds((height, width), nr, nc) and \
                           not visited[nr, nc] and \
                           grid[nr, nc] == color:
                            visited[nr, nc] = True
                            component_pixels.add((nr, nc))
                            q.append((nr, nc))

                if component_pixels:
                    objects.append({'color': color, 'pixels': component_pixels})
    return objects

def classify_red_object(pixels):
    """Classifies a red object based on its pixel coordinates."""
    if not pixels:
        return None # Should not happen for valid objects

    rows = [r for r, c in pixels]
    cols = [c for r, c in pixels]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)

    height = max_r - min_r + 1
    width = max_c - min_c + 1

    if height == 1 and width > 1:
        return 'H' # Horizontal Line
    elif width == 1 and height > 1:
        return 'V' # Vertical Line
    elif height == 1 and width == 1:
        return 'P' # Point
    else:
        # Handle blocks or other shapes - Treat as 'P' for reflection?
        # Or base on adjacency? Examples only show lines/points as mirrors.
        # Let's default to 'P' (horizontal reflection) for blocks for now.
         return 'P'


def transform(input_grid):
    # Convert to numpy array
    input_grid_np = np.array(input_grid, dtype=int)
    height, width = input_grid_np.shape
    grid_shape = (height, width)

    # 1. Initialize output_grid as a copy
    output_grid = np.copy(input_grid_np)

    # 2. Determine background color
    background_color = find_background_color(input_grid_np)

    # 3. Find all connected components (objects)
    all_objects = find_connected_components(input_grid_np)

    # 4. Separate objects
    red_objects = []
    reflectable_objects = []
    red_pixel_map = {} # Map: red pixel coord -> its object info

    for obj in all_objects:
        if obj['color'] == 2:
            # 5. Classify Red Objects
            classification = classify_red_object(obj['pixels'])
            obj['classification'] = classification
            red_objects.append(obj)
            # 6. Create red pixel map
            for pixel in obj['pixels']:
                red_pixel_map[pixel] = obj
        elif obj['color'] != background_color:
            reflectable_objects.append(obj)

    # 7. Iterate through reflectable objects
    for r_obj in reflectable_objects:
        obj_color = r_obj['color']
        obj_pixels = r_obj['pixels']
        reflection_triggered = False
        
        # 8. Check for adjacency to any red pixel
        for r, c in obj_pixels:
            if reflection_triggered: # Only reflect once per object
                break
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc

                # 9. If adjacent to a red pixel
                if is_within_bounds(grid_shape, nr, nc) and input_grid_np[nr, nc] == 2:
                    # 9a. Identify the red object and its classification
                    if (nr, nc) in red_pixel_map:
                        adjacent_red_obj = red_pixel_map[(nr, nc)]
                        red_classification = adjacent_red_obj['classification']
                        reflection_triggered = True # Mark that reflection should happen

                        # 9b. Determine reflection type
                        reflect_vertically = (red_classification == 'H')

                        # 9c. Iterate through ALL pixels of the reflectable object
                        for orig_r, orig_c in obj_pixels:
                            # 9d. Calculate reflected coordinates based on adjacent red pixel (nr, nc)
                            rr, rc = -1, -1
                            if reflect_vertically:
                                rr = nr + (nr - orig_r)
                                rc = orig_c
                            else: # Reflect horizontally
                                rr = orig_r
                                rc = nc + (nc - orig_c)

                            # 9e. Check bounds
                            if is_within_bounds(grid_shape, rr, rc):
                                # 9f. Update output grid if background
                                if output_grid[rr, rc] == background_color:
                                    output_grid[rr, rc] = obj_color
                        
                        # 9g. Break neighbor check once reflection is done for this object
                        break 
            # Break pixel loop once reflection is triggered
            if reflection_triggered:
                break

    # 11. Return the modified grid as list of lists
    return output_grid.tolist()
```
