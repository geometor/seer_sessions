
## train_1

**input:**
```
3 3 3 4 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
4 4 4 4 3 3 3 3 3 4 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3
4 3 3 3 3 3 3 3 3 3 3 4 4 4 3 3 3 3 3 3 3 3 3 3 3
4 3 3 3 3 3 3 3 3 3 3 3 3 4 4 3 3 3 3 3 3 3 3 3 3
4 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
4 3 3 3 4 4 4 4 4 4 3 3 3 3 4 4 3 3 3 3 3 3 3 3 3
4 3 3 4 4 3 3 3 3 4 4 3 3 3 3 4 3 3 4 4 3 3 3 3 3
4 3 3 4 3 3 3 3 3 3 4 3 3 3 3 4 3 3 4 4 4 3 3 3 3
4 3 3 4 3 4 4 4 3 3 4 3 3 3 3 4 3 3 3 4 4 3 3 3 3
4 3 4 4 3 3 4 4 3 3 4 3 3 3 3 4 3 3 3 3 3 3 3 3 3
4 3 3 4 3 3 3 3 3 3 4 3 3 3 4 4 3 3 3 3 3 3 3 3 3
4 3 3 4 4 3 3 3 3 4 4 3 3 3 4 3 3 3 3 3 3 3 3 3 3
4 3 3 3 4 4 4 4 4 4 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
4 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
4 3 3 3 3 3 3 3 3 3 3 3 3 4 4 3 3 3 3 3 3 3 3 3 3
4 4 3 3 3 4 4 4 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3
3 4 3 3 3 4 4 4 3 3 3 3 4 4 3 3 3 3 3 3 3 3 3 3 3
3 4 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3
3 4 3 3 3 3 3 3 3 3 3 4 4 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
4 4 4 4 4 4 4 4 4 3 3 3
4 3 3 3 3 3 3 3 4 3 3 3
4 3 4 4 4 4 4 3 4 3 3 3
4 3 4 3 3 3 4 3 4 3 3 3
4 3 4 3 4 3 4 3 4 3 4 3
4 3 4 3 3 3 4 3 4 3 3 3
4 3 4 4 4 4 4 3 4 3 3 3
4 3 3 3 3 3 3 3 4 3 3 3
4 3 3 3 4 3 3 3 4 3 3 3
4 3 3 3 3 3 3 3 4 3 3 3
4 4 4 4 4 4 4 4 4 3 3 3
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 1 1 1 1 1
1 1 1 4 4 4 1 1 1 1 4 1 1 1 1 1
1 1 4 4 1 1 1 4 1 1 4 1 1 1 1 1
1 1 4 1 1 4 4 4 1 1 4 1 1 1 1 1
1 1 4 1 1 4 4 4 1 1 4 1 1 1 1 1
1 1 4 1 1 1 4 1 1 1 4 1 1 1 1 1
1 1 4 1 1 1 1 1 1 4 4 1 1 1 1 1
1 1 4 4 1 1 1 4 4 4 1 1 1 1 1 1
1 1 1 4 4 4 4 4 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
4 4 4 4 4
4 1 1 1 4
4 1 4 1 4
4 1 1 1 4
4 4 4 4 4
```


## train_3

**input:**
```
4 4 4 4 9 9 9 9 9 9 4 4 4 4 4 4
4 4 4 9 9 4 4 4 4 9 4 4 4 4 4 4
4 9 9 9 4 4 4 4 4 9 9 4 4 4 4 4
4 9 4 4 4 4 4 4 4 4 9 4 4 4 4 4
4 9 4 4 4 9 9 4 4 4 9 4 4 4 4 4
4 9 4 4 9 9 9 4 4 4 9 4 4 4 4 4
4 9 4 4 9 9 4 4 4 4 9 4 4 4 4 4
4 9 4 4 4 4 4 4 4 4 9 4 4 4 4 4
4 9 4 4 4 4 9 4 4 4 9 4 4 4 4 4
4 9 4 4 9 9 9 4 4 9 9 4 4 4 4 4
4 9 4 4 4 9 9 4 4 9 4 4 4 4 4 4
4 9 9 4 4 4 4 4 4 9 4 4 4 4 4 4
4 4 9 4 4 4 4 4 4 9 4 4 4 4 4 4
4 9 9 4 4 4 4 4 4 9 4 4 4 4 4 4
4 9 4 4 4 4 4 4 9 9 4 4 4 4 4 4
4 9 9 9 9 4 4 9 9 4 4 4 4 4 4 4
4 4 4 4 9 9 9 9 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
9 9 9 9 9
9 4 4 4 9
9 4 9 4 9
9 4 4 4 9
9 4 9 4 9
9 4 4 4 9
9 9 9 9 9
```


## train_4

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2
2 2 2 2 4 4 4 4 4 4 4 2 2 2 2 2 4 2 2 2 2 2 2 2 2
2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 4 4 2 2 2 2 2 2 2
2 2 2 2 4 2 2 2 4 4 4 4 4 4 2 2 2 4 4 4 2 2 2 2 2
2 2 2 2 4 2 2 4 4 2 2 2 2 4 2 2 2 2 2 4 4 2 2 2 2
2 2 2 2 4 2 2 4 2 2 4 4 2 4 2 2 2 2 2 2 4 2 2 2 2
2 2 2 2 4 2 2 4 2 4 4 4 2 4 2 4 4 4 2 2 4 2 2 2 2
2 2 2 2 4 4 2 4 2 4 4 4 2 4 2 4 4 2 2 2 4 2 2 2 2
2 2 2 2 2 4 2 4 2 2 2 2 2 4 2 2 2 2 2 4 4 2 2 2 2
2 2 2 2 2 4 2 4 4 4 2 2 4 4 2 2 2 4 4 4 2 2 2 2 2
2 2 2 2 2 4 2 2 2 4 4 4 4 2 2 2 4 4 2 2 2 2 2 2 2
2 2 2 2 2 4 4 2 2 2 2 2 2 2 2 4 4 2 2 2 2 2 2 2 2
2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4
4 2 2 2 2 2 2 2 2 2 4
4 2 4 4 4 4 4 2 2 2 4
4 2 4 2 2 2 4 2 2 2 4
4 2 4 2 4 2 4 2 4 2 4
4 2 4 2 2 2 4 2 2 2 4
4 2 4 4 4 4 4 2 2 2 4
4 2 2 2 2 2 2 2 2 2 4
4 4 4 4 4 4 4 4 4 4 4
```

*   **Perception:** The input grids are large and mostly filled with a single background color. Scattered within this background are pixels of a different, single "object" color. The output grid is a smaller subgrid extracted from the input. The output grid seems to capture the "interesting" part of the input, specifically the region containing all the pixels of the object color. The relative positions and colors of the pixels within this extracted region are preserved.

*   **YAML Facts:**
    
```yaml
    task_description: Extract the minimal bounding box containing all pixels of the non-background color.
    
    elements:
      - role: background
        description: The most frequent color in the input grid, filling most of the area.
        properties:
          - color: Varies (green, blue, yellow, red in examples)
          - frequency: Dominant
      - role: object_pixels
        description: Pixels of a single color different from the background color, forming one or more distinct clusters or shapes.
        properties:
          - color: Varies (yellow, yellow, maroon, yellow in examples)
          - frequency: Non-dominant
          - contiguity: Can be contiguous or scattered
      - role: bounding_box
        description: The smallest rectangular region enclosing all object_pixels.
        properties:
          - defined_by: min/max row and column of object_pixels
      - role: output_grid
        description: The subgrid extracted from the input based on the bounding_box.
        properties:
          - content: Pixels from the input within the bounding_box boundaries
          - dimensions: Determined by the bounding_box size
    
    relationships:
      - type: containment
        element1: input_grid
        element2: object_pixels
      - type: definition
        element1: object_pixels
        element2: bounding_box
      - type: extraction
        source: input_grid
        region: bounding_box
        result: output_grid
    
    actions:
      - identify_colors: Determine the background and object colors based on frequency.
      - locate_object_pixels: Find the coordinates (row, column) of all pixels matching the object color.
      - calculate_bounding_box: Compute the minimum and maximum row and column indices from the located object pixel coordinates.
      - extract_subgrid: Copy the portion of the input grid defined by the bounding box coordinates into a new grid (the output).
    ```


*   **Natural Language Program:**
    1.  Identify the two colors present in the input grid.
    2.  Determine which color is the background color (the most frequent one) and which is the object color (the less frequent one).
    3.  Find the locations (row and column indices) of all pixels that have the object color.
    4.  Calculate the minimum row index (`min_row`), maximum row index (`max_row`), minimum column index (`min_col`), and maximum column index (`max_col`) occupied by these object pixels.
    5.  Create a new output grid by extracting the rectangular subgrid from the input grid that starts at `min_row`, `min_col` and ends at `max_row`, `max_col` (inclusive). The content and colors of the pixels within this extracted region remain unchanged.
```python
import numpy as np
from collections import Counter

def find_bounding_box(grid, target_color):
    """
    Finds the minimum bounding box coordinates for a target color in the grid.

    Args:
        grid (np.array): The input grid.
        target_color (int): The color to find the bounding box for.

    Returns:
        tuple: (min_row, max_row, min_col, max_col) or None if target_color not found.
    """
    rows, cols = np.where(grid == target_color)
    if rows.size == 0:
        return None  # Target color not found
    min_row = np.min(rows)
    max_row = np.max(rows)
    min_col = np.min(cols)
    max_col = np.max(cols)
    return min_row, max_row, min_col, max_col

def transform(input_grid):
    """
    Extracts the minimal bounding box containing all pixels of the non-background color.

    1. Identify the two colors present in the input grid.
    2. Determine the background color (most frequent) and object color (less frequent).
    3. Find the locations (row, column) of all pixels with the object color.
    4. Calculate the minimum and maximum row and column indices (bounding box) for the object pixels.
    5. Extract the subgrid defined by the bounding box from the input grid.
    """
    # Convert input list of lists to a NumPy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    
    # Find unique colors and their counts
    unique_colors, counts = np.unique(grid, return_counts=True)

    if len(unique_colors) == 1:
        # If only one color exists, maybe return the whole grid or an empty one?
        # Based on examples, there are always at least two. Let's assume this.
        # If the single color is the 'object' color somehow, the bounding box is the whole grid.
        # If it's background, maybe return empty? Let's return the original grid for now.
        # Or perhaps, treat the single color as the 'object' and return the full grid.
         return input_grid # Or potentially an empty grid or handle as an error

    if len(unique_colors) > 2:
         # Find the most frequent color (background)
        background_color = unique_colors[np.argmax(counts)]
        # Find the object color(s) - assume the single least frequent? Or all non-background?
        # The prompt implies a single object color. Let's find the least frequent.
        object_color = unique_colors[np.argmin(counts)]
        # This might fail if there are multiple non-background colors with the same count.
        # Let's refine: Find the *second* most frequent, or simply the one that isn't the background.
        counts_dict = {color: count for color, count in zip(unique_colors, counts)}
        background_color = max(counts_dict, key=counts_dict.get)
        # Assume any color that is not the background is the object color.
        # If there are multiple, the problem description is slightly ambiguous.
        # The examples only show one non-background color.
        object_colors = [c for c in unique_colors if c != background_color]
        if len(object_colors) != 1:
             # If more than one non-background color, we need a clearer rule.
             # For now, let's pick the first one found. Or perhaps the least frequent non-bg?
             # Let's stick to the assumption of one object color based on examples.
             # Re-evaluating: Maybe the background is *always* the most frequent,
             # and *all* other colors contribute to the bounding box calculation?
             # Let's try that.
            rows, cols = np.where(grid != background_color)
            if rows.size == 0:
                 return [] # No object pixels found
            min_row = np.min(rows)
            max_row = np.max(rows)
            min_col = np.min(cols)
            max_col = np.max(cols)

        else:
             object_color = object_colors[0]
             # Find bounding box for the single object color
             bbox = find_bounding_box(grid, object_color)
             if bbox is None:
                 return [] # Should not happen if object_color exists
             min_row, max_row, min_col, max_col = bbox

    elif len(unique_colors) == 2:
        # Identify background (most frequent) and object (least frequent) colors
        if counts[0] > counts[1]:
            background_color = unique_colors[0]
            object_color = unique_colors[1]
        else:
            background_color = unique_colors[1]
            object_color = unique_colors[0]
            
        # Find the bounding box coordinates for the object color
        bbox = find_bounding_box(grid, object_color)
        if bbox is None:
            # This case implies the grid only had background color, handled above.
             return []
        min_row, max_row, min_col, max_col = bbox

    # Extract the subgrid using the bounding box coordinates
    # Slicing is inclusive of the start index and exclusive of the end index, so add 1 to max values
    output_grid_np = grid[min_row:max_row + 1, min_col:max_col + 1]

    # Convert the resulting NumPy array back to a list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
```python
import numpy as np
from collections import Counter

def transform(input_grid):
    """
    Extracts the minimal bounding box containing all pixels whose color is not the most frequent color (background color).

    1. Analyze the input grid to find unique colors and their frequencies.
    2. Identify the background color as the most frequent color.
    3. Locate all pixels that do *not* match the background color.
    4. If no such pixels exist, return an empty grid.
    5. Otherwise, determine the minimum and maximum row and column indices (bounding box) encompassing these non-background pixels.
    6. Extract the subgrid defined by this bounding box from the input grid.
    """
    # Convert input list of lists to a NumPy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    
    # Handle empty input grid case
    if grid.size == 0:
        return []

    # 1. Find unique colors and their counts
    unique_colors, counts = np.unique(grid, return_counts=True)

    # Handle the case where the grid has only one color
    if len(unique_colors) <= 1:
        # If only one color exists, it's the background, so no 'object' pixels exist.
        return [] 

    # 2. Determine the background color (most frequent)
    background_color = unique_colors[np.argmax(counts)]

    # 3. Locate all pixels that are *not* the background color
    object_pixels_coords = np.where(grid != background_color)

    # 4. If no non-background pixels are found, return an empty grid
    if object_pixels_coords[0].size == 0:
        return []

    # 5. Calculate the bounding box coordinates
    min_row = np.min(object_pixels_coords[0])
    max_row = np.max(object_pixels_coords[0])
    min_col = np.min(object_pixels_coords[1])
    max_col = np.max(object_pixels_coords[1])

    # 6. Extract the subgrid using the bounding box coordinates
    # Slicing is inclusive of start index, exclusive of end index, so add 1 to max values.
    output_grid_np = grid[min_row:max_row + 1, min_col:max_col + 1]

    # Convert the resulting NumPy array back to a list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
