{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, sum as ndi_sum\n\n\"\"\"\nIdentifies connected regions of white (0) pixels that are fully enclosed by a single, \ncontiguous non-white object (the border loop) and do not touch the grid edges. \nFor each such enclosed region:\n1. Determines the color of the border loop.\n2. Finds the largest distinct object (contiguous block of pixels of the same color) \n   located strictly within the region, excluding any objects that are white (0) \n   or match the color of the border loop. Notes the color and coordinates of this \n   largest interior object. If no such valid object exists, it's noted as None.\n3. Based on the border loop's color and the color of the largest valid interior object \n   (or None), a specific fill color is determined using a predefined mapping.\n4. All pixels within the originally enclosed white region are changed to this fill color \n   in the output grid, *except* for the pixels belonging to the largest interior \n   object identified in step 2 (if one exists). \nPixels forming the border loop, pixels of the largest interior object, and pixels \nin unenclosed regions or outside any loop remain unchanged from the input.\n\nThe fill color mapping is derived from the examples:\n- Border Red(2), Largest Interior Blue(1) -> Fill Green(3)\n- Border Yellow(4), Largest Interior Blue(1) -> Fill Gray(5)\n- Border Red(2), Largest Interior Yellow(4) -> Fill Maroon(9)\n- Border Blue(1), No valid Interior Object -> Fill Magenta(6)\n- Border Green(3), No valid Interior Object -> Fill Green(3)\n- Border Magenta(6), No valid Interior Object -> Fill Orange(7)\n- Border Yellow(4), No valid Interior Object -> Fill Yellow(4)\n- Border Orange(7), No valid Interior Object -> Fill Magenta(6) \n\"\"\"\n\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Get valid orthogonal neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Fills enclosed white areas based on border color and largest interior object color,\n    preserving the largest interior object.\n    \"\"\"\n    # Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define the fill color mapping based on (border_color, largest_interior_color)\n    # Use None for largest_interior_color if no relevant interior object exists.\n    fill_map = {\n        (2, 1): 3,  # Border: Red, Inner: Blue -> Fill: Green\n        (4, 1): 5,  # Border: Yellow, Inner: Blue -> Fill: Gray\n        (2, 4): 9,  # Border: Red, Inner: Yellow -> Fill: Maroon\n        (1, None): 6, # Border: Blue, Inner: None -> Fill: Magenta\n        (3, None): 3, # Border: Green, Inner: None -> Fill: Green\n        (6, None): 7, # Border: Magenta, Inner: None -> Fill: Orange\n        (4, None): 4, # Border: Yellow, Inner: None -> Fill: Yellow\n        (7, None): 6, # Border: Orange, Inner: None -> Fill: Magenta\n    }\n\n    # Define structure for orthogonal connectivity\n    structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=bool)\n\n    # Label all non-white connected components (potential borders)\n    labeled_objects, _ = label(input_grid != 0, structure=structure)\n\n    # Identify all distinct connected regions of white (0) pixels in the input grid.\n    labeled_white, num_white_labels = label(input_grid == 0, structure=structure)\n\n    # Iterate through each identified white region.\n    for w_label in range(1, num_white_labels + 1):\n        \n        # Get coordinates of the current white region\n        white_coords_list = np.argwhere(labeled_white == w_label)\n        if white_coords_list.size == 0:\n            continue # Should not happen, but safe check\n\n        # Create a boolean mask for the current white region for easier indexing later\n        # This mask identifies the pixels *originally* white in this component.\n        original_white_mask = (labeled_white == w_label)\n\n        # Check if any pixel of the white region lies on the outermost border of the grid.\n        touches_boundary = np.any(white_coords_list[:, 0] == 0) or \\\n                           np.any(white_coords_list[:, 0] == height - 1) or \\\n                           np.any(white_coords_list[:, 1] == 0) or \\\n                           np.any(white_coords_list[:, 1] == width - 1)\n        \n        # If it touches the boundary, this region is not enclosed; skip to the next white region.\n        if touches_boundary:\n            continue \n\n        # Determine the set of unique, contiguous, non-white objects adjacent to the current white region.\n        adjacent_object_labels = set()\n        for r, c in white_coords_list:\n            # Check orthogonal neighbors\n            for nr, nc in get_neighbors(r, c, height, width):\n                obj_label = labeled_objects[nr, nc]\n                # If the neighbor is part of a non-white object (label > 0)\n                if obj_label != 0: \n                    adjacent_object_labels.add(obj_label)\n\n        # If the set contains *exactly one* non-white object label, the region is enclosed by a single border_loop.\n        if len(adjacent_object_labels) == 1:\n            border_label = list(adjacent_object_labels)[0]\n            \n            # Find the color of the border object (border_color)\n            border_coords = np.argwhere(labeled_objects == border_label)\n            if border_coords.size == 0 : \n                continue \n            border_color = input_grid[border_coords[0, 0], border_coords[0, 1]]\n\n            # --- Find the largest interior object (non-white, non-border color) ---\n            \n            # Create a mask for pixels within the original white region bounds \n            # that are *not* white and *not* the border color in the input grid.\n            potential_interior_obj_mask = original_white_mask & (input_grid != 0) & (input_grid != border_color)\n            \n            # Label connected components within this specific mask\n            labeled_interior_objs, num_interior_objs = label(potential_interior_obj_mask, structure=structure)\n\n            largest_interior_object_color = None\n            largest_obj_mask = np.zeros_like(input_grid, dtype=bool) # Mask for the largest object's pixels\n\n            # If one or more valid interior objects exist\n            if num_interior_objs > 0:\n                interior_obj_indices = np.arange(1, num_interior_objs + 1)\n                # Sum the boolean mask 'potential_interior_obj_mask' over areas defined by 'labeled_interior_objs'\n                object_sizes = ndi_sum(potential_interior_obj_mask, labeled_interior_objs, index=interior_obj_indices)\n\n                if object_sizes.size > 0:\n                    # Find the label corresponding to the largest size\n                    largest_obj_local_label_idx = np.argmax(object_sizes)\n                    largest_obj_label = interior_obj_indices[largest_obj_local_label_idx]\n                    \n                    # Create the mask for the largest object\n                    largest_obj_mask = (labeled_interior_objs == largest_obj_label)\n                    \n                    # Find coordinates of this largest object to determine its color\n                    largest_obj_coords = np.argwhere(largest_obj_mask)\n                    if largest_obj_coords.size > 0:\n                        largest_interior_object_color = input_grid[largest_obj_coords[0, 0], largest_obj_coords[0, 1]]\n\n            # --- Determine the fill color using the map ---\n            fill_key = (border_color, largest_interior_object_color)\n            fill_color = fill_map.get(fill_key) \n\n            # --- Apply the fill color ---\n            if fill_color is not None:\n                # Define the mask for pixels to be filled:\n                # They must be part of the original white region (original_white_mask)\n                # AND they must *not* be part of the largest interior object (if one exists)\n                fill_mask = original_white_mask & (~largest_obj_mask)\n                \n                # Apply the fill color to the output grid using the calculated mask\n                output_grid[fill_mask] = fill_color\n\n    # Return the final modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18539,
    "candidates_token_count": 2182,
    "total_token_count": 20721,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.724388,
  "retries": 1
}