
## train_1

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3
3 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 8 3 3
3 3 3 8 3 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 3 3
3 3 3 3 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 8 3 8 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 4 3 4 3 3 3 3 3 3 3 3 3
0 8 0 0 0 0 0 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 4 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 2 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0
0 8 0 8 0 8 0
0 0 0 0 0 0 0
0 4 0 0 0 0 0
0 0 0 0 0 0 0
0 2 0 2 0 0 0
0 0 0 0 0 0 0
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 2 1 1 1 1 1 1 1 0 8 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 3 3 3 1 0 3 0 0 0 0 0 0 0 0 0 0
1 3 1 1 1 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 4 1 1 1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 4 4 4 1 1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 1 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 4 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 1 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 4 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
0 0 0 0 0
0 1 0 1 0
0 0 0 0 0
0 4 0 0 0
0 0 0 0 0
```

*   **Perception:** The input grids are relatively large and contain a dominant background color (green, blue, or azure). Scattered across this background are various small colored shapes or individual pixels. Crucially, each input grid contains a single rectangular area composed entirely of white (0) pixels. Within this white rectangle, there are a few non-white pixels. The output grid is significantly smaller than the input and corresponds exactly in size to the white rectangular area found in the input. The content of the output grid consists of the non-white pixels from within the input's white rectangle, placed at the same relative positions, against a white background. All other elements from the input grid are discarded.

*   **YAML Facts:**
    
```yaml
    task_description: Extract the content of the white rectangular region from the input grid.
    
    elements:
      - element: input_grid
        description: A 2D grid of pixels with varying dimensions and a dominant background color.
        properties:
          - contains_background_pixels
          - contains_scattered_colored_pixels
          - contains_white_rectangle: A single contiguous rectangular area composed solely of white (0) pixels.
            sub_elements:
              - element: internal_pixels
                description: Pixels located within the bounds of the white rectangle.
                properties:
                  - can_be_white: Part of the rectangle's background.
                  - can_be_non_white: Represent the content to be extracted.
      - element: output_grid
        description: A 2D grid whose dimensions match the white rectangle from the input.
        properties:
          - background_color: white (0)
          - content: Consists of the non-white pixels extracted from the input's white rectangle.
          - pixel_positions: The relative positions of non-white pixels within the output match their relative positions within the input's white rectangle.
    
    transformation:
      - action: find_white_rectangle
        input: input_grid
        output: coordinates (top-left, bottom-right) and dimensions (height, width) of the white rectangle.
        condition: Identify the largest contiguous rectangular block of white (0) pixels.
      - action: extract_content
        input: input_grid, white_rectangle_coordinates
        output: list of non-white pixels and their relative coordinates within the rectangle.
        details: Iterate through the pixels within the rectangle's bounds. Record the color and relative position (row - top_row, col - left_col) for any non-white pixel.
      - action: create_output_grid
        input: white_rectangle_dimensions, extracted_content
        output: output_grid
        details: Initialize a new grid with the same height and width as the white rectangle, filled with white (0). Place the extracted non-white pixels onto this grid at their recorded relative coordinates.
    
    relationships:
      - relationship: size_correspondence
        element1: output_grid
        element2: white_rectangle (from input_grid)
        property: The height and width of the output grid are identical to the height and width of the white rectangle.
      - relationship: content_mapping
        element1: non-white pixels inside white_rectangle (input_grid)
        element2: non-white pixels in output_grid
        property: For each non-white pixel in the input's white rectangle at relative position (r, c), there is an identical non-white pixel at position (r, c) in the output grid.
    ```


*   **Natural Language Program:**
    1.  Identify the unique, contiguous rectangular region within the input grid that consists entirely of white (0) pixels. Determine its top-left corner coordinates, height, and width.
    2.  Create a new output grid with the same height and width as the identified white rectangle. Initialize all pixels in the output grid to white (0).
    3.  Iterate through each pixel within the bounds of the white rectangle in the input grid.
    4.  For each pixel examined in step 3, if its color is not white (0), copy its color to the corresponding relative position in the output grid. The relative position is calculated by subtracting the top-left corner coordinates of the white rectangle from the pixel's absolute coordinates in the input grid.
    5.  The final output grid contains the non-white content of the input's white rectangle, preserving relative positions, on a white background.
```python
import numpy as np
import sys

# Increase recursion depth for potentially deep searches in helper functions, although not strictly needed for this specific solution.
# sys.setrecursionlimit(2000) 

"""
Identify the unique, contiguous rectangular region within the input grid that consists entirely of white (0) pixels. Determine its top-left corner coordinates, height, and width. Create a new output grid with the same height and width as the identified white rectangle, initialized to white (0). Iterate through each pixel within the bounds of the white rectangle in the input grid. For each pixel examined, if its color is not white (0), copy its color to the corresponding relative position in the output grid. The relative position is calculated by subtracting the top-left corner coordinates of the white rectangle from the pixel's absolute coordinates in the input grid. The final output grid contains the non-white content of the input's white rectangle, preserving relative positions, on a white background.
"""

def find_largest_white_rectangle(grid):
    """
    Finds the largest rectangular area composed entirely of white (0) pixels.

    Args:
        grid (np.array): The input grid.

    Returns:
        tuple: (min_row, max_row, min_col, max_col) coordinates of the largest 
               white rectangle, or None if no white pixel is found. Returns coordinates inclusive.
    """
    rows, cols = grid.shape
    if rows == 0 or cols == 0:
        return None

    # Precompute heights of consecutive white cells ending at (r, c) looking upwards.
    heights = np.zeros((rows, cols), dtype=int)
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 0:
                heights[r, c] = heights[r - 1, c] + 1 if r > 0 else 1
            else:
                heights[r, c] = 0

    max_area = 0
    best_rect = None # (min_row, max_row, min_col, max_col)

    # For each row, treat it as the bottom row of potential rectangles
    # and compute the largest rectangle using the histogram approach.
    for r in range(rows):
        stack = [] # Stores indices of columns (potential left boundaries)
        for c in range(cols + 1): # Iterate through columns + one extra to flush stack
            h = heights[r, c] if c < cols else 0 # Current height
            
            while stack and heights[r, stack[-1]] >= h:
                height = heights[r, stack.pop()]
                width = c if not stack else c - stack[-1] - 1
                area = height * width
                
                if area > max_area:
                    max_area = area
                    min_c = stack[-1] + 1 if stack else 0
                    max_c = c - 1
                    min_r = r - height + 1
                    max_r = r
                    best_rect = (min_r, max_r, min_c, max_c)
                    
            stack.append(c)

    return best_rect


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by extracting the non-white content from the largest 
    all-white rectangular area.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the output grid.
    """
    
    # Find the largest rectangle composed entirely of white pixels (0)
    rect_coords = find_largest_white_rectangle(input_grid)

    if rect_coords is None:
        # Handle edge case where no white rectangle is found (though examples suggest one exists)
        # Returning an empty grid might be appropriate, or based on problem constraints.
        # Let's assume based on examples, a rectangle will always be found.
        # If this assumption is wrong, error handling or returning input_grid might be needed.
         print("Warning: No white rectangle found.") 
         # Return 1x1 white grid as a fallback
         return np.zeros((1, 1), dtype=int)


    min_row, max_row, min_col, max_col = rect_coords
    
    # Calculate the dimensions of the rectangle
    rect_height = max_row - min_row + 1
    rect_width = max_col - min_col + 1

    # Initialize the output grid with the dimensions of the rectangle, filled with white (0)
    output_grid = np.zeros((rect_height, rect_width), dtype=int)

    # Iterate through the found rectangle in the input grid
    for r in range(rect_height):
        for c in range(rect_width):
            # Get the corresponding coordinates in the input grid
            input_r = min_row + r
            input_c = min_col + c
            
            # Get the pixel value from the input grid within the rectangle
            pixel_value = input_grid[input_r, input_c]
            
            # If the pixel is not white (0), copy it to the output grid
            # Note: The problem statement focuses on copying NON-white pixels from the 
            # WHITE rectangle area. So, even if the rectangle definition found includes 
            # non-white pixels (which it shouldn't by definition of find_largest_white_rectangle),
            # we only copy non-white ones.
            if pixel_value != 0:
                output_grid[r, c] = pixel_value
                
    return output_grid
```

Previous Code:
```python
import numpy as np
import sys

# Increase recursion depth for potentially deep searches in helper functions, although not strictly needed for this specific solution.
# sys.setrecursionlimit(2000) 

"""
Identify the unique, contiguous rectangular region within the input grid that consists entirely of white (0) pixels. Determine its top-left corner coordinates, height, and width. Create a new output grid with the same height and width as the identified white rectangle, initialized to white (0). Iterate through each pixel within the bounds of the white rectangle in the input grid. For each pixel examined, if its color is not white (0), copy its color to the corresponding relative position in the output grid. The relative position is calculated by subtracting the top-left corner coordinates of the white rectangle from the pixel's absolute coordinates in the input grid. The final output grid contains the non-white content of the input's white rectangle, preserving relative positions, on a white background.
"""

def find_largest_white_rectangle(grid):
    """
    Finds the largest rectangular area composed entirely of white (0) pixels.

    Args:
        grid (np.array): The input grid.

    Returns:
        tuple: (min_row, max_row, min_col, max_col) coordinates of the largest 
               white rectangle, or None if no white pixel is found. Returns coordinates inclusive.
    """
    rows, cols = grid.shape
    if rows == 0 or cols == 0:
        return None

    # Precompute heights of consecutive white cells ending at (r, c) looking upwards.
    heights = np.zeros((rows, cols), dtype=int)
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 0:
                heights[r, c] = heights[r - 1, c] + 1 if r > 0 else 1
            else:
                heights[r, c] = 0

    max_area = 0
    best_rect = None # (min_row, max_row, min_col, max_col)

    # For each row, treat it as the bottom row of potential rectangles
    # and compute the largest rectangle using the histogram approach.
    for r in range(rows):
        stack = [] # Stores indices of columns (potential left boundaries)
        for c in range(cols + 1): # Iterate through columns + one extra to flush stack
            h = heights[r, c] if c < cols else 0 # Current height
            
            while stack and heights[r, stack[-1]] >= h:
                height = heights[r, stack.pop()]
                width = c if not stack else c - stack[-1] - 1
                area = height * width
                
                if area > max_area:
                    max_area = area
                    min_c = stack[-1] + 1 if stack else 0
                    max_c = c - 1
                    min_r = r - height + 1
                    max_r = r
                    best_rect = (min_r, max_r, min_c, max_c)
                    
            stack.append(c)

    return best_rect


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by extracting the non-white content from the largest 
    all-white rectangular area.

    Args:
        input_grid (np.array): A 2D numpy array representing the input grid.

    Returns:
        np.array: A 2D numpy array representing the output grid.
    """
    
    # Find the largest rectangle composed entirely of white pixels (0)
    rect_coords = find_largest_white_rectangle(input_grid)

    if rect_coords is None:
        # Handle edge case where no white rectangle is found (though examples suggest one exists)
        # Returning an empty grid might be appropriate, or based on problem constraints.
        # Let's assume based on examples, a rectangle will always be found.
        # If this assumption is wrong, error handling or returning input_grid might be needed.
         print("Warning: No white rectangle found.") 
         # Return 1x1 white grid as a fallback
         return np.zeros((1, 1), dtype=int)


    min_row, max_row, min_col, max_col = rect_coords
    
    # Calculate the dimensions of the rectangle
    rect_height = max_row - min_row + 1
    rect_width = max_col - min_col + 1

    # Initialize the output grid with the dimensions of the rectangle, filled with white (0)
    output_grid = np.zeros((rect_height, rect_width), dtype=int)

    # Iterate through the found rectangle in the input grid
    for r in range(rect_height):
        for c in range(rect_width):
            # Get the corresponding coordinates in the input grid
            input_r = min_row + r
            input_c = min_col + c
            
            # Get the pixel value from the input grid within the rectangle
            pixel_value = input_grid[input_r, input_c]
            
            # If the pixel is not white (0), copy it to the output grid
            # Note: The problem statement focuses on copying NON-white pixels from the 
            # WHITE rectangle area. So, even if the rectangle definition found includes 
            # non-white pixels (which it shouldn't by definition of find_largest_white_rectangle),
            # we only copy non-white ones.
            if pixel_value != 0:
                output_grid[r, c] = pixel_value
                
    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3
3 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 8 3 3
3 3 3 8 3 8 3 3 3 3 3 3 3 3 3 3 3 3 8 3 3 3
3 3 3 3 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 8 3 8 3 3 3 3 3 3 3
3 3 2 2 3 3 3 3 3 3 3 3 3 8 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 4 3 4 3 3 3 3 3 3 3 3 3
0 8 0 0 0 0 0 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 4 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3
0 2 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
0 0 0 0 0 0 0
0 8 0 8 0 8 0
0 0 0 0 0 0 0
0 4 0 0 0 0 0
0 0 0 0 0 0 0
0 2 0 2 0 0 0
0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 2:
Input:
```
1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1 1 1 1 0 2 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 2 1 1 1 1 1 1 1 0 8 0 0 0 0 0 0 0 0 0 0
1 1 2 2 2 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 3 3 3 1 0 3 0 0 0 0 0 0 0 0 0 0
1 3 1 1 1 1 1 1 3 1 1 0 0 0 0 0 0 0 0 0 0 0 0
3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1 1
1 1 1 1 8 1 8 1 1 1 1 1 1 1 1 8 1 8 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 1 1
1 1 1 1 1 4 1 1 1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 4 4 4 1 1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 0 8 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 3 0 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 3:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 1 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 4 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 0 0 0 0 0 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 1 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 2 2 8 8 8 8 8 8 8 4 4 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
0 0 0 0 0
0 1 0 1 0
0 0 0 0 0
0 4 0 0 0
0 0 0 0 0
```
Transformed Output:
```
0 0 0
0 0 0
0 0 0
0 0 0
0 0 0
```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None
**General Assessment:**

The previous code correctly identified the overall goal: extracting content from a white rectangular region within the input. However, the `find_largest_white_rectangle` function failed to correctly identify the target rectangle in all training examples, leading to output grids of incorrect dimensions and missing content. The function appears to be finding *some* rectangle of white pixels, but not the specific one that contains the relevant non-white pixels for the output.

The strategy must be revised to correctly identify the specific white rectangle relevant to the transformation. Observation suggests there is only one such prominent white rectangle in each input that frames the non-white pixels seen in the output. The identification logic needs to reliably find *this* rectangle, not just any large white rectangle.

**Metrics Gathering:**

Let's analyze the expected output dimensions and compare them with the rectangle found by the previous `find_largest_white_rectangle` function. We also need to determine the coordinates and dimensions of the *actual* white rectangle corresponding to the output.


