
## train_1

**input:**
```
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 8 0 1 0 1 0 1
1 0 1 0 1 0 3 0 8 0 1 0 1 0
0 1 0 1 0 3 0 3 0 8 0 1 0 1
1 0 1 0 3 0 1 0 3 0 1 0 1 0
0 1 0 8 0 3 0 3 0 1 0 1 0 1
1 0 1 0 8 0 3 0 1 0 1 0 1 0
0 1 0 1 0 8 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
```


**output:**
```
1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 8
1 0 1 0 1 0 1 0 1 0 1 0 8 0
0 1 0 1 0 1 0 1 0 1 0 8 0 1
1 0 1 0 1 0 1 0 1 0 8 0 1 0
0 1 0 1 0 1 0 1 0 8 0 1 0 8
1 0 1 0 1 0 1 0 8 0 1 0 8 0
0 1 0 1 0 1 0 8 0 1 0 8 0 1
1 0 1 0 1 0 3 0 8 0 8 0 1 0
0 1 0 1 0 3 0 3 0 8 0 1 0 1
1 0 1 0 3 0 1 0 3 0 1 0 1 0
0 1 0 8 0 3 0 3 0 1 0 1 0 1
1 0 8 0 8 0 3 0 1 0 1 0 1 0
0 8 0 1 0 8 0 1 0 1 0 1 0 1
8 0 1 0 8 0 1 0 1 0 1 0 1 0
0 1 0 8 0 1 0 1 0 1 0 1 0 1
1 0 8 0 1 0 1 0 1 0 1 0 1 0
0 8 0 1 0 1 0 1 0 1 0 1 0 1
8 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1
```


## train_2

**input:**
```
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 2 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 2 0 3 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 2 0 3 0 3 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 3 0 1 0 3 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 4 0 3 0 3 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 4 0 3 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 4 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
```


**output:**
```
1 0 2 0 1 0 2 0 1 0 1 0 1 0 4 0 1 0 4 0 1 0 1 0 1 0 1 0 1 0
0 1 0 2 0 1 0 2 0 1 0 1 0 4 0 1 0 4 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 2 0 1 0 2 0 1 0 4 0 1 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 2 0 1 0 2 0 4 0 1 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 2 0 2 0 3 0 4 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 2 0 3 0 3 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 1 0 3 0 1 0 3 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 4 0 3 0 3 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 1 0 4 0 4 0 3 0 2 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 4 0 1 0 4 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 0 1 0 4 0 1 0 4 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 4 0 1 0 4 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0 1 0 1
1 0 4 0 1 0 4 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0 1 0
0 4 0 1 0 4 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0 1
4 0 1 0 4 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1 0
0 1 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0 1
1 0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1 0
0 4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0 1
4 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 2 0 1 0 2
```

*   **Perception of Task Elements:**
    *   The input and output grids share a common checkerboard background pattern of blue (1) and white (0) pixels.
    *   The input grids contain sparsely distributed "source" pixels of other colors (azure-8, green-3 in train\_1; red-2, green-3, yellow-4 in train\_2).
    *   The transformation involves modifying the blue (1) pixels based on the locations of specific source pixels.
    *   In the output grids, the source pixels seem to 'radiate' or 'propagate' their color along diagonal lines.
    *   This propagation replaces the blue (1) pixels along these diagonal lines, while white (0) pixels and green (3) pixels remain unchanged.
    *   The propagation extends outwards from the source pixel location to the boundaries of the grid.
    *   Only certain source colors (azure-8, red-2, yellow-4) participate in this propagation; green (3) pixels do not.

*   **YAML Facts:**
    
```yaml
    task_context:
      grid_properties:
        - background: Checkerboard pattern of blue (1) and white (0).
        - dimensions: Variable height and width.
      objects:
        - type: background_pixel
          colors: [blue (1), white (0)]
          role: Forms the base pattern, blue pixels are targets for modification.
        - type: source_pixel
          colors: [azure (8), red (2), yellow (4)] # Propagating colors
          role: Initiate diagonal propagation.
        - type: inert_pixel
          colors: [green (3)] # Non-propagating color
          role: Present in the grid but does not affect the transformation.
    transformation:
      action: diagonal_propagation
      actor: source_pixel (azure, red, yellow)
      target: background_pixel (blue)
      rule:
        - Identify all source pixels (azure, red, yellow) in the input grid.
        - For each source pixel:
          - Trace four diagonal lines (up-left, up-right, down-left, down-right) starting from the source pixel's location.
          - Along each traced diagonal line:
            - If a pixel location contains a blue (1) pixel in the input grid:
              - Change the color of that pixel in the output grid to the color of the source pixel that initiated the trace.
      constraints:
        - Propagation only affects blue (1) pixels.
        - White (0) pixels and inert pixels (green-3) are unaffected by propagation.
        - Propagation stops at the grid boundaries.
        - The state of the grid for determining propagation targets is the original input grid state.
      output_composition:
        - Start with a copy of the input grid.
        - Apply all modifications caused by propagation from all source pixels.
        - Inert pixels (green-3) and the original source pixels remain in their input locations.
        - White pixels remain unchanged unless a source pixel was located there (which doesn't seem to happen in examples).
    ```


*   **Natural Language Program:**
    1.  Create a copy of the input grid to serve as the initial output grid.
    2.  Identify all pixels in the input grid that have a "propagating color": azure (8), red (2), or yellow (4). Record their locations and colors.
    3.  For each identified propagating pixel (let its location be `(row, col)` and its color be `prop_color`):
        a.  Trace the **up-left** diagonal: Iterate `i` from 1 upwards. Calculate the position `(row - i, col - i)`. If this position is within the grid boundaries and the pixel at `(row - i, col - i)` in the *original input grid* is blue (1), change the pixel at `(row - i, col - i)` in the *output grid* to `prop_color`. Stop this trace when the position goes out of bounds.
        b.  Trace the **up-right** diagonal: Iterate `i` from 1 upwards. Calculate the position `(row - i, col + i)`. If this position is within the grid boundaries and the pixel at `(row - i, col + i)` in the *original input grid* is blue (1), change the pixel at `(row - i, col + i)` in the *output grid* to `prop_color`. Stop this trace when the position goes out of bounds.
        c.  Trace the **down-left** diagonal: Iterate `i` from 1 upwards. Calculate the position `(row + i, col - i)`. If this position is within the grid boundaries and the pixel at `(row + i, col - i)` in the *original input grid* is blue (1), change the pixel at `(row + i, col - i)` in the *output grid* to `prop_color`. Stop this trace when the position goes out of bounds.
        d.  Trace the **down-right** diagonal: Iterate `i` from 1 upwards. Calculate the position `(row + i, col + i)`. If this position is within the grid boundaries and the pixel at `(row + i, col + i)` in the *original input grid* is blue (1), change the pixel at `(row + i, col + i)` in the *output grid* to `prop_color`. Stop this trace when the position goes out of bounds.
    4.  Return the modified output grid.
```python
import numpy as np

"""
Transforms the input grid by propagating specific source colors (azure-8, red-2, yellow-4) diagonally outwards.

The transformation works as follows:
1. Identify all pixels with propagating colors (azure-8, red-2, yellow-4) in the input grid.
2. For each identified source pixel:
   - Trace four diagonal lines (up-left, up-right, down-left, down-right) starting from the source pixel's location.
   - Along each diagonal line, if a pixel location in the original input grid contains a blue (1) pixel, change the color of that pixel in the output grid to the color of the source pixel that initiated the trace.
3. Pixels with other colors (white-0, green-3) and the original source pixels themselves remain unchanged, except for blue pixels modified by propagation.
4. Propagation stops at the grid boundaries.
"""

def transform(input_grid):
    """
    Applies the diagonal color propagation transformation to the input grid.

    Args:
        input_grid (list of lists): A 2D list representing the input grid.

    Returns:
        list of lists: A 2D list representing the transformed output grid.
    """
    # Convert input list of lists to a numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Initialize output grid as a copy of the input grid
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # Define the colors that propagate
    propagating_colors = {2, 4, 8} # red, yellow, azure
    # Define the color that gets overwritten
    target_color = 1 # blue

    # Find all source pixels with propagating colors
    source_pixels = []
    for r in range(height):
        for c in range(width):
            if input_np[r, c] in propagating_colors:
                source_pixels.append(((r, c), input_np[r, c]))

    # Define the four diagonal directions (delta_row, delta_col)
    directions = [
        (-1, -1), # up-left
        (-1, 1),  # up-right
        (1, -1),  # down-left
        (1, 1)   # down-right
    ]

    # Process each source pixel
    for (r_src, c_src), prop_color in source_pixels:
        # Propagate in each of the four diagonal directions
        for dr, dc in directions:
            # Start tracing from the position next to the source pixel
            for step in range(1, max(height, width)): # Max possible steps
                nr, nc = r_src + dr * step, c_src + dc * step

                # Check if the new position is within grid boundaries
                if 0 <= nr < height and 0 <= nc < width:
                    # Check if the pixel at the new position in the *original* input grid is the target color (blue)
                    if input_np[nr, nc] == target_color:
                        # Update the corresponding pixel in the output grid with the propagating color
                        output_np[nr, nc] = prop_color
                    # Note: Propagation continues even if it hits a non-target color,
                    # but only overwrites target colors. This seems implied by the examples
                    # where propagation lines can "pass through" other colors without stopping.
                    # If propagation should stop upon hitting *any* non-target color,
                    # an 'else: break' would be needed here. Based on outputs, it seems
                    # it only stops at boundaries or only *affects* blue cells.
                else:
                    # Stop tracing in this direction if out of bounds
                    break

    # Convert the final numpy array back to a list of lists
    output_grid = output_np.tolist()
    return output_grid
```
