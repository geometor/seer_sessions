
## train_1

**input:**
```
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 1 1 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
8 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
6 8 8 8 8 8 1 8 8 8 8 8 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
7 8 8 8 8 7 1 8 8 8 8 8 8 8 8 8
6 7 7 7 7 7 1 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 1 1 8 8 8 8
8 8 8 8 1 1 8 8 8 8
8 8 8 8 1 1 8 8 8 1
8 8 8 8 8 8 8 8 8 1
1 8 8 8 8 8 8 8 8 1
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8
6 8 8 8 8 1 1 8 8 8
```


**output:**
```
7 7 7 7 1 1 7 7 7 7
7 8 8 7 1 1 7 8 7 7
7 8 8 7 1 1 7 8 7 1
7 7 8 7 7 7 7 8 7 1
1 7 8 8 8 8 8 8 7 1
7 7 8 8 8 8 8 8 7 7
7 8 8 8 8 8 8 8 8 7
7 8 8 8 8 7 7 7 8 7
7 8 8 8 7 7 1 7 8 7
6 7 7 7 7 1 1 7 7 7
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 8 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 1 8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8
1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
6 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 1 7 7 7 7 7 7 7
7 8 8 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
7 7 8 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 7 7 8 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 1 7 7 8 8 8 8 8 8 8 7 1 7 8 8 8 8 8 7
1 1 1 7 7 8 8 8 8 8 8 7 7 7 8 8 8 8 8 7
1 1 1 1 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
1 1 1 1 1 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
1 1 1 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 7
7 7 7 7 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 7
7 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
7 8 8 8 8 8 8 8 8 8 8 8 8 7 1 1 1 1 1 1
6 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 1 1 1
```

*   **Perception:**
    *   The input and output grids have the same dimensions.
    *   The input grids contain a gray (8) background, some blue (1) structures that act like walls or barriers, and a single magenta (6) pixel.
    *   The output grids retain the blue (1) structures and the magenta (6) pixel in their original positions.
    *   The transformation involves changing the color of some gray (8) background pixels to orange (7).
    *   The pattern suggests a connectivity or reachability analysis. The orange (7) pixels appear to be the gray (8) pixels that are *not* reachable from the magenta (6) pixel without crossing a blue (1) barrier. It resembles a flood fill process where the unreached areas are marked.

*   **Facts:**
    
```yaml
    task_elements:
      - element: background
        color: gray (8)
        role: fillable_area
      - element: barriers
        color: blue (1)
        role: impassable_boundaries
      - element: start_point
        color: magenta (6)
        count: 1
        role: origin_for_reachability_check
      - element: target_fill
        color: orange (7)
        role: color_for_unreachable_background_pixels
    transformation:
      type: region_identification_and_coloring
      based_on: connectivity
      start: magenta (6) pixel location
      passable: gray (8) pixels
      blocked_by: blue (1) pixels
      rule: Identify all gray (8) pixels reachable from the magenta (6) pixel via adjacent (up, down, left, right) gray (8) pixels without crossing blue (1) pixels. Change all other gray (8) pixels (those not reachable) to orange (7). Keep blue (1) and magenta (6) pixels unchanged.
    grid_properties:
      - dimensions: remain_constant
      - colors_preserved: [blue (1), magenta (6)]
      - colors_modified: [gray (8)]
      - colors_introduced: [orange (7)]
    ```


*   **Natural Language Program:**
    1.  Create a copy of the input grid to serve as the basis for the output grid.
    2.  Locate the single magenta (6) pixel in the input grid; this is the starting point.
    3.  Identify all gray (8) pixels that are reachable from the starting point by moving horizontally or vertically through adjacent gray (8) pixels only. Blue (1) pixels block movement. (This can be done using a flood fill or breadth-first/depth-first search algorithm). Keep track of these reachable gray (8) pixels.
    4.  Iterate through each pixel of the input grid.
    5.  If a pixel is gray (8) and was *not* identified as reachable in step 3, change its color to orange (7) in the output grid.
    6.  Leave all other pixels (blue, magenta, and reachable gray) unchanged in the output grid.
    7.  The final modified grid is the result.
```python
import numpy as np
from collections import deque

"""
Identify all gray (8) pixels reachable from the single magenta (6) pixel by moving horizontally or vertically through adjacent gray (8) pixels, without crossing blue (1) barriers. Change all gray (8) pixels that are *not* reachable to orange (7). Keep blue (1), magenta (6), and reachable gray (8) pixels unchanged.
"""

def find_start_point(grid):
    """Finds the coordinates of the magenta (6) pixel."""
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 6:
                return (r, c)
    return None # Should not happen based on problem description

def get_reachable_gray_pixels(grid, start_pos):
    """Performs a BFS to find all gray pixels reachable from neighbors of the start point."""
    rows, cols = grid.shape
    reachable = set()
    queue = deque()
    
    start_r, start_c = start_pos

    # Add initial gray neighbors of the magenta start point to the queue
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = start_r + dr, start_c + dc
        if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 8:
            if (nr, nc) not in reachable:
                reachable.add((nr, nc))
                queue.append((nr, nc))

    # Perform BFS
    while queue:
        r, c = queue.popleft()

        # Explore neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds and if the neighbor is a gray pixel
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == 8:
                # If this gray pixel hasn't been reached yet
                if (nr, nc) not in reachable:
                    reachable.add((nr, nc))
                    queue.append((nr, nc))
                    
    return reachable


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Transforms the input grid by finding gray pixels reachable from the magenta
    pixel and changing unreachable gray pixels to orange.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    rows, cols = input_grid.shape

    # 1. Locate the single magenta (6) pixel
    start_point = find_start_point(input_grid)
    if start_point is None:
        # Handle case where magenta pixel isn't found (though examples suggest it always exists)
        return output_grid 

    # 2. Identify all reachable gray (8) pixels using BFS starting from neighbors of magenta
    reachable_gray = get_reachable_gray_pixels(input_grid, start_point)

    # 3. Iterate through the grid and change unreachable gray pixels
    for r in range(rows):
        for c in range(cols):
            # Check if the current pixel is gray
            if input_grid[r, c] == 8:
                # Check if this gray pixel was NOT reached by the BFS
                if (r, c) not in reachable_gray:
                    # Change it to orange (7) in the output grid
                    output_grid[r, c] = 7
            # All other pixels (blue, magenta, reachable gray) remain unchanged

    return output_grid
```
