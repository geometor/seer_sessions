{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the single connected component of gray (8) pixels that is cardinally \nadjacent to the single magenta (6) pixel or reachable from those adjacent gray \npixels via cardinal gray-to-gray steps (this is the 'reachable area' R). Blue (1) \npixels act as barriers during this reachability check.\n\nThen, create the output grid based on the following rules:\n1. Magenta (6) pixels remain magenta.\n2. Gray (8) pixels within the reachable area R remain gray.\n3. Gray (8) pixels *outside* the reachable area R become orange (7).\n4. Blue (1) pixels that are cardinally adjacent to any gray pixel within the \n   reachable area R become gray (8).\n5. Blue (1) pixels that are *not* cardinally adjacent to any gray pixel in R \n   remain blue (1).\n\"\"\"\n\ndef find_pixel(grid, color):\n    \"\"\"\n    Finds the coordinates (row, col) of the first pixel with the specified color.\n\n    Args:\n        grid: The numpy array representing the grid.\n        color: The integer color value to find.\n\n    Returns:\n        A tuple (row, col) if found, otherwise None.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color:\n                return (r, c)\n    return None\n\ndef find_reachable_gray_component(grid, start_pos):\n    \"\"\"\n    Performs a Breadth-First Search (BFS) starting from the gray (8) neighbors\n    of the start_pos (magenta pixel) to find all connected gray pixels,\n    respecting blue (1) barriers.\n\n    Args:\n        grid: The numpy array representing the input grid.\n        start_pos: A tuple (row, col) representing the coordinates of the\n                   magenta (6) pixel.\n\n    Returns:\n        A set of tuples, where each tuple is the (row, col) coordinate of a\n        gray pixel belonging to the connected component adjacent to the magenta pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    component_pixels_r = set() # Stores (r, c) of gray pixels in the reachable component R\n    queue = deque()\n    \n    if start_pos is None: # Handle case where magenta is missing\n        return component_pixels_r\n        \n    start_r, start_c = start_pos\n\n    # --- Step 1: Find initial gray neighbors of the magenta start point ---\n    # These are the entry points into the gray component we want to identify.\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Cardinal directions\n        nr, nc = start_r + dr, start_c + dc\n        \n        # Check if neighbor is within grid bounds\n        if 0 <= nr < rows and 0 <= nc < cols:\n            # Check if the neighbor is gray (8)\n            if grid[nr, nc] == 8:\n                # Add to set and queue if not already present\n                if (nr, nc) not in component_pixels_r:\n                    component_pixels_r.add((nr, nc))\n                    queue.append((nr, nc))\n\n    # --- Step 2: Perform BFS starting from these initial gray neighbors ---\n    while queue:\n        r, c = queue.popleft() # Get the next gray pixel to explore from\n\n        # Explore cardinal neighbors of the current gray pixel\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor is gray (8) AND not already visited/added\n                if grid[nr, nc] == 8 and (nr, nc) not in component_pixels_r:\n                    component_pixels_r.add((nr, nc))\n                    queue.append((nr, nc)) # Add valid gray neighbor to queue\n                    \n    return component_pixels_r\n\ndef is_blue_adjacent_to_reachable_gray(r, c, grid, reachable_gray_set):\n    \"\"\"\n    Checks if a blue pixel at (r, c) is cardinally adjacent to any gray pixel\n    that belongs to the reachable_gray_set.\n\n    Args:\n        r, c: Coordinates of the blue pixel.\n        grid: The input numpy array.\n        reachable_gray_set: The set 'R' of reachable gray pixel coordinates.\n\n    Returns:\n        True if adjacent to a reachable gray pixel, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Cardinal directions\n        nr, nc = r + dr, c + dc\n        # Check bounds and if the neighbor is gray and in the reachable set\n        if 0 <= nr < rows and 0 <= nc < cols:\n            if grid[nr, nc] == 8 and (nr, nc) in reachable_gray_set:\n                return True\n    return False\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # --- Step 1: Locate the single magenta (6) pixel ---\n    magenta_pos = find_pixel(input_grid, 6)\n    # Note: Examples guarantee magenta exists, but robust code might handle absence.\n\n    # --- Step 2: Identify the reachable gray component R ---\n    reachable_gray_coords = find_reachable_gray_component(input_grid, magenta_pos)\n\n    # --- Step 3: Iterate and transform pixels based on rules ---\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = input_grid[r, c]\n            \n            # Rule 3: Gray (8) pixels outside R become Orange (7)\n            if pixel_color == 8:\n                if (r, c) not in reachable_gray_coords:\n                    output_grid[r, c] = 7\n                # Else (if it's in R), it remains 8 (due to copy) - Rule 2\n                \n            # Rule 4 & 5: Blue (1) pixels transformation\n            elif pixel_color == 1:\n                if is_blue_adjacent_to_reachable_gray(r, c, input_grid, reachable_gray_coords):\n                    # Rule 4: Blue adjacent to reachable gray becomes gray\n                    output_grid[r, c] = 8\n                # Else, it remains 1 (due to copy) - Rule 5\n                \n            # Rule 1: Magenta remains magenta (due to copy)\n\n    # --- Step 4: Return the modified grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19175,
    "candidates_token_count": 1657,
    "total_token_count": 20832,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.020728,
  "retries": 1
}