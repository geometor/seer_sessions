{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nSimulates the movement of colored pixels on a grid based on specific rules.\n\nThe grid contains a background checkerboard pattern (blue=1, white=0) and foreground pixels of different colors.\nGreen (3) pixels are static obstacles.\nRed (2), Yellow (4), and Azure (8) pixels are mobile.\nThe simulation proceeds in discrete steps until no pixels can move.\n\nRules per step:\n1.  Identify all mobile pixels in the current grid state.\n2.  For each mobile pixel, determine its potential next position(s) based on its color:\n    - Red (2): Tries to move one step down. If the cell below is blocked (out of bounds, not background, or already claimed in this step), it tries to move one step down-left.\n    - Yellow (4): Tries to move one step down. If the cell below is blocked, it tries to move one step down-right.\n    - Azure (8): Tries to move *both* one step down-left and one step down-right simultaneously. Each potential move is evaluated independently.\n3.  A move is valid only if the target cell is within grid bounds, contains a background color (0 or 1) in the *current* grid state, and has not already been claimed by another pixel moving in the *same* step.\n4.  Conflicts for the same target cell are resolved by prioritizing the pixel encountered first during a top-down, left-right scan of the grid.\n5.  All valid moves are determined based on the grid state at the beginning of the step.\n6.  After identifying all valid moves for the step:\n    - Create the next grid state.\n    - Place the moved pixels in their new target cells.\n    - For each pixel that successfully moved, clear its original cell by restoring the background color (0 or 1) from the initial input grid. An Azure pixel's original cell is cleared if at least one of its potential moves (down-left or down-right) was successful.\n7.  Repeat steps 1-6 until a step occurs where no pixels move.\n8.  Return the final grid state.\n\"\"\"\n\nimport numpy as np\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the iterative pixel movement simulation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the initial grid state.\n\n    Returns:\n        A list of lists representing the final grid state after simulation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    current_grid = input_np.copy()\n    height, width = input_np.shape\n    background_colors = {0, 1} # white, blue\n    mobile_colors = {2, 4, 8} # red, yellow, azure\n\n    while True:\n        moved_in_step = False\n        # next_grid starts as a copy, modifications happen based on calculated moves\n        next_grid = current_grid.copy()\n        # Keep track of targets claimed in this step to handle conflicts\n        occupied_targets_this_step = set()\n        # Keep track of sources that successfully initiated a move\n        sources_to_clear_this_step = set()\n        # Store the actual moves to perform after scanning the whole grid\n        moves_to_make = [] # Stores tuples of (target_r, target_c, color)\n\n        # --- Scan the grid to determine all valid moves for this step ---\n        for r in range(height):\n            for c in range(width):\n                current_color = current_grid[r, c]\n\n                if current_color not in mobile_colors:\n                    continue\n\n                # --- Helper function to check if a move to (nr, nc) is valid ---\n                def can_move_to(nr, nc):\n                    # Check bounds\n                    if not (0 <= nr < height and 0 <= nc < width):\n                        return False\n                    # Check if target is currently background\n                    if current_grid[nr, nc] not in background_colors:\n                        return False\n                    # Check if target is already claimed in this step\n                    if (nr, nc) in occupied_targets_this_step:\n                        return False\n                    return True\n\n                # --- Determine potential moves based on color ---\n                if current_color == 2: # Red\n                    moved_pixel = False\n                    # Try down\n                    target_r, target_c = r + 1, c\n                    if can_move_to(target_r, target_c):\n                        occupied_targets_this_step.add((target_r, target_c))\n                        moves_to_make.append((target_r, target_c, 2))\n                        sources_to_clear_this_step.add((r, c))\n                        moved_in_step = True\n                        moved_pixel = True\n                    # Else try down-left\n                    elif not moved_pixel:\n                        target_r, target_c = r + 1, c - 1\n                        if can_move_to(target_r, target_c):\n                            occupied_targets_this_step.add((target_r, target_c))\n                            moves_to_make.append((target_r, target_c, 2))\n                            sources_to_clear_this_step.add((r, c))\n                            moved_in_step = True\n                            moved_pixel = True\n\n\n                elif current_color == 4: # Yellow\n                    moved_pixel = False\n                    # Try down\n                    target_r, target_c = r + 1, c\n                    if can_move_to(target_r, target_c):\n                        occupied_targets_this_step.add((target_r, target_c))\n                        moves_to_make.append((target_r, target_c, 4))\n                        sources_to_clear_this_step.add((r, c))\n                        moved_in_step = True\n                        moved_pixel = True\n                    # Else try down-right\n                    elif not moved_pixel:\n                        target_r, target_c = r + 1, c + 1\n                        if can_move_to(target_r, target_c):\n                            occupied_targets_this_step.add((target_r, target_c))\n                            moves_to_make.append((target_r, target_c, 4))\n                            sources_to_clear_this_step.add((r, c))\n                            moved_in_step = True\n                            moved_pixel = True\n\n                elif current_color == 8: # Azure\n                    moved_azure_component = False\n                    # Try down-left (independent)\n                    target_r_left, target_c_left = r + 1, c - 1\n                    if can_move_to(target_r_left, target_c_left):\n                        occupied_targets_this_step.add((target_r_left, target_c_left))\n                        moves_to_make.append((target_r_left, target_c_left, 8))\n                        moved_in_step = True\n                        moved_azure_component = True\n\n                    # Try down-right (independent)\n                    target_r_right, target_c_right = r + 1, c + 1\n                    if can_move_to(target_r_right, target_c_right):\n                        occupied_targets_this_step.add((target_r_right, target_c_right))\n                        moves_to_make.append((target_r_right, target_c_right, 8))\n                        moved_in_step = True\n                        moved_azure_component = True\n\n                    # If at least one component moved, mark the source for clearing\n                    if moved_azure_component:\n                        sources_to_clear_this_step.add((r, c))\n\n\n        # --- If no pixels moved in this step, simulation is done ---\n        if not moved_in_step:\n            break\n\n        # --- Apply the changes for the next step ---\n        # 1. Clear the source cells of moved pixels (restore original background)\n        for r, c in sources_to_clear_this_step:\n             # Only clear if it wasn't occupied by another move in the same step\n             if (r,c) not in occupied_targets_this_step:\n                next_grid[r, c] = input_np[r, c] # Restore original background\n\n        # 2. Place the pixels in their new target locations\n        for r, c, color in moves_to_make:\n            next_grid[r, c] = color\n\n        # Update the grid for the next iteration\n        current_grid = next_grid\n\n    # Return the final state as a list of lists\n    return current_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16349,
    "candidates_token_count": 2000,
    "total_token_count": 18349,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.76216,
  "retries": 1
}