{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid by iteratively propagating specific colors (Red=2, Yellow=4, Azure=8) downwards onto background cells (White=0, Blue=1).\n\nThe propagation follows these rules:\n1.  The process iterates until no changes occur in a full pass over the grid.\n2.  Propagation only occurs into cells that were originally background (White or Blue) in the input grid AND are currently background in the grid being updated.\n3.  Green (3) pixels are static and block propagation; they are never overwritten.\n4.  Red (2) pixels attempt to propagate straight down (r+1, c). If blocked or invalid, they attempt to propagate down-left (r+1, c-1).\n5.  Yellow (4) pixels attempt to propagate straight down (r+1, c). If blocked or invalid, they attempt to propagate down-right (r+1, c+1).\n6.  Azure (8) pixels attempt to propagate *both* down-left (r+1, c-1) and down-right (r+1, c+1) independently in each step.\n7.  Changes within one iteration step are based on the grid state at the *start* of that step and are applied simultaneously before the next iteration begins.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the iterative color propagation rules to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the initial grid state.\n\n    Returns:\n        A list of lists representing the final grid state after propagation stops.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = input_np.copy()\n    height, width = input_np.shape\n    \n    # Define background and mobile colors\n    background_colors = {0, 1} # white, blue\n    mobile_colors = {2, 4, 8} # red, yellow, azure\n\n    # Loop until no more changes occur in a full iteration\n    while True:\n        changed = False\n        # Create a grid for the next state based on the current state.\n        # This prevents changes within one iteration from immediately affecting\n        # subsequent checks in the same iteration.\n        next_output_grid = output_grid.copy()\n\n        # --- Helper function to check propagation validity ---\n        # Checks bounds, original background status, and current background status in the next_grid\n        def is_valid_target(nr, nc):\n            # Check bounds\n            if not (0 <= nr < height and 0 <= nc < width):\n                return False\n            # Check if the target was originally background in the input\n            if input_np[nr, nc] not in background_colors:\n                return False\n            # Check if the target in the *next* state grid is currently background\n            # (meaning it hasn't been claimed by another propagation in this iteration)\n            if next_output_grid[nr, nc] not in background_colors:\n                return False\n            return True\n\n        # Iterate row by row, from top to bottom\n        # We check pixels in row 'r' to potentially modify row 'r+1'\n        for r in range(height - 1): # Last row cannot propagate downwards\n            for c in range(width):\n                # Get the color from the *current* state grid\n                current_color = output_grid[r, c]\n\n                # --- Propagation Logic ---\n                if current_color == 2: # Red\n                    propagated_down = False\n                    # Try down\n                    target_r, target_c = r + 1, c\n                    if is_valid_target(target_r, target_c):\n                        # Check if the target isn't already Red to avoid redundant changes flag\n                        if next_output_grid[target_r, target_c] != 2:\n                           next_output_grid[target_r, target_c] = 2\n                           changed = True\n                        propagated_down = True # Mark attempt down successful even if already red\n                    \n                    # If down attempt failed (blocked/invalid OR already red), try down-left\n                    # Note: The original logic was \"If down failed\" -> try diag.\n                    # Let's refine: Try down first. If that specific target cell is invalid, try diagonal.\n                    # If the target cell *was* valid but already contained the color, we don't try diagonal.\n                    \n                    # More accurate: Try down. If target is invalid, try down-left.\n                    target_r_down, target_c_down = r + 1, c\n                    is_down_valid = is_valid_target(target_r_down, target_c_down)\n\n                    if is_down_valid:\n                        if next_output_grid[target_r_down, target_c_down] != 2:\n                            next_output_grid[target_r_down, target_c_down] = 2\n                            changed = True\n                    else: # Down target was invalid, try down-left\n                        target_r_dl, target_c_dl = r + 1, c - 1\n                        if is_valid_target(target_r_dl, target_c_dl):\n                           if next_output_grid[target_r_dl, target_c_dl] != 2:\n                                next_output_grid[target_r_dl, target_c_dl] = 2\n                                changed = True\n\n\n                elif current_color == 4: # Yellow\n                    # Try down. If target is invalid, try down-right.\n                    target_r_down, target_c_down = r + 1, c\n                    is_down_valid = is_valid_target(target_r_down, target_c_down)\n\n                    if is_down_valid:\n                        if next_output_grid[target_r_down, target_c_down] != 4:\n                            next_output_grid[target_r_down, target_c_down] = 4\n                            changed = True\n                    else: # Down target was invalid, try down-right\n                        target_r_dr, target_c_dr = r + 1, c + 1\n                        if is_valid_target(target_r_dr, target_c_dr):\n                            if next_output_grid[target_r_dr, target_c_dr] != 4:\n                                next_output_grid[target_r_dr, target_c_dr] = 4\n                                changed = True\n\n                elif current_color == 8: # Azure\n                    # Propagates both ways *if possible*, independently.\n                    # Try down-left\n                    target_r_left, target_c_left = r + 1, c - 1\n                    if is_valid_target(target_r_left, target_c_left):\n                        if next_output_grid[target_r_left, target_c_left] != 8:\n                            next_output_grid[target_r_left, target_c_left] = 8\n                            changed = True\n                    # Try down-right\n                    target_r_right, target_c_right = r + 1, c + 1\n                    if is_valid_target(target_r_right, target_c_right):\n                        if next_output_grid[target_r_right, target_c_right] != 8:\n                            next_output_grid[target_r_right, target_c_right] = 8\n                            changed = True\n\n        # Update the main grid for the next iteration\n        # Check if the grid actually changed to avoid infinite loops if logic is flawed\n        if np.array_equal(output_grid, next_output_grid):\n           #print(\"No change detected, breaking loop.\")\n           break\n           \n        output_grid = next_output_grid\n\n        # If no changes were flagged in this full pass, the simulation is stable\n        # The np.array_equal check above is a more robust break condition\n        # if not changed:\n        #    print(\"Changed flag is False, breaking loop.\")\n        #    break\n\n    # Return the final state as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18709,
    "candidates_token_count": 1888,
    "total_token_count": 20597,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.304096,
  "retries": 1
}