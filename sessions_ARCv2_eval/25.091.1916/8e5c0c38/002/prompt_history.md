
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 1 8 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 1 1 8 8 6 6 6 6 8 8 8
8 8 8 8 8 1 8 8 8 8 8 1 8 8 8 8 6 8 6 8 8 8
8 8 8 8 1 1 8 1 1 1 8 1 8 8 8 8 6 6 6 8 8 8
8 8 8 8 1 1 1 1 8 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 2 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 2 2 2 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 1 1 1 8 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 1 1 8 8 8 6 6 6 8 8 8
8 8 8 8 8 1 8 8 8 8 8 1 8 8 8 8 6 8 6 8 8 8
8 8 8 8 8 1 8 1 1 1 8 1 8 8 8 8 6 6 6 8 8 8
8 8 8 8 8 1 1 1 8 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 1 8 8 8 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 2 2 2 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0 2 2 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 0 2 2 0 0 2 2 0 0
0 0 0 0 0 8 8 0 8 0 0 0 0 0 0 2 2 2 2 0 0 0
0 0 0 0 0 8 8 0 8 0 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 4 4 0 0 0 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 2 2 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 0 2 2 0 0 2 2 0 0
0 0 0 0 0 0 8 0 8 0 0 0 0 0 0 2 2 2 2 0 0 0
0 0 0 0 0 0 8 0 8 0 0 0 0 0 0 0 2 2 0 0 0 0
0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 4 0 0 0 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

1.  **Grid Structure:** Both input and output grids are the same size in each example.
2.  **Colors:** The examples use multiple colors against a dominant background color (azure-8 in train\_1, white-0 in train\_2).
3.  **Objects:** The non-background colors form distinct shapes or objects within the grid.
4.  **Transformation:** The transformation involves removing specific pixels from the non-background objects. The background pixels remain unchanged.
5.  **Pattern of Removal:** Comparing inputs and outputs, the removed pixels seem to be 'weakly connected' parts of the objects. Specifically, observing the neighbours (including diagonals) of the pixels that are removed, they consistently have exactly 3 neighbours of the *same* color as themselves. Pixels with fewer or more than 3 same-colored neighbours remain unchanged.

**Facts**


```yaml
task_description: Modifies objects by removing pixels based on their local neighborhood connectivity.

definitions:
  - background_color: The color that occupies the most cells in the input grid.
  - object_pixel: A pixel whose color is not the background_color.
  - neighbor: Any of the 8 cells directly or diagonally adjacent to a given cell.
  - same_color_neighbor: A neighbor cell that has the same color as the central cell being considered.

examples:
  - id: train_1
    input:
      background_color: 8 # azure
      objects:
        - color: 1 # blue
        - color: 6 # magenta
        - color: 2 # red
      transformation:
        action: remove_pixels
        condition: Pixels with exactly 3 same_color_neighbors are changed to the background_color (8).
    output:
      preserves:
        - grid_dimensions
        - background_color
        - object_colors (partially)
      changes:
        - Specific pixels within objects are replaced by the background_color.
  - id: train_2
    input:
      background_color: 0 # white
      objects:
        - color: 2 # red
        - color: 8 # azure
        - color: 4 # yellow
      transformation:
        action: remove_pixels
        condition: Pixels with exactly 3 same_color_neighbors are changed to the background_color (0).
    output:
      preserves:
        - grid_dimensions
        - background_color
        - object_colors (partially)
      changes:
        - Specific pixels within objects are replaced by the background_color.

general_rule:
  - step: 1
    action: Identify the background color (most frequent color in the input grid).
  - step: 2
    action: Create a copy of the input grid for modification.
  - step: 3
    action: Iterate through each cell (pixel) of the input grid.
  - step: 4
    action: For each cell that is NOT the background color:
      - sub_step: 4.1
        action: Count its 8 neighbors (orthogonal and diagonal) that have the same color as the cell itself.
      - sub_step: 4.2
        condition: If the count of same_color_neighbors is exactly 3.
        action: Change the color of the corresponding cell in the copied grid to the background color.
  - step: 5
    action: Return the modified grid.
```


**Natural Language Program**

1.  Determine the background color by finding the most frequent color in the input grid.
2.  Initialize the output grid as a copy of the input grid.
3.  Iterate through each pixel (cell) of the input grid using its row and column index.
4.  For the current pixel, check if its color is the background color.
5.  If the current pixel's color is *not* the background color:
    a.  Examine its eight neighbours (up, down, left, right, and the four diagonals).
    b.  Count how many of these neighbours have the exact same color as the current pixel.
    c.  If this count is precisely 3, update the corresponding pixel in the output grid to the background color.
6.  If the current pixel's color *is* the background color, or if the count of same-colored neighbours is not 3, leave the corresponding pixel in the output grid unchanged from the initial copy.
7.  After checking all pixels, return the final output grid.
```python
"""
Transforms an input grid by identifying the background color and then iterating 
through each non-background pixel. If a non-background pixel has exactly 3 
neighbors (including diagonals) of the same color as itself, that pixel's color 
is changed to the background color in the output grid. Otherwise, the pixel's 
color remains unchanged.
"""

import numpy as np
from collections import Counter

def get_background_color(grid):
    """
    Identifies the most frequent color in the grid, considering it the background.
    
    Args:
        grid (np.array): The input grid.
        
    Returns:
        int: The color value considered as the background.
    """
    colors, counts = np.unique(grid, return_counts=True)
    background_color = colors[np.argmax(counts)]
    return background_color

def count_same_color_neighbors(grid, r, c, color):
    """
    Counts the 8 neighbors (orthogonal and diagonal) of a cell (r, c) 
    that have the specified color.

    Args:
        grid (np.array): The grid to check within.
        r (int): The row index of the cell.
        c (int): The column index of the cell.
        color (int): The color to match in the neighbors.

    Returns:
        int: The count of neighbors with the specified color.
    """
    height, width = grid.shape
    count = 0
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the cell itself
            if dr == 0 and dc == 0:
                continue
            
            nr, nc = r + dr, c + dc
            
            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr, nc] == color:
                    count += 1
    return count

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid (list[list[int]]): The input grid represented as a list of lists.

    Returns:
        list[list[int]]: The transformed grid as a list of lists.
    """
    # Convert input to numpy array for easier processing
    input_np = np.array(input_grid, dtype=int)
    
    # Initialize output_grid as a copy of the input
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # Step 1: Identify the background color
    background_color = get_background_color(input_np)

    # Step 3 & 4: Iterate through each cell
    for r in range(height):
        for c in range(width):
            current_color = input_np[r, c]
            
            # Step 4: Check if the cell is NOT the background color
            if current_color != background_color:
                # Step 4.1: Count same-colored neighbors
                neighbor_count = count_same_color_neighbors(input_np, r, c, current_color)
                
                # Step 4.2: Condition and Action
                if neighbor_count == 3:
                    output_np[r, c] = background_color
            # Step 6: If it's background or neighbor count is not 3, 
            # the output_np already holds the correct value from the copy.

    # Convert the result back to a list of lists
    output_grid = output_np.tolist()
    
    # Step 5 & 7: Return the modified grid
    return output_grid
```
