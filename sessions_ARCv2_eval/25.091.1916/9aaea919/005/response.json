{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, List, Dict, Set\n\n\"\"\"\nModify the color of 3x5 cross shapes to gray (5) if their column range \noverlaps with the column range of a red (2) 1x5 line located on the \nbottom row of the grid. Remove all red (2) and green (3) 1x5 lines \nfrom the bottom row, replacing them with the background color. \nOther grid elements remain unchanged.\n\"\"\"\n\n# Define color constants for clarity\nCOLORS = {\n    \"white\": 0,\n    \"blue\": 1,\n    \"red\": 2,\n    \"green\": 3,\n    \"yellow\": 4,\n    \"gray\": 5,\n    \"magenta\": 6,\n    \"orange\": 7,\n    \"azure\": 8,\n    \"maroon\": 9,\n}\nTRIGGER_COLORS = {COLORS[\"red\"], COLORS[\"green\"]}\nLINE_WIDTH = 5\nCROSS_HEIGHT = 3\nCROSS_WIDTH = 5\n\ndef _find_trigger_lines(grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Finds all 1x5 horizontal lines of Red(2) or Green(3) on the bottom row.\n\n    Args:\n        grid: The input numpy array representing the grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        (line_color, start_column_index, end_column_index).\n    \"\"\"\n    H, W = grid.shape\n    bottom_row_index = H - 1\n    lines = []\n    processed_cols = set()\n\n    # Iterate through potential starting columns for a line\n    for c in range(W - (LINE_WIDTH - 1)):\n        if c in processed_cols:\n            continue\n            \n        # Check the segment on the bottom row\n        line_segment = grid[bottom_row_index, c : c + LINE_WIDTH]\n        potential_line_color = line_segment[0]\n\n        # Check if it's a solid line of a single trigger color\n        if (potential_line_color in TRIGGER_COLORS and \n            np.all(line_segment == potential_line_color)):\n            \n            # Found a trigger line\n            start_col = c\n            end_col = c + LINE_WIDTH - 1\n            lines.append((potential_line_color, start_col, end_col))\n            \n            # Mark columns as processed to avoid finding overlapping segments\n            for i in range(start_col, end_col + 1):\n                processed_cols.add(i)\n                \n    return lines\n\ndef _find_cross_shapes(grid: np.ndarray, background_color: int) -> List[Tuple[int, Set[Tuple[int, int]], int, int]]:\n    \"\"\"\n    Finds all 3x5 cross shapes in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        background_color: The background color of the grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        (cross_color, set_of_coordinates, start_column_index, end_column_index).\n    \"\"\"\n    H, W = grid.shape\n    crosses = []\n    \n    # Iterate through potential center points of the cross\n    # Center needs 1 row above/below and 2 cols left/right\n    for r in range(1, H - 1):\n        for c in range(2, W - 2):\n            center_color = grid[r, c]\n            \n            # Skip if the center is background color\n            if center_color == background_color:\n                continue\n\n            # Check horizontal bar (1x5 centered at r, c)\n            h_start_c = c - 2\n            h_end_c = c + 2\n            if not (0 <= h_start_c < W and 0 <= h_end_c < W): continue # Bounds check\n            horizontal_bar = grid[r, h_start_c : h_end_c + 1]\n            if not np.all(horizontal_bar == center_color):\n                continue\n\n            # Check vertical bar (3x1 centered at r, c)\n            v_start_r = r - 1\n            v_end_r = r + 1\n            if not (0 <= v_start_r < H and 0 <= v_end_r < H): continue # Bounds check\n            vertical_bar = grid[v_start_r : v_end_r + 1, c]\n            if not np.all(vertical_bar == center_color):\n                continue\n                \n            # Check surrounding background pixels to confirm it's just the cross\n            is_isolated = True\n            # Corners of the 3x5 bounding box\n            corners = [\n                (v_start_r, h_start_c), (v_start_r, h_end_c),\n                (v_end_r, h_start_c), (v_end_r, h_end_c)\n            ]\n            # Points adjacent to vertical bar ends (but not on horizontal)\n            adj_vertical = [\n                 (v_start_r, c-1), (v_start_r, c+1),\n                 (v_end_r, c-1), (v_end_r, c+1)\n            ]\n            \n            for check_r, check_c in corners + adj_vertical:\n                 if grid[check_r, check_c] != background_color:\n                     is_isolated = False\n                     break\n            if not is_isolated:\n                continue\n                \n            # If all checks pass, it's a valid cross\n            cross_coords = set()\n            # Add horizontal bar coordinates\n            for col in range(h_start_c, h_end_c + 1):\n                cross_coords.add((r, col))\n            # Add vertical bar coordinates (excluding center)\n            cross_coords.add((v_start_r, c))\n            cross_coords.add((v_end_r, c))\n                \n            crosses.append((center_color, cross_coords, h_start_c, h_end_c))\n\n    return crosses\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    \n    # Determine the background color (assuming top-left pixel is representative)\n    background_color = input_grid[0, 0]\n    \n    # Find trigger lines on the bottom row\n    trigger_lines = _find_trigger_lines(input_grid)\n    red_lines = [(start, end) for color, start, end in trigger_lines if color == COLORS[\"red\"]]\n    \n    # Find all cross shapes\n    cross_shapes = _find_cross_shapes(input_grid, background_color)\n    \n    # Process cross shapes based on red trigger lines\n    for cross_color, cross_coords, cross_start, cross_end in cross_shapes:\n        change_to_gray = False\n        # Check for overlap with any red line\n        for red_start, red_end in red_lines:\n            # Check for column range overlap\n            if max(cross_start, red_start) <= min(cross_end, red_end):\n                change_to_gray = True\n                break # Found an overlap, no need to check other red lines\n                \n        # If overlap detected, change the cross color in the output grid\n        if change_to_gray:\n            for r, c in cross_coords:\n                 # Ensure coordinates are valid just in case (should be)\n                 if 0 <= r < H and 0 <= c < W:\n                     output_grid[r, c] = COLORS[\"gray\"]\n\n    # Remove all trigger lines (Red and Green) from the output grid\n    bottom_row_index = H - 1\n    for _, line_start, line_end in trigger_lines:\n        if 0 <= bottom_row_index < H and 0 <= line_start < W and 0 <= line_end < W:\n            output_grid[bottom_row_index, line_start : line_end + 1] = background_color\n            \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19548,
    "candidates_token_count": 1972,
    "total_token_count": 21520,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.161407,
  "retries": 1
}