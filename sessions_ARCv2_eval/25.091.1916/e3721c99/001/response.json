{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Description:\n\n1. Identify a horizontal blue separator line. The grid is divided into a 'key' area above and a 'work' area below.\n2. Identify 'key' objects (Yellow 3x3 solid, Green 3x3 hollow, Blue 3x5 pattern, Red 3x7 pattern) in the key area. Store their color, shape pattern (relative pixel coordinates), and pixel count.\n3. Identify all gray objects in the work area.\n4. For each gray object:\n    a. Determine which key object patterns fit entirely within the gray object's shape. A key pattern fits if its shape (set of relative pixel coordinates) can be translated such that all its pixels coincide with pixels of the gray object.\n    b. If multiple key patterns fit, choose the one with the largest pixel count (Red > Blue > Yellow > Green).\n    c. If at least one key pattern fits, recolor all pixels of the gray object in the output grid with the color of the chosen key pattern.\n5. The separator line and the key objects remain unchanged in the output grid.\n\"\"\"\n\ndef find_objects(grid, colors):\n    \"\"\"Finds all connected objects of specified colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    target_colors = set(colors)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in target_colors and not visited[r, c]:\n                obj_color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == obj_color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                if obj_pixels:\n                    objects.append({\n                        'color': obj_color,\n                        'pixels': obj_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef get_relative_pattern(pixels, top_left):\n    \"\"\"Converts absolute pixel coordinates to relative coordinates based on top_left.\"\"\"\n    min_r, min_c = top_left\n    return frozenset((r - min_r, c - min_c) for r, c in pixels)\n\ndef check_fit(key_rel_pattern, gray_rel_pattern):\n    \"\"\"Checks if the key_rel_pattern fits inside the gray_rel_pattern.\"\"\"\n    if not key_rel_pattern or not gray_rel_pattern:\n        return False\n\n    # Get dimensions for iteration bounds\n    max_key_dr = max(dr for dr, dc in key_rel_pattern) if key_rel_pattern else -1\n    max_key_dc = max(dc for dr, dc in key_rel_pattern) if key_rel_pattern else -1\n    max_gray_dr = max(dr for dr, dc in gray_rel_pattern) if gray_rel_pattern else -1\n    max_gray_dc = max(dc for dr, dc in gray_rel_pattern) if gray_rel_pattern else -1\n\n    key_h = max_key_dr + 1\n    key_w = max_key_dc + 1\n    gray_h = max_gray_dr + 1\n    gray_w = max_gray_dc + 1\n\n    # Iterate through all possible top-left offsets for the key within the gray's relative bounding box\n    for offset_r in range(gray_h - key_h + 1):\n        for offset_c in range(gray_w - key_w + 1):\n            fits_at_offset = True\n            # Check if every pixel of the shifted key pattern exists in the gray pattern\n            for kdr, kdc in key_rel_pattern:\n                target_rel = (kdr + offset_r, kdc + offset_c)\n                if target_rel not in gray_rel_pattern:\n                    fits_at_offset = False\n                    break # This offset doesn't work\n            \n            if fits_at_offset:\n                return True # Found a working offset\n\n    return False # No offset worked\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule:\n    - Finds key patterns above a blue line.\n    - Finds gray objects below the blue line.\n    - Recolors gray objects based on the largest fitting key pattern.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    rows, cols = input_grid_np.shape\n\n    # --- 1. Find Separator and Define Areas ---\n    separator_row = -1\n    for r in range(rows):\n        if np.all(input_grid_np[r, :] == 1): # Assuming blue (1) is the separator color\n             # Check if it spans the whole width and is not the only color in the grid\n            is_separator = True\n            for c in range(cols):\n                 if input_grid_np[r,c] != 1:\n                      is_separator = False\n                      break\n            # Make sure it's not just a single blue object somewhere\n            if is_separator and cols > 1:\n                 # Also check if there are non-blue pixels elsewhere to confirm it's a separator\n                 if np.any(input_grid_np != 1):\n                    separator_row = r\n                    break\n    \n    # If no clear separator, maybe handle differently? For now, assume it exists.\n    # If no separator found, maybe assume keys are top-most objects and work area is everything else?\n    # For this problem, the separator seems consistent.\n    if separator_row == -1:\n         print(\"Warning: Blue separator line not found. Processing might be incorrect.\")\n         # Heuristic: assume top 5 rows are key area if separator not found explicitly\n         separator_row = 4 # Based on examples\n\n    key_area_rows = range(0, separator_row)\n    work_area_rows = range(separator_row + 1, rows)\n\n    # --- 2. Identify Key Objects ---\n    key_colors = {2, 3, 4, 1} # Red, Green, Yellow, Blue (excluding separator blue)\n    all_objects = find_objects(input_grid_np, list(range(10))) # Find all colored objects initially\n\n    key_objects_info = []\n    for obj in all_objects:\n        # Check if object is entirely within the key area and is a key color\n        min_r, _, _, _ = obj['bbox']\n        if min_r in key_area_rows and obj['color'] in key_colors:\n             # Ensure it's not part of the separator line if blue\n             if obj['color'] == 1 and min_r == separator_row:\n                 continue\n\n             rel_pattern = get_relative_pattern(obj['pixels'], (obj['bbox'][0], obj['bbox'][1]))\n             key_objects_info.append({\n                 'color': obj['color'],\n                 'pattern': rel_pattern,\n                 'pixel_count': len(obj['pixels'])\n             })\n    \n    # Sort keys by pixel count descending for tie-breaking\n    key_objects_info.sort(key=lambda x: x['pixel_count'], reverse=True)\n\n\n    # --- 3. Identify Gray Objects ---\n    gray_objects = []\n    for obj in all_objects:\n        min_r, _, _, _ = obj['bbox']\n        # Check if object is gray (5) and starts in the work area\n        if obj['color'] == 5 and min_r in work_area_rows:\n             gray_objects.append(obj)\n\n    # --- 4. Process Gray Objects ---\n    for gray_obj in gray_objects:\n        gray_pixels = gray_obj['pixels']\n        gray_bbox_min_r, gray_bbox_min_c, _, _ = gray_obj['bbox']\n        gray_rel_pattern = get_relative_pattern(gray_pixels, (gray_bbox_min_r, gray_bbox_min_c))\n\n        best_fit_color = -1 # Use -1 to indicate no fit found yet\n\n        # Find the best fitting key (largest pixel count first due to sorting)\n        for key_info in key_objects_info:\n            if check_fit(key_info['pattern'], gray_rel_pattern):\n                best_fit_color = key_info['color']\n                break # Found the best fit according to tie-breaker rule\n\n        # --- 5. Recolor ---\n        if best_fit_color != -1:\n            for r, c in gray_pixels:\n                # Ensure coordinates are valid (should be, but safety check)\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_grid[r, c] = best_fit_color\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 6779,
            "end_index": 7114,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9628,
    "candidates_token_count": 2311,
    "total_token_count": 11939,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.78822,
  "retries": 1
}