{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThe transformation rule identifies the first occurrence (scanning row-major) of a trigger pattern involving an adjacent yellow (4) and red (2) pixel. \n\nThere are two possible trigger configurations:\n1. Vertical: Yellow (4) is directly above Red (2) in the same column 'c'.\n2. Horizontal: Yellow (4) is directly to the left of Red (2) in the same row, involving columns 'c' and 'c+1'.\n\nThe type of trigger determines the transformation applied to the column(s) containing the trigger pixels:\n\n- If the trigger is vertical (4 above 2) in column 'c':\n    - The column 'c' is filled with an alternating pattern starting with red (2) and then yellow (4).\n    - This fill extends from the top edge (row 0) down to, but not including, the row containing the topmost blue (1) pixel in that column. If no blue pixel exists, the pattern fills the entire column.\n\n- If the trigger is horizontal (4 left of 2) involving columns 'c' (yellow) and 'c+1' (red):\n    - Column 'c' is filled with solid yellow (4).\n    - Column 'c+1' is filled with solid red (2).\n    - Each fill extends from the top edge (row 0) down to, but not including, the row containing the topmost blue (1) pixel in that specific column. If no blue pixel exists in a column, the fill covers the entire column height.\n\nAll pixels outside the specifically filled regions remain unchanged from the input grid.\n\"\"\"\n\ndef find_highest_blue(grid, col_index):\n    \"\"\"\n    Finds the row index of the topmost blue (1) pixel in a given column.\n    Returns the grid height if no blue pixel is found or if the column index is invalid.\n    \"\"\"\n    height, width = grid.shape\n    if col_index < 0 or col_index >= width:\n        return height # Invalid column treated as having no boundary\n\n    for r in range(height):\n        if grid[r, col_index] == 1:\n            return r\n    return height # Return height if no blue pixel is found\n\ndef find_first_trigger(grid):\n    \"\"\"\n    Scans the grid row-major to find the first trigger pattern.\n    Returns:\n        tuple: (trigger_type, col1, col2) where:\n            trigger_type (str): 'vertical', 'horizontal', or None\n            col1 (int): Index of the (first) column involved, or -1 if no trigger.\n            col2 (int): Index of the second column (only for horizontal), or -1.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            # Check for vertical trigger (4 above 2)\n            if r + 1 < height and grid[r, c] == 4 and grid[r + 1, c] == 2:\n                return 'vertical', c, -1 # col2 is not used for vertical\n            # Check for horizontal trigger (4 left of 2)\n            if c + 1 < width and grid[r, c] == 4 and grid[r, c + 1] == 2:\n                return 'horizontal', c, c + 1 # col1=yellow's col, col2=red's col\n    return None, -1, -1 # No trigger found\n\ndef apply_alternating_pattern(output_grid, col_index, end_row, color1, color2):\n    \"\"\"\n    Applies an alternating pattern (color1, color2, color1, ...)\n    to a specific column up to the end_row (exclusive).\n    \"\"\"\n    if col_index < 0 or col_index >= output_grid.shape[1]:\n        return # Avoid accessing invalid columns\n\n    for row in range(end_row):\n        if row % 2 == 0:\n            output_grid[row, col_index] = color1\n        else:\n            output_grid[row, col_index] = color2\n\ndef apply_solid_fill(output_grid, col_index, end_row, color):\n    \"\"\"\n    Applies a solid color fill to a specific column up to the end_row (exclusive).\n    \"\"\"\n    if col_index < 0 or col_index >= output_grid.shape[1]:\n        return # Avoid accessing invalid columns\n        \n    for row in range(end_row):\n        output_grid[row, col_index] = color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the first found trigger pattern.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n    \n    # Find the first trigger pattern\n    trigger_type, col1, col2 = find_first_trigger(grid)\n\n    # If no trigger is found, return the unmodified grid copy\n    if trigger_type is None:\n        return output_grid.tolist()\n\n    # Apply transformation based on the trigger type\n    if trigger_type == 'vertical':\n        # Find the blue boundary for the single affected column\n        blue_row_boundary = find_highest_blue(grid, col1)\n        # Apply alternating pattern: starts with red (2), alternates with yellow (4)\n        apply_alternating_pattern(output_grid, col1, blue_row_boundary, 2, 4)\n        \n    elif trigger_type == 'horizontal':\n        # Process column col1 (where yellow 4 was)\n        blue_row_boundary_c1 = find_highest_blue(grid, col1)\n        # Apply solid fill with yellow (4)\n        apply_solid_fill(output_grid, col1, blue_row_boundary_c1, 4)\n        \n        # Process column col2 (where red 2 was)\n        blue_row_boundary_c2 = find_highest_blue(grid, col2)\n        # Apply solid fill with red (2)\n        apply_solid_fill(output_grid, col2, blue_row_boundary_c2, 2)\n\n    # Return the modified grid as a standard list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20566,
    "candidates_token_count": 1468,
    "total_token_count": 22034,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.038005,
  "retries": 1
}