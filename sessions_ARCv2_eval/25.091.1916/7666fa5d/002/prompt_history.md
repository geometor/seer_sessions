
## train_1

**input:**
```
8 8 8 8 8 8 8 8 4 8 8 8 4 8 8 8
8 8 8 8 8 8 8 4 8 8 8 4 8 8 8 4
8 8 8 8 8 8 8 8 8 8 4 8 8 8 4 8
8 8 8 8 8 8 8 8 8 4 8 8 8 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 4 8 8 8 8 4 8 8 8 8 8 4 8
8 8 4 8 8 8 8 4 8 8 8 8 8 4 8 8
8 8 8 8 8 8 4 8 8 8 8 8 4 8 8 8
8 8 8 8 8 4 8 8 8 8 8 4 8 8 8 8
8 8 8 8 4 8 8 8 8 8 4 8 8 8 8 8
8 8 8 4 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 4 8 8 8 4 8 8 8
8 8 8 8 8 8 8 4 2 2 8 4 2 2 8 4
8 8 8 8 8 8 8 8 2 2 4 2 2 2 4 8
8 8 8 8 8 8 8 8 8 4 8 2 2 4 8 8
8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8
8 8 8 4 2 2 8 8 4 8 8 8 8 8 4 8
8 8 4 2 2 2 2 4 2 2 8 8 8 4 8 8
8 8 8 2 2 2 4 2 2 2 2 8 4 8 8 8
8 8 8 8 2 4 2 2 2 2 2 4 8 8 8 8
8 8 8 8 4 8 2 2 2 2 4 8 8 8 8 8
8 8 8 4 8 8 8 2 2 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 3 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 8 8 8 8
8 8 8 8 3 8 8 8 8 3 8 8 8 8 8 8
8 8 8 3 8 8 8 8 3 8 8 8 8 8 8 8
8 8 3 8 8 8 8 3 8 8 8 8 8 8 8 8
8 3 8 8 8 8 3 8 8 8 8 8 8 8 8 8
3 8 8 8 8 8 8 8 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
8 8 8 8 8 8 8 3 8 8 8 8 8 8 8 3
8 8 8 8 8 8 3 8 8 8 8 8 8 8 3 8
8 8 8 8 8 3 8 8 8 8 8 8 8 3 8 8
8 8 8 8 3 8 8 8 8 8 8 8 3 8 8 8
8 8 8 3 8 8 8 8 8 8 8 3 8 8 8 8
8 8 3 8 8 8 8 8 8 8 3 8 8 8 8 8
8 3 8 8 8 8 8 8 8 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 3 8 8 8 8
8 8 8 8 8 8 8 8 8 8 3 8 8 8 8 8
8 8 8 8 3 8 8 8 8 3 8 8 8 8 8 8
8 8 8 3 2 2 8 8 3 2 2 8 8 8 8 8
8 8 3 2 2 2 2 3 2 2 2 2 8 8 8 8
8 3 2 2 2 2 3 2 2 2 2 2 2 8 8 8
3 2 2 2 2 2 2 2 2 3 2 2 2 2 8 8
8 2 2 2 2 2 2 2 3 2 2 2 2 2 2 8
8 8 2 2 2 2 2 3 2 2 2 2 2 2 2 3
8 8 8 2 2 2 3 2 2 2 2 2 2 2 3 8
8 8 8 8 2 3 2 2 2 2 2 2 2 3 8 8
8 8 8 8 3 2 2 2 2 2 2 2 3 8 8 8
8 8 8 3 8 2 2 2 2 2 2 3 8 8 8 8
8 8 3 8 8 8 2 2 2 2 3 8 8 8 8 8
8 3 8 8 8 8 8 2 2 3 8 8 8 8 8 8
8 8 8 8 8 8 8 8 3 8 8 8 8 8 8 8
```

Okay, let's analyze the provided examples.

**Perception of the Elements:**

1.  **Input Grid:** The input grids feature a dominant background color (azure, 8). Scattered across this background are individual pixels of a different, single color (yellow, 4 in the first example; green, 3 in the second). These non-background pixels appear somewhat sparse.
2.  **Output Grid:** The output grids retain the original background color and the original scattered pixels (yellow/green) in their exact input positions. Additionally, new pixels of red color (2) have been introduced.
3.  **Transformation:** The red pixels appear to form straight lines (horizontal, vertical, and diagonal) connecting pairs of the original scattered pixels (yellow/green). It seems that for every possible pair of the initial yellow/green pixels, a line is drawn between them using the red color.
4.  **Line Drawing:** The lines are drawn *over* the background pixels (azure, 8). Importantly, the original yellow/green pixels are *not* overwritten, even if a line passes through their location. They remain unchanged. The red lines fill the space between the pairs.

**Facts (YAML):**


```yaml
task_description: Draw straight lines between all pairs of non-background pixels.
background_color: 8 (azure)
objects:
  - type: feature_pixels
    description: Isolated pixels that are not the background color.
    color_in_example_1: 4 (yellow)
    color_in_example_2: 3 (green)
    count: Variable across examples and grids.
  - type: background
    description: The dominant color filling most of the grid.
    color: 8 (azure)
  - type: connecting_lines
    description: Pixels added in the output grid to connect pairs of feature pixels.
    color: 2 (red)
relationships:
  - type: pairwise_connection
    description: Every pair of feature pixels defines the start and end points for a potential connecting line.
actions:
  - action: identify_feature_pixels
    description: Locate all pixels in the input grid that are not the background color.
  - action: identify_pairs
    description: Generate all unique pairs from the identified feature pixels.
  - action: draw_lines
    description: For each pair of feature pixels, calculate the coordinates of the pixels forming a straight line between them.
    color_used: 2 (red)
    target_pixels: Only pixels that were originally background pixels (azure, 8) along the line path are changed.
    preservation: Original feature pixels are not overwritten by the connecting lines.
grid_properties:
  - size: Remains the same between input and output.
  - content: Input feature pixels are preserved in the output. Background pixels may be replaced by connecting line pixels.
```


**Natural Language Program:**

1.  Identify the background color (which is azure, 8, in the examples).
2.  Find the coordinates of all pixels in the input grid that are *not* the background color. Let's call these "feature pixels".
3.  Create a copy of the input grid. This copy will become the output grid.
4.  Generate all unique pairs of feature pixel coordinates.
5.  For each pair of coordinates, (point A and point B):
    a.  Determine the set of all grid coordinates that lie on the straight line segment connecting point A and point B. (A line drawing algorithm like Bresenham's can find these.)
    b.  For each coordinate on this line segment:
        i.  Check the color of the pixel at this coordinate in the *original input grid*.
        ii. If the original color was the background color (azure, 8), change the color of the pixel at this coordinate in the *output grid* to red (2).
        iii. If the original color was *not* the background color (i.e., it's one of the feature pixels), do nothing (leave the pixel in the output grid unchanged).
6.  Return the modified output grid.
```python
import numpy as np
import itertools

"""
Identifies the background color (azure, 8). Finds all non-background pixels ("feature pixels").
Creates a copy of the input grid.
Generates all unique pairs of feature pixel coordinates.
For each pair, calculates the coordinates of the pixels forming a straight line between them using Bresenham's algorithm.
For each pixel coordinate on the calculated line:
  If the pixel in the original input grid at this coordinate was the background color (azure, 8), 
  change the color of the pixel at this coordinate in the output grid copy to red (2).
Returns the modified grid copy.
"""

def get_line_pixels(r1, c1, r2, c2):
    """
    Calculates the coordinates of pixels forming a line between (r1, c1) and (r2, c2)
    using Bresenham's line algorithm.
    Handles horizontal, vertical, and diagonal lines.
    """
    points = []
    dr = abs(r2 - r1)
    dc = abs(c2 - c1)
    # Determine step direction for row and column
    sr = 1 if r1 < r2 else -1 if r1 > r2 else 0
    sc = 1 if c1 < c2 else -1 if c1 > c2 else 0

    r, c = r1, c1
    
    # Determine initial error based on dominant axis
    # Adapted Bresenham's algorithm
    if dc > dr:  # Line is more horizontal (or horizontal)
        err = dc / 2.0
        while True:
            points.append((r, c))
            if c == c2: # Reached end column
                 # Ensure the final row is correct, especially for steep lines handled here
                 if r != r2: 
                     # This adjustment might be needed if the standard loop terminates early on column match
                     # but let's test without first, standard Bresenham should handle it.
                     # If issues arise, we might need to force the last point.
                     pass # Assume standard loop is correct for now
                 break 
            err -= dr
            if err < 0:
                r += sr # Move vertically
                err += dc
            c += sc # Always move horizontally (dominant axis)
            # Check loop termination condition again, in case we stepped onto the target
            # This helps ensure termination for lines ending exactly at c2
            if c == c2 and r == r2 and (r,c) not in points:
                 points.append((r, c)) # Add final point if exactly reached after step
                 break

    else:  # Line is more vertical (or vertical, or diagonal 45 deg)
        err = dr / 2.0
        while True:
            points.append((r, c))
            if r == r2: # Reached end row
                 # Similar check for column if needed
                 # if c != c2:
                 #     pass 
                 break
            err -= dc
            if err < 0:
                c += sc # Move horizontally
                err += dr
            r += sr # Always move vertically (dominant axis)
            # Check loop termination condition again
            if c == c2 and r == r2 and (r,c) not in points:
                 points.append((r, c)) # Add final point if exactly reached after step
                 break
                 
    # Ensure the absolute final point is included if the loop terminated slightly early 
    # or due to edge cases. Standard Bresenham should cover this, but double-check.
    if not points or points[-1] != (r2, c2):
         # A simpler loop termination might be `while True:` and `if r == r2 and c == c2: break` inside
         # Let's ensure the last point is always added manually if missing.
         if (r2, c2) not in points:
             points.append((r2, c2))
             
    return points

def transform(input_grid):
    """
    Draws red lines connecting all pairs of non-azure pixels, 
    only coloring over original azure pixels.
    """
    # Make a copy to modify
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape

    # Define colors based on observations
    background_color = 8  # Azure
    line_color = 2        # Red

    # Find coordinates of all "feature" pixels (non-background)
    feature_pixels_coords = []
    for r in range(height):
        for c in range(width):
            if input_grid[r, c] != background_color:
                feature_pixels_coords.append((r, c))

    # If there are fewer than 2 feature pixels, no lines can be drawn
    if len(feature_pixels_coords) < 2:
        return output_grid

    # Generate all unique pairs of feature pixel coordinates
    # Uses itertools.combinations to avoid duplicate pairs (like (A,B) and (B,A))
    # and pairs of a point with itself (like (A,A))
    pixel_pairs = list(itertools.combinations(feature_pixels_coords, 2))

    # Process each pair to draw a line
    for pair in pixel_pairs:
        (r1, c1), (r2, c2) = pair
        
        # Get all pixels coordinates forming the line between the pair
        line_coords = get_line_pixels(r1, c1, r2, c2)

        # Color the line pixels on the output grid
        for r, c in line_coords:
            # Check bounds (Bresenham should stay within reasonable bounds, but safety check)
            if 0 <= r < height and 0 <= c < width:
                # IMPORTANT: Only change the color if the pixel in the ORIGINAL grid was background
                # This prevents overwriting the feature pixels themselves.
                if input_grid[r, c] == background_color:
                    output_grid[r, c] = line_color
            # Else: Pixel is out of bounds (shouldn't happen with correct Bresenham)
            # Or Pixel was a feature pixel (don't overwrite)

    return output_grid
```
