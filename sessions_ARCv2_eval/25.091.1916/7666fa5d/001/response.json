{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport itertools\n\n\"\"\"\nIdentifies the background color (azure, 8). Finds all non-background pixels (\"feature pixels\").\nCreates a copy of the input grid.\nGenerates all unique pairs of feature pixel coordinates.\nFor each pair, calculates the coordinates of the pixels forming a straight line between them using Bresenham's algorithm.\nFor each pixel coordinate on the calculated line:\n  If the pixel in the original input grid at this coordinate was the background color (azure, 8), \n  change the color of the pixel at this coordinate in the output grid copy to red (2).\nReturns the modified grid copy.\n\"\"\"\n\ndef get_line_pixels(r1, c1, r2, c2):\n    \"\"\"\n    Calculates the coordinates of pixels forming a line between (r1, c1) and (r2, c2)\n    using Bresenham's line algorithm.\n    Handles horizontal, vertical, and diagonal lines.\n    \"\"\"\n    points = []\n    dr = abs(r2 - r1)\n    dc = abs(c2 - c1)\n    # Determine step direction for row and column\n    sr = 1 if r1 < r2 else -1 if r1 > r2 else 0\n    sc = 1 if c1 < c2 else -1 if c1 > c2 else 0\n\n    r, c = r1, c1\n    \n    # Determine initial error based on dominant axis\n    # Adapted Bresenham's algorithm\n    if dc > dr:  # Line is more horizontal (or horizontal)\n        err = dc / 2.0\n        while True:\n            points.append((r, c))\n            if c == c2: # Reached end column\n                 # Ensure the final row is correct, especially for steep lines handled here\n                 if r != r2: \n                     # This adjustment might be needed if the standard loop terminates early on column match\n                     # but let's test without first, standard Bresenham should handle it.\n                     # If issues arise, we might need to force the last point.\n                     pass # Assume standard loop is correct for now\n                 break \n            err -= dr\n            if err < 0:\n                r += sr # Move vertically\n                err += dc\n            c += sc # Always move horizontally (dominant axis)\n            # Check loop termination condition again, in case we stepped onto the target\n            # This helps ensure termination for lines ending exactly at c2\n            if c == c2 and r == r2 and (r,c) not in points:\n                 points.append((r, c)) # Add final point if exactly reached after step\n                 break\n\n    else:  # Line is more vertical (or vertical, or diagonal 45 deg)\n        err = dr / 2.0\n        while True:\n            points.append((r, c))\n            if r == r2: # Reached end row\n                 # Similar check for column if needed\n                 # if c != c2:\n                 #     pass \n                 break\n            err -= dc\n            if err < 0:\n                c += sc # Move horizontally\n                err += dr\n            r += sr # Always move vertically (dominant axis)\n            # Check loop termination condition again\n            if c == c2 and r == r2 and (r,c) not in points:\n                 points.append((r, c)) # Add final point if exactly reached after step\n                 break\n                 \n    # Ensure the absolute final point is included if the loop terminated slightly early \n    # or due to edge cases. Standard Bresenham should cover this, but double-check.\n    if not points or points[-1] != (r2, c2):\n         # A simpler loop termination might be `while True:` and `if r == r2 and c == c2: break` inside\n         # Let's ensure the last point is always added manually if missing.\n         if (r2, c2) not in points:\n             points.append((r2, c2))\n             \n    return points\n\ndef transform(input_grid):\n    \"\"\"\n    Draws red lines connecting all pairs of non-azure pixels, \n    only coloring over original azure pixels.\n    \"\"\"\n    # Make a copy to modify\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define colors based on observations\n    background_color = 8  # Azure\n    line_color = 2        # Red\n\n    # Find coordinates of all \"feature\" pixels (non-background)\n    feature_pixels_coords = []\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r, c] != background_color:\n                feature_pixels_coords.append((r, c))\n\n    # If there are fewer than 2 feature pixels, no lines can be drawn\n    if len(feature_pixels_coords) < 2:\n        return output_grid\n\n    # Generate all unique pairs of feature pixel coordinates\n    # Uses itertools.combinations to avoid duplicate pairs (like (A,B) and (B,A))\n    # and pairs of a point with itself (like (A,A))\n    pixel_pairs = list(itertools.combinations(feature_pixels_coords, 2))\n\n    # Process each pair to draw a line\n    for pair in pixel_pairs:\n        (r1, c1), (r2, c2) = pair\n        \n        # Get all pixels coordinates forming the line between the pair\n        line_coords = get_line_pixels(r1, c1, r2, c2)\n\n        # Color the line pixels on the output grid\n        for r, c in line_coords:\n            # Check bounds (Bresenham should stay within reasonable bounds, but safety check)\n            if 0 <= r < height and 0 <= c < width:\n                # IMPORTANT: Only change the color if the pixel in the ORIGINAL grid was background\n                # This prevents overwriting the feature pixels themselves.\n                if input_grid[r, c] == background_color:\n                    output_grid[r, c] = line_color\n            # Else: Pixel is out of bounds (shouldn't happen with correct Bresenham)\n            # Or Pixel was a feature pixel (don't overwrite)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4034,
    "candidates_token_count": 1440,
    "total_token_count": 5474,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.964019,
  "retries": 1
}