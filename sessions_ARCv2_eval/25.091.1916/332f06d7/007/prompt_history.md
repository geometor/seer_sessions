
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

*   **Perception:** The task involves conditional color replacement based on the input grid's properties. The primary colors involved are red (2) and white (0). White pixels always change to blue (1). Red pixels change to white (0) only if a specific condition related to the grid's size is met. Other colors, like blue (1) and green (3), are present but remain unchanged and do not seem to directly influence the transformation rule, except potentially as context that was considered during analysis. The key insight is identifying that the grid dimensions act as the condition for the transformation of red pixels.

*   **Facts:**
    
```yaml
    task_elements:
      - element: grid
        properties:
          - height: integer between 1 and 30
          - width: integer between 1 and 30
          - pixels: colored cells with values 0-9
      - element: pixel_color_white
        value: 0
        transformation: changes to blue (1)
        condition: always
      - element: pixel_color_red
        value: 2
        transformation: changes to white (0)
        condition: depends on grid size
    conditions:
      - condition_name: grid_size_check
        property: grid dimensions (height H, width W)
        rule: (H < 14) AND (W < 14)
    relationships:
      - The transformation rule for red pixels (2) is gated by the grid_size_check condition.
      - If grid_size_check is true, red pixels change to white (0).
      - If grid_size_check is false, red pixels remain red (2).
      - The transformation rule for white pixels (0) is independent and always results in blue (1).
      - All other pixel colors remain unchanged.

    ```


*   **Natural Language Program:**
    1.  Determine the height (H) and width (W) of the input grid.
    2.  Create a new grid with the same dimensions as the input grid.
    3.  Evaluate the condition: Is H less than 14 AND W less than 14?
    4.  Iterate through each cell of the input grid at position (row, column):
        a.  Get the color value `C` of the input cell.
        b.  If `C` is 0 (white), set the corresponding cell in the new grid to 1 (blue).
        c.  Else if `C` is 2 (red):
            i.  If the condition (H < 14 AND W < 14) is true, set the corresponding cell in the new grid to 0 (white).
            ii. If the condition is false, set the corresponding cell in the new grid to 2 (red).
        d.  Else (for any other color `C`), set the corresponding cell in the new grid to `C`.
    5.  The new grid is the output.
```python
import numpy as np

"""
Transforms the input grid based on pixel color and grid dimensions.

1.  Determine the height (H) and width (W) of the input grid.
2.  Create a new grid (output_grid) as a copy of the input grid.
3.  Evaluate the condition: Is H less than 14 AND W less than 14?
4.  Iterate through each cell of the input grid at position (row, column):
    a.  Get the color value `C` of the input cell.
    b.  If `C` is 0 (white), set the corresponding cell in the output_grid to 1 (blue).
    c.  Else if `C` is 2 (red):
        i.  If the condition (H < 14 AND W < 14) is true, set the corresponding cell in the output_grid to 0 (white).
        ii. If the condition is false, the corresponding cell in output_grid remains 2 (red) (handled by initial copy).
    d.  Else (for any other color `C`), the corresponding cell in output_grid remains `C` (handled by initial copy).
5.  The output_grid is the final result.
"""

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # 1. Determine the height (H) and width (W) of the input grid.
    H, W = input_grid.shape

    # 2. Create a new grid (output_grid) as a copy of the input grid.
    #    This handles step 4d implicitly (other colors remain unchanged).
    output_grid = np.copy(input_grid)

    # 3. Evaluate the condition: Is H less than 14 AND W less than 14?
    is_small_grid = H < 14 and W < 14

    # 4. Iterate through each cell of the input grid.
    for r in range(H):
        for c in range(W):
            input_pixel = input_grid[r, c]

            # a. Get the color value `C` (already done: input_pixel)

            # b. If `C` is 0 (white), set output to 1 (blue).
            if input_pixel == 0:
                output_grid[r, c] = 1
            # c. Else if `C` is 2 (red):
            elif input_pixel == 2:
                # i. If the condition is true, set output to 0 (white).
                if is_small_grid:
                    output_grid[r, c] = 0
                # ii. If the condition is false, output remains 2 (handled by copy).
                # else: # No action needed, already copied
                #     output_grid[r, c] = 2

    # 5. The new grid is the output.
    return output_grid
```
```python
import numpy as np

"""
Transforms the input grid based on pixel color and grid dimensions.
The transformation rule depends on whether the grid is "small" (both height and width < 14) or "large" (height >= 14 or width >= 14).

Rule Breakdown:
1.  Determine grid dimensions (Height H, Width W).
2.  Check if the grid is small: `is_small = (H < 14 and W < 14)`
3.  Iterate through each pixel:
    - If the pixel is White (0): Always change it to Blue (1), regardless of grid size.
    - If the grid is small (`is_small` is True):
        - If the pixel is Red (2): Change it to White (0).
        - Other colors remain unchanged.
    - If the grid is large (`is_small` is False):
        - If the pixel is Blue (1): Change it to White (0).
        - Other colors (including Red (2)) remain unchanged.
"""

def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rule to the input grid based on its size.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # 1. Determine grid dimensions (Height H, Width W).
    H, W = input_grid.shape

    # 2. Check if the grid is small.
    is_small_grid = H < 14 and W < 14

    # Initialize output_grid as a copy of the input grid.
    # This handles cases where pixels remain unchanged.
    output_grid = np.copy(input_grid)

    # 3. Iterate through each pixel.
    for r in range(H):
        for c in range(W):
            pixel_color = input_grid[r, c]

            # Rule: White (0) always becomes Blue (1).
            if pixel_color == 0:
                output_grid[r, c] = 1
            # Rules specific to small grids.
            elif is_small_grid:
                # Rule: Red (2) becomes White (0) in small grids.
                if pixel_color == 2:
                    output_grid[r, c] = 0
                # Other colors (1, 3-9) remain unchanged (handled by copy).
            # Rules specific to large grids.
            else: # not is_small_grid (i.e., large grid)
                # Rule: Blue (1) becomes White (0) in large grids.
                if pixel_color == 1:
                    output_grid[r, c] = 0
                # Other colors (2-9, excluding 0 which was handled above) remain unchanged (handled by copy).

    return output_grid
```
```python
import numpy as np

"""
Transforms the input grid based on pixel color and grid dimensions.
The transformation rules depend on whether the grid is "small" (both height and width < 14) or "large" (height >= 14 or width >= 14).

Rule Overview:
1. White(0) pixels always change to Blue(1).
2. If the grid is small (H < 14 AND W < 14):
   - Red(2) pixels change to White(0).
   - Other colors (including Blue(1)) remain unchanged.
3. If the grid is large (H >= 14 OR W >= 14):
   - Blue(1) pixels change to White(0) *only if* all 8 of their neighbors in the input grid are either Blue(1) or Green(3).
   - Other colors (including Red(2)) remain unchanged.
"""

def _check_blue_neighbors(grid: np.ndarray, r: int, c: int) -> bool:
    """
    Checks if all 8 neighbors of a Blue(1) pixel at (r, c) are either Blue(1) or Green(3).

    Args:
        grid: The input numpy array representing the grid.
        r: The row index of the pixel to check.
        c: The column index of the pixel to check.

    Returns:
        True if all neighbors are Blue(1) or Green(3), False otherwise.
    """
    H, W = grid.shape
    # Iterate through the 8 neighbors (relative coordinates)
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the center pixel itself
            if dr == 0 and dc == 0:
                continue

            nr, nc = r + dr, c + dc

            # Check boundary conditions
            if 0 <= nr < H and 0 <= nc < W:
                neighbor_color = grid[nr, nc]
                # If a neighbor is *not* Blue(1) and *not* Green(3), condition fails
                if neighbor_color != 1 and neighbor_color != 3:
                    return False
            # Implicitly, neighbors outside the grid don't violate the condition,
            # but practically, for a pixel to be truly 'surrounded', it shouldn't
            # be on the edge unless the edge is filled with 1s or 3s.
            # However, based on typical ARC behavior, edge cases often just need
            # to check valid neighbors. Let's stick to checking only valid neighbors.

    # If the loop completes without returning False, all valid neighbors are 1 or 3.
    return True


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rules to the input grid.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Get grid dimensions
    H, W = input_grid.shape

    # Initialize output_grid as a copy - handles unchanged pixels
    output_grid = np.copy(input_grid)

    # Determine if the grid is small
    is_small = H < 14 and W < 14

    # Iterate through each cell of the input grid
    for r in range(H):
        for c in range(W):
            pixel_color = input_grid[r, c]

            # Rule 1: White(0) always becomes Blue(1)
            if pixel_color == 0:
                output_grid[r, c] = 1
            # Rule 2: Small grid specific transformation for Red(2)
            elif is_small and pixel_color == 2:
                output_grid[r, c] = 0
            # Rule 3: Large grid specific transformation for Blue(1)
            elif not is_small and pixel_color == 1:
                # Check neighbors using the helper function on the *input* grid
                if _check_blue_neighbors(input_grid, r, c):
                    output_grid[r, c] = 0
            # Other cases: pixel remains unchanged (handled by initial copy)

    return output_grid
```

Previous Code:
```python
import numpy as np

"""
Transforms the input grid based on pixel color and grid dimensions.
The transformation rules depend on whether the grid is "small" (both height and width < 14) or "large" (height >= 14 or width >= 14).

Rule Overview:
1. White(0) pixels always change to Blue(1).
2. If the grid is small (H < 14 AND W < 14):
   - Red(2) pixels change to White(0).
   - Other colors (including Blue(1)) remain unchanged.
3. If the grid is large (H >= 14 OR W >= 14):
   - Blue(1) pixels change to White(0) *only if* all 8 of their neighbors in the input grid are either Blue(1) or Green(3).
   - Other colors (including Red(2)) remain unchanged.
"""

def _check_blue_neighbors(grid: np.ndarray, r: int, c: int) -> bool:
    """
    Checks if all 8 neighbors of a Blue(1) pixel at (r, c) are either Blue(1) or Green(3).

    Args:
        grid: The input numpy array representing the grid.
        r: The row index of the pixel to check.
        c: The column index of the pixel to check.

    Returns:
        True if all neighbors are Blue(1) or Green(3), False otherwise.
    """
    H, W = grid.shape
    # Iterate through the 8 neighbors (relative coordinates)
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            # Skip the center pixel itself
            if dr == 0 and dc == 0:
                continue

            nr, nc = r + dr, c + dc

            # Check boundary conditions
            if 0 <= nr < H and 0 <= nc < W:
                neighbor_color = grid[nr, nc]
                # If a neighbor is *not* Blue(1) and *not* Green(3), condition fails
                if neighbor_color != 1 and neighbor_color != 3:
                    return False
            # Implicitly, neighbors outside the grid don't violate the condition,
            # but practically, for a pixel to be truly 'surrounded', it shouldn't
            # be on the edge unless the edge is filled with 1s or 3s.
            # However, based on typical ARC behavior, edge cases often just need
            # to check valid neighbors. Let's stick to checking only valid neighbors.

    # If the loop completes without returning False, all valid neighbors are 1 or 3.
    return True


def transform(input_grid: np.ndarray) -> np.ndarray:
    """
    Applies the transformation rules to the input grid.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Get grid dimensions
    H, W = input_grid.shape

    # Initialize output_grid as a copy - handles unchanged pixels
    output_grid = np.copy(input_grid)

    # Determine if the grid is small
    is_small = H < 14 and W < 14

    # Iterate through each cell of the input grid
    for r in range(H):
        for c in range(W):
            pixel_color = input_grid[r, c]

            # Rule 1: White(0) always becomes Blue(1)
            if pixel_color == 0:
                output_grid[r, c] = 1
            # Rule 2: Small grid specific transformation for Red(2)
            elif is_small and pixel_color == 2:
                output_grid[r, c] = 0
            # Rule 3: Large grid specific transformation for Blue(1)
            elif not is_small and pixel_color == 1:
                # Check neighbors using the helper function on the *input* grid
                if _check_blue_neighbors(input_grid, r, c):
                    output_grid[r, c] = 0
            # Other cases: pixel remains unchanged (handled by initial copy)

    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```
Transformed Output:
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0

## Example 2:
Input:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 0 0 0 0 1 1 1 3 3
3 3 3 3 3 0 0 0 0 1 1 1 3 3
3 3 3 3 3 0 0 3 3 3 3 3 3 3
3 3 3 3 3 0 0 3 3 3 3 3 3 3
3 3 3 3 3 0 0 3 3 3 3 3 3 3
3 3 3 3 3 0 0 0 0 0 3 3 3 3
3 3 3 3 3 0 0 0 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 0 3 3 3 3
3 0 0 0 0 0 0 0 0 0 3 3 3 3
3 1 1 1 0 0 0 0 0 0 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```
Match: False
Pixels Off: 36
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 36.734693877551024

## Example 3:
Input:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Expected Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 0 0 0 0 0 0 0 0 0 0 0 3
2 2 2 1 0 0 0 3 3 0 0 0 0 0 0 3
2 2 2 1 0 3 3 3 3 3 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 3
3 3 3 0 0 0 0 0 0 0 3 3 3 0 0 3
3 3 3 0 0 0 0 0 0 0 3 3 3 0 0 3
3 3 3 0 0 0 0 0 0 0 3 3 3 0 0 3
3 3 0 0 0 0 3 0 0 0 3 3 3 0 0 3
3 3 0 0 0 0 3 0 0 3 3 3 0 0 0 3
3 3 0 0 0 0 3 0 0 3 3 3 0 0 0 3
3 3 1 1 1 3 3 0 0 3 3 3 0 0 0 3
3 1 1 1 1 3 3 0 0 0 0 0 0 0 0 3
3 1 1 1 1 3 3 0 0 0 0 0 0 0 0 3
3 1 1 1 1 3 3 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```
Match: False
Pixels Off: 102
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 79.6875

## Example 4:
Input:
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```
Expected Output:
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0
**General Assessment:**

The initial analysis correctly identified that White(0) pixels always become Blue(1) and that grid dimensions play a role. The distinction between "small" grids (H<14 and W<14) and "large" grids (H>=14 or W>=14) appears valid. The rule for small grids (Red(2) -> White(0)) worked correctly for Examples 1 and 4.

The failures occurred in the large grid examples (2 and 3). The previous assumption about the transformation of Blue(1) pixels in large grids (based on neighbor checks for individual pixels) was incorrect. It resulted in too many Blue(1) pixels being changed to White(0).

The key insight seems to be related to specific *shapes* within the grid. In the large grid examples, only solid rectangular blocks composed entirely of Blue(1) pixels, whose immediate surrounding neighbors (perimeter cells) are all either Blue(1) or Green(3), are transformed to White(0).

**Strategy:**

1.  Confirm the grid dimension categories.
2.  Refine the rules based on the small/large grid distinction.
3.  For large grids, implement logic to:
    *   Identify all possible solid rectangular blocks consisting solely of Blue(1) pixels.
    *   For each such rectangle, check the colors of all cells directly adjacent to its perimeter (including diagonals).
    *   If all these neighboring cells are either Blue(1) or Green(3) in the *input* grid, then change the pixels within that rectangular block to White(0) in the *output* grid.
4.  Ensure the White(0) -> Blue(1) rule applies universally.
5.  Ensure the Red(2) -> White(0) rule applies only to small grids.
6.  Ensure Red(2) pixels and other colors remain unchanged in large grids, except for the specific Blue(1) rectangles identified above.

**Metrics:**

| Example   | Input Dimensions | Category | Previous Code Match | Previous Code Pixels Off | Analysis Notes                                                                  |
| :-------- | :--------------- | :------- | :------------------ | :----------------------- | :------------------------------------------------------------------------------ |
| train\_1  | 12x12            | Small    | True                | 0                        | Small grid rule (0->1, 2->0) applied correctly.                                 |
| train\_2  | 14x14            | Large    | False               | 36                       | Large grid. Incorrect Blue(1)->White(0) transformation. Target: 2x2 Blue block. |
| train\_3  | 16x16            | Large    | False               | 102                      | Large grid. Incorrect Blue(1)->White(0) transformation. Target: 3x3 Blue block. |
| train\_4  | 10x10            | Small    | True                | 0                        | Small grid rule (0->1, 2->0) applied correctly.                                 |

**Facts:**


```yaml
grid_properties:
  - height: H
  - width: W
  - category: Small if H < 14 and W < 14, else Large

pixel_colors:
  - color_name: White
    value: 0
  - color_name: Blue
    value: 1
  - color_name: Red
    value: 2
  - color_name: Green
    value: 3
  - color_name: Other
    value: 4-9

transformations:
  - applies_to: White (0) pixels
    condition: Always (regardless of grid category)
    action: Change color to Blue (1).
  - applies_to: Red (2) pixels
    condition: Grid category is Small.
    action: Change color to White (0).
  - applies_to: Red (2) pixels
    condition: Grid category is Large.
    action: No change.
  - applies_to: Blue (1) pixels
    condition: Grid category is Small.
    action: No change.
  - applies_to: Blue (1) pixels
    condition: Grid category is Large.
    action: Change color to White (0) IF the pixel is part of a solid rectangular block of Blue(1)s AND all cells immediately neighboring this block's perimeter (including diagonals) in the input grid are either Blue(1) or Green(3). Otherwise, no change.
  - applies_to: Green (3) pixels
    condition: Always.
    action: No change.
  - applies_to: Other (4-9) pixels
    condition: Always.
    action: No change.

objects:
  - type: Solid Rectangular Block
    composed_of: Blue (1) pixels
    relevance: Subject to transformation in Large grids based on neighbor conditions.

neighbor_condition (for Blue rectangles in Large grids):
  - requirement: All cells adjacent to the perimeter of the Blue(1) rectangle must be Blue(1) or Green(3).
  - scope: Checks 8 directions (including diagonals) around the entire perimeter.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Determine the height (H) and width (W) of the input grid.
3.  Determine the grid category: "Small" if H < 14 and W < 14, otherwise "Large".
4.  **First Pass (Universal White Transformation):** Iterate through every cell (r, c) of the input grid. If the input pixel `input_grid[r, c]` is White(0), set the corresponding output pixel `output_grid[r, c]` to Blue(1).
5.  **Second Pass (Category-Specific Transformations):**
    a.  **If the grid category is "Small":**
        i.  Iterate through every cell (r, c). If the input pixel `input_grid[r, c]` is Red(2), set the corresponding output pixel `output_grid[r, c]` to White(0). *(Note: White pixels were already handled in the first pass)*.
    b.  **If the grid category is "Large":**
        i.  Identify all possible solid rectangular blocks composed entirely of Blue(1) pixels in the *input* grid. Iterate through potential top-left corners (r1, c1) and bottom-right corners (r2, c2).
        ii. For each potential rectangle defined by `(r1, c1)` and `(r2, c2)`:
            1.  Verify it contains *only* Blue(1) pixels in the `input_grid`.
            2.  If it's a solid Blue(1) rectangle, check all its neighboring cells in the `input_grid`. A neighbor is any cell `(nr, nc)` such that `r1-1 <= nr <= r2+1` and `c1-1 <= nc <= c2+1`, excluding the cells within the rectangle itself (`r1 <= nr <= r2` and `c1 <= nc <= c2`). Handle boundary conditions (neighbors outside the grid do not invalidate the condition).
            3.  Check if *all* valid neighboring cells have a color of Blue(1) or Green(3).
            4.  If the neighbor condition is met, iterate through all cells `(r, c)` within this rectangle (`r1 <= r <= r2`, `c1 <= c <= c2`) and set the corresponding `output_grid[r, c]` pixel to White(0). *(Important: This overwrites the Blue(1) value copied initially or potentially set in the first pass if the original was White(0) - although 0->1 is handled first, so this shouldn't be an issue)*.
6.  The final `output_grid` contains the result.
