
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 3 3 8 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 3 1 1 1 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's break down this task.

**Perception**

1.  **Grid Structure:** The input and output grids have the same dimensions in each example.
2.  **Background Color:** The dominant color in both input and output is Azure (8), acting as the background.
3.  **Input Elements:**
    *   There are distinct shapes composed of Blue (1) and Green (3) pixels. The Green pixels often appear at corners or edges but seem functionally part of the Blue shapes. Let's call these "Blue/Green shapes". The number of these shapes varies across examples (1, 4, 3, 2).
    *   There is always a single Yellow (4) pixel.
    *   Directly below the Yellow pixel, there is a short vertical line of Red (2) pixels. This Yellow/Red structure appears consistently in one column. Let's call this the "Key Column".
4.  **Output Elements:**
    *   The output grids consist only of the background color (Azure, 8) and Red (2) pixels.
    *   The Blue/Green shapes and the Yellow/Red key structure from the input are absent in the output.
    *   Two distinct output patterns emerge based on the input:
        *   In Example 1, where there's only *one* Blue/Green shape, the output is a solid Red vertical line filling the *entire* Key Column.
        *   In Examples 2, 3, and 4, where there are *multiple* Blue/Green shapes, the output grid replicates the exact positions of *all* the input Blue/Green shapes, but colored Red (2) instead of Blue (1) or Green (3).

**Facts**


```yaml
Task: Conditional Shape Transformation or Column Fill

Grid_Properties:
  - Background_Color: 8 (Azure)
  - Grid_Size_Preserved: True

Input_Objects:
  - Object: Key_Marker
    - Pixels:
        - Color: 4 (Yellow), Count: 1
        - Color: 2 (Red), Variable Count (>=1)
    - Properties:
        - Yellow pixel is unique.
        - Red pixels form a vertical line directly below the Yellow pixel.
    - Role: Defines the 'Key_Column'. Also involved in triggering the transformation.
  - Object: Shapes
    - Pixels:
        - Color: 1 (Blue)
        - Color: 3 (Green)
    - Properties:
        - Form connected components (objects).
        - Green pixels seem part of the Blue shapes structurally.
        - The number of distinct shapes varies (1 to many).
    - Role: These are the primary objects potentially transformed or counted.

Relationships_Actions:
  - Relationship: Key_Column_Definition
    - Element1: Key_Marker (Yellow pixel)
    - Element2: Grid Column
    - Description: The column containing the Yellow pixel (and the Red line below it) is the Key_Column.
  - Action: Count_Shapes
    - Target: Shapes (Blue/Green objects)
    - Description: Determine the number of distinct, disconnected Blue/Green shapes.
  - Action: Conditional_Transformation
    - Trigger: Count of Shapes
    - Condition_1: Count == 1
      - Result: Fill the entire Key_Column with Red (2) in the output grid. Set all other pixels to the Background_Color (8).
    - Condition_2: Count > 1
      - Result: For every pixel belonging to any Blue (1) or Green (3) shape in the input, color the corresponding pixel Red (2) in the output grid. Set all other pixels to the Background_Color (8).

Output_Objects:
  - Color: 2 (Red)
  - Represents: Either the Key_Column (if input shape count was 1) or the copied locations of input Shapes (if input shape count > 1).
  - Color: 8 (Azure)
  - Represents: Background filler.
```


**Natural Language Program**

1.  Initialize the output grid with the same dimensions as the input grid, filling it entirely with the background color (Azure, 8).
2.  Identify all distinct, connected shapes (objects) composed of Blue (1) pixels and Green (3) pixels in the input grid. Treat Blue and Green pixels equally when defining the boundaries of these shapes.
3.  Count the total number of these distinct Blue/Green shapes found.
4.  Locate the single Yellow (4) pixel in the input grid and determine its column index (the Key_Column).
5.  **Conditional Step:**
    *   **If** the count of Blue/Green shapes is exactly 1:
        *   Fill every cell in the Key_Column of the output grid with Red (2).
    *   **Else (if** the count of Blue/Green shapes is greater than 1):
        *   Iterate through all the pixel coordinates (row, column) that were part of *any* Blue/Green shape identified in step 2.
        *   For each such coordinate, set the corresponding pixel in the output grid to Red (2).
6.  Return the modified output grid.
```python
import numpy as np
from scipy.ndimage import label

"""
Transformation Rule:

1. Identify all distinct connected shapes composed of Blue (1) and Green (3) pixels in the input grid. Treat Blue and Green as equivalent for shape definition.
2. Count the total number of these distinct shapes.
3. Locate the single Yellow (4) pixel and identify its column (the "Key Column").
4. Based on the shape count:
    a. If the count is exactly 1: Create an output grid of the same dimensions filled with the background color (Azure, 8), and then set all pixels in the Key Column to Red (2).
    b. If the count is greater than 1: Create an output grid of the same dimensions filled with the background color (Azure, 8). Then, for every pixel that was part of any Blue (1) or Green (3) shape in the input, set the corresponding pixel in the output grid to Red (2).
"""

def find_objects(grid, colors):
    """
    Finds connected objects of specified colors in a grid.

    Args:
        grid (np.ndarray): The input grid.
        colors (list or set): A list or set of color values to consider as part of the objects.

    Returns:
        tuple: A tuple containing:
            - labeled_array (np.ndarray): An array where each object is marked with a unique integer label.
            - num_objects (int): The total number of distinct objects found.
    """
    mask = np.isin(grid, list(colors))
    labeled_array, num_objects = label(mask)
    return labeled_array, num_objects

def transform(input_grid):
    """
    Applies the transformation rule based on the count of Blue/Green shapes.

    Args:
        input_grid (np.ndarray): The input 2D grid.

    Returns:
        np.ndarray: The transformed 2D grid.
    """
    # Define colors
    background_color = 8
    shape_colors = {1, 3}  # Blue and Green
    key_color = 4          # Yellow
    output_color = 2       # Red

    # Initialize output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # Find and count the Blue/Green shapes
    labeled_shapes, num_shapes = find_objects(input_grid, shape_colors)

    # Find the location of the Yellow key pixel
    key_coords = np.where(input_grid == key_color)
    if len(key_coords[0]) == 0:
        # Handle case where key color is not found (optional, based on task constraints)
        # For this task, assume it's always present based on examples.
        # If it could be missing, we might return the initial background grid or raise an error.
        print("Warning: Key color (Yellow) not found.")
        return output_grid 
    
    # Assuming only one key pixel exists as per examples
    key_col = key_coords[1][0] 

    # Apply conditional transformation based on the number of shapes
    if num_shapes == 1:
        # Fill the entire Key Column with the output color
        output_grid[:, key_col] = output_color
    elif num_shapes > 1:
        # Find all coordinates belonging to the Blue/Green shapes
        shape_coords = np.where(np.isin(input_grid, list(shape_colors)))
        # Set the corresponding pixels in the output grid to the output color
        output_grid[shape_coords] = output_color
    # If num_shapes == 0, the output grid remains the background color, which seems correct.

    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label
from scipy.spatial import ConvexHull
from matplotlib.path import Path

"""
Transformation Rule:

1. Identify all distinct connected shapes composed of Blue (1) and Green (3) pixels. Treat these colors as equivalent for shape definition.
2. Count the total number of these distinct shapes.
3. Locate the single Yellow (4) pixel and identify its column index (the "Key Column").
4. Based on the shape count:
    a. If the count is exactly 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Fill the entire Key Column with Red (2).
    b. If the count is greater than 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Collect all coordinates (row, col) of the Blue (1) and Green (3) pixels.
        - If 3 or more such pixels exist:
            - Calculate the convex hull of these points.
            - Determine the bounding box (min/max row/col) enclosing the hull vertices.
            - Iterate through all integer grid coordinates (pixels) within this bounding box.
            - For each coordinate, check if it lies inside or on the boundary of the convex hull polygon.
            - If it does, set the corresponding pixel in the output grid to Red (2).
        - If fewer than 3 such pixels exist (cannot form a polygon):
            - Color only the original Blue/Green pixel locations Red (2) in the output grid.
"""

def find_objects(grid, colors):
    """
    Finds connected objects of specified colors in a grid using 8-way connectivity.

    Args:
        grid (np.ndarray): The input grid.
        colors (list or set): A list or set of color values to consider as part of the objects.

    Returns:
        tuple: A tuple containing:
            - labeled_array (np.ndarray): An array where each object is marked with a unique integer label.
            - num_objects (int): The total number of distinct objects found.
    """
    mask = np.isin(grid, list(colors))
    # Define connectivity structure (8-way including diagonals)
    structure = np.array([[1,1,1],
                          [1,1,1],
                          [1,1,1]], dtype=bool)
    labeled_array, num_objects = label(mask, structure=structure)
    return labeled_array, num_objects

def points_inside_hull(points, hull):
    """
    Generates grid points inside a convex hull.

    Args:
        points (np.ndarray): N x 2 array of points defining the hull vertices.
        hull (scipy.spatial.ConvexHull): The calculated convex hull object.

    Returns:
        list: A list of [row, col] coordinates inside or on the boundary of the hull.
    """
    path = Path(points[hull.vertices])
    
    # Determine bounding box
    min_r, min_c = np.min(points[hull.vertices], axis=0).astype(int)
    max_r, max_c = np.max(points[hull.vertices], axis=0).astype(int)

    inside_points = []
    # Iterate through grid points within the bounding box
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            # Check if the center of the pixel (r, c) is inside the path
            # Use a small tolerance for points exactly on the boundary
            if path.contains_point([r, c], radius=1e-9): 
                inside_points.append([r, c])
                
    # Also explicitly add the original points that form the hull vertices
    # This ensures boundary points are definitely included, addressing potential floating point issues
    # Convert hull vertices back to original point coordinates if necessary
    for vertex_idx in hull.vertices:
        point = points[vertex_idx].astype(int) # Ensure integer coordinates
        if list(point) not in inside_points:
             inside_points.append(list(point))
             
    # Add the original shape points as well to ensure they are colored
    # This covers cases where points are inside the hull but not vertices
    # and helps with thin shapes or lines that might not be fully captured by contains_point test
    for r_orig, c_orig in zip(*np.where(np.isin(input_grid, list(shape_colors)))) :
        point = [r_orig, c_orig]
        if point not in inside_points:
            inside_points.append(point)

    return inside_points


def transform(input_grid):
    """
    Applies the transformation rule based on the count and configuration of Blue/Green shapes.

    Args:
        input_grid (np.ndarray): The input 2D grid.

    Returns:
        np.ndarray: The transformed 2D grid.
    """
    # Define colors
    global background_color, shape_colors, key_color, output_color # Make global for helper
    background_color = 8
    shape_colors = {1, 3}  # Blue and Green
    key_color = 4          # Yellow
    output_color = 2       # Red

    # Initialize output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # Find and count the Blue/Green shapes
    labeled_shapes, num_shapes = find_objects(input_grid, shape_colors)

    # Find the location of the Yellow key pixel
    key_coords = np.where(input_grid == key_color)
    if len(key_coords[0]) == 0:
        # Should not happen based on examples, but handle defensively
        print("Warning: Key color (Yellow) not found.")
        return output_grid # Return background grid if key is missing

    key_col = key_coords[1][0] # Assume only one key pixel

    # --- Conditional Transformation ---
    if num_shapes == 1:
        # Case 1: Single shape -> Fill Key Column
        output_grid[:, key_col] = output_color
        
    elif num_shapes > 1:
        # Case 2: Multiple shapes -> Fill Convex Hull
        
        # Get coordinates of all blue/green pixels
        shape_pixel_coords_r, shape_pixel_coords_c = np.where(np.isin(input_grid, list(shape_colors)))
        
        # Check if we have enough points for a hull
        if len(shape_pixel_coords_r) >= 3:
            # Combine row and column coordinates into a list of [row, col] pairs
            points = np.vstack((shape_pixel_coords_r, shape_pixel_coords_c)).T
            
            try:
                # Calculate the convex hull
                hull = ConvexHull(points)
                
                # Find all integer grid points inside the hull
                fill_points = points_inside_hull(points, hull)
                
                # Color the identified points in the output grid
                for r, c in fill_points:
                    # Ensure coordinates are within grid bounds before coloring
                    if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:
                        output_grid[r, c] = output_color
                        
            except Exception as e:
                 # This might happen if points are collinear, ConvexHull fails
                 print(f"ConvexHull calculation failed (possibly collinear points): {e}")
                 # Fallback: Just color the original shape pixels
                 output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color

        elif len(shape_pixel_coords_r) > 0: # Handle cases with 1 or 2 points (lines)
             # Fallback for too few points: Just color the original shape pixels
             output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color
             
    # If num_shapes == 0, the grid remains background color, which is correct.

    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label
from scipy.spatial import ConvexHull
from matplotlib.path import Path

"""
Transformation Rule:

1. Identify all distinct connected shapes composed of Blue (1) and Green (3) pixels using 8-way connectivity. Treat these colors as equivalent for shape definition.
2. Count the total number of these distinct shapes.
3. Locate the single Yellow (4) pixel and identify its column index (the "Key Column").
4. Based on the shape count:
    a. If the count is exactly 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Fill the entire Key Column with Red (2).
    b. If the count is greater than 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Collect all coordinates (row, col) of the Blue (1) and Green (3) pixels.
        - If 3 or more such pixels exist:
            - Calculate the convex hull of these points.
            - Determine the bounding box (min/max row/col) enclosing the hull vertices.
            - Iterate through all integer grid coordinates (pixels) within this bounding box.
            - For each coordinate, check if it lies inside or on the boundary of the convex hull polygon using matplotlib.path.
            - If it does, set the corresponding pixel in the output grid to Red (2).
            - Ensure original shape pixels are also colored Red (2) in the output.
        - If fewer than 3 such pixels exist (cannot form a polygon):
            - Color only the original Blue/Green pixel locations Red (2) in the output grid.
    c. If the count is 0:
        - Return the background grid.
"""

def find_objects(grid, colors):
    """
    Finds connected objects of specified colors in a grid using 8-way connectivity.

    Args:
        grid (np.ndarray): The input grid.
        colors (list or set): A list or set of color values to consider as part of the objects.

    Returns:
        tuple: A tuple containing:
            - labeled_array (np.ndarray): An array where each object is marked with a unique integer label.
            - num_objects (int): The total number of distinct objects found.
    """
    mask = np.isin(grid, list(colors))
    # Define connectivity structure (8-way including diagonals)
    structure = np.array([[1,1,1],
                          [1,1,1],
                          [1,1,1]], dtype=bool)
    labeled_array, num_objects = label(mask, structure=structure)
    return labeled_array, num_objects

def get_pixels_inside_hull(grid_shape, points, hull):
    """
    Generates integer grid coordinates inside or on the boundary of a convex hull polygon.

    Args:
        grid_shape (tuple): The (rows, cols) dimensions of the grid.
        points (np.ndarray): N x 2 array of points ([row, col]) that formed the hull.
        hull (scipy.spatial.ConvexHull): The calculated convex hull object.

    Returns:
        tuple: A tuple of (rows, cols) numpy arrays representing the coordinates inside the hull.
    """
    # Create a Path object from the hull vertices
    # Ensure the path is closed by repeating the first vertex at the end for contains_points
    hull_path = Path(np.vstack((points[hull.vertices], points[hull.vertices[0]])))

    # Determine bounding box based on the hull vertices for efficient checking
    min_coords = np.floor(np.min(points[hull.vertices], axis=0)).astype(int)
    max_coords = np.ceil(np.max(points[hull.vertices], axis=0)).astype(int)

    # Clamp bounding box coordinates to be within the grid dimensions
    min_r, min_c = np.maximum(0, min_coords)
    max_r, max_c = np.minimum(np.array(grid_shape) - 1, max_coords)

    # Generate a grid of points within the bounding box to test for inclusion
    rr, cc = np.meshgrid(np.arange(min_r, max_r + 1),
                         np.arange(min_c, max_c + 1),
                         indexing='ij') # 'ij' indexing aligns with numpy array (row, col)

    # Stack coordinates into a format suitable for contains_points
    test_points = np.vstack((rr.ravel(), cc.ravel())).T

    # Check which points fall inside or on the boundary of the hull path
    # A small radius helps include points exactly on the boundary
    inside_mask = hull_path.contains_points(test_points, radius=1e-9)

    # Get the coordinates of the points that tested positive
    inside_points_coords = test_points[inside_mask]

    # Combine the points found inside with the original points that define the shapes
    # This ensures all original shape pixels are included, especially for thin shapes or lines
    # not fully captured by the contains_points test on grid centers.
    all_fill_points = np.vstack((inside_points_coords, points))

    # Remove duplicates and convert to integer coordinates using rounding
    # Use a set of tuples for efficient duplicate removal
    unique_coords_set = set()
    for r, c in all_fill_points:
       rint, cint = int(round(r)), int(round(c)) # Round to nearest integer coordinates
       # Final check to ensure coordinates are within grid bounds after rounding
       if 0 <= rint < grid_shape[0] and 0 <= cint < grid_shape[1]:
           unique_coords_set.add((rint, cint))

    # If no points were identified, return empty arrays
    if not unique_coords_set:
        return (np.array([], dtype=int), np.array([], dtype=int))

    # Convert the set of unique coordinates back into separate row and column arrays
    final_rows, final_cols = zip(*unique_coords_set)
    return (np.array(final_rows), np.array(final_cols))


def transform(input_grid):
    """
    Applies the transformation rule based on the count and configuration of Blue/Green shapes.

    Args:
        input_grid (np.ndarray): The input 2D grid.

    Returns:
        np.ndarray: The transformed 2D grid.
    """
    # Define colors used in the task
    background_color = 8
    shape_colors = {1, 3}  # Blue and Green pixels define shapes
    key_color = 4          # Yellow pixel defines the key column
    output_color = 2       # Red is the output color for filled areas

    # Initialize the output grid with the same dimensions as the input, filled with background color
    output_grid = np.full_like(input_grid, background_color)

    # Identify and count distinct connected shapes made of Blue or Green pixels
    labeled_shapes, num_shapes = find_objects(input_grid, shape_colors)

    # Find the coordinates of the Yellow key pixel
    key_coords_r, key_coords_c = np.where(input_grid == key_color)

    # Check if the key pixel exists (should always be true based on examples)
    if len(key_coords_r) == 0:
        print("Warning: Key color (Yellow) not found.")
        # If key is missing, return the background grid as a safe default
        return output_grid

    # Extract the column index of the key pixel (assuming only one exists)
    key_col = key_coords_c[0]

    # --- Apply Transformation Based on Shape Count ---

    if num_shapes == 1:
        # Case 1: Exactly one shape found.
        # Fill the entire column identified by the key pixel with the output color.
        output_grid[:, key_col] = output_color

    elif num_shapes > 1:
        # Case 2: More than one shape found.
        # Fill the convex hull encompassing all shape pixels.

        # Get the coordinates of all pixels belonging to any Blue or Green shape
        shape_pixel_coords_r, shape_pixel_coords_c = np.where(np.isin(input_grid, list(shape_colors)))

        # Proceed only if there are actually shape pixels
        if len(shape_pixel_coords_r) > 0:
            # Check if there are enough points to form a convex hull polygon (at least 3)
            if len(shape_pixel_coords_r) >= 3:
                # Combine row and column coordinates into an N x 2 array of points
                points = np.vstack((shape_pixel_coords_r, shape_pixel_coords_c)).T

                try:
                    # Calculate the convex hull of the points.
                    # 'QJ' option asks Qhull to jitter points if it encounters precision issues (e.g., collinear points)
                    hull = ConvexHull(points, qhull_options='QJ')

                    # Determine all integer grid coordinates falling inside or on the boundary of this hull
                    fill_rows, fill_cols = get_pixels_inside_hull(input_grid.shape, points, hull)

                    # Color these identified pixels in the output grid with the output color
                    if len(fill_rows) > 0:
                        output_grid[fill_rows, fill_cols] = output_color

                except Exception as e:
                     # Handle cases where ConvexHull fails even with jittering (e.g., all points perfectly collinear)
                     print(f"ConvexHull calculation failed: {e}. Falling back to coloring original pixels.")
                     # As a fallback, just color the original shape pixels
                     output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color

            else: # Case 2b: Fewer than 3 shape pixels (1 or 2 points)
                 # Cannot form a hull polygon. Just color the original shape pixels.
                 output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color

    # Case 3: num_shapes == 0. No shapes found.
    # The output grid remains the initialized background color, which is correct.

    return output_grid
```
