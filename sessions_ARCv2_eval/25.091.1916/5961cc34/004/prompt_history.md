
## train_1

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
8 8 1 1 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 4 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 3 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 3 3 8 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 1 1 1 1 8 8 8 1 1 1 3 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 2 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


## train_3

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 1 1 1 1 1 1 8 8 8 8 8 8 3 1 1 1 1 1 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 1 1 1 1 8 8 8
8 8 8 8 3 3 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 3 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 2 2 2 2 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 2 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
2 2 2 2 2 2 2 2 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 2 8 8 8 8 8
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 1 1 1 1 1 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 3 1 1 1 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
8 8 8 2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
```

Okay, let's break down this task.

**Perception**

1.  **Grid Structure:** The input and output grids have the same dimensions in each example.
2.  **Background Color:** The dominant color in both input and output is Azure (8), acting as the background.
3.  **Input Elements:**
    *   There are distinct shapes composed of Blue (1) and Green (3) pixels. The Green pixels often appear at corners or edges but seem functionally part of the Blue shapes. Let's call these "Blue/Green shapes". The number of these shapes varies across examples (1, 4, 3, 2).
    *   There is always a single Yellow (4) pixel.
    *   Directly below the Yellow pixel, there is a short vertical line of Red (2) pixels. This Yellow/Red structure appears consistently in one column. Let's call this the "Key Column".
4.  **Output Elements:**
    *   The output grids consist only of the background color (Azure, 8) and Red (2) pixels.
    *   The Blue/Green shapes and the Yellow/Red key structure from the input are absent in the output.
    *   Two distinct output patterns emerge based on the input:
        *   In Example 1, where there's only *one* Blue/Green shape, the output is a solid Red vertical line filling the *entire* Key Column.
        *   In Examples 2, 3, and 4, where there are *multiple* Blue/Green shapes, the output grid replicates the exact positions of *all* the input Blue/Green shapes, but colored Red (2) instead of Blue (1) or Green (3).

**Facts**


```yaml
Task: Conditional Shape Transformation or Column Fill

Grid_Properties:
  - Background_Color: 8 (Azure)
  - Grid_Size_Preserved: True

Input_Objects:
  - Object: Key_Marker
    - Pixels:
        - Color: 4 (Yellow), Count: 1
        - Color: 2 (Red), Variable Count (>=1)
    - Properties:
        - Yellow pixel is unique.
        - Red pixels form a vertical line directly below the Yellow pixel.
    - Role: Defines the 'Key_Column'. Also involved in triggering the transformation.
  - Object: Shapes
    - Pixels:
        - Color: 1 (Blue)
        - Color: 3 (Green)
    - Properties:
        - Form connected components (objects).
        - Green pixels seem part of the Blue shapes structurally.
        - The number of distinct shapes varies (1 to many).
    - Role: These are the primary objects potentially transformed or counted.

Relationships_Actions:
  - Relationship: Key_Column_Definition
    - Element1: Key_Marker (Yellow pixel)
    - Element2: Grid Column
    - Description: The column containing the Yellow pixel (and the Red line below it) is the Key_Column.
  - Action: Count_Shapes
    - Target: Shapes (Blue/Green objects)
    - Description: Determine the number of distinct, disconnected Blue/Green shapes.
  - Action: Conditional_Transformation
    - Trigger: Count of Shapes
    - Condition_1: Count == 1
      - Result: Fill the entire Key_Column with Red (2) in the output grid. Set all other pixels to the Background_Color (8).
    - Condition_2: Count > 1
      - Result: For every pixel belonging to any Blue (1) or Green (3) shape in the input, color the corresponding pixel Red (2) in the output grid. Set all other pixels to the Background_Color (8).

Output_Objects:
  - Color: 2 (Red)
  - Represents: Either the Key_Column (if input shape count was 1) or the copied locations of input Shapes (if input shape count > 1).
  - Color: 8 (Azure)
  - Represents: Background filler.
```


**Natural Language Program**

1.  Initialize the output grid with the same dimensions as the input grid, filling it entirely with the background color (Azure, 8).
2.  Identify all distinct, connected shapes (objects) composed of Blue (1) pixels and Green (3) pixels in the input grid. Treat Blue and Green pixels equally when defining the boundaries of these shapes.
3.  Count the total number of these distinct Blue/Green shapes found.
4.  Locate the single Yellow (4) pixel in the input grid and determine its column index (the Key_Column).
5.  **Conditional Step:**
    *   **If** the count of Blue/Green shapes is exactly 1:
        *   Fill every cell in the Key_Column of the output grid with Red (2).
    *   **Else (if** the count of Blue/Green shapes is greater than 1):
        *   Iterate through all the pixel coordinates (row, column) that were part of *any* Blue/Green shape identified in step 2.
        *   For each such coordinate, set the corresponding pixel in the output grid to Red (2).
6.  Return the modified output grid.
```python
import numpy as np
from scipy.ndimage import label

"""
Transformation Rule:

1. Identify all distinct connected shapes composed of Blue (1) and Green (3) pixels in the input grid. Treat Blue and Green as equivalent for shape definition.
2. Count the total number of these distinct shapes.
3. Locate the single Yellow (4) pixel and identify its column (the "Key Column").
4. Based on the shape count:
    a. If the count is exactly 1: Create an output grid of the same dimensions filled with the background color (Azure, 8), and then set all pixels in the Key Column to Red (2).
    b. If the count is greater than 1: Create an output grid of the same dimensions filled with the background color (Azure, 8). Then, for every pixel that was part of any Blue (1) or Green (3) shape in the input, set the corresponding pixel in the output grid to Red (2).
"""

def find_objects(grid, colors):
    """
    Finds connected objects of specified colors in a grid.

    Args:
        grid (np.ndarray): The input grid.
        colors (list or set): A list or set of color values to consider as part of the objects.

    Returns:
        tuple: A tuple containing:
            - labeled_array (np.ndarray): An array where each object is marked with a unique integer label.
            - num_objects (int): The total number of distinct objects found.
    """
    mask = np.isin(grid, list(colors))
    labeled_array, num_objects = label(mask)
    return labeled_array, num_objects

def transform(input_grid):
    """
    Applies the transformation rule based on the count of Blue/Green shapes.

    Args:
        input_grid (np.ndarray): The input 2D grid.

    Returns:
        np.ndarray: The transformed 2D grid.
    """
    # Define colors
    background_color = 8
    shape_colors = {1, 3}  # Blue and Green
    key_color = 4          # Yellow
    output_color = 2       # Red

    # Initialize output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # Find and count the Blue/Green shapes
    labeled_shapes, num_shapes = find_objects(input_grid, shape_colors)

    # Find the location of the Yellow key pixel
    key_coords = np.where(input_grid == key_color)
    if len(key_coords[0]) == 0:
        # Handle case where key color is not found (optional, based on task constraints)
        # For this task, assume it's always present based on examples.
        # If it could be missing, we might return the initial background grid or raise an error.
        print("Warning: Key color (Yellow) not found.")
        return output_grid 
    
    # Assuming only one key pixel exists as per examples
    key_col = key_coords[1][0] 

    # Apply conditional transformation based on the number of shapes
    if num_shapes == 1:
        # Fill the entire Key Column with the output color
        output_grid[:, key_col] = output_color
    elif num_shapes > 1:
        # Find all coordinates belonging to the Blue/Green shapes
        shape_coords = np.where(np.isin(input_grid, list(shape_colors)))
        # Set the corresponding pixels in the output grid to the output color
        output_grid[shape_coords] = output_color
    # If num_shapes == 0, the output grid remains the background color, which seems correct.

    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label
from scipy.spatial import ConvexHull
from matplotlib.path import Path

"""
Transformation Rule:

1. Identify all distinct connected shapes composed of Blue (1) and Green (3) pixels. Treat these colors as equivalent for shape definition.
2. Count the total number of these distinct shapes.
3. Locate the single Yellow (4) pixel and identify its column index (the "Key Column").
4. Based on the shape count:
    a. If the count is exactly 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Fill the entire Key Column with Red (2).
    b. If the count is greater than 1:
        - Create an output grid filled with the background color (Azure, 8).
        - Collect all coordinates (row, col) of the Blue (1) and Green (3) pixels.
        - If 3 or more such pixels exist:
            - Calculate the convex hull of these points.
            - Determine the bounding box (min/max row/col) enclosing the hull vertices.
            - Iterate through all integer grid coordinates (pixels) within this bounding box.
            - For each coordinate, check if it lies inside or on the boundary of the convex hull polygon.
            - If it does, set the corresponding pixel in the output grid to Red (2).
        - If fewer than 3 such pixels exist (cannot form a polygon):
            - Color only the original Blue/Green pixel locations Red (2) in the output grid.
"""

def find_objects(grid, colors):
    """
    Finds connected objects of specified colors in a grid using 8-way connectivity.

    Args:
        grid (np.ndarray): The input grid.
        colors (list or set): A list or set of color values to consider as part of the objects.

    Returns:
        tuple: A tuple containing:
            - labeled_array (np.ndarray): An array where each object is marked with a unique integer label.
            - num_objects (int): The total number of distinct objects found.
    """
    mask = np.isin(grid, list(colors))
    # Define connectivity structure (8-way including diagonals)
    structure = np.array([[1,1,1],
                          [1,1,1],
                          [1,1,1]], dtype=bool)
    labeled_array, num_objects = label(mask, structure=structure)
    return labeled_array, num_objects

def points_inside_hull(points, hull):
    """
    Generates grid points inside a convex hull.

    Args:
        points (np.ndarray): N x 2 array of points defining the hull vertices.
        hull (scipy.spatial.ConvexHull): The calculated convex hull object.

    Returns:
        list: A list of [row, col] coordinates inside or on the boundary of the hull.
    """
    path = Path(points[hull.vertices])
    
    # Determine bounding box
    min_r, min_c = np.min(points[hull.vertices], axis=0).astype(int)
    max_r, max_c = np.max(points[hull.vertices], axis=0).astype(int)

    inside_points = []
    # Iterate through grid points within the bounding box
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            # Check if the center of the pixel (r, c) is inside the path
            # Use a small tolerance for points exactly on the boundary
            if path.contains_point([r, c], radius=1e-9): 
                inside_points.append([r, c])
                
    # Also explicitly add the original points that form the hull vertices
    # This ensures boundary points are definitely included, addressing potential floating point issues
    # Convert hull vertices back to original point coordinates if necessary
    for vertex_idx in hull.vertices:
        point = points[vertex_idx].astype(int) # Ensure integer coordinates
        if list(point) not in inside_points:
             inside_points.append(list(point))
             
    # Add the original shape points as well to ensure they are colored
    # This covers cases where points are inside the hull but not vertices
    # and helps with thin shapes or lines that might not be fully captured by contains_point test
    for r_orig, c_orig in zip(*np.where(np.isin(input_grid, list(shape_colors)))) :
        point = [r_orig, c_orig]
        if point not in inside_points:
            inside_points.append(point)

    return inside_points


def transform(input_grid):
    """
    Applies the transformation rule based on the count and configuration of Blue/Green shapes.

    Args:
        input_grid (np.ndarray): The input 2D grid.

    Returns:
        np.ndarray: The transformed 2D grid.
    """
    # Define colors
    global background_color, shape_colors, key_color, output_color # Make global for helper
    background_color = 8
    shape_colors = {1, 3}  # Blue and Green
    key_color = 4          # Yellow
    output_color = 2       # Red

    # Initialize output grid with the background color
    output_grid = np.full_like(input_grid, background_color)

    # Find and count the Blue/Green shapes
    labeled_shapes, num_shapes = find_objects(input_grid, shape_colors)

    # Find the location of the Yellow key pixel
    key_coords = np.where(input_grid == key_color)
    if len(key_coords[0]) == 0:
        # Should not happen based on examples, but handle defensively
        print("Warning: Key color (Yellow) not found.")
        return output_grid # Return background grid if key is missing

    key_col = key_coords[1][0] # Assume only one key pixel

    # --- Conditional Transformation ---
    if num_shapes == 1:
        # Case 1: Single shape -> Fill Key Column
        output_grid[:, key_col] = output_color
        
    elif num_shapes > 1:
        # Case 2: Multiple shapes -> Fill Convex Hull
        
        # Get coordinates of all blue/green pixels
        shape_pixel_coords_r, shape_pixel_coords_c = np.where(np.isin(input_grid, list(shape_colors)))
        
        # Check if we have enough points for a hull
        if len(shape_pixel_coords_r) >= 3:
            # Combine row and column coordinates into a list of [row, col] pairs
            points = np.vstack((shape_pixel_coords_r, shape_pixel_coords_c)).T
            
            try:
                # Calculate the convex hull
                hull = ConvexHull(points)
                
                # Find all integer grid points inside the hull
                fill_points = points_inside_hull(points, hull)
                
                # Color the identified points in the output grid
                for r, c in fill_points:
                    # Ensure coordinates are within grid bounds before coloring
                    if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:
                        output_grid[r, c] = output_color
                        
            except Exception as e:
                 # This might happen if points are collinear, ConvexHull fails
                 print(f"ConvexHull calculation failed (possibly collinear points): {e}")
                 # Fallback: Just color the original shape pixels
                 output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color

        elif len(shape_pixel_coords_r) > 0: # Handle cases with 1 or 2 points (lines)
             # Fallback for too few points: Just color the original shape pixels
             output_grid[shape_pixel_coords_r, shape_pixel_coords_c] = output_color
             
    # If num_shapes == 0, the grid remains background color, which is correct.

    return output_grid
```
