elements:
  - object: separator
    type: vertical_line
    color: red (2)
    location: variable column (consistent within an example)
    function: divides grid into left (input) and right (output) regions

  - object: input_pattern_segment
    type: horizontal_sequence
    location: rows to the left of the separator column
    properties:
      - composition: sequence of pixels in a row, potentially including white (0)
      - length: equal to the separator column index

  - object: non_white_sequence (S)
    type: derived_sequence
    source: input_pattern_segment
    properties:
      - composition: ordered sequence of non-white pixels from the input_pattern_segment
      - first_color: S[0] if S is not empty
      - last_color: S[-1] if S is not empty
      - length: len(S)
    existence: exists only if input_pattern_segment contains non-white pixels

  - object: base_pattern (P)
    type: derived_sequence
    source: non_white_sequence (S)
    properties:
      - composition: determined by rules based on S's properties (first_color, last_color, length)
      - length: variable, depends on the rule applied

  - object: output_pattern
    type: horizontal_sequence
    location: rows to the right of the separator
    properties:
      - width: determined by grid_width - separator_column - 1
      - composition: generated by tiling the base_pattern (P) to fill the output width
    existence: generated only if a corresponding non_white_sequence (S) exists for the row

actions:
  - name: identify_separator
    input: input_grid
    output: column_index (C) of red line

  - name: calculate_output_width
    input: grid_width, separator_column_index (C)
    output: width (W) = grid_width - C - 1

  - name: extract_input_segment
    input: input_grid_row, separator_column_index (C)
    output: segment = row[0:C]

  - name: derive_non_white_sequence
    input: input_segment
    output: sequence (S) of non-white pixels

  - name: determine_base_pattern
    input: first_color, last_color, length (lenS) of non_white_sequence (S)
    rules: (applied in order)
      1. if last_color == 8 (azure): P = [8]
      2. if first_color == 2 (red) and last_color == 1 (blue): P = [1, 2]
      3. if first_color == 3 (green) and last_color == 4 (yellow): P = [4, 0, 4, 3]
      4. otherwise (default):
         - if lenS == 1: P = [first_color]
         - if lenS > 1: P = [first_color] + [0] * (lenS - 1) # first color followed by lenS-1 white pixels
    output: base_pattern (P)

  - name: generate_output_pattern (Tiling)
    input: base_pattern (P), output_width (W)
    logic: Repeat P cyclically to fill width W. ( P * (W // len(P)) + P[:(W % len(P))] )
    condition: only if W > 0 and P is not empty
    output: final_output_pattern_for_row

  - name: update_output_grid
    input: output_grid, row_index (r), separator_column_index (C), final_output_pattern
    action: replace output_grid[r, C+1 : C+1+W] with final_output_pattern
    condition: only if final_output_pattern was generated

relationships:
  - type: correspondence
    entity1: input_pattern_segment (row r, left)
    entity2: output_pattern (row r, right)
    description: A non-white sequence derived from the input segment in a row determines the output pattern in the same row.

  - type: dependency
    entity1: base_pattern (P)
    entity2: non_white_sequence (S)
    description: The base pattern P is determined by the first color, last color, and length of S according to specific rules.

  - type: dependency
    entity1: output_pattern
    entity2: base_pattern (P), output_width (W)
    description: The output pattern is generated by tiling the base pattern P to fit the calculated output width W.