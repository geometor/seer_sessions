{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nfrom skimage.measure import label\n\n\"\"\"\nIdentify the background color (most frequent color).\nIdentify all contiguous objects (shapes) of non-background colors.\nDetermine the largest non-background object as the main boundary.\nIdentify all other non-background objects.\n\nCheck if the main boundary encloses any background regions by performing a flood fill from the grid edges on background pixels. Background pixels not reached are considered enclosed.\n\nIf enclosed background regions exist:\n  Determine the fill color by finding the most frequent non-background color within the original pixels of the enclosed region(s).\n  The fill target is the set of enclosed background pixels.\nElse (no enclosed regions):\n  Determine the fill color from the smallest non-background, non-boundary object (by pixel count).\n  The fill target is the set of background pixels reachable from the grid edge.\n\nCreate the output grid by copying the input grid and replacing the pixels in the fill target region with the determined fill color.\n\"\"\"\n\ndef find_objects(grid, colors_to_ignore):\n    \"\"\"\n    Finds connected components (objects) in the grid, ignoring specified colors.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (set): A set of color values to ignore (typically background).\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (list of tuples), and 'size'.\n              Returns empty list if no objects found.\n    \"\"\"\n    objects = []\n    unique_colors = np.unique(grid)\n    rows, cols = grid.shape\n\n    for color in unique_colors:\n        if color in colors_to_ignore:\n            continue\n\n        # Create a mask for the current color\n        mask = (grid == color)\n        # Label connected components for this color\n        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True) # 4-connectivity\n\n        for i in range(1, num_labels + 1):\n            coords = np.argwhere(labeled_mask == i)\n            # Convert coords to list of tuples (row, col)\n            coords_list = [tuple(coord) for coord in coords]\n            obj = {\n                'color': color,\n                'coords': coords_list,\n                'size': len(coords_list)\n            }\n            objects.append(obj)\n\n    # Sort objects primarily by size (descending), then arbitrarily if sizes are equal\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef get_background_color(grid):\n    \"\"\"Determines the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef flood_fill_from_edge(grid, background_color):\n    \"\"\"\n    Performs a flood fill starting from background pixels at the grid edges.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color of the background pixels to fill.\n\n    Returns:\n        set: A set of (row, col) tuples representing background pixels\n             connected to the edge.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    queue = deque()\n\n    # Add all edge background pixels to the queue\n    for r in range(rows):\n        if grid[r, 0] == background_color:\n            queue.append((r, 0))\n            visited.add((r, 0))\n        if grid[r, cols - 1] == background_color:\n            queue.append((r, cols - 1))\n            visited.add((r, cols - 1))\n    for c in range(cols):\n        if grid[0, c] == background_color:\n            queue.append((0, c))\n            visited.add((0, c))\n        if grid[rows - 1, c] == background_color:\n            queue.append((rows - 1, c))\n            visited.add((rows - 1, c))\n\n    # BFS\n    while queue:\n        r, c = queue.popleft()\n\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append((nr, nc))\n\n    return visited\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional region fill transformation to the input grid.\n\n    Args:\n        input_grid_list (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the output grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify background color\n    background_color = get_background_color(input_grid)\n\n    # 2. Identify all non-background objects\n    all_objects = find_objects(input_grid, {background_color})\n\n    if not all_objects: # If only background exists, return original grid\n        return input_grid_list\n\n    # 3. Determine the main boundary object (largest)\n    main_boundary_object = all_objects[0]\n    boundary_coords = set(main_boundary_object['coords'])\n\n    # 4. Identify other non-background, non-boundary objects\n    other_objects = [obj for obj in all_objects[1:]] # Exclude the largest object\n\n    # 5. Check for enclosed background regions\n    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))\n    outside_background_coords = flood_fill_from_edge(input_grid, background_color)\n    enclosed_background_coords = all_background_coords - outside_background_coords\n\n    fill_target_coords = set()\n    fill_color = -1 # Placeholder for invalid color\n\n    # 6. & 7. Determine fill type, target, and color\n    if enclosed_background_coords:\n        # Inside Fill\n        fill_target_coords = enclosed_background_coords\n\n        # Find most frequent non-background color within the original enclosed region\n        enclosed_pixels_colors = []\n        for r, c in enclosed_background_coords:\n             # Check neighbors for non-background colors IN THE ORIGINAL INPUT\n             # This interpretation seems wrong based on example 3.\n             # We need the colors of the objects *within* the enclosed area.\n             pass # Re-think this part\n\n        # Alternative interpretation for inside fill color (Example 3):\n        # Look at *all* pixels (including non-background) within the bounding box\n        # of the enclosed region, or just the original colors *at* the enclosed\n        # background coordinates? The description implies looking at the content\n        # *within* the enclosure. Let's find all objects fully contained within\n        # the bounding box defined by the enclosed area. Simpler: Find the colors\n        # of pixels *adjacent* to the enclosed background pixels, or get all pixels\n        # inside the bounding box and find the most frequent non-background color.\n        # Let's try: Get all non-background pixels from input_grid whose coordinates\n        # fall within the space notionally defined by the enclosed region.\n\n        # A simpler proxy for \"within the enclosed region\" might be pixels *adjacent*\n        # to the enclosed background pixels, or pixels whose objects are fully contained.\n        # Let's analyze Example 3 again. Enclosed area is near the green shapes.\n        # The fill color is green (3). Green objects are within/adjacent.\n\n        # Let's try finding the most frequent color of objects adjacent to the enclosed area.\n        adjacent_non_bg_colors = []\n        for r, c in enclosed_background_coords:\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1,1), (1,-1), (-1,1), (-1,-1)]: # 8-connectivity adjacency\n                 nr, nc = r + dr, c + dc\n                 if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr, nc] != background_color:\n                     # Check if this adjacent pixel belongs to the main boundary\n                     is_boundary_pixel = False\n                     for br, bc in boundary_coords:\n                         if nr == br and nc == bc:\n                            is_boundary_pixel = True\n                            break\n                     # We only consider colors of objects *other* than the main boundary, if possible\n                     # Or simply the most frequent non-bg color adjacent?\n                     # Let's just collect all adjacent non-bg colors first.\n                     adjacent_non_bg_colors.append(input_grid[nr, nc])\n\n        if adjacent_non_bg_colors:\n            color_counts = Counter(adjacent_non_bg_colors)\n            # Remove boundary color counts if we want color *from inside*\n            boundary_obj_colors = set(o['color'] for o in [main_boundary_object]) # Assuming single color boundary\n            for b_color in boundary_obj_colors:\n                if b_color in color_counts:\n                   del color_counts[b_color] # Remove boundary color influence? Maybe not needed.\n\n            # Try again: just find the most frequent non-background color in the enclosed area itself\n            original_colors_in_enclosed = []\n            # This needs a way to define the *region*, not just the background pixels within it.\n            # Let's stick to the original description: \"Examine the pixels within these enclosed\n            # regions in the original input grid. Identify the most frequent color present there,\n            # excluding the background color itself.\"\n            # How to define \"within\"? Let's use a bounding box of the enclosed coords + neighbors.\n            if enclosed_background_coords:\n                 min_r = min(r for r, c in enclosed_background_coords)\n                 max_r = max(r for r, c in enclosed_background_coords)\n                 min_c = min(c for r, c in enclosed_background_coords)\n                 max_c = max(c for r, c in enclosed_background_coords)\n\n                 # Collect non-background colors within this bounding box from the input\n                 colors_in_bbox = []\n                 for r in range(min_r, max_r + 1):\n                     for c in range(min_c, max_c + 1):\n                         pixel_color = input_grid[r, c]\n                         if pixel_color != background_color:\n                             colors_in_bbox.append(pixel_color)\n\n                 if colors_in_bbox:\n                     fill_color = Counter(colors_in_bbox).most_common(1)[0][0]\n                 else:\n                     # Fallback if no non-background colors found inside bbox (unlikely for examples)\n                     # Perhaps use the boundary color or a default? Let's assume one is found.\n                     # If still no color, maybe default to boundary color?\n                     fill_color = main_boundary_object['color'] # Guessing fallback\n\n\n            # If still no fill color identified (e.g., only background in bbox), need a fallback.\n            if fill_color == -1:\n                 # Maybe use the color of the boundary?\n                 fill_color = main_boundary_object['color'] # Fallback guess\n\n        else:\n             # Extremely unlikely case: enclosed region with no adjacent non-background pixels?\n             # Fallback to boundary color\n             fill_color = main_boundary_object['color']\n\n\n    else:\n        # Outside Fill\n        fill_target_coords = outside_background_coords\n\n        # Find the smallest object among 'other_objects'\n        if other_objects:\n            # Sort other_objects by size (ascending)\n            other_objects.sort(key=lambda o: o['size'])\n            fill_color = other_objects[0]['color']\n        else:\n             # If there are no 'other' objects, what determines the fill color?\n             # Example 1: Boundary=3, Others=9(sz 1), 5(sz 2). Smallest=9. Fills 9.\n             # Example 2: Boundary=5, Others=4(sz 1). Smallest=4. Fills 4.\n             # If other_objects is empty, it means the boundary was the *only* non-background object.\n             # This edge case isn't covered by examples. Maybe fill with boundary color? Or leave as background?\n             # Let's assume it fills with the boundary color if no other objects exist.\n             fill_color = main_boundary_object['color']\n\n\n    # 8. Apply fill\n    if fill_color != -1: # Ensure a valid fill color was determined\n        for r, c in fill_target_coords:\n            output_grid[r, c] = fill_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4902,
    "candidates_token_count": 3109,
    "total_token_count": 8011,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 44.815771,
  "retries": 1
}