{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n# Attempt to import skimage for connected components labeling\ntry:\n    from skimage.measure import label\n    SKIMAGE_AVAILABLE = True\nexcept ImportError:\n    SKIMAGE_AVAILABLE = False\n    # Define a simple placeholder or raise an error if skimage is critical\n    def label(mask, connectivity=1, background=0, return_num=False):\n        \"\"\"Placeholder for skimage.measure.label if not installed.\"\"\"\n        # This simple BFS labeler is a basic fallback.\n        # It might be less efficient than skimage's implementation.\n        rows, cols = mask.shape\n        labeled_mask = np.zeros_like(mask, dtype=int)\n        current_label = 0\n        \n        q = deque()\n        \n        # Define neighbors based on connectivity (1 -> 4-way, 2 -> 8-way)\n        if connectivity == 1:\n            neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        else: # Default to 8-way if not 1\n             neighbors = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n\n        for r in range(rows):\n            for c in range(cols):\n                # If pixel is part of the mask and not yet labeled\n                if mask[r, c] == 1 and labeled_mask[r, c] == 0:\n                    current_label += 1\n                    labeled_mask[r, c] = current_label\n                    q.append((r, c))\n                    \n                    # BFS for the current component\n                    while q:\n                        row, col = q.popleft()\n                        for dr, dc in neighbors:\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               mask[nr, nc] == 1 and labeled_mask[nr, nc] == 0:\n                                labeled_mask[nr, nc] = current_label\n                                q.append((nr, nc))\n                                \n        if return_num:\n            return labeled_mask, current_label\n        else:\n            return labeled_mask\n\n\"\"\"\nTransformation Rule: Conditional Region Fill\n\n1.  Identify the background color by finding the most frequent color in the input grid.\n2.  Identify all contiguous objects (shapes) formed by non-background colors using 4-way connectivity. Record each object's color, size (pixel count), and coordinates.\n3.  Determine the main boundary object: this is the object with the largest size. Note its color and coordinates.\n4.  Identify all remaining non-background objects as 'other objects'.\n5.  Perform a flood fill (using 4-way connectivity) starting from all background pixels located on the edges of the grid. The set of all reached background pixels constitutes the 'outside region'.\n6.  Identify the 'enclosed region' by finding all background pixels that were *not* reached by the flood fill in step 5 (i.e., the set difference between all background pixels and the 'outside region').\n7.  **If** the 'enclosed region' is non-empty:\n    a.  The target for filling is the 'enclosed region'.\n    b.  Determine the fill color: Examine all pixels adjacent (using 8-way connectivity) to any pixel in the 'enclosed region'. Collect the colors of these adjacent pixels, *excluding* the background color and any pixels belonging to the main boundary object identified in step 3. The fill color is the most frequent color among this collected set.\n    c.  *Fallback:* If no such adjacent pixels are found (e.g., the enclosed region is only adjacent to the boundary and background), use the color of the main boundary object as the fill color.\n8.  **Else (if the 'enclosed region' is empty):**\n    a.  The target for filling is the 'outside region' (identified in step 5).\n    b.  Determine the fill color: Find the object among the 'other objects' (from step 4) that has the smallest size. The fill color is the color of this smallest object.\n    c.  *Fallback:* If there are no 'other objects', use the color of the main boundary object as the fill color.\n9.  Create the output grid by copying the input grid. Then, for every coordinate in the determined fill target region (from step 7a or 8a), change the pixel color in the output grid to the determined fill color (from step 7b/c or 8b/c). Leave all other pixels unchanged.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Determines the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background for empty grid\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, colors_to_ignore):\n    \"\"\"\n    Finds connected components (objects) in the grid using 4-way connectivity,\n    ignoring specified colors.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (set): A set of color values to ignore.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (list of tuples), and 'size'.\n              Sorted by size descending. Returns empty list if no objects found.\n    \"\"\"\n    objects = []\n    unique_colors = np.unique(grid)\n    rows, cols = grid.shape\n\n    for color in unique_colors:\n        if color in colors_to_ignore:\n            continue\n\n        mask = (grid == color)\n        # Use connectivity=1 for 4-way adjacency for finding objects\n        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True)\n\n        for i in range(1, num_labels + 1):\n            coords = np.argwhere(labeled_mask == i)\n            if coords.size == 0: continue\n            coords_list = [tuple(coord) for coord in coords]\n            obj = {\n                'color': int(color), # Ensure color is standard int\n                'coords': coords_list,\n                'size': len(coords_list)\n            }\n            objects.append(obj)\n\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef flood_fill_from_edge(grid, background_color):\n    \"\"\"\n    Performs a flood fill starting from background pixels at the grid edges\n    using 4-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color of the background pixels to fill.\n\n    Returns:\n        set: A set of (row, col) tuples representing background pixels\n             connected to the edge.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    queue = deque()\n\n    # Seed the queue with all background pixels on the border\n    for r in range(rows):\n        if grid[r, 0] == background_color:\n            if (r, 0) not in visited: queue.append((r, 0)); visited.add((r, 0))\n        if cols > 1 and grid[r, cols - 1] == background_color: # Check cols > 1 for 1D cases\n             if (r, cols - 1) not in visited: queue.append((r, cols - 1)); visited.add((r, cols - 1))\n    for c in range(1, cols - 1): # Avoid double-adding corners\n        if grid[0, c] == background_color:\n             if (0, c) not in visited: queue.append((0, c)); visited.add((0, c))\n        if rows > 1 and grid[rows - 1, c] == background_color: # Check rows > 1\n             if (rows - 1, c) not in visited: queue.append((rows - 1, c)); visited.add((rows - 1, c))\n             \n    # Handle 1x1 grid case separately if necessary\n    if rows == 1 and cols == 1 and grid[0,0] == background_color:\n        if (0,0) not in visited: visited.add((0,0))\n\n\n    # Perform BFS using 4-way connectivity\n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 neighbors\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append((nr, nc))\n\n    return visited\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional region fill transformation based on whether the largest\n    non-background object encloses a background region.\n    \"\"\"\n    # Convert input to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Determine background color\n    background_color = get_background_color(input_grid)\n\n    # 2. Find all non-background objects (using 4-way connectivity)\n    all_objects = find_objects(input_grid, {background_color})\n\n    # Handle edge case: If no non-background objects, return original grid\n    if not all_objects:\n        return input_grid_list\n\n    # 3. Identify boundary object (largest) and its properties\n    boundary_object = all_objects[0]\n    boundary_coords_set = set(boundary_object['coords'])\n    # Assuming single color boundary for simplicity based on examples\n    # If boundary could be multi-colored, this needs adjustment\n    boundary_color = boundary_object['color']\n\n    # 4. Identify other objects\n    other_objects = all_objects[1:]\n\n    # 5. Find background pixels connected to the edge (outside region) using 4-way flood fill\n    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))\n    outside_background_coords = flood_fill_from_edge(input_grid, background_color)\n\n    # 6. Identify enclosed background pixels\n    enclosed_background_coords = all_background_coords - outside_background_coords\n\n    fill_target_coords = set()\n    fill_color = -1 # Initialize with invalid color\n\n    # 7. Check if an enclosed region exists and determine fill parameters\n    if enclosed_background_coords:\n        # --- Inside Fill ---\n        fill_target_coords = enclosed_background_coords\n\n        # Determine fill color based on 8-way adjacent non-background, non-boundary pixels\n        adjacent_colors = []\n        for r, c in enclosed_background_coords:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0: continue # Skip self\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        pixel_coord = (nr, nc)\n                        pixel_color = input_grid[nr, nc]\n                        # Check if pixel is NOT background AND NOT part of the boundary object\n                        if pixel_color != background_color and pixel_coord not in boundary_coords_set:\n                            adjacent_colors.append(pixel_color)\n\n        if adjacent_colors:\n            # Fill color is the most frequent among valid adjacent colors\n            color_counts = Counter(adjacent_colors)\n            fill_color = color_counts.most_common(1)[0][0]\n        else:\n            # Fallback: Use boundary color if no valid adjacent pixels found\n            fill_color = boundary_color\n\n    # 8. Else (no enclosed region), determine parameters for outside fill\n    else:\n        # --- Outside Fill ---\n        fill_target_coords = outside_background_coords\n\n        if other_objects:\n            # Fill color is from the smallest 'other object'\n            # Need to handle potential ties in size - examples don't show this, pick first one\n            smallest_other_object = min(other_objects, key=lambda o: o['size'])\n            fill_color = smallest_other_object['color']\n        else:\n            # Fallback: Use boundary color if no 'other objects' exist\n            fill_color = boundary_color\n\n    # 9. Apply the fill to the output grid\n    if fill_color != -1 and fill_target_coords: # Ensure valid color and target\n        for r, c in fill_target_coords:\n             # Check if the target coord is indeed background in the original grid\n             # Redundant check as target coords are derived from background pixels, but safe\n             if input_grid[r,c] == background_color:\n                  output_grid[r, c] = fill_color\n\n    # Convert final numpy grid back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19479,
    "candidates_token_count": 3135,
    "total_token_count": 22614,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.571858,
  "retries": 1
}