{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n# Attempt to import skimage for connected components labeling\ntry:\n    from skimage.measure import label\n    SKIMAGE_AVAILABLE = True\nexcept ImportError:\n    SKIMAGE_AVAILABLE = False\n    # Define a simple placeholder or raise an error if skimage is critical\n    def label(mask, connectivity=1, background=0, return_num=False):\n        \"\"\"Placeholder for skimage.measure.label if not installed.\"\"\"\n        print(\"Warning: skimage not found. Connected components analysis might be limited or inaccurate.\")\n        # Basic BFS/DFS based labeling could be implemented here as a fallback\n        # For now, return an empty result to indicate failure.\n        if return_num:\n            return np.zeros_like(mask, dtype=int), 0\n        else:\n            return np.zeros_like(mask, dtype=int)\n\n\"\"\"\nTransformation Rule: Conditional Region Fill\n\n1.  Identify the background color (most frequent).\n2.  Find all contiguous non-background objects (using 4-way adjacency).\n3.  Identify the largest object as the 'boundary' and others as 'other objects'.\n4.  Determine if the boundary encloses any background pixels by performing a flood fill from the grid edges on background pixels. Unreached background pixels form the 'enclosed region'.\n5.  If an enclosed region exists:\n    a. Fill the enclosed region.\n    b. The fill color is determined by the non-background, non-boundary pixels adjacent (8-way) to the enclosed region. Specifically, it's the most frequent color among these adjacent pixels. If no such pixels exist, or in case of a tie, a fallback might be needed (e.g., boundary color), though not explicitly required by examples.\n6.  If no enclosed region exists:\n    a. Fill the background pixels connected to the edge ('outside region').\n    b. The fill color is the color of the smallest 'other object' by pixel count.\n    c. If no 'other objects' exist, use the color of the boundary object as the fill color.\n7.  Apply the determined fill color to the determined fill region, leaving all other pixels unchanged.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"Determines the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background for empty grid\n    # Find the color with the maximum count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_objects(grid, colors_to_ignore):\n    \"\"\"\n    Finds connected components (objects) in the grid using 4-way connectivity,\n    ignoring specified colors. Requires skimage.measure.label or a fallback.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (set): A set of color values to ignore.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'coords' (list of tuples), and 'size'.\n              Sorted by size descending. Returns empty list if no objects found\n              or if labeling fails.\n    \"\"\"\n    objects = []\n    unique_colors = np.unique(grid)\n    rows, cols = grid.shape\n\n    for color in unique_colors:\n        if color in colors_to_ignore:\n            continue\n\n        mask = (grid == color)\n        # Use connectivity=1 for 4-way adjacency\n        labeled_mask, num_labels = label(mask, connectivity=1, background=0, return_num=True)\n\n        # Handle case where skimage might not be available or fails\n        if num_labels == 0 and np.any(mask):\n             if not SKIMAGE_AVAILABLE:\n                 print(f\"Error: Cannot label objects of color {color} without skimage.\")\n                 # Potentially implement a fallback BFS/DFS labeler here if needed\n             # else: # skimage is available but found 0 labels - should not happen if mask is not empty\n                 # print(f\"Warning: skimage.measure.label found 0 components for color {color} despite presence.\")\n\n\n        for i in range(1, num_labels + 1):\n            coords = np.argwhere(labeled_mask == i)\n            if coords.size == 0: continue # Skip if label somehow has no coords\n            coords_list = [tuple(coord) for coord in coords]\n            obj = {\n                'color': color,\n                'coords': coords_list,\n                'size': len(coords_list)\n            }\n            objects.append(obj)\n\n    # Sort objects primarily by size (descending)\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef flood_fill_from_edge(grid, background_color):\n    \"\"\"\n    Performs a flood fill starting from background pixels at the grid edges\n    using 4-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color of the background pixels to fill.\n\n    Returns:\n        set: A set of (row, col) tuples representing background pixels\n             connected to the edge.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    queue = deque()\n\n    # Seed the queue with all background pixels on the border\n    for r in range(rows):\n        if grid[r, 0] == background_color:\n            if (r,0) not in visited: queue.append((r, 0)); visited.add((r, 0))\n        if grid[r, cols - 1] == background_color:\n             if (r,cols-1) not in visited: queue.append((r, cols - 1)); visited.add((r, cols - 1))\n    for c in range(1, cols - 1): # Avoid double-adding corners\n        if grid[0, c] == background_color:\n             if (0,c) not in visited: queue.append((0, c)); visited.add((0, c))\n        if grid[rows - 1, c] == background_color:\n             if (rows-1,c) not in visited: queue.append((rows - 1, c)); visited.add((rows - 1, c))\n\n    # Perform BFS using 4-way connectivity\n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 neighbors\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append((nr, nc))\n\n    return visited\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional region fill transformation based on whether the largest\n    non-background object encloses a background region.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Determine background color\n    background_color = get_background_color(input_grid)\n\n    # 2. Find all non-background objects\n    all_objects = find_objects(input_grid, {background_color})\n\n    # If no non-background objects, return the original grid\n    if not all_objects:\n        return input_grid_list\n\n    # 3. Identify boundary object (largest) and other objects\n    boundary_object = all_objects[0]\n    boundary_coords_set = set(boundary_object['coords'])\n    boundary_color = boundary_object['color'] # Assuming single color for boundary object\n    other_objects = all_objects[1:]\n\n    # 4. Find outside and enclosed background regions\n    all_background_coords = set(tuple(coord) for coord in np.argwhere(input_grid == background_color))\n    outside_background_coords = flood_fill_from_edge(input_grid, background_color)\n    enclosed_background_coords = all_background_coords - outside_background_coords\n\n    fill_target_coords = set()\n    fill_color = -1 # Initialize with invalid color\n\n    # 5. & 6. Determine fill type, target region, and fill color\n    if enclosed_background_coords:\n        # --- Inside Fill ---\n        fill_target_coords = enclosed_background_coords\n\n        # Find colors of non-background, non-boundary pixels adjacent (8-way) to the enclosed region\n        adjacent_colors = []\n        for r, c in enclosed_background_coords:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0: continue # Skip self\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        pixel_coord = (nr, nc)\n                        pixel_color = input_grid[nr, nc]\n                        # Check if pixel is non-background and not part of the main boundary object\n                        if pixel_color != background_color and pixel_coord not in boundary_coords_set:\n                            adjacent_colors.append(pixel_color)\n\n        if adjacent_colors:\n            # Determine fill color: most frequent among adjacent non-boundary colors\n            color_counts = Counter(adjacent_colors)\n            fill_color = color_counts.most_common(1)[0][0]\n        else:\n            # Fallback: If no *other* objects are adjacent, maybe use boundary color?\n            # Or perhaps a different rule applies? Example 3 has adjacent 'other' objects.\n            # Let's default to boundary color as a plausible fallback.\n            fill_color = boundary_color\n            # print(\"Warning: Enclosed region found, but no non-boundary objects adjacent. Falling back to boundary color.\")\n\n\n    else:\n        # --- Outside Fill ---\n        fill_target_coords = outside_background_coords\n\n        if other_objects:\n            # Find smallest 'other object'\n            smallest_other_object = min(other_objects, key=lambda o: o['size'])\n            fill_color = smallest_other_object['color']\n        else:\n            # Fallback: No 'other objects', use boundary color\n            fill_color = boundary_color\n            # print(\"Warning: Outside fill required, but no 'other objects' found. Using boundary color.\")\n\n    # 7. Apply the fill\n    if fill_color != -1 and fill_target_coords: # Ensure valid color and target found\n        for r, c in fill_target_coords:\n             # Check if the target coord is indeed background in the original grid\n             # This check prevents accidentally overwriting parts of objects if logic is flawed\n             # Although fill_target_coords should only contain background pixels by definition\n             if input_grid[r,c] == background_color:\n                  output_grid[r, c] = fill_color\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18936,
    "candidates_token_count": 2606,
    "total_token_count": 21542,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.540487,
  "retries": 1
}