{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies enclosed regions of white pixels (0) within single-colored shapes in the input grid. \nDetermines a fill color for each enclosed region based on the colors of adjacent pixels from other shapes. \nIf no other shapes are adjacent to the enclosed region, it's filled with the color of the surrounding shape. \nIf other shapes are adjacent, the fill color is the most frequent adjacent color from those other shapes (ties broken by lowest color index).\nThe output grid is the input grid with these enclosed regions filled.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Yields valid orthogonal neighbor coordinates.\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            yield nr, nc\n\ndef find_enclosed_regions(grid):\n    \"\"\"\n    Finds all connected regions of white pixels (0) that are not reachable \n    from the grid boundary via other white pixels.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of regions, where each region is a list of (row, col) tuples.\n    \"\"\"\n    height, width = grid.shape\n    visited_background = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Start BFS from all boundary white pixels\n    for r in range(height):\n        if grid[r, 0] == 0 and not visited_background[r, 0]:\n            q.append((r, 0))\n            visited_background[r, 0] = True\n        if grid[r, width - 1] == 0 and not visited_background[r, width - 1]:\n            q.append((r, width - 1))\n            visited_background[r, width - 1] = True\n    for c in range(width):\n        if grid[0, c] == 0 and not visited_background[0, c]:\n            q.append((0, c))\n            visited_background[0, c] = True\n        if grid[height - 1, c] == 0 and not visited_background[height - 1, c]:\n            q.append((height - 1, c))\n            visited_background[height - 1, c] = True\n\n    while q:\n        r, c = q.popleft()\n        for nr, nc in get_neighbors(r, c, height, width):\n            if grid[nr, nc] == 0 and not visited_background[nr, nc]:\n                visited_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify enclosed white pixels (those not visited)\n    enclosed_coords = set()\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == 0 and not visited_background[r, c]:\n                enclosed_coords.add((r, c))\n\n    # Group enclosed pixels into connected regions using BFS\n    regions = []\n    processed_enclosed = set()\n\n    for r_start, c_start in enclosed_coords:\n        if (r_start, c_start) in processed_enclosed:\n            continue\n\n        current_region = []\n        region_q = deque([(r_start, c_start)])\n        processed_enclosed.add((r_start, c_start))\n        \n        while region_q:\n            r, c = region_q.popleft()\n            current_region.append((r, c))\n\n            for nr, nc in get_neighbors(r, c, height, width):\n                coord = (nr, nc)\n                # Check if the neighbor is an enclosed white pixel AND not yet processed for this region\n                if coord in enclosed_coords and coord not in processed_enclosed:\n                    processed_enclosed.add(coord)\n                    region_q.append(coord)\n        \n        if current_region:\n            regions.append(current_region)\n            \n    return regions\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling enclosed white regions within \n    single-colored shapes based on adjacent colors.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Find all enclosed white regions\n    enclosed_regions = find_enclosed_regions(grid)\n\n    # Process each enclosed region\n    for region_coords in enclosed_regions:\n        if not region_coords:\n            continue\n\n        primary_colors = set()\n        foreign_colors = []\n        \n        # Determine the primary surrounding color and collect foreign adjacent colors\n        for r, c in region_coords:\n            for nr, nc in get_neighbors(r, c, height, width):\n                neighbor_color = grid[nr, nc]\n                if neighbor_color != 0: # If neighbor is not white\n                    # If neighbor is not part of the current region (should always be true for non-white neighbors)\n                    if (nr, nc) not in region_coords: \n                        primary_colors.add(neighbor_color)\n        \n        # If the region is bordered by more than one color, it doesn't fit the pattern\n        # (Based on examples, enclosed regions are surrounded by a single color)\n        # If primary_colors is empty, something is wrong (a white hole with no colored neighbors?)\n        if len(primary_colors) != 1:\n            # print(f\"Warning: Region at {region_coords[0]} has {len(primary_colors)} primary colors: {primary_colors}. Skipping.\")\n            continue # Skip this region if it's not enclosed by a single color\n            \n        c_primary = list(primary_colors)[0]\n\n        # Now collect foreign colors adjacent to the region\n        for r, c in region_coords:\n             for nr, nc in get_neighbors(r, c, height, width):\n                 neighbor_color = grid[nr, nc]\n                 if neighbor_color != 0 and neighbor_color != c_primary:\n                     foreign_colors.append(neighbor_color)\n\n        # Determine the fill color\n        fill_color = c_primary # Default to primary color\n        if foreign_colors:\n            color_counts = Counter(foreign_colors)\n            max_freq = 0\n            # Find the maximum frequency\n            for color in color_counts:\n                 if color_counts[color] > max_freq:\n                     max_freq = color_counts[color]\n            \n            # Find all colors with the maximum frequency\n            most_frequent_colors = []\n            for color in color_counts:\n                if color_counts[color] == max_freq:\n                    most_frequent_colors.append(color)\n            \n            # Choose the one with the lowest index (value)\n            fill_color = min(most_frequent_colors)\n\n        # Fill the region in the output grid\n        for r, c in region_coords:\n            output_grid[r, c] = fill_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3879,
    "candidates_token_count": 1750,
    "total_token_count": 5629,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.415883,
  "retries": 1
}