{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms an input grid by performing a flood fill operation on a specific subgrid.\n\n1.  Extracts a subgrid (canvas) from the input grid, specifically rows 6 onwards \n    and columns 1 onwards. This canvas corresponds to the output grid dimensions.\n2.  Identifies the 'background color' within this canvas, defined as the most \n    frequent color excluding Azure (8).\n3.  Locates all initial 'seed' pixels within the canvas, which are pixels with \n    the Azure color (8).\n4.  Performs a 4-directional flood fill (Breadth-First Search) starting from the \n    seed pixels.\n5.  The fill operation changes pixels matching the identified background color to \n    Azure (8).\n6.  The fill stops at the canvas boundaries or when encountering pixels that do \n    not match the background color (acting as barriers).\n7.  If no background color is found (e.g., the canvas only contains Azure pixels),\n    the canvas is returned unmodified.\n8.  The final state of the canvas after the flood fill is the output.\n\"\"\"\n\ndef _find_most_frequent_excluding(grid, exclude_value):\n    \"\"\"\n    Finds the most frequent value in a grid, excluding a specific value.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        exclude_value (int): The value to exclude from frequency counting.\n\n    Returns:\n        int or None: The most frequent value, or None if no other value exists \n                     or the grid is effectively empty after exclusion.\n    \"\"\"\n    # Flatten the grid to easily count pixel values\n    flat_grid = grid.flatten()\n    \n    # Filter out the value to exclude\n    filtered_values = flat_grid[flat_grid != exclude_value]\n    \n    # If no values remain after filtering, return None\n    if filtered_values.size == 0:\n        return None\n\n    # Count occurrences of each remaining value\n    counts = Counter(filtered_values)\n    \n    # Find the value with the highest count\n    # counts.most_common(1) returns a list like [ (value, count) ]\n    most_common_value = counts.most_common(1)[0][0] \n    return most_common_value\n\ndef _find_pixels_with_color(grid, color):\n    \"\"\"\n    Finds the coordinates of all pixels with a specific color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color value to search for.\n\n    Returns:\n        np.ndarray: An array of coordinates [(r1, c1), (r2, c2), ...].\n    \"\"\"\n    return np.argwhere(grid == color)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the flood fill transformation to the relevant subgrid of the input.\n\n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid.\n    \"\"\"\n    \n    # 1. Extract Canvas: Create the output_grid by taking a slice of the \n    # input_grid (rows 6+, columns 1+). Use copy() to ensure modifications \n    # don't affect the original input slice.\n    output_grid = input_grid[6:, 1:].copy()\n    \n    # Get dimensions for boundary checks\n    rows, cols = output_grid.shape\n\n    # 2. Determine Background Color: Find the most frequent color excluding Azure (8).\n    background_color = _find_most_frequent_excluding(output_grid, 8) \n\n    # If no background color is found, return the extracted grid as is.\n    if background_color is None:\n        return output_grid\n\n    # 3. Locate Seeds: Find coordinates of all Azure (8) pixels.\n    seed_pixels_coords = _find_pixels_with_color(output_grid, 8)\n\n    # If there are no seed pixels, no fill can occur, return grid as is.\n    if seed_pixels_coords.size == 0:\n        return output_grid\n\n    # 4. Initialize Fill: Set up the queue and visited tracker.\n    queue = deque(seed_pixels_coords.tolist()) # Use deque for efficient popleft\n    visited = np.zeros_like(output_grid, dtype=bool)\n    \n    # Mark initial seeds as visited\n    for r, c in seed_pixels_coords:\n        # Ensure seeds are within bounds before marking (should always be true\n        # if found by argwhere, but good practice)\n        if 0 <= r < rows and 0 <= c < cols:\n            visited[r, c] = True\n\n    # 5. Execute Flood Fill (BFS)\n    while queue:\n        r, c = queue.popleft()\n\n        # Define the four cardinal neighbors\n        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]\n\n        for nr, nc in neighbors:\n            # Check 1: Is the neighbor within the grid boundaries?\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check 2: Does the neighbor have the background color?\n                # Check 3: Has the neighbor NOT been visited yet?\n                if output_grid[nr, nc] == background_color and not visited[nr, nc]:\n                    # All checks pass:\n                    # - Change the neighbor's color to Azure (8)\n                    output_grid[nr, nc] = 8\n                    # - Mark as visited\n                    visited[nr, nc] = True\n                    # - Add the neighbor to the queue for further expansion\n                    queue.append((nr, nc))\n\n    # 6. Return Result: The modified grid is the output.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12936,
    "candidates_token_count": 1362,
    "total_token_count": 14298,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.073306,
  "retries": 1
}