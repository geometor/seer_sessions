
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 1 0 0 0 5 5 6 0 0 0 5 5 4 0 0 0 5 5 2 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
3 3 3 3 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 3 3 3 3 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 3 3 3 3 8 8 3 3 3 3 3 3 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 4 4 4 4 3 3
1 1 1 1 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 3 3 8 8 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 0 0 0 2 5 5 4 0 0 0 5 5 0 0 0 6 5 5 3 0 0 0 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 6 6 6 6 6 1 1 1 1 1 1
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 8 8 8 8 8 8 8 8
1 1 1 1 8 8 1 1 8 8 1 1 1 1 8 8 1 1 1 1 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 1 1 8 8 1 1 1 1 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 3 3 3 3 1 1 1 1
2 2 2 2 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 0 0 0 4 5 5 6 0 0 0 5 5 3 0 0 0 5 5 0 0 0 2 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 3 3 3 3 3 3 3 3 3 3 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```


**output:**
```
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 7 7 7 7
7 7 7 8 8 7 7 7 3 3 3 3 3 3 3 3 3 3 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
8 8 8 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 8 8 6 6 6 6
7 7 7 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 6 6 6 6
2 2 2 8 8 7 7 7 7 7 7 7 8 8 7 7 7 7 7 7 6 6 6 6
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 8 8 8 8 8 8 8 8 8 8 8 7 7 7 7 7 7 7 7 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
2 2 2 7 7 7 7 7 4 4 4 4 4 4 4 4 4 4 4 4 4 4 7 7
```

Okay, let's break down the task based on the provided examples.

**Perception of Task Elements:**

1.  **Input Structure:** The input grids consistently have a distinct structure:
    *   A top section (first 6 rows) acting as a header or palette. This section is bordered by gray (5) pixels and contains smaller squares, each with a gray border, a unique color sample (like blue, magenta, yellow, red), and a white interior. This section seems informational and not part of the direct transformation canvas.
    *   A bottom section (rows 6 onwards) acting as the main canvas or drawing area. This area has a dominant background color and contains various shapes or objects made of different colors, including small squares of azure (8).
2.  **Output Structure:** The output grids are smaller than the input grids (19x24 vs 25x25). They correspond dimensionally to the bottom section of the input grid, excluding the first column (input rows 6-24, columns 1-24). The top header/palette section of the input is completely absent in the output.
3.  **Transformation:** The core transformation occurs within the bottom section (drawing area) of the input grid.
    *   The azure (8) pixels present in the initial drawing area act as starting points or "seeds".
    *   A specific color within the drawing area acts as the "background" that gets painted over. This background color varies between examples (green in train_1, blue in train_2, orange in train_3). It appears to be the most prevalent color in the drawing area, excluding the initial azure pixels.
    *   The azure color (8) "expands" or "fills" outwards from the initial seed pixels in the four cardinal directions (up, down, left, right).
    *   This expansion only affects pixels matching the identified background color.
    *   The expansion stops when it hits the grid boundaries or any pixel whose color is *not* the background color. Other colored shapes within the drawing area act as barriers to the azure expansion.
4.  **Color Roles:**
    *   Gray (5): Used as a border/separator in the input's header section. Does not appear in the transformation logic itself.
    *   White (0): Used as filler within the palette squares in the input's header.
    *   Azure (8): The "paint" color and the initial "seed" color for the transformation.
    *   Other colors (Blue, Red, Green, Yellow, Magenta, Orange, etc.): Can form shapes/objects within the drawing area that act as barriers to the azure expansion, or can be the background color itself.

**Facts (YAML):**


```yaml
task_context:
  grid_dimensionality: 2D
  grid_size_input: 25x25 (consistent across examples)
  grid_size_output: 19x24 (consistent across examples)
  input_structure:
    - header_section:
        location: Rows 0-5
        content: Gray borders, contains color samples (palette)
        role: Informational, discarded in output
    - canvas_section:
        location: Rows 6-24
        content: Main drawing area with background color, objects, and azure seed pixels
        role: Area undergoing transformation
  output_derivation: Derived from a subgrid of the input's canvas_section
  subgrid_definition: Input rows 6-24, Input columns 1-24

objects:
  - type: seed_pixels
    color: Azure (8)
    location: Within the canvas_section of the input
    role: Starting points for expansion
  - type: background_pixels
    color: Varies (most frequent color in the initial drawing subgrid, excluding azure)
    location: Within the canvas_section of the input
    role: Pixels eligible to be changed to azure
  - type: barrier_pixels
    color: Any color except the identified background color and azure (within the drawing subgrid)
    location: Within the canvas_section of the input
    role: Pixels that block the expansion of azure

actions:
  - action: identify_subgrid
    input: Input grid
    output: Drawing grid (input[6:25, 1:25])
  - action: identify_background_color
    input: Drawing grid
    criteria: Most frequent color excluding azure (8)
    output: Background color value
  - action: identify_seed_pixels
    input: Drawing grid
    criteria: Pixels with azure color (8)
    output: List of seed pixel coordinates
  - action: expand_color
    source_pixels: Seed pixels
    target_color: Azure (8)
    affected_pixels: Background pixels
    mechanism: Flood fill or BFS outwards in 4 cardinal directions
    stopping_conditions: Grid boundaries, non-background pixels
    output: Modified drawing grid

relationships:
  - The output grid dimensions (19x24) match the dimensions of the input grid's subgrid defined by rows 6-24 and columns 1-24.
  - The initial azure pixels in the subgrid determine where the expansion starts.
  - The expansion process transforms background pixels into azure pixels.
  - Non-background pixels (barriers) and grid boundaries limit the extent of the azure expansion.

```


**Natural Language Program:**

1.  **Isolate the Drawing Grid:** Extract the subgrid from the input grid starting from row index 6 down to the last row, and from column index 1 across to the last column. Let this be the `working_grid`. The dimensions of `working_grid` will be 19x24.
2.  **Identify Background Color:** Analyze the `working_grid` to find the most frequent pixel color, ignoring any azure (8) pixels. This identified color is the `background_color`.
3.  **Identify Seed Pixels:** Locate all pixels within the `working_grid` that initially have the azure color (8). Collect their row and column coordinates into a list of `seed_pixels`.
4.  **Initialize Expansion:** Create a copy of the `working_grid` which will become the `output_grid`. Create a queue for the expansion process and add all coordinates from `seed_pixels` to it. Also, create a set or boolean grid called `visited` (same dimensions as `working_grid`) to keep track of pixels that have been processed or are seeds; initialize it by marking all `seed_pixels` locations as visited.
5.  **Perform Expansion (Flood Fill):**
    *   While the queue is not empty:
        *   Remove a coordinate `(r, c)` from the front of the queue.
        *   Examine its four cardinal neighbors (up, down, left, right): `(nr, nc)`.
        *   For each neighbor `(nr, nc)`:
            *   Check if `(nr, nc)` is within the boundaries of the `output_grid`.
            *   Check if the pixel at `output_grid[nr, nc]` currently has the `background_color`.
            *   Check if `(nr, nc)` has *not* been marked as visited.
            *   If all three conditions are true:
                *   Change the color of the pixel at `output_grid[nr, nc]` to azure (8).
                *   Mark `(nr, nc)` as visited.
                *   Add `(nr, nc)` to the queue.
6.  **Final Output:** Once the queue is empty, the expansion is complete. The final state of the `output_grid` is the result of the transformation.
```python
import numpy as np
from collections import deque, Counter

def find_most_frequent_excluding(grid, exclude_value):
    """Finds the most frequent value in a grid, excluding a specific value."""
    # Flatten the grid to easily count pixel values
    flat_grid = grid.flatten()
    
    # Filter out the value to exclude
    filtered_values = flat_grid[flat_grid != exclude_value]
    
    # If no values remain after filtering, return None or a default
    if filtered_values.size == 0:
        # Check if the grid only contained the excluded value
        if np.all(flat_grid == exclude_value):
             # Or maybe the original grid was empty? Although ARC constraints likely prevent this.
             # If only excluded value was present, there's no background to fill.
             # Let's return None to signify this. The caller should handle it.
             # Or, perhaps return the exclude_value itself if that makes sense in context?
             # Let's stick with None for now.
             return None
        else: # Grid was empty or had other values but none meeting criteria
             return None # Or maybe default to 0 (white)? Let's stick with None.


    # Count occurrences of each remaining value
    counts = Counter(filtered_values)
    
    # Find the value with the highest count
    if not counts: # handles case where filtered_values was empty
        return None
        
    most_common_value = counts.most_common(1)[0][0]
    return most_common_value

def solve(input_grid):
    """
    Transforms the input grid based on the following rules:
    1. Isolate the Drawing Grid: Extract the subgrid from the input grid starting from row index 6 and column index 1.
    2. Identify Background Color: Find the most frequent pixel color in the drawing grid, excluding azure (8).
    3. Identify Seed Pixels: Locate all initial azure (8) pixels in the drawing grid.
    4. Perform Expansion (Flood Fill): Starting from the seed pixels, expand the azure color outwards (up, down, left, right) onto adjacent pixels that match the background color. Expansion stops at grid boundaries or pixels that are not the background color.
    5. Return the modified drawing grid.
    """
    # 1. Isolate the Drawing Grid
    # Extracts rows 6 onwards and columns 1 onwards
    working_grid = input_grid[6:, 1:].copy() # Use copy to avoid modifying slice of input
    output_grid = working_grid # Start output as a copy of the working area

    # Get dimensions for boundary checks
    rows, cols = output_grid.shape

    # 2. Identify Background Color
    background_color = find_most_frequent_excluding(working_grid, 8) # 8 is azure

    # Handle case where no background color is found (e.g., grid only contains azure)
    if background_color is None:
        # If there's no background color to fill, the grid likely remains unchanged
        # or maybe it should all become azure? The examples suggest barriers stop fill,
        # so if only azure exists, nothing happens.
        # Let's assume returning the initial state is correct.
        return output_grid

    # 3. Identify Seed Pixels
    seed_pixels_coords = np.argwhere(working_grid == 8)

    # 4. Initialize Expansion structures
    queue = deque(seed_pixels_coords.tolist()) # Use deque for efficient popleft
    visited = np.zeros_like(working_grid, dtype=bool)
    
    # Mark initial seeds as visited
    for r, c in seed_pixels_coords:
        visited[r, c] = True

    # 5. Perform Expansion (Flood Fill / BFS)
    while queue:
        r, c = queue.popleft()

        # Define the four cardinal neighbors
        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

        for nr, nc in neighbors:
            # Check if the neighbor is within the grid boundaries
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is the background color AND hasn't been visited
                if output_grid[nr, nc] == background_color and not visited[nr, nc]:
                    # Change the neighbor's color to azure
                    output_grid[nr, nc] = 8
                    # Mark as visited
                    visited[nr, nc] = True
                    # Add the neighbor to the queue for further expansion
                    queue.append((nr, nc))

    # 6. Final Output
    return output_grid

```
```python
import numpy as np
from collections import deque, Counter

"""
Transforms an input grid by performing a flood fill operation on a specific subgrid.

1.  Extracts a subgrid (canvas) from the input grid, specifically rows 6 onwards 
    and columns 1 onwards. This canvas corresponds to the output grid dimensions.
2.  Identifies the 'background color' within this canvas, defined as the most 
    frequent color excluding Azure (8).
3.  Locates all initial 'seed' pixels within the canvas, which are pixels with 
    the Azure color (8).
4.  Performs a 4-directional flood fill (Breadth-First Search) starting from the 
    seed pixels.
5.  The fill operation changes pixels matching the identified background color to 
    Azure (8).
6.  The fill stops at the canvas boundaries or when encountering pixels that do 
    not match the background color (acting as barriers).
7.  If no background color is found (e.g., the canvas only contains Azure pixels),
    the canvas is returned unmodified.
8.  The final state of the canvas after the flood fill is the output.
"""

def _find_most_frequent_excluding(grid, exclude_value):
    """
    Finds the most frequent value in a grid, excluding a specific value.

    Args:
        grid (np.ndarray): The input grid.
        exclude_value (int): The value to exclude from frequency counting.

    Returns:
        int or None: The most frequent value, or None if no other value exists 
                     or the grid is effectively empty after exclusion.
    """
    # Flatten the grid to easily count pixel values
    flat_grid = grid.flatten()
    
    # Filter out the value to exclude
    filtered_values = flat_grid[flat_grid != exclude_value]
    
    # If no values remain after filtering, return None
    if filtered_values.size == 0:
        return None

    # Count occurrences of each remaining value
    counts = Counter(filtered_values)
    
    # Find the value with the highest count
    # counts.most_common(1) returns a list like [ (value, count) ]
    most_common_value = counts.most_common(1)[0][0] 
    return most_common_value

def _find_pixels_with_color(grid, color):
    """
    Finds the coordinates of all pixels with a specific color.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color value to search for.

    Returns:
        np.ndarray: An array of coordinates [(r1, c1), (r2, c2), ...].
    """
    return np.argwhere(grid == color)


def transform(input_grid):
    """
    Applies the flood fill transformation to the relevant subgrid of the input.

    Args:
        input_grid (np.ndarray): The 2D input grid.

    Returns:
        np.ndarray: The transformed 2D output grid.
    """
    
    # 1. Extract Canvas: Create the output_grid by taking a slice of the 
    # input_grid (rows 6+, columns 1+). Use copy() to ensure modifications 
    # don't affect the original input slice.
    output_grid = input_grid[6:, 1:].copy()
    
    # Get dimensions for boundary checks
    rows, cols = output_grid.shape

    # 2. Determine Background Color: Find the most frequent color excluding Azure (8).
    background_color = _find_most_frequent_excluding(output_grid, 8) 

    # If no background color is found, return the extracted grid as is.
    if background_color is None:
        return output_grid

    # 3. Locate Seeds: Find coordinates of all Azure (8) pixels.
    seed_pixels_coords = _find_pixels_with_color(output_grid, 8)

    # If there are no seed pixels, no fill can occur, return grid as is.
    if seed_pixels_coords.size == 0:
        return output_grid

    # 4. Initialize Fill: Set up the queue and visited tracker.
    queue = deque(seed_pixels_coords.tolist()) # Use deque for efficient popleft
    visited = np.zeros_like(output_grid, dtype=bool)
    
    # Mark initial seeds as visited
    for r, c in seed_pixels_coords:
        # Ensure seeds are within bounds before marking (should always be true
        # if found by argwhere, but good practice)
        if 0 <= r < rows and 0 <= c < cols:
            visited[r, c] = True

    # 5. Execute Flood Fill (BFS)
    while queue:
        r, c = queue.popleft()

        # Define the four cardinal neighbors
        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

        for nr, nc in neighbors:
            # Check 1: Is the neighbor within the grid boundaries?
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check 2: Does the neighbor have the background color?
                # Check 3: Has the neighbor NOT been visited yet?
                if output_grid[nr, nc] == background_color and not visited[nr, nc]:
                    # All checks pass:
                    # - Change the neighbor's color to Azure (8)
                    output_grid[nr, nc] = 8
                    # - Mark as visited
                    visited[nr, nc] = True
                    # - Add the neighbor to the queue for further expansion
                    queue.append((nr, nc))

    # 6. Return Result: The modified grid is the output.
    return output_grid
```
```python
import numpy as np
from collections import deque, Counter

"""
Transforms an input grid by performing a flood fill operation on a specific subgrid.

1.  Extracts a subgrid (canvas) from the input grid, specifically rows 6 onwards 
    and columns 1 onwards. This canvas corresponds to the output grid dimensions.
2.  Identifies the 'background color' within this canvas, defined as the most 
    frequent color excluding Azure (8).
3.  Locates all initial 'seed' pixels within the canvas, which are pixels with 
    the Azure color (8).
4.  Performs a 4-directional flood fill (Breadth-First Search) starting from the 
    seed pixels.
5.  The fill operation changes pixels matching the identified background color to 
    Azure (8).
6.  The fill stops at the canvas boundaries or when encountering pixels that do 
    not match the background color (acting as barriers).
7.  If no background color is found (e.g., the canvas only contains Azure pixels 
    or is empty after exclusion) or if there are no seed pixels, the canvas is 
    returned unmodified.
8.  The final state of the canvas after the flood fill is the output.
"""

# === Helper Functions ===

def _get_subgrid(grid, start_row, start_col):
    """
    Extracts a subgrid from the specified starting row/col to the end.

    Args:
        grid (np.ndarray): The input grid.
        start_row (int): The starting row index (inclusive).
        start_col (int): The starting column index (inclusive).

    Returns:
        np.ndarray: A copy of the extracted subgrid.
    """
    # Ensure indices are within bounds, though slicing handles this gracefully
    rows, cols = grid.shape
    if start_row >= rows or start_col >= cols:
        # Return an empty array of appropriate type if start is out of bounds
        return np.array([[]], dtype=grid.dtype) 
    return grid[start_row:, start_col:].copy()

def _find_most_frequent_excluding(grid, exclude_value):
    """
    Finds the most frequent value in a grid, excluding a specific value.

    Args:
        grid (np.ndarray): The input grid.
        exclude_value (int): The value to exclude from frequency counting.

    Returns:
        int or None: The most frequent value, or None if no other value exists 
                     or the grid is effectively empty after exclusion.
    """
    # Check for empty grid case
    if grid.size == 0:
        return None
        
    flat_grid = grid.flatten()
    filtered_values = flat_grid[flat_grid != exclude_value]
    
    # If no values remain after filtering, return None
    if filtered_values.size == 0:
        return None

    # Count occurrences of each remaining value
    counts = Counter(filtered_values)
    
    # Check if the Counter is empty (shouldn't happen if filtered_values.size > 0)
    if not counts: 
        return None
        
    # Find the value with the highest count
    # counts.most_common(1) returns a list like [ (value, count) ]
    most_common_value = counts.most_common(1)[0][0] 
    return most_common_value

def _find_pixels_with_color(grid, color):
    """
    Finds the coordinates of all pixels with a specific color.

    Args:
        grid (np.ndarray): The input grid.
        color (int): The color value to search for.

    Returns:
        np.ndarray: An array of coordinates [(r1, c1), (r2, c2), ...]. 
                    Returns an empty array if no pixels match.
    """
    # Check for empty grid case
    if grid.size == 0:
        return np.array([], dtype=int).reshape(0, 2) # Return empty 2D array
    return np.argwhere(grid == color)

def _flood_fill_4_direction(grid, seeds, fill_color, target_color):
    """
    Performs a 4-directional flood fill in-place on the grid.

    Args:
        grid (np.ndarray): The grid to modify.
        seeds (np.ndarray): Array of seed coordinates [(r1, c1), ...].
        fill_color (int): The color to fill with.
        target_color (int or None): The color of pixels to be filled. If None,
                                    no filling occurs.

    Returns:
        np.ndarray: The modified grid (note: the input grid is modified in-place).
    """
    # Check for conditions where no fill should occur
    if target_color is None or seeds.size == 0 or grid.size == 0:
        return grid 
        
    rows, cols = grid.shape
    queue = deque(seeds.tolist())
    # Visited array is crucial to prevent infinite loops and re-processing
    visited = np.zeros_like(grid, dtype=bool)

    # Mark initial seeds as visited *only if they are within bounds*
    # The seeds are found within the grid, so they should be in bounds,
    # but this adds robustness.
    initial_queue = deque()
    for r, c in seeds:
        if 0 <= r < rows and 0 <= c < cols:
           # Only mark/add seeds that haven't somehow already been visited
           # (shouldn't happen with a fresh visited array, but safe)
           if not visited[r, c]:
               visited[r, c] = True
               initial_queue.append((r, c))
               # We assume seeds already have the fill_color and don't need changing.
    
    queue = initial_queue # Use the validated initial queue

    # Perform Breadth-First Search (BFS)
    while queue:
        r, c = queue.popleft()

        # Define the four cardinal neighbors
        neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

        for nr, nc in neighbors:
            # Check 1: Is the neighbor within the grid boundaries?
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check 2: Does the neighbor have the target color?
                # Check 3: Has the neighbor NOT been visited yet?
                if grid[nr, nc] == target_color and not visited[nr, nc]:
                    # All checks pass:
                    # - Change the neighbor's color to the fill color
                    grid[nr, nc] = fill_color
                    # - Mark as visited
                    visited[nr, nc] = True
                    # - Add the neighbor to the queue for further expansion
                    queue.append((nr, nc))
                    
    return grid

# === Main Transformation Function ===

def transform(input_grid):
    """
    Applies the flood fill transformation based on the described rules:
    Extracts a subgrid, finds the most frequent non-azure color as background,
    locates azure seeds, and flood-fills the background from the seeds.
    
    Args:
        input_grid (np.ndarray): The 2D input grid.

    Returns:
        np.ndarray: The transformed 2D output grid (the modified subgrid).
    """
    # Define constants based on problem description/observation
    HEADER_ROWS = 6 # Number of rows to skip at the top
    START_COL = 1   # Starting column index for the subgrid (0-based)
    SEED_COLOR = 8  # Azure - the color that initiates the fill
    FILL_COLOR = 8  # Azure - the color used to fill

    # 1. Extract the canvas (working area) from the input
    #    Handles potential empty input grid via helper function.
    canvas = _get_subgrid(input_grid, HEADER_ROWS, START_COL)

    # If the extracted canvas is empty, return it immediately
    if canvas.size == 0:
        return canvas

    # 2. Identify the background color to be filled (target color)
    #    Exclude the seed color itself from being the background.
    background_color = _find_most_frequent_excluding(canvas, SEED_COLOR)

    # 3. Find initial seed pixels (pixels that already have the fill color)
    #    These are the starting points for the flood fill.
    seed_coords = _find_pixels_with_color(canvas, SEED_COLOR)

    # 4. Perform flood fill
    #    - The function modifies 'canvas' in-place.
    #    - It fills pixels matching 'background_color' starting from 'seed_coords'.
    #    - Handles cases where background_color is None or no seeds are found.
    output_grid = _flood_fill_4_direction(canvas, seed_coords, FILL_COLOR, background_color)

    # 5. Return the modified canvas as the final output grid
    return output_grid
```
