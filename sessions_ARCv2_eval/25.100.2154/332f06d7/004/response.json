{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\ndef find_largest_msb(grid: list[list[int]], digit: int) -> tuple[tuple[int, int] | None, int]:\n    \"\"\"\n    Finds the largest monochromatic square block (MSB) of a given digit.\n\n    Args:\n        grid: The input grid (list of lists of integers).\n        digit: The digit to search for (0, 1, or 2).\n\n    Returns:\n        A tuple containing:\n        - The top-left coordinate (row, col) of the first largest MSB found\n          (in reading order), or None if no MSB of size >= 2x2 exists.\n        - The size (side length N) of the largest MSB found, or 0 if none exists.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    max_size = 0\n    best_coord = None\n\n    # Iterate possible sizes from largest possible down to 2\n    for size in range(min(rows, cols), 1, -1):\n        found_at_this_size = False\n        # Iterate through possible top-left corners\n        for r in range(rows - size + 1):\n            for c in range(cols - size + 1):\n                is_msb = True\n                # Check if the square block is monochromatic\n                for i in range(r, r + size):\n                    for j in range(c, c + size):\n                        if grid[i][j] != digit:\n                            is_msb = False\n                            break\n                    if not is_msb:\n                        break\n                \n                if is_msb:\n                    # Found an MSB of the current size\n                    if size > max_size:\n                        # This is the largest size found so far\n                        max_size = size\n                        best_coord = (r, c)\n                        found_at_this_size = True\n                    elif size == max_size and best_coord is None:\n                        # This is the first block of the current max size found\n                         best_coord = (r,c)\n                         found_at_this_size = True\n                    # Only need the first one for a given size if it's the max size found so far\n                    # For subsequent blocks of the *same* max size, we keep the first coordinate found\n        # If we found the largest possible size, no need to check smaller sizes\n        if found_at_this_size and size == max_size:\n             break # optimization: we found the largest size\n\n    return best_coord, max_size\n\n\ndef find_first_msb_of_size(grid: list[list[int]], digit: int, size: int) -> tuple[int, int] | None:\n    \"\"\"\n    Finds the first monochromatic square block (MSB) of a given digit and exact size.\n\n    Args:\n        grid: The input grid.\n        digit: The digit to search for.\n        size: The exact side length N of the square block to find.\n\n    Returns:\n        The top-left coordinate (row, col) of the first MSB found\n        (in reading order), or None if no such block exists.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n\n    if size < 2 or size > min(rows, cols):\n        return None\n\n    # Iterate through possible top-left corners in reading order\n    for r in range(rows - size + 1):\n        for c in range(cols - size + 1):\n            is_msb = True\n            # Check if the square block is monochromatic and of the target size\n            for i in range(r, r + size):\n                for j in range(c, c + size):\n                    if grid[i][j] != digit:\n                        is_msb = False\n                        break\n                if not is_msb:\n                    break\n            \n            if is_msb:\n                # Found the first MSB of the required size\n                return (r, c)\n                \n    return None # No MSB of the specified size found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the following rules:\n\n    Default Rule:\n    - Change all '0's to '1's.\n    - Change all '2's to '0's.\n    - '1's and '3's remain unchanged.\n\n    Exception Condition:\n    - If the largest monochromatic square block (MSB) of '0's (size N0 >= 2)\n      and the largest MSB of '2's (size N2 >= 2) both exist AND have the\n      exact same size (N0 = N2 = N), then the following overrides apply:\n        1. The '0's within the N x N 0-MSB change to '1's (as per default).\n        2. The '2's within the N x N 2-MSB remain '2's (overriding default).\n        3. The first N x N MSB of '1's found (in reading order) changes\n           to a block of '0's (overriding default).\n        4. All other digits outside these specific blocks follow the default rule.\n    \"\"\"\n    \n    # Find the largest MSBs for 0 and 2\n    coord0, N0 = find_largest_msb(input_grid, 0)\n    coord2, N2 = find_largest_msb(input_grid, 2)\n\n    # Initialize output grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(output_grid)\n    cols = len(output_grid[0]) if rows > 0 else 0\n\n    # Check if the exception condition is met\n    exception_applies = (N0 >= 2 and N2 >= 2 and N0 == N2)\n    \n    if exception_applies:\n        N = N0 # The common size\n        # Find the first MSB of '1's with size N\n        coord1_special = find_first_msb_of_size(input_grid, 1, N)\n\n        # Apply transformations considering the exception\n        for r in range(rows):\n            for c in range(cols):\n                # Check if cell is within the 2-MSB\n                is_in_L2_MSB = (coord2 is not None and \n                                r >= coord2[0] and r < coord2[0] + N and \n                                c >= coord2[1] and c < coord2[1] + N)\n                \n                # Check if cell is within the special 1-MSB\n                is_in_L1_special = (coord1_special is not None and \n                                      r >= coord1_special[0] and r < coord1_special[0] + N and \n                                      c >= coord1_special[1] and c < coord1_special[1] + N)\n\n                if is_in_L2_MSB:\n                    # Rule 2: 2s in the 2-MSB remain 2\n                    output_grid[r][c] = 2 \n                elif is_in_L1_special:\n                     # Rule 3: 1s in the special 1-MSB become 0\n                    output_grid[r][c] = 0\n                else:\n                    # Apply default rules for cells outside the exception blocks\n                    if input_grid[r][c] == 0:\n                        output_grid[r][c] = 1\n                    elif input_grid[r][c] == 2:\n                        output_grid[r][c] = 0\n                    # else: 1s and 3s remain as copied initially\n                        \n    else:\n        # Apply default transformations globally\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == 0:\n                    output_grid[r][c] = 1\n                elif input_grid[r][c] == 2:\n                    output_grid[r][c] = 0\n                # else: 1s and 3s remain as copied initially\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9443,
    "candidates_token_count": 2948,
    "total_token_count": 12391,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.227355,
  "retries": 1
}