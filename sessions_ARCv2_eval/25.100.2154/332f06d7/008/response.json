{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransforms an input grid based on monochromatic square blocks (MSBs).\n\nDefault Rule:\n- Change all '0's to '1's.\n- Change all '2's to '0's.\n- '1's and '3's (typically borders) remain unchanged.\n\nException Condition:\n- This rule applies ONLY if the largest valid MSB of '0's (size N0 >= 2)\n  and the largest valid MSB of '2's (size N2 >= 2) both exist AND have the\n  exact same size (N0 = N2 = N). A 'valid' MSB is one that is >= 2x2\n  and contains no cells with the value '3'.\n\nException Actions:\n- If the exception condition is met:\n    1. Find all valid N x N MSBs of '1's.\n    2. Select the target 1s block (L1_target) from these candidates based\n       on the minimum Euclidean distance between its center and the grid's\n       geometric center (tie-breaking by reading order).\n    3. Apply rules cell by cell:\n        a. If cell is in the largest valid 2-MSB (L2_MSB): output = 2.\n        b. Else if cell is in the target 1-MSB (L1_target): output = 0.\n        c. Else (covers largest valid 0-MSB and all others): Apply the\n           Default Rule mapping to the input cell value (0->1, 2->0, 1->1, 3->3).\n\nIf the exception condition is NOT met, the Default Rule applies globally.\n\"\"\"\n\ndef _is_valid_msb(grid: list[list[int]], r: int, c: int, size: int, digit: int) -> bool:\n    \"\"\"Checks if an NxN block starting at (r, c) is a valid MSB of 'digit'.\n       Valid means all cells == digit and no cell == 3.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    # Check bounds first\n    if r + size > rows or c + size > cols:\n        return False\n    # Check cells\n    for i in range(r, r + size):\n        for j in range(c, c + size):\n            # Check for incorrect digit or presence of border value '3'\n            if grid[i][j] != digit or grid[i][j] == 3:\n                return False\n    return True\n\ndef find_largest_valid_msb(grid: list[list[int]], digit: int) -> tuple[tuple[int, int] | None, int]:\n    \"\"\"\n    Finds the largest valid MSB (size>=2, no 3s) of a given digit.\n    Returns the top-left coord and size (N). Prioritizes largest N,\n    then first in reading order for ties. Returns (None, 0) if none found.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    max_size = 0\n    best_coord = None\n\n    # Iterate possible sizes from largest possible down to 2\n    for size in range(min(rows, cols), 1, -1):\n        found_at_this_size = False\n        # Iterate through possible top-left corners in reading order\n        for r in range(rows - size + 1):\n            for c in range(cols - size + 1):\n                if _is_valid_msb(grid, r, c, size, digit):\n                    # Found a valid MSB of the current size\n                    if size > max_size:\n                        max_size = size\n                        best_coord = (r, c)\n                        found_at_this_size = True\n                        # Optimization: Since we search largest size first,\n                        # the first one we find *is* the largest. We only need\n                        # to complete the loops for (r,c) at this size to respect\n                        # reading-order tie-breaking if needed later, but can\n                        # break the outer size loop once this size is processed.\n                        # Correction: We need the FIRST one found at the MAX size.\n                        # So once we find one, we record it and continue checking\n                        # this size row by row, col by col, but DON'T update if\n                        # another of the same max size is found.\n                        # Simpler: break inner loops and outer loop immediately\n                        # once the first block of the current 'size' is found,\n                        # because we iterate 'size' downwards.\n                        break # Found first block at this size\n            if found_at_this_size:\n                 break # Found first block for the largest possible size\n        if found_at_this_size:\n             break # Break size loop if found\n\n    # If we found a best_coord, ensure max_size > 0\n    if best_coord is not None:\n        max_size = max(2, max_size) # Ensure size is at least 2 if coord found\n    else:\n        max_size = 0 # Ensure size is 0 if no coord found\n\n    return best_coord, max_size\n\n\ndef find_all_valid_msb_of_size(grid: list[list[int]], digit: int, size: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all valid MSBs (size>=2, no 3s) of a given digit and exact size.\n    Returns a list of top-left coordinates in reading order.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    found_coords = []\n\n    if size < 2 or size > min(rows, cols):\n        return []\n\n    # Iterate through possible top-left corners in reading order\n    for r in range(rows - size + 1):\n        for c in range(cols - size + 1):\n            if _is_valid_msb(grid, r, c, size, digit):\n                found_coords.append((r, c))\n    return found_coords\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n    if rows == 0 or cols == 0:\n        return [] # Handle empty grid case\n\n    # --- Check for Exception Condition ---\n    # Find the largest valid MSBs for 0 and 2\n    coord0, N0 = find_largest_valid_msb(input_grid, 0)\n    coord2, N2 = find_largest_valid_msb(input_grid, 2)\n\n    # Determine if the exception applies\n    exception_applies = (N0 >= 2 and N2 >= 2 and N0 == N2)\n\n    # --- Apply Transformations ---\n    if exception_applies:\n        N = N0 # The common size\n\n        # Find the target 1s block\n        coord1_target = None\n        l1_candidates_coords = find_all_valid_msb_of_size(input_grid, 1, N)\n\n        if l1_candidates_coords:\n            # Calculate grid center\n            grid_center_r = (rows - 1) / 2.0\n            grid_center_c = (cols - 1) / 2.0\n            min_dist_sq = float('inf')\n            best_candidate_coord = None\n\n            # Find the candidate closest to the grid center\n            for r1, c1 in l1_candidates_coords:\n                # Calculate block center\n                block_center_r = r1 + N / 2.0 - 0.5\n                block_center_c = c1 + N / 2.0 - 0.5\n                # Calculate squared distance\n                dist_sq = (block_center_r - grid_center_r)**2 + (block_center_c - grid_center_c)**2\n\n                # Update if closer distance found\n                if dist_sq < min_dist_sq:\n                    min_dist_sq = dist_sq\n                    best_candidate_coord = (r1, c1)\n                # Tie-breaking is implicit: first one encountered with min_dist_sq is kept\n\n            coord1_target = best_candidate_coord\n\n        # Apply transformations cell by cell for the exception case\n        for r in range(rows):\n            for c in range(cols):\n                # Check if cell is within the L2_MSB (coord2 is guaranteed not None here)\n                is_in_L2_MSB = (r >= coord2[0] and r < coord2[0] + N and\n                                c >= coord2[1] and c < coord2[1] + N)\n\n                # Check if cell is within the L1_target\n                is_in_L1_target = (coord1_target is not None and\n                                   r >= coord1_target[0] and r < coord1_target[0] + N and\n                                   c >= coord1_target[1] and c < coord1_target[1] + N)\n\n                if is_in_L2_MSB:\n                    # Exception rule: 2s in L2_MSB remain 2\n                    output_grid[r][c] = 2\n                elif is_in_L1_target:\n                    # Exception rule: 1s in L1_target become 0\n                    output_grid[r][c] = 0\n                else:\n                    # Apply default rules for all other cells (including L0_MSB)\n                    if input_grid[r][c] == 0:\n                        output_grid[r][c] = 1\n                    elif input_grid[r][c] == 2:\n                        output_grid[r][c] = 0\n                    # else: 1s and 3s remain as copied initially\n\n    else:\n        # Apply default transformations globally if exception doesn't apply\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == 0:\n                    output_grid[r][c] = 1\n                elif input_grid[r][c] == 2:\n                    output_grid[r][c] = 0\n                # else: 1s and 3s remain as copied initially\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32219,
    "candidates_token_count": 3296,
    "total_token_count": 35515,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.23559,
  "retries": 1
}