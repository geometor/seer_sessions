{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransforms an input grid based on monochromatic square blocks (MSBs).\n\nDefault Rule:\n- Change all '0's to '1's.\n- Change all '2's to '0's.\n- '1's and '3's (typically borders) remain unchanged.\n\nException Condition:\n- This rule applies ONLY if the largest MSB of '0's (size N0 >= 2)\n  and the largest MSB of '2's (size N2 >= 2), both located strictly\n  within the non-border area (i.e., not containing any '3's),\n  exist AND have the exact same size (N0 = N2 = N).\n\nException Actions:\n- If the exception condition is met:\n    1. The '0's within the N x N 0-MSB change to '1's.\n    2. The '2's within the N x N 2-MSB remain '2's (overriding default).\n    3. Find all N x N MSBs of '1's within the non-border area. Select the\n       one whose geometric center is closest to the grid's geometric center.\n       The '1's in this target 1-MSB change to '0's (overriding default).\n       (Tie-breaking: choose the first one found in reading order).\n    4. All other digits *outside* these three specific MSBs follow the\n       default rule (0->1, 2->0, 1->1, 3->3).\n\nIf the exception condition is NOT met, the Default Rule applies globally.\n\"\"\"\n\ndef _is_valid_msb(grid: list[list[int]], r: int, c: int, size: int, digit: int) -> bool:\n    \"\"\"Checks if an NxN block starting at (r, c) is a valid MSB of 'digit' (contains no 3s).\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    if r + size > rows or c + size > cols:\n        return False # Out of bounds\n    for i in range(r, r + size):\n        for j in range(c, c + size):\n            if grid[i][j] != digit or grid[i][j] == 3: # Check digit and ensure no border value 3\n                return False\n    return True\n\ndef find_largest_msb(grid: list[list[int]], digit: int) -> tuple[tuple[int, int] | None, int]:\n    \"\"\"\n    Finds the largest valid MSB (size>=2, no 3s) of a given digit.\n    Returns the top-left coord and size (N). Prioritizes largest N,\n    then first in reading order for ties. Returns (None, 0) if none found.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    max_size = 0\n    best_coord = None\n\n    # Iterate possible sizes from largest possible down to 2\n    for size in range(min(rows, cols), 1, -1):\n        found_at_this_size = False\n        # Iterate through possible top-left corners\n        for r in range(rows - size + 1):\n            for c in range(cols - size + 1):\n                if _is_valid_msb(grid, r, c, size, digit):\n                    # Found a valid MSB of the current size\n                    if size > max_size:\n                        max_size = size\n                        best_coord = (r, c)\n                        found_at_this_size = True\n                        # Optimization: Since we go largest to smallest,\n                        # the first one we find of this size IS the largest.\n                        # For tie-breaking, we stop searching smaller sizes\n                        # and ensure we keep the first coord found at this max size.\n                        break # Found the largest size for this digit\n                    # If size == max_size, we keep the first coord found (implicit)\n            if found_at_this_size and size == max_size:\n                 break # Break outer loop if we found the first largest\n        if found_at_this_size and size == max_size:\n             break # Break size loop as well\n\n    return best_coord, max_size\n\n\ndef find_all_msb_of_size(grid: list[list[int]], digit: int, size: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all valid MSBs (size>=2, no 3s) of a given digit and exact size.\n    Returns a list of top-left coordinates in reading order.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    found_coords = []\n\n    if size < 2:\n        return []\n\n    for r in range(rows - size + 1):\n        for c in range(cols - size + 1):\n            if _is_valid_msb(grid, r, c, size, digit):\n                found_coords.append((r, c))\n    return found_coords\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Get grid dimensions\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n    if rows == 0 or cols == 0:\n        return []\n\n    # Find the largest MSBs for 0 and 2\n    coord0, N0 = find_largest_msb(input_grid, 0)\n    coord2, N2 = find_largest_msb(input_grid, 2)\n\n    # Initialize output grid\n    output_grid = copy.deepcopy(input_grid)\n\n    # Check if the exception condition is met\n    exception_applies = (N0 >= 2 and N2 >= 2 and N0 == N2)\n\n    if exception_applies:\n        N = N0 # The common size\n        # Find all candidate 1s-MSBs of size N\n        l1_candidates_coords = find_all_msb_of_size(input_grid, 1, N)\n        coord1_target = None\n\n        if l1_candidates_coords:\n            # Calculate grid center\n            grid_center_r = (rows - 1) / 2.0\n            grid_center_c = (cols - 1) / 2.0\n            min_dist_sq = float('inf')\n\n            # Find the candidate closest to the grid center\n            for r1, c1 in l1_candidates_coords:\n                block_center_r = r1 + N / 2.0 - 0.5\n                block_center_c = c1 + N / 2.0 - 0.5\n                dist_sq = (block_center_r - grid_center_r)**2 + (block_center_c - grid_center_c)**2\n                \n                if dist_sq < min_dist_sq:\n                    min_dist_sq = dist_sq\n                    coord1_target = (r1, c1)\n            # Tie-breaking is implicit: the first one checked with min_dist_sq is kept.\n\n        # Apply transformations for the exception case\n        for r in range(rows):\n            for c in range(cols):\n                # Check if cell is within the 2-MSB (coord2 is guaranteed not None here)\n                is_in_L2_MSB = (r >= coord2[0] and r < coord2[0] + N and\n                                c >= coord2[1] and c < coord2[1] + N)\n\n                # Check if cell is within the target 1-MSB\n                is_in_L1_target = (coord1_target is not None and\n                                   r >= coord1_target[0] and r < coord1_target[0] + N and\n                                   c >= coord1_target[1] and c < coord1_target[1] + N)\n\n                if is_in_L2_MSB:\n                    # Rule 2: 2s in the 2-MSB remain 2\n                    output_grid[r][c] = 2\n                elif is_in_L1_target:\n                    # Rule 3: 1s in the target 1-MSB become 0\n                    output_grid[r][c] = 0\n                else:\n                    # Apply default rules for all other cells\n                    if input_grid[r][c] == 0:\n                        output_grid[r][c] = 1\n                    elif input_grid[r][c] == 2:\n                        output_grid[r][c] = 0\n                    # else: 1s and 3s remain as copied initially\n\n    else:\n        # Apply default transformations globally if exception doesn't apply\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == 0:\n                    output_grid[r][c] = 1\n                elif input_grid[r][c] == 2:\n                    output_grid[r][c] = 0\n                # else: 1s and 3s remain as copied initially\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20637,
    "candidates_token_count": 2909,
    "total_token_count": 23546,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.113666,
  "retries": 1
}