{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport math\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\nDefault Rule:\n- Change all '0's to '1's.\n- Change all '2's to '0's.\n- '1's and '3's remain unchanged.\n\nException Condition:\n- Find the largest \"valid\" Monochromatic Square Block (MSB) for digit '0' (size N0).\n- Find the largest \"valid\" MSB for digit '2' (size N2).\n- A \"valid\" MSB must have size N >= 2 and be fully contained within the\n  non-border area (i.e., all its cells (r, c) must satisfy 0 < r < rows-1\n  and 0 < c < cols-1).\n- The exception applies ONLY if N0 >= 2 AND N2 >= 2 AND N0 == N2.\n\nException Actions:\n- If the exception condition is met (let N = N0 = N2):\n    1. Find all valid N x N MSBs of '1's.\n    2. Select the target 1s block (L1_target) from these candidates based\n       on the minimum Euclidean distance between its geometric center and the\n       grid's geometric center. Ties are broken by choosing the block whose\n       top-left corner appears first in reading order.\n    3. Apply transformations cell by cell:\n        a. If cell is in the largest valid 2-MSB (L2_MSB): output = 2.\n        b. Else if cell is in the target 1-MSB (L1_target): output = 0.\n        c. Else (covers largest valid 0-MSB and all others): Apply the\n           Default Rule mapping to the input cell value (0->1, 2->0, 1->1, 3->3).\n\nIf the exception condition is NOT met, the Default Rule applies globally to all cells.\n\"\"\"\n\ndef _is_within_border(r, c, rows, cols):\n    \"\"\"Checks if a coordinate is strictly within the border.\"\"\"\n    return r > 0 and r < rows - 1 and c > 0 and c < cols - 1\n\ndef _is_valid_msb(grid: list[list[int]], r: int, c: int, size: int, digit: int) -> bool:\n    \"\"\"\n    Checks if an NxN block starting at (r, c) is a valid MSB of 'digit'.\n    Valid means:\n    1. All cells == digit.\n    2. All cells are strictly within the non-border area (not row 0/max, col 0/max).\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    # Check bounds first\n    if r + size > rows or c + size > cols:\n        return False\n\n    # Check cells for correct digit and position\n    for i in range(r, r + size):\n        for j in range(c, c + size):\n            # Check if cell is strictly within border and has the correct digit\n            if not _is_within_border(i, j, rows, cols) or grid[i][j] != digit:\n                return False\n    return True\n\ndef find_largest_valid_msb(grid: list[list[int]], digit: int) -> tuple[tuple[int, int] | None, int]:\n    \"\"\"\n    Finds the largest valid MSB (size>=2, strictly within border) of a given digit.\n    Returns the top-left coord and size (N). Prioritizes largest N,\n    then first in reading order for ties. Returns (None, 0) if none found.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    max_size = 0\n    best_coord = None\n\n    # Iterate possible sizes from largest possible down to 2\n    # Max possible size must fit within the inner grid dimensions\n    max_possible_size = min(rows - 2, cols - 2) if rows > 2 and cols > 2 else 0\n    for size in range(max_possible_size, 1, -1):\n        found_at_this_size = False\n        # Iterate through possible top-left corners (must start within inner grid)\n        # Top-left corner must be at least (1,1) and allow the block to end before the border\n        for r in range(1, rows - size):\n            for c in range(1, cols - size):\n                # We only need to check _is_valid_msb if the top-left is valid\n                # But _is_valid_msb already checks full containment\n                if _is_valid_msb(grid, r, c, size, digit):\n                    # Found a valid MSB of the current size\n                    if size > max_size:\n                        max_size = size\n                        best_coord = (r, c)\n                        found_at_this_size = True\n                        # Since we iterate size downwards, the first size we find\n                        # a block for is the max size. We just need the first coord.\n                        break # Found first block at this size\n            if found_at_this_size:\n                 break # Found first block for this size (which is max size found so far)\n        if found_at_this_size:\n             break # Break size loop if found max size\n\n    # Ensure consistency: size is 0 if no block found\n    if best_coord is None:\n        max_size = 0\n\n    return best_coord, max_size\n\n\ndef find_all_valid_msb_of_size(grid: list[list[int]], digit: int, size: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all valid MSBs (size>=2, strictly within border) of a given digit and exact size.\n    Returns a list of top-left coordinates in reading order.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    found_coords = []\n\n    if size < 2 or size > min(rows - 2, cols - 2): # Check if size can fit inside border\n        return []\n\n    # Iterate through possible top-left corners (must start within inner grid)\n    for r in range(1, rows - size):\n        for c in range(1, cols - size):\n            if _is_valid_msb(grid, r, c, size, digit):\n                found_coords.append((r, c))\n    return found_coords\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    cols = len(input_grid[0]) if rows > 0 else 0\n    if rows == 0 or cols == 0:\n        return [] # Handle empty grid case\n\n    # --- Check for Exception Condition ---\n    # Find the largest valid MSBs for 0 and 2\n    coord0, N0 = find_largest_valid_msb(input_grid, 0)\n    coord2, N2 = find_largest_valid_msb(input_grid, 2)\n\n    # Determine if the exception applies\n    exception_applies = (N0 >= 2 and N2 >= 2 and N0 == N2)\n\n    # --- Apply Transformations ---\n    if exception_applies:\n        N = N0 # The common size\n\n        # Find the target 1s block (L1_target)\n        coord1_target = None\n        l1_candidates_coords = find_all_valid_msb_of_size(input_grid, 1, N)\n\n        if l1_candidates_coords:\n            # Calculate grid center\n            grid_center_r = (rows - 1) / 2.0\n            grid_center_c = (cols - 1) / 2.0\n            min_dist_sq = float('inf')\n            best_candidate_coord = None\n\n            # Find the candidate closest to the grid center\n            for r1, c1 in l1_candidates_coords:\n                # Calculate block center\n                block_center_r = r1 + N / 2.0 - 0.5\n                block_center_c = c1 + N / 2.0 - 0.5\n                # Calculate squared distance\n                dist_sq = (block_center_r - grid_center_r)**2 + (block_center_c - grid_center_c)**2\n\n                # Update if strictly closer distance found\n                # Tie-breaking (first in reading order) handled implicitly\n                if dist_sq < min_dist_sq:\n                    min_dist_sq = dist_sq\n                    best_candidate_coord = (r1, c1)\n\n            coord1_target = best_candidate_coord\n\n        # Apply transformations cell by cell for the exception case\n        for r in range(rows):\n            for c in range(cols):\n                # Check if cell is within the L2_MSB (coord2 is guaranteed not None here)\n                is_in_L2_MSB = (r >= coord2[0] and r < coord2[0] + N and\n                                c >= coord2[1] and c < coord2[1] + N)\n\n                # Check if cell is within the L1_target\n                is_in_L1_target = (coord1_target is not None and\n                                   r >= coord1_target[0] and r < coord1_target[0] + N and\n                                   c >= coord1_target[1] and c < coord1_target[1] + N)\n\n                if is_in_L2_MSB:\n                    # Exception rule: 2s in L2_MSB remain 2\n                    output_grid[r][c] = 2\n                elif is_in_L1_target:\n                    # Exception rule: 1s in L1_target become 0\n                    output_grid[r][c] = 0\n                else:\n                    # Apply default rules for all other cells (including L0_MSB)\n                    if input_grid[r][c] == 0:\n                        output_grid[r][c] = 1\n                    elif input_grid[r][c] == 2:\n                        output_grid[r][c] = 0\n                    # else: 1s and 3s remain as copied initially from input_grid\n\n    else:\n        # --- Apply Default Transformations Globally ---\n        # Apply default transformations globally if exception doesn't apply\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == 0:\n                    output_grid[r][c] = 1\n                elif input_grid[r][c] == 2:\n                    output_grid[r][c] = 0\n                # else: 1s and 3s remain as copied initially from input_grid\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 44639,
    "candidates_token_count": 3022,
    "total_token_count": 47661,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.502353,
  "retries": 1
}