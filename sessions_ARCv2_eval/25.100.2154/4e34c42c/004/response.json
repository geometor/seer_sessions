{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nDetermines the background digit (most frequent). Identifies connected objects \nof non-background digits. Finds a pair of objects (A, B) sharing a unique \nheight (H_pair), identifying Left (A) and Right (B) based on column index. \nFinds the widest object (C) among the remaining (ignored) objects. \nIf no ignored object C exists, or if C's width (W_C) is not greater than B's \nwidth (W_B), applies the Simple Rule: horizontally concatenates B's content \nand A's content (excluding A's first column). \nIf W_C > W_B, applies the Complex Rule: creates a Padding grid by vertically \ncentering the first W_C-2 columns of C's content to height H_pair; creates \nan Assembly grid by horizontally concatenating A's content (excluding A's \nfirst two columns) and B's content; finally, concatenates the Padding and \nAssembly grids horizontally. Returns the resulting grid.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\nimport collections\n\ndef find_background(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent element in the grid, assumed to be the background.\"\"\"\n    if grid.size == 0:\n        # Default background or raise error for empty grid? Let's default to 0\n        return 0\n    counts = Counter(grid.flatten())\n    background_digit = counts.most_common(1)[0][0]\n    return background_digit\n\ndef find_connected_objects(grid: np.ndarray, background_digit: int) -> list[dict]:\n    \"\"\"Finds connected components of non-background digits and returns their properties.\"\"\"\n    mask = grid != background_digit\n    labeled_array, num_features = label(mask)\n    \n    objects = []\n    slices = find_objects(labeled_array)\n    \n    if not slices: # Handle cases with no foreground objects\n        return []\n\n    for i, slc in enumerate(slices):\n        if slc is None: \n             continue\n        obj_id = i + 1 # Labels start from 1\n        \n        # Use bounding box dimensions directly from find_objects slice\n        obj_content_full = grid[slc] \n        height = slc[0].stop - slc[0].start\n        width = slc[1].stop - slc[1].start\n        min_row = slc[0].start\n        min_col = slc[1].start\n\n        # Filter out objects that might be detected but contain only background\n        # (e.g., if find_objects returns slices slightly larger than the actual component)\n        # This check seems redundant if label() worked correctly on the mask.\n        # component_mask = labeled_array[slc] == obj_id\n        # if not np.any(grid[slc][component_mask] != background_digit):\n        #     continue\n        \n        # Check if the object is empty after slicing (shouldn't happen with valid slices)\n        if height <= 0 or width <= 0:\n            continue\n\n        objects.append({\n            'id': obj_id,\n            'slice': slc,\n            'content': obj_content_full,\n            'height': height,\n            'width': width,\n            'min_row': min_row,\n            'min_col': min_col\n        })\n        \n    return objects\n\ndef vertically_center(content: np.ndarray, target_height: int, pad_value: int) -> np.ndarray:\n    \"\"\"Centers 'content' vertically within a grid of 'target_height', padding with 'pad_value'.\"\"\"\n    current_height, current_width = content.shape\n    \n    # Handle empty content case\n    if current_height == 0 or current_width == 0:\n        return np.full((target_height, current_width), pad_value, dtype=content.dtype)\n\n    if current_height >= target_height:\n        # If content is taller or equal, take the central part\n        start_row = (current_height - target_height) // 2\n        return content[start_row:start_row + target_height, :]\n\n    # Calculate padding needed above and below\n    pad_total = target_height - current_height\n    pad_top = pad_total // 2\n    pad_bottom = pad_total - pad_top\n\n    # Create padding arrays\n    top_padding = np.full((pad_top, current_width), pad_value, dtype=content.dtype)\n    bottom_padding = np.full((pad_bottom, current_width), pad_value, dtype=content.dtype)\n\n    # Stack them vertically\n    centered_content = np.vstack((top_padding, content, bottom_padding))\n    return centered_content\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Convert input to numpy array\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return [] # Handle empty input grid\n\n    # 1. Determine background digit\n    background_digit = find_background(grid)\n    \n    # 2. Identify all distinct connected objects\n    all_objects = find_connected_objects(grid, background_digit)\n    if not all_objects:\n        # No foreground objects found, return empty grid? Or original? Let's return empty.\n        return [] \n\n    # 3. Group objects by height and find the pair height\n    height_groups = collections.defaultdict(list)\n    for obj in all_objects:\n        height_groups[obj['height']].append(obj)\n        \n    selected_pair = []\n    H_pair = -1\n    for height, objs in height_groups.items():\n        if len(objs) == 2:\n            selected_pair = objs\n            H_pair = height\n            break # Assume only one such height exists per problem constraints\n            \n    if not selected_pair:\n        # Error case: No pair with unique matching height found.\n        # The problem description implies this case won't happen in valid inputs.\n        # Returning empty list for now.\n        print(\"Error: No pair of objects with the same unique height found.\")\n        return []\n\n    # 4. Identify Left (A) and Right (B) objects in the selected pair\n    obj1, obj2 = selected_pair\n    if obj1['min_col'] < obj2['min_col']:\n        object_A = obj1 # Left\n        object_B = obj2 # Right\n    else:\n        object_A = obj2 # Left\n        object_B = obj1 # Right\n        \n    content_A = object_A['content']\n    content_B = object_B['content']\n    W_A = object_A['width']\n    W_B = object_B['width']\n\n    # 5. Identify the ignored set\n    ignored_set = [obj for obj in all_objects if obj['id'] != object_A['id'] and obj['id'] != object_B['id']]\n\n    # 6. Find the widest ignored object C\n    widest_ignored_object_C = None\n    W_C_maxW = 0\n    if ignored_set:\n        # Sort by width (desc) and then potentially by row/col if widths are equal (doesn't matter which one we pick if tied)\n        ignored_set.sort(key=lambda x: x['width'], reverse=True)\n        widest_ignored_object_C = ignored_set[0]\n        W_C_maxW = widest_ignored_object_C['width']\n\n    # 7. Apply conditional transformation rule\n    if widest_ignored_object_C is None or W_C_maxW <= W_B:\n        # Apply the Simple Rule\n        \n        # Slice A: remove first column\n        if W_A <= 1:\n             sliced_content_A = np.empty((H_pair, 0), dtype=content_A.dtype) # Empty slice if A is too narrow\n        else:\n             sliced_content_A = content_A[:, 1:]\n             \n        # Concatenate B and Sliced A\n        output_grid_np = np.hstack((content_B, sliced_content_A))\n\n    else:\n        # Apply the Complex Rule (W_C_maxW > W_B)\n        content_C = widest_ignored_object_C['content']\n        \n        # Calculate padding dimensions and content\n        pad_W = W_C_maxW - 2\n        if pad_W <= 0:\n             # If C is too narrow (width 1 or 2), padding base is empty\n             padding_base = np.empty((content_C.shape[0], 0), dtype=content_C.dtype) \n        else:\n             padding_base = content_C[:, :pad_W]\n\n        # Create the vertically centered padding grid\n        padding_grid = vertically_center(padding_base, H_pair, background_digit)\n        \n        # Create Assembly part\n        # Slice A: remove first two columns\n        if W_A <= 2:\n            assembly_slice_A = np.empty((H_pair, 0), dtype=content_A.dtype) # Empty slice if A is too narrow\n        else:\n            assembly_slice_A = content_A[:, 2:]\n            \n        # Slice B: use full content B\n        assembly_slice_B = content_B\n        \n        # Concatenate Assembly parts\n        assembly_grid = np.hstack((assembly_slice_A, assembly_slice_B))\n\n        # Concatenate final output: Padding + Assembly\n        output_grid_np = np.hstack((padding_grid, assembly_grid))\n\n    # Convert final numpy array back to list of lists\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13423,
    "candidates_token_count": 2856,
    "total_token_count": 16279,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.779438,
  "retries": 1
}