{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\nimport collections\n\n\"\"\"\nDetermines the background digit (most frequent). Identifies connected objects \nof non-background digits. Finds a pair of objects (A=Left, B=Right) sharing a unique \nheight (H_pair). Finds the widest object (C) among the remaining (ignored) objects. \nIf no ignored object C exists, or if C's width (W_C) is not greater than B's \nwidth (W_B), applies the Simple Rule: horizontally concatenates B's content \nand A's content (excluding A's first column). \nIf W_C > W_B, applies the Complex Rule: \n1. Creates a Padding grid by vertically centering the first W_C-2 columns of C's \n   content to height H_pair.\n2. Creates an Assembly grid by horizontally concatenating A's content (excluding \n   A's first two columns) and B's content (excluding B's last two columns).\n3. Finally, concatenates the Padding and Assembly grids horizontally. \nReturns the resulting grid.\n\"\"\"\n\ndef find_background(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent element in the grid, assumed to be the background.\"\"\"\n    if grid.size == 0:\n        return 0 # Default for empty grid\n    counts = Counter(grid.flatten())\n    # If multiple elements have the same highest frequency, pick one (e.g., the lowest value)\n    # This shouldn't matter for ARC tasks typically.\n    background_digit = counts.most_common(1)[0][0]\n    return background_digit\n\ndef find_connected_objects(grid: np.ndarray, background_digit: int) -> list[dict]:\n    \"\"\"Finds connected components of non-background digits and returns their properties.\"\"\"\n    mask = grid != background_digit\n    # Use 8-connectivity (default for label)\n    labeled_array, num_features = label(mask) \n    \n    objects = []\n    slices = find_objects(labeled_array)\n    \n    if not slices: \n        return []\n\n    for i, slc in enumerate(slices):\n        if slc is None: \n             continue\n        obj_id = i + 1 # Labels start from 1\n        \n        # Extract content and properties from the bounding box slice\n        obj_content_full = grid[slc] \n        height = slc[0].stop - slc[0].start\n        width = slc[1].stop - slc[1].start\n        min_row = slc[0].start\n        min_col = slc[1].start\n        \n        # Ensure the extracted object is not empty\n        if height <= 0 or width <= 0:\n            continue\n\n        objects.append({\n            'id': obj_id,\n            'slice': slc,\n            'content': obj_content_full,\n            'height': height,\n            'width': width,\n            'min_row': min_row,\n            'min_col': min_col\n        })\n        \n    return objects\n\ndef vertically_center(content: np.ndarray, target_height: int, pad_value: int) -> np.ndarray:\n    \"\"\"Centers 'content' vertically within a grid of 'target_height', padding with 'pad_value'.\"\"\"\n    current_height, current_width = content.shape\n    \n    # Handle cases with empty dimensions\n    if current_width == 0:\n        return np.full((target_height, 0), pad_value, dtype=content.dtype)\n    if current_height == 0:\n         # If input content has no height but some width, return full background\n        return np.full((target_height, current_width), pad_value, dtype=content.dtype)\n\n    if current_height >= target_height:\n        # If content is taller or equal, take the central part\n        start_row = (current_height - target_height) // 2\n        return content[start_row:start_row + target_height, :]\n\n    # Calculate padding needed above and below\n    pad_total = target_height - current_height\n    pad_top = pad_total // 2\n    pad_bottom = pad_total - pad_top\n\n    # Create padding arrays\n    top_padding = np.full((pad_top, current_width), pad_value, dtype=content.dtype)\n    bottom_padding = np.full((pad_bottom, current_width), pad_value, dtype=content.dtype)\n\n    # Stack them vertically\n    centered_content = np.vstack((top_padding, content, bottom_padding))\n    return centered_content\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Convert input to numpy array\n    grid = np.array(input_grid, dtype=int)\n    if grid.size == 0:\n        return [] # Handle empty input grid\n\n    # Step 1: Determine background digit\n    background_digit = find_background(grid)\n    \n    # Step 2: Identify all distinct connected objects\n    all_objects = find_connected_objects(grid, background_digit)\n    if not all_objects:\n        return [] # No foreground objects found\n\n    # Step 3: Group objects by height and find the pair height\n    height_groups = collections.defaultdict(list)\n    for obj in all_objects:\n        height_groups[obj['height']].append(obj)\n        \n    selected_pair = []\n    H_pair = -1\n    for height, objs in height_groups.items():\n        if len(objs) == 2:\n            selected_pair = objs\n            H_pair = height\n            break # Assume only one such height exists per problem constraints\n            \n    if not selected_pair:\n        # Error case: No pair with unique matching height found.\n        # Based on examples, this shouldn't happen for valid inputs.\n        print(\"Error: No pair of objects with the same unique height found.\")\n        return [] \n\n    # Step 4: Identify Left (A) and Right (B) objects in the selected pair\n    obj1, obj2 = selected_pair\n    if obj1['min_col'] < obj2['min_col']:\n        object_A = obj1 # Left\n        object_B = obj2 # Right\n    else:\n        object_A = obj2 # Left\n        object_B = obj1 # Right\n        \n    content_A = object_A['content']\n    content_B = object_B['content']\n    W_A = object_A['width']\n    W_B = object_B['width']\n\n    # Step 5: Identify the ignored set\n    ignored_set = [obj for obj in all_objects if obj['id'] != object_A['id'] and obj['id'] != object_B['id']]\n\n    # Step 6: Find the widest ignored object C\n    widest_ignored_object_C = None\n    W_C_maxW = 0\n    if ignored_set:\n        # Sort by width (descending) to find the widest\n        ignored_set.sort(key=lambda x: x['width'], reverse=True)\n        widest_ignored_object_C = ignored_set[0]\n        W_C_maxW = widest_ignored_object_C['width']\n\n    # Step 7: Apply conditional transformation rule\n    output_grid_np = None\n    if widest_ignored_object_C is None or W_C_maxW <= W_B:\n        # === Apply the Simple Rule ===\n        \n        # Slice A: remove first column\n        if W_A <= 1:\n             sliced_content_A = np.empty((H_pair, 0), dtype=content_A.dtype) \n        else:\n             sliced_content_A = content_A[:, 1:]\n             \n        # Concatenate B and Sliced A\n        output_grid_np = np.hstack((content_B, sliced_content_A))\n\n    else:\n        # === Apply the Complex Rule (W_C_maxW > W_B) ===\n        content_C = widest_ignored_object_C['content']\n        \n        # --- 1. Create Padding grid ---\n        pad_W = W_C_maxW - 2\n        padding_base = None\n        if pad_W <= 0:\n             # If C is too narrow (width 1 or 2), padding base is empty\n             # Need the height of C to create an empty array of correct type/dims\n             h_C = content_C.shape[0]\n             padding_base = np.empty((h_C, 0), dtype=content_C.dtype) \n        else:\n             padding_base = content_C[:, :pad_W]\n\n        # Vertically center the padding base\n        padding_grid = vertically_center(padding_base, H_pair, background_digit)\n        \n        # --- 2. Create Assembly grid ---\n        # a. Slice A: remove first two columns\n        assembly_slice_A = None\n        if W_A <= 2:\n            assembly_slice_A = np.empty((H_pair, 0), dtype=content_A.dtype) \n        else:\n            assembly_slice_A = content_A[:, 2:]\n            \n        # b. Slice B: remove last two columns\n        assembly_slice_B = None\n        if W_B <= 2:\n             assembly_slice_B = np.empty((H_pair, 0), dtype=content_B.dtype)\n        else:\n             assembly_slice_B = content_B[:, :-2]\n        \n        # c. Concatenate Assembly parts\n        assembly_grid = np.hstack((assembly_slice_A, assembly_slice_B))\n\n        # --- 3. Combine Padding and Assembly ---\n        output_grid_np = np.hstack((padding_grid, assembly_grid))\n\n    # Convert final numpy array back to list of lists\n    if output_grid_np is None:\n        # Should not happen if logic covers all cases, but as a safeguard\n        return [] \n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34816,
    "candidates_token_count": 3072,
    "total_token_count": 37888,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.387767,
  "retries": 1
}