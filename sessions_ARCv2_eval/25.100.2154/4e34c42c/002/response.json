{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies connected components (objects) of non-background digits in an input grid.\nDetermines the background digit as the most frequent digit.\nFinds the height (H_pair) shared by exactly two objects (selected_pair).\nIdentifies the left (A) and right (B) objects within the selected_pair.\nFinds the widest object (C) among the remaining (ignored) objects.\nApplies one of two transformation rules based on whether the width of C (W_C) is greater than the width of B (W_B):\n1. Simple Rule (W_C <= W_B): Concatenates the content of B with the content of A (excluding A's first column).\n2. Complex Rule (W_C > W_B): \n   - Creates a padding grid by vertically centering the first W_C-2 columns of C's content to height H_pair.\n   - Takes the content of A excluding the first two columns (Slice_A).\n   - Reorders the columns of B's content: column 2, then columns 0-1, then columns 3+ (Slice_B).\n   - Concatenates Padding, Slice_A, and Slice_B horizontally.\nReturns the resulting grid.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\nimport collections\n\ndef find_background(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent element in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assume the most frequent is the background\n    background_digit = counts.most_common(1)[0][0]\n    return background_digit\n\ndef find_objects(grid: np.ndarray, background_digit: int) -> list[dict]:\n    \"\"\"Finds connected components of non-background digits.\"\"\"\n    mask = grid != background_digit\n    labeled_array, num_features = label(mask)\n    \n    objects = []\n    slices = find_objects(labeled_array)\n    \n    if not slices: # Handle cases with no foreground objects\n        return []\n\n    for i, slc in enumerate(slices):\n        if slc is None: # Might happen if labels are not contiguous? Skip.\n             continue\n        obj_id = i + 1 # Labels start from 1\n        # Ensure we only consider the actual object, not the bounding box padding\n        component_mask = labeled_array[slc] == obj_id\n        obj_content_full = grid[slc] # Content within bounding box\n        # Extract only the non-background digits for shape calculation (alternative bounding box)\n        # rows, cols = np.where(component_mask)\n        # min_r, max_r = rows.min(), rows.max()\n        # min_c, max_c = cols.min(), cols.max()\n        # height = max_r - min_r + 1\n        # width = max_c - min_c + 1\n        \n        # Use bounding box dimensions directly from find_objects slice\n        height = slc[0].stop - slc[0].start\n        width = slc[1].stop - slc[1].start\n        min_row = slc[0].start\n        min_col = slc[1].start\n\n        objects.append({\n            'id': obj_id,\n            'slice': slc,\n            'content': obj_content_full,\n            'height': height,\n            'width': width,\n            'min_row': min_row,\n            'min_col': min_col\n        })\n        \n    return objects\n\ndef vertically_center(content: np.ndarray, target_height: int, pad_value: int) -> np.ndarray:\n    \"\"\"Centers 'content' vertically within a grid of 'target_height', padding with 'pad_value'.\"\"\"\n    current_height, current_width = content.shape\n    if current_height >= target_height:\n        # If content is taller or equal, take the central part\n        start_row = (current_height - target_height) // 2\n        return content[start_row:start_row + target_height, :]\n\n    # Calculate padding needed above and below\n    pad_total = target_height - current_height\n    pad_top = pad_total // 2\n    pad_bottom = pad_total - pad_top\n\n    # Create padding arrays\n    top_padding = np.full((pad_top, current_width), pad_value, dtype=content.dtype)\n    bottom_padding = np.full((pad_bottom, current_width), pad_value, dtype=content.dtype)\n\n    # Stack them vertically\n    centered_content = np.vstack((top_padding, content, bottom_padding))\n    return centered_content\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    \n    # 1. Find Background Digit\n    background_digit = find_background(grid)\n    \n    # 2. Find Objects\n    all_objects = find_objects(grid, background_digit)\n    if not all_objects:\n        return [] # Or handle as error, return empty grid?\n\n    # 3. Group by height and find the pair height\n    height_groups = collections.defaultdict(list)\n    for obj in all_objects:\n        height_groups[obj['height']].append(obj)\n        \n    selected_pair = []\n    H_pair = -1\n    for height, objs in height_groups.items():\n        if len(objs) == 2:\n            selected_pair = objs\n            H_pair = height\n            break\n            \n    if not selected_pair:\n        # Handle error: No pair with unique matching height found\n        # This case is not covered by the examples, returning empty for now.\n        print(\"Error: No pair of objects with the same unique height found.\")\n        return []\n\n    # 4. Identify Left/Right in selected_pair\n    obj1, obj2 = selected_pair\n    if obj1['min_col'] < obj2['min_col']:\n        object_A = obj1 # Left\n        object_B = obj2 # Right\n    else:\n        object_A = obj2 # Left\n        object_B = obj1 # Right\n        \n    content_A = object_A['content']\n    content_B = object_B['content']\n    W_A = object_A['width']\n    W_B = object_B['width']\n\n    # 5. Identify Ignored Set\n    ignored_set = [obj for obj in all_objects if obj not in selected_pair]\n\n    # 6. Find Widest Ignored Object\n    widest_ignored_object = None\n    W_C_maxW = 0\n    if ignored_set:\n        widest_ignored_object = max(ignored_set, key=lambda obj: obj['width'])\n        W_C_maxW = widest_ignored_object['width']\n\n    # 7. Apply Conditional Rule Selection\n    if widest_ignored_object and W_C_maxW > W_B:\n        # Apply the Complex Rule\n        content_C = widest_ignored_object['content']\n        \n        pad_W = W_C_maxW - 2\n        if pad_W <= 0:\n             # If widest ignored is too thin, maybe default to simple rule or handle error?\n             # Based on example 2, C has width 8, B has width 7 -> pad_W = 6.\n             # Let's assume pad_W will be positive based on the logic W_C > W_B.\n             # If C has width 1 or 2, this rule might behave unexpectedly.\n             # If W_C = 3 and W_B = 2, pad_W=1. Seems okay.\n             # If W_C = 2 and W_B = 1, pad_W=0. Padding will be empty.\n             padding_base = np.empty((content_C.shape[0], 0), dtype=content_C.dtype) # Empty base if pad_W is 0\n        else:\n             padding_base = content_C[:, :pad_W]\n\n        # Create padding grid\n        padding_grid = vertically_center(padding_base, H_pair, background_digit)\n        \n        # Slice A (remove first two columns)\n        if W_A <= 2:\n            slice_A = np.empty((H_pair, 0), dtype=content_A.dtype) # Empty slice\n        else:\n            slice_A = content_A[:, 2:]\n            \n        # Slice and reassemble B\n        parts_B = []\n        # Part 1: Column 2 (index 2)\n        if W_B > 2:\n            parts_B.append(content_B[:, 2:3])\n        # Part 2: Columns 0, 1 (index 0, 1)\n        if W_B > 0:\n             parts_B.append(content_B[:, 0:min(2, W_B)]) # Take up to first 2 cols\n        # Part 3: Columns 3 onwards (index 3+)\n        if W_B > 3:\n            parts_B.append(content_B[:, 3:])\n            \n        if not parts_B:\n             slice_B = np.empty((H_pair, 0), dtype=content_B.dtype) # Empty slice if B is too small\n        else:\n             slice_B = np.hstack(parts_B)\n\n        # Concatenate final output for complex rule\n        output_grid_np = np.hstack((padding_grid, slice_A, slice_B))\n\n    else:\n        # Apply the Simple Rule\n        # Slice A (remove first column)\n        if W_A <= 1:\n             sliced_content_A = np.empty((H_pair, 0), dtype=content_A.dtype) # Empty slice\n        else:\n             sliced_content_A = content_A[:, 1:]\n             \n        # Concatenate final output for simple rule\n        output_grid_np = np.hstack((content_B, sliced_content_A))\n\n    # Convert back to list of lists\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6036,
    "candidates_token_count": 3273,
    "total_token_count": 9309,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 25.954617,
  "retries": 1
}