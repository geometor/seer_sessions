{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation rule identifies distinct roles for non-background colors: Anchor, Static, and Mover. It operates sequentially, allowing later steps to overwrite earlier ones under specific conditions.\n\n1.  **Initialization**: Determine grid dimensions (H, W) and the background color (B, most frequent). Create an output grid initialized with B.\n2.  **Role Identification**:\n    *   **Anchor**: Find the column (`anc_c`) containing specific, preserved non-background values (`anchor_vals`). Heuristics like known patterns ([2, 8], [2], [5], [6]) or column consistency are used.\n    *   **Mover**: Identify the most frequent non-anchor, non-background color (`M`).\n    *   **Static**: Identify any remaining non-background, non-anchor, non-mover colors (`S`).\n3.  **Sequential Placement (Overwrite Logic)**:\n    *   **Static Placement**: Copy Static objects (`S`) from input to output, overwriting the background.\n    *   **Anchor Placement**: Copy the anchor column (`anc_c`) from input to output, overwriting background/static values in that column.\n    *   **Mover Processing**: Determine if Movers (`M`) are primarily LEFT or RIGHT of `anc_c`.\n        *   **Left Movers**:\n            *   Calculate target coordinates `(tr, tc)` based on shifts `(dr, dc)` specific to `M` and the relative column (`rel_c`: -1, -2, or -3 for M=9).\n                *   `rel_c = -1`: Shift `(dr1(M), 0)`. `dr1` maps M={4:0, 3:-1, 8:-4, 9:0}.\n                *   `rel_c = -2`: Shift `(dr2(M), dc2(M))`. `dr2` maps M={4:-2, 3:-1, 8:-4, 9:-2}. `dc2` is 0 if M=9, else 1.\n                *   `rel_c = -3`: Only if M=9, shift `(-5, 0)`.\n            *   Place `M` at `(tr, tc)` **only if** the target cell in the *current output grid* contains the background color `B`. Track if any move originated from `rel_c = -2` (`flag_minus_2`).\n            *   **Conditional Generation**: If `flag_minus_2` is true, attempt to place `M` at specific coordinates near the top, **only if** the target cell contains the background color `B`.\n                *   M=4: Target `(0, anc_c)`.\n                *   M=8: Target `(0, anc_c - 1)`.\n                *   M=9: Targets `(0, anc_c - 1)` and `(1, anc_c - 1)`.\n        *   **Right Movers (M=7 Specific)**:\n            *   Preserve an M=7 mover at `(r, anc_c + 1)` if `input[r, anc_c]` is an anchor value. Place M=7 at this coord in the output (overwrites background/static). Store location `(pr, pc)`.\n            *   If preserved, generate a 'V' shape using M=7 relative to `(pr, pc)` and Static object (S=9) properties. Place M=7 at shape coordinates **only if** the target cell contains the background color `B`.\n        *   **Other Movers**: Movers far left/right or in unhandled patterns are effectively removed (left as background or overwritten).\n4.  **Output**: Return the final state of the output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background_color(grid_np: np.ndarray) -> int:\n    \"\"\"Identifies the most frequent color as the background color.\"\"\"\n    counts = Counter(grid_np.flatten())\n    if not counts:\n        return 0 # Default background\n    # Assume most frequent color is background\n    background_color = counts.most_common(1)[0][0]\n    return int(background_color)\n\ndef find_anchor_column(grid_np: np.ndarray, background_color: int) -> tuple[int, set[int]]:\n    \"\"\"\n    Identifies the anchor column index and the set of anchor values.\n    Relies on heuristics like known patterns or column consistency.\n    \"\"\"\n    H, W = grid_np.shape\n    # Known anchor patterns observed in examples\n    known_anchor_sets = [{2, 8}, {2}, {5}, {6}]\n\n    anchor_candidates = []\n\n    for c in range(W):\n        column = grid_np[:, c]\n        non_background_mask = column != background_color\n        non_background_values = column[non_background_mask]\n\n        if len(non_background_values) > 0:\n            unique_non_bg = set(non_background_values)\n            # Assign priority based on matching known sets, single value, or multiple values\n            priority = 3\n            if unique_non_bg in known_anchor_sets:\n                priority = 1\n            elif len(unique_non_bg) == 1:\n                 priority = 2\n            \n            anchor_candidates.append({'col': c, 'vals': unique_non_bg, 'priority': priority, 'count': len(non_background_values)})\n\n\n    if not anchor_candidates:\n        return -1, set()\n\n    # Sort candidates: lowest priority number first, then highest count\n    anchor_candidates.sort(key=lambda x: (x['priority'], -x['count']))\n\n    best_candidate = anchor_candidates[0]\n    return best_candidate['col'], best_candidate['vals']\n\n\ndef identify_roles(grid_np: np.ndarray, anchor_col: int, anchor_vals: set[int], background_color: int) -> tuple[int, set[int]]:\n    \"\"\"Identifies Mover (most frequent other) and Static colors.\"\"\"\n    H, W = grid_np.shape\n    counts = Counter(grid_np.flatten())\n    mover_color = -1\n    static_colors = set()\n\n    potential_movers = {}\n    for val, count in counts.items():\n        val_int = int(val) # Ensure integer type\n        # Exclude background and anchor values\n        if val_int != background_color and val_int not in anchor_vals:\n            potential_movers[val_int] = count\n\n    # Heuristic: Mover is the most frequent non-anchor, non-background color\n    if potential_movers:\n        mover_color = max(potential_movers, key=potential_movers.get)\n\n    # Heuristic: Static colors are any other non-anchor, non-bg, non-mover colors\n    for val in potential_movers:\n        if val != mover_color:\n            static_colors.add(val)\n\n    return mover_color, static_colors\n\ndef get_object_coords(grid_np: np.ndarray, value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of a given value.\"\"\"\n    coords = np.argwhere(grid_np == value)\n    # Return list of tuples, ensuring correct types\n    return [(int(r), int(c)) for r, c in coords]\n\ndef get_static_properties(static_coords: list[tuple[int, int]]) -> tuple[int, int, int]:\n    \"\"\"Calculates properties of static objects, useful for M=7 rule.\"\"\"\n    if not static_coords:\n        return -1, -1, -1\n    cols = [c for r, c in static_coords]\n    rows = [r for r, c in static_coords]\n    # Assuming static objects often form a column (like train_3's '9's)\n    static_c = Counter(cols).most_common(1)[0][0] if cols else -1\n    min_r_S = min(rows) if rows else -1\n    max_r_S = max(rows) if rows else -1\n    return int(static_c), int(min_r_S), int(max_r_S)\n\ndef generate_v_shape(preserved_coord: tuple[int, int] | None, static_props: tuple[int, int, int], H: int, W: int) -> list[tuple[int, int]]:\n    \"\"\"Generates coordinates for the 'V' shape in the M=7 right-side rule.\"\"\"\n    shape_coords = []\n    if not preserved_coord or not static_props or static_props[0] == -1:\n        return shape_coords\n\n    pr, pc = preserved_coord\n    static_c, min_r_S, max_r_S = static_props\n\n    # Ensure static properties are valid\n    if min_r_S == -1 or max_r_S == -1:\n         return shape_coords\n\n    # Segment 1 (Approach): Diagonal down-right until static object row\n    for i in range(1, H):\n        tr, tc = pr + i, pc + i\n        if tr >= min_r_S: break # Stop before hitting static object's row span\n        if 0 <= tr < H and 0 <= tc < W: shape_coords.append((tr, tc))\n        else: break # Out of bounds\n\n    # Segment 2 (Alongside): Down alongside static object + 1 column\n    for i in range(max_r_S - min_r_S + 1):\n        tr, tc = min_r_S + i, static_c + 1\n        if 0 <= tr < H and 0 <= tc < W: shape_coords.append((tr, tc))\n\n    # Segment 3 (Depart): Diagonal down-left from static object until preservation column\n    for i in range(H): # Limit search range\n        tr, tc = max_r_S + 1 + i, static_c - i\n        if tc < 0: break # Out of bounds left\n        if 0 <= tr < H and 0 <= tc < W:\n            shape_coords.append((tr, tc))\n        else: break # Out of bounds other\n        if tc == pc: break # Stop when reaching the preserved mover's column\n\n    return shape_coords\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on identified Anchor, Static, and Mover roles.\n    Follows a sequential placement/overwrite logic, with movers/generation only placing on background.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    inp = np.array(input_grid, dtype=int)\n    if inp.size == 0: return [] # Handle empty input\n    H, W = inp.shape\n\n    # 1. Determine background color\n    B = find_background_color(inp)\n\n    # 2. Initialize output grid\n    out = np.full((H, W), B, dtype=int)\n\n    # 3. Identify Anchor column and value(s)\n    anc_c, anchor_vals = find_anchor_column(inp, B)\n    # If no clear anchor found, return background grid.\n    if anc_c == -1:\n        return out.tolist()\n\n    # 4. Identify Mover (M) and Static (S) colors\n    M, static_colors = identify_roles(inp, anc_c, anchor_vals, B)\n\n    # 5. Static Placement (Overwrites Background)\n    all_static_coords = []\n    static_props = (-1, -1, -1)\n    for S_val in static_colors:\n        s_coords = get_object_coords(inp, S_val)\n        all_static_coords.extend(s_coords)\n        for r, c in s_coords:\n            if 0 <= r < H and 0 <= c < W: out[r, c] = S_val\n\n    # Get static properties potentially needed for M=7 rule\n    if M == 7:\n         # Assumption: M=7 rule specifically uses the static object '9' based on train_3\n         static_coords_for_M7 = get_object_coords(inp, 9)\n         static_props = get_static_properties(static_coords_for_M7)\n\n    # 6. Anchor Placement (Overwrites Background/Static)\n    if 0 <= anc_c < W:\n        out[:, anc_c] = inp[:, anc_c]\n\n    # If no mover identified, return grid with static/anchor placed\n    if M == -1:\n        return out.tolist()\n\n    # 7. Get Mover coordinates from input\n    input_M_coords = get_object_coords(inp, M)\n    if not input_M_coords:\n        return out.tolist() # No movers to process\n\n    # 8. Determine LEFT vs RIGHT mover location\n    mover_cols = [c for r, c in input_M_coords]\n    avg_col_M = sum(mover_cols) / len(mover_cols) if mover_cols else anc_c\n    # Treat movers exactly in anchor column as neither left nor right for these rules\n    is_left_mover = avg_col_M < anc_c\n    # Right mover rules are currently only defined for M=7\n    is_right_mover = avg_col_M > anc_c and M == 7\n\n    # 9. Process LEFT Movers\n    if is_left_mover:\n        flag_minus_2 = False # Tracks if a successful move originated from rel_col -2\n\n        # Define M-dependent shifts\n        dr1_map = {4: 0, 3: -1, 8: -4, 9: 0}\n        dr2_map = {4: -2, 3: -1, 8: -4, 9: -2}\n        dr3 = -5 # M=9 only\n\n        dc1 = 0\n        # dc2 is 0 for M=9, else 1\n        dc2 = 0 if M == 9 else 1\n        dc3 = 0 # M=9 only\n\n        mover_placements = [] # Stores (target_row, target_col, source_rel_col)\n\n        # Calculate target positions for all relevant input movers\n        for r, c in input_M_coords:\n            rel_c = c - anc_c\n            dr, dc = 0, 0\n            valid_shift_rule = False\n\n            if rel_c == -1:\n                dr, dc = dr1_map.get(M, 0), dc1\n                valid_shift_rule = True\n            elif rel_c == -2:\n                dr, dc = dr2_map.get(M, 0), dc2\n                valid_shift_rule = True\n            elif rel_c == -3 and M == 9:\n                dr, dc = dr3, dc3\n                valid_shift_rule = True\n\n            if valid_shift_rule:\n                tr, tc = r + dr, c + dc\n                mover_placements.append({'tr': tr, 'tc': tc, 'src_rel_c': rel_c})\n\n        # Apply Mover Placements (Only Overwrite Background)\n        for placement in mover_placements:\n            tr, tc, src_rel_c = placement['tr'], placement['tc'], placement['src_rel_c']\n            if 0 <= tr < H and 0 <= tc < W and out[tr, tc] == B: # Check bounds and background\n                out[tr, tc] = M\n                if src_rel_c == -2:\n                    flag_minus_2 = True # Mark success only if placement happened\n\n        # Apply Conditional Generation (Only Overwrite Background)\n        if flag_minus_2:\n            if M == 4:\n                # Target (0, anc_c)\n                tr, tc = 0, anc_c\n                if 0 <= tr < H and 0 <= tc < W and out[tr, tc] == B: out[tr, tc] = 4\n            elif M == 8:\n                # Target (0, anc_c - 1)\n                tr, tc = 0, anc_c - 1\n                if 0 <= tr < H and 0 <= tc < W and out[tr, tc] == B: out[tr, tc] = 8\n            elif M == 9:\n                # Target1 (0, anc_c - 1)\n                tr1, tc1 = 0, anc_c - 1\n                if 0 <= tr1 < H and 0 <= tc1 < W and out[tr1, tc1] == B: out[tr1, tc1] = 9\n                # Target2 (1, anc_c - 1)\n                tr2, tc2 = 1, anc_c - 1\n                if 0 <= tr2 < H and 0 <= tc2 < W and out[tr2, tc2] == B: out[tr2, tc2] = 9\n\n    # 10. Process RIGHT Movers (Only M=7 logic defined)\n    elif is_right_mover: # M == 7 is implied by the flag\n        preserved_mover_coord = None\n        # Find and place the preserved mover adjacent to the anchor (Overwrites)\n        for r, c in input_M_coords:\n            if c == anc_c + 1:\n                 # Check input anchor column at the same row\n                 if 0 <= r < H and inp[r, anc_c] in anchor_vals:\n                     # Place in output if bounds are valid (Overwrite OK here)\n                     if 0 <= r < H and 0 <= c < W:\n                         out[r, c] = M # M is 7 here\n                         preserved_mover_coord = (r, c)\n                         break # Assume only one based on train_3\n\n        # Generate 'V' shape if preservation occurred and static props are valid\n        if preserved_mover_coord and static_props[0] != -1:\n             shape_coords = generate_v_shape(preserved_mover_coord, static_props, H, W)\n             # Place shape points (Only Overwrite Background)\n             for gr, gc in shape_coords:\n                 if 0 <= gr < H and 0 <= gc < W and out[gr, gc] == B: # Check bounds and background\n                     out[gr, gc] = M # M is 7 here\n\n    # 11. ELSE (Mixed/Unknown Mover pattern, or M != 7 on right)\n    # No action defined for these cases, grid remains as is after Static/Anchor placement.\n\n    # 12. Return final grid\n    return out.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34721,
    "candidates_token_count": 4917,
    "total_token_count": 39638,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 29.665758,
  "retries": 1
}