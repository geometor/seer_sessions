{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation rule identifies distinct roles for different non-background colors in the input grid: Anchor, Static, and Mover.\n\n1.  **Initialization**: Determine grid dimensions (H, W) and the background color (B, typically the most frequent color). Create an output grid initialized with B.\n2.  **Role Identification**:\n    *   **Anchor**: Find the column (`anc_c`) containing specific, vertically consistent non-background values (`anchor_vals`). These values often form known patterns (e.g., [2], [5], [6], [2, 8]) or are the only non-background values in that column.\n    *   **Mover**: Identify the most frequent non-anchor, non-background color (`M`) in the input grid.\n    *   **Static**: Identify any remaining non-background, non-anchor, non-mover colors (`S`).\n3.  **Sequential Placement (Overwrite Logic)**: Apply transformations in order, allowing later steps to overwrite earlier ones.\n    *   **Static Placement**: Copy all Static objects (`S`) from their input positions to the output grid. Record properties (column, row span) if needed (especially for the M=7 case).\n    *   **Anchor Placement**: Copy the entire anchor column (`anc_c`) from the input to the output grid.\n    *   **Mover Processing**:\n        *   Determine if the Mover (`M`) objects are primarily located LEFT (`< anc_c`) or RIGHT (`> anc_c`) of the anchor column based on their average column index.\n        *   **Left Movers**:\n            *   Apply specific vertical (`dr`) and horizontal (`dc`) shifts to movers based on `M` and their relative column (`rel_c`) to the anchor:\n                *   `rel_c = -1`: Shift `(dr1(M), 0)`. `dr1` maps M={4:0, 3:-1, 8:-4, 9:0}.\n                *   `rel_c = -2`: Shift `(dr2(M), dc2(M))`. `dr2` maps M={4:-2, 3:-1, 8:-4, 9:-2}. `dc2` is 0 if M=9, else 1.\n                *   `rel_c = -3`: Only if M=9, shift `(-5, 0)`.\n            *   Place the shifted Mover value in the output grid if the target coordinates are valid. Keep track if any successful move originated from `rel_c = -2` (`flag_minus_2`).\n            *   **Conditional Generation**: If `flag_minus_2` is true, generate new Mover values at specific locations near the top of the grid, depending on `M`:\n                *   M=4: Place 4 at `(0, anc_c)`.\n                *   M=8: Place 8 at `(0, anc_c - 1)`.\n                *   M=9: Place 9 at `(0, anc_c - 1)` and `(1, anc_c - 1)`.\n        *   **Right Movers (M=7 Specific)**:\n            *   Find and preserve an M=7 mover at `(r, anc_c + 1)` if `input[r, anc_c]` is an anchor value. Store its location `(pr, pc)`.\n            *   If preserved, generate a 'V' shape using M=7, positioned relative to `(pr, pc)` and the properties (column, row span) of the Static objects (assumed to be S=9 based on examples). Place the shape in the output grid.\n        *   **Other Movers**: Movers far left (`rel_c < -3`, unless M=9) or movers in unhandled right-side patterns are effectively removed (overwritten by background or other placements).\n4.  **Output**: Return the final state of the output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background_color(grid_np: np.ndarray) -> int:\n    \"\"\"Identifies the most frequent color as the background color.\"\"\"\n    counts = Counter(grid_np.flatten())\n    if not counts:\n        return 0 # Default background\n    # Assume most frequent color is background\n    background_color = counts.most_common(1)[0][0]\n    return int(background_color)\n\ndef find_anchor_column(grid_np: np.ndarray, background_color: int) -> tuple[int, set[int]]:\n    \"\"\"\n    Identifies the anchor column index and the set of anchor values.\n    Relies on heuristics like known patterns or column consistency.\n    \"\"\"\n    H, W = grid_np.shape\n    # Known anchor patterns observed in examples\n    known_anchor_sets = [{2, 8}, {2}, {5}, {6}]\n\n    anchor_candidates = []\n\n    for c in range(W):\n        column = grid_np[:, c]\n        non_background_mask = column != background_color\n        non_background_values = column[non_background_mask]\n\n        if len(non_background_values) > 0:\n            unique_non_bg = set(non_background_values)\n            # Prioritize known patterns\n            if unique_non_bg in known_anchor_sets:\n                anchor_candidates.append({'col': c, 'vals': unique_non_bg, 'priority': 1, 'count': len(non_background_values)})\n            # Otherwise consider columns with only one type of non-bg value\n            elif len(unique_non_bg) == 1:\n                 anchor_candidates.append({'col': c, 'vals': unique_non_bg, 'priority': 2, 'count': len(non_background_values)})\n            # Fallback: store any column with non-bg elements\n            else:\n                 anchor_candidates.append({'col': c, 'vals': unique_non_bg, 'priority': 3, 'count': len(non_background_values)})\n\n\n    if not anchor_candidates:\n        return -1, set()\n\n    # Sort candidates: lowest priority number first, then highest count\n    anchor_candidates.sort(key=lambda x: (x['priority'], -x['count']))\n\n    best_candidate = anchor_candidates[0]\n    return best_candidate['col'], best_candidate['vals']\n\n\ndef identify_roles(grid_np: np.ndarray, anchor_col: int, anchor_vals: set[int], background_color: int) -> tuple[int, set[int]]:\n    \"\"\"Identifies Mover (most frequent other) and Static colors.\"\"\"\n    H, W = grid_np.shape\n    counts = Counter(grid_np.flatten())\n    mover_color = -1\n    static_colors = set()\n\n    potential_movers = {}\n    for val, count in counts.items():\n        val_int = int(val) # Ensure integer type\n        # Exclude background and anchor values\n        if val_int != background_color and val_int not in anchor_vals:\n             # Check if it's actually present outside the anchor column too,\n             # although the main heuristic is frequency.\n            potential_movers[val_int] = count\n\n    # Heuristic: Mover is the most frequent non-anchor, non-background color\n    if potential_movers:\n        mover_color = max(potential_movers, key=potential_movers.get)\n\n    # Heuristic: Static colors are any other non-anchor, non-bg, non-mover colors\n    for val in potential_movers:\n        if val != mover_color:\n            static_colors.add(val)\n\n    return mover_color, static_colors\n\ndef get_object_coords(grid_np: np.ndarray, value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of a given value.\"\"\"\n    coords = np.argwhere(grid_np == value)\n    # Return list of tuples, ensuring correct types\n    return [(int(r), int(c)) for r, c in coords]\n\ndef get_static_properties(static_coords: list[tuple[int, int]]) -> tuple[int, int, int]:\n    \"\"\"Calculates properties of static objects, useful for M=7 rule.\"\"\"\n    if not static_coords:\n        return -1, -1, -1\n    cols = [c for r, c in static_coords]\n    rows = [r for r, c in static_coords]\n    # Assuming static objects often form a column (like train_3's '9's)\n    static_c = Counter(cols).most_common(1)[0][0] if cols else -1\n    min_r_S = min(rows) if rows else -1\n    max_r_S = max(rows) if rows else -1\n    return int(static_c), int(min_r_S), int(max_r_S)\n\ndef generate_v_shape(preserved_coord: tuple[int, int] | None, static_props: tuple[int, int, int], H: int, W: int) -> list[tuple[int, int]]:\n    \"\"\"Generates coordinates for the 'V' shape in the M=7 right-side rule.\"\"\"\n    shape_coords = []\n    if not preserved_coord or not static_props or static_props[0] == -1:\n        return shape_coords\n\n    pr, pc = preserved_coord\n    static_c, min_r_S, max_r_S = static_props\n\n    # Segment 1 (Approach): Diagonal down-right until static object row\n    for i in range(1, H):\n        tr, tc = pr + i, pc + i\n        if tr >= min_r_S: break # Stop before hitting static object's row span\n        if 0 <= tr < H and 0 <= tc < W: shape_coords.append((tr, tc))\n        else: break # Out of bounds\n\n    # Segment 2 (Alongside): Down alongside static object + 1 column\n    for i in range(max_r_S - min_r_S + 1):\n        tr, tc = min_r_S + i, static_c + 1\n        if 0 <= tr < H and 0 <= tc < W: shape_coords.append((tr, tc))\n\n    # Segment 3 (Depart): Diagonal down-left from static object until preservation column\n    for i in range(H): # Limit search range\n        tr, tc = max_r_S + 1 + i, static_c - i\n        if tc < 0: break # Out of bounds left\n        if 0 <= tr < H and 0 <= tc < W:\n            shape_coords.append((tr, tc))\n        else: break # Out of bounds other\n        if tc == pc: break # Stop when reaching the preserved mover's column\n\n    return shape_coords\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on identified Anchor, Static, and Mover roles.\n    Follows a sequential placement/overwrite logic.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    inp = np.array(input_grid, dtype=int)\n    if inp.size == 0: return [] # Handle empty input\n    H, W = inp.shape\n\n    # 1. Determine background color\n    B = find_background_color(inp)\n\n    # 2. Initialize output grid\n    out = np.full((H, W), B, dtype=int)\n\n    # 3. Identify Anchor column and value(s)\n    anc_c, anchor_vals = find_anchor_column(inp, B)\n    # If no clear anchor found, maybe return input or background?\n    # Based on examples, anchor seems always present. If not, return background.\n    if anc_c == -1:\n        # print(\"Warning: No anchor column identified.\")\n        return out.tolist()\n\n    # 4. Identify Mover (M) and Static (S) colors\n    M, static_colors = identify_roles(inp, anc_c, anchor_vals, B)\n\n    # If no mover found, just place static and anchor and return\n    if M == -1:\n        # print(\"Warning: No mover identified.\")\n        # Place Static\n        for S_val in static_colors:\n             static_coords = get_object_coords(inp, S_val)\n             for r, c in static_coords:\n                 if 0 <= r < H and 0 <= c < W: out[r, c] = S_val\n        # Place Anchor\n        if 0 <= anc_c < W: out[:, anc_c] = inp[:, anc_c]\n        return out.tolist()\n\n    # 5. Static Placement\n    all_static_coords = []\n    static_props = (-1, -1, -1)\n    for S_val in static_colors:\n        s_coords = get_object_coords(inp, S_val)\n        all_static_coords.extend(s_coords)\n        for r, c in s_coords:\n            if 0 <= r < H and 0 <= c < W: out[r, c] = S_val\n\n    # Get properties potentially needed for M=7 rule\n    if M == 7:\n         # Assumption: M=7 rule specifically uses the static object '9' based on train_3\n         static_coords_for_M7 = get_object_coords(inp, 9)\n         static_props = get_static_properties(static_coords_for_M7)\n    # else: # Currently no other rule explicitly needs static props\n    #    static_props = get_static_properties(all_static_coords)\n\n\n    # 6. Anchor Placement (overwrites static if necessary)\n    if 0 <= anc_c < W:\n        out[:, anc_c] = inp[:, anc_c]\n\n    # 7. Get Mover coordinates\n    input_M_coords = get_object_coords(inp, M)\n    if not input_M_coords:\n        return out.tolist() # No movers to process\n\n    # 8. Determine LEFT vs RIGHT mover location\n    mover_cols = [c for r, c in input_M_coords]\n    avg_col_M = sum(mover_cols) / len(mover_cols) if mover_cols else anc_c\n    # Treat movers exactly in anchor column as neither left nor right for these rules\n    is_left_mover = avg_col_M < anc_c\n    # Right mover rules are currently only defined for M=7\n    is_right_mover = avg_col_M > anc_c and M == 7\n\n    # 9. Process LEFT Movers\n    if is_left_mover:\n        flag_minus_2 = False # Tracks if a successful move originated from rel_col -2\n\n        # Define M-dependent shifts\n        dr1_map = {4: 0, 3: -1, 8: -4, 9: 0}\n        dr2_map = {4: -2, 3: -1, 8: -4, 9: -2}\n        dr3 = -5 # M=9 only\n\n        dc1 = 0\n        # dc2 is 0 for M=9, else 1\n        dc2 = 0 if M == 9 else 1\n        dc3 = 0 # M=9 only\n\n        mover_placements = [] # Stores (target_row, target_col, source_rel_col)\n\n        # Calculate target positions for all relevant input movers\n        for r, c in input_M_coords:\n            rel_c = c - anc_c\n            dr, dc = 0, 0\n            valid_move = False\n\n            if rel_c == -1:\n                dr, dc = dr1_map.get(M, 0), dc1 # Default dr=0 if M unknown\n                valid_move = True\n            elif rel_c == -2:\n                dr, dc = dr2_map.get(M, 0), dc2 # Default dr=0 if M unknown\n                valid_move = True\n            elif rel_c == -3 and M == 9:\n                dr, dc = dr3, dc3\n                valid_move = True\n\n            if valid_move:\n                tr, tc = r + dr, c + dc\n                mover_placements.append((tr, tc, rel_c))\n\n        # Apply Mover Placements (overwrites anchor/static if necessary)\n        for tr, tc, src_rel_c in mover_placements:\n            if 0 <= tr < H and 0 <= tc < W:\n                out[tr, tc] = M\n                if src_rel_c == -2:\n                    flag_minus_2 = True\n\n        # Apply Conditional Generation (if triggered by a move from rel_col -2)\n        if flag_minus_2:\n            if M == 4:\n                # Place 4 at (0, anc_c)\n                if 0 <= 0 < H and 0 <= anc_c < W: out[0, anc_c] = 4\n            elif M == 8:\n                # Place 8 at (0, anc_c - 1)\n                tc_gen = anc_c - 1\n                if 0 <= 0 < H and 0 <= tc_gen < W: out[0, tc_gen] = 8\n            elif M == 9:\n                # Place 9 at (0, anc_c - 1) and (1, anc_c - 1)\n                tc_gen = anc_c - 1\n                if 0 <= 0 < H and 0 <= tc_gen < W: out[0, tc_gen] = 9\n                if 0 <= 1 < H and 0 <= tc_gen < W: out[1, tc_gen] = 9\n\n    # 10. Process RIGHT Movers (Only M=7 logic defined)\n    elif is_right_mover: # M == 7 is implied by the flag\n        preserved_mover_coord = None\n        # Find and place the preserved mover adjacent to the anchor\n        for r, c in input_M_coords:\n            if c == anc_c + 1:\n                 # Check input anchor column at the same row\n                 if 0 <= r < H and inp[r, anc_c] in anchor_vals:\n                     # Place in output if bounds are valid\n                     if 0 <= r < H and 0 <= c < W:\n                         out[r, c] = M # M is 7 here\n                         preserved_mover_coord = (r, c)\n                         break # Assume only one based on train_3\n\n        # Generate 'V' shape if preservation occurred and static props are valid\n        if preserved_mover_coord and static_props[0] != -1:\n             shape_coords = generate_v_shape(preserved_mover_coord, static_props, H, W)\n             for gr, gc in shape_coords:\n                 # Place shape points (overwriting previous values)\n                 if 0 <= gr < H and 0 <= gc < W:\n                     out[gr, gc] = M # M is 7 here\n\n    # 11. ELSE (Mixed/Unknown Mover pattern, or M != 7 on right)\n    # No action defined for these cases, grid remains as is after Static/Anchor placement.\n\n    # 12. Return final grid\n    return out.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14459,
    "candidates_token_count": 8988,
    "total_token_count": 23447,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 65.940099,
  "retries": 1
}