{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport itertools\nfrom copy import deepcopy\n\n\"\"\"\nTransforms an input grid based on two potential modes, determined by the presence of unique colors (colors appearing exactly once, excluding the background color).\n\nMode 1: Unique Colors Exist\n1. Determine fill colors:\n    - Identify unique colors (uc) and their non-background orthogonal neighbors (nc).\n    - Form candidate pairs (uc, nc or uc).\n    - 'outer_fill_color' is the value (nc or uc) from the pair with the max value, breaking ties by maximizing the associated uc.\n    - 'uc_used' is the unique color associated with the selected outer fill pair.\n    - 'inner_fill_color' is the highest remaining unique color not equal to 'uc_used', if any.\n2. Determine fill regions:\n    - Identify size-3 objects with color < 5 ('outer_bb_objects').\n    - 'BB_outer' is the minimal bounding box of 'outer_bb_objects'.\n    - If 'inner_fill_color' exists:\n        - Find the set of most frequent non-background color(s).\n        - Apply UNCERTAIN RULE: Identify 'inner_bb_objects' (subset of 'outer_bb_objects' whose color is NOT in the most frequent set).\n        - 'BB_inner' is the minimal bounding box of 'inner_bb_objects'. (WARNING: This rule is known to be incorrect/incomplete).\n3. Apply fills:\n    - Fill background cells within 'BB_outer' with 'outer_fill_color'.\n    - If 'BB_inner' exists, fill background cells within 'BB_inner' with 'inner_fill_color' (overwrites outer).\n\nMode 2: No Unique Colors Exist\n1. Group size-3 objects by their color 'C'. Sort these colors 'C'.\n2. For each color group 'C' in sorted order:\n    - Determine 'fill_color_C': max(max non-background color adjacent to any cell of color C, C itself).\n    - Apply UNCERTAIN RULE: Calculate 'BB_C': minimal bounding box for the size-3 objects of color 'C'. (WARNING: This region rule is known to be incorrect/incomplete, especially when fill color comes from a neighbor).\n    - Fill background cells within 'BB_C' with 'fill_color_C'. Later fills (higher C) overwrite earlier ones.\n\nGeneral Rules:\n- The 'background_color' is the most frequent color in the input grid.\n- Only background cells are ever filled. Original non-background cells are preserved.\n- Object finding uses orthogonal connectivity for cells of the *same* color.\n- Bounding boxes are minimal axis-aligned rectangles.\n\"\"\"\n\n# Imports\nimport collections\nfrom copy import deepcopy\n\n\n# Helper Functions\ndef get_neighbors(r, c, height, width):\n    \"\"\"Yields valid orthogonal neighbor coordinates.\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            yield nr, nc\n\ndef find_objects(grid: list[list[int]], background_color: int) -> list[dict]:\n    \"\"\"Finds connected objects of the same non-background color.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r][c]\n            # Start BFS only if cell is not background and not already visited\n            if color != background_color and (r, c) not in visited:\n                obj_locations = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_locations.add((r,c))\n\n                # BFS to find all connected cells of the same color\n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr][nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            obj_locations.add((nr, nc))\n                            \n                # Store found object\n                if obj_locations:\n                    objects.append({\n                        \"color\": color,\n                        \"locations\": list(obj_locations),\n                        \"size\": len(obj_locations)\n                    })\n    return objects\n\ndef get_color_counts(grid: list[list[int]]) -> collections.Counter:\n    \"\"\"Counts occurrences of each color in the grid.\"\"\"\n    counts = collections.Counter()\n    for row in grid:\n        counts.update(row)\n    return counts\n\ndef get_bounding_box(objects: list[dict]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the minimal bounding box for a list of objects.\"\"\"\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    has_locations = False\n\n    # Find min/max row/col across all locations in all objects\n    for obj in objects:\n        for r, c in obj['locations']:\n            has_locations = True\n            min_r = min(min_r, r)\n            min_c = min(min_c, c)\n            max_r = max(max_r, r)\n            max_c = max(max_c, c)\n\n    # Return None if no objects or locations found\n    if not has_locations:\n        return None \n\n    return min_r, min_c, max_r, max_c\n\n# Main transformation function\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # Step 2: Initialize output grid as a copy of the input\n    output_grid = deepcopy(input_grid)\n\n    # Step 1: Determine background color\n    color_counts = get_color_counts(input_grid)\n    if not color_counts: return output_grid # Handle empty grid\n    background_color = color_counts.most_common(1)[0][0]\n\n    # Step 3: Find all objects\n    all_objects = find_objects(input_grid, background_color)\n    if not all_objects: return output_grid # Handle grid with only background\n\n    # Step 4: Find unique colors (excluding background) and their locations\n    unique_colors = {}\n    non_bg_counts = {color: count for color, count in color_counts.items() if color != background_color}\n    for r in range(height):\n        for c in range(width):\n             color = input_grid[r][c]\n             if color != background_color and non_bg_counts.get(color) == 1:\n                 unique_colors[color] = (r, c) # Store color and location\n\n    # Step 5: Identify size-3 objects\n    size_3_objects = [obj for obj in all_objects if obj['size'] == 3]\n    \n    # Step 6: Mode Selection\n    if unique_colors:\n        # -------- Mode 1: Unique Colors Exist --------\n        \n        # Step 7: Determine Fill Colors\n        candidate_pairs = []\n        for uc, (r, c) in unique_colors.items():\n            candidate_pairs.append((uc, uc)) # Pair unique color with itself\n            # Check neighbors for non-background, non-uc colors\n            for nr, nc in get_neighbors(r, c, height, width):\n                neighbor_color = input_grid[nr][nc]\n                if neighbor_color != background_color and neighbor_color != uc:\n                     candidate_pairs.append((uc, neighbor_color)) # Pair uc with neighbor\n                     \n        if not candidate_pairs:\n             # This case should not be reachable if unique_colors is non-empty\n             return output_grid \n\n        # Find the best pair: sort by value (desc), then by unique color (desc)\n        candidate_pairs.sort(key=lambda pair: (pair[1], pair[0]), reverse=True)\n        uc_used, outer_fill_color = candidate_pairs[0]\n\n        # Determine inner fill color: highest unique color not used for outer fill\n        remaining_unique_colors = {uc for uc in unique_colors if uc != uc_used}\n        inner_fill_color = max(remaining_unique_colors) if remaining_unique_colors else None\n\n        # Step 8: Outer Fill\n        # Select objects for outer bounding box (size=3, color<5)\n        outer_bb_objects = [obj for obj in size_3_objects if obj['color'] < 5]\n\n        if outer_bb_objects: # Proceed only if objects are found\n            # Calculate outer bounding box\n            bb_outer = get_bounding_box(outer_bb_objects)\n            if bb_outer: # Proceed only if BB is valid\n                min_r_outer, min_c_outer, max_r_outer, max_c_outer = bb_outer\n\n                # Apply Outer Fill to background cells within the box\n                for r in range(min_r_outer, max_r_outer + 1):\n                    for c in range(min_c_outer, max_c_outer + 1):\n                        if input_grid[r][c] == background_color:\n                            output_grid[r][c] = outer_fill_color\n\n        # Step 9: Inner Fill Condition\n        if inner_fill_color is not None:\n            # Step 10: Determine Inner BB Objects (UNCERTAIN RULE)\n            # Find the set of most frequent non-background colors\n            most_frequent_set = set()\n            if non_bg_counts:\n                 max_freq = 0\n                 # Find the maximum frequency among non-background colors\n                 for count in non_bg_counts.values():\n                      max_freq = max(max_freq, count)\n                 # Collect all colors that have this maximum frequency\n                 most_frequent_set = {color for color, count in non_bg_counts.items() if count == max_freq}\n\n            # WARNING: This rule for selecting inner_bb_objects is known to be flawed.\n            # Select objects from outer set whose color is NOT in the most frequent set\n            inner_bb_objects = [obj for obj in outer_bb_objects if obj['color'] not in most_frequent_set]\n            \n            # Step 11: Inner Fill Execution\n            if inner_bb_objects: # Proceed only if the filtering yielded objects\n                bb_inner = get_bounding_box(inner_bb_objects)\n                if bb_inner: # Proceed only if a valid inner bounding box exists\n                    min_r_inner, min_c_inner, max_r_inner, max_c_inner = bb_inner\n                    # Apply Inner Fill to background cells, overwriting outer fill\n                    for r in range(min_r_inner, max_r_inner + 1):\n                        for c in range(min_c_inner, max_c_inner + 1):\n                            if input_grid[r][c] == background_color:\n                                output_grid[r][c] = inner_fill_color # Overwrite\n        \n        # Step 12: (Implicit) Proceed to return\n\n    else:\n        # -------- Mode 2: No Unique Colors Exist --------\n        \n        # Step 13: Process per Color Group\n        # Get distinct colors found in size-3 objects, sort them\n        colors_in_size_3 = sorted(list({obj['color'] for obj in size_3_objects}))\n\n        # Process each color group C\n        for color_c in colors_in_size_3:\n            # Determine Fill Color for C\n            max_adjacent_color = -1\n            cells_of_color_c = []\n            group_c_objects = []\n            # Collect all size-3 objects of color C and their cell locations\n            for obj in size_3_objects:\n                if obj['color'] == color_c:\n                    group_c_objects.append(obj)\n                    cells_of_color_c.extend(obj['locations'])\n            \n            if not group_c_objects: continue # Skip if no objects found for this color (safety check)\n\n            # Find the highest non-background neighbor color different from C\n            for r, c in cells_of_color_c:\n                 for nr, nc in get_neighbors(r, c, height, width):\n                     neighbor_color = input_grid[nr][nc]\n                     if neighbor_color != background_color and neighbor_color != color_c:\n                         max_adjacent_color = max(max_adjacent_color, neighbor_color)\n\n            # Fill color is the max of the highest adjacent neighbor (if any > -1) and C itself\n            fill_color_c = max(max_adjacent_color, color_c) \n\n            # Determine Fill Region for C (UNCERTAIN RULE)\n            # WARNING: This bounding box rule is known to be flawed for some cases in Mode 2 (e.g., E4, C=6).\n            bb_c = get_bounding_box(group_c_objects)\n            if bb_c is None: continue # Skip if no bounding box could be determined\n\n            min_r_c, min_c_c, max_r_c, max_c_c = bb_c\n\n            # Execute Fill for C - fill background cells in BB_C\n            for r in range(min_r_c, max_r_c + 1):\n                for c in range(min_c_c, max_c_c + 1):\n                    if input_grid[r][c] == background_color:\n                        # Overwrite based on processing order (sorted colors C)\n                        output_grid[r][c] = fill_color_c\n        \n        # Step 14: (Implicit) Proceed to return\n\n    # Step 15: Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 53726,
    "candidates_token_count": 3847,
    "total_token_count": 57573,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.249827,
  "retries": 1
}