{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport itertools\nfrom copy import deepcopy\n\n\"\"\"\nTransforms an input grid based on two potential modes, determined by the presence of unique colors (colors appearing exactly once).\n\nMode 1: Unique Colors Exist\n1. Identify unique colors and their non-background orthogonal neighbors.\n2. Determine 'outer_fill_color' based on the highest value among unique colors and their neighbors, prioritizing pairs with higher unique colors in case of ties.\n3. Determine 'inner_fill_color' (if applicable) as the highest remaining unique color.\n4. Identify size-3 objects with color < 5 ('outer_bb_objects').\n5. Calculate the bounding box ('BB_outer') for these objects.\n6. Fill background cells within 'BB_outer' with 'outer_fill_color'.\n7. If 'inner_fill_color' exists and there's a single most frequent non-background color:\n    a. Identify 'inner_bb_objects' (subset of 'outer_bb_objects' whose color is not the most frequent non-background color).\n    b. Calculate the bounding box ('BB_inner') for these objects.\n    c. Fill background cells within 'BB_inner' with 'inner_fill_color', overwriting the outer fill.\n\nMode 2: No Unique Colors Exist\n1. Group size-3 objects by their color 'C'.\n2. For each color group 'C':\n    a. Determine 'fill_color_C' as the maximum non-background color adjacent to any cell of color 'C', or 'C' itself if no different neighbors exist.\n    b. Calculate the bounding box ('BB_C') for the size-3 objects of color 'C'.\n    c. Fill background cells within 'BB_C' with 'fill_color_C'. (Overwrites follow processing order).\n\nGeneral Rules:\n- The 'background_color' is the most frequent color in the input grid.\n- Only background cells are ever filled. Original non-background cells are preserved.\n- Object finding considers orthogonal connectivity.\n- Bounding boxes are minimal axis-aligned rectangles enclosing the specified objects.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Yields valid orthogonal neighbor coordinates.\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            yield nr, nc\n\ndef find_objects(grid: list[list[int]], background_color: int) -> list[dict]:\n    \"\"\"Finds connected objects of non-background colors.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] != background_color and (r, c) not in visited:\n                obj_color = grid[r][c]\n                obj_locations = set()\n                is_single_color = True\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_locations.add((r,c))\n                colors_in_obj = {obj_color}\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check neighbors\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        neighbor_color = grid[nr][nc]\n                        if neighbor_color != background_color and (nr, nc) not in visited:\n                            # For this problem, assume objects are single-colored unless logic needs otherwise\n                            # If objects can be multi-colored, need adjustment here\n                            if neighbor_color == obj_color:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                                obj_locations.add((nr,nc))\n                            # Handle case where adjacent cells have different non-background colors if needed by future tasks\n                            # For now, we assume objects are defined by connectivity of the *same* non-bg color.\n                            # If the problem implies multi-color objects based on adjacency, this needs revision.\n                            # Based on examples, seems like objects are mono-colored.\n                            \n                # Store the object if it has locations\n                if obj_locations:\n                    objects.append({\n                        \"color\": obj_color, # Assumes mono-colored object based on initial cell\n                        \"locations\": list(obj_locations),\n                        \"size\": len(obj_locations)\n                    })\n    return objects\n\n\ndef get_color_counts(grid: list[list[int]]) -> collections.Counter:\n    \"\"\"Counts occurrences of each color in the grid.\"\"\"\n    counts = collections.Counter()\n    for row in grid:\n        counts.update(row)\n    return counts\n\ndef get_bounding_box(objects: list[dict]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the minimal bounding box for a list of objects.\"\"\"\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    has_locations = False\n\n    for obj in objects:\n        for r, c in obj['locations']:\n            has_locations = True\n            min_r = min(min_r, r)\n            min_c = min(min_c, c)\n            max_r = max(max_r, r)\n            max_c = max(max_c, c)\n\n    if not has_locations:\n        return None # No objects, no bounding box\n\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    height = len(input_grid)\n    width = len(input_grid[0])\n    output_grid = deepcopy(input_grid)\n\n    # 1. Determine background color\n    color_counts = get_color_counts(input_grid)\n    if not color_counts: return output_grid # Empty grid\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Find all objects\n    all_objects = find_objects(input_grid, background_color)\n    if not all_objects: return output_grid # No objects\n\n    # 3. Find unique colors and their locations\n    unique_colors = {}\n    non_bg_counts = {color: count for color, count in color_counts.items() if color != background_color}\n    for r in range(height):\n        for c in range(width):\n             color = input_grid[r][c]\n             if color != background_color and non_bg_counts.get(color) == 1:\n                 unique_colors[color] = (r, c) # Store location too\n\n    # 4. Identify size-3 objects\n    size_3_objects = [obj for obj in all_objects if obj['size'] == 3]\n    \n    # 5. Mode Selection\n    if unique_colors:\n        # -------- Mode 1: Unique Colors Exist --------\n        \n        # 7. Determine Fill Colors\n        candidate_pairs = []\n        for uc, (r, c) in unique_colors.items():\n            candidate_pairs.append((uc, uc)) # Pair with itself\n            for nr, nc in get_neighbors(r, c, height, width):\n                neighbor_color = input_grid[nr][nc]\n                if neighbor_color != background_color and neighbor_color != uc:\n                     # Ensure the unique color 'uc' is first element for tie-breaking\n                     candidate_pairs.append((uc, neighbor_color))\n                     \n        if not candidate_pairs:\n             # Fallback: if unique colors only neighbor background, maybe just use highest unique?\n             # Based on logic, should always have at least (uc, uc) pairs if unique_colors exists.\n             # If truly no pairs (e.g. if definition changes), return original.\n             return output_grid \n\n        # Find the best pair: max value, tie-break with max uc\n        candidate_pairs.sort(key=lambda pair: (pair[1], pair[0]), reverse=True)\n        uc_used, outer_fill_color = candidate_pairs[0]\n\n        remaining_unique_colors = {uc for uc in unique_colors if uc != uc_used}\n        inner_fill_color = max(remaining_unique_colors) if remaining_unique_colors else None\n\n        # 8. Determine Fill Regions & Execute Fill\n        outer_bb_objects = [obj for obj in size_3_objects if obj['color'] < 5]\n\n        if not outer_bb_objects:\n            return output_grid # No objects to define outer region\n\n        bb_outer = get_bounding_box(outer_bb_objects)\n        if bb_outer is None: return output_grid\n\n        min_r_outer, min_c_outer, max_r_outer, max_c_outer = bb_outer\n\n        # (Outer Fill)\n        for r in range(min_r_outer, max_r_outer + 1):\n            for c in range(min_c_outer, max_c_outer + 1):\n                if input_grid[r][c] == background_color:\n                    output_grid[r][c] = outer_fill_color\n\n        # (Inner Fill Condition & Execution)\n        if inner_fill_color is not None:\n            # Find single most frequent non-background color\n            most_frequent_non_bg = None\n            if non_bg_counts:\n                 sorted_non_bg = sorted(non_bg_counts.items(), key=lambda item: item[1], reverse=True)\n                 if len(sorted_non_bg) == 1 or sorted_non_bg[0][1] > sorted_non_bg[1][1]:\n                      most_frequent_non_bg = sorted_non_bg[0][0]\n\n            if most_frequent_non_bg is not None:\n                inner_bb_objects = [obj for obj in outer_bb_objects if obj['color'] != most_frequent_non_bg]\n\n                if inner_bb_objects:\n                    bb_inner = get_bounding_box(inner_bb_objects)\n                    if bb_inner:\n                        min_r_inner, min_c_inner, max_r_inner, max_c_inner = bb_inner\n                        # (Inner Fill Execution)\n                        for r in range(min_r_inner, max_r_inner + 1):\n                            for c in range(min_c_inner, max_c_inner + 1):\n                                if input_grid[r][c] == background_color:\n                                    output_grid[r][c] = inner_fill_color # Overwrite\n                                    \n    else:\n        # -------- Mode 2: No Unique Colors Exist --------\n        \n        # 9. Process per Color Group\n        colors_in_size_3 = sorted(list({obj['color'] for obj in size_3_objects}))\n\n        for color_c in colors_in_size_3:\n            # Determine Fill Color for C\n            max_adjacent_color = -1\n            cells_of_color_c = []\n            group_c_objects = []\n            for obj in size_3_objects:\n                if obj['color'] == color_c:\n                    group_c_objects.append(obj)\n                    cells_of_color_c.extend(obj['locations'])\n            \n            if not group_c_objects: continue # Should not happen if color_c came from the set\n\n            for r, c in cells_of_color_c:\n                 for nr, nc in get_neighbors(r, c, height, width):\n                     neighbor_color = input_grid[nr][nc]\n                     if neighbor_color != background_color and neighbor_color != color_c:\n                         max_adjacent_color = max(max_adjacent_color, neighbor_color)\n\n            fill_color_c = max_adjacent_color if max_adjacent_color > -1 else color_c\n\n            # Determine Fill Region for C\n            bb_c = get_bounding_box(group_c_objects)\n            if bb_c is None: continue\n\n            min_r_c, min_c_c, max_r_c, max_c_c = bb_c\n\n            # Execute Fill for C\n            for r in range(min_r_c, max_r_c + 1):\n                for c in range(min_c_c, max_c_c + 1):\n                    if input_grid[r][c] == background_color:\n                         # Overwrite based on processing order (sorted colors)\n                        output_grid[r][c] = fill_color_c\n\n    # 11. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10692,
    "candidates_token_count": 3772,
    "total_token_count": 14464,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 29.548546,
  "retries": 1
}