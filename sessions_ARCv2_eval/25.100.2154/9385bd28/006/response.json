{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport itertools\nfrom copy import deepcopy\n\n\"\"\"\nTransforms an input grid based on two potential modes, determined by the presence of unique colors (colors appearing exactly once, excluding the background color).\n\nMode 1: Unique Colors Exist\n1. Determine fill colors:\n    - Identify unique colors (uc) and their non-background orthogonal neighbors (nc).\n    - Form candidate pairs (uc, nc or uc).\n    - 'outer_fill_color' is the value (nc or uc) from the pair with the max value, breaking ties by maximizing the associated uc.\n    - 'uc_used' is the unique color associated with the selected outer fill pair.\n    - 'inner_fill_color' is the highest remaining unique color not equal to 'uc_used', if any.\n2. Determine fill regions:\n    - Identify size-3 objects with color < 5 ('outer_bb_objects').\n    - 'BB_outer' is the minimal bounding box of 'outer_bb_objects'.\n    - If 'inner_fill_color' exists:\n        - Find the set of most frequent non-background color(s).\n        - Identify 'inner_bb_objects' (subset of 'outer_bb_objects' whose color is NOT in the most frequent set).\n        - 'BB_inner' is the minimal bounding box of 'inner_bb_objects'. (High uncertainty about this rule).\n3. Apply fills:\n    - Fill background cells within 'BB_outer' with 'outer_fill_color'.\n    - If 'BB_inner' exists, fill background cells within 'BB_inner' with 'inner_fill_color' (overwrites outer).\n\nMode 2: No Unique Colors Exist (High Uncertainty)\n1. Group size-3 objects by their color 'C'. Sort these colors 'C'.\n2. For each color group 'C' in sorted order:\n    - Determine 'fill_color_C': max(max non-background color adjacent to any cell of color C, C itself).\n    - Calculate 'BB_C': minimal bounding box for the size-3 objects of color 'C'. (Region rule is likely incorrect).\n    - Fill background cells within 'BB_C' with 'fill_color_C'. Later fills (higher C) overwrite earlier ones.\n\nGeneral Rules:\n- The 'background_color' is the most frequent color in the input grid.\n- Only background cells are ever filled. Original non-background cells are preserved.\n- Object finding uses orthogonal connectivity for cells of the *same* color.\n- Bounding boxes are minimal axis-aligned rectangles.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Yields valid orthogonal neighbor coordinates.\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            yield nr, nc\n\ndef find_objects(grid: list[list[int]], background_color: int) -> list[dict]:\n    \"\"\"Finds connected objects of the same non-background color.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r][c]\n            if color != background_color and (r, c) not in visited:\n                obj_locations = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_locations.add((r,c))\n\n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr][nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            obj_locations.add((nr, nc))\n                            \n                if obj_locations:\n                    objects.append({\n                        \"color\": color,\n                        \"locations\": list(obj_locations),\n                        \"size\": len(obj_locations)\n                    })\n    return objects\n\ndef get_color_counts(grid: list[list[int]]) -> collections.Counter:\n    \"\"\"Counts occurrences of each color in the grid.\"\"\"\n    counts = collections.Counter()\n    for row in grid:\n        counts.update(row)\n    return counts\n\ndef get_bounding_box(objects: list[dict]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the minimal bounding box for a list of objects.\"\"\"\n    min_r, min_c = float('inf'), float('inf')\n    max_r, max_c = float('-inf'), float('-inf')\n    has_locations = False\n\n    for obj in objects:\n        for r, c in obj['locations']:\n            has_locations = True\n            min_r = min(min_r, r)\n            min_c = min(min_c, c)\n            max_r = max(max_r, r)\n            max_c = max(max_c, c)\n\n    if not has_locations:\n        return None \n\n    return min_r, min_c, max_r, max_c\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    height = len(input_grid)\n    width = len(input_grid[0])\n    output_grid = deepcopy(input_grid)\n\n    # 1. Determine background color\n    color_counts = get_color_counts(input_grid)\n    if not color_counts: return output_grid\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Find all objects\n    all_objects = find_objects(input_grid, background_color)\n    if not all_objects: return output_grid\n\n    # 3. Find unique colors (excluding background) and their locations\n    unique_colors = {}\n    non_bg_counts = {color: count for color, count in color_counts.items() if color != background_color}\n    for r in range(height):\n        for c in range(width):\n             color = input_grid[r][c]\n             if color != background_color and non_bg_counts.get(color) == 1:\n                 unique_colors[color] = (r, c) \n\n    # 4. Identify size-3 objects\n    size_3_objects = [obj for obj in all_objects if obj['size'] == 3]\n    \n    # 5. Mode Selection\n    if unique_colors:\n        # -------- Mode 1: Unique Colors Exist --------\n        \n        # 7. Determine Fill Colors\n        candidate_pairs = []\n        for uc, (r, c) in unique_colors.items():\n            candidate_pairs.append((uc, uc)) # Pair with itself\n            for nr, nc in get_neighbors(r, c, height, width):\n                neighbor_color = input_grid[nr][nc]\n                if neighbor_color != background_color and neighbor_color != uc:\n                     candidate_pairs.append((uc, neighbor_color))\n                     \n        if not candidate_pairs:\n             return output_grid # Should not happen if unique_colors is non-empty\n\n        # Find the best pair: max value, tie-break with max uc\n        candidate_pairs.sort(key=lambda pair: (pair[1], pair[0]), reverse=True)\n        uc_used, outer_fill_color = candidate_pairs[0]\n\n        # Determine inner fill color\n        remaining_unique_colors = {uc for uc in unique_colors if uc != uc_used}\n        inner_fill_color = max(remaining_unique_colors) if remaining_unique_colors else None\n\n        # 8. Outer Fill\n        outer_bb_objects = [obj for obj in size_3_objects if obj['color'] < 5]\n\n        if not outer_bb_objects:\n            return output_grid # No objects to define outer region\n\n        bb_outer = get_bounding_box(outer_bb_objects)\n        if bb_outer is None: return output_grid\n\n        min_r_outer, min_c_outer, max_r_outer, max_c_outer = bb_outer\n\n        # Apply Outer Fill\n        for r in range(min_r_outer, max_r_outer + 1):\n            for c in range(min_c_outer, max_c_outer + 1):\n                if input_grid[r][c] == background_color:\n                    output_grid[r][c] = outer_fill_color\n\n        # 9. Inner Fill Condition\n        if inner_fill_color is not None:\n            # 10. Determine Inner BB Objects (High Uncertainty)\n            most_frequent_set = set()\n            if non_bg_counts:\n                 max_freq = 0\n                 for color, count in non_bg_counts.items():\n                      max_freq = max(max_freq, count)\n                 most_frequent_set = {color for color, count in non_bg_counts.items() if count == max_freq}\n\n            inner_bb_objects = [obj for obj in outer_bb_objects if obj['color'] not in most_frequent_set]\n            \n            # Fallback (speculative, maybe not needed or correct)\n            # if not inner_bb_objects and outer_bb_objects:\n            #     inner_bb_objects = outer_bb_objects \n\n            # 11. Inner Fill Execution\n            if inner_bb_objects:\n                bb_inner = get_bounding_box(inner_bb_objects)\n                if bb_inner:\n                    min_r_inner, min_c_inner, max_r_inner, max_c_inner = bb_inner\n                    # Apply Inner Fill\n                    for r in range(min_r_inner, max_r_inner + 1):\n                        for c in range(min_c_inner, max_c_inner + 1):\n                            if input_grid[r][c] == background_color:\n                                output_grid[r][c] = inner_fill_color # Overwrite\n                                    \n    else:\n        # -------- Mode 2: No Unique Colors Exist (High Uncertainty) --------\n        \n        # 13. Process per Color Group\n        colors_in_size_3 = sorted(list({obj['color'] for obj in size_3_objects}))\n\n        for color_c in colors_in_size_3:\n            # Determine Fill Color for C\n            max_adjacent_color = -1\n            cells_of_color_c = []\n            group_c_objects = []\n            for obj in size_3_objects:\n                if obj['color'] == color_c:\n                    group_c_objects.append(obj)\n                    cells_of_color_c.extend(obj['locations'])\n            \n            if not group_c_objects: continue # Should not happen\n\n            for r, c in cells_of_color_c:\n                 for nr, nc in get_neighbors(r, c, height, width):\n                     neighbor_color = input_grid[nr][nc]\n                     if neighbor_color != background_color and neighbor_color != color_c:\n                         max_adjacent_color = max(max_adjacent_color, neighbor_color)\n\n            fill_color_c = max(max_adjacent_color, color_c) # Use neighbor if found and higher, else C\n\n            # Determine Fill Region for C (Likely incorrect rule for E4)\n            bb_c = get_bounding_box(group_c_objects)\n            if bb_c is None: continue\n\n            min_r_c, min_c_c, max_r_c, max_c_c = bb_c\n\n            # Execute Fill for C\n            for r in range(min_r_c, max_r_c + 1):\n                for c in range(min_c_c, max_c_c + 1):\n                    if input_grid[r][c] == background_color:\n                        # Overwrite based on processing order (sorted colors C)\n                        output_grid[r][c] = fill_color_c\n\n    # 15. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24891,
    "candidates_token_count": 3586,
    "total_token_count": 28477,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.311645,
  "retries": 1
}