{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport math\n\n\"\"\"\nTransforms a sparse 20x20 input grid containing four distinct digit clusters into a smaller, dense output grid.\n\nThe transformation involves:\n1.  Identifying the four non-zero digit clusters in the input grid.\n2.  Calculating properties for each cluster: bounding box, dimensions (H, W), center, dominant digit, and presence of the digit 5.\n3.  Determining the size 'N' for subgrids based on the minimum of the maximum dimensions (H or W) of the four clusters.\n4.  Assigning roles (Top-Left, Top-Right, Bottom-Left, Bottom-Right) to the clusters based on their center coordinates.\n5.  Selecting an assembly rule (A or B) based on the vertical alignment of the Top-Left and Top-Right role clusters. Rule B involves swapping the placement of the top two clusters and rotating the one originally in the Top-Right role (which ends up in the top-left output quadrant).\n6.  Extracting the top-left NxN subgrid from each cluster's bounding box.\n7.  Assembling a 2N x 2N output grid by placing the extracted (and potentially rotated) subgrids according to the selected assembly rule.\n8.  Filling any zero cells within each quadrant of the assembled grid with the dominant digit of the cluster that *sourced* that quadrant.\n9.  Applying specific modifications, including:\n    - Setting the top-left cell (0,0) to 5 if any input cluster contained the digit 5.\n    - Overwriting specific cells near the internal boundaries based on N and the dominant digits of the original role clusters. (Note: The exact boundary interaction rules derived from examples N=3 and N=5 might not perfectly generalize to all N, particularly N=2, suggesting a more complex underlying mechanism not fully captured yet).\n\"\"\"\n\ndef find_clusters(grid: list[list[int]]) -> list[dict]:\n    \"\"\"\n    Finds connected components of non-zero digits in the grid.\n\n    Args:\n        grid: The input grid (list of lists of ints).\n\n    Returns:\n        A list of cluster dictionaries, each containing:\n        'coords': set of (row, col) tuples.\n        'bbox': (min_r, min_c, max_r, max_c) tuple.\n        'H': Height of the bounding box.\n        'W': Width of the bounding box.\n        'center': (center_r, center_c) tuple.\n        'dominant_digit': The most frequent non-zero digit.\n        'contains_5': Boolean indicating if 5 is present.\n        'digits': List of all non-zero digits in the cluster.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    clusters = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                component_coords = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                component_coords.add((r,c))\n                all_digits_in_component = []\n\n                while q:\n                    row, col = q.popleft()\n                    all_digits_in_component.append(grid[row][col])\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            component_coords.add((nr, nc))\n                            q.append((nr, nc))\n\n                if component_coords:\n                    # Calculate properties\n                    min_r = min(r for r, c in component_coords)\n                    min_c = min(c for r, c in component_coords)\n                    max_r = max(r for r, c in component_coords)\n                    max_c = max(c for r, c in component_coords)\n                    bbox = (min_r, min_c, max_r, max_c)\n                    H = max_r - min_r + 1\n                    W = max_c - min_c + 1\n                    center = (min_r + (H - 1) / 2, min_c + (W - 1) / 2)\n\n                    non_zero_digits = [d for d in all_digits_in_component if d != 0]\n                    if not non_zero_digits: continue # Should not happen based on finding logic\n\n                    dominant_digit = collections.Counter(non_zero_digits).most_common(1)[0][0]\n                    contains_5 = 5 in non_zero_digits\n\n                    clusters.append({\n                        'coords': component_coords,\n                        'bbox': bbox,\n                        'H': H,\n                        'W': W,\n                        'center': center,\n                        'dominant_digit': dominant_digit,\n                        'contains_5': contains_5,\n                        'digits': non_zero_digits # Store all non-zero digits\n                    })\n    # Sort clusters top-to-bottom, then left-to-right by center for consistent role assignment\n    clusters.sort(key=lambda c: (c['center'][0], c['center'][1]))\n    return clusters\n\ndef extract_subgrid(grid: list[list[int]], bbox: tuple[int, int, int, int], N: int) -> list[list[int]]:\n    \"\"\"Extracts the top-left NxN subgrid relative to the bounding box.\"\"\"\n    min_r, min_c, _, _ = bbox\n    subgrid = [[0] * N for _ in range(N)]\n    grid_rows = len(grid)\n    grid_cols = len(grid[0])\n    for r in range(N):\n        for c in range(N):\n            source_r, source_c = min_r + r, min_c + c\n            if 0 <= source_r < grid_rows and 0 <= source_c < grid_cols:\n                subgrid[r][c] = grid[source_r][source_c]\n            # else: keep 0 (or handle out-of-bounds if needed, though unlikely here)\n    return subgrid\n\ndef rotate_grid_270_cw(grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Rotates a grid 270 degrees clockwise (or 90 degrees counter-clockwise).\"\"\"\n    if not grid:\n        return []\n    rows = len(grid)\n    cols = len(grid[0])\n    new_grid = [[0] * rows for _ in range(cols)]\n    for r in range(rows):\n        for c in range(cols):\n            new_grid[cols - 1 - c][r] = grid[r][c]\n    return new_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Performs the grid transformation based on identified clusters.\n    \"\"\"\n    # 1. Identify Clusters and Properties\n    clusters = find_clusters(input_grid)\n    if len(clusters) != 4:\n        # Handle error: expected 4 clusters\n        print(f\"Warning: Found {len(clusters)} clusters, expected 4.\")\n        # Depending on requirements, might return empty, input, or raise error\n        # For now, proceed if possible, but results might be wrong\n        if len(clusters) == 0: return []\n\n\n    # 2. Determine Subgrid Size N\n    max_dims = [max(c['H'], c['W']) for c in clusters]\n    N = min(max_dims) if max_dims else 0 # Handle case with no clusters found\n    if N == 0: return [] # Cannot proceed without N\n\n    # 3. Assign Cluster Roles\n    # Sort by center Y, then center X\n    clusters.sort(key=lambda c: (c['center'][0], c['center'][1]))\n    top_clusters = sorted(clusters[:2], key=lambda c: c['center'][1])\n    bottom_clusters = sorted(clusters[2:], key=lambda c: c['center'][1])\n\n    role_map = {}\n    role_map['TL_Cluster'] = top_clusters[0]\n    role_map['TR_Cluster'] = top_clusters[1]\n    role_map['BL_Cluster'] = bottom_clusters[0]\n    role_map['BR_Cluster'] = bottom_clusters[1]\n\n    D_TL = role_map['TL_Cluster']['dominant_digit']\n    D_TR = role_map['TR_Cluster']['dominant_digit']\n    D_BL = role_map['BL_Cluster']['dominant_digit']\n    D_BR = role_map['BR_Cluster']['dominant_digit']\n\n    # 4. Select Assembly Rule and Rotation\n    minY_TL = role_map['TL_Cluster']['bbox'][0]\n    minY_TR = role_map['TR_Cluster']['bbox'][0]\n\n    assembly_rule_B = (minY_TL == minY_TR)\n    rotation_needed = assembly_rule_B\n\n    # 5. Extract and Transform Subgrids\n    subgrids = {}\n    for role, cluster in role_map.items():\n        subgrids[role] = extract_subgrid(input_grid, cluster['bbox'], N)\n\n    transformed_subgrid_for_TL_output = None\n    if rotation_needed:\n        # Rotate the subgrid from the TR-role cluster\n        transformed_subgrid_for_TL_output = rotate_grid_270_cw(subgrids['TR_Cluster'])\n    else:\n        # Use the subgrid from the TL-role cluster directly\n        transformed_subgrid_for_TL_output = subgrids['TL_Cluster']\n\n    # Determine which subgrid goes to TR output based on rule\n    subgrid_for_TR_output = subgrids['TL_Cluster'] if assembly_rule_B else subgrids['TR_Cluster']\n    subgrid_for_BL_output = subgrids['BL_Cluster']\n    subgrid_for_BR_output = subgrids['BR_Cluster']\n\n    # Determine source dominant digits for filling, based on the assembly rule\n    fill_digit = {}\n    if assembly_rule_B:\n        fill_digit['TL'] = D_TR # TR Cluster went to TL output\n        fill_digit['TR'] = D_TL # TL Cluster went to TR output\n    else:\n        fill_digit['TL'] = D_TL # TL Cluster went to TL output\n        fill_digit['TR'] = D_TR # TR Cluster went to TR output\n    fill_digit['BL'] = D_BL # BL Cluster went to BL output\n    fill_digit['BR'] = D_BR # BR Cluster went to BR output\n\n\n    # 6. Assemble Initial Output Grid\n    output_size = 2 * N\n    output_grid = [[0] * output_size for _ in range(output_size)]\n\n    # Place TL output\n    for r in range(N):\n        for c in range(N):\n            output_grid[r][c] = transformed_subgrid_for_TL_output[r][c]\n    # Place TR output\n    for r in range(N):\n        for c in range(N):\n            output_grid[r][N + c] = subgrid_for_TR_output[r][c]\n    # Place BL output\n    for r in range(N):\n        for c in range(N):\n            output_grid[N + r][c] = subgrid_for_BL_output[r][c]\n    # Place BR output\n    for r in range(N):\n        for c in range(N):\n            output_grid[N + r][N + c] = subgrid_for_BR_output[r][c]\n\n    # 7. Fill Zeroes\n    for r in range(output_size):\n        for c in range(output_size):\n            if output_grid[r][c] == 0: # Only fill original zeroes from subgrids\n                if r < N and c < N: # TL Quadrant\n                    output_grid[r][c] = fill_digit['TL']\n                elif r < N and c >= N: # TR Quadrant\n                    output_grid[r][c] = fill_digit['TR']\n                elif r >= N and c < N: # BL Quadrant\n                    output_grid[r][c] = fill_digit['BL']\n                else: # BR Quadrant\n                    output_grid[r][c] = fill_digit['BR']\n\n    # 8. Apply Boundary Interaction/Modification\n    # Rule 1: Check for '5' in any input cluster\n    any_cluster_has_5 = any(c['contains_5'] for c in clusters)\n    if any_cluster_has_5:\n        if output_size > 0: # Ensure grid is not empty\n             output_grid[0][0] = 5\n\n    # Rule 2: Specific boundary overrides (based on N=3, N=5 observations)\n    # Note: These might not be entirely correct, especially for N=2 as seen in train_3\n    if N > 0: # Check N to avoid index errors if N=0\n        k = N // 2 # Integer division for center index approximation\n\n        # Check boundaries before attempting access\n        if N - 1 < output_size and k < output_size:\n            output_grid[N - 1][k] = D_BL\n        if k < output_size and N < output_size:\n            output_grid[k][N] = D_TL\n        if N - 1 < output_size and N + k < output_size:\n            output_grid[N - 1][N + k] = D_BR\n\n        # Need to be careful with indices N+k\n        if N + k < output_size:\n            if 0 < output_size: # Check col 0 exists\n                output_grid[N + k][0] = D_BL\n            if 1 < output_size: # Check col 1 exists\n                 output_grid[N + k][1] = D_BL\n\n        # Conditional override (observed for N=5, maybe related to k>1 or N>=5?)\n        if N >= 5: # Or maybe k >= 2? Testing N>=5\n             if N - 2 >= 0 and N + k < output_size:\n                  output_grid[N - 2][N + k] = D_BR\n        \n        # --- Placeholder for more complex boundary logic ---\n        # The overrides above work for train_1 (N=3) and train_2 (N=5),\n        # but fail to produce the correct output for train_3 (N=2).\n        # This suggests the true boundary interaction rule is more complex\n        # than these fixed point overrides or depends differently on N.\n        # Further analysis of N=2 examples or other examples is needed\n        # to generalize this step accurately.\n        # For example, in train_3 (N=2), output[1,1] becomes 8 (D_TR) and output[2,2] becomes 2 (D_TL).\n        # This might involve copying from diagonal quadrants or a different rule set for small N.\n\n\n    # 9. Final Output\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10691,
    "candidates_token_count": 4560,
    "total_token_count": 15251,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 33.068821,
  "retries": 1
}