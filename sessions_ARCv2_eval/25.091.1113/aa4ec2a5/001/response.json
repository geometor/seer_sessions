{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis transformation rule processes a grid containing a background color (yellow, 4) and one or more shapes made of blue pixels (1).\n\nThe rule performs the following steps:\n1. Initialize the output grid as a copy of the input grid.\n2. Identify all distinct contiguous regions (shapes) of blue pixels in the input grid.\n3. For each identified blue shape:\n    a. Find all yellow pixels immediately adjacent (including diagonals) to the blue shape. Change these pixels to red (2) in the output grid, forming a border.\n    b. Determine if the original blue shape encloses any regions of yellow pixels (holes). This is done by finding all yellow pixels not reachable from the grid's outer border.\n    c. If the shape encloses holes:\n        i. Change all pixels corresponding to the original blue shape to azure (8) in the output grid.\n        ii. Change all yellow pixels determined to be within holes enclosed by this shape to magenta (6) in the output grid.\n    d. If the shape does not enclose any holes:\n        i. Leave the pixels corresponding to the original blue shape as blue (1) in the output grid.\n4. Yellow pixels that are part of the exterior background and are not turned into border pixels remain yellow (4).\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets valid neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if connectivity == 4 and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_connected_components(grid, target_color):\n    \"\"\"Finds all connected components of a specific color.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n    pixel_to_component_id = {}\n    component_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_id = component_id_counter\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n                    pixel_to_component_id[(curr_r, curr_c)] = component_id\n                    \n                    # Use 4-connectivity for finding components of the same color\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=4):\n                        if grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component_coords:\n                    components.append(component_coords)\n                    component_id_counter += 1\n                    \n    return components, pixel_to_component_id\n\ndef find_exterior_pixels(grid, background_color):\n    \"\"\"Finds all background pixels reachable from the border.\"\"\"\n    height, width = grid.shape\n    exterior_pixels = set()\n    q = deque()\n    visited_flood = np.zeros_like(grid, dtype=bool)\n\n    # Add border background pixels to the queue\n    for r in range(height):\n        for c in [0, width - 1]:\n            if grid[r, c] == background_color and not visited_flood[r,c]:\n                q.append((r, c))\n                visited_flood[r,c] = True\n                exterior_pixels.add((r, c))\n    for c in range(width):\n        for r in [0, height - 1]:\n             if grid[r, c] == background_color and not visited_flood[r,c]:\n                q.append((r, c))\n                visited_flood[r,c] = True\n                exterior_pixels.add((r, c))\n\n    # Flood fill from the border\n    while q:\n        curr_r, curr_c = q.popleft()\n        # Use 4-connectivity for flood fill within background\n        for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=4):\n            if grid[nr, nc] == background_color and not visited_flood[nr, nc]:\n                visited_flood[nr, nc] = True\n                exterior_pixels.add((nr, nc))\n                q.append((nr, nc))\n                \n    return exterior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on bordering and filling blue shapes.\n    Holes within shapes are filled with magenta, and the shape itself becomes azure.\n    Solid shapes remain blue. Borders become red.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    \n    background_color = 4\n    shape_color = 1\n    border_color = 2\n    hole_fill_color = 6\n    shape_with_hole_color = 8\n\n    # 1. Find all blue shapes\n    blue_shapes, pixel_to_shape_id = find_connected_components(input_np, shape_color)\n\n    if not blue_shapes: # No blue shapes, return original grid\n        return output_grid.tolist()\n\n    # 2. Find all exterior yellow pixels\n    exterior_yellow = find_exterior_pixels(input_np, background_color)\n\n    # 3. Identify all hole pixels (yellow pixels not reachable from outside)\n    all_hole_pixels = set()\n    for r in range(height):\n        for c in range(width):\n            if input_np[r, c] == background_color and (r, c) not in exterior_yellow:\n                all_hole_pixels.add((r, c))\n\n    # 4. Determine which shapes have holes and find border pixels\n    shape_has_holes = [False] * len(blue_shapes)\n    all_border_pixels = set()\n    shape_borders = [set() for _ in blue_shapes]\n    shape_adjacent_holes = [set() for _ in blue_shapes]\n\n    for shape_id, shape_coords in enumerate(blue_shapes):\n        current_border = set()\n        for r, c in shape_coords:\n            # Check 8 neighbors for border potential\n            for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                if input_np[nr, nc] == background_color:\n                    current_border.add((nr, nc))\n                \n                # Check if this blue pixel is adjacent to a hole pixel\n                if (nr, nc) in all_hole_pixels:\n                    shape_has_holes[shape_id] = True\n                    # Associate this hole pixel with the current shape\n                    shape_adjacent_holes[shape_id].add((nr,nc)) \n\n        shape_borders[shape_id] = current_border\n        all_border_pixels.update(current_border)\n        \n        # Also need to check if any border pixel is adjacent to a hole pixel\n        # This covers cases where hole pixels don't touch the main shape body directly\n        for br, bc in current_border:\n             for nr, nc in get_neighbors(br, bc, height, width, connectivity=8):\n                 if (nr,nc) in all_hole_pixels:\n                     # Check if this hole pixel is *only* reachable via this shape's area\n                     # This check is complex. Let's assume adjacency implies belonging for now.\n                     # A more robust check might involve flood-filling the hole and seeing which shape(s) surround it.\n                     # Simplification: if a shape's border touches a hole pixel, we associate the hole pixel with the shape.\n                     shape_has_holes[shape_id] = True\n                     shape_adjacent_holes[shape_id].add((nr,nc))\n\n\n    # 5. Create the output grid based on findings\n    \n    # Process shapes and their associated holes\n    for shape_id, shape_coords in enumerate(blue_shapes):\n        fill_color = shape_with_hole_color if shape_has_holes[shape_id] else shape_color\n        for r, c in shape_coords:\n            output_grid[r, c] = fill_color\n            \n        # Fill the holes associated with this shape\n        if shape_has_holes[shape_id]:\n            # Find *all* connected hole pixels starting from those adjacent to the shape\n            visited_holes = set()\n            hole_q = deque(list(shape_adjacent_holes[shape_id]))\n            all_connected_hole_pixels_for_shape = set()\n\n            while hole_q:\n                hr, hc = hole_q.popleft()\n                if (hr, hc) not in all_hole_pixels or (hr, hc) in visited_holes:\n                    continue\n                \n                visited_holes.add((hr, hc))\n                all_connected_hole_pixels_for_shape.add((hr, hc))\n                \n                # Explore neighbors within the hole region (4-connectivity is usually sufficient for filling)\n                for nr, nc in get_neighbors(hr, hc, height, width, connectivity=4):\n                    if (nr, nc) in all_hole_pixels and (nr, nc) not in visited_holes:\n                        hole_q.append((nr, nc))\n                        \n            # Now fill these identified hole pixels\n            for hr, hc in all_connected_hole_pixels_for_shape:\n                 output_grid[hr, hc] = hole_fill_color\n\n\n    # Place the borders (do this last to overwrite any mis-filled holes if logic was imperfect)\n    for br, bc in all_border_pixels:\n         # Only draw border over original background or holes that might have been adjacent\n         if input_np[br, bc] == background_color or (br, bc) in all_hole_pixels:\n             output_grid[br, bc] = border_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8320,
    "candidates_token_count": 2449,
    "total_token_count": 10769,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 121.340785,
  "retries": 2
}