{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis transformation rule processes a grid containing a background color (yellow, 4) and one or more shapes made of blue pixels (1).\n\nThe rule performs the following steps:\n1. Identify all separate, contiguous regions (shapes) of blue (1) pixels using 4-connectivity.\n2. Identify all yellow (4) background pixels reachable from the grid's outer border using a 4-connectivity flood fill ('exterior_yellow').\n3. Identify all yellow (4) pixels not reachable from the border ('hole_pixels').\n4. For each blue shape, determine if it encloses any holes by checking if any of its adjacent pixels (8-connectivity) is a 'hole_pixel'.\n5. For each blue shape, identify the 'exterior_yellow' pixels adjacent (8-connectivity) to it; these form the potential border.\n6. Create the output grid:\n    a. Initialize with the background color (yellow, 4).\n    b. Fill all 'hole_pixels' with magenta (6).\n    c. Fill the pixels corresponding to blue shapes: use azure (8) if the shape encloses holes, otherwise use blue (1).\n    d. Fill the identified border pixels with red (2).\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets valid neighbor coordinates based on specified connectivity (4 or 8).\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonals for 4-connectivity\n            if connectivity == 4 and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_connected_components(grid, target_color, connectivity=4):\n    \"\"\"Finds all connected components of a specific color using specified connectivity.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and not visited[r, c]:\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=connectivity):\n                        if grid[nr, nc] == target_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if component_coords:\n                    components.append(component_coords)\n\n    return components\n\ndef find_exterior_pixels(grid, background_color, connectivity=4):\n    \"\"\"Finds all background pixels reachable from the border using specified connectivity.\"\"\"\n    height, width = grid.shape\n    exterior_pixels = set()\n    q = deque()\n    visited_flood = np.zeros_like(grid, dtype=bool)\n\n    # Add border background pixels to the queue if they match the background color\n    for r in range(height):\n        for c in [0, width - 1]:\n            if grid[r, c] == background_color and not visited_flood[r,c]:\n                q.append((r, c))\n                visited_flood[r,c] = True\n                exterior_pixels.add((r, c))\n    for c in range(width): # Use range(width) instead of range(1, width - 1) to include corners\n        for r in [0, height - 1]:\n             if grid[r, c] == background_color and not visited_flood[r,c]:\n                q.append((r, c))\n                visited_flood[r,c] = True\n                exterior_pixels.add((r, c))\n\n    # Flood fill from the border using specified connectivity\n    while q:\n        curr_r, curr_c = q.popleft()\n        for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=connectivity):\n            if grid[nr, nc] == background_color and not visited_flood[nr, nc]:\n                visited_flood[nr, nc] = True\n                exterior_pixels.add((nr, nc))\n                q.append((nr, nc))\n\n    return exterior_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by bordering blue shapes and filling based on holes.\n    - Shapes enclosing holes become azure (8), holes become magenta (6).\n    - Shapes without holes remain blue (1).\n    - Borders on the exterior side become red (2).\n    - Background remains yellow (4).\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Define colors\n    background_color = 4\n    shape_color = 1\n    border_color = 2\n    hole_fill_color = 6\n    shape_with_hole_color = 8\n\n    # 1. Find all blue shapes (using 4-connectivity for shape definition)\n    blue_shapes = find_connected_components(input_np, shape_color, connectivity=4)\n\n    if not blue_shapes: # No blue shapes, return original grid\n        return input_np.tolist()\n\n    # 2. Find all exterior yellow pixels (using 4-connectivity for background reachability)\n    exterior_yellow = find_exterior_pixels(input_np, background_color, connectivity=4)\n\n    # 3. Identify all hole pixels (yellow pixels not reachable from outside)\n    all_hole_pixels = set()\n    for r in range(height):\n        for c in range(width):\n            if input_np[r, c] == background_color and (r, c) not in exterior_yellow:\n                all_hole_pixels.add((r, c))\n\n    # 4. Determine which shapes have holes and identify border pixels\n    shape_has_holes = [False] * len(blue_shapes)\n    all_border_pixels = set() # Pixels that are exterior_yellow and adjacent to a shape\n\n    for shape_id, shape_coords in enumerate(blue_shapes):\n        current_shape_borders = set()\n        shape_touches_hole = False\n        for r, c in shape_coords:\n            # Check 8 neighbors for holes and potential borders\n            for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                neighbor_coord = (nr, nc)\n                if input_np[nr, nc] == background_color:\n                    if neighbor_coord in exterior_yellow:\n                        current_shape_borders.add(neighbor_coord)\n                    elif neighbor_coord in all_hole_pixels:\n                        # If any part of the shape touches a hole pixel, mark the shape\n                        shape_touches_hole = True\n        \n        shape_has_holes[shape_id] = shape_touches_hole\n        all_border_pixels.update(current_shape_borders)\n\n    # 5. Create the output grid, applying colors in order of precedence\n    # Initialize with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # Fill holes first\n    for hr, hc in all_hole_pixels:\n        output_grid[hr, hc] = hole_fill_color\n\n    # Fill shapes based on whether they have holes\n    for shape_id, shape_coords in enumerate(blue_shapes):\n        fill_color = shape_with_hole_color if shape_has_holes[shape_id] else shape_color\n        for r, c in shape_coords:\n            output_grid[r, c] = fill_color\n\n    # Fill borders last (only affects original exterior yellow locations)\n    for br, bc in all_border_pixels:\n         # Check if the target pixel wasn't already filled by a shape or hole.\n         # This check might be redundant if logic is correct, but adds safety.\n         # The border should only occupy space that was originally exterior yellow.\n        if (br, bc) in exterior_yellow:\n             output_grid[br, bc] = border_color\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25373,
    "candidates_token_count": 1986,
    "total_token_count": 27359,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.660519,
  "retries": 1
}