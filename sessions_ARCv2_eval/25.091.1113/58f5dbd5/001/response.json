{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the background color of the input grid. Locate all separate, contiguous \ngroups of non-background colored pixels (objects). For each object, determine if \nit forms a 'solid rectangle', meaning its bounding box contains only pixels of the \nobject's color. Filter to keep only the solid rectangles. Determine the minimal \nbounding box enclosing all kept solid rectangles. Create an output grid sized to \nfit this combined bounding box plus a one-pixel border on all sides, filled with \nthe background color. Copy the subgrid corresponding to the combined bounding box \nfrom the input into the center of the output grid.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color considered as background.\n\n    Returns:\n        list: A list of tuples, where each tuple contains:\n              - color (int): The color of the object.\n              - coords (set): A set of (row, col) tuples representing the object's pixels.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and \\\n                           grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords:\n                    objects.append((color, obj_coords))\n                    \n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    \n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    \n    return min_r, min_c, max_r, max_c\n\ndef is_solid_rectangle(grid, color, bounding_box):\n    \"\"\"\n    Checks if the area within the bounding box is filled only with the object's color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The expected color within the box.\n        bounding_box (tuple): (min_r, min_c, max_r, max_c).\n\n    Returns:\n        bool: True if the object forms a solid rectangle, False otherwise.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r, c] != color:\n                return False\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Filters objects in the input grid, keeping only solid rectangles, and crops \n    the output grid around the kept objects with a one-pixel border.\n    \n    Args:\n        input_grid (list of lists): The input grid representation.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify the background color (assuming it's the color of the top-left corner)\n    background_color = grid[0, 0]\n\n    # 2. Find all distinct objects\n    all_objects = find_objects(grid, background_color)\n\n    # 3. & 4. Filter objects, keeping only solid rectangles\n    solid_rectangles = []\n    all_kept_coords = set()\n    for color, coords in all_objects:\n        bbox = get_bounding_box(coords)\n        if bbox:\n            # Check if it's a solid rectangle\n            min_r, min_c, max_r, max_c = bbox\n            is_solid = True\n            for r in range(min_r, max_r + 1):\n                for c in range(min_c, max_c + 1):\n                     # Check if pixel is within grid bounds before accessing\n                     if not (0 <= r < rows and 0 <= c < cols):\n                         # This case shouldn't happen if bounding box is derived correctly\n                         # but good for safety.\n                         is_solid = False\n                         break\n                     if grid[r, c] != color:\n                         is_solid = False\n                         break\n                if not is_solid:\n                    break\n            \n            # Additionally check if the count of pixels matches the area\n            if is_solid and len(coords) == (max_r - min_r + 1) * (max_c - min_c + 1):\n                solid_rectangles.append((color, coords, bbox))\n                all_kept_coords.update(coords)\n\n    # Handle case where no solid rectangles are found (return minimal background grid?)\n    # Based on examples, there are always kept objects. If not, the bounding box calculation below fails.\n    # Let's assume at least one solid rectangle is kept as per examples.\n    if not all_kept_coords:\n         # If no solid rectangles are found, return a 3x3 grid of the background color\n         # This is an assumption based on needing *some* output.\n         # Or perhaps return the input unchanged? Let's stick to 3x3 background for now.\n         # Revisit if a test case contradicts this.\n         # The examples provided DO have outputs derived from kept objects.\n         # A better default might be to return a 1x1 grid of background.\n         # Let's follow the logic: if no coords, bbox fails. If bbox fails, crop fails.\n         # Safest bet might be a minimal grid. Let's try 1x1.\n        # return [[background_color]] \n        # Let's stick to the plan derived from examples: derive output from kept objects.\n        # If nothing kept, this will raise an error later, which is okay during dev.\n        # Update: Let's return empty grid if nothing found? No, examples show structure.\n        # Let's return 3x3 background for now as a placeholder default.\n        return [[background_color] * 3 for _ in range(3)]\n\n\n    # 5. Determine the minimal bounding box enclosing all selected solid rectangles\n    overall_bbox = get_bounding_box(all_kept_coords)\n    if overall_bbox is None:\n         # Should not happen if all_kept_coords is not empty\n         return [[background_color] * 3 for _ in range(3)] # Fallback\n\n    min_r_overall, min_c_overall, max_r_overall, max_c_overall = overall_bbox\n\n    # 6. Extract the subgrid from the input corresponding to this minimal bounding box\n    subgrid_height = max_r_overall - min_r_overall + 1\n    subgrid_width = max_c_overall - min_c_overall + 1\n    extracted_subgrid = grid[min_r_overall:max_r_overall+1, min_c_overall:max_c_overall+1]\n\n    # 7. Create the output grid, sized to fit the extracted subgrid plus a 1-pixel border\n    output_height = subgrid_height + 2\n    output_width = subgrid_width + 2\n    output_grid = np.full((output_height, output_width), background_color, dtype=int)\n\n    # 8. & 9. Place the extracted subgrid into the center of the output grid\n    output_grid[1:1+subgrid_height, 1:1+subgrid_width] = extracted_subgrid\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5593,
    "candidates_token_count": 2065,
    "total_token_count": 7658,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.049475,
  "retries": 1
}