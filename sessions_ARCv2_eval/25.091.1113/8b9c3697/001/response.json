{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies \"cavities\" - regions of background pixels bounded by a single contiguous non-background, non-red object (\"container\").\nIf a red pixel (color 2) is adjacent (including diagonals) to such a cavity, the cavity region is filled with white (color 0).\nThe red object that triggered the fill is then modified:\n- If any pixel of the red object is edge-adjacent to the newly filled white cavity, the entire red object becomes white (0).\n- Otherwise, the entire red object becomes the background color.\nRed objects that are not adjacent to any valid cavity are changed to the background color.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"Gets valid neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if connectivity == 4 and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_connected_component(grid, start_r, start_c, target_colors, visited_global=None):\n    \"\"\"\n    Finds all connected pixels of target_colors starting from (start_r, start_c)\n    using BFS. Updates visited_global if provided.\n    \"\"\"\n    if grid[start_r, start_c] not in target_colors:\n        return set()\n    \n    height, width = grid.shape\n    component = set()\n    q = deque([(start_r, start_c)])\n    visited_local = set([(start_r, start_c)])\n\n    if visited_global is not None:\n        if (start_r, start_c) in visited_global:\n            return set() # Already processed globally\n        visited_global.add((start_r, start_c))\n\n\n    while q:\n        r, c = q.popleft()\n        component.add((r, c))\n\n        for nr, nc in get_neighbors(r, c, height, width, connectivity=8): # Use 8-connectivity for components\n            neighbor_coord = (nr, nc)\n            if neighbor_coord not in visited_local and grid[nr, nc] in target_colors:\n                visited_local.add(neighbor_coord)\n                if visited_global is not None:\n                     if neighbor_coord in visited_global: continue # Already processed globally\n                     visited_global.add(neighbor_coord)\n                q.append(neighbor_coord)\n                \n    return component\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the cavity filling transformation.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    background_color = find_background_color(input_grid)\n    fill_color = 0\n    red_color = 2\n    \n    processed_red_pixels = set() # Keeps track of red pixels belonging to objects already processed\n    pixels_to_change = {} # Stores final changes: {(r, c): color}\n    visited_background = set() # Track visited background pixels for cavity finding efficiency\n    \n    cavities_found = [] # Stores tuples: (cavity_coords, bounding_container_coords, adjacent_red_coords)\n\n    # 1. Find potential cavities (background regions bounded by single container object)\n    for r in range(height):\n        for c in range(width):\n            # Start search from unvisited background pixels\n            if input_grid[r, c] == background_color and (r, c) not in visited_background:\n                # Find the full connected region of background pixels\n                background_region = find_connected_component(input_grid, r, c, {background_color}, visited_global=visited_background)\n                if not background_region: continue\n\n                boundary_pixels = set()\n                adjacent_red_pixels = set()\n                container_boundary_pixels = set()\n                \n                # Analyze neighbors of the background region\n                for br, bc in background_region:\n                    for nr, nc in get_neighbors(br, bc, height, width, connectivity=8): # Check all 8 neighbors\n                        neighbor_coord = (nr, nc)\n                        # Skip if neighbor is part of the same background region\n                        if neighbor_coord in background_region: \n                            continue\n                            \n                        neighbor_color = input_grid[nr, nc]\n                        # If neighbor is non-background, it's part of the boundary\n                        if neighbor_color != background_color:\n                             boundary_pixels.add(neighbor_coord)\n                             # Categorize boundary pixel\n                             if neighbor_color == red_color:\n                                 adjacent_red_pixels.add(neighbor_coord)\n                             else: # It's a container pixel\n                                 container_boundary_pixels.add(neighbor_coord)\n\n                # Check if this region is a valid cavity candidate:\n                # - Must have container boundary pixels\n                # - Must have adjacent red pixels\n                if not container_boundary_pixels or not adjacent_red_pixels:\n                    continue\n\n                # Check if all container boundary pixels belong to a single connected container object\n                first_container_pixel = next(iter(container_boundary_pixels))\n                container_color = input_grid[first_container_pixel]\n                "
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7927,
    "candidates_token_count": 1323,
    "total_token_count": 9250,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 156.213402,
  "retries": 2
}