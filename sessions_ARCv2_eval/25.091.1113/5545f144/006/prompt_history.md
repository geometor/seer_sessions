
## train_1

**input:**
```
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 1 1 3 1 4 1 1 1 1 1 1
1 1 1 4 1 4 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 4 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 4 1 4 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 4 1 1 4 1 3 1 1 1 4 1 1 4 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 4 1 4
1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1 3 1 4 1 1 1 1 4 1
1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1
1 4 1 1 1 1 1 1
4 1 4 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 3 0 0 3 0 2 0 3 0 0 3 0 2 0 0 0 3 3 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 3 3 3 0 0 0 2 0 0 0 3 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 3 3 3
0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 3 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
3 3 3 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0 2 0 0 0 0 3 0
0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 3 3 3
0 0 0 0 3 0
0 0 0 0 0 0
```


## train_3

**input:**
```
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 6 5 5 6 5 5 5 6 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 6 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 6 5 6 5 5 6 5 5 6 5 4 5 5 6 5 6 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 6 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5 4 5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 6 5 5 6 5 5 5 5 5 5 4 5 5 6 5 5 6 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 4 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 5 6 5 5 5 5 5 5
5 5 5 5 6 5 6 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5
```

Okay, let's break down the task based on the examples provided.

**Perception of Elements:**

1.  **Input Grid Structure:** The input grids consist of pixels with various colors. A prominent feature is the presence of one or more vertical columns composed entirely of a single, repeating color. These columns act as dividers.
2.  **Dividers:**
    *   In `train_1`, the dividers are columns of green (3).
    *   In `train_2`, the dividers are columns of red (2).
    *   In `train_3`, the divider is a column of yellow (4).
3.  **Sections:** These divider columns partition the input grid into distinct vertical sections or subgrids.
4.  **Background Color:** Within each example, there appears to be a dominant background color, distinct from the divider color.
    *   `train_1`: Background is blue (1).
    *   `train_2`: Background is white (0).
    *   `train_3`: Background is gray (5).
5.  **Foreground Objects:** Each section contains foreground objects composed of pixels whose color is neither the background color nor the divider color.
    *   `train_1`: Foreground is yellow (4).
    *   `train_2`: Foreground is green (3).
    *   `train_3`: Foreground is magenta (6).
6.  **Output Grid:** The output grid is consistently a copy of exactly *one* of the vertical sections from the input grid.
7.  **Selection Logic:** The key transformation is selecting *which* section becomes the output. Comparing the sections reveals a pattern: the section chosen for the output is the one containing the *highest number* of foreground pixels (pixels that are not the background color and not the divider color).
    *   `train_1`: Sections have 7, 4, and 3 yellow pixels. The first section (with 7) is chosen.
    *   `train_2`: Sections have 6, 5, 4, and 7 green pixels. The last section (with 7) is chosen.
    *   `train_3`: Sections have 11 and 8 magenta pixels. The first section (with 11) is chosen.
8.  **Tie-breaking:** In case of a tie in the count of foreground pixels between sections, the examples (`train_1`, `train_3`) suggest selecting the leftmost section among those tied for the maximum count. `train_2` does not involve a tie.

**YAML Facts:**


```yaml
task_description: Find vertical columns acting as dividers, identify the background color, count foreground pixels in each section defined by the dividers, and output the section with the maximum count of foreground pixels.

elements:
  - role: input_grid
    description: A 2D array of pixels representing colors.
  - role: output_grid
    description: A 2D array of pixels, representing a subgrid derived from the input.
  - role: divider_column
    description: A vertical column in the input grid where all pixels share the same color. This color is consistent across all divider columns within a single input.
    properties:
      - uniformity: All pixels in the column have the same color.
      - function: Partitions the grid into vertical sections.
  - role: divider_color
    description: The color of the pixels within the divider columns.
  - role: background_color
    description: The most frequent color in the input grid, excluding the divider columns.
    properties:
      - prevalence: Most common pixel color outside dividers.
  - role: section
    description: A vertical subgrid of the input grid, located between divider columns or between a grid edge and a divider column.
  - role: foreground_pixel
    description: A pixel within a section whose color is neither the background_color nor the divider_color.
    properties:
      - color: Distinguishes it from background and dividers.

actions:
  - name: identify_divider_columns
    description: Scan the input grid column by column to find columns composed of a single, repeating color. Determine the divider_color.
  - name: identify_background_color
    description: Count the frequency of each color in the input grid, ignoring pixels in the divider columns. The color with the highest frequency is the background_color.
  - name: segment_grid
    description: Use the identified divider columns to split the input grid into vertical sections.
  - name: count_foreground_pixels
    description: For each section, count the number of pixels that are neither the background_color nor the divider_color.
  - name: select_target_section
    description: Identify the section(s) with the maximum count of foreground pixels. If there is a tie, select the leftmost section among those tied.
  - name: generate_output
    description: Create the output grid by copying the selected target section.

relationships:
  - type: defines
    source: divider_columns
    target: sections
    description: Divider columns define the boundaries between sections.
  - type: excludes
    source: foreground_pixel
    target: [background_color, divider_color]
    description: A foreground pixel's color cannot be the background or divider color.
  - type: determines
    source: count_of_foreground_pixels_in_sections
    target: selected_target_section
    description: The maximum count determines which section is selected.
  - type: equals
    source: output_grid
    target: selected_target_section
    description: The output grid is identical to the selected target section.
```


**Natural Language Program:**

1.  **Analyze Columns:** Examine each column of the input grid. Identify columns where all pixels have the same color. These are potential divider columns. Determine the single color used across all such uniform columns; this is the `divider_color`. Confirm that at least one such column exists.
2.  **Identify Background:** Consider all pixels *not* located in the identified divider columns. Count the occurrences of each color among these non-divider pixels. The color with the highest frequency is the `background_color`.
3.  **Define Sections:** Mentally (or actually) split the input grid vertically using the divider columns as boundaries. This creates multiple sections. The sections include the areas from the left edge to the first divider, between consecutive dividers, and from the last divider to the right edge.
4.  **Count Foreground in Sections:** For each section created in step 3, iterate through its pixels. Count how many pixels have a color that is *neither* the `divider_color` nor the `background_color`. Record this count for each section.
5.  **Select Section:** Find the maximum count recorded in step 4. Identify the section(s) that achieved this maximum count. If only one section has the maximum count, select it. If multiple sections tie for the maximum count, select the one that appears furthest to the left in the original input grid.
6.  **Produce Output:** The output grid is an exact copy of the single section selected in step 5.
```python
import numpy as np
from collections import Counter

"""
Identify vertical divider columns (columns with a single repeating color). 
Determine the background color (most frequent color excluding dividers).
Split the grid into sections based on the divider columns.
Count 'foreground' pixels (neither background nor divider color) in each section.
Select the section with the maximum foreground pixel count. If there's a tie, choose the leftmost section among the tied ones.
The output grid is the selected section.
"""

def find_divider_columns(grid):
    """
    Finds columns composed of a single repeating color.

    Args:
        grid: A numpy array representing the input grid.

    Returns:
        A tuple containing:
        - divider_indices: A list of column indices that are divider columns.
        - divider_color: The color value used in the divider columns (int or None if no dividers found).
    """
    height, width = grid.shape
    divider_indices = []
    potential_divider_color = None
    first_divider_found = False

    for c in range(width):
        column = grid[:, c]
        # Check if all elements in the column are the same
        if np.all(column == column[0]):
            current_color = column[0]
            # If this is the first divider found, store its color
            if not first_divider_found:
                potential_divider_color = current_color
                divider_indices.append(c)
                first_divider_found = True
            # If subsequent dividers are found, ensure they have the same color
            elif current_color == potential_divider_color:
                divider_indices.append(c)
            else:
                # Found a uniform column with a *different* color - this contradicts the pattern
                # Or handle this case differently if needed? For now, assume only one divider color.
                # Based on examples, let's stick to the first color found.
                # Or maybe return an error/None? Let's assume only one valid divider color per task.
                 pass # Ignore columns with different uniform colors for now.

    return divider_indices, potential_divider_color


def find_background_color(grid, divider_indices, divider_color):
    """
    Finds the most frequent color in the grid, excluding divider columns.

    Args:
        grid: A numpy array representing the input grid.
        divider_indices: A list of column indices that are divider columns.
        divider_color: The color value used in the divider columns.

    Returns:
        The background color value (int). Returns -1 if no non-divider pixels exist.
    """
    height, width = grid.shape
    non_divider_pixels = []

    for r in range(height):
        for c in range(width):
            if c not in divider_indices:
                non_divider_pixels.append(grid[r, c])

    if not non_divider_pixels:
        # Edge case: Grid is all dividers or empty after removing dividers
        # Let's return a value indicating no background, maybe the most frequent color overall?
        # Or assume this won't happen based on examples.
        # Let's try returning the most frequent overall color if non_divider_pixels is empty,
        # otherwise this might fail later. Or perhaps default to 0?
        # Revisit if necessary. For now, let's pick the most frequent non-divider color.
        # If truly empty, return -1 as an error indicator.
         return -1 # Indicate error or ambiguity

    # Count frequencies of non-divider pixels
    color_counts = Counter(non_divider_pixels)

    # Remove the divider color from counts if it exists there
    if divider_color is not None and divider_color in color_counts:
        del color_counts[divider_color]

    # Find the most common color among the remaining
    if not color_counts:
        # This could happen if all non-divider pixels were the divider_color
        # In this case, what is the background? Let's default to 0 (white) or maybe the divider color itself?
        # Let's default to 0 for now.
        return 0 # Default background if only divider color remains after filtering

    # Find the color with the highest count
    background_color = color_counts.most_common(1)[0][0]
    return background_color

def split_into_sections(grid, divider_indices):
    """
    Splits the grid into vertical sections based on divider column indices.

    Args:
        grid: A numpy array representing the input grid.
        divider_indices: A list of column indices that are divider columns.

    Returns:
        A list of numpy arrays, where each array is a section (subgrid).
    """
    sections = []
    width = grid.shape[1]
    start_col = 0

    # Sort indices just in case they weren't found in order
    sorted_indices = sorted(divider_indices)

    for div_idx in sorted_indices:
        # Add section before the current divider
        if div_idx > start_col:
            sections.append(grid[:, start_col:div_idx])
        # Update start for the next section (it starts *after* the divider)
        start_col = div_idx + 1

    # Add the last section (from the last divider to the end)
    if start_col < width:
        sections.append(grid[:, start_col:width])

    # Handle case where there are no dividers found (shouldn't happen based on examples)
    if not divider_indices and width > 0:
         sections.append(grid) # The whole grid is one section

    return sections

def count_foreground_pixels(section, background_color, divider_color):
    """
    Counts pixels in a section that are neither the background nor the divider color.

    Args:
        section: A numpy array representing a grid section.
        background_color: The determined background color.
        divider_color: The color of the divider columns.

    Returns:
        The count of foreground pixels (int).
    """
    count = 0
    if section.size == 0: # Handle empty sections
        return 0
        
    for pixel in section.flat:
        if pixel != background_color and pixel != divider_color:
            count += 1
    return count

def transform(input_grid):
    """
    Transforms the input grid by finding the vertical section with the most 
    'foreground' pixels (pixels that are neither the divider color nor the 
    most common non-divider color) and returning that section. Ties are 
    broken by selecting the leftmost section.
    """
    input_np = np.array(input_grid)

    # 1. Analyze Columns: Find divider columns and their color
    divider_indices, divider_color = find_divider_columns(input_np)
    
    # Handle case where no dividers are found - return input? or error?
    # Based on examples, dividers are always present. If not, the logic breaks down.
    # Let's assume dividers exist. If divider_color is None, maybe raise error or return input?
    # For now proceed, hoping find_background_color handles it gracefully.

    # 2. Identify Background: Find the most frequent non-divider color
    background_color = find_background_color(input_np, divider_indices, divider_color)
    if background_color == -1:
         # Handle error: Could not determine background (e.g., grid only dividers)
         # Return empty grid or input? Let's return empty for now.
         return np.array([[]], dtype=int) # Or raise an Exception

    # 3. Define Sections: Split the grid based on dividers
    sections = split_into_sections(input_np, divider_indices)
    
    if not sections:
        # Should not happen if input grid has dimensions, but handle defensively
        return np.array([[]], dtype=int)


    # 4. Count Foreground in Sections and 5. Select Section
    max_foreground_count = -1
    selected_section = None

    for section in sections:
        foreground_count = count_foreground_pixels(section, background_color, divider_color)

        # Keep the *first* section encountered that has the maximum count
        if foreground_count > max_foreground_count:
            max_foreground_count = foreground_count
            selected_section = section

    # 6. Produce Output: Return the selected section
    if selected_section is None:
         # This might happen if all sections were empty or had 0 foreground pixels
         # Return the first section? Or an empty grid? Let's return the first section.
         if sections:
             return sections[0].tolist() # Convert back to list of lists
         else:
             return [[]] # Should be already handled above

    return selected_section.tolist() # Convert numpy array back to list of lists for ARC format

```
```python
import numpy as np
from collections import Counter

"""
The transformation rule involves identifying vertical divider columns (columns where all pixels have the same color, and this color is consistent across all such columns). 
These dividers split the input grid into vertical sections. 
The background color is determined as the most frequent color in the grid, excluding the pixels within the divider columns. 
Foreground pixels within each section are defined as those whose color is neither the background color nor the divider color. 
The rule is to count these foreground pixels in each section. 
The output grid is a copy of the section that contains the maximum number of foreground pixels. 
If multiple sections tie for the maximum count, the leftmost section among them is chosen.
"""

def find_divider_columns(grid: np.ndarray) -> tuple[list[int], int | None]:
    """
    Finds columns composed of a single repeating color.

    Args:
        grid: A numpy array representing the input grid.

    Returns:
        A tuple containing:
        - divider_indices: A list of column indices that are divider columns.
        - divider_color: The color value used in the divider columns (int or None if no dividers found).
    """
    height, width = grid.shape
    if height == 0 or width == 0:
        return [], None
        
    divider_indices = []
    potential_divider_color = None
    first_divider_found = False

    for c in range(width):
        column = grid[:, c]
        # Check if all elements in the column are the same
        # Use unique check which is efficient for numpy arrays
        unique_elements = np.unique(column)
        if len(unique_elements) == 1:
            current_color = unique_elements[0]
            # If this is the first divider found, store its color
            if not first_divider_found:
                potential_divider_color = current_color
                divider_indices.append(c)
                first_divider_found = True
            # If subsequent dividers are found, ensure they have the same color
            elif current_color == potential_divider_color:
                divider_indices.append(c)
            # else: Ignore columns with different uniform colors based on task examples

    return divider_indices, potential_divider_color


def find_background_color(grid: np.ndarray, divider_indices: list[int], divider_color: int | None) -> int:
    """
    Finds the most frequent color in the grid, excluding divider columns and the divider color itself.

    Args:
        grid: A numpy array representing the input grid.
        divider_indices: A list of column indices that are divider columns.
        divider_color: The color value used in the divider columns.

    Returns:
        The background color value (int). Returns 0 if determination is ambiguous.
    """
    height, width = grid.shape
    non_divider_pixels = []
    divider_indices_set = set(divider_indices) # Use set for faster lookup

    for c in range(width):
        if c not in divider_indices_set:
            non_divider_pixels.extend(grid[:, c].tolist())

    if not non_divider_pixels:
        # No pixels outside dividers - ambiguous background. Default to 0.
        return 0

    # Count frequencies of non-divider pixels
    color_counts = Counter(non_divider_pixels)

    # Remove the divider color from counts if it exists and is not None
    if divider_color is not None and divider_color in color_counts:
        del color_counts[divider_color]

    # Find the most common color among the remaining
    if not color_counts:
        # This could happen if all non-divider pixels were the divider_color
        # Or if non_divider_pixels was empty initially. Default background to 0.
        return 0

    # Find the color with the highest count
    # most_common returns list of tuples [(element, count)], access first element's first item
    background_color = color_counts.most_common(1)[0][0]
    return background_color


def split_into_sections(grid: np.ndarray, divider_indices: list[int]) -> list[np.ndarray]:
    """
    Splits the grid into vertical sections based on divider column indices.

    Args:
        grid: A numpy array representing the input grid.
        divider_indices: A list of column indices that are divider columns.

    Returns:
        A list of numpy arrays, where each array is a section (subgrid).
    """
    sections = []
    height, width = grid.shape
    if width == 0:
        return []
        
    start_col = 0
    # Ensure indices are sorted for correct section splitting
    sorted_indices = sorted(divider_indices)

    for div_idx in sorted_indices:
        # Add section before the current divider, if it's not empty
        if div_idx > start_col:
            sections.append(grid[:, start_col:div_idx])
        # Update start for the next section (it starts *after* the divider)
        start_col = div_idx + 1

    # Add the last section (from the last divider to the end), if it's not empty
    if start_col < width:
        sections.append(grid[:, start_col:width])

    # Handle case where there are no dividers found (treat whole grid as one section)
    if not divider_indices and width > 0:
         sections.append(grid)

    return sections


def count_foreground_pixels(section: np.ndarray, background_color: int, divider_color: int | None) -> int:
    """
    Counts pixels in a section that are neither the background nor the divider color.

    Args:
        section: A numpy array representing a grid section.
        background_color: The determined background color.
        divider_color: The color of the divider columns (can be None).

    Returns:
        The count of foreground pixels (int).
    """
    count = 0
    if section.size == 0: # Handle empty sections gracefully
        return 0
        
    for pixel in section.flat:
        is_background = (pixel == background_color)
        # Only check against divider_color if it's defined (not None)
        is_divider = (divider_color is not None and pixel == divider_color)
        
        if not is_background and not is_divider:
            count += 1
    return count


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid according to the described rule:
    1. Find vertical divider columns (uniform color).
    2. Determine background color (most frequent non-divider color).
    3. Split grid into sections based on dividers.
    4. Count foreground pixels (not background, not divider) in each section.
    5. Select the leftmost section with the maximum foreground pixel count.
    6. Return the selected section.
    """
    input_np = np.array(input_grid, dtype=int)
    
    if input_np.size == 0:
        return [] # Handle empty input grid

    # 1. Analyze Columns: Find divider columns and their color
    divider_indices, divider_color = find_divider_columns(input_np)
    
    # Although examples always have dividers, add a check.
    # If no dividers, the whole grid is one section. The logic below handles this.

    # 2. Identify Background: Find the most frequent non-divider/non-divider-color pixel
    background_color = find_background_color(input_np, divider_indices, divider_color)
    
    # 3. Define Sections: Split the grid based on dividers
    sections = split_into_sections(input_np, divider_indices)
    
    if not sections:
        # This might happen if the grid width is 0, or only consists of dividers.
        # Return an empty grid consistent with ARC format.
        return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []


    # 4. Count Foreground in Sections and 5. Select Section
    max_foreground_count = -1  # Use -1 to ensure the first section's count is always >
    selected_section_index = -1 # Keep track of index for tie-breaking

    for i, section in enumerate(sections):
        foreground_count = count_foreground_pixels(section, background_color, divider_color)

        # Keep the *first* section encountered (smallest index i) that has the maximum count
        if foreground_count > max_foreground_count:
            max_foreground_count = foreground_count
            selected_section_index = i
            
    # 6. Produce Output: Return the selected section
    if selected_section_index == -1:
        # This case means no sections had foreground > -1.
        # This could happen if all sections are empty or all pixels are background/divider.
        # Default behavior: return the first section if available, else empty.
        if sections:
            selected_section = sections[0]
        else:
             # Should have been caught earlier, but defensively return empty
             return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []
    else:
        selected_section = sections[selected_section_index]

    # Convert the selected numpy section back to list of lists for ARC format
    output_grid = selected_section.tolist()
    
    # Ensure output is not empty list if input height > 0 but section width is 0
    if not output_grid and input_np.shape[0] > 0:
         return [[]] * input_np.shape[0]
         
    return output_grid
```
```python
import numpy as np
from collections import Counter

"""
The transformation rule involves:
1. Finding the overall most frequent color in the input grid, designated as the background color.
2. Identifying all vertical columns composed of a single, uniform color.
3. Determining the divider color, which is the color forming uniform columns but is *not* the background color.
4. Locating the specific columns composed entirely of the divider color (divider columns).
5. Splitting the input grid into vertical sections using these divider columns as boundaries.
6. For each section, counting the 'foreground' pixels, defined as pixels whose color is neither the background color nor the divider color.
7. Selecting the section that contains the maximum number of foreground pixels. If multiple sections tie for the maximum count, the leftmost section among them is chosen.
8. The output grid is an exact copy of the selected section.
"""

def find_overall_most_frequent_color(grid: np.ndarray) -> int | None:
    """Finds the most frequent color in the entire grid."""
    if grid.size == 0:
        return None
    colors, counts = np.unique(grid, return_counts=True)
    # In case of a tie in frequency, numpy returns the smallest color value first.
    # This seems okay as a tie-breaker if needed, but examples suggest a clear winner.
    most_frequent_color = colors[np.argmax(counts)]
    return int(most_frequent_color) # Cast to standard int

def find_uniform_columns_data(grid: np.ndarray) -> dict[int, list[int]]:
    """
    Finds all uniform columns and returns a dictionary mapping
    the uniform color to a list of column indices where it occurs.
    """
    height, width = grid.shape
    uniform_columns_map = {}
    if height == 0 or width == 0:
        return uniform_columns_map

    for c in range(width):
        column = grid[:, c]
        unique_elements = np.unique(column)
        if len(unique_elements) == 1:
            color = int(unique_elements[0]) # Cast to standard int
            if color not in uniform_columns_map:
                uniform_columns_map[color] = []
            uniform_columns_map[color].append(c)
    return uniform_columns_map

def split_into_sections(grid: np.ndarray, divider_indices: list[int]) -> list[np.ndarray]:
    """
    Splits the grid into vertical sections based on divider column indices.
    (Same logic as previous attempt, verified robust)
    """
    sections = []
    height, width = grid.shape
    if width == 0:
        return []

    start_col = 0
    # Ensure indices are sorted for correct section splitting
    sorted_indices = sorted(divider_indices)

    for div_idx in sorted_indices:
        # Add section before the current divider, if it's not empty
        if div_idx > start_col:
            sections.append(grid[:, start_col:div_idx])
        # Update start for the next section (it starts *after* the divider)
        start_col = div_idx + 1

    # Add the last section (from the last divider to the end), if it's not empty
    if start_col < width:
        sections.append(grid[:, start_col:width])

    # Handle case where there are no dividers found (treat whole grid as one section)
    if not divider_indices and width > 0:
         sections.append(grid)

    return sections

def count_foreground_pixels(section: np.ndarray, background_color: int, divider_color: int | None) -> int:
    """
    Counts pixels in a section that are neither the background nor the divider color.
    (Same logic as previous attempt, verified robust)
    """
    count = 0
    if section.size == 0: # Handle empty sections gracefully
        return 0

    for pixel in section.flat:
        is_background = (pixel == background_color)
        # Only check against divider_color if it's defined (not None)
        is_divider = (divider_color is not None and pixel == divider_color)

        if not is_background and not is_divider:
            count += 1
    return count

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    """
    input_np = np.array(input_grid, dtype=int)

    if input_np.size == 0:
        return [] # Handle empty input grid

    # --- Workflow ---

    # 1. Find Background Color: Overall most frequent color
    background_color = find_overall_most_frequent_color(input_np)
    if background_color is None: # Should only happen for empty grid, already handled
         return []

    # 2. Identify Potential Divider Colors/Columns
    uniform_columns_data = find_uniform_columns_data(input_np)

    # 3. Determine True Divider Color and Indices
    divider_color = None
    divider_indices = []
    for color, indices in uniform_columns_data.items():
        if color != background_color:
            # Assume only one such color exists per the examples
            divider_color = color
            divider_indices = indices
            break # Found the divider color

    # Note: If no uniform column color is different from the background,
    # divider_color remains None and divider_indices remains empty.
    # The split_into_sections function handles empty divider_indices correctly
    # by treating the whole grid as one section.

    # 5. Define Sections
    sections = split_into_sections(input_np, divider_indices)

    if not sections:
        # This might happen if the grid width is 0.
        # Return an empty grid structure matching input height.
        return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []

    # 6. & 7. Count Foreground and Select Output Section
    max_foreground_count = -1  # Use -1 to ensure the first section's count is always >=
    selected_section_index = -1 # Keep track of index for tie-breaking (leftmost)

    for i, section in enumerate(sections):
        # Pass the identified background and divider colors for counting
        foreground_count = count_foreground_pixels(section, background_color, divider_color)

        # Keep the *first* section encountered (smallest index i) that has the maximum count
        if foreground_count > max_foreground_count:
            max_foreground_count = foreground_count
            selected_section_index = i

    # 8. Produce Output
    if selected_section_index == -1:
        # This case means no sections had foreground > -1.
        # Occurs if all sections are empty or all pixels are background/divider.
        # Default behavior: return the first section if available, else empty.
        if sections:
            selected_section = sections[0]
        else:
             # Should have been caught earlier by the 'if not sections' check
             return [[]] * input_np.shape[0] if input_np.shape[0] > 0 else []
    else:
        selected_section = sections[selected_section_index]

    # Convert the selected numpy section back to list of lists for ARC format
    output_grid = selected_section.tolist()

    # Ensure output structure consistency for empty sections
    if not output_grid and input_np.shape[0] > 0:
         # If section width is 0, tolist() gives [], but ARC expects [[]] * height
         return [[]] * input_np.shape[0]

    return output_grid
```
