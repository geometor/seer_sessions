
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's analyze the provided examples to understand the transformation rule.

**Perception of Task Elements:**

Each task example consists of an input grid and a corresponding output grid. The grids contain pixels of different colors. The core transformation seems to involve a "filling" process where one color expands into the background color, constrained by other colors.

1.  **Example 1:** The input has a blue background (1), green (3) and gray (5) pixels forming a partial boundary, and a single maroon (9) pixel inside this boundary. The output shows the maroon (9) color having filled the blue (1) area enclosed by the green (3) and gray (5) pixels. The original boundary and maroon pixels remain.
2.  **Example 2:** The input has a white background (0), gray (5) pixels forming scattered boundary elements, and a single yellow (4) pixel. The output shows the yellow (4) color having filled the white (0) area connected to the original yellow pixel, stopping when it encounters gray (5) pixels.
3.  **Example 3:** The input has an orange background (7), maroon (9) pixels forming an outer boundary, green (3) pixels inside this boundary, and some isolated magenta (6) and azure (8) pixels. The output shows the green (3) color having filled the orange (7) area within the maroon (9) boundary, starting from the original green (3) pixels. The maroon, magenta, and azure pixels remain unchanged and act as implicit boundaries for the fill.

The common pattern is a flood fill operation. A specific color ("fill color") expands into the background color. All other non-background colors act as boundaries, halting the expansion. The fill originates from the initial position(s) of the fill color.

**YAML Facts:**


```yaml
task_type: pattern_transformation
transformation_name: flood_fill_with_boundaries
common_elements:
  - grid_representation: 2D array of integers (colors)
  - background_color: Typically the most frequent color in the input.
  - objects: Contiguous areas of non-background colors.
actions:
  - identify_background_color
  - identify_non_background_colors
  - determine_fill_color: The color that expands.
  - determine_boundary_colors: All non-background colors *except* the fill color.
  - perform_flood_fill:
      origin: All pixels initially having the fill color.
      target_pixels: Pixels with the background color.
      fill_value: The fill color.
      stop_condition: Encountering a boundary color pixel or grid edge.
      connectivity: Cardinal neighbors (up, down, left, right).
relationships:
  - fill_color: Expands into the background.
  - boundary_colors: Constrain the expansion of the fill color.
  - background_color: Is replaced by the fill color during the operation.
  - other_colors: (Like Magenta/Azure in Ex3) Act as boundary colors if they are not the designated fill color.
examples_summary:
  - example_1:
      background: blue (1)
      fill_color: maroon (9)
      boundary_colors: [green (3), gray (5)]
  - example_2:
      background: white (0)
      fill_color: yellow (4)
      boundary_colors: [gray (5)]
  - example_3:
      background: orange (7)
      fill_color: green (3)
      boundary_colors: [maroon (9), magenta (6), azure (8)] # Note: Magenta and Azure are present but outside the main filled area. They still act as boundaries if the fill reaches them.
uncertainty:
  - The exact rule for selecting the 'fill_color' from multiple non-background colors needs clarification. In the examples, it seems to be the color whose flood fill (using other non-background colors as boundaries) successfully generates the output. A more direct selection criteria isn't immediately obvious from just these three examples (e.g., it's not always the unique color, nor always the color with fewest/most pixels).

```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the background color, which is the most frequent color in the input grid.
3.  Identify all non-background colors present in the input grid.
4.  Iterate through each non-background color identified in step 3, treating it as a potential 'fill color'.
    a.  For the current potential 'fill color', designate all *other* non-background colors as 'boundary colors'.
    b.  Create a temporary grid, initially a copy of the input grid.
    c.  Find all pixel coordinates in the temporary grid that contain the potential 'fill color'. Add these coordinates to a queue or stack for processing (these are the starting points for the flood fill).
    d.  Maintain a set of visited coordinates for the current fill operation, initially containing the starting coordinates.
    e.  While the queue/stack is not empty:
        i.  Dequeue/pop a coordinate (row, col).
        ii. For each cardinal neighbor (up, down, left, right) of the current coordinate:
            *   Check if the neighbor is within the grid boundaries.
            *   Check if the neighbor has *not* been visited yet in this fill operation.
            *   Check if the neighbor's color in the temporary grid is the background color.
            *   If all checks pass:
                *   Change the neighbor's color in the temporary grid to the potential 'fill color'.
                *   Mark the neighbor as visited.
                *   Enqueue/push the neighbor's coordinate.
    f.  After the flood fill process for the potential 'fill color' completes (the queue/stack is empty), compare the resulting temporary grid with the target output grid provided in the example.
    g.  If the temporary grid matches the target output grid, then the current potential 'fill color' is the correct one. Store this temporary grid as the final result and stop the iteration.
5.  Return the final result grid.
```python
import numpy as np
from collections import deque

"""
The transformation identifies a background color (most frequent color) and several non-background colors forming shapes or boundaries. 
It then determines a specific 'fill color' from the non-background colors. 
This fill color expands (flood fills) into adjacent background-colored areas. 
The expansion is constrained by the grid boundaries and any other non-background colors, which act as barriers.
The final output grid shows the result of this constrained flood fill, with the original boundary colors and the expanded fill color replacing the background color in the filled regions.

The fill color appears to be the unique non-background color that has adjacent background pixels it can expand into, considering other non-background colors as impassable boundaries.
"""

def find_background_color(grid):
    """Identifies the most frequent color as the background."""
    unique_colors, counts = np.unique(grid, return_counts=True)
    background_color = unique_colors[np.argmax(counts)]
    return background_color

def get_non_background_colors(grid, background_color):
    """Finds all unique colors that are not the background color."""
    unique_colors = np.unique(grid)
    non_background_colors = set(unique_colors) - {background_color}
    return non_background_colors

def find_potential_fill_candidates(grid, background_color, non_background_colors):
    """Identifies non-background colors adjacent to the background color."""
    rows, cols = grid.shape
    candidates = set()
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            if color in non_background_colors:
                # Check cardinal neighbors
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        if grid[nr, nc] == background_color:
                            candidates.add(color)
                            break # Found one background neighbor, no need to check others for this pixel
    return candidates


def flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):
    """Performs a flood fill on the grid."""
    rows, cols = grid.shape
    output_grid = np.copy(grid)
    q = deque(start_coords)
    visited = set(start_coords)

    while q:
        r, c = q.popleft()

        # Explore cardinal neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue

            # Check if visited
            if (nr, nc) in visited:
                continue

            neighbor_color = output_grid[nr, nc]

            # Check if it's background color (target for filling)
            if neighbor_color == background_color:
                output_grid[nr, nc] = fill_color
                visited.add((nr, nc))
                q.append((nr, nc))
            # Implicitly, if neighbor_color is in boundary_colors or is the fill_color itself,
            # we don't add it to the queue, effectively stopping the fill at boundaries.

    return output_grid


def transform(input_grid):
    """
    Applies a constrained flood fill transformation.

    1. Identifies background, non-background, and the specific fill color.
    2. Performs flood fill from the fill color pixels into the background color.
    3. Other non-background colors act as boundaries.
    """
    # Make a copy to avoid modifying the original input
    grid = np.array(input_grid)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # 1. Identify colors
    background_color = find_background_color(grid)
    non_background_colors = get_non_background_colors(grid, background_color)

    if not non_background_colors:
        # No non-background colors, nothing to fill
        return output_grid

    # 2. Determine the fill color
    # Assumption: The fill color is the unique non-background color adjacent to the background color.
    # This holds for the training examples.
    potential_fillers = find_potential_fill_candidates(grid, background_color, non_background_colors)

    # Heuristic: If exactly one color can expand, that's our fill color.
    # If multiple or none can expand, the logic might be different, but based on examples, assume one.
    if len(potential_fillers) != 1:
         # Fallback or error? Based on examples, assume this doesn't happen or means no change.
         # Let's refine this: Try each potential filler and see which one produces a change.
         # If only one produces a change from the input, use that one.
         # For now, stick to the simpler heuristic derived from observation.
         # If there are no potential fillers (e.g., everything is enclosed), return original.
         if len(potential_fillers) == 0:
             return output_grid
         # If ambiguity (>1), we can't be sure based on current logic. Return original.
         # print(f"Warning: Found {len(potential_fillers)} potential fill candidates: {potential_fillers}. Cannot determine unique fill color.")
         # Forcing the first one for now if ambiguous, might need better logic later.
         # A better approach might be to simulate fill for each and see which one modifies the grid.
         # Or, maybe the one *inside* the boundaries is the fill color.
         # Let's stick to the len==1 assumption derived from examples for now.
         # If this fails tests, we'll need to revisit the fill color selection.
         # Returning original grid if ambiguous.
         return output_grid # Or raise an error, or try a more complex heuristic


    fill_color = list(potential_fillers)[0]
    boundary_colors = non_background_colors - {fill_color}

    # 3. Find starting points for the flood fill
    start_coords = []
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == fill_color:
                start_coords.append((r, c))

    if not start_coords:
        # Fill color identified, but no pixels of that color exist? Should not happen based on candidate logic.
        return output_grid

    # 4. Perform the flood fill
    output_grid = flood_fill(grid, start_coords, fill_color, background_color, boundary_colors)

    return output_grid.tolist() # Return as list of lists per ARC standard

```
```python
import numpy as np
from collections import deque
from collections import Counter

"""
The transformation identifies the most frequent color in the input grid as the background color. 
It then identifies all other colors as non-background colors. 
The core logic involves determining a single 'fill color' from the set of non-background colors. 
This fill color performs a flood fill operation, starting from its initial positions, expanding into adjacent cells containing the background color. 
The expansion is blocked by the grid boundaries and by any cells containing other non-background colors (which act as boundary colors).

The specific fill color is determined implicitly: the transformation that occurs is the one resulting from a flood fill using one of the non-background colors as the source/fill color and the rest as boundaries. 
Since we don't have the target output for the test case, we assume the correct fill is the one that results in a grid different from the input grid. If multiple potential fills change the grid, or none do, this logic might be incomplete, but it matches the pattern observed in the training examples where only one color effectively fills.
"""

def find_background_color(grid):
    """Identifies the most frequent color as the background."""
    if grid.size == 0:
        return 0 # Default background for empty grid
    unique_colors, counts = np.unique(grid, return_counts=True)
    if len(counts) == 0:
         return 0 # Should not happen with non-empty grid, but safer
    background_color = unique_colors[np.argmax(counts)]
    return int(background_color) # Ensure python int

def get_non_background_colors(grid, background_color):
    """Finds all unique colors that are not the background color."""
    unique_colors = np.unique(grid)
    non_background_colors = {int(c) for c in unique_colors if c != background_color}
    return non_background_colors

def flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):
    """
    Performs a flood fill on a copy of the grid.
    
    Args:
        grid (np.array): The input grid state.
        start_coords (list): List of (r, c) tuples where the fill starts.
        fill_color (int): The color to fill with.
        background_color (int): The color to replace.
        boundary_colors (set): Set of colors that block the fill.

    Returns:
        np.array: A new grid with the flood fill applied.
    """
    rows, cols = grid.shape
    output_grid = np.copy(grid) # Work on a copy
    q = deque(start_coords)
    
    # Initialize visited set with start coordinates to avoid re-processing them
    # and ensure they are treated correctly if adjacent to background.
    visited = set(start_coords) 

    while q:
        r, c = q.popleft()

        # Explore cardinal neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue

            # Check if already visited
            if (nr, nc) in visited:
                continue

            neighbor_color = output_grid[nr, nc]

            # Check if it's background color (target for filling)
            if neighbor_color == background_color:
                output_grid[nr, nc] = fill_color
                visited.add((nr, nc)) # Mark as visited *after* processing
                q.append((nr, nc))
            # If neighbor_color is a boundary or the fill color itself, add to visited
            # to prevent re-checking, but don't add to queue.
            elif neighbor_color in boundary_colors or neighbor_color == fill_color:
                 visited.add((nr, nc))
            # Any other color (e.g. background color already processed)
            # Add to visited to prevent re-queueing
            else:
                 visited.add((nr, nc))


    return output_grid


def transform(input_grid_list):
    """
    Applies the selective flood fill transformation.
    Identifies background, non-background colors.
    Simulates flood fill for each non-background color.
    Returns the result of the fill that changes the grid compared to the input.
    If no fill changes the grid, or multiple do, returns the original grid based on ambiguity.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    rows, cols = input_grid.shape
    
    # 1. Identify background and non-background colors
    background_color = find_background_color(input_grid)
    non_background_colors = get_non_background_colors(input_grid, background_color)

    # If no non-background colors, no fill can happen
    if not non_background_colors:
        return input_grid_list

    possible_outputs = []
    
    # 2. Simulate fill for each non-background color as potential fill color
    for potential_fill_color in non_background_colors:
        # Define boundaries for this simulation
        boundary_colors = non_background_colors - {potential_fill_color}
        
        # Find starting points for this potential fill color
        start_coords = []
        for r in range(rows):
            for c in range(cols):
                if input_grid[r, c] == potential_fill_color:
                    start_coords.append((r, c))

        # If this color exists in the grid, perform the fill simulation
        if start_coords:
            candidate_output_grid = flood_fill(
                input_grid, 
                start_coords, 
                potential_fill_color, 
                background_color, 
                boundary_colors
            )
            # Check if this simulation actually changed the grid
            if not np.array_equal(input_grid, candidate_output_grid):
                possible_outputs.append(candidate_output_grid)

    # 3. Select the correct transformation result
    # Based on training examples, assume only one fill operation results in a change.
    if len(possible_outputs) == 1:
        # Convert the result back to list of lists
        return possible_outputs[0].tolist()
    else:
        # If zero or more than one fill caused a change, the rule is ambiguous
        # based on the examples. Return the original grid.
        # print(f"Ambiguous transformation: {len(possible_outputs)} fills changed the grid. Returning original.")
        return input_grid_list
```
