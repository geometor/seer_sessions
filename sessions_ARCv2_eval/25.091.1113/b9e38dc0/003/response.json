{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies the most frequent color in the input grid as the background color. \nIt then identifies all other colors as non-background colors. \nThe core logic involves determining a single 'fill color' from the set of non-background colors. \nThis fill color performs a flood fill operation, starting from its initial positions, expanding into adjacent cells containing the background color. \nThe expansion is blocked by the grid boundaries and by any cells containing other non-background colors (which act as boundary colors).\n\nThe specific fill color is determined implicitly: the transformation that occurs is the one resulting from a flood fill using one of the non-background colors as the source/fill color and the rest as boundaries. \nSince we don't have the target output for the test case, we assume the correct fill is the one that results in a grid different from the input grid. If multiple potential fills change the grid, or none do, this logic might be incomplete, but it matches the pattern observed in the training examples where only one color effectively fills.\n\"\"\"\n\ndef find_background_color(grid):\n    \"\"\"Identifies the most frequent color as the background.\"\"\"\n    if grid.size == 0:\n        return 0 # Default background for empty grid\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    if len(counts) == 0:\n         return 0 # Should not happen with non-empty grid, but safer\n    background_color = unique_colors[np.argmax(counts)]\n    return int(background_color) # Ensure python int\n\ndef get_non_background_colors(grid, background_color):\n    \"\"\"Finds all unique colors that are not the background color.\"\"\"\n    unique_colors = np.unique(grid)\n    non_background_colors = {int(c) for c in unique_colors if c != background_color}\n    return non_background_colors\n\ndef flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):\n    \"\"\"\n    Performs a flood fill on a copy of the grid.\n    \n    Args:\n        grid (np.array): The input grid state.\n        start_coords (list): List of (r, c) tuples where the fill starts.\n        fill_color (int): The color to fill with.\n        background_color (int): The color to replace.\n        boundary_colors (set): Set of colors that block the fill.\n\n    Returns:\n        np.array: A new grid with the flood fill applied.\n    \"\"\"\n    rows, cols = grid.shape\n    output_grid = np.copy(grid) # Work on a copy\n    q = deque(start_coords)\n    \n    # Initialize visited set with start coordinates to avoid re-processing them\n    # and ensure they are treated correctly if adjacent to background.\n    visited = set(start_coords) \n\n    while q:\n        r, c = q.popleft()\n\n        # Explore cardinal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue\n\n            # Check if already visited\n            if (nr, nc) in visited:\n                continue\n\n            neighbor_color = output_grid[nr, nc]\n\n            # Check if it's background color (target for filling)\n            if neighbor_color == background_color:\n                output_grid[nr, nc] = fill_color\n                visited.add((nr, nc)) # Mark as visited *after* processing\n                q.append((nr, nc))\n            # If neighbor_color is a boundary or the fill color itself, add to visited\n            # to prevent re-checking, but don't add to queue.\n            elif neighbor_color in boundary_colors or neighbor_color == fill_color:\n                 visited.add((nr, nc))\n            # Any other color (e.g. background color already processed)\n            # Add to visited to prevent re-queueing\n            else:\n                 visited.add((nr, nc))\n\n\n    return output_grid\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the selective flood fill transformation.\n    Identifies background, non-background colors.\n    Simulates flood fill for each non-background color.\n    Returns the result of the fill that changes the grid compared to the input.\n    If no fill changes the grid, or multiple do, returns the original grid based on ambiguity.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n    \n    # 1. Identify background and non-background colors\n    background_color = find_background_color(input_grid)\n    non_background_colors = get_non_background_colors(input_grid, background_color)\n\n    # If no non-background colors, no fill can happen\n    if not non_background_colors:\n        return input_grid_list\n\n    possible_outputs = []\n    \n    # 2. Simulate fill for each non-background color as potential fill color\n    for potential_fill_color in non_background_colors:\n        # Define boundaries for this simulation\n        boundary_colors = non_background_colors - {potential_fill_color}\n        \n        # Find starting points for this potential fill color\n        start_coords = []\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r, c] == potential_fill_color:\n                    start_coords.append((r, c))\n\n        # If this color exists in the grid, perform the fill simulation\n        if start_coords:\n            candidate_output_grid = flood_fill(\n                input_grid, \n                start_coords, \n                potential_fill_color, \n                background_color, \n                boundary_colors\n            )\n            # Check if this simulation actually changed the grid\n            if not np.array_equal(input_grid, candidate_output_grid):\n                possible_outputs.append(candidate_output_grid)\n\n    # 3. Select the correct transformation result\n    # Based on training examples, assume only one fill operation results in a change.\n    if len(possible_outputs) == 1:\n        # Convert the result back to list of lists\n        return possible_outputs[0].tolist()\n    else:\n        # If zero or more than one fill caused a change, the rule is ambiguous\n        # based on the examples. Return the original grid.\n        # print(f\"Ambiguous transformation: {len(possible_outputs)} fills changed the grid. Returning original.\")\n        return input_grid_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24464,
    "candidates_token_count": 1563,
    "total_token_count": 26027,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.410808,
  "retries": 1
}