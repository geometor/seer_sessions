
## train_1

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 7 7 7 7 7 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 2 2 2 2 2 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 7 6 7
7 7 6 6 6 6 6 7 7 7 6 6 6 6
7 7 6 2 2 2 6 7 7 7 6 2 2 2
6 6 6 6 6 6 6 7 7 7 6 7 7 7
2 2 2 2 2 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 7 7 7 6 7 7 7
7 7 7 7 7 6 6 6 6 6 6 6 6 6
7 7 7 7 7 6 6 2 2 2 2 2 2 2
7 6 6 6 6 6 6 6 7 7 7 7 7 7
7 6 2 2 2 2 2 6 7 7 7 7 7 7
7 6 7 7 6 6 6 6 6 6 6 6 7 7
7 6 7 7 6 2 2 2 2 2 2 6 7 7
7 6 7 7 6 7 7 7 7 7 7 6 7 7
```


## train_2

**input:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 2 2 2 2 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 7 7 7 6 7
7 7 7 7 6 7 7 7 6 6 6 6 7
7 7 7 7 6 7 7 7 6 2 2 2 2
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
7 7 7 7 6 7 7 7 6 7 7 7 7
6 6 6 6 6 6 7 7 6 7 7 7 7
6 2 2 2 2 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 7 7 6 7 7 6 7 7 7 7
6 7 7 6 6 6 6 6 6 7 7 7 7
6 7 7 6 2 2 2 2 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
6 7 7 6 7 7 7 7 6 7 7 7 7
```


## train_3

**input:**
```
7 7 6 7 7 7 7 2 2
7 7 6 7 7 7 7 2 7
7 2 2 2 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 7 7 7
```


**output:**
```
7 7 6 7 7 7 7 2 2
6 6 6 6 6 7 7 2 7
6 2 2 2 6 7 7 7 7
6 7 7 7 6 7 7 7 7
6 7 6 6 6 6 6 6 7
6 7 6 2 2 2 2 6 7
6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 6 6 7
```


## train_4

**input:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 7 7
7 7 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
7 7 7 7 7
2 2 2 7 2
7 7 7 7 7
7 7 2 2 2
7 7 7 7 7
```


**output:**
```
7 7 7 6 7
2 2 2 6 2
7 7 7 6 7
7 7 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
7 6 7 7 7
7 6 7 7 7
6 6 6 6 7
2 2 2 6 2
7 6 6 6 6
7 6 2 2 2
7 6 7 7 7
```


## train_5

**input:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 7 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 6 6 6 6 6
7 7 7 7 7 7 2 2 2 2 7 7 7 7 7 6 2 2 2 2
7 7 2 2 2 2 7 7 7 7 7 7 6 6 6 6 6 6 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 2 2 2 2 2 6 7
7 7 7 7 7 7 7 7 7 7 7 7 6 7 7 7 7 7 6 7
```


## train_6

**input:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 2 2 2 2 2 2 2 2 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 2 2 2 2 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 2 2 2 2 2 2 2 2 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
2 2 7 7 2 2 2 2 2 2 2 2 2 2 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
2 2 2 2 2 2 6 7 7 2 2 2 2 2 2 2
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 7
7 7 7 6 6 6 6 6 6 6 6 6 6 6 7 7
7 7 7 6 2 2 2 2 2 2 2 2 2 6 7 7
7 7 7 6 7 7 7 7 7 7 7 7 7 6 7 7
6 6 6 6 6 6 6 6 6 6 6 7 7 6 7 7
2 2 2 2 2 2 2 2 2 2 6 7 7 6 7 7
7 7 7 7 7 7 7 7 7 7 6 7 7 6 7 7
7 7 7 7 7 7 6 6 6 6 6 6 6 6 6 6
7 7 7 7 7 7 6 2 2 2 2 2 2 2 2 6
7 7 7 7 7 7 6 7 7 7 7 7 7 7 7 6
7 7 7 6 6 6 6 6 6 6 6 6 6 6 6 6
2 2 7 6 2 2 2 2 2 2 2 2 2 2 6 6
7 7 7 6 7 7 7 7 7 7 7 7 7 7 6 6
```

**Perception:**

1.  **Colors:** The primary colors involved are orange (7), magenta (6), and red (2). Orange appears to be the background color. Magenta is present in the input as vertical lines and is the color used for filling in the output. Red forms various shapes scattered across the grid.
2.  **Input Structure:** The input grid contains one or more red objects and one or two distinct vertical lines composed entirely of magenta pixels. These magenta lines always span the full height of the grid. The rest of the grid is typically filled with the orange background color.
3.  **Output Structure:** The output grid is the input grid modified by changing some orange pixels to magenta. The original red objects and magenta lines remain unchanged.
4.  **Transformation:** The transformation involves identifying a specific region based on the vertical magenta lines and the locations of the red objects, and then filling the orange pixels within that region with magenta.
5.  **Region Identification:**
    *   **Vertical Boundaries:** The vertical magenta lines in the input define the vertical boundaries of the region to be filled.
        *   If two magenta lines exist, the region is between these two lines (inclusive of the columns containing the lines).
        *   If only one magenta line exists, the region is between that line (inclusive) and the closest vertical edge of the grid (left or right edge). The side chosen (left or right of the single line) is the one containing red objects. More precisely, it seems to be the area from the grid edge *up to* the single magenta line, encompassing any red objects found in that span.
        *   If no magenta lines exist (though not shown in examples, consider this edge case), maybe no filling occurs, or it fills based only on red objects. The examples all have lines, so we focus on that.
    *   **Horizontal Boundaries:** Within the vertically defined columns, the horizontal boundaries (top and bottom rows) of the fill region are determined by the minimum and maximum row indices containing any red pixels within those specific columns.
6.  **Filling Process:** All pixels that are originally orange (7) within the identified rectangular region (defined by the vertical boundaries from magenta lines/edges and horizontal boundaries from red objects) are changed to magenta (6). Pixels that are already red (2) or part of the original magenta (6) lines within this region remain unchanged.

**Facts:**


```yaml
elements:
  - object: grid
    attributes:
      - background_color: orange (7)
      - contains: [red_object, magenta_line]
  - object: red_object
    attributes:
      - color: red (2)
      - shape: variable (contiguous blocks)
      - role: defines horizontal extent of the fill area
  - object: magenta_line
    attributes:
      - color: magenta (6)
      - shape: vertical line spanning grid height
      - quantity: 1 or 2
      - role: defines vertical extent of the fill area
  - object: fill_area
    attributes:
      - color: magenta (6) (replaces orange (7))
      - location: determined by magenta_lines and red_objects
relationships:
  - type: boundary_definition
    source: magenta_line(s)
    target: fill_area
    details: >
      Magenta lines define the column range. If two lines, fill between them.
      If one line, fill between the line and the nearest grid edge that contains red objects within that span.
  - type: boundary_definition
    source: red_object(s)
    target: fill_area
    details: >
      Within the columns defined by magenta lines, the min/max row of any red pixel
      defines the row range for the fill_area.
actions:
  - action: identify_magenta_lines
    inputs: [input_grid]
    outputs: [list_of_line_columns, line_count]
  - action: determine_vertical_bounds
    inputs: [list_of_line_columns, line_count, grid_width]
    outputs: [min_col, max_col]
  - action: identify_red_pixels_in_vertical_bounds
    inputs: [input_grid, min_col, max_col]
    outputs: [list_of_red_pixel_rows]
  - action: determine_horizontal_bounds
    inputs: [list_of_red_pixel_rows]
    outputs: [min_row, max_row]
    condition: requires at least one red pixel in the vertical bounds
  - action: fill_region
    inputs: [input_grid, min_col, max_col, min_row, max_row]
    outputs: [output_grid]
    details: Change orange (7) pixels to magenta (6) within the rectangle defined by (min_row, min_col) and (max_row, max_col).
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all columns that consist entirely of magenta (6) pixels (these are the vertical magenta lines). Store their column indices.
3.  Determine the vertical range (minimum and maximum column indices) for the potential fill area based on the identified magenta lines:
    *   If two magenta lines are found at columns `c1` and `c2` (where `c1 < c2`), the vertical range is from `c1` to `c2`, inclusive.
    *   If one magenta line is found at column `c`, determine which side (left or right) relative to this line contains red (2) pixels.
        *   Check for red pixels in columns `0` to `c`. If found, the vertical range is `0` to `c`, inclusive.
        *   Check for red pixels in columns `c` to `grid_width - 1`. If found, the vertical range is `c` to `grid_width - 1`, inclusive. (Assume red pixels won't exist on both sides relative to a single line based on examples). If red pixels exist both left and right (or if only one side is checked and is positive), assume the range is from the line to the nearest edge encompassing red pixels. *Refinement based on examples:* If one line at `c` exists, the range seems to be columns `0` to `c` *if* red pixels exist in that range, OR columns `c` to `grid_width-1` *if* red pixels exist in *that* range. The examples suggest it fills the side containing the red pixels, bounded by the line and the grid edge.
    *   If no magenta lines are found, no filling occurs (the output is identical to the input).
4.  If a vertical range (`min_col`, `max_col`) was determined:
    *   Find all red (2) pixels within this vertical range (columns `min_col` to `max_col`).
    *   If no red pixels are found within this range, no filling occurs.
    *   If red pixels are found, determine the minimum (`min_row`) and maximum (`max_row`) row indices among these red pixels.
    *   Iterate through all cells in the output grid within the rectangle defined by `min_row`, `max_row`, `min_col`, `max_col`.
    *   If a cell's color in the original input grid at this location `(row, col)` is orange (7), change its color in the output grid to magenta (6).
5.  Return the modified output grid.
```python
import numpy as np

"""
Identifies vertical magenta lines (color 6) that span the grid height.
Determines a vertical column range based on these lines:
- If two lines are found at c1 and c2 (c1 < c2), the range is [c1, c2].
- If one line is found at c, the range is [0, c] if red pixels (color 2) exist in columns 0 to c-1,
  or [c, width-1] if red pixels exist in columns c+1 to width-1. If red pixels exist on both sides
  (not observed in examples), or only within column c, the behavior is based on the side with red pixels closest to the line or potentially favoring one side if ambiguous (let's assume it picks the side containing any red pixel). The implementation will check left first, then right.
- If no lines are found, no changes are made.

Within the determined vertical column range [min_col, max_col]:
- Find all red pixels (color 2).
- If red pixels are found, determine the minimum (min_row) and maximum (max_row) row index among them.
- Fill the rectangular region defined by [min_row, max_row] and [min_col, max_col]
  by changing all orange pixels (color 7) within this rectangle to magenta (color 6).
  Existing red and magenta pixels within the region remain unchanged.
"""

def find_magenta_lines(grid):
    """Finds columns composed entirely of magenta (6)."""
    height, width = grid.shape
    line_cols = []
    for c in range(width):
        if np.all(grid[:, c] == 6):
            line_cols.append(c)
    return line_cols

def transform(input_grid):
    """
    Applies the described transformation to the input grid.
    """
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # 1. Identify vertical magenta lines
    magenta_line_cols = find_magenta_lines(input_grid)
    num_lines = len(magenta_line_cols)

    min_col = -1
    max_col = -1

    # 2. Determine the vertical range (columns) for filling
    if num_lines == 2:
        min_col = magenta_line_cols[0]
        max_col = magenta_line_cols[1]
    elif num_lines == 1:
        line_col = magenta_line_cols[0]
        # Check for red pixels to the left of the line
        red_exists_left = np.any(input_grid[:, 0:line_col] == 2)
        # Check for red pixels to the right of the line
        red_exists_right = np.any(input_grid[:, line_col+1:width] == 2)
        # Check for red pixels within the line column itself (might be relevant if no red outside)
        # red_exists_in_line_col = np.any(input_grid[:, line_col] == 2) # Unused for now based on examples

        if red_exists_left:
             min_col = 0
             max_col = line_col
        elif red_exists_right:
             min_col = line_col
             max_col = width - 1
        # If red exists only IN the line column, or neither side (edge case not in examples)
        # Current logic based on examples implies fill happens towards the side WITH red pixels.
        # If neither side has red pixels strictly outside the line, no fill based on examples.
        # Let's refine: If red is *only* on the left, fill left. If *only* on the right, fill right.
        # If red is on *both* sides (unlikely per examples), need tie-break - let's stick to the first found side (left)
        # If red is *neither* left nor right (could be in the line col, or nowhere), no fill.
        if not red_exists_left and not red_exists_right:
             # Check if any red pixels exist within the column bounds defined by the line itself
             # If red pixels *only* exist within the line column c, the examples don't clearly define behaviour.
             # Example 4 has red inside the column bounds [3, 4] and the fill happens there.
             # Example 3 has red inside the column bounds [0, 2] and the fill happens there.
             # Let's assume if red exists *anywhere* relative to the line, we pick that side.
             # Re-evaluating the single line case based on observation:
             # It seems sufficient to check if ANY red pixel exists left of OR AT the line column when setting the left boundary,
             # and ANY red pixel exists right of OR AT the line column when setting the right boundary.

             red_indices_left_or_at = np.argwhere(input_grid[:, 0:line_col+1] == 2)
             red_indices_right_or_at = np.argwhere(input_grid[:, line_col:width] == 2)

             if red_indices_left_or_at.size > 0:
                 min_col = 0
                 max_col = line_col
             elif red_indices_right_or_at.size > 0:
                 min_col = line_col
                 max_col = width - 1
             # If still no red found relative to the line, do nothing.


    elif num_lines == 0:
        # No magenta lines, return the original grid
        return output_grid
    # else num_lines > 2 is not expected based on examples

    # If no valid column range was determined (e.g., single line with no relevant red pixels)
    if min_col == -1 or max_col == -1:
        return output_grid

    # 3. Find red pixels within the determined vertical range [min_col, max_col]
    red_pixel_rows = []
    # Iterate only through the selected columns
    for c in range(min_col, max_col + 1):
        for r in range(height):
            if input_grid[r, c] == 2:
                red_pixel_rows.append(r)

    # 4. Determine horizontal bounds if red pixels were found
    if not red_pixel_rows:
        # No red pixels found in the relevant columns, no fill needed
        return output_grid

    min_row = min(red_pixel_rows)
    max_row = max(red_pixel_rows)

    # 5. Fill the identified region
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            # Check the original input grid's color
            if input_grid[r, c] == 7: # If orange
                output_grid[r, c] = 6 # Change to magenta

    return output_grid
```
