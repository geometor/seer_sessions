
## train_1

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 4 4 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 9 9 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 4 4 7 7 7 7
7 7 7 7 9 9 9 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 9 9 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 9 9 9 9 9 7 0 0 0 0 0 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 9 9 9 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 2 2 2 2 7 7 7 7 7 7 7 3 3 3 3 3 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 5 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 5 5 5 5 5 7 7 7 7 7 7 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 5 5 5 7 7 7 7 7 7 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 5 5 5 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 5 5 5 5 5 7 0 0 0 0 0 7 1 1 1 1 1 7 4 4 4 4 4 7 7 7 7
7 7 7 7 5 5 5 7 7 7 0 0 0 7 7 7 1 1 1 7 7 7 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 6 6 6 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 6 6 6 6 6 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 6 6 6 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 5 5 5 1 1 1 1 1
1 1 1 0 0 0 0 0 1 8 8 8 8 8 1 4 4 4 4 4 1 5 5 5 5 5 1 1 1 1
1 1 1 1 0 0 0 1 1 1 8 8 8 1 1 1 4 4 4 1 1 1 5 5 5 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 3 3 3 3 3 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 3 3 3 3 3 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 0 0 0 6 6 6 6 6
6 6 6 7 7 7 7 7 6 2 2 2 2 2 6 3 3 3 3 3 6 0 0 0 0 0 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 3 3 3 6 6 6 0 0 0 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 3 3 3 3 3 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 2 2 2 2 2 6 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 0 0 0 6 6 6 6 6
6 6 6 7 7 7 7 7 6 2 2 2 2 2 6 5 5 5 5 5 6 0 0 0 0 0 6 6 6 6
6 6 6 6 7 7 7 6 6 6 2 2 2 6 6 6 5 5 5 6 6 6 0 0 0 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```

*   **Perception of task elements:**
    *   The input and output grids are the same size (30x30).
    *   Each grid has a dominant background color (Orange=7 in train\_1, Blue=1 in train\_2, Magenta=6 in train\_3).
    *   The input grids contain multiple distinct objects, primarily 5-pixel plus-shapes (+) and 5-pixel horizontal lines (-).
    *   The transformation involves selective removal of some objects and color changes of others, while leaving the rest unchanged.
    *   Specifically, horizontal line objects of certain colors (Red=2, Green=3) are removed (replaced by the background color).
    *   Plus-shaped objects of certain colors (Maroon=9, Magenta=6, Green=3) are changed to Gray (5).
    *   Other plus-shaped objects retain their original colors.

*   **YAML facts:**
    
```yaml
    background_color:
      description: The dominant color filling most of the grid.
      input_train_1: 7 # Orange
      output_train_1: 7 # Orange
      input_train_2: 1 # Blue
      output_train_2: 1 # Blue
      input_train_3: 6 # Magenta
      output_train_3: 6 # Magenta
      transformation: Remains unchanged.
    objects:
      description: Contiguous blocks of non-background colors.
      types:
        - shape: plus # 5 pixels in a '+' configuration
        - shape: horizontal_line # 5 pixels in a '-' configuration
      actions:
        - condition:
            shape: horizontal_line
            color: [2, 3] # Red, Green
          effect: remove # Replace with background color
        - condition:
            shape: plus
            color: [9, 6, 3] # Maroon, Magenta, Green
          effect: change_color # Replace color with Gray (5)
        - condition:
            shape: plus
            color: [0, 1, 2, 4, 7, 8] # White, Blue, Red, Yellow, Orange, Azure
          effect: keep # No change
    grid_size:
      description: Dimensions of the input and output grids.
      value: 30x30
      transformation: Remains unchanged.
    ```


*   **Natural Language Program:**
    1.  Identify the background color of the input grid (the most frequent color).
    2.  Create an output grid initialized with the same background color and dimensions as the input grid.
    3.  Find all distinct objects (contiguous groups of pixels with the same non-background color) in the input grid.
    4.  For each identified object:
        a.  Determine the shape of the object.
        b.  Determine the color of the object.
        c.  If the object is a 5-pixel horizontal line and its color is Red (2) or Green (3), do nothing (it remains background color in the output).
        d.  If the object is a 5-pixel plus-shape and its color is Maroon (9), Magenta (6), or Green (3), copy the object's shape to the corresponding position in the output grid, but change its color to Gray (5).
        e.  If the object is a 5-pixel plus-shape and its color is *not* Maroon (9), Magenta (6), or Green (3), copy the object (shape and original color) to the corresponding position in the output grid.
        f.  Ignore any other object shapes or colors not explicitly mentioned above (though none appear in the examples).
    5.  Return the final output grid.
```python
import numpy as np
from collections import Counter, deque

# Color constants based on the problem description (mapping not strictly needed for logic but good for reference)
# COLOR_MAP = {
#     0: 'white', 1: 'blue', 2: 'red', 3: 'green', 4: 'yellow',
#     5: 'gray', 6: 'magenta', 7: 'orange', 8: 'azure', 9: 'maroon',
# }

# Colors to be modified or removed
PLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray
LINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed
GRAY_COLOR = 5

def _find_background_color(grid):
    """Finds the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Handle empty grid case if necessary, though ARC constraints likely prevent this
    if not counts:
        return 0 # Default to white if grid is empty
    # Find the color with the highest count
    background_color = counts.most_common(1)[0][0]
    return background_color

def _find_objects(grid, background_color):
    """Finds all connected objects of non-background colors."""
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            # If pixel is not background and not yet visited, start BFS
            if grid[r, c] != background_color and not visited[r, c]:
                obj_color = grid[r, c]
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True

                while q:
                    row, col = q.popleft()
                    obj_coords.add((row, col))

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if neighbor has the same color and not visited
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == obj_color:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                if obj_coords:
                    objects.append({'color': obj_color, 'coords': obj_coords})
    return objects

def _check_shape(coords):
    """Determines if the object shape is a 5-pixel plus or horizontal line."""
    if len(coords) != 5:
        return None # Only considering 5-pixel shapes based on examples

    rows = [r for r, c in coords]
    cols = [c for r, c in coords]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    height = max_r - min_r + 1
    width = max_c - min_c + 1

    # Check for 3x3 bounding box (characteristic of a plus)
    if height == 3 and width == 3:
        # Verify it's a plus shape (center must exist and have 4 neighbors)
        center_r = min_r + 1
        center_c = min_c + 1
        if (center_r, center_c) in coords and \
           (center_r - 1, center_c) in coords and \
           (center_r + 1, center_c) in coords and \
           (center_r, center_c - 1) in coords and \
           (center_r, center_c + 1) in coords:
            return "plus"

    # Check for 1x5 bounding box (characteristic of a horizontal line)
    if height == 1 and width == 5:
         # Verify all 5 pixels are present consecutively
        expected_coords = set((min_r, c) for c in range(min_c, max_c + 1))
        if coords == expected_coords:
             return "horizontal_line"

    # Potentially add check for vertical line (5x1) if needed, but not in examples

    return None # Unknown 5-pixel shape

def transform(input_grid):
    """
    Transforms the input grid based on specific object shapes and colors.
    - Identifies the background color.
    - Finds all non-background objects (connected components).
    - Determines the shape of each 5-pixel object (plus or horizontal line).
    - Applies rules:
        - Removes 5-pixel horizontal lines if they are Red (2) or Green (3).
        - Changes the color of 5-pixel plus shapes to Gray (5) if they are
          Maroon (9), Magenta (6), or Green (3).
        - Keeps all other identified objects unchanged.
    - Returns the transformed grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)

    # 1. Identify the background color
    background_color = _find_background_color(input_grid_np)

    # 2. Create an output grid initialized with the background color
    output_grid = np.full_like(input_grid_np, background_color)

    # 3. Find all distinct objects
    objects = _find_objects(input_grid_np, background_color)

    # 4. Process each object
    for obj in objects:
        color = obj['color']
        coords = obj['coords']

        # 4a. Determine the shape
        shape = _check_shape(coords)

        # 4b. Apply transformation rules based on shape and color
        if shape == "horizontal_line" and color in LINE_TO_REMOVE_COLORS:
            # Do nothing - pixels remain background color in output_grid
            pass
        elif shape == "plus" and color in PLUS_TO_GRAY_COLORS:
            # Change color to Gray
            for r, c in coords:
                output_grid[r, c] = GRAY_COLOR
        else:
            # Keep the object as is (copy its pixels to the output grid)
            # This covers plus shapes of other colors, horizontal lines of other colors,
            # and any shapes not explicitly handled (though examples only show these two)
            for r, c in coords:
                output_grid[r, c] = color

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
```python
"""
Transforms an input grid based on specific rules applied to 5-pixel objects.
1. Identifies the background color (most frequent color).
2. Creates an output grid filled with the background color.
3. Finds all connected objects of non-background colors.
4. Filters for objects consisting of exactly 5 pixels.
5. Determines the shape of each 5-pixel object ('plus' or 'horizontal_line').
6. Applies rules:
   - Removes 5-pixel horizontal lines if they are Red (2) or Green (3) by leaving them as the background color.
   - Changes the color of 5-pixel plus shapes to Gray (5) if they are Maroon (9), Magenta (6), or Green (3).
   - Keeps all other identified 5-pixel plus or horizontal line shapes unchanged (copies their original color to the output).
"""

import numpy as np
from collections import Counter, deque

# Define color constants for rules
PLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray
LINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed
GRAY_COLOR = 5

def _find_background_color(grid):
    """Finds the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Handle empty grid case if necessary
    if not counts:
        return 0 # Default to white if grid is empty
    # Find the color with the highest count
    background_color = counts.most_common(1)[0][0]
    return background_color

def _find_objects(grid, background_color):
    """Finds all connected objects of non-background colors using BFS."""
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            # If pixel is not background and not yet visited, start BFS
            if grid[r, c] != background_color and not visited[r, c]:
                obj_color = grid[r, c]
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True

                while q:
                    row, col = q.popleft()
                    obj_coords.add((row, col))

                    # Check 4 neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds and if neighbor has the same color and not visited
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == obj_color:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                if obj_coords:
                    objects.append({'color': obj_color, 'coords': obj_coords})
    return objects

def _check_shape(coords):
    """Determines if the object shape is a 5-pixel plus or horizontal line."""
    # Rule applies only to 5-pixel objects based on examples
    if len(coords) != 5:
        return None 

    rows = sorted([r for r, c in coords])
    cols = sorted([c for r, c in coords])
    min_r, max_r = rows[0], rows[-1]
    min_c, max_c = cols[0], cols[-1]
    height = max_r - min_r + 1
    width = max_c - min_c + 1

    # Check for 3x3 bounding box (characteristic of a plus)
    if height == 3 and width == 3:
        # Verify it's a plus shape (center must exist and have 4 neighbors)
        center_r = rows[2] # Median row
        center_c = cols[2] # Median col
        # Check if the median coordinate is the center and if all expected points exist
        expected_plus_coords = {
            (center_r, center_c), 
            (center_r - 1, center_c), 
            (center_r + 1, center_c), 
            (center_r, center_c - 1), 
            (center_r, center_c + 1)
        }
        if coords == expected_plus_coords:
            return "plus"

    # Check for 1x5 bounding box (characteristic of a horizontal line)
    if height == 1 and width == 5:
         # Verify all 5 pixels are present consecutively
        expected_line_coords = set((min_r, c) for c in range(min_c, max_c + 1))
        if coords == expected_line_coords:
             return "horizontal_line"

    # Note: Vertical lines (5x1) are not present in examples, so not explicitly checked.
    
    return None # Not a recognized 5-pixel shape

def transform(input_grid):
    """
    Applies shape and color-based transformations to a grid.
    """
    # Convert input list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape

    # 1. Identify the background color
    background_color = _find_background_color(input_grid_np)

    # 2. Create an output grid initialized with the background color
    output_grid = np.full_like(input_grid_np, background_color)

    # 3. Find all distinct non-background objects
    objects = _find_objects(input_grid_np, background_color)

    # 4. Process each object
    for obj in objects:
        color = obj['color']
        coords = obj['coords']
        
        # Focus only on 5-pixel objects as per observations
        if len(coords) != 5:
            # If object size isn't 5, copy it as is (defensive programming)
            # Although examples only show 5-pixel objects being transformed
            for r, c in coords:
                 if 0 <= r < rows and 0 <= c < cols: # Ensure coords are valid
                     output_grid[r,c] = color
            continue # Skip shape check and specific rules for non-5-pixel objects

        # 4a. Determine the shape for 5-pixel objects
        shape = _check_shape(coords)

        # 4b. Apply transformation rules based on shape and color
        output_color = color # Default: keep original color

        if shape == "horizontal_line":
            if color in LINE_TO_REMOVE_COLORS:
                # Keep background color by setting output_color to it
                output_color = background_color 
            # else: keep original color (output_color = color)

        elif shape == "plus":
            if color in PLUS_TO_GRAY_COLORS:
                # Change color to Gray
                output_color = GRAY_COLOR
            # else: keep original color (output_color = color)

        # else shape is None or not 'plus'/'horizontal_line': keep original color 
        # (output_color = color)
        
        # 5. Draw the object onto the output grid with the determined output color
        # If output_color is background_color, the object is effectively removed.
        if output_color != background_color:
             for r, c in coords:
                 # Bounds check just in case, though coords should be valid
                 if 0 <= r < rows and 0 <= c < cols: 
                     output_grid[r, c] = output_color

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter

# Define color constants for rules based on observations from examples
PLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray
LINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed
GRAY_COLOR = 5

def _find_background_color(grid):
    """Finds the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Handle empty grid case if necessary
    if not counts:
        return 0 # Default to white if grid is empty
    # Find the color with the highest count
    background_color = counts.most_common(1)[0][0]
    return background_color

def _is_plus_center(grid, r, c, rows, cols, color):
    """Checks if (r, c) is the center of a 3x3 plus shape of the given color."""
    # Check bounds for a 3x3 area centered at (r, c)
    if not (0 < r < rows - 1 and 0 < c < cols - 1):
        return False
    # Check if the center and its 4 orthogonal neighbors have the specified color
    return (grid[r-1, c] == color and
            grid[r+1, c] == color and
            grid[r, c-1] == color and
            grid[r, c+1] == color)

def _is_h_line_start(grid, r, c, rows, cols, color):
    """Checks if (r, c) is the start of a 1x5 horizontal line of the given color."""
    # Check bounds for a 1x5 area starting at (r, c)
    if not (c + 4 < cols):
        return False
    # Check if the 5 pixels starting from (r, c) have the specified color
    for i in range(5):
        if grid[r, c+i] != color:
            return False
    # Optional: Ensure it's the *start* by checking the pixel to the left (if exists)
    # if c > 0 and grid[r, c-1] == color:
    #     return False # Part of a longer line or detected earlier
    return True


"""
Transforms an input grid based on specific rules applied to 5-pixel objects.
1. Identifies the background color (most frequent color).
2. Creates an output grid filled with the background color.
3. Iterates through the input grid, identifying 5-pixel plus shapes and 
   5-pixel horizontal lines.
4. Applies rules:
   - Removes 5-pixel horizontal lines if they are Red (2) or Green (3) by 
     leaving them as the background color in the output.
   - Changes the color of 5-pixel plus shapes to Gray (5) if they are 
     Maroon (9), Magenta (6), or Green (3).
   - Keeps all other identified 5-pixel plus or horizontal line shapes 
     unchanged (copies their original color to the output).
5. Uses a visited mask to avoid processing pixels multiple times.
"""
def transform(input_grid):
    # Convert input list of lists to numpy array for easier manipulation
    input_grid_np = np.array(input_grid, dtype=int)
    rows, cols = input_grid_np.shape

    # 1. Identify the background color
    background_color = _find_background_color(input_grid_np)

    # 2. Create an output grid initialized with the background color
    output_grid = np.full_like(input_grid_np, background_color)

    # 3. Create a visited mask to track processed pixels
    visited = np.zeros_like(input_grid_np, dtype=bool)

    # 4. Iterate through each pixel to find shapes
    for r in range(rows):
        for c in range(cols):
            # Skip if already processed or background
            if visited[r, c] or input_grid_np[r, c] == background_color:
                continue

            color = input_grid_np[r, c]

            # Check if it's the center of a plus shape
            if _is_plus_center(input_grid_np, r, c, rows, cols, color):
                coords = [(r, c), (r-1, c), (r+1, c), (r, c-1), (r, c+1)]
                
                # Determine output color based on rules
                output_color = GRAY_COLOR if color in PLUS_TO_GRAY_COLORS else color
                
                # Apply to output grid and mark visited
                for pr, pc in coords:
                    output_grid[pr, pc] = output_color
                    visited[pr, pc] = True
                continue # Move to next pixel in grid iteration

            # Check if it's the start of a horizontal line shape
            # Add check to ensure we only process lines starting at c or where c-1 is different
            is_actual_start = (c == 0 or input_grid_np[r, c-1] != color)
            if is_actual_start and _is_h_line_start(input_grid_np, r, c, rows, cols, color):
                coords = [(r, c+i) for i in range(5)]

                # Determine if line should be kept and its color
                output_color = background_color # Default to remove/background
                if color not in LINE_TO_REMOVE_COLORS:
                    output_color = color # Keep original color
                
                # Apply to output grid (if not removed) and mark visited
                for pr, pc in coords:
                    if output_color != background_color:
                         output_grid[pr, pc] = output_color
                    visited[pr, pc] = True # Mark visited even if removed
                continue # Move to next pixel in grid iteration

            # If the pixel is not background, not visited, and not part of 
            # a recognized shape starting/centered here, it might be noise 
            # or part of an unrecognized shape. 
            # Based on examples, such pixels don't seem to appear or are 
            # implicitly handled by being part of shapes processed earlier.
            # If we needed to preserve *all* non-background pixels not part 
            # of the specific shapes, we'd add:
            # else:
            #     output_grid[r, c] = color
            #     visited[r,c] = True
            # But the current logic matches the example transformations better.


    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
