{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n# Define color constants for rules based on observations from examples\nPLUS_TO_GRAY_COLORS = {9, 6, 3}  # Maroon, Magenta, Green plus shapes become Gray\nLINE_TO_REMOVE_COLORS = {2, 3}   # Red, Green horizontal lines are removed\nGRAY_COLOR = 5\n\ndef _find_background_color(grid):\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Handle empty grid case if necessary\n    if not counts:\n        return 0 # Default to white if grid is empty\n    # Find the color with the highest count\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef _is_plus_center(grid, r, c, rows, cols, color):\n    \"\"\"Checks if (r, c) is the center of a 3x3 plus shape of the given color.\"\"\"\n    # Check bounds for a 3x3 area centered at (r, c)\n    if not (0 < r < rows - 1 and 0 < c < cols - 1):\n        return False\n    # Check if the center and its 4 orthogonal neighbors have the specified color\n    return (grid[r-1, c] == color and\n            grid[r+1, c] == color and\n            grid[r, c-1] == color and\n            grid[r, c+1] == color)\n\ndef _is_h_line_start(grid, r, c, rows, cols, color):\n    \"\"\"Checks if (r, c) is the start of a 1x5 horizontal line of the given color.\"\"\"\n    # Check bounds for a 1x5 area starting at (r, c)\n    if not (c + 4 < cols):\n        return False\n    # Check if the 5 pixels starting from (r, c) have the specified color\n    for i in range(5):\n        if grid[r, c+i] != color:\n            return False\n    # Optional: Ensure it's the *start* by checking the pixel to the left (if exists)\n    # if c > 0 and grid[r, c-1] == color:\n    #     return False # Part of a longer line or detected earlier\n    return True\n\n\n\"\"\"\nTransforms an input grid based on specific rules applied to 5-pixel objects.\n1. Identifies the background color (most frequent color).\n2. Creates an output grid filled with the background color.\n3. Iterates through the input grid, identifying 5-pixel plus shapes and \n   5-pixel horizontal lines.\n4. Applies rules:\n   - Removes 5-pixel horizontal lines if they are Red (2) or Green (3) by \n     leaving them as the background color in the output.\n   - Changes the color of 5-pixel plus shapes to Gray (5) if they are \n     Maroon (9), Magenta (6), or Green (3).\n   - Keeps all other identified 5-pixel plus or horizontal line shapes \n     unchanged (copies their original color to the output).\n5. Uses a visited mask to avoid processing pixels multiple times.\n\"\"\"\ndef transform(input_grid):\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Identify the background color\n    background_color = _find_background_color(input_grid_np)\n\n    # 2. Create an output grid initialized with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 3. Create a visited mask to track processed pixels\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    # 4. Iterate through each pixel to find shapes\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if already processed or background\n            if visited[r, c] or input_grid_np[r, c] == background_color:\n                continue\n\n            color = input_grid_np[r, c]\n\n            # Check if it's the center of a plus shape\n            if _is_plus_center(input_grid_np, r, c, rows, cols, color):\n                coords = [(r, c), (r-1, c), (r+1, c), (r, c-1), (r, c+1)]\n                \n                # Determine output color based on rules\n                output_color = GRAY_COLOR if color in PLUS_TO_GRAY_COLORS else color\n                \n                # Apply to output grid and mark visited\n                for pr, pc in coords:\n                    output_grid[pr, pc] = output_color\n                    visited[pr, pc] = True\n                continue # Move to next pixel in grid iteration\n\n            # Check if it's the start of a horizontal line shape\n            # Add check to ensure we only process lines starting at c or where c-1 is different\n            is_actual_start = (c == 0 or input_grid_np[r, c-1] != color)\n            if is_actual_start and _is_h_line_start(input_grid_np, r, c, rows, cols, color):\n                coords = [(r, c+i) for i in range(5)]\n\n                # Determine if line should be kept and its color\n                output_color = background_color # Default to remove/background\n                if color not in LINE_TO_REMOVE_COLORS:\n                    output_color = color # Keep original color\n                \n                # Apply to output grid (if not removed) and mark visited\n                for pr, pc in coords:\n                    if output_color != background_color:\n                         output_grid[pr, pc] = output_color\n                    visited[pr, pc] = True # Mark visited even if removed\n                continue # Move to next pixel in grid iteration\n\n            # If the pixel is not background, not visited, and not part of \n            # a recognized shape starting/centered here, it might be noise \n            # or part of an unrecognized shape. \n            # Based on examples, such pixels don't seem to appear or are \n            # implicitly handled by being part of shapes processed earlier.\n            # If we needed to preserve *all* non-background pixels not part \n            # of the specific shapes, we'd add:\n            # else:\n            #     output_grid[r, c] = color\n            #     visited[r,c] = True\n            # But the current logic matches the example transformations better.\n\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18223,
    "candidates_token_count": 1568,
    "total_token_count": 19791,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.023137,
  "retries": 1
}