
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 4 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 6 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 6 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 4 6 1
1 6 4 4 4 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 6 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 4 6 1
1 6 6 6 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 4 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 1 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 1 1 1 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 4 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 4 4 3
3 4 4 1 1 4 3
3 4 1 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
```

Okay, let's break down this task.

## Perception of Elements

1.  **Grid Structure:** Both input examples feature a larger grid divided into smaller, equally sized square subgrids by lines of a single color (blue `1` in `train_1`, green `3` in `train_2`). These dividing lines are one pixel thick.
2.  **Subgrids:** These subgrids act as containers for patterns. In both examples, the subgrids including their borders are 7x7 pixels.
3.  **Patterns:** Inside each 7x7 subgrid, there's an internal 5x5 area where a distinct pattern resides. These patterns are composed of two colors: the subgrid's background color (magenta `6` in `train_1`, yellow `4` in `train_2`) and a pattern color (yellow `4` in `train_1`, blue `1` in `train_2`).
4.  **Arrangement:**
    *   `train_1` input: A 3x3 arrangement of 7x7 subgrids.
    *   `train_2` input: A 3x4 arrangement of 7x7 subgrids.
5.  **Output Structure:** The output grid retains the height of the input grid and the vertical grid structure (the horizontal dividing lines). However, the output width is reduced to accommodate only *one* column of subgrids (7 pixels wide).
6.  **Transformation Logic:** The core transformation involves selecting *one* specific subgrid from each *row* of subgrids in the input and arranging these selected subgrids vertically in the output.
7.  **Selection Criterion:** The subgrid selected from each input row appears to be the one containing a pattern that is *unique* within that row. If all patterns in a row are identical, the first pattern from that row is selected.
    *   In `train_1`, row 1 has two 'C' shapes and one 'O-like' shape; the 'O-like' one is selected. Row 2 has two 'C' shapes and one 'backward C'; the 'backward C' is selected. Row 3 has a 'C', a 'backward C', and an 'O-missing-middle'; the 'O-missing-middle' is selected.
    *   In `train_2`, row 1 has four identical 'H' shapes; the first one is selected. Row 2 has one 'C' shape and three 'H' shapes; the 'C' shape is selected. Row 3 has three 'H' shapes and one 'different' shape; the 'different' shape is selected.

## YAML Facts


```yaml
task_description: Identify and extract unique patterns from rows of subgrids within a larger grid.

input_grid:
  properties:
    - composed_of: subgrids arranged in rows and columns
    - separated_by: single-pixel-thick grid lines of a uniform color (frame_color)
    - contains: N rows and M columns of subgrids

subgrid:
  properties:
    - dimensions: fixed size (e.g., 7x7 in examples)
    - contains:
        - outer_border: 1 pixel thick, same color as grid lines (frame_color)
        - inner_area: contains a pattern
          - pattern_background_color: uniform color within the subgrid (bg_color)
          - pattern_foreground_color: color forming the specific shape (fg_color)
          - pattern_dimensions: fixed size (e.g., 5x5 in examples)

patterns:
  properties:
    - defined_by: the arrangement of pattern_foreground_color pixels within the inner area of a subgrid
    - comparison: patterns within the same row of subgrids in the input are compared for uniqueness

transformation:
  action: select_subgrid_per_row
  criterion:
    - IF: one subgrid's pattern is unique within its input row
      THEN: select that unique subgrid
    - ELSE IF: all subgrid patterns in the input row are identical
      THEN: select the first subgrid in that row
  output_construction:
    - vertically stack the selected subgrids, maintaining the original vertical spacing and frame color
    - output_dimensions: same height as input, width equal to one subgrid's width

colors:
  - frame_color: color of the grid lines and subgrid outer borders (e.g., blue `1`, green `3`)
  - bg_color: background color within the pattern area (e.g., magenta `6`, yellow `4`)
  - fg_color: color making the pattern shape (e.g., yellow `4`, blue `1`)
```


## Natural Language Program

1.  **Identify Grid Structure:** Determine the dimensions of the input grid. Identify the color and locations of the grid lines that divide the input into a matrix of smaller, equally-sized subgrids. Determine the dimensions of these subgrids (e.g., 7x7).
2.  **Extract Subgrids:** Extract each subgrid from the input grid based on the identified structure. Store these subgrids, maintaining their original row and column position.
3.  **Process Rows:** Iterate through each row of subgrids identified in the previous step.
4.  **Compare Patterns within Row:** For the current row of subgrids, compare the patterns contained within them. Two patterns are considered identical if the subgrids are pixel-for-pixel identical.
5.  **Identify Unique/First Pattern:** Count the occurrences of each distinct pattern within the current row.
    *   If one pattern occurs exactly once, identify the subgrid containing this unique pattern as the "selected subgrid" for this row.
    *   If all patterns in the row are identical (i.e., only one distinct pattern exists, and it occurs multiple times), identify the first subgrid (leftmost) in that row as the "selected subgrid".
6.  **Store Selected Subgrids:** Keep track of the selected subgrid for each row.
7.  **Construct Output Grid:** Create a new grid with the same height as the input grid but with a width equal to the width of a single subgrid.
8.  **Populate Output Grid:** Place the selected subgrids vertically into the output grid, preserving their original row position and maintaining the original grid line structure (horizontal lines and the left/right borders). The final output will be a single column of the selected subgrids.
