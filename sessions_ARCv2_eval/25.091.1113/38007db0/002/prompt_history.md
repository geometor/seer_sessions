
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 4 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 6 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 4 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 6 4 6 6 6 1 6 4 6 6 6 1 6 4 6 6 6 1
1 6 4 4 4 6 1 6 4 4 4 6 1 6 4 4 4 6 1
1 6 6 4 6 6 1 6 6 6 6 6 1 6 6 4 6 6 1
1 6 6 6 6 6 1 6 6 6 6 6 1 6 6 6 6 6 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 4 6 1
1 6 4 4 4 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 6 6 1
1 6 6 4 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
1 6 6 6 6 6 1
1 6 4 6 6 6 1
1 6 4 4 4 6 1
1 6 6 6 6 6 1
1 6 6 6 6 6 1
1 1 1 1 1 1 1
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3
3 4 4 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 1 4 3 4 1 1 4 4 3
3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 4 4 3 4 4 1 1 4 3
3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3 4 1 1 4 4 3
3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3 4 4 4 4 4 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 1 1 1 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 1 4 3
3 4 4 1 4 4 3
3 4 4 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
3 4 4 4 4 4 3
3 4 1 1 4 4 3
3 4 4 1 1 4 3
3 4 1 1 4 4 3
3 4 4 4 4 4 3
3 3 3 3 3 3 3
```

Okay, let's break down this task.

## Perception of Elements

1.  **Grid Structure:** Both input examples feature a larger grid divided into smaller, equally sized square subgrids by lines of a single color (blue `1` in `train_1`, green `3` in `train_2`). These dividing lines are one pixel thick.
2.  **Subgrids:** These subgrids act as containers for patterns. In both examples, the subgrids including their borders are 7x7 pixels.
3.  **Patterns:** Inside each 7x7 subgrid, there's an internal 5x5 area where a distinct pattern resides. These patterns are composed of two colors: the subgrid's background color (magenta `6` in `train_1`, yellow `4` in `train_2`) and a pattern color (yellow `4` in `train_1`, blue `1` in `train_2`).
4.  **Arrangement:**
    *   `train_1` input: A 3x3 arrangement of 7x7 subgrids.
    *   `train_2` input: A 3x4 arrangement of 7x7 subgrids.
5.  **Output Structure:** The output grid retains the height of the input grid and the vertical grid structure (the horizontal dividing lines). However, the output width is reduced to accommodate only *one* column of subgrids (7 pixels wide).
6.  **Transformation Logic:** The core transformation involves selecting *one* specific subgrid from each *row* of subgrids in the input and arranging these selected subgrids vertically in the output.
7.  **Selection Criterion:** The subgrid selected from each input row appears to be the one containing a pattern that is *unique* within that row. If all patterns in a row are identical, the first pattern from that row is selected.
    *   In `train_1`, row 1 has two 'C' shapes and one 'O-like' shape; the 'O-like' one is selected. Row 2 has two 'C' shapes and one 'backward C'; the 'backward C' is selected. Row 3 has a 'C', a 'backward C', and an 'O-missing-middle'; the 'O-missing-middle' is selected.
    *   In `train_2`, row 1 has four identical 'H' shapes; the first one is selected. Row 2 has one 'C' shape and three 'H' shapes; the 'C' shape is selected. Row 3 has three 'H' shapes and one 'different' shape; the 'different' shape is selected.

## YAML Facts


```yaml
task_description: Identify and extract unique patterns from rows of subgrids within a larger grid.

input_grid:
  properties:
    - composed_of: subgrids arranged in rows and columns
    - separated_by: single-pixel-thick grid lines of a uniform color (frame_color)
    - contains: N rows and M columns of subgrids

subgrid:
  properties:
    - dimensions: fixed size (e.g., 7x7 in examples)
    - contains:
        - outer_border: 1 pixel thick, same color as grid lines (frame_color)
        - inner_area: contains a pattern
          - pattern_background_color: uniform color within the subgrid (bg_color)
          - pattern_foreground_color: color forming the specific shape (fg_color)
          - pattern_dimensions: fixed size (e.g., 5x5 in examples)

patterns:
  properties:
    - defined_by: the arrangement of pattern_foreground_color pixels within the inner area of a subgrid
    - comparison: patterns within the same row of subgrids in the input are compared for uniqueness

transformation:
  action: select_subgrid_per_row
  criterion:
    - IF: one subgrid's pattern is unique within its input row
      THEN: select that unique subgrid
    - ELSE IF: all subgrid patterns in the input row are identical
      THEN: select the first subgrid in that row
  output_construction:
    - vertically stack the selected subgrids, maintaining the original vertical spacing and frame color
    - output_dimensions: same height as input, width equal to one subgrid's width

colors:
  - frame_color: color of the grid lines and subgrid outer borders (e.g., blue `1`, green `3`)
  - bg_color: background color within the pattern area (e.g., magenta `6`, yellow `4`)
  - fg_color: color making the pattern shape (e.g., yellow `4`, blue `1`)
```


## Natural Language Program

1.  **Identify Grid Structure:** Determine the dimensions of the input grid. Identify the color and locations of the grid lines that divide the input into a matrix of smaller, equally-sized subgrids. Determine the dimensions of these subgrids (e.g., 7x7).
2.  **Extract Subgrids:** Extract each subgrid from the input grid based on the identified structure. Store these subgrids, maintaining their original row and column position.
3.  **Process Rows:** Iterate through each row of subgrids identified in the previous step.
4.  **Compare Patterns within Row:** For the current row of subgrids, compare the patterns contained within them. Two patterns are considered identical if the subgrids are pixel-for-pixel identical.
5.  **Identify Unique/First Pattern:** Count the occurrences of each distinct pattern within the current row.
    *   If one pattern occurs exactly once, identify the subgrid containing this unique pattern as the "selected subgrid" for this row.
    *   If all patterns in the row are identical (i.e., only one distinct pattern exists, and it occurs multiple times), identify the first subgrid (leftmost) in that row as the "selected subgrid".
6.  **Store Selected Subgrids:** Keep track of the selected subgrid for each row.
7.  **Construct Output Grid:** Create a new grid with the same height as the input grid but with a width equal to the width of a single subgrid.
8.  **Populate Output Grid:** Place the selected subgrids vertically into the output grid, preserving their original row position and maintaining the original grid line structure (horizontal lines and the left/right borders). The final output will be a single column of the selected subgrids.
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1.  **Identify Grid Structure:** The input grid is composed of smaller, equally-sized square subgrids arranged in a larger grid format. These subgrids are separated by single-pixel-thick lines of a uniform 'frame_color'.
2.  **Extract Subgrids:** Determine the size of the subgrids and extract each subgrid from the input. Maintain their original row arrangement.
3.  **Identify Unique Pattern per Row:** For each row of subgrids in the input:
    a.  Compare all subgrids within that row.
    b.  Count the occurrences of each distinct subgrid pattern.
    c.  If one pattern appears exactly once in the row, select the subgrid containing that unique pattern.
    d.  If all patterns in the row are identical (i.e., only one distinct pattern exists, repeated multiple times), select the first (leftmost) subgrid from that row.
4.  **Construct Output:** Create an output grid with the same height as the input grid but with a width equal to the width of a single subgrid. Vertically stack the selected subgrids (one from each original row) into this output grid, preserving the vertical arrangement and spacing defined by the subgrid size.
"""

def find_subgrid_size(grid):
    """
    Determines the size of the subgrids by finding the second occurrence
    of the frame color along the top row and first column.
    Assumes the top-left pixel (0,0) is part of the frame.
    """
    frame_color = grid[0, 0]
    height, width = grid.shape

    # Find horizontal size
    h_size = -1
    for c in range(1, width):
        if grid[0, c] == frame_color:
            h_size = c
            break
    
    # Find vertical size (should be the same for square subgrids)
    v_size = -1
    for r in range(1, height):
        if grid[r, 0] == frame_color:
            v_size = r
            break

    # Basic check if sizes were found and match
    if h_size == -1 or v_size == -1:
        # Fallback or error: maybe only one subgrid row/column
        if h_size != -1: return h_size
        if v_size != -1: return v_size
        # If neither works, assume full grid is the 'subgrid' (or handle error)
        # Based on examples, we expect grid lines. If not found, maybe size is the full dimension?
        # Let's assume grid lines are always present for multiple subgrids.
        # If only one subgrid vertically, v_size will be height. If only one horizontally, h_size is width.
        if h_size == -1 and v_size == -1: # Only one subgrid total
             return max(height, width) # Or specific logic if needed
        elif h_size == -1: # Only one column
             h_size = width 
        elif v_size == -1: # Only one row
             v_size = height

    if h_size != v_size:
         # This case shouldn't happen based on examples, but good to note
         print(f"Warning: Non-square subgrid structure detected? h_size={h_size}, v_size={v_size}")
         # Decide how to handle: maybe use the smaller, larger, or average? Or stick to h_size? Let's use h_size for now.

    # We add 1 because the index `c` or `r` is the position *of* the second frame line.
    # The size includes the pixels up to *before* that line. E.g., if line is at index 7, size is 7.
    # Let's re-evaluate: if grid[0,0] is frame and grid[0,7] is the next frame pixel, 
    # the subgrid content spans columns 0 through 6, which is a size of 7. So h_size itself is correct.
    # Similarly for v_size.
    
    # Correction: The logic seems to find the *start* of the next subgrid border.
    # If grid[0,0] is border and grid[0,7] is the next border pixel, the first subgrid
    # spans indices 0 to 6 horizontally. Size = 7. So the found index IS the size.
    subgrid_dim = h_size # Assuming square based on examples
    if subgrid_dim <= 0: # Handle cases where no second line was found
        subgrid_dim = max(width, height) if width == height else -1 # Fallback for single block or error
        if subgrid_dim == -1:
             raise ValueError("Could not determine subgrid size reliably.")
             
    return subgrid_dim


def extract_subgrids(grid, subgrid_size):
    """Extracts all subgrids into a list of lists."""
    height, width = grid.shape
    num_rows = height // subgrid_size
    num_cols = width // subgrid_size
    
    subgrids = []
    for r in range(num_rows):
        row_subgrids = []
        for c in range(num_cols):
            top = r * subgrid_size
            left = c * subgrid_size
            subgrid = grid[top : top + subgrid_size, left : left + subgrid_size]
            row_subgrids.append(subgrid)
        subgrids.append(row_subgrids)
    return subgrids

def select_subgrid_for_row(subgrid_row):
    """Selects the unique or first subgrid from a list of subgrids."""
    # Convert numpy arrays to tuples for hashing
    subgrid_tuples = [tuple(map(tuple, sg)) for sg in subgrid_row]
    
    # Count occurrences
    counts = Counter(subgrid_tuples)
    
    # Find unique subgrid
    unique_sg_tuple = None
    for sg_tuple, count in counts.items():
        if count == 1:
            unique_sg_tuple = sg_tuple
            break
            
    # If a unique one was found, find its original index to return the numpy array
    if unique_sg_tuple is not None:
        for i, sg_tuple in enumerate(subgrid_tuples):
            if sg_tuple == unique_sg_tuple:
                return subgrid_row[i]
    else:
        # If no unique one, return the first subgrid
        return subgrid_row[0]


def transform(input_grid):
    """
    Transforms the input grid by selecting unique or first subgrids from each row
    and stacking them vertically.
    """
    input_np = np.array(input_grid)
    height, width = input_np.shape

    # 1. Identify Grid Structure - Determine subgrid size
    try:
        subgrid_size = find_subgrid_size(input_np)
        if subgrid_size <= 0 or height % subgrid_size != 0 or width % subgrid_size != 0:
             # Fallback or default if structure unclear - treat as single block
             print(f"Warning: Grid dimensions {height}x{width} not divisible by deduced subgrid size {subgrid_size}. Treating as single block.")
             # For this specific task, an invalid structure likely means it cannot be solved by this logic.
             # However, let's try a simple fallback: If only one 'row' of subgrids exists, maybe return the unique/first?
             # Or maybe the task implies valid structure always. Let's assume valid structure.
             # Re-evaluate find_subgrid_size if issues persist.
             if subgrid_size <= 0 :
                  raise ValueError("Cannot determine subgrid size.") # More appropriate than fallback for this task
    except ValueError as e:
         print(f"Error in grid structure analysis: {e}")
         # Handle error case, maybe return input or empty grid? Let's return input.
         # return input_np 
         # Let's reconsider: returning input is likely wrong. Maybe an empty grid of required size?
         # The problem expects a transformation. Let's try to proceed assuming full grid if size fails.
         # This seems risky. Let's stick to raising the error if size determination fails.
         raise e


    # 2. Extract Subgrids
    # Check if dimensions are valid before extracting
    if height % subgrid_size != 0 or width % subgrid_size != 0:
        raise ValueError(f"Input dimensions ({height}x{width}) not divisible by subgrid size ({subgrid_size})")
        
    all_subgrids = extract_subgrids(input_np, subgrid_size)
    num_subgrid_rows = len(all_subgrids)

    if num_subgrid_rows == 0:
         # Handle empty input case or error
         return np.array([[]], dtype=int) # Return empty grid
         
    # 3. Process Rows & Select Subgrids
    selected_subgrids = []
    for subgrid_row in all_subgrids:
        if not subgrid_row: # Skip empty rows if they somehow occur
            continue
        selected = select_subgrid_for_row(subgrid_row)
        selected_subgrids.append(selected)

    # 4. Construct Output Grid
    output_height = height # Same height as input
    output_width = subgrid_size # Width of one subgrid
    output_grid = np.zeros((output_height, output_width), dtype=input_np.dtype)

    # 5. Populate Output Grid
    for i, sg in enumerate(selected_subgrids):
        # Calculate top-left corner for placing the subgrid
        row_start = i * subgrid_size
        # Check bounds before placing
        if row_start + subgrid_size <= output_height:
             output_grid[row_start : row_start + subgrid_size, 0 : subgrid_size] = sg
        else:
             # This shouldn't happen if num_subgrid_rows * subgrid_size == height
             print(f"Warning: Subgrid placement exceeds output bounds. Row {i}, Start {row_start}")


    return output_grid.tolist() # Return as list of lists per ARC standard

```
