{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Identify Regions & Elements:**\n    *   The input grid is conceptually divided into an upper region containing 'pattern' objects and a lower region containing horizontal 'bands'. There might be separator rows between these regions or between bands.\n    *   Determine the background color of the upper region (often the color at 0,0).\n    *   Find all connected components (objects) in the upper region that are not the background color. These are the 'patterns'. For each pattern, record its constituent pixels' coordinates, the set of colors it contains, and the count of each color.\n    *   Identify horizontal bands in the lower region. A band is characterized by a central 'fill color' and a 'border color' typically flanking the fill area horizontally. Record the fill color, border color, and the coordinates of the fill area for each band.\n\n2.  **Match Patterns to Bands:**\n    *   Establish a one-to-one correspondence between patterns and bands.\n    *   The matching rule is based on color: A pattern is a potential match for a band if one of the colors *within* the pattern is the same as the band's *fill color*.\n    *   If multiple patterns could match a single band based on its fill color, the pattern with the *highest count* of that fill color among its pixels is chosen for the match.\n\n3.  **Stamp Patterns onto Bands:**\n    *   Create an output grid, initially a copy of the input grid.\n    *   For each matched (pattern, band) pair:\n        *   Determine the shape of the pattern (the relative coordinates of its pixels from its top-left corner).\n        *   Get the top-left coordinate of the band's *fill area*.\n        *   Get the band's *border color*.\n        *   \"Stamp\" the pattern's shape onto the band's fill area in the output grid using the band's border color. This means for each relative coordinate `(dr, dc)` in the pattern's shape, the pixel at `(band_fill_top_left_row + dr, band_fill_top_left_col + dc)` in the output grid is set to the band's border color, overwriting the original fill color.\n\n4.  **Clean Up Upper Region:**\n    *   In the output grid, replace all pixels corresponding to the original locations of the pattern objects with the upper region's background color.\n\n5.  **Return Output:** The modified grid is the result.\n\"\"\"\n\ndef find_objects(grid, background_color, region_mask):\n    \"\"\"Finds connected objects of non-background colors within a specified region.\"\"\"\n    objects = []\n    visited = np.zeros(grid.shape, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is within the specified region, not background, and not visited\n            if region_mask[r, c] and grid[r, c] != background_color and not visited[r, c]:\n                obj_coords = set()\n                obj_colors = Counter()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.add((row, col))\n                    obj_colors[grid[row, col]] += 1\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           region_mask[nr, nc] and \\\n                           grid[nr, nc] != background_color and \\\n                           not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Calculate relative shape\n                shape = set((orow - min_r, ocol - min_c) for orow, ocol in obj_coords)\n\n                objects.append({\n                    'coords': obj_coords,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'colors': dict(obj_colors),\n                    'shape': shape,\n                    'top_left': (min_r, min_c)\n                })\n    return objects\n\ndef find_bands(grid, start_row):\n    \"\"\"Identifies horizontal bands below a given start row.\"\"\"\n    bands = []\n    rows, cols = grid.shape\n    if start_row >= rows:\n        return bands\n\n    current_band_rows = []\n    for r in range(start_row, rows):\n        row_data = grid[r, :]\n        # Basic band heuristic: Check if first and last pixel differ from the second\n        if cols >= 3 and row_data[0] != row_data[1] and row_data[0] == row_data[-1]:\n            border_color = row_data[0]\n            fill_color = row_data[1]\n            # Check if the central part is mostly the fill color\n            is_band_row = True\n            fill_coords_row = set()\n            for c in range(1, cols - 1):\n                if row_data[c] == fill_color:\n                    fill_coords_row.add((r, c))\n                elif row_data[c] != border_color: # Allow border color inside sometimes? No, strictly fill or border\n                     # Example 3 shows stamping can happen over border pixels if they are inside the fill region conceptually\n                     # Let's stick to the simple definition first: border | fill+ | border\n                     pass # Allow other colors? Let's assume only fill/border for now.\n                     # Revisit: The examples show stamping *can* overwrite border color if it's inside the fill area bounds.\n                     # Let's define fill area more loosely first: columns between the first and last.\n                     # Better: Find first and last column index of the fill color.\n                #else:\n                #    is_band_row = False\n                #    break\n            \n            # More robust check: scan inwards for border and fill\n            left_border_end = 0\n            while left_border_end < cols and row_data[left_border_end] == border_color:\n                left_border_end += 1\n            \n            right_border_start = cols - 1\n            while right_border_start >= 0 and row_data[right_border_start] == border_color:\n                right_border_start -= 1\n\n            # Potential fill area is between left_border_end and right_border_start\n            potential_fill_color = -1\n            is_simple_band = True\n            if left_border_end <= right_border_start:\n                potential_fill_color = row_data[left_border_end]\n                for c in range(left_border_end, right_border_start + 1):\n                     # Allow fill color or border color within the fill zone due to stamping\n                    if row_data[c] != potential_fill_color and row_data[c] != border_color : \n                        is_simple_band = False\n                        break\n            else: # No fill area\n                is_simple_band = False\n\n            if is_simple_band and potential_fill_color != -1 and potential_fill_color != border_color :\n                # This looks like a band row\n                if not current_band_rows or \\\n                   (grid[current_band_rows[-1][0], 0] == border_color and \\\n                    grid[current_band_rows[-1][0], left_border_end] == potential_fill_color): # Check continuity\n                    current_band_rows.append((r, border_color, potential_fill_color, left_border_end, right_border_start))\n                else:\n                    # End previous band\n                    if current_band_rows:\n                        bands.append(process_band_rows(grid, current_band_rows))\n                    current_band_rows = [(r, border_color, potential_fill_color, left_border_end, right_border_start)]\n            else:\n                 # End previous band if any\n                if current_band_rows:\n                    bands.append(process_band_rows(grid, current_band_rows))\n                current_band_rows = [] # Reset, not a band row or different band type\n        else:\n            # End previous band if any\n            if current_band_rows:\n                 bands.append(process_band_rows(grid, current_band_rows))\n            current_band_rows = [] # Reset, not a band row\n\n    # Add the last band if it exists\n    if current_band_rows:\n         bands.append(process_band_rows(grid, current_band_rows))\n\n    return bands\n\ndef process_band_rows(grid, band_rows_info):\n    \"\"\"Helper to consolidate information for a band spanning multiple rows.\"\"\"\n    start_r = band_rows_info[0][0]\n    end_r = band_rows_info[-1][0]\n    border_color = band_rows_info[0][1]\n    fill_color = band_rows_info[0][2] # Assuming fill color is consistent\n    \n    # Determine fill area bounds (min/max columns over all rows)\n    min_fill_c = grid.shape[1]\n    max_fill_c = -1\n    fill_coords = set()\n    fill_min_r, fill_min_c = start_r, grid.shape[1]\n\n\n    for r, bc, fc, lbe, rbs in band_rows_info:\n         # Define fill columns strictly as non-border between the borders\n        current_min_c = lbe\n        current_max_c = rbs\n        min_fill_c = min(min_fill_c, current_min_c)\n        max_fill_c = max(max_fill_c, current_max_c)\n        \n        # Collect actual fill coordinates (original fill color) - might be needed?\n        # Stamping uses the border color, overwriting whatever is there.\n        # We need the top-left corner of the conceptual fill *rectangle* for stamping alignment.\n        fill_min_c = min(fill_min_c, current_min_c) # Update fill top-left\n        \n        for c in range(current_min_c, current_max_c + 1):\n              fill_coords.add((r,c)) # Add all coords within the fill bounds\n\n\n    return {\n        'rows': (start_r, end_r),\n        'fill_color': fill_color,\n        'border_color': border_color,\n        'fill_coords': fill_coords, # All coords within L/R bounds\n        'fill_bbox': (start_r, min_fill_c, end_r, max_fill_c),\n         'fill_top_left': (start_r, min_fill_c)\n    }\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern stamping transformation.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Upper Background Color (Assume top-left)\n    upper_background_color = input_grid[0, 0]\n\n    # 2. Find potential band start row\n    # Find the first row that looks like a band or a separator that isn't the background color\n    band_start_row = 0\n    found_lower_region = False\n    for r in range(rows):\n        is_background_row = np.all(input_grid[r,:] == upper_background_color)\n        # Check for simple band structure (as in find_bands)\n        is_band_like = False\n        if cols >= 3 and input_grid[r, 0] != input_grid[r, 1] and input_grid[r, 0] == input_grid[r, -1] and input_grid[r,0] != upper_background_color:\n             is_band_like = True\n        # Check for separator line (single color, not background)\n        is_separator = len(np.unique(input_grid[r,:])) == 1 and input_grid[r,0] != upper_background_color\n        \n        if not is_background_row and (is_band_like or is_separator):\n             band_start_row = r\n             found_lower_region = True\n             break\n    \n    # If no bands/separators found, the whole grid might be the upper region? Or task is different.\n    # For this specific task structure, assume bands exist. If not found, maybe default to row 0 or half?\n    # Let's assume band_start_row correctly identifies the split.\n\n    # Define upper region mask\n    upper_region_mask = np.zeros(input_grid.shape, dtype=bool)\n    if found_lower_region:\n        upper_region_mask[:band_start_row, :] = True\n    else: \n        # Fallback if no clear lower region start found - treat whole grid? Unlikely for this task.\n        # Let's assume the first non-background row marks the start if no bands found.\n         for r in range(rows):\n            if not np.all(input_grid[r,:] == upper_background_color):\n                band_start_row = r\n                upper_region_mask[:band_start_row, :] = True\n                break\n         else: # Grid is all background?\n             return output_grid # No patterns/bands likely\n\n\n    # 3. Extract Patterns from the upper region\n    patterns = find_objects(input_grid, upper_background_color, upper_region_mask)\n    \n    # Keep track of original pattern pixels for cleanup\n    all_pattern_coords = set()\n    for p in patterns:\n        all_pattern_coords.update(p['coords'])\n\n    # 4. Extract Bands from the lower region\n    bands = find_bands(input_grid, band_start_row)\n\n    # 5. Match Patterns and Bands\n    matched_patterns = set()\n    matched_bands = set()\n    matches = [] # List of (pattern, band) tuples\n\n    # Create lookup for faster matching\n    patterns_by_color = defaultdict(list)\n    for i, p in enumerate(patterns):\n        for color, count in p['colors'].items():\n            patterns_by_color[color].append({'id': i, 'count': count, 'pattern': p})\n\n    \n    # Iterate until no more matches can be made\n    made_match_this_round = True\n    while made_match_this_round :\n        made_match_this_round = False\n        best_match_for_band = {} # band_idx -> potential_match_info {'pattern_id', 'score', 'pattern_idx_in_patterns_list'}\n\n        for band_idx, band in enumerate(bands):\n            if band_idx in matched_bands:\n                continue\n\n            fill_color = band['fill_color']\n            \n            # Find candidate patterns containing the fill color\n            candidate_patterns = []\n            if fill_color in patterns_by_color:\n                 for p_info in patterns_by_color[fill_color]:\n                     if p_info['id'] not in matched_patterns:\n                         candidate_patterns.append(p_info)\n\n            if not candidate_patterns:\n                continue # No available patterns match this band's fill color\n\n            # Find the best candidate (highest count of fill_color)\n            best_candidate = max(candidate_patterns, key=lambda x: x['count'])\n            \n            # Store this as the best potential match *for this band*\n            # If another band also wants this pattern, the tie-breaking (highest count) decides\n            # We need a way to resolve conflicts if multiple bands point to the same best pattern.\n            # Let's try a simpler approach first: Iterate through bands and claim the best available pattern.\n            \n            # Find best match directly\n            best_pattern_info = max(candidate_patterns, key=lambda p: p['count'])\n            pattern_global_idx = best_pattern_info['id']\n\n            # Tentatively assign\n            # Check if this pattern is a better match for *this* band than any other band it could match\n            # This seems overly complex. Let's stick to the description:\n            # For a band, find all *available* patterns containing its fill color.\n            # From those, pick the one with the highest count of that fill color.\n            \n            # Simple greedy matching based on iteration order and highest count\n            current_best_pattern_idx = best_pattern_info['id']\n            \n            # Record this potential match\n            # Score is the count of the fill color in the pattern\n            match_info = {'pattern_id': current_best_pattern_idx, 'score': best_pattern_info['count'], 'band_idx': band_idx}\n\n            # If this pattern is already potentially matched to another band, check scores\n            # This still feels complex. Let's simplify: Process bands one by one.\n            # When a band is processed, find its best available pattern and claim it immediately.\n\n        # --- Simplified Greedy Matching ---\n        for band_idx, band in enumerate(bands):\n             if band_idx in matched_bands:\n                 continue\n\n             fill_color = band['fill_color']\n             candidate_patterns_info = []\n             if fill_color in patterns_by_color:\n                  for p_info in patterns_by_color[fill_color]:\n                      if p_info['id'] not in matched_patterns:\n                          candidate_patterns_info.append(p_info)\n            \n             if not candidate_patterns_info:\n                 continue\n\n             # Find the best available pattern for this band\n             best_pattern_info = max(candidate_patterns_info, key=lambda p: p['count'])\n             pattern_global_idx = best_pattern_info['id']\n\n             # Make the match\n             matches.append((patterns[pattern_global_idx], band))\n             matched_patterns.add(pattern_global_idx)\n             matched_bands.add(band_idx)\n             made_match_this_round = True # We made at least one match in this pass\n             \n        # If the number of matches equals patterns or bands, we can stop early potentially\n        if len(matches) == len(patterns) or len(matches) == len(bands):\n             break\n        # The loop `while made_match_this_round` is actually sufficient for the greedy approach.\n\n    # 6. Apply Stamping\n    for pattern, band in matches:\n        shape = pattern['shape']\n        border_color = band['border_color']\n        # Align stamping with the top-left of the *fill area*\n        fill_top_left_r, fill_top_left_c = band['fill_top_left']\n        \n        min_r_fill, min_c_fill, max_r_fill, max_c_fill = band['fill_bbox']\n\n        for dr, dc in shape:\n            target_r = fill_top_left_r + dr\n            target_c = fill_top_left_c + dc\n\n            # Ensure stamping occurs within the band's fill bounding box conceptually\n            # The examples show stamping happens regardless of original content (fill/border)\n            # within the derived target coordinates. Check bounds of the grid.\n            if 0 <= target_r < rows and 0 <= target_c < cols:\n                 # Check if target is within the conceptual fill area for safety?\n                 # The examples imply direct coordinate mapping is enough.\n                 # Let's trust the derived coordinates map correctly based on fill_top_left.\n                 output_grid[target_r, target_c] = border_color\n\n    # 7. Clean Up Upper Region\n    for r, c in all_pattern_coords:\n        # Ensure cleanup only happens in the originally defined upper region\n        if upper_region_mask[r, c]:\n             output_grid[r, c] = upper_background_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11589,
    "candidates_token_count": 4791,
    "total_token_count": 16380,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 53.759962,
  "retries": 1
}