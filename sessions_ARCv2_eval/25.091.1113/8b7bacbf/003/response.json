{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Scan the input grid to find the unique 'fill color' pixel (either yellow/4 or orange/7). Store this fill color.\n3. Find all connected components (regions) of white (0) pixels in the input grid.\n4. For each white component:\n    a. Check if the component touches the grid edge. If it does, ignore it.\n    b. Determine all pixels immediately adjacent (up, down, left, right) to the component that are *not* part of the component itself. These are the boundary neighbors.\n    c. Check if all boundary neighbors exist and have the *exact same* single non-white color. Store this boundary color. If not uniform or if white, ignore the component.\n    d. Apply a filter based on the fill color and the boundary color:\n        i. If the fill color is orange (7), the component is only valid if its boundary color is red (2) or gray (5).\n        ii. If the fill color is yellow (4), the component is only valid if its boundary color is red (2).\n    e. If the component is valid (passes edge check, uniform non-white boundary check, and the filter check), then change the color of all pixels belonging to this component in the *output* grid to the stored 'fill color'.\n5. Return the modified output grid.\n\"\"\"\n\ndef find_fill_color(grid):\n    \"\"\"Scans the grid to find the unique yellow (4) or orange (7) pixel.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            pixel_color = grid[r, c]\n            if pixel_color == 4 or pixel_color == 7:\n                return pixel_color\n    # Fallback, though examples suggest a fill color always exists\n    return -1 # Use -1 to indicate not found, distinct from valid colors\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid adjacent neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_connected_components(grid, color_to_find):\n    \"\"\"Finds all connected components of a specific color using BFS.\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color_to_find and not visited[r, c]:\n                # Start BFS for a new component\n                component = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr, nc] == color_to_find and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                \n                components.append(component)\n    return components\n\ndef check_enclosure_and_filter(component, grid, fill_color):\n    \"\"\"\n    Checks if a component of white pixels is enclosed by a single non-white color,\n    does not touch the grid edge, and meets the color filter criteria.\n    Returns True if enclosed and filtered, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    boundary_colors = set()\n    first_boundary_color = -1 # Initialize\n    touches_edge = False\n    has_boundary_neighbors = False\n\n    for r, c in component:\n        # Check if the component pixel is on the edge\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            touches_edge = True\n            # Can stop checking edges, but still need to find boundary colors\n            # Break here is only safe if we don't care about boundary color yet.\n            # Let's continue to find all boundary colors for the uniformity check.\n\n        # Find neighbors of the current component pixel\n        for nr, nc in get_neighbors(r, c, height, width):\n            # If the neighbor is NOT part of the component, it's a boundary neighbor\n            if (nr, nc) not in component:\n                has_boundary_neighbors = True\n                neighbor_color = grid[nr, nc]\n                boundary_colors.add(neighbor_color)\n                if first_boundary_color == -1:\n                    first_boundary_color = neighbor_color\n\n    # Condition 1: Must not touch the edge\n    if touches_edge:\n        return False\n        \n    # Condition 2: Must have boundary neighbors\n    if not has_boundary_neighbors:\n        return False\n\n    # Condition 3: All boundary neighbors must have the same color, and it must not be white (0)\n    is_uniform_non_white = len(boundary_colors) == 1 and 0 not in boundary_colors\n    if not is_uniform_non_white:\n        return False\n        \n    # If conditions 1, 2, 3 are met, proceed to filter\n    boundary_color = first_boundary_color # Since it's uniform, first one is the one\n\n    # Condition 4: Apply color filter\n    if fill_color == 7: # Orange fill\n        if boundary_color == 2 or boundary_color == 5: # Red or Gray boundary\n            return True\n    elif fill_color == 4: # Yellow fill\n        if boundary_color == 2: # Red boundary only\n            return True\n\n    # If filter conditions are not met\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds the fill color (orange/yellow),\n    identifies white regions enclosed by specific boundary colors (depending on fill color),\n    and fills those regions with the fill color.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Step 1: Find the fill color\n    fill_color = find_fill_color(grid)\n    if fill_color == -1: # Handle case where fill color isn't found\n         print(\"Warning: Fill color (4 or 7) not found in input grid.\")\n         return output_grid.tolist() \n\n    # Step 2: Find all connected components of white (0) pixels\n    white_components = find_connected_components(grid, 0)\n\n    # Step 3 & 4: Check each white component for enclosure, filter, and fill if necessary\n    for component in white_components:\n        # Check enclosure conditions and color filter\n        if check_enclosure_and_filter(component, grid, fill_color):\n            # Step 5: Fill the valid enclosed region in the output grid\n            for r, c in component:\n                output_grid[r, c] = fill_color\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16782,
    "candidates_token_count": 1754,
    "total_token_count": 18536,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.55639,
  "retries": 1
}