{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Initialize the output grid as a copy of the input grid.\n2. Scan the input grid to find the unique 'fill color' pixel (either yellow/4 or orange/7). Store this fill color.\n3. Find all connected components (regions) of white (0) pixels in the input grid.\n4. For each white component:\n    a. Check if any pixel in the component touches the grid edge. If it does, this component is invalid; ignore it.\n    b. Determine all pixels immediately adjacent (up, down, left, right) to any pixel in the component, but which are *not* part of the component itself. These are the boundary neighbors.\n    c. Check if all boundary neighbors exist (i.e., the component is not empty and has neighbors outside itself) and if they all have the *exact same* single non-white color. Store this boundary color. If neighbors don't exist, or are not uniform, or are white, this component is invalid; ignore it.\n    d. Apply a filter based on the fill color and the boundary color:\n        i. If the fill color is orange (7), the component is only valid if its boundary color is red (2) or gray (5).\n        ii. If the fill color is yellow (4), the component is only valid if its boundary color is red (2).\n    e. If the component is valid (passes edge check, uniform non-white boundary check, and the color filter check), then mark it for filling.\n5. Change the color of all pixels belonging to any valid marked component in the *output* grid to the stored 'fill color'.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_fill_color(grid):\n    \"\"\"Scans the grid to find the unique yellow (4) or orange (7) pixel.\"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            pixel_color = grid[r, c]\n            # Check if the color is yellow (4) or orange (7)\n            if pixel_color == 4 or pixel_color == 7:\n                return pixel_color\n    # Fallback, though examples suggest a fill color always exists.\n    # Return -1 to indicate not found, distinct from valid colors 0-9.\n    return -1 \n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid adjacent neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    # Check neighbor above\n    if r > 0: neighbors.append((r - 1, c))\n    # Check neighbor below\n    if r < height - 1: neighbors.append((r + 1, c))\n    # Check neighbor left\n    if c > 0: neighbors.append((r, c - 1))\n    # Check neighbor right\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_connected_components(grid, color_to_find):\n    \"\"\"Finds all connected components of a specific color using Breadth-First Search (BFS).\"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    # Iterate through each cell in the grid\n    for r in range(height):\n        for c in range(width):\n            # If the cell has the target color and hasn't been visited yet\n            if grid[r, c] == color_to_find and not visited[r, c]:\n                # Start BFS for a new component\n                component = set() # Store coordinates of pixels in the component\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n                component.add((r, c))\n\n                # Process the queue\n                while q:\n                    row, col = q.popleft()\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        # If neighbor has the target color and hasn't been visited\n                        if grid[nr, nc] == color_to_find and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Add the found component to the list\n                components.append(component)\n    return components\n\ndef check_enclosure_and_filter(component, grid, fill_color):\n    \"\"\"\n    Checks if a component of white pixels satisfies all enclosure and filter conditions:\n    1. Does not touch the grid edge.\n    2. Is enclosed by a single, uniform, non-white color.\n    3. Meets the specific color filter based on fill_color and boundary_color.\n    Returns True if all conditions are met, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    boundary_colors = set()\n    first_boundary_color = -1 # Initialize boundary color tracker\n    touches_edge = False\n    has_boundary_neighbors = False\n\n    # Iterate through each pixel in the component\n    for r, c in component:\n        # 1. Check if the component pixel is on the grid edge\n        if r == 0 or r == height - 1 or c == 0 or c == width - 1:\n            touches_edge = True\n            # If it touches the edge, it cannot be enclosed per the rule.\n            return False \n\n        # Find neighbors of the current component pixel\n        for nr, nc in get_neighbors(r, c, height, width):\n            # Check if the neighbor is *outside* the current white component\n            if (nr, nc) not in component:\n                has_boundary_neighbors = True\n                neighbor_color = grid[nr, nc]\n                boundary_colors.add(neighbor_color)\n                # Store the first boundary color encountered\n                if first_boundary_color == -1:\n                    first_boundary_color = neighbor_color\n\n    # 2a. Check if the component actually has any boundary neighbors\n    if not has_boundary_neighbors:\n        # Isolated component with no neighbors outside itself (e.g., whole grid is white)\n        return False\n\n    # 2b. Check if all boundary neighbors have the same, single, non-white color\n    is_uniform_non_white = len(boundary_colors) == 1 and 0 not in boundary_colors\n    if not is_uniform_non_white:\n        # Boundary is non-uniform, or contains white pixels\n        return False\n        \n    # If edge check and uniformity check passed, proceed to the color filter\n    boundary_color = first_boundary_color # Since it's uniform, the first one represents all\n\n    # 3. Apply color filter based on fill_color and boundary_color\n    if fill_color == 7: # Fill color is Orange\n        # Valid only if boundary is Red (2) or Gray (5)\n        if boundary_color == 2 or boundary_color == 5: \n            return True\n    elif fill_color == 4: # Fill color is Yellow\n        # Valid only if boundary is Red (2)\n        if boundary_color == 2: \n            return True\n\n    # If the filter conditions are not met for the specific fill/boundary combination\n    return False\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds the fill color (orange/7 or yellow/4),\n    identifies white regions that are fully enclosed by specific boundary colors \n    (red/2 or gray/5 for orange fill; red/2 only for yellow fill) without touching the edge,\n    and fills those valid regions with the fill color.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # Step 1: Find the fill color (4 or 7)\n    fill_color = find_fill_color(grid)\n    # If no fill color is found, return the original grid (as per fallback in helper)\n    if fill_color == -1: \n         #print(\"Warning: Fill color (4 or 7) not found in input grid.\")\n         return output_grid.tolist() \n\n    # Step 2: Find all connected components of white (0) pixels\n    white_components = find_connected_components(grid, 0)\n\n    # Step 3 & 4: Check each white component for validity and filter\n    for component in white_components:\n        # Check enclosure conditions (edge, uniform non-white boundary) and color filter\n        if check_enclosure_and_filter(component, grid, fill_color):\n            # Step 5: If valid, fill the region in the output grid\n            for r, c in component:\n                output_grid[r, c] = fill_color\n\n    # Return the final modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19309,
    "candidates_token_count": 2080,
    "total_token_count": 21389,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.18671,
  "retries": 1
}