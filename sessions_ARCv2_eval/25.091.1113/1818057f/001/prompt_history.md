
## train_1

**input:**
```
2 2 2 2 4 4 2 2 2 2 2 2
2 2 2 2 2 4 2 2 4 2 4 2
4 2 2 2 2 2 2 2 2 2 4 2
2 2 2 4 2 2 2 2 4 4 2 2
2 2 4 2 2 2 2 2 4 4 2 2
4 2 2 2 2 2 4 2 4 4 4 2
2 4 2 4 2 2 4 2 2 4 2 2
2 2 2 2 2 2 4 2 2 2 2 2
2 4 2 2 2 2 4 2 2 4 2 2
2 2 2 4 4 2 2 4 2 4 2 4
```


**output:**
```
2 2 2 2 4 4 2 2 2 2 2 2
2 2 2 2 2 4 2 2 4 2 4 2
4 2 2 2 2 2 2 2 2 2 4 2
2 2 2 4 2 2 2 2 4 4 2 2
2 2 4 2 2 2 2 2 4 8 2 2
4 2 2 2 2 2 4 2 8 8 8 2
2 4 2 4 2 2 4 2 2 8 2 2
2 2 2 2 2 2 4 2 2 2 2 2
2 4 2 2 2 2 4 2 2 4 2 2
2 2 2 4 4 2 2 4 2 4 2 4
```


## train_2

**input:**
```
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
2 2 4 4 4 2 2 4 4 4 2 2 4 4 4 2 2
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
4 4 2 4 2 4 4 2 4 2 4 4 2 4 2 4 4
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
2 2 4 4 4 2 2 4 4 4 2 2 4 4 4 2 2
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
2 2 4 4 4 2 2 4 4 4 2 2 4 4 4 2 2
2 2 2 4 2 2 2 2 4 2 2 2 2 4 2 2 2
4 4 2 4 2 4 4 2 4 2 4 4 2 4 2 4 4
```


**output:**
```
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
2 2 8 8 8 2 2 8 8 8 2 2 8 8 8 2 2
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
4 4 2 4 2 4 4 2 4 2 4 4 2 4 2 4 4
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
2 2 8 8 8 2 2 8 8 8 2 2 8 8 8 2 2
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
4 4 2 2 2 4 4 2 2 2 4 4 2 2 2 4 4
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
2 2 8 8 8 2 2 8 8 8 2 2 8 8 8 2 2
2 2 2 8 2 2 2 2 8 2 2 2 2 8 2 2 2
4 4 2 4 2 4 4 2 4 2 4 4 2 4 2 4 4
```


## train_3

**input:**
```
2 2 2 2 2 4 4 4 2 2 2 4
2 2 2 2 2 4 4 4 2 2 2 4
2 2 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 4 4 4 4 4 4 4
2 2 2 2 2 4 4 4 2 2 2 4
4 2 2 2 2 2 4 4 2 2 2 4
4 4 2 2 2 2 2 4 4 4 4 4
4 4 4 2 2 2 4 4 4 4 2 2
4 4 4 2 2 2 4 2 2 2 2 2
2 2 2 4 4 4 4 2 2 2 4 4
2 2 2 4 4 4 4 4 4 4 4 4
```


**output:**
```
2 2 2 2 2 4 4 4 2 2 2 4
2 2 2 2 2 4 4 4 2 2 2 4
2 2 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 2 2 2 2 2 2 4
2 2 2 2 2 4 8 4 4 4 4 4
2 2 2 2 2 8 8 8 2 2 2 4
4 2 2 2 2 2 8 4 2 2 2 4
4 8 2 2 2 2 2 4 4 4 4 4
8 8 8 2 2 2 4 4 4 4 2 2
4 8 4 2 2 2 4 2 2 2 2 2
2 2 2 4 4 4 4 2 2 2 4 4
2 2 2 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

## Perception

1.  **Grid Size:** The input and output grids in each example have the same dimensions.
2.  **Colors:**
    *   The input grids primarily use red (2) and yellow (4).
    *   The output grids introduce a new color, azure (8), while retaining red (2) and yellow (4).
    *   Red pixels remain unchanged between input and output.
    *   Some yellow pixels change to azure, while others remain yellow.
3.  **Pattern/Shape:** The change from yellow (4) to azure (8) doesn't happen randomly. It occurs in specific configurations. Comparing input and output grids, the pixels that change form a '+' shape (a central pixel and its four orthogonal neighbors).
4.  **Condition for Change:** A '+' shape configuration of pixels changes color *only if* all five pixels comprising the shape (center and four orthogonal neighbors) are yellow (4) in the input grid.
5.  **Result of Change:** When the condition is met, all five yellow pixels forming that specific '+' shape change their color to azure (8) in the output grid. Pixels not part of such a "qualifying" yellow '+' shape retain their original input color.
6.  **Multiple Instances:** The transformation applies independently to all occurrences of qualifying yellow '+' shapes within the grid (as seen clearly in `train_2`).

## YAML Facts


```yaml
grid_properties:
  - Input and output grids have identical dimensions for each example pair.

color_palette:
  - Input colors: [red (2), yellow (4)]
  - Output colors: [red (2), yellow (4), azure (8)]
  - Unchanged color: red (2)
  - Transformed color: yellow (4) can become azure (8) under specific conditions.
  - New color: azure (8) appears in the output.

objects:
  - type: pattern
    name: plus_shape
    definition: A central pixel and its four cardinally adjacent (up, down, left, right) neighbors.
    relevant_color: yellow (4)

transformation_rule:
  - condition: Identify all instances where a `plus_shape` pattern consists entirely of yellow (4) pixels in the input grid.
  - action: For each identified instance, change the color of all five pixels constituting that `plus_shape` from yellow (4) to azure (8) in the output grid.
  - preservation: Pixels not belonging to any such qualifying yellow `plus_shape` retain their original color from the input grid.
```


## Natural Language Program

1.  Initialize the output grid as an exact copy of the input grid.
2.  Iterate through each cell (pixel) in the input grid at `(row, column)`, excluding the border rows and columns (i.e., iterate from `row = 1` to `height - 2` and `column = 1` to `width - 2`), considering each as a potential center of a '+' shape.
3.  For each potential center cell `(row, column)`:
    a.  Check if the color of the center cell `(row, column)` is yellow (4).
    b.  Check if the color of the top neighbor `(row - 1, column)` is yellow (4).
    c.  Check if the color of the bottom neighbor `(row + 1, column)` is yellow (4).
    d.  Check if the color of the left neighbor `(row, column - 1)` is yellow (4).
    e.  Check if the color of the right neighbor `(row, column + 1)` is yellow (4).
4.  If all five conditions in step 3 (a-e) are true (i.e., the cell and all four orthogonal neighbors are yellow in the input grid):
    a.  Update the color of the cell at `(row, column)` in the *output* grid to azure (8).
    b.  Update the color of the cell at `(row - 1, column)` in the *output* grid to azure (8).
    c.  Update the color of the cell at `(row + 1, column)` in the *output* grid to azure (8).
    d.  Update the color of the cell at `(row, column - 1)` in the *output* grid to azure (8).
    e.  Update the color of the cell at `(row, column + 1)` in the *output* grid to azure (8).
5.  After checking all possible center cells, return the final output grid.
