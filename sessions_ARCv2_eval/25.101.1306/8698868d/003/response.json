{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\nfrom scipy import stats as ss\n\n\"\"\"\nIdentifies a 'separator' color and distinct rectangular objects ('frames' and 'contents') in the input grid. \nFrames are larger (N x M) and Contents are smaller (N-2 x M-2).\nThe transformation constructs an output grid preserving the relative arrangement of the Frames.\nEach Frame's 1-pixel border (using its main color, Fc) is copied to the output.\nThe interior (core) of each Frame in the output is filled based on a pattern derived from its paired Content block.\nTo generate the core:\n1. Identify the dominant color (Cc) of the paired Content block (most frequent non-separator color).\n2. Take the rectangular slice of the *input grid* corresponding to the Content block's area (size N-2 x M-2).\n3. For each pixel in this slice: if it's the separator color, the output core pixel is Fc; otherwise, it's Cc.\nFrame and Content blocks are paired based on their reading order (top-to-bottom, left-to-right).\n\"\"\"\n\ndef get_separator_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Identifies the separator color in the grid.\n    The separator is assumed to be the color that has the highest number of\n    distinct neighboring colors (adjacency diversity). Ties are broken by\n    choosing the most frequent color among the candidates with max diversity.\n    As a fallback, returns the most frequent color in the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return 0 # Default for empty grid (white)\n        \n    neighbor_colors = defaultdict(set)\n    color_counts = defaultdict(int)\n\n    # Iterate through grid to find distinct neighbors and count colors\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            color_counts[color] += 1\n            # Check 8 neighbors (Moore neighborhood)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                         neighbor_color = grid[nr, nc]\n                         # Add neighbor color if it's different from the cell color\n                         if neighbor_color != color:\n                             neighbor_colors[color].add(neighbor_color)\n\n    max_diversity = -1\n    candidate_separators = []\n\n    # Find the colors with the maximum number of distinct neighbor colors\n    for color, neighbors in neighbor_colors.items():\n         num_distinct_neighbors = len(neighbors)\n         if num_distinct_neighbors > max_diversity:\n             max_diversity = num_distinct_neighbors\n             candidate_separators = [color] # New maximum found\n         elif num_distinct_neighbors == max_diversity:\n             candidate_separators.append(color) # Add to candidates with same max diversity\n\n    separator_color = -1\n    if len(candidate_separators) == 1:\n        # Only one color has the maximum diversity\n        separator_color = candidate_separators[0]\n    elif len(candidate_separators) > 1:\n        # Tie-breaking: Choose the most frequent color among the candidates\n        max_count = -1\n        tied_candidates = []\n        for cand_color in candidate_separators:\n            count = color_counts.get(cand_color, 0)\n            if count > max_count:\n                max_count = count\n                tied_candidates = [cand_color]\n            elif count == max_count:\n                tied_candidates.append(cand_color)\n        # If still tied after frequency, just pick the first one\n        if tied_candidates:\n             separator_color = tied_candidates[0]\n            \n    # Fallback if no diversity or tie-breaking failed\n    if separator_color < 0: \n        unique_colors, counts = np.unique(grid, return_counts=True)\n        if len(counts) > 0:\n            # Avoid picking black (0) as separator if possible, unless it's the only color\n            most_frequent_idx = np.argsort(counts)[::-1]\n            for idx in most_frequent_idx:\n                if unique_colors[idx] != 0 or len(unique_colors) == 1:\n                    separator_color = unique_colors[idx]\n                    break\n            if separator_color < 0: # Should only happen if grid was all black\n                 separator_color = 0 \n        else:\n             separator_color = 0 # Default white for empty grid\n\n    # Ensure a valid color (>= 0) is returned\n    if separator_color < 0:\n        separator_color = 0\n\n    return separator_color\n\ndef find_color_blocks(grid: np.ndarray, ignore_color: int = -1) -> list[dict]:\n    \"\"\" \n    Finds all contiguous blocks of the same color using BFS, optionally ignoring one color.\n    Returns a list of dictionaries, each describing a block: its main color,\n    bounding box (top, left, bottom, right - inclusive), height, width, \n    pixel coordinates, and pixel count.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Skip if already visited or if it's the ignore_color\n            if not visited[r, c] and color != ignore_color:\n                q = deque([(r, c)])\n                visited[r, c] = True\n                pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            pixels.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                # Calculate block properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                # Store block information\n                blocks.append({\n                    'color': color, # The main color of the contiguous block\n                    'bounds': (min_r, min_c, max_r, max_c), # top, left, bottom, right (inclusive)\n                    'height': height,\n                    'width': width,\n                    'pixels': pixels, # Set of (row, col) tuples\n                    'pixel_count': len(pixels),\n                })\n    return blocks\n\ndef get_dominant_color(grid_slice: np.ndarray, ignore_color: int) -> int:\n    \"\"\"Finds the most frequent color in a grid slice, ignoring a specific color.\"\"\"\n    unique_elements, counts = np.unique(grid_slice, return_counts=True)\n    # Filter out the ignore_color\n    mask = unique_elements != ignore_color\n    filtered_elements = unique_elements[mask]\n    filtered_counts = counts[mask]\n    \n    if len(filtered_elements) == 0:\n        # If only the ignored color was present, return it as a fallback\n        # Or perhaps return a default like 0? Let's return ignore_color's opposite if simple?\n        # For now, let's default to 0 (white) if no other color found.\n        return 0 \n    else:\n        # Return the element with the highest count\n        return filtered_elements[np.argmax(filtered_counts)]\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid by identifying frame/content pairs, extracting\n    patterns, and assembling them into an output grid based on the described rules.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return [] # Handle empty input\n\n    # 1. Identify the separator color\n    separator_color = get_separator_color(grid)\n\n    # 2. Find all contiguous blocks, excluding the separator color\n    all_blocks = find_color_blocks(grid, ignore_color=separator_color)\n    if not all_blocks:\n        return [] # No objects found besides separator\n\n    # 3. Categorize remaining blocks into 'frame' and 'content' based on size\n    #    We expect rectangular bounding boxes for frames/contents.\n    sizes = defaultdict(list)\n    for block in all_blocks:\n         # Use bounding box dimensions for categorization\n         size_key = (block['height'], block['width'])\n         sizes[size_key].append(block)\n\n    frame_size = None\n    content_size = None\n    possible_pairs = []\n    \n    # Sort potential sizes by area (descending) to check larger ones first\n    sorted_size_keys = sorted(sizes.keys(), key=lambda x: x[0]*x[1], reverse=True) \n\n    # Try to identify frame/content pair based on size relationship (frame = content + 2)\n    for i in range(len(sorted_size_keys)):\n        for j in range(len(sorted_size_keys)):\n            if i == j: continue\n            s_large = sorted_size_keys[i]\n            s_small = sorted_size_keys[j]\n            # Check if larger size is exactly 2 units bigger in height and width\n            if s_large[0] == s_small[0] + 2 and s_large[1] == s_small[1] + 2:\n                # Check if number of blocks matches for this pair\n                if len(sizes[s_large]) == len(sizes[s_small]):\n                    possible_pairs.append({'frame': s_large, 'content': s_small})\n    \n    if len(possible_pairs) == 1:\n        # Found exactly one pair matching the rule and count\n        frame_size = possible_pairs[0]['frame']\n        content_size = possible_pairs[0]['content']\n    elif len(sizes) >= 2 and not possible_pairs:\n        # Fallback: If no pair matches rule exactly, but >= 2 sizes exist,\n        # assume the most frequent largest size is frame, most frequent second largest is content.\n        # This is less robust.\n        size_counts = {size: len(blocks) for size, blocks in sizes.items()}\n        sorted_by_freq_then_area = sorted(\n            sizes.keys(), \n            key=lambda x: (size_counts[x], x[0]*x[1]), \n            reverse=True\n        )\n        if len(sorted_by_freq_then_area) >= 2:\n            frame_size = sorted_by_freq_then_area[0]\n            content_size = sorted_by_freq_then_area[1]\n            # Add a check if counts match even in fallback\n            if size_counts[frame_size] != size_counts[content_size]:\n                 frame_size, content_size = None, None # Reset if counts mismatch\n\n    # Check if sizes were successfully determined\n    if frame_size is None or content_size is None:\n        # Cannot determine sizes reliably, return empty or original? Let's return empty.\n        return [] \n\n    frames = sizes.get(frame_size, [])\n    contents = sizes.get(content_size, [])\n\n    # 4. Sort frames and contents by reading order (top-left corner: row, then column)\n    frames.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n    # *** Assumption: Simple reading order pairing works. This might fail for some tasks. ***\n    contents.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n\n    # Check for equal number of frames and contents after sorting\n    if len(frames) != len(contents):\n        return [] # Error: Mismatch after filtering/sorting\n    if not frames:\n        return [] # No valid frame/content pairs found\n\n    # 5. Determine output grid layout and size based on frame positions\n    min_frame_top = min(f['bounds'][0] for f in frames)\n    min_frame_left = min(f['bounds'][1] for f in frames)\n    # Use the determined frame_size for dimensions\n    max_frame_bottom_coord = max(f['bounds'][0] + frame_size[0] - 1 for f in frames)\n    max_frame_right_coord = max(f['bounds'][1] + frame_size[1] - 1 for f in frames)\n\n    # Calculate output grid dimensions\n    output_height = max_frame_bottom_coord - min_frame_top + 1\n    output_width = max_frame_right_coord - min_frame_left + 1\n    \n    # Check for non-positive dimensions\n    if output_height <= 0 or output_width <= 0:\n        return []\n\n    # 6. Initialize output grid (fill with a default, e.g., white=0 or separator?) Use white=0.\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # 7. Assemble the output grid by combining frame borders and content cores\n    for frame, content in zip(frames, contents):\n        frame_color = frame['color'] # Fc: Main color of the contiguous frame block\n        content_color = content['color'] # Cc: Main color of the contiguous content block\n        \n        f_top, f_left, _, _ = frame['bounds'] # Frame top-left for positioning\n        c_top, c_left, c_bottom, c_right = content['bounds'] # Content bounds for pattern extraction\n\n        # Frame dimensions N x M\n        frame_h, frame_w = frame_size \n        # Content dimensions (N-2) x (M-2)\n        content_h, content_w = content_size \n\n        # Calculate position in output grid based on frame's top-left relative to min top-left\n        out_r_start = f_top - min_frame_top\n        out_c_start = f_left - min_frame_left\n        out_r_end = out_r_start + frame_h # Exclusive index for slicing end\n        out_c_end = out_c_start + frame_w # Exclusive index for slicing end\n\n        # Check if the calculated output position is valid\n        if not (0 <= out_r_start < output_height and 0 <= out_c_start < output_width and \\\n                out_r_end <= output_height and out_c_end <= output_width):\n            continue # Skip this frame if it doesn't fit\n\n        # Draw frame border onto output grid\n        output_grid[out_r_start, out_c_start:out_c_end] = frame_color       # Top border\n        output_grid[out_r_end - 1, out_c_start:out_c_end] = frame_color     # Bottom border\n        output_grid[out_r_start:out_r_end, out_c_start] = frame_color       # Left border\n        output_grid[out_r_start:out_r_end, out_c_end - 1] = frame_color     # Right border\n        \n        # Extract the rectangular content pattern source from the *input* grid\n        # using the content block's bounding box. Remember bounds are inclusive.\n        # Expected slice size is content_h x content_w\n        if c_bottom - c_top + 1 == content_h and c_right - c_left + 1 == content_w:\n             content_pattern_source = grid[c_top : c_bottom + 1, c_left : c_right + 1]\n        else:\n             # Bounding box doesn't match expected content size, maybe noise distorted it?\n             # Try to fallback to expected size centered? Or skip? For now, skip.\n             continue \n\n        # Generate the output core based on the mapping rule\n        output_core = np.zeros_like(content_pattern_source)\n        for r_idx in range(content_h):\n            for c_idx in range(content_w):\n                source_pixel = content_pattern_source[r_idx, c_idx]\n                if source_pixel == separator_color:\n                    output_core[r_idx, c_idx] = frame_color # Fc\n                else:\n                    output_core[r_idx, c_idx] = content_color # Cc\n        \n        # Place the generated output core into the output grid's inner area\n        out_core_r_start = out_r_start + 1\n        out_core_c_start = out_c_start + 1\n        out_core_r_end = out_core_r_start + content_h # Exclusive end\n        out_core_c_end = out_core_c_start + content_w # Exclusive end\n\n        # Ensure the placement fits within the frame border area\n        if out_core_r_end <= (out_r_start + frame_h - 1) and \\\n           out_core_c_end <= (out_c_start + frame_w - 1):\n             output_grid[out_core_r_start : out_core_r_end, out_core_c_start : out_core_c_end] = output_core\n        # Else: Core doesn't fit (shouldn't happen if sizes N and N-2 match), leave the default background (0)\n\n    # 8. Return the final grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 26015,
    "candidates_token_count": 5449,
    "total_token_count": 31464,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 39.176753,
  "retries": 1
}