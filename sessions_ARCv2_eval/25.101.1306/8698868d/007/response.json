{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\n\n\"\"\"\nIdentifies a 'separator' color and distinct objects in the input grid. Objects \nare contiguous blocks of a single non-separator color. These objects are \ncategorized into 'Frames' (larger bounding box, N x M) and 'Contents' \n(smaller bounding box, N-2 x M-2). Assumes a 1-to-1 pairing exists.\n\nThe transformation constructs an output grid by preserving the relative \narrangement of the Frames. Each reconstructed frame in the output consists of:\n1. A 1-pixel border using the Frame's main color (Fc).\n2. An interior 'core' pattern derived from the paired Content block.\n\nTo generate the core pattern:\n- Take the rectangular slice of the *original input grid* corresponding to the \n  Content block's bounding box (size N-2 x M-2). Let this be InputPatternSlice.\n- Identify the main color (Cc) of the Content block.\n- Create an Output Core grid (size N-2 x M-2).\n- For each pixel `p` at `(i, j)` in the InputPatternSlice: \n    - If `p` is the separator color, the Output Core pixel `Oc[i, j]` is Fc.\n    - Otherwise, the Output Core pixel `Oc[i, j]` is Cc.\n\nFrame and Content blocks are paired based on sorting their top-left bounding box \ncorners in reading order (top-to-bottom, left-to-right).\n\"\"\"\n\ndef get_separator_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Identifies the separator color in the grid.\n    Assumes the separator has the highest number of distinct neighboring colors.\n    Ties are broken by choosing the most frequent color among candidates,\n    and then by the lowest color value if frequency is also tied.\n    Falls back to the overall most frequent color if diversity analysis fails.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return 0 # Default white for empty grid\n        \n    neighbor_colors = defaultdict(set)\n    color_counts = defaultdict(int)\n\n    # Iterate through grid to find distinct neighbors and count colors\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            color_counts[color] += 1\n            # Check 8 neighbors (Moore neighborhood)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                         neighbor_color = grid[nr, nc]\n                         # Add neighbor color if it's different from the cell color\n                         if neighbor_color != color:\n                             neighbor_colors[color].add(neighbor_color)\n\n    max_diversity = -1\n    candidate_separators = []\n    present_colors = color_counts.keys()\n\n    # Find colors with maximum neighbor diversity\n    for color in present_colors:\n         neighbors = neighbor_colors[color]\n         num_distinct_neighbors = len(neighbors)\n         if num_distinct_neighbors > max_diversity:\n             max_diversity = num_distinct_neighbors\n             candidate_separators = [color]\n         elif num_distinct_neighbors == max_diversity:\n             candidate_separators.append(color)\n\n    separator_color = -1\n    if len(candidate_separators) == 1:\n        separator_color = candidate_separators[0]\n    elif len(candidate_separators) > 1:\n        # Tie-breaking: 1st by frequency, 2nd by lowest color value\n        max_count = -1\n        best_candidate = -1\n        tied_candidates_by_freq = []\n        \n        for cand_color in candidate_separators:\n            count = color_counts.get(cand_color, 0)\n            if count > max_count:\n                max_count = count\n                tied_candidates_by_freq = [cand_color]\n            elif count == max_count:\n                tied_candidates_by_freq.append(cand_color)\n                \n        if len(tied_candidates_by_freq) == 1:\n             separator_color = tied_candidates_by_freq[0]\n        elif len(tied_candidates_by_freq) > 1:\n              separator_color = min(tied_candidates_by_freq) # Break final tie with min value\n        else: # Should not happen if candidates existed\n             separator_color = candidate_separators[0] # Fallback within tie-break\n            \n    # Fallback if diversity analysis failed\n    if separator_color < 0: \n        if color_counts:\n             # Sort by count desc, then color asc for tie-breaking\n             sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n             separator_color = sorted_colors[0][0]\n        else:\n             separator_color = 0 # Default white for empty grid\n\n    # Ensure a valid color (>= 0) is returned\n    if separator_color < 0:\n        separator_color = 0\n\n    return separator_color\n\n\ndef find_color_blocks(grid: np.ndarray, ignore_color: int) -> list[dict]:\n    \"\"\" \n    Finds all contiguous blocks of the same color using BFS, ignoring ignore_color.\n    Returns a list of dictionaries, each describing a block: its main color,\n    bounding box (top, left, bottom, right - inclusive), height, and width.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Skip if already visited or if it's the ignore_color\n            if not visited[r, c] and color != ignore_color:\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # BFS to find all connected pixels of the same color\n                # Only need to track bounds, not all pixels\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Calculate block properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                # Store block information\n                blocks.append({\n                    'color': color, # The main color of the contiguous block\n                    'bounds': (min_r, min_c, max_r, max_c), # top, left, bottom, right (inclusive)\n                    'height': height,\n                    'width': width,\n                })\n    return blocks\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the specified rules: identifies \n    frame/content pairs, extracts patterns, and assembles them into an output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return [] # Handle empty input\n\n    # 1. Identify the separator color\n    separator_color = get_separator_color(grid)\n\n    # 2. Find all contiguous non-separator blocks\n    all_blocks = find_color_blocks(grid, ignore_color=separator_color)\n    if not all_blocks:\n        return [] # No objects found\n\n    # 3. Categorize blocks into 'frame' and 'content' based on bounding box size\n    sizes = defaultdict(list)\n    for block in all_blocks:\n        size_key = (block['height'], block['width'])\n        sizes[size_key].append(block)\n\n    frame_size = None\n    content_size = None\n    possible_pairs = []\n    \n    # Sort potential sizes by area (descending)\n    sorted_size_keys = sorted(sizes.keys(), key=lambda x: x[0]*x[1], reverse=True) \n\n    # Identify frame/content pair based on size relationship (frame = content + 2)\n    for i in range(len(sorted_size_keys)):\n        s_large = sorted_size_keys[i]\n        for j in range(len(sorted_size_keys)):\n            if i == j: continue\n            s_small = sorted_size_keys[j]\n            # Check if larger size is exactly 2 units bigger in height and width\n            if s_large[0] == s_small[0] + 2 and s_large[1] == s_small[1] + 2:\n                # Check if number of blocks matches for this pair\n                if len(sizes[s_large]) == len(sizes[s_small]):\n                    possible_pairs.append({'frame': s_large, 'content': s_small})\n                    break # Found a potential content size for this frame size\n\n    # Select the best pair \n    if len(possible_pairs) == 1:\n        frame_size = possible_pairs[0]['frame']\n        content_size = possible_pairs[0]['content']\n    elif len(possible_pairs) > 1:\n         # Ambiguous: Default to the pair with the largest frame size.\n         possible_pairs.sort(key=lambda p: p['frame'][0]*p['frame'][1], reverse=True)\n         frame_size = possible_pairs[0]['frame']\n         content_size = possible_pairs[0]['content']\n    # No fallback implemented if N vs N-2 rule fails\n\n    # Ensure sizes were determined\n    if frame_size is None or content_size is None:\n        return [] # Cannot determine sizes reliably\n\n    frames = sizes.get(frame_size, [])\n    contents = sizes.get(content_size, [])\n\n    # 4. Sort frames and contents by reading order (top-left corner)\n    frames.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n    contents.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n\n    # Check for equal number of frames and contents after sorting\n    if len(frames) != len(contents) or not frames:\n        return [] # Mismatch or no pairs found\n\n    # 5. Determine output grid layout and size\n    min_frame_top = min(f['bounds'][0] for f in frames)\n    min_frame_left = min(f['bounds'][1] for f in frames)\n    # Use Frame size for calculating max bounds, not just bounds[2]/bounds[3]\n    # which might be affected if the found block wasn't perfectly rectangular initially\n    max_frame_bottom = max(f['bounds'][0] + frame_size[0] - 1 for f in frames)\n    max_frame_right = max(f['bounds'][1] + frame_size[1] - 1 for f in frames)\n\n    output_height = max_frame_bottom - min_frame_top + 1\n    output_width = max_frame_right - min_frame_left + 1\n    \n    if output_height <= 0 or output_width <= 0:\n        return [] # Invalid dimensions\n\n    # 6. Initialize output grid (filled with white=0)\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # 7. Process pairs and construct output\n    for frame, content in zip(frames, contents):\n        frame_color = frame['color']    # Fc\n        content_color = content['color']  # Cc\n        \n        f_top, f_left, _, _ = frame['bounds'] # Use top-left for positioning\n        c_top, c_left, c_bottom, c_right = content['bounds'] \n        \n        frame_h, frame_w = frame_size \n        content_h, content_w = content_size \n\n        # Calculate target top-left position in output grid\n        out_r_start = f_top - min_frame_top\n        out_c_start = f_left - min_frame_left\n        out_r_end = out_r_start + frame_h # Exclusive index for slicing\n        out_c_end = out_c_start + frame_w # Exclusive index for slicing\n\n        # Ensure target position is within bounds of output grid\n        if not (0 <= out_r_start < output_height and 0 <= out_c_start < output_width and \\\n                out_r_end <= output_height and out_c_end <= output_width):\n            continue # Skip if frame placement is out of bounds\n\n        # Extract the InputPatternSlice from the original grid using Content bounds\n        # Slicing uses exclusive end index, so add 1 to inclusive bounds\n        input_pattern_slice = grid[c_top : c_bottom + 1, c_left : c_right + 1]\n        \n        # Verify extracted slice matches expected content dimensions\n        if input_pattern_slice.shape != (content_h, content_w):\n             # Content block bounds did not match expected size, skip.\n             continue\n\n        # Generate the Output Core based on the mapping rule\n        output_core = np.zeros_like(input_pattern_slice)\n        for r_idx in range(content_h):\n            for c_idx in range(content_w):\n                source_pixel = input_pattern_slice[r_idx, c_idx]\n                if source_pixel == separator_color:\n                    output_core[r_idx, c_idx] = frame_color # Use Frame color (Fc)\n                else:\n                    output_core[r_idx, c_idx] = content_color # Use Content color (Cc)\n        \n        # Draw frame border onto output grid\n        output_grid[out_r_start, out_c_start:out_c_end] = frame_color       # Top border\n        output_grid[out_r_end - 1, out_c_start:out_c_end] = frame_color     # Bottom border\n        output_grid[out_r_start:out_r_end, out_c_start] = frame_color       # Left border\n        output_grid[out_r_start:out_r_end, out_c_end - 1] = frame_color     # Right border\n\n        # Place the generated Output Core into the output grid's inner area\n        out_core_r_start = out_r_start + 1\n        out_core_c_start = out_c_start + 1\n        out_core_r_end = out_core_r_start + content_h # Exclusive end for slicing\n        out_core_c_end = out_core_c_start + content_w # Exclusive end for slicing\n\n        # Ensure placement fits within the frame border area in the output grid\n        if out_core_r_end <= (out_r_end - 1) and \\\n           out_core_c_end <= (out_c_end - 1) and \\\n           out_core_r_start >= out_r_start and \\\n           out_core_c_start >= out_c_start:\n                output_grid[out_core_r_start : out_core_r_end, out_core_c_start : out_core_c_end] = output_core\n        # Else: Core doesn't fit - logic assumes N vs N-2 holds, so this shouldn't normally fail.\n\n    # 8. Return the final grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 71485,
    "candidates_token_count": 4386,
    "total_token_count": 75871,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.094259,
  "retries": 1
}