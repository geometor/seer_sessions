{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\n\n\"\"\"\nIdentifies a 'separator' color and distinct rectangular objects ('frames' and 'contents') in the input grid. \nFrames are larger (N x M) and Contents are smaller (N-2 x M-2), identified as contiguous blocks of non-separator colors.\nThe transformation constructs an output grid preserving the relative arrangement of the Frames.\nEach Frame's 1-pixel border (using its main color, Fc) is copied to the output.\nThe interior (core) of each Frame in the output is filled based on a pattern derived from its paired Content block.\nTo generate the core:\n1. Identify the main color (Fc) of the Frame block and the main color (Cc) of the paired Content block.\n2. Take the rectangular slice of the *original input grid* corresponding to the Content block's bounding box (size N-2 x M-2). Let this be InputPatternSlice.\n3. Create an Output Core grid (size N-2 x M-2).\n4. For each pixel `p` at `(i, j)` in the InputPatternSlice: if `p` is the separator color, the Output Core pixel `Oc[i, j]` is Fc; otherwise, it's Cc.\nFrame and Content blocks are paired based on their reading order (top-to-bottom, left-to-right sorting of their top-left corners).\n\"\"\"\n\ndef get_separator_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Identifies the separator color in the grid.\n    The separator is assumed to be the color that has the highest number of\n    distinct neighboring colors (adjacency diversity). Ties are broken by\n    choosing the most frequent color among the candidates with max diversity.\n    As a fallback, returns the most frequent color in the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return 0 # Default for empty grid (white)\n        \n    neighbor_colors = defaultdict(set)\n    color_counts = defaultdict(int)\n\n    # Iterate through grid to find distinct neighbors and count colors\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            color_counts[color] += 1\n            # Check 8 neighbors (Moore neighborhood)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                         neighbor_color = grid[nr, nc]\n                         # Add neighbor color if it's different from the cell color\n                         if neighbor_color != color:\n                             neighbor_colors[color].add(neighbor_color)\n\n    max_diversity = -1\n    candidate_separators = []\n\n    # Find the colors with the maximum number of distinct neighbor colors\n    # Consider only colors present in the grid\n    present_colors = color_counts.keys()\n    for color in present_colors:\n         neighbors = neighbor_colors[color] # Get neighbors for this color\n         num_distinct_neighbors = len(neighbors)\n         if num_distinct_neighbors > max_diversity:\n             max_diversity = num_distinct_neighbors\n             candidate_separators = [color] # New maximum found\n         elif num_distinct_neighbors == max_diversity:\n             candidate_separators.append(color) # Add to candidates with same max diversity\n\n    separator_color = -1\n    if len(candidate_separators) == 1:\n        # Only one color has the maximum diversity\n        separator_color = candidate_separators[0]\n    elif len(candidate_separators) > 1:\n        # Tie-breaking: Choose the most frequent color among the candidates\n        max_count = -1\n        tied_candidates = []\n        for cand_color in candidate_separators:\n            count = color_counts.get(cand_color, 0)\n            if count > max_count:\n                max_count = count\n                tied_candidates = [cand_color]\n            elif count == max_count:\n                tied_candidates.append(cand_color)\n        # If still tied after frequency, just pick the first one (often lowest numerical value)\n        if tied_candidates:\n             separator_color = min(tied_candidates) # Use min as a consistent tie-breaker\n            \n    # Fallback if no diversity or tie-breaking failed\n    if separator_color < 0: \n        # Fallback to most frequent color overall\n        if color_counts:\n             # Sort by count desc, then color asc for tie-breaking\n             sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n             separator_color = sorted_colors[0][0]\n        else:\n             separator_color = 0 # Default white for empty grid\n\n\n    # Ensure a valid color (>= 0) is returned\n    if separator_color < 0:\n        separator_color = 0 # Should not happen with current logic, but safety check\n\n    return separator_color\n\n\ndef find_color_blocks(grid: np.ndarray, ignore_color: int = -1) -> list[dict]:\n    \"\"\" \n    Finds all contiguous blocks of the same color using BFS, optionally ignoring one color.\n    Returns a list of dictionaries, each describing a block: its main color,\n    bounding box (top, left, bottom, right - inclusive), height, width, \n    and pixel count. Only returns blocks that form perfect rectangles within their bounds.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Skip if already visited or if it's the ignore_color\n            if not visited[r, c] and color != ignore_color:\n                q = deque([(r, c)])\n                visited[r, c] = True\n                pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            pixels.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                # Calculate block properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                pixel_count = len(pixels)\n                \n                # Only consider blocks that are solid rectangles (pixel count == height * width)\n                if pixel_count == height * width:\n                    blocks.append({\n                        'color': color, # The main color of the contiguous block\n                        'bounds': (min_r, min_c, max_r, max_c), # top, left, bottom, right (inclusive)\n                        'height': height,\n                        'width': width,\n                        'pixel_count': pixel_count,\n                    })\n    return blocks\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the specified rules.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return [] # Handle empty input\n\n    # 1. Identify the separator color\n    separator_color = get_separator_color(grid)\n\n    # 2. Find all contiguous non-separator blocks that are perfect rectangles\n    all_blocks = find_color_blocks(grid, ignore_color=separator_color)\n    if not all_blocks:\n        return [] # No valid objects found\n\n    # 3. Categorize blocks into 'frame' and 'content' based on size\n    sizes = defaultdict(list)\n    for block in all_blocks:\n        size_key = (block['height'], block['width'])\n        sizes[size_key].append(block)\n\n    frame_size = None\n    content_size = None\n    possible_pairs = []\n    \n    # Sort potential sizes by area (descending)\n    sorted_size_keys = sorted(sizes.keys(), key=lambda x: x[0]*x[1], reverse=True) \n\n    # Identify frame/content pair based on size relationship (frame = content + 2)\n    for i in range(len(sorted_size_keys)):\n        for j in range(len(sorted_size_keys)):\n            if i == j: continue\n            s_large = sorted_size_keys[i]\n            s_small = sorted_size_keys[j]\n            # Check if larger size is exactly 2 units bigger in height and width\n            if s_large[0] == s_small[0] + 2 and s_large[1] == s_small[1] + 2:\n                # Check if number of blocks matches for this pair\n                if len(sizes[s_large]) == len(sizes[s_small]):\n                    possible_pairs.append({'frame': s_large, 'content': s_small})\n                    # Break inner loop once a valid pair type is found for s_large\n                    break \n        # If a pair was found for s_large, no need to check smaller s_large candidates\n        if any(p['frame'] == s_large for p in possible_pairs):\n            pass # Could potentially break outer loop if only one type expected\n\n    # Select the best pair (currently assumes only one valid pair type exists)\n    if len(possible_pairs) == 1:\n        frame_size = possible_pairs[0]['frame']\n        content_size = possible_pairs[0]['content']\n    elif len(possible_pairs) > 1:\n         # Ambiguous: multiple size pairs fit the N vs N-2 rule with matching counts.\n         # Default to the pair with the largest frame size.\n         possible_pairs.sort(key=lambda p: p['frame'][0]*p['frame'][1], reverse=True)\n         frame_size = possible_pairs[0]['frame']\n         content_size = possible_pairs[0]['content']\n    else:\n         # Fallback if no N vs N-2 pair found (less likely for this task based on examples)\n         if len(sorted_size_keys) >= 2:\n              # Check if the top two sizes have matching counts\n              size1 = sorted_size_keys[0]\n              size2 = sorted_size_keys[1]\n              if len(sizes[size1]) == len(sizes[size2]):\n                  frame_size = size1\n                  content_size = size2\n              # Else: Cannot reliably determine sizes\n         \n    # Ensure sizes were determined\n    if frame_size is None or content_size is None:\n        return [] # Cannot determine sizes reliably\n\n    frames = sizes.get(frame_size, [])\n    contents = sizes.get(content_size, [])\n\n    # 4. Sort frames and contents by reading order (top-left corner)\n    frames.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n    contents.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n\n    # Check for equal number of frames and contents after sorting\n    if len(frames) != len(contents) or not frames:\n        return [] # Mismatch or no pairs found\n\n    # 5. Determine output grid layout and size\n    min_frame_top = min(f['bounds'][0] for f in frames)\n    min_frame_left = min(f['bounds'][1] for f in frames)\n    max_frame_bottom = max(f['bounds'][2] for f in frames)\n    max_frame_right = max(f['bounds'][3] for f in frames)\n\n    # Calculate output grid dimensions based on relative positioning\n    output_height = max_frame_bottom - min_frame_top + 1\n    output_width = max_frame_right - min_frame_left + 1\n    \n    if output_height <= 0 or output_width <= 0:\n        return [] # Invalid dimensions\n\n    # 6. Initialize output grid (filled with white=0)\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # 7. Process pairs and construct output\n    for frame, content in zip(frames, contents):\n        frame_color = frame['color']    # Fc\n        content_color = content['color']  # Cc\n        \n        f_top, f_left, f_bottom, f_right = frame['bounds']\n        c_top, c_left, c_bottom, c_right = content['bounds'] \n        \n        frame_h, frame_w = frame_size \n        content_h, content_w = content_size \n\n        # Calculate target top-left position in output grid\n        out_r_start = f_top - min_frame_top\n        out_c_start = f_left - min_frame_left\n        out_r_end = out_r_start + frame_h # Exclusive index for slicing\n        out_c_end = out_c_start + frame_w # Exclusive index for slicing\n\n        # Ensure target position is within bounds\n        if not (0 <= out_r_start < output_height and 0 <= out_c_start < output_width and \\\n                out_r_end <= output_height and out_c_end <= output_width):\n            continue # Skip if frame placement is out of bounds\n\n        # Extract the InputPatternSlice from the original grid using Content bounds\n        # Slicing uses exclusive end index, so add 1 to inclusive bounds\n        input_pattern_slice = grid[c_top : c_bottom + 1, c_left : c_right + 1]\n        \n        # Verify extracted slice matches expected content dimensions\n        if input_pattern_slice.shape != (content_h, content_w):\n             # This might happen if the content block wasn't perfectly rectangular\n             # or bounds were calculated incorrectly. Skip this pair.\n             continue\n\n        # Generate the Output Core based on the mapping rule\n        output_core = np.zeros_like(input_pattern_slice)\n        for r_idx in range(content_h):\n            for c_idx in range(content_w):\n                source_pixel = input_pattern_slice[r_idx, c_idx]\n                if source_pixel == separator_color:\n                    output_core[r_idx, c_idx] = frame_color # Use Frame color (Fc)\n                else:\n                    output_core[r_idx, c_idx] = content_color # Use Content color (Cc)\n        \n        # Draw frame border onto output grid\n        output_grid[out_r_start, out_c_start:out_c_end] = frame_color       # Top border\n        output_grid[out_r_end - 1, out_c_start:out_c_end] = frame_color     # Bottom border\n        output_grid[out_r_start:out_r_end, out_c_start] = frame_color       # Left border\n        output_grid[out_r_start:out_r_end, out_c_end - 1] = frame_color     # Right border\n\n        # Place the generated Output Core into the output grid's inner area\n        out_core_r_start = out_r_start + 1\n        out_core_c_start = out_c_start + 1\n        out_core_r_end = out_core_r_start + content_h # Exclusive end\n        out_core_c_end = out_core_c_start + content_w # Exclusive end\n\n        # Final check: Ensure placement fits within frame border area in output grid\n        if out_core_r_end <= (out_r_end -1) and \\\n           out_core_c_end <= (out_c_end -1):\n             output_grid[out_core_r_start : out_core_r_end, out_core_c_start : out_core_c_end] = output_core\n        # Else: Core doesn't fit (shouldn't happen if N vs N-2 logic is correct)\n\n    # 8. Return the final grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 52532,
    "candidates_token_count": 4587,
    "total_token_count": 57119,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 31.451049,
  "retries": 1
}