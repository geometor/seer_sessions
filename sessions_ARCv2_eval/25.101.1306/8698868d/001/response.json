{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict, deque\n\n\"\"\"\nIdentifies 'frame' and 'content' rectangular blocks separated by a background color \nin the input grid. The background/separator color is identified as the color \nadjacent to the most diverse set of other colors. The 'frame' blocks are larger \nthan the 'content' blocks, typically by 2 units in height and width. \nThe transformation constructs an output grid by preserving the relative arrangement \nof the frame blocks. For each frame block, its 1-pixel border is drawn in the output. \nThe interior area of the frame in the output is then filled with the pattern found \nin the interior (excluding the 1-pixel border) of the corresponding 'content' block \nfrom the input grid. Frame and content blocks are paired based on their reading order \n(top-to-bottom, left-to-right).\n\"\"\"\n\ndef get_separator_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Identifies the separator color in the grid.\n    The separator is assumed to be the color that has the highest number of\n    distinct neighboring colors (adjacency diversity). Ties are broken by\n    choosing the most frequent color among the candidates with max diversity.\n    As a fallback, returns the most frequent color in the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return 0 # Default for empty grid (white)\n        \n    neighbor_colors = defaultdict(set)\n\n    # Iterate through grid to find distinct neighbors for each color\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check 8 neighbors (Moore neighborhood)\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                         neighbor_color = grid[nr, nc]\n                         # Add neighbor color if it's different from the cell color\n                         if neighbor_color != color:\n                             neighbor_colors[color].add(neighbor_color)\n\n    max_diversity = -1\n    candidate_separators = []\n\n    # Find the colors with the maximum number of distinct neighbor colors\n    for color, neighbors in neighbor_colors.items():\n         num_distinct_neighbors = len(neighbors)\n         if num_distinct_neighbors > max_diversity:\n             max_diversity = num_distinct_neighbors\n             candidate_separators = [color] # New maximum found\n         elif num_distinct_neighbors == max_diversity:\n             candidate_separators.append(color) # Add to candidates with same max diversity\n\n    separator_color = -1\n    if len(candidate_separators) == 1:\n        # Only one color has the maximum diversity\n        separator_color = candidate_separators[0]\n    elif len(candidate_separators) > 1:\n        # Tie-breaking: Choose the most frequent color among the candidates\n        counts = defaultdict(int)\n        grid_flat = grid.flatten()\n        for pixel_color in grid_flat:\n            if pixel_color in candidate_separators:\n                counts[pixel_color] += 1\n        # Find the color with the max count among candidates\n        if counts:\n            separator_color = max(counts, key=counts.get)\n        else: # Should not happen if candidates exist, but as safety:\n            separator_color = candidate_separators[0] \n            \n    else: \n         # Fallback: If no diversity found (e.g., solid grid) or other issue\n         # guess the most frequent color overall as the separator (less reliable)\n        unique_colors, counts = np.unique(grid, return_counts=True)\n        if len(counts) > 0:\n             separator_color = unique_colors[np.argmax(counts)]\n        else:\n             separator_color = 0 # Default white for empty grid\n\n    # Ensure a valid color (>= 0) is returned\n    if separator_color < 0:\n        separator_color = 0\n\n    return separator_color\n\ndef find_color_blocks(grid: np.ndarray) -> list[dict]:\n    \"\"\" \n    Finds all contiguous blocks of the same color using BFS.\n    Returns a list of dictionaries, each describing a block: its color,\n    bounding box (top, left, bottom, right - inclusive), height, width, \n    and pixel count.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    for r in range(rows):\n        for c in range(cols):\n             # If cell hasn't been visited yet, start a new block search\n             if not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                pixels = set([(r,c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                # BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visit status, and color match\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            pixels.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                # Calculate block properties\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                # Store block information\n                blocks.append({\n                    'color': color,\n                    'bounds': (min_r, min_c, max_r, max_c), # top, left, bottom, right (inclusive)\n                    'height': height,\n                    'width': width,\n                    'pixel_count': len(pixels),\n                })\n    return blocks\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the rules derived from the examples.\n    1. Identifies the separator color.\n    2. Finds all contiguous blocks of non-separator colors.\n    3. Categorizes blocks into 'frames' (larger) and 'contents' (smaller) based on size,\n       preferring pairs where frame_size = content_size + (2, 2).\n    4. Sorts frames and contents by reading order.\n    5. Constructs the output grid by placing frame borders and content cores according\n       to the relative positions of the frames.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return [] # Handle empty input\n\n    # 1. Identify the separator color\n    separator_color = get_separator_color(grid)\n\n    # 2. Find all contiguous blocks of solid color\n    all_blocks = find_color_blocks(grid)\n    \n    # 3. Filter out blocks that match the identified separator color\n    object_blocks = [b for b in all_blocks if b['color'] != separator_color]\n    if not object_blocks:\n        return [] # No objects found besides separator\n\n    # 4. Categorize remaining blocks into 'frame' and 'content' based on size\n    sizes = defaultdict(list)\n    for block in object_blocks:\n        # Group blocks by their bounding box dimensions (height, width)\n        sizes[(block['height'], block['width'])].append(block)\n\n    frame_size = None\n    content_size = None\n\n    # Try to identify frame/content pair based on size relationship (frame = content + 2)\n    possible_pairs = []\n    sorted_size_keys = sorted(sizes.keys(), key=lambda x: x[0]*x[1], reverse=True) # Sort by area\n    for i in range(len(sorted_size_keys)):\n        for j in range(len(sorted_size_keys)): # Check all pairs, not just i+1\n             if i == j: continue\n             s_large = sorted_size_keys[i]\n             s_small = sorted_size_keys[j]\n             # Check if larger size is exactly 2 units bigger in height and width\n             if s_large[0] == s_small[0] + 2 and s_large[1] == s_small[1] + 2:\n                  # Check if number of blocks matches for this pair\n                  if len(sizes[s_large]) == len(sizes[s_small]):\n                      possible_pairs.append({'frame': s_large, 'content': s_small})\n\n    if len(possible_pairs) == 1:\n        # Found exactly one pair matching the rule and count\n        frame_size = possible_pairs[0]['frame']\n        content_size = possible_pairs[0]['content']\n    elif len(sizes) >= 2:\n         # Fallback: If multiple pairs match or no pair matches rule exactly,\n         # assume the most frequent largest size is frame, most frequent second largest is content.\n         # Or simply the largest two sizes if counts are equal.\n         if len(sorted_size_keys) >= 2:\n            frame_size = sorted_size_keys[0]\n            content_size = sorted_size_keys[1]\n            # Optional: Add check len(sizes[frame_size]) == len(sizes[content_size])\n            if len(sizes.get(frame_size,[])) != len(sizes.get(content_size,[])):\n                 # Counts don't match, indicates ambiguity\n                 return input_grid # Return original grid on failure\n    else:\n        # Cannot determine frame/content sizes reliably\n        return input_grid # Return original grid on failure\n\n    # Ensure sizes were determined\n    if frame_size is None or content_size is None:\n         return input_grid # Return original grid on failure\n\n    frames = sizes.get(frame_size, [])\n    contents = sizes.get(content_size, [])\n\n    # 5. Sort frames and contents by reading order (top-left corner: row, then column)\n    frames.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n    contents.sort(key=lambda x: (x['bounds'][0], x['bounds'][1]))\n\n    # Check for equal number of frames and contents after sorting\n    if len(frames) != len(contents):\n         return input_grid # Error: Mismatch after filtering/sorting\n    if not frames:\n        return [] # No valid frame/content pairs found\n\n    # 6. Determine output grid layout and size based on frame positions\n    min_frame_top = min(f['bounds'][0] for f in frames)\n    min_frame_left = min(f['bounds'][1] for f in frames)\n    # Calculate max bottom/right coordinates using frame_size for dimensions\n    max_frame_bottom_coord = max(f['bounds'][0] + frame_size[0] - 1 for f in frames)\n    max_frame_right_coord = max(f['bounds'][1] + frame_size[1] - 1 for f in frames)\n\n    # Calculate output grid dimensions\n    output_height = max_frame_bottom_coord - min_frame_top + 1\n    output_width = max_frame_right_coord - min_frame_left + 1\n    \n    # Check for non-positive dimensions\n    if output_height <= 0 or output_width <= 0:\n        return []\n\n    # 7. Initialize output grid (fill with white=0 by default)\n    output_grid = np.zeros((output_height, output_width), dtype=int) \n\n    # 8. Assemble the output grid by combining frame borders and content cores\n    for frame, content in zip(frames, contents):\n        f_top, f_left, _, _ = frame['bounds'] # Frame top-left for positioning\n        c_top, c_left, c_bottom, c_right = content['bounds'] # Content bounds for core extraction\n        \n        frame_h, frame_w = frame_size # Use determined consistent frame size\n        content_h, content_w = content_size # Use determined consistent content size\n\n        # Calculate position in output grid based on frame's top-left relative to min top-left\n        out_r_start = f_top - min_frame_top\n        out_c_start = f_left - min_frame_left\n        out_r_end = out_r_start + frame_h # Exclusive index for slicing end\n        out_c_end = out_c_start + frame_w # Exclusive index for slicing end\n\n        # Frame color is the color of the contiguous block found\n        frame_color = frame['color'] \n\n        # Draw frame border onto output grid if within bounds\n        if 0 <= out_r_start < output_height and 0 <= out_c_start < output_width and \\\n           out_r_end <= output_height and out_c_end <= output_width:\n            output_grid[out_r_start, out_c_start:out_c_end] = frame_color       # Top border\n            output_grid[out_r_end - 1, out_c_start:out_c_end] = frame_color     # Bottom border\n            output_grid[out_r_start:out_r_end, out_c_start] = frame_color       # Left border\n            output_grid[out_r_start:out_r_end, out_c_end - 1] = frame_color     # Right border\n        else:\n            continue # Skip this frame if it doesn't fit\n\n        # Extract content inner core from the *input* grid using content bounds\n        core_r_start_in = c_top + 1\n        core_r_end_in = c_bottom # Inclusive bound from find_color_blocks\n        core_c_start_in = c_left + 1\n        core_c_end_in = c_right # Inclusive bound from find_color_blocks\n\n        # Calculate expected core dimensions based on content_size\n        expected_core_h = content_h - 2\n        expected_core_w = content_w - 2\n        \n        # Check if core dimensions are valid and extract\n        if expected_core_h > 0 and expected_core_w > 0 and \\\n           core_r_end_in >= core_r_start_in and core_c_end_in >= core_c_start_in:\n            \n            # Slice using numpy: end index is exclusive, so add 1 to inclusive bounds\n            content_core = grid[core_r_start_in : core_r_end_in + 1, core_c_start_in : core_c_end_in + 1]\n            actual_core_h, actual_core_w = content_core.shape\n            \n            # Place content core into the output grid's inner area\n            # Destination indices within the output grid\n            out_core_r_start = out_r_start + 1\n            out_core_c_start = out_c_start + 1\n            out_core_r_end = out_core_r_start + actual_core_h # Exclusive end\n            out_core_c_end = out_core_c_start + actual_core_w # Exclusive end\n            \n            # Final check: ensure extracted core size matches expected size and fits within frame border\n            if actual_core_h == expected_core_h and actual_core_w == expected_core_w and \\\n               out_core_r_end <= (out_r_start + frame_h -1) and \\\n               out_core_c_end <= (out_c_start + frame_w -1) and \\\n               out_core_r_start < output_height and out_core_c_start < output_width: # Check placement start is valid\n                 output_grid[out_core_r_start : out_core_r_end, out_core_c_start : out_core_c_end] = content_core\n            # else: Core size mismatch or doesn't fit, leave the default background (0)\n\n    # 9. Return the final grid as list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5237,
    "candidates_token_count": 18962,
    "total_token_count": 24199,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 132.581102,
  "retries": 1
}