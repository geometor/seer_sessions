
## train_1

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 2 7 7 7 7 7 7 7 7 7 7 7 1 7
7 2 7 7 7 7 7 7 7 9 7 7 7 1 7 7
2 7 7 7 7 7 7 7 9 7 7 7 1 7 7 7
7 7 7 2 7 7 7 9 7 7 7 1 7 7 7 7
7 7 2 7 7 7 9 7 7 7 1 7 7 7 7 7
7 7 7 7 7 9 7 7 7 1 7 7 7 7 7 7
7 7 7 7 9 7 7 7 1 7 7 7 7 7 7 7
7 7 7 7 7 7 7 1 7 7 7 1 7 7 7 7
7 7 7 7 7 7 1 7 7 7 1 7 7 7 7 7
7 7 7 7 7 7 7 7 7 1 7 7 7 7 7 7
7 7 7 7 7 7 7 7 1 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 2 7 7 7 7 7 7 7 7 7 7
7 7 7 7 2 7 7 7 7 7 7 7 7 7 7 7
7 7 7 2 7 7 7 2 7 7 7 7 7 7 7 7
7 7 2 7 7 7 2 7 7 7 7 7 7 7 7 7
7 2 7 7 7 2 7 7 7 9 7 7 7 7 7 7
2 7 7 7 2 7 7 7 9 7 7 7 7 7 7 7
7 7 7 2 7 7 7 9 7 7 7 1 7 7 7 7
7 7 2 7 7 7 9 7 7 7 1 7 7 7 7 7
7 7 7 7 7 9 7 7 7 1 7 7 7 1 7 7
7 7 7 7 9 7 7 7 1 7 7 7 1 7 7 7
7 7 7 7 7 7 7 1 7 7 7 1 7 7 7 7
7 7 7 7 7 7 1 7 7 7 1 7 7 7 7 7
7 7 7 7 7 7 7 7 7 1 7 7 7 7 7 7
7 7 7 7 7 7 7 7 1 7 7 7 7 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 5 5 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 9 9 9 9 9 9 9 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 3 3 3 3 3 3 3 3 3 3 3 3 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 5 5 5 5 5 5 5 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 9 9 9 9 9 9 9 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 3 3 3 3 3 3 3 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 7 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 7 7 7 8 7 8 7 7 7 7 7 8 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 8 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 8 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 8 7 7 8 7 8 7 8 7 7 7 8 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

Okay, let's break down the task based on the provided examples.

**Perception of Elements:**

1.  **Grid Structure:** All examples use a 16x16 grid.
2.  **Background Color:** The predominant background color is orange (7).
3.  **Foreground Objects:** Various other colors appear as pixels, sometimes forming lines or scattered patterns. These include red (2), maroon (9), blue (1), gray (5), green (3), and azure (8).
4.  **Transformations:** The core task involves modifying the arrangement or extent of these foreground colored pixels based on their color and initial configuration. The background remains orange unless foreground pixels overwrite it.
5.  **Rule Variability:** The specific transformation rule appears to change depending on the set of colors present in the input grid. Each example seems to demonstrate a distinct rule:
    *   Example 1 (Red, Maroon, Blue): Diagonal line extension.
    *   Example 2 (Gray, Maroon, Green): Horizontal line adjustment (extension/truncation) to a specific column boundary (column 9).
    *   Example 3 (Azure): Vertical gap filling between pixels of the same color within a column.

**YAML Facts:**


```yaml
Grid:
  Size: 16x16
  Background: Orange (7)

Objects:
  - Type: Pixel
    Properties:
      - Color: [Red(2), Maroon(9), Blue(1), Gray(5), Green(3), Azure(8), Orange(7)]
      - Position: (row, column)
  - Type: Line/Segment
    Properties:
      - Color: [Red(2), Maroon(9), Blue(1), Gray(5), Green(3), Azure(8)]
      - Orientation: [Diagonal_UpLeft, Diagonal_UpRight, Diagonal_DownRight, Horizontal, Vertical]
      - Endpoints: (start_row, start_col), (end_row, end_col)
  - Type: Vertical Gap
    Properties:
      - Column: column_index
      - Boundaries: Defined by two pixels of the same color (Azure) in the same column.
      - Content: Orange pixels between the boundary pixels.

Relationships:
  - Color_To_Action_Mapping:
      - {Red(2), Maroon(9), Blue(1)} -> Diagonal Extension
      - {Gray(5), Green(3), Maroon(9)} -> Horizontal Adjustment to Column 9
      - {Azure(8)} -> Vertical Gap Filling
  - Adjacency: Pixels can be adjacent horizontally, vertically, or diagonally.
  - Betweenness: Orange pixels located vertically between two Azure pixels in the same column.

Actions:
  - Identify unique non-background colors.
  - Select transformation rule based on the identified color set.
  - Trace lines diagonally (up-left, up-right, down-right).
  - Extend lines horizontally.
  - Truncate lines horizontally.
  - Fill vertical gaps between pixels.
  - Change pixel color (Orange to foreground color, or foreground color to Orange).
  - Stop action based on grid boundaries or encountering non-Orange pixels.
```


**Natural Language Program:**

1.  Initialize the `output` grid as a direct copy of the `input` grid.
2.  Identify the set of unique colors present in the `input` grid, excluding the background color Orange (7). Let this set be `active_colors`.
3.  **Conditional Rule Application:**
    a.  **If** `active_colors` consists of Red (2), Maroon (9), and Blue (1):
        i.  Create a list of potential changes.
        ii. For every cell `(r, c)` in the `input` grid containing Red (2): Trace diagonally up-left `(r-i, c-i)` for `i = 1, 2, ...`. If the traced cell `(r-i, c-i)` is within grid bounds and contains Orange (7), add `((r-i, c-i), Red)` to the changes list. Stop tracing this path when hitting a grid boundary or a non-Orange cell.
        iii. For every cell `(r, c)` in the `input` grid containing Maroon (9): Trace diagonally up-right `(r-i, c+i)` for `i = 1, 2, ...`. If the traced cell `(r-i, c+i)` is within grid bounds and contains Orange (7), add `((r-i, c+i), Maroon)` to the changes list. Stop tracing this path when hitting a grid boundary or a non-Orange cell.
        iv. For every cell `(r, c)` in the `input` grid containing Blue (1): Trace diagonally down-right `(r+i, c+i)` for `i = 1, 2, ...`. If the traced cell `(r+i, c+i)` is within grid bounds and contains Orange (7), add `((r+i, c+i), Blue)` to the changes list. Stop tracing this path when hitting a grid boundary or a non-Orange cell.
        v.  Apply all unique changes from the list to the `output` grid.
    b.  **Else If** `active_colors` includes Gray (5), Green (3), or Maroon (9):
        i.  Iterate through each row `r` from top to bottom.
        ii. Find all contiguous horizontal segments of Gray, Green, or Maroon pixels in the `input` grid for that row.
        iii. For each segment found, with color `C` starting at column `c_start` and ending at `c_end`:
            1.  Extend the segment rightwards to column 9 if it ends before it: For `c` from `c_end + 1` to 9, change `output[r, c]` to `C`.
            2.  Truncate the segment at column 9 if it extends beyond it: For `c` from 10 to `c_end`, change `output[r, c]` to Orange (7).
            *(Note: Ensure modifications for one segment don't interfere with processing others in the same row if rules overlap - process based on input state or use a temporary grid/row)*. A safer approach might be to determine the target state for the whole row based on all segments and then apply changes.
    c.  **Else If** `active_colors` includes Azure (8):
        i.  Create a list of cells to fill.
        ii. Iterate through each column `c` from left to right.
        iii. Find all row indices `r` where `input[r, c]` is Azure (8).
        iv. If there are two or more Azure pixels in the column:
            1.  Sort the row indices: `r1, r2, ..., rk`.
            2.  Iterate through consecutive pairs `(ri, rj)` from the sorted list.
            3.  Check if all cells `input[r, c]` for `ri < r < rj` are Orange (7).
            4.  If the gap is filled only with Orange, add all coordinates `(r, c)` where `ri < r < rj` to the fill list.
        v.  After checking all columns, iterate through the unique coordinates in the fill list and change the corresponding cell in the `output` grid to Azure (8).
4.  Return the final `output` grid.
```python
import numpy as np
from typing import List, Set, Tuple

"""
Identify the unique non-background colors present in the input grid.
Apply a specific transformation rule based on the exact set of colors found:

Rule 1 (Colors: Red(2), Maroon(9), Blue(1)):
- For each Red pixel, trace diagonally up-left and color any Orange(7) background pixels Red until a non-Orange pixel or grid boundary is hit.
- For each Maroon pixel, trace diagonally up-right and color any Orange(7) background pixels Maroon until a non-Orange pixel or grid boundary is hit.
- For each Blue pixel, trace diagonally down-right and color any Orange(7) background pixels Blue until a non-Orange pixel or grid boundary is hit.

Rule 2 (Colors: Gray(5), Maroon(9), Green(3)):
- For each row, identify contiguous horizontal segments of Gray, Maroon, or Green.
- Extend each segment rightwards to end at column index 9 (inclusive) by changing Orange(7) pixels to the segment's color.
- Truncate each segment that extends beyond column index 9 by changing pixels from column index 10 onwards back to Orange(7).

Rule 3 (Color: Azure(8)):
- For each column, find all Azure pixels.
- If there are two or more Azure pixels in a column, consider pairs of vertically adjacent Azure pixels.
- If the space between a pair of vertically adjacent Azure pixels consists entirely of Orange(7) background pixels, fill that space with Azure(8).

If none of these exact color sets are found, return the input grid unchanged.
The background color is assumed to be Orange(7).
"""

def get_unique_colors(grid: np.ndarray, background_color: int = 7) -> Set[int]:
    """Finds unique colors in the grid, excluding the background color."""
    unique_colors = set(np.unique(grid))
    unique_colors.discard(background_color)
    return unique_colors

def apply_rule_1(input_grid: np.ndarray, output_grid: np.ndarray, height: int, width: int):
    """Applies diagonal extension rule for Red, Maroon, Blue."""
    background_color = 7
    for r in range(height):
        for c in range(width):
            color = input_grid[r, c]
            
            # Red (2): Trace up-left
            if color == 2:
                for i in range(1, max(height, width)):
                    nr, nc = r - i, c - i
                    if not (0 <= nr < height and 0 <= nc < width):
                        break
                    if input_grid[nr, nc] == background_color:
                        output_grid[nr, nc] = 2
                    else:
                        break # Stop tracing if non-background hit
                        
            # Maroon (9): Trace up-right
            elif color == 9:
                 for i in range(1, max(height, width)):
                    nr, nc = r - i, c + i
                    if not (0 <= nr < height and 0 <= nc < width):
                        break
                    if input_grid[nr, nc] == background_color:
                        output_grid[nr, nc] = 9
                    else:
                        break # Stop tracing if non-background hit

            # Blue (1): Trace down-right
            elif color == 1:
                for i in range(1, max(height, width)):
                    nr, nc = r + i, c + i
                    if not (0 <= nr < height and 0 <= nc < width):
                        break
                    if input_grid[nr, nc] == background_color:
                        output_grid[nr, nc] = 1
                    else:
                        break # Stop tracing if non-background hit

def apply_rule_2(input_grid: np.ndarray, output_grid: np.ndarray, height: int, width: int):
    """Applies horizontal adjustment rule for Gray, Maroon, Green to column 9."""
    target_col_index = 9
    background_color = 7
    rule_colors = {5, 9, 3}

    for r in range(height):
        c = 0
        while c < width:
            color = input_grid[r, c]
            if color in rule_colors:
                # Find the end of the segment
                c_start = c
                c_end = c
                while c_end + 1 < width and input_grid[r, c_end + 1] == color:
                    c_end += 1
                
                # Apply extension/truncation logic
                # Extend if segment ends before target column
                if c_end < target_col_index:
                    for fill_c in range(c_end + 1, target_col_index + 1):
                         if fill_c < width: # Check bounds before filling
                             output_grid[r, fill_c] = color
                             
                # Truncate if segment ends after target column
                # Note: We only need to clear *beyond* the target column index
                if c_end > target_col_index:
                    for clear_c in range(target_col_index + 1, c_end + 1):
                         if clear_c < width: # Check bounds before clearing
                            output_grid[r, clear_c] = background_color

                # Move past the processed segment
                c = c_end + 1
            else:
                c += 1


def apply_rule_3(input_grid: np.ndarray, output_grid: np.ndarray, height: int, width: int):
    """Applies vertical gap filling rule for Azure."""
    color_to_fill = 8
    background_color = 7

    for c in range(width):
        azure_rows = [r for r in range(height) if input_grid[r, c] == color_to_fill]
        
        if len(azure_rows) >= 2:
            # Sort rows just in case, though find iteration should preserve order
            azure_rows.sort() 
            
            for i in range(len(azure_rows) - 1):
                r1 = azure_rows[i]
                r2 = azure_rows[i+1]
                
                # Check if there's a gap between them
                if r2 > r1 + 1:
                    # Check if the gap is entirely background color
                    is_background_gap = True
                    for r_gap in range(r1 + 1, r2):
                        if input_grid[r_gap, c] != background_color:
                            is_background_gap = False
                            break
                    
                    # If it's a pure background gap, fill it
                    if is_background_gap:
                        for r_fill in range(r1 + 1, r2):
                            output_grid[r_fill, c] = color_to_fill


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid based on the set of unique non-background colors present.
    """
    # Convert to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input
    output_np = input_np.copy()
    height, width = input_np.shape
    background_color = 7

    # Identify the unique colors present (excluding background)
    unique_colors = get_unique_colors(input_np, background_color)

    # --- Conditional Rule Application ---

    # Rule 1 condition: Exactly Red(2), Maroon(9), Blue(1)
    if unique_colors == {1, 2, 9}:
        apply_rule_1(input_np, output_np, height, width)
        
    # Rule 2 condition: Exactly Gray(5), Maroon(9), Green(3)
    elif unique_colors == {3, 5, 9}:
        apply_rule_2(input_np, output_np, height, width)
        
    # Rule 3 condition: Exactly Azure(8)
    elif unique_colors == {8}:
        apply_rule_3(input_np, output_np, height, width)
        
    # Else: No specific rule matches the color set, output remains a copy of input.

    # Convert back to list of lists for the expected output format
    return output_np.tolist()
```
