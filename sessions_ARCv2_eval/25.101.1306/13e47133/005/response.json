{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by performing a simultaneous competitive flood fill\noriginating from 'seed' pixels.\n\n1.  Identify the boundary color (red, 2) and the background color (most frequent color\n    excluding boundaries).\n2.  Identify all 'seed' pixels (neither background nor boundary).\n3.  Initialize data structures:\n    - `output_grid`: A copy of the input grid.\n    - `distance_grid`: Stores the minimum BFS distance from any seed to each cell\n                      (initialized to infinity).\n    - `origin_seed_grid`: Stores the tuple `(color, row, col)` of the seed that\n                         claimed each cell (initialized with a placeholder).\n    - `queue`: A queue for the multi-source BFS.\n4.  Seed the BFS: For each seed pixel, set its distance to 0 in `distance_grid`,\n    record its info in `origin_seed_grid`, and add its location to the `queue`.\n5.  Run the multi-source BFS:\n    - While the queue is not empty, dequeue a cell `(r, c)`.\n    - For each valid neighbor `(nr, nc)`:\n        - If the neighbor is a background pixel in the input grid:\n            - Calculate the distance from the current cell's originating seed.\n            - Compare this new path (distance and seed priority) with any existing\n              path recorded for the neighbor.\n            - Tie-breaking: If distances are equal, the seed with the lower color index wins.\n              If colors are also equal, the seed with the lower row index wins. If rows\n              are also equal, the seed with the lower column index wins. (This is\n              handled implicitly by tuple comparison).\n            - If the new path is better (shorter distance or wins tie-break):\n                - Update the neighbor's distance, originating seed, and color in the\n                  output grid.\n                - Enqueue the neighbor *only if* the distance was improved (not just\n                  if a tie was broken).\n6.  Return the modified `output_grid`.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque, Counter\nimport heapq # Could potentially use heapq for priority queue if needed, but simple deque works for BFS\n\ndef find_background_color(grid: np.ndarray, boundary_color: int) -> int:\n    \"\"\"Finds the most frequent color in the grid, ignoring the boundary color.\"\"\"\n    counts = Counter(grid.flatten())\n    if boundary_color in counts:\n        del counts[boundary_color] # Don't consider boundary color as background\n    if not counts: # Handle edge case of grid with only boundary color or empty\n        overall_counts = Counter(grid.flatten())\n        if overall_counts:\n            return overall_counts.most_common(1)[0][0]\n        else:\n            return 0 # Default background\n    # Tie-breaking for background color (if needed, though unlikely in ARC):\n    # Could sort by count descending, then color ascending if Counter keeps insertion order or sort items.\n    # For now, most_common(1) is sufficient based on examples.\n    return counts.most_common(1)[0][0]\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the simultaneous competitive flood fill transformation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.copy(input_np) # Initialize output grid\n\n    # --- Define constants and identify colors ---\n    boundary_color = 2\n    background_color = find_background_color(input_np, boundary_color)\n\n    # --- Initialize BFS data structures ---\n    distance_grid = np.full((height, width), np.inf, dtype=float)\n    # Placeholder seed tuple that will lose any tie-break comparison\n    placeholder_seed = (np.inf, np.inf, np.inf)\n    origin_seed_grid = np.full((height, width), placeholder_seed, dtype=object)\n    queue = deque()\n\n    # --- Seed the BFS queue with initial seed pixels ---\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color != background_color and color != boundary_color: # It's a seed\n                seed_info = (color, r, c) # Tie-breaking priority: color, row, col\n                distance_grid[r, c] = 0\n                origin_seed_grid[r, c] = seed_info\n                queue.append((r, c))\n            # Optional: Mark boundaries in distance grid if needed for logic, but checking input_np is sufficient\n            # if color == boundary_color:\n            #     distance_grid[r, c] = -1 # Mark as unwalkable/non-target\n\n    # --- Run the multi-source BFS ---\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance_grid[r, c]\n        origin_seed = origin_seed_grid[r, c] # The (color, r, c) tuple of the seed that claimed cell (r,c)\n\n        # Explore neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is a background pixel (target for filling)\n                if input_np[nr, nc] == background_color:\n                    new_dist = current_dist + 1\n                    existing_dist = distance_grid[nr, nc]\n                    existing_origin_seed = origin_seed_grid[nr, nc]\n\n                    # --- Claiming Logic ---\n                    update_owner = False\n                    enqueue_neighbor = False\n\n                    if new_dist < existing_dist:\n                        # Found a shorter path\n                        update_owner = True\n                        enqueue_neighbor = True # Must explore further from this cell\n                    elif new_dist == existing_dist:\n                        # Equidistant path - apply tie-breaking\n                        # Lower tuple value means higher priority (lower color, then row, then col)\n                        if origin_seed < existing_origin_seed:\n                             update_owner = True\n                             # Do NOT enqueue - distance didn't decrease, avoids cycles/redundancy\n\n                    if update_owner:\n                        distance_grid[nr, nc] = new_dist\n                        origin_seed_grid[nr, nc] = origin_seed\n                        output_grid[nr, nc] = origin_seed[0] # Assign color of the winning seed\n\n                    if enqueue_neighbor:\n                        queue.append((nr, nc))\n\n                # Implicitly handles boundaries and other seeds:\n                # If input_np[nr, nc] is not background_color, the 'if' condition fails.\n\n    # --- Return the result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34846,
    "candidates_token_count": 3731,
    "total_token_count": 38577,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 30.909235,
  "retries": 1
}