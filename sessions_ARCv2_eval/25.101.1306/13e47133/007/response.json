{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nTransforms the input grid by performing a simultaneous competitive flood fill\noriginating from 'seed' pixels. Background pixels are claimed by the 'closest'\nseed based on Breadth-First Search (BFS) distance. Ties in distance are broken\nby seed priority: lowest color index first, then lowest row index, then lowest\ncolumn index.\n\n1.  Identify the boundary color (red, 2) and the background color (most frequent color\n    excluding boundaries).\n2.  Identify all 'seed' pixels (neither background nor boundary).\n3.  Initialize data structures:\n    - `output_grid`: A copy of the input grid.\n    - `distance_grid`: Stores the minimum BFS distance from any seed to each cell\n                      (initialized to infinity).\n    - `origin_seed_grid`: Stores the tuple `(color, row, col)` of the seed that\n                         claimed each cell (initialized to None).\n    - `queue`: A queue for the multi-source BFS.\n4.  Seed the BFS: For each seed pixel, set its distance to 0 in `distance_grid`,\n    record its info in `origin_seed_grid`, and add its location to the `queue`.\n5.  Run the multi-source BFS:\n    - While the queue is not empty, dequeue a cell `(r, c)`.\n    - For each valid neighbor `(nr, nc)`:\n        - If the neighbor is a background pixel in the input grid:\n            - Calculate the distance from the current cell's originating seed.\n            - Compare this new path (distance and seed priority tuple) with any existing\n              path recorded for the neighbor. The seed priority tuple `(color, row, col)`\n              allows direct comparison for tie-breaking.\n            - If the new path is better (shorter distance or wins tie-break):\n                - Update the neighbor's distance, originating seed, and color in the\n                  output grid.\n                - Enqueue the neighbor *only if* the distance was improved (or it's the first time reaching it).\n6.  Return the modified `output_grid`.\n\"\"\"\n\ndef find_background_color(grid: np.ndarray, boundary_color: int) -> int:\n    \"\"\"Finds the most frequent color in the grid, ignoring the boundary color.\"\"\"\n    counts = Counter(grid.flatten())\n    if boundary_color in counts:\n        del counts[boundary_color] # Don't consider boundary color as background\n    if not counts: # Handle edge case of grid with only boundary color or empty\n        overall_counts = Counter(grid.flatten())\n        if overall_counts:\n            return overall_counts.most_common(1)[0][0]\n        else:\n            return 0 # Default background\n    return counts.most_common(1)[0][0]\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the simultaneous competitive flood fill transformation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.copy(input_np) # Initialize output grid\n\n    # --- Define constants and identify colors ---\n    boundary_color = 2\n    background_color = find_background_color(input_np, boundary_color)\n\n    # --- Initialize BFS data structures ---\n    distance_grid = np.full((height, width), np.inf, dtype=float)\n    # Initialize with None using object dtype to store tuples later\n    origin_seed_grid = np.full((height, width), None, dtype=object)\n    queue = deque()\n\n    # --- Seed the BFS queue with initial seed pixels ---\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            # Identify seed pixels (not background and not boundary)\n            if color != background_color and color != boundary_color:\n                seed_info = (color, r, c) # Tie-breaking priority: color, row, col\n                distance_grid[r, c] = 0\n                origin_seed_grid[r, c] = seed_info\n                queue.append((r, c))\n            # Mark boundaries as inaccessible by keeping distance as infinity\n            # (or could explicitly mark if needed, but checking input grid works)\n\n    # --- Run the multi-source BFS ---\n    while queue:\n        r, c = queue.popleft()\n        current_dist = distance_grid[r, c]\n        # origin_seed will be None only if the queue somehow got an invalid initial state\n        # which shouldn't happen with the seeding logic above.\n        origin_seed = origin_seed_grid[r, c]\n\n        # Explore neighbors (4-directional)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if the neighbor is a background pixel (target for filling)\n                if input_np[nr, nc] == background_color:\n                    new_dist = current_dist + 1\n                    existing_dist = distance_grid[nr, nc]\n                    existing_origin_seed = origin_seed_grid[nr, nc]\n\n                    # --- Claiming Logic ---\n                    update_owner = False\n                    enqueue_neighbor = False\n\n                    # Check if this path is better than any existing path to the neighbor\n                    if existing_origin_seed is None: # First time reaching this cell\n                        update_owner = True\n                        enqueue_neighbor = True\n                    elif new_dist < existing_dist: # Found a strictly shorter path\n                        update_owner = True\n                        enqueue_neighbor = True\n                    elif new_dist == existing_dist: # Equidistant path - apply tie-breaking\n                        # Compare seed tuples: (color, r, c) < (other_color, other_r, other_c)\n                        # Lower tuple value means higher priority\n                        if origin_seed < existing_origin_seed:\n                            update_owner = True\n                            # Do NOT enqueue - distance didn't decrease, just updated owner for tie-break\n\n                    # If the current path is better, update the neighbor's info\n                    if update_owner:\n                        distance_grid[nr, nc] = new_dist\n                        origin_seed_grid[nr, nc] = origin_seed\n                        # Update the output grid with the color of the winning seed\n                        output_grid[nr, nc] = origin_seed[0]\n\n                    # Enqueue the neighbor only if we found a new shorter path\n                    # or reached it for the first time.\n                    if enqueue_neighbor:\n                        queue.append((nr, nc))\n\n                # If the neighbor is not a background pixel (it's a boundary, another seed, or already filled),\n                # the BFS wave stops here for this path.\n\n    # --- Return the result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 39909,
    "candidates_token_count": 2201,
    "total_token_count": 42110,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.630109,
  "retries": 1
}