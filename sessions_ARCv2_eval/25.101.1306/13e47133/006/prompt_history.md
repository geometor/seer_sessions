
## train_1

**input:**
```
7 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 8
1 8 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 4 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 3 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 4 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 7 7 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 8 8 8 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 3 3 3 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 7 7 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
```


## train_2

**input:**
```
4 4 4 4 4 4 4 4 4 4 2 8 4 4 4 4 4 4 4 4
4 3 4 4 4 4 4 4 4 4 2 4 1 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 2 5 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 2 8 8 8 8 8 8 8 8 8
4 3 3 3 3 3 3 3 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 4 4 4 4 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 3 3 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 3 4 4 3 4 3 4 2 8 8 8 8 8 8 8 8 8
4 3 4 3 4 4 3 4 3 4 2 2 2 2 2 2 2 2 2 2
4 3 4 3 4 4 3 4 3 4 2 5 5 5 5 5 5 5 5 5
4 3 4 3 4 4 3 4 3 4 2 5 0 0 0 0 0 0 0 5
4 3 4 3 4 4 3 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 4 3 3 3 3 4 3 4 2 5 0 1 5 5 5 1 0 5
4 3 4 4 4 4 4 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 3 3 3 3 3 3 3 4 2 5 0 0 0 0 0 0 0 5
4 4 4 4 4 4 4 4 4 4 2 5 5 5 5 5 5 5 5 5
```

## Perception

1.  **Grid Structure:** The input grid has a primary background color (blue, color 1 in train_1; yellow, color 4 in train_2).
2.  **Boundaries:** Red lines (color 2) act as dividers or barriers within the grid. These lines can be horizontal, vertical, or both, and may not span the entire grid.
3.  **Seed Points:** Several pixels with colors different from the background and the boundary color exist. These act as "seeds".
4.  **Transformation:** The core transformation is a type of "coloring" or "flood fill" of the background pixels. The red boundary lines remain unchanged, and the original seed pixels also retain their color and position in the output.
5.  **Color Propagation:** The background areas, separated by the red boundaries, are filled with colors derived from the seeds. It appears to be a competitive flood fill process where seeds attempt to color the background regions adjacent to them.
6.  **Priority:** When multiple seeds could potentially color the same background region, a priority rule determines the final color. Based on the examples, the seed with the lowest color index takes precedence. If color indices are equal, the seed with the lower row index takes precedence, and if rows are also equal, the lower column index takes precedence.
7.  **Fill Mechanism:** Each prioritized seed initiates a flood fill into adjacent background-colored pixels. The fill stops when it encounters a boundary pixel (red), a pixel already filled by a higher-priority seed (including original seed locations), or the grid edge.

## Facts


```yaml
task_elements:
  - role: grid_property
    type: background_color
    description: The most frequent color in the input grid, which gets replaced in the output.
    value: [blue (1) in train_1, yellow (4) in train_2]
  - role: grid_element
    type: boundary
    color: red (2)
    description: Pixels forming lines that partition the grid and act as barriers for color filling. These pixels remain unchanged.
  - role: grid_element
    type: seed
    description: Pixels with colors other than the background or boundary colors. They initiate the color filling process and retain their original color and position.
    properties: [location, color_index]
  - role: process
    type: competitive_flood_fill
    description: Background areas are filled based on flood fills originating from seed points.
    parameters:
      - seeds: All identified seed pixels.
      - background_color: The identified background color.
      - boundaries: Red (2) pixels and grid edges.
      - priority_rule: Seeds are processed in order of lowest color index, then lowest row index, then lowest column index.
      - fill_behavior: Fill propagates only into background pixels and stops at boundaries or already filled areas (including original seed locations).
  - role: relationship
    type: containment_and_adjacency
    description: Seed points are contained within regions defined by boundaries. Flood fill propagates based on adjacency to background pixels.
  - role: constraint
    type: immutability
    description: Boundary pixels (red) and original seed pixels maintain their color and location in the output grid.
```


## Natural Language Program

1.  Identify the background color (the most common color in the input grid).
2.  Identify the boundary color (red, color 2).
3.  Identify all other pixels as "seeds", noting their color and location.
4.  Create a copy of the input grid to serve as the output grid.
5.  Create a helper grid (`filled_mask`) of the same dimensions, initially all `False`, to track which pixels are considered "filled" (boundaries, seeds, or already colored by the process). Mark the locations of all boundary pixels and all initial seed pixels as `True` in the `filled_mask`.
6.  Create a list of all identified seeds.
7.  Sort the list of seeds based on a priority rule: first by the lowest color index, then by the lowest row index, and finally by the lowest column index as tie-breakers.
8.  Iterate through the sorted seeds one by one, from highest priority (lowest index values) to lowest.
9.  For the current seed (with color `seed_color` at location `seed_loc`):
    a.  Start a Breadth-First Search (BFS) or Flood Fill originating from `seed_loc`. Use a queue and add `seed_loc` to it initially.
    b.  While the BFS queue is not empty:
        i.  Get the current location (`current_loc`) from the front of the queue.
        ii. Examine the 4 direct neighbors (`neighbor_loc`) of `current_loc`.
        iii. For each `neighbor_loc` that is within the grid boundaries:
            *   Check if the pixel at `neighbor_loc` in the input grid has the background color AND if `filled_mask[neighbor_loc]` is `False`.
            *   If both conditions are true, it means this is an unfilled background pixel adjacent to the current fill area:
                *   Set the color of the pixel at `neighbor_loc` in the output grid to `seed_color`.
                *   Mark `filled_mask[neighbor_loc]` as `True`.
                *   Add `neighbor_loc` to the BFS queue to continue the fill from there.
10. After iterating through all seeds, the output grid contains the final transformed state. Return the output grid.
```python
import numpy as np
from collections import deque, Counter

"""
Natural Language Program Description:

1.  Identify the background color (the most common color in the input grid, excluding the boundary color red (2)).
2.  Identify the boundary color (red, color 2).
3.  Identify all other pixels as "seeds", noting their color and location.
4.  Create a copy of the input grid to serve as the output grid.
5.  Create a helper grid (`filled_mask`) of the same dimensions, initially all `False`, to track which pixels are considered "filled" (boundaries, seeds, or already colored by the process). Mark the locations of all boundary pixels (red, 2) and all initial seed pixels as `True` in the `filled_mask`.
6.  Create a list of all identified seeds.
7.  Sort the list of seeds based on a priority rule: first by the lowest color index, then by the lowest row index, and finally by the lowest column index as tie-breakers.
8.  Iterate through the sorted seeds one by one, from highest priority (lowest index values) to lowest.
9.  For the current seed (with color `seed_color` at location `seed_loc`):
    a.  Start a Breadth-First Search (BFS) or Flood Fill originating from `seed_loc`. Use a queue. The queue will store locations to explore *from*.
    b.  While the BFS queue is not empty:
        i.  Get the current location (`current_loc`) from the front of the queue.
        ii. Examine the 4 direct neighbors (`neighbor_loc`) of `current_loc`.
        iii. For each `neighbor_loc` that is within the grid boundaries:
            *   Check if the pixel at `neighbor_loc` in the input grid has the background color AND if `filled_mask[neighbor_loc]` is `False`.
            *   If both conditions are true, it means this is an unfilled background pixel adjacent to the current fill area:
                *   Set the color of the pixel at `neighbor_loc` in the output grid to `seed_color`.
                *   Mark `filled_mask[neighbor_loc]` as `True`.
                *   Add `neighbor_loc` to the BFS queue to continue the fill from there.
10. After iterating through all seeds, the output grid contains the final transformed state. Return the output grid.
"""


def find_background_color(grid: np.ndarray, boundary_color: int) -> int:
    """Finds the most frequent color in the grid, ignoring the boundary color."""
    counts = Counter(grid.flatten())
    if boundary_color in counts:
        del counts[boundary_color] # Don't consider boundary color as background
    if not counts: # Handle edge case of grid with only boundary color
        # Fallback: if no other colors, maybe default to 0 or the most frequent *overall*?
        # Let's pick the most frequent overall if available, else 0.
        overall_counts = Counter(grid.flatten())
        if overall_counts:
            return overall_counts.most_common(1)[0][0]
        else:
            return 0 # Default if grid is empty or truly unusual
    return counts.most_common(1)[0][0]

def bfs_fill(grid: np.ndarray, 
             output_grid: np.ndarray, 
             filled_mask: np.ndarray, 
             start_loc: tuple[int, int], 
             seed_color: int, 
             background_color: int, 
             boundary_color: int):
    """Performs BFS fill starting from neighbors of start_loc."""
    q = deque()
    height, width = grid.shape

    # Initial seeding: Add valid background neighbors of the seed point to the queue
    r_start, c_start = start_loc
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r_start + dr, c_start + dc
        if 0 <= nr < height and 0 <= nc < width:
            neighbor_loc = (nr, nc)
            # Check if neighbor is background and not already filled
            if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                 # Fill it immediately
                output_grid[neighbor_loc] = seed_color
                filled_mask[neighbor_loc] = True
                q.append(neighbor_loc) # Add to queue for further exploration

    # Start BFS from the initial neighbors
    while q:
        r, c = q.popleft()

        # Explore neighbors of the current cell
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_loc = (nr, nc)
                # Check if neighbor is background and not already filled
                if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                    # Fill the neighbor
                    output_grid[neighbor_loc] = seed_color
                    filled_mask[neighbor_loc] = True
                    q.append(neighbor_loc) # Add to queue

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by performing a competitive flood fill.
    Regions defined by a boundary color (red, 2) are filled based on 
    'seed' pixels within them. Filling prioritizes seeds by color index, 
    then row, then column. The fill expands into the background color pixels.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_grid = np.copy(input_np)

    # --- Define constants ---
    boundary_color = 2 

    # --- Identify background color ---
    background_color = find_background_color(input_np, boundary_color)

    # --- Identify seeds and initialize filled_mask ---
    seeds = []
    filled_mask = np.zeros_like(input_np, dtype=bool)
    for r in range(height):
        for c in range(width):
            color = input_np[r, c]
            if color == boundary_color:
                filled_mask[r, c] = True
            elif color != background_color:
                seeds.append((color, r, c)) # Store color, row, col
                filled_mask[r, c] = True # Seed locations are considered filled

    # --- Sort seeds by priority: color, then row, then column ---
    seeds.sort()

    # --- Perform competitive BFS fill for each seed ---
    for seed_color, r_seed, c_seed in seeds:
        seed_loc = (r_seed, c_seed)
        # The BFS function handles filling the adjacent background areas
        bfs_fill(input_np, output_grid, filled_mask, seed_loc, seed_color, background_color, boundary_color)

    # --- Return the result ---
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import deque, Counter

"""
Natural Language Program Description:

1.  Identify the background color (the most common color in the input grid, excluding the boundary color red (2)).
2.  Identify the boundary color (red, color 2).
3.  Identify all other pixels as "seeds", noting their color and location.
4.  Create a copy of the input grid to serve as the output grid.
5.  Create a helper grid (`filled_mask`) of the same dimensions, initially all `False`, to track which pixels are considered "filled" (boundaries, seeds, or already colored by the process). Mark the locations of all boundary pixels (red, 2) and all initial seed pixels as `True` in the `filled_mask`.
6.  Create a list of all identified seeds.
7.  Sort the list of seeds based on a priority rule: first by the lowest color index, then by the lowest row index, and finally by the lowest column index as tie-breakers.
8.  Iterate through the sorted seeds one by one, from highest priority (lowest index values) to lowest.
9.  For the current seed (with color `seed_color` at location `seed_loc`):
    a.  Start a Breadth-First Search (BFS) or Flood Fill originating from `seed_loc`. Use a queue. The queue will store locations to explore *from*.
    b.  While the BFS queue is not empty:
        i.  Get the current location (`current_loc`) from the front of the queue.
        ii. Examine the 4 direct neighbors (`neighbor_loc`) of `current_loc`.
        iii. For each `neighbor_loc` that is within the grid boundaries:
            *   Check if the pixel at `neighbor_loc` in the input grid has the background color AND if `filled_mask[neighbor_loc]` is `False`.
            *   If both conditions are true, it means this is an unfilled background pixel adjacent to the current fill area:
                *   Set the color of the pixel at `neighbor_loc` in the output grid to `seed_color`.
                *   Mark `filled_mask[neighbor_loc]` as `True`.
                *   Add `neighbor_loc` to the BFS queue to continue the fill from there.
10. After iterating through all seeds, the output grid contains the final transformed state. Return the output grid.
"""


def find_background_color(grid: np.ndarray, boundary_color: int) -> int:
    """Finds the most frequent color in the grid, ignoring the boundary color."""
    counts = Counter(grid.flatten())
    if boundary_color in counts:
        del counts[boundary_color] # Don't consider boundary color as background
    if not counts: # Handle edge case of grid with only boundary color
        # Fallback: if no other colors, maybe default to 0 or the most frequent *overall*?
        # Let's pick the most frequent overall if available, else 0.
        overall_counts = Counter(grid.flatten())
        if overall_counts:
            return overall_counts.most_common(1)[0][0]
        else:
            return 0 # Default if grid is empty or truly unusual
    return counts.most_common(1)[0][0]

def bfs_fill(grid: np.ndarray, 
             output_grid: np.ndarray, 
             filled_mask: np.ndarray, 
             start_loc: tuple[int, int], 
             seed_color: int, 
             background_color: int, 
             boundary_color: int):
    """Performs BFS fill starting from neighbors of start_loc."""
    q = deque()
    height, width = grid.shape

    # Initial seeding: Add valid background neighbors of the seed point to the queue
    r_start, c_start = start_loc
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r_start + dr, c_start + dc
        if 0 <= nr < height and 0 <= nc < width:
            neighbor_loc = (nr, nc)
            # Check if neighbor is background and not already filled
            if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                 # Fill it immediately
                output_grid[neighbor_loc] = seed_color
                filled_mask[neighbor_loc] = True
                q.append(neighbor_loc) # Add to queue for further exploration

    # Start BFS from the initial neighbors
    while q:
        r, c = q.popleft()

        # Explore neighbors of the current cell
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_loc = (nr, nc)
                # Check if neighbor is background and not already filled
                if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                    # Fill the neighbor
                    output_grid[neighbor_loc] = seed_color
                    filled_mask[neighbor_loc] = True
                    q.append(neighbor_loc) # Add to queue

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by performing a competitive flood fill.
    Regions defined by a boundary color (red, 2) are filled based on 
    'seed' pixels within them. Filling prioritizes seeds by color index, 
    then row, then column. The fill expands into the background color pixels.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_grid = np.copy(input_np)

    # --- Define constants ---
    boundary_color = 2 

    # --- Identify background color ---
    background_color = find_background_color(input_np, boundary_color)

    # --- Identify seeds and initialize filled_mask ---
    seeds = []
    filled_mask = np.zeros_like(input_np, dtype=bool)
    for r in range(height):
        for c in range(width):
            color = input_np[r, c]
            if color == boundary_color:
                filled_mask[r, c] = True
            elif color != background_color:
                seeds.append((color, r, c)) # Store color, row, col
                filled_mask[r, c] = True # Seed locations are considered filled

    # --- Sort seeds by priority: color, then row, then column ---
    seeds.sort()

    # --- Perform competitive BFS fill for each seed ---
    for seed_color, r_seed, c_seed in seeds:
        seed_loc = (r_seed, c_seed)
        # The BFS function handles filling the adjacent background areas
        bfs_fill(input_np, output_grid, filled_mask, seed_loc, seed_color, background_color, boundary_color)

    # --- Return the result ---
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
7 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 8
1 8 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 4 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 3 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 4 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 7 7 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 8 8 8 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 3 3 3 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 7 7 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 8
7 8 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 2 2 2 2 2 2 2 2 4 4 4
7 7 7 7 7 7 7 7 2 3 3 3 3 3 3 3 2 4 4 4
7 7 7 7 7 7 7 7 2 3 3 3 3 3 4 3 2 4 4 4
7 7 7 7 7 7 7 7 2 3 3 3 3 3 3 3 2 4 4 4
7 7 7 7 7 7 7 7 2 3 3 3 3 3 3 3 2 4 4 4
7 7 7 7 7 7 7 7 2 3 3 3 3 3 3 3 2 4 4 4
7 7 7 7 7 7 7 7 2 2 2 2 2 2 2 2 2 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
7 7 7 7 7 7 7 7 2 4 4 4 4 4 4 4 4 4 4 4
```
Match: False
Pixels Off: 178
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 88.99999999999999

## Example 2:
Input:
```
4 4 4 4 4 4 4 4 4 4 2 8 4 4 4 4 4 4 4 4
4 3 4 4 4 4 4 4 4 4 2 4 1 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 2 5 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
```
Expected Output:
```
4 4 4 4 4 4 4 4 4 4 2 8 8 8 8 8 8 8 8 8
4 3 3 3 3 3 3 3 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 4 4 4 4 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 3 3 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 3 4 4 3 4 3 4 2 8 8 8 8 8 8 8 8 8
4 3 4 3 4 4 3 4 3 4 2 2 2 2 2 2 2 2 2 2
4 3 4 3 4 4 3 4 3 4 2 5 5 5 5 5 5 5 5 5
4 3 4 3 4 4 3 4 3 4 2 5 0 0 0 0 0 0 0 5
4 3 4 3 4 4 3 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 4 3 3 3 3 4 3 4 2 5 0 1 5 5 5 1 0 5
4 3 4 4 4 4 4 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 3 3 3 3 3 3 3 4 2 5 0 0 0 0 0 0 0 5
4 4 4 4 4 4 4 4 4 4 2 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 2 8 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 1 1 1 1 1 1 1 1 1
3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2
3 3 3 3 3 3 3 3 3 3 2 5 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 1 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0 0 0 0 0
3 3 3 3 3 3 3 3 3 3 2 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 224
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 112.0
## General Assessment

The initial analysis identified the core mechanism as a competitive flood fill originating from "seed" pixels, constrained by "boundary" pixels. The initial code implemented this using a Breadth-First Search (BFS) for each seed, processed in order of priority. The priority was assumed to be lowest color index first, then lowest row, then lowest column.

However, the results show this priority logic leads to incorrect outputs. In both examples, lower color index seeds incorrectly dominate regions that, in the expected output, are filled by higher color index seeds. For instance, in Example 1, seed 7 (orange) fills the entire left region in the code's output, while the expected output shows a mix of seed 7 and seed 8 (azure). Similarly, seed 4 (yellow) dominates the right side in the code's output, whereas seed 8 has a larger presence in the expected output.

This pattern strongly suggests the priority order is incorrect. Reversing the primary sort key – prioritizing the **highest** color index first – appears to align with the expected outputs. Seeds with higher color values should perform their fill first, followed by seeds with progressively lower values. The tie-breaking rules (lowest row index, then lowest column index) likely remain the same for seeds with identical colors.

The strategy is to:
1.  Confirm the background color identification and seed identification are correct.
2.  Verify boundary pixels (red, 2) remain unchanged.
3.  Implement the competitive flood fill using BFS, but **reverse the priority sort order** for the seeds (highest color index first).
4.  Gather metrics to confirm assumptions about unchanged pixels and color distributions.

## Metrics Gathering


*code_execution:*
```python
import numpy as np
from collections import Counter

def analyze_example(input_grid_list, expected_output_list, actual_output_list):
    input_grid = np.array(input_grid_list)
    expected_output = np.array(expected_output_list)
    actual_output = np.array(actual_output_list)

    metrics = {}
    metrics['dimensions'] = {
        'input': input_grid.shape,
        'expected': expected_output.shape,
        'actual': actual_output.shape
    }
    metrics['all_dims_match'] = (input_grid.shape == expected_output.shape == actual_output.shape)

    metrics['unique_colors'] = {
        'input': sorted(list(np.unique(input_grid))),
        'expected': sorted(list(np.unique(expected_output))),
        'actual': sorted(list(np.unique(actual_output)))
    }

    boundary_color = 2
    metrics['boundary_pixels'] = {
        'input_count': np.sum(input_grid == boundary_color),
        'expected_count': np.sum(expected_output == boundary_color),
        'actual_count': np.sum(actual_output == boundary_color),
        'preserved_in_expected': np.sum(expected_output[input_grid == boundary_color] == boundary_color),
        'preserved_in_actual': np.sum(actual_output[input_grid == boundary_color] == boundary_color)
    }
    metrics['boundary_match_expected'] = metrics['boundary_pixels']['input_count'] == metrics['boundary_pixels']['expected_count'] == metrics['boundary_pixels']['preserved_in_expected']
    metrics['boundary_match_actual'] = metrics['boundary_pixels']['input_count'] == metrics['boundary_pixels']['actual_count'] == metrics['boundary_pixels']['preserved_in_actual']


    # Background color determination (most frequent excluding boundary)
    input_counts = Counter(input_grid.flatten())
    if boundary_color in input_counts: del input_counts[boundary_color]
    background_color = input_counts.most_common(1)[0][0] if input_counts else -1 # -1 if no non-boundary pixels

    # Seed pixels (not background, not boundary)
    seed_mask_input = (input_grid != background_color) & (input_grid != boundary_color)
    seed_locations_input = np.argwhere(seed_mask_input)
    seeds_input = [(input_grid[r, c], r, c) for r, c in seed_locations_input]

    seed_mask_expected = (expected_output != background_color) & (expected_output != boundary_color)
    seed_locations_expected = np.argwhere(seed_mask_expected)
    
    seed_mask_actual = (actual_output != background_color) & (actual_output != boundary_color)
    seed_locations_actual = np.argwhere(seed_mask_actual)


    metrics['background_color'] = background_color
    metrics['seeds'] = {
        'input_count': len(seeds_input),
        'input_details': sorted(seeds_input), # Sorted by default tuple order (color, r, c)
        'original_seeds_preserved_in_expected': True,
        'original_seeds_preserved_in_actual': True,
    }
    
    # Verify original seeds are preserved
    for color, r, c in seeds_input:
        if expected_output[r, c] != color:
             metrics['seeds']['original_seeds_preserved_in_expected'] = False
        if actual_output[r, c] != color:
             metrics['seeds']['original_seeds_preserved_in_actual'] = False

    # Count differences
    metrics['diff_actual_vs_expected'] = {
        'pixel_count': np.sum(actual_output != expected_output),
        'percentage': np.mean(actual_output != expected_output) * 100
    }

    return metrics

# Example 1 Data (as provided in the prompt)
input_1 = [[7, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8], [1, 8, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 4, 1, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]
expected_1 = [[7, 7, 7, 7, 7, 7, 7, 7, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [7, 8, 8, 8, 8, 8, 8, 7, 2, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8], [7, 8, 7, 7, 7, 7, 8, 7, 2, 8, 4, 8, 8, 8, 8, 8, 8, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 4, 8, 4, 4, 4, 4, 4, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 4, 8, 4, 8, 8, 8, 4, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 4, 8, 4, 4, 4, 4, 4, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 4, 8, 8, 8, 8, 8, 8, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 3, 4, 4, 4, 4, 4, 3, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 3, 4, 3, 3, 3, 4, 3, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 3, 4, 4, 4, 4, 4, 3, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 4, 8], [7, 8, 7, 8, 8, 7, 8, 7, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8], [7, 8, 7, 7, 7, 7, 8, 7, 2, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8], [7, 8, 8, 8, 8, 8, 8, 7, 2, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8], [7, 7, 7, 7, 7, 7, 7, 7, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]
actual_1 = [[7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8], [7, 8, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 3, 3, 3, 3, 3, 4, 3, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 3, 3, 3, 3, 3, 3, 3, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]

# Example 2 Data
input_2 = [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 8, 4, 4, 4, 4, 4, 4, 4, 4], [4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 1, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 5, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 0, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 1, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4]]
expected_2 = [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 8, 1, 1, 1, 1, 1, 1, 1, 8], [4, 3, 4, 4, 4, 4, 4, 4, 3, 4, 2, 8, 1, 8, 8, 8, 8, 8, 1, 8], [4, 3, 4, 3, 3, 3, 3, 4, 3, 4, 2, 8, 1, 8, 1, 1, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 1, 8, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 1, 8, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 1, 8, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 1, 8, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 1, 1, 1, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 8, 8, 8, 8, 8, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 1, 1, 1, 1, 1, 1, 1, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 5, 0, 0, 0, 0, 0, 0, 0, 5], [4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 2, 5, 0, 1, 1, 1, 1, 1, 0, 5], [4, 3, 4, 3, 3, 3, 3, 4, 3, 4, 2, 5, 0, 1, 5, 5, 5, 1, 0, 5], [4, 3, 4, 4, 4, 4, 4, 4, 3, 4, 2, 5, 0, 1, 1, 1, 1, 1, 0, 5], [4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 5, 0, 0, 0, 0, 0, 0, 0, 5], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5]]
actual_2 = [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 8, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

metrics_1 = analyze_example(input_1, expected_1, actual_1)
metrics_2 = analyze_example(input_2, expected_2, actual_2)

print("--- Example 1 Metrics ---")
print(metrics_1)
print("\n--- Example 2 Metrics ---")
print(metrics_2)
```

*code_execution_result:*
outcome: OUTCOME_OK
```
--- Example 1 Metrics ---
{'dimensions': {'input': (20, 20), 'expected': (20, 20), 'actual': (20, 20)}, 'all_dims_match': True, 'unique_colors': {'input': [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(7), np.int64(8)], 'expected': [np.int64(2), np.int64(3), np.int64(4), np.int64(7), np.int64(8)], 'actual': [np.int64(2), np.int64(3), np.int64(4), np.int64(7), np.int64(8)]}, 'boundary_pixels': {'input_count': np.int64(41), 'expected_count': np.int64(41), 'actual_count': np.int64(41), 'preserved_in_expected': np.int64(41), 'preserved_in_actual': np.int64(41)}, 'boundary_match_expected': np.True_, 'boundary_match_actual': np.True_, 'background_color': np.int64(1), 'seeds': {'input_count': 6, 'input_details': [(np.int64(3), np.int64(10), np.int64(15)), (np.int64(4), np.int64(1), np.int64(18)), (np.int64(4), np.int64(11), np.int64(14)), (np.int64(7), np.int64(0), np.int64(0)), (np.int64(8), np.int64(0), np.int64(19)), (np.int64(8), np.int64(1), np.int64(1))], 'original_seeds_preserved_in_expected': True, 'original_seeds_preserved_in_actual': True}, 'diff_actual_vs_expected': {'pixel_count': np.int64(178), 'percentage': np.float64(44.5)}}

--- Example 2 Metrics ---
{'dimensions': {'input': (20, 20), 'expected': (20, 20), 'actual': (20, 20)}, 'all_dims_match': True, 'unique_colors': {'input': [np.int64(0), np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(8)], 'expected': [np.int64(0), np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5), np.int64(8)], 'actual': [np.int64(0), np.int64(1), np.int64(2), np.int64(3), np.int64(5), np.int64(8)]}, 'boundary_pixels': {'input_count': np.int64(29), 'expected_count': np.int64(29), 'actual_count': np.int64(29), 'preserved_in_expected': np.int64(29), 'preserved_in_actual': np.int64(29)}, 'boundary_match_expected': np.True_, 'boundary_match_actual': np.True_, 'background_color': np.int64(4), 'seeds': {'input_count': 6, 'input_details': [(np.int64(0), np.int64(14), np.int64(12)), (np.int64(1), np.int64(1), np.int64(12)), (np.int64(1), np.int64(15), np.int64(13)), (np.int64(3), np.int64(1), np.int64(1)), (np.int64(5), np.int64(13), np.int64(11)), (np.int64(8), np.int64(0), np.int64(11))], 'original_seeds_preserved_in_expected': True, 'original_seeds_preserved_in_actual': True}, 'diff_actual_vs_expected': {'pixel_count': np.int64(224), 'percentage': np.float64(56.00000000000001)}}

```
**Metrics Analysis:**

*   **Dimensions & Boundaries:** Input, expected output, and actual output dimensions match for both examples. The boundary pixels (red, 2) are correctly identified and preserved in both the expected and actual outputs.
*   **Background Color:** The background color (1 for Ex1, 4 for Ex2) is correctly identified.
*   **Seeds:** The correct number of seeds are identified in the input. Crucially, the original locations of these seeds retain their original color in both the expected output and the actual output generated by the code. This confirms that the `filled_mask` correctly prevents seeds from being overwritten, and the `output_grid` is initialized correctly.
*   **Colors:** The unique colors present in the actual output match the expected output for Ex1. In Ex2, the actual output is missing color 4 (yellow, the background) which is present in the expected output (only in cells (0,0) to (0,9) and (19,0) to (19,9), and a few isolated spots) - this suggests the fill expanded too far in the actual output.
*   **Difference:** The high pixel difference percentages (44.5% for Ex1, 56% for Ex2) confirm the significant deviation caused by the incorrect fill logic.

The metrics confirm that the basic object identification (background, boundary, seeds) and preservation rules (boundaries, seed locations) are handled correctly by the previous code. The error lies specifically in the competitive filling process, strongly supporting the hypothesis that the seed priority order needs to be reversed.

## Facts


```yaml
task_elements:
  - role: grid_property
    type: background_color
    description: The most frequent color in the input grid, excluding the boundary color (red, 2). This color is replaced by seed colors in the output.
    value: [blue (1) in train_1, yellow (4) in train_2]
  - role: grid_element
    type: boundary
    color: red (2)
    description: Pixels forming lines that partition the grid and act as barriers for color filling. These pixels remain unchanged in the output.
  - role: grid_element
    type: seed
    description: Pixels with colors other than the background or boundary colors. They initiate the color filling process and retain their original color and location in the output.
    properties: [location (row, col), color_index]
  - role: process
    type: competitive_flood_fill
    description: Background areas are filled based on flood fills originating from seed points, respecting boundaries.
    parameters:
      - seeds: All identified seed pixels.
      - background_color: The identified background color.
      - boundaries: Red (2) pixels and grid edges act as barriers.
      - priority_rule: Seeds are processed in order of **highest** color index first, then lowest row index, then lowest column index for tie-breaking.
      - fill_behavior: Fill propagates via 4-way adjacency only into background pixels. Fill stops at boundaries or pixels already filled by a higher-priority seed (including original seed locations).
  - role: relationship
    type: containment_and_adjacency
    description: Seed points are contained within regions defined by boundaries. Flood fill propagates based on 4-way adjacency into background pixels.
  - role: constraint
    type: immutability
    description: Boundary pixels (red) and original seed pixels maintain their color and location in the output grid.
  - role: constraint
    type: fill_priority
    description: Fill from higher priority seeds prevents fill from lower priority seeds into the same background pixel.
```


## Natural Language Program

1.  Identify the boundary color (red, color 2).
2.  Identify the background color by finding the most frequent color in the input grid, excluding the boundary color.
3.  Identify all pixels that are neither the background color nor the boundary color as "seeds". Record each seed's color, row index, and column index.
4.  Create a copy of the input grid to serve as the output grid.
5.  Create a boolean helper grid (`filled_mask`) of the same dimensions as the input, initialized to `False`.
6.  Mark the locations of all boundary pixels (red, 2) as `True` in the `filled_mask`.
7.  Mark the locations of all identified initial seed pixels as `True` in the `filled_mask`.
8.  Create a list of all identified seeds.
9.  Sort the list of seeds based on a priority rule:
    a.  Primary key: **Highest** color index first (descending order).
    b.  Secondary key: Lowest row index first (ascending order).
    c.  Tertiary key: Lowest column index first (ascending order).
10. Iterate through the sorted seeds one by one (from highest priority to lowest).
11. For the current seed (with color `seed_color` at location `seed_loc`):
    a.  Initialize a queue for Breadth-First Search (BFS) for this seed.
    b.  Check the 4 direct neighbors (up, down, left, right) of the `seed_loc`.
    c.  For each neighbor that is within the grid boundaries:
        i.  Check if the neighbor pixel in the *input* grid has the `background_color`.
        ii. Check if the neighbor location in the `filled_mask` is `False`.
        iii. If both conditions are true (it's a background pixel not yet filled), then:
            *   Set the color of the pixel at the neighbor location in the `output_grid` to `seed_color`.
            *   Mark the neighbor location in the `filled_mask` as `True`.
            *   Add the neighbor location to the BFS queue.
    d.  While the BFS queue is not empty:
        i.  Dequeue a location (`current_loc`).
        ii. Examine the 4 direct neighbors (`neighbor_loc`) of `current_loc`.
        iii. For each `neighbor_loc` that is within the grid boundaries:
            *   Check if the pixel at `neighbor_loc` in the *input* grid has the `background_color`.
            *   Check if `filled_mask[neighbor_loc]` is `False`.
            *   If both conditions are true:
                *   Set the color of the pixel at `neighbor_loc` in the `output_grid` to `seed_color`.
                *   Mark `filled_mask[neighbor_loc]` as `True`.
                *   Add `neighbor_loc` to the BFS queue.
12. After iterating through all seeds and completing their respective BFS fills, return the `output_grid`.
```python
import numpy as np
from collections import deque, Counter

"""
Transforms the input grid by performing a competitive flood fill based on seed pixels.

1.  Identify the boundary color (red, color 2).
2.  Identify the background color (most frequent color excluding boundary).
3.  Identify 'seed' pixels (neither background nor boundary).
4.  Create an output grid, initially a copy of the input.
5.  Create a mask to track filled pixels (boundaries, seeds, and filled areas).
6.  Sort seeds by priority: highest color index first, then lowest row, then lowest column.
7.  Iterate through sorted seeds:
    - Perform a Breadth-First Search (BFS) starting from the neighbors of the current seed.
    - The BFS fills adjacent background pixels with the seed's color.
    - The fill stops at boundaries, already filled pixels (by higher priority seeds or original elements), or grid edges.
    - Update the output grid and the filled mask during the BFS.
8.  Return the final output grid.
"""

def find_background_color(grid: np.ndarray, boundary_color: int) -> int:
    """Finds the most frequent color in the grid, ignoring the boundary color."""
    counts = Counter(grid.flatten())
    if boundary_color in counts:
        del counts[boundary_color] # Don't consider boundary color as background
    if not counts: # Handle edge case of grid with only boundary color or empty
        overall_counts = Counter(grid.flatten())
        if overall_counts:
            return overall_counts.most_common(1)[0][0]
        else:
            return 0 # Default background
    return counts.most_common(1)[0][0]

def bfs_fill(input_grid: np.ndarray,
             output_grid: np.ndarray,
             filled_mask: np.ndarray,
             start_loc: tuple[int, int],
             seed_color: int,
             background_color: int):
    """
    Performs BFS fill originating from valid background neighbors of start_loc.
    Updates output_grid and filled_mask in place.
    """
    q = deque()
    height, width = input_grid.shape
    r_start, c_start = start_loc

    # --- Initial Step: Seed the queue with valid neighbors ---
    # Check the 4 direct neighbors of the actual seed location
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r_start + dr, c_start + dc

        # Check bounds
        if 0 <= nr < height and 0 <= nc < width:
            neighbor_loc = (nr, nc)
            # Check if neighbor is background AND not already filled/blocked
            if input_grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                # Fill this neighbor immediately
                output_grid[neighbor_loc] = seed_color
                filled_mask[neighbor_loc] = True
                q.append(neighbor_loc) # Add to queue for further expansion

    # --- BFS Expansion ---
    while q:
        r, c = q.popleft()

        # Explore neighbors of the current cell (r, c) from the queue
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_loc = (nr, nc)
                # Check if neighbor is background AND not already filled/blocked
                if input_grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                    # Fill the neighbor
                    output_grid[neighbor_loc] = seed_color
                    filled_mask[neighbor_loc] = True
                    q.append(neighbor_loc) # Add to queue

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the competitive flood fill transformation.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_grid = np.copy(input_np) # Initialize output grid

    # --- Define constants ---
    boundary_color = 2

    # --- Identify background color ---
    background_color = find_background_color(input_np, boundary_color)

    # --- Identify seeds and initialize filled_mask ---
    seeds = []
    filled_mask = np.zeros_like(input_np, dtype=bool)
    for r in range(height):
        for c in range(width):
            color = input_np[r, c]
            if color == boundary_color:
                filled_mask[r, c] = True # Mark boundaries as filled
            elif color != background_color:
                # This is a seed pixel
                seeds.append({'color': color, 'row': r, 'col': c})
                filled_mask[r, c] = True # Mark seed locations as filled

    # --- Sort seeds by priority: highest color, lowest row, lowest col ---
    # Sort key uses negative color for descending order
    seeds.sort(key=lambda s: (-s['color'], s['row'], s['col']))

    # --- Perform competitive BFS fill for each seed in priority order ---
    for seed in seeds:
        seed_loc = (seed['row'], seed['col'])
        seed_color = seed['color']
        # The BFS function handles filling adjacent background areas
        # It modifies output_grid and filled_mask directly
        bfs_fill(input_np, output_grid, filled_mask, seed_loc, seed_color, background_color)

    # --- Return the result ---
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import deque, Counter

"""
Transforms the input grid by performing a competitive flood fill based on seed pixels.

1.  Identify the boundary color (red, color 2).
2.  Identify the background color (most frequent color excluding boundary).
3.  Identify 'seed' pixels (neither background nor boundary).
4.  Create an output grid, initially a copy of the input.
5.  Create a mask to track filled pixels (boundaries, seeds, and filled areas).
6.  Sort seeds by priority: highest color index first, then lowest row, then lowest column.
7.  Iterate through sorted seeds:
    - Perform a Breadth-First Search (BFS) starting from the neighbors of the current seed.
    - The BFS fills adjacent background pixels with the seed's color.
    - The fill stops at boundaries, already filled pixels (by higher priority seeds or original elements), or grid edges.
    - Update the output grid and the filled mask during the BFS.
8.  Return the final output grid.
"""

def find_background_color(grid: np.ndarray, boundary_color: int) -> int:
    """Finds the most frequent color in the grid, ignoring the boundary color."""
    counts = Counter(grid.flatten())
    if boundary_color in counts:
        del counts[boundary_color] # Don't consider boundary color as background
    if not counts: # Handle edge case of grid with only boundary color or empty
        overall_counts = Counter(grid.flatten())
        if overall_counts:
            return overall_counts.most_common(1)[0][0]
        else:
            return 0 # Default background
    return counts.most_common(1)[0][0]

def bfs_fill(input_grid: np.ndarray,
             output_grid: np.ndarray,
             filled_mask: np.ndarray,
             start_loc: tuple[int, int],
             seed_color: int,
             background_color: int):
    """
    Performs BFS fill originating from valid background neighbors of start_loc.
    Updates output_grid and filled_mask in place.
    """
    q = deque()
    height, width = input_grid.shape
    r_start, c_start = start_loc

    # --- Initial Step: Seed the queue with valid neighbors ---
    # Check the 4 direct neighbors of the actual seed location
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r_start + dr, c_start + dc

        # Check bounds
        if 0 <= nr < height and 0 <= nc < width:
            neighbor_loc = (nr, nc)
            # Check if neighbor is background AND not already filled/blocked
            if input_grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                # Fill this neighbor immediately
                output_grid[neighbor_loc] = seed_color
                filled_mask[neighbor_loc] = True
                q.append(neighbor_loc) # Add to queue for further expansion

    # --- BFS Expansion ---
    while q:
        r, c = q.popleft()

        # Explore neighbors of the current cell (r, c) from the queue
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_loc = (nr, nc)
                # Check if neighbor is background AND not already filled/blocked
                if input_grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:
                    # Fill the neighbor
                    output_grid[neighbor_loc] = seed_color
                    filled_mask[neighbor_loc] = True
                    q.append(neighbor_loc) # Add to queue

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the competitive flood fill transformation.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_grid = np.copy(input_np) # Initialize output grid

    # --- Define constants ---
    boundary_color = 2

    # --- Identify background color ---
    background_color = find_background_color(input_np, boundary_color)

    # --- Identify seeds and initialize filled_mask ---
    seeds = []
    filled_mask = np.zeros_like(input_np, dtype=bool)
    for r in range(height):
        for c in range(width):
            color = input_np[r, c]
            if color == boundary_color:
                filled_mask[r, c] = True # Mark boundaries as filled
            elif color != background_color:
                # This is a seed pixel
                seeds.append({'color': color, 'row': r, 'col': c})
                filled_mask[r, c] = True # Mark seed locations as filled

    # --- Sort seeds by priority: highest color, lowest row, lowest col ---
    # Sort key uses negative color for descending order
    seeds.sort(key=lambda s: (-s['color'], s['row'], s['col']))

    # --- Perform competitive BFS fill for each seed in priority order ---
    for seed in seeds:
        seed_loc = (seed['row'], seed['col'])
        seed_color = seed['color']
        # The BFS function handles filling adjacent background areas
        # It modifies output_grid and filled_mask directly
        bfs_fill(input_np, output_grid, filled_mask, seed_loc, seed_color, background_color)

    # --- Return the result ---
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
7 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 8
1 8 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 4 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 3 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 4 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1
1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 7 7 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 8 8 8 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 4 4 4 4 4 8 4 8
7 8 7 8 8 7 8 7 2 8 4 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 3 3 3 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 4 4 4 4 4 3 2 8 4 8
7 8 7 8 8 7 8 7 2 3 3 3 3 3 3 3 2 8 4 8
7 8 7 8 8 7 8 7 2 2 2 2 2 2 2 2 2 8 4 8
7 8 7 8 8 7 8 7 2 8 8 8 8 8 8 8 8 8 4 8
7 8 7 7 7 7 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 8 8 8 8 8 8 7 2 8 4 4 4 4 4 4 4 4 4 8
7 7 7 7 7 7 7 7 2 8 8 8 8 8 8 8 8 8 8 8
```
Transformed Output:
```
7 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 4 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 4 4 4 4 4 4 3 2 8 8 8
8 8 8 8 8 8 8 8 2 4 4 4 4 4 4 4 2 8 8 8
8 8 8 8 8 8 8 8 2 4 4 4 4 4 4 4 2 8 8 8
8 8 8 8 8 8 8 8 2 4 4 4 4 4 4 4 2 8 8 8
8 8 8 8 8 8 8 8 2 4 4 4 4 4 4 4 2 8 8 8
8 8 8 8 8 8 8 8 2 2 2 2 2 2 2 2 2 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 2 8 8 8 8 8 8 8 8 8 8 8
```
Match: False
Pixels Off: 175
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 87.5

## Example 2:
Input:
```
4 4 4 4 4 4 4 4 4 4 2 8 4 4 4 4 4 4 4 4
4 3 4 4 4 4 4 4 4 4 2 4 1 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 2 2 2 2 2 2 2 2 2
4 4 4 4 4 4 4 4 4 4 2 5 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 1 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 2 4 4 4 4 4 4 4 4 4
```
Expected Output:
```
4 4 4 4 4 4 4 4 4 4 2 8 8 8 8 8 8 8 8 8
4 3 3 3 3 3 3 3 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 4 4 4 4 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 3 3 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 8 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 1 1 1 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 8 8 8 8 8 1 8
4 3 4 3 4 4 3 4 3 4 2 8 1 1 1 1 1 1 1 8
4 3 4 3 4 4 3 4 3 4 2 8 8 8 8 8 8 8 8 8
4 3 4 3 4 4 3 4 3 4 2 2 2 2 2 2 2 2 2 2
4 3 4 3 4 4 3 4 3 4 2 5 5 5 5 5 5 5 5 5
4 3 4 3 4 4 3 4 3 4 2 5 0 0 0 0 0 0 0 5
4 3 4 3 4 4 3 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 4 3 3 3 3 4 3 4 2 5 0 1 5 5 5 1 0 5
4 3 4 4 4 4 4 4 3 4 2 5 0 1 1 1 1 1 0 5
4 3 3 3 3 3 3 3 3 4 2 5 0 0 0 0 0 0 0 5
4 4 4 4 4 4 4 4 4 4 2 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 1 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 8 8 8 8 8 8 8 8 8
3 3 3 3 3 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2
3 3 3 3 3 3 3 3 3 3 2 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 0 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 5 1 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 5 5 5 5 5 5 5 5
3 3 3 3 3 3 3 3 3 3 2 5 5 5 5 5 5 5 5 5
```
Match: False
Pixels Off: 193
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 96.50000000000001
## General Assessment

The previous attempts assumed a sequential flood fill based on seed priority (either lowest or highest color index first). Both approaches failed to produce the correct output, indicating the core filling mechanism or the priority rule was misunderstood. The significant pixel differences in the results confirm this.

The errors suggest a different kind of "competition" between seeds. Instead of one seed filling its entire potential area before the next starts, the filling might happen more concurrently. A plausible model is a **simultaneous multi-source Breadth-First Search (BFS)**. In this model:

1.  All seeds start expanding simultaneously.
2.  A background pixel is colored by the "closest" seed. Distance is measured in steps (Manhattan distance in BFS).
3.  If a background pixel is equidistant from multiple seeds, a tie-breaking rule is needed. Based on the previous attempts and common ARC patterns, the likely tie-breaker is: lowest color index, then lowest row index, then lowest column index of the *originating seed*.

This approach aligns better with the concept of regions expanding until they meet boundaries or regions from other seeds.

**Strategy:**

1.  Implement a multi-source BFS. This requires managing a single queue containing cells to visit, along with information about which seed originated the expansion towards that cell and the distance.
2.  Maintain auxiliary grids to store the minimum distance found so far to reach each cell and the seed that achieved that minimum distance.
3.  When visiting a cell, compare the current path's distance and seed priority with any previously recorded path to that cell to handle ties correctly.
4.  Gather metrics to ensure basic assumptions (boundaries, seed locations preserved) still hold.
5.  Update the facts and natural language program to accurately describe the simultaneous BFS process and the tie-breaking rule.

## Metrics Gathering

The previous metrics script already confirms that boundary pixels and original seed locations are preserved correctly by the code structure, and the background color is identified correctly. The core issue lies purely within the `bfs_fill` logic and the order/manner in which seeds claim territory. Therefore, re-running the exact same metrics script on the *failed* output of the second attempt wouldn't provide new insights into *why* the fill pattern is wrong, only *that* it is wrong (which we already know).

Instead, the focus shifts to implementing the new simultaneous BFS strategy and then validating *that* implementation against the examples. The key assumptions verified previously (background color, boundary preservation, seed location preservation) remain valid for guiding the implementation of the new strategy.

## Facts


```yaml
task_elements:
  - role: grid_property
    type: background_color
    description: The most frequent color in the input grid, excluding the boundary color (red, 2). This color is replaced by seed colors in the output.
    value: [blue (1) in train_1, yellow (4) in train_2]
  - role: grid_element
    type: boundary
    color: red (2)
    description: Pixels forming lines that partition the grid and act as barriers for color filling. These pixels remain unchanged and block fill propagation.
  - role: grid_element
    type: seed
    description: Pixels with colors other than the background or boundary colors. They initiate the color filling process and retain their original color and location. Each seed acts as a source for the fill.
    properties: [location (row, col), color_index]
  - role: process
    type: simultaneous_competitive_flood_fill
    description: Background areas are filled based on a simultaneous expansion from all seed points, respecting boundaries. The fill uses a multi-source Breadth-First Search (BFS).
    parameters:
      - seeds: All identified seed pixels act as sources.
      - background_color: The identified background color is the target for filling.
      - boundaries: Red (2) pixels and grid edges act as barriers.
      - fill_mechanism: Multi-source BFS determines the "closest" seed for each background pixel. Distance is measured in BFS steps (Manhattan distance).
      - tie_breaking_priority: If a background pixel is equidistant from multiple seeds, the seed with the highest priority claims the pixel. Priority is determined by: 1st lowest color index, 2nd lowest row index, 3rd lowest column index.
      - fill_behavior: Fill propagates via 4-way adjacency only into background pixels. Propagation stops at boundaries or already claimed pixels.
  - role: relationship
    type: adjacency_and_distance
    description: Fill propagates based on 4-way adjacency. Closeness (minimum BFS distance) determines which seed's color fills a background pixel.
  - role: constraint
    type: immutability
    description: Boundary pixels (red) and original seed pixels maintain their color and location in the output grid.
  - role: constraint
    type: fill_competition
    description: The first seed (considering distance and tie-breaking priority) to reach a background pixel claims it, preventing other seeds from coloring it.
```


## Natural Language Program

1.  **Initialization:**
    a.  Identify the boundary color (red, 2).
    b.  Identify the background color (most frequent color excluding boundaries).
    c.  Identify all seed pixels (neither background nor boundary), storing their color, row, and column (`seed_color`, `seed_row`, `seed_col`).
    d.  Create the `output_grid`, initializing it as a copy of the `input_grid`.
    e.  Create a `distance_grid` of the same dimensions, initialized to infinity.
    f.  Create an `origin_seed_grid` of the same dimensions, initialized to store tuples `(color, row, col)` or `None`. This tracks which seed claimed each cell.
    g.  Initialize a single queue for the multi-source BFS.

2.  **Seed the BFS:**
    a.  For each identified seed at `(seed_row, seed_col)` with `seed_color`:
        i.  Mark its location: `distance_grid[seed_row, seed_col] = 0`.
        ii. Set its origin: `origin_seed_grid[seed_row, seed_col] = (seed_color, seed_row, seed_col)`.
        iii. Add the seed's location to the BFS queue: `queue.append((seed_row, seed_col))`.

3.  **Simultaneous BFS Expansion:**
    a.  While the queue is not empty:
        i.  Dequeue the current location `(r, c)`.
        ii. Get the distance and originating seed for this location: `current_dist = distance_grid[r, c]`, `origin_seed = origin_seed_grid[r, c]`.
        iii. Examine the 4 direct neighbors `(nr, nc)` of `(r, c)`.
        iv. For each neighbor `(nr, nc)` that is within the grid boundaries:
            *   Check if the neighbor is a background pixel in the `input_grid`: `input_grid[nr, nc] == background_color`.
            *   If it is a background pixel:
                *   Calculate the potential new distance: `new_dist = current_dist + 1`.
                *   Compare with the existing distance stored for the neighbor: `existing_dist = distance_grid[nr, nc]`.
                *   **Claiming Logic:**
                    *   **If `new_dist < existing_dist`:** This is the first or a shorter path found.
                        *   Update: `distance_grid[nr, nc] = new_dist`.
                        *   Update: `origin_seed_grid[nr, nc] = origin_seed`.
                        *   Update: `output_grid[nr, nc] = origin_seed[0]` (the color of the originating seed).
                        *   Enqueue the neighbor: `queue.append((nr, nc))`.
                    *   **If `new_dist == existing_dist`:** This path is equidistant to a previously found path. Apply tie-breaking.
                        *   Get the previously recorded originating seed: `existing_origin_seed = origin_seed_grid[nr, nc]`.
                        *   Compare `origin_seed` with `existing_origin_seed` based on priority: lowest color index, then lowest row, then lowest column.
                        *   If the current `origin_seed` has higher priority (wins the tie-break):
                            *   Update: `origin_seed_grid[nr, nc] = origin_seed`.
                            *   Update: `output_grid[nr, nc] = origin_seed[0]`.
                            *   *Do not re-enqueue* as the distance hasn't changed, preventing infinite loops. We only need to update the owner/color.

4.  **Finalization:** After the queue is empty, the `output_grid` contains the final state with all reachable background pixels colored according to the closest, highest-priority seed. Return the `output_grid`.
```python
"""
Transforms the input grid by performing a simultaneous competitive flood fill
originating from 'seed' pixels.

1.  Identify the boundary color (red, 2) and the background color (most frequent color
    excluding boundaries).
2.  Identify all 'seed' pixels (neither background nor boundary).
3.  Initialize data structures:
    - `output_grid`: A copy of the input grid.
    - `distance_grid`: Stores the minimum BFS distance from any seed to each cell
                      (initialized to infinity).
    - `origin_seed_grid`: Stores the tuple `(color, row, col)` of the seed that
                         claimed each cell (initialized with a placeholder).
    - `queue`: A queue for the multi-source BFS.
4.  Seed the BFS: For each seed pixel, set its distance to 0 in `distance_grid`,
    record its info in `origin_seed_grid`, and add its location to the `queue`.
5.  Run the multi-source BFS:
    - While the queue is not empty, dequeue a cell `(r, c)`.
    - For each valid neighbor `(nr, nc)`:
        - If the neighbor is a background pixel in the input grid:
            - Calculate the distance from the current cell's originating seed.
            - Compare this new path (distance and seed priority) with any existing
              path recorded for the neighbor.
            - Tie-breaking: If distances are equal, the seed with the lower color index wins.
              If colors are also equal, the seed with the lower row index wins. If rows
              are also equal, the seed with the lower column index wins. (This is
              handled implicitly by tuple comparison).
            - If the new path is better (shorter distance or wins tie-break):
                - Update the neighbor's distance, originating seed, and color in the
                  output grid.
                - Enqueue the neighbor *only if* the distance was improved (not just
                  if a tie was broken).
6.  Return the modified `output_grid`.
"""

import numpy as np
from collections import deque, Counter
import heapq # Could potentially use heapq for priority queue if needed, but simple deque works for BFS

def find_background_color(grid: np.ndarray, boundary_color: int) -> int:
    """Finds the most frequent color in the grid, ignoring the boundary color."""
    counts = Counter(grid.flatten())
    if boundary_color in counts:
        del counts[boundary_color] # Don't consider boundary color as background
    if not counts: # Handle edge case of grid with only boundary color or empty
        overall_counts = Counter(grid.flatten())
        if overall_counts:
            return overall_counts.most_common(1)[0][0]
        else:
            return 0 # Default background
    # Tie-breaking for background color (if needed, though unlikely in ARC):
    # Could sort by count descending, then color ascending if Counter keeps insertion order or sort items.
    # For now, most_common(1) is sufficient based on examples.
    return counts.most_common(1)[0][0]

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the simultaneous competitive flood fill transformation.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape
    output_grid = np.copy(input_np) # Initialize output grid

    # --- Define constants and identify colors ---
    boundary_color = 2
    background_color = find_background_color(input_np, boundary_color)

    # --- Initialize BFS data structures ---
    distance_grid = np.full((height, width), np.inf, dtype=float)
    # Placeholder seed tuple that will lose any tie-break comparison
    placeholder_seed = (np.inf, np.inf, np.inf)
    origin_seed_grid = np.full((height, width), placeholder_seed, dtype=object)
    queue = deque()

    # --- Seed the BFS queue with initial seed pixels ---
    for r in range(height):
        for c in range(width):
            color = input_np[r, c]
            if color != background_color and color != boundary_color: # It's a seed
                seed_info = (color, r, c) # Tie-breaking priority: color, row, col
                distance_grid[r, c] = 0
                origin_seed_grid[r, c] = seed_info
                queue.append((r, c))
            # Optional: Mark boundaries in distance grid if needed for logic, but checking input_np is sufficient
            # if color == boundary_color:
            #     distance_grid[r, c] = -1 # Mark as unwalkable/non-target

    # --- Run the multi-source BFS ---
    while queue:
        r, c = queue.popleft()
        current_dist = distance_grid[r, c]
        origin_seed = origin_seed_grid[r, c] # The (color, r, c) tuple of the seed that claimed cell (r,c)

        # Explore neighbors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if the neighbor is a background pixel (target for filling)
                if input_np[nr, nc] == background_color:
                    new_dist = current_dist + 1
                    existing_dist = distance_grid[nr, nc]
                    existing_origin_seed = origin_seed_grid[nr, nc]

                    # --- Claiming Logic ---
                    update_owner = False
                    enqueue_neighbor = False

                    if new_dist < existing_dist:
                        # Found a shorter path
                        update_owner = True
                        enqueue_neighbor = True # Must explore further from this cell
                    elif new_dist == existing_dist:
                        # Equidistant path - apply tie-breaking
                        # Lower tuple value means higher priority (lower color, then row, then col)
                        if origin_seed < existing_origin_seed:
                             update_owner = True
                             # Do NOT enqueue - distance didn't decrease, avoids cycles/redundancy

                    if update_owner:
                        distance_grid[nr, nc] = new_dist
                        origin_seed_grid[nr, nc] = origin_seed
                        output_grid[nr, nc] = origin_seed[0] # Assign color of the winning seed

                    if enqueue_neighbor:
                        queue.append((nr, nc))

                # Implicitly handles boundaries and other seeds:
                # If input_np[nr, nc] is not background_color, the 'if' condition fails.

    # --- Return the result ---
    return output_grid.tolist()
```
