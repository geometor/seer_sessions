{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nNatural Language Program Description:\n\n1.  Identify the background color (the most common color in the input grid, excluding the boundary color red (2)).\n2.  Identify the boundary color (red, color 2).\n3.  Identify all other pixels as \"seeds\", noting their color and location.\n4.  Create a copy of the input grid to serve as the output grid.\n5.  Create a helper grid (`filled_mask`) of the same dimensions, initially all `False`, to track which pixels are considered \"filled\" (boundaries, seeds, or already colored by the process). Mark the locations of all boundary pixels (red, 2) and all initial seed pixels as `True` in the `filled_mask`.\n6.  Create a list of all identified seeds.\n7.  Sort the list of seeds based on a priority rule: first by the lowest color index, then by the lowest row index, and finally by the lowest column index as tie-breakers.\n8.  Iterate through the sorted seeds one by one, from highest priority (lowest index values) to lowest.\n9.  For the current seed (with color `seed_color` at location `seed_loc`):\n    a.  Start a Breadth-First Search (BFS) or Flood Fill originating from `seed_loc`. Use a queue. The queue will store locations to explore *from*.\n    b.  While the BFS queue is not empty:\n        i.  Get the current location (`current_loc`) from the front of the queue.\n        ii. Examine the 4 direct neighbors (`neighbor_loc`) of `current_loc`.\n        iii. For each `neighbor_loc` that is within the grid boundaries:\n            *   Check if the pixel at `neighbor_loc` in the input grid has the background color AND if `filled_mask[neighbor_loc]` is `False`.\n            *   If both conditions are true, it means this is an unfilled background pixel adjacent to the current fill area:\n                *   Set the color of the pixel at `neighbor_loc` in the output grid to `seed_color`.\n                *   Mark `filled_mask[neighbor_loc]` as `True`.\n                *   Add `neighbor_loc` to the BFS queue to continue the fill from there.\n10. After iterating through all seeds, the output grid contains the final transformed state. Return the output grid.\n\"\"\"\n\n\ndef find_background_color(grid: np.ndarray, boundary_color: int) -> int:\n    \"\"\"Finds the most frequent color in the grid, ignoring the boundary color.\"\"\"\n    counts = Counter(grid.flatten())\n    if boundary_color in counts:\n        del counts[boundary_color] # Don't consider boundary color as background\n    if not counts: # Handle edge case of grid with only boundary color\n        # Fallback: if no other colors, maybe default to 0 or the most frequent *overall*?\n        # Let's pick the most frequent overall if available, else 0.\n        overall_counts = Counter(grid.flatten())\n        if overall_counts:\n            return overall_counts.most_common(1)[0][0]\n        else:\n            return 0 # Default if grid is empty or truly unusual\n    return counts.most_common(1)[0][0]\n\ndef bfs_fill(grid: np.ndarray, \n             output_grid: np.ndarray, \n             filled_mask: np.ndarray, \n             start_loc: tuple[int, int], \n             seed_color: int, \n             background_color: int, \n             boundary_color: int):\n    \"\"\"Performs BFS fill starting from neighbors of start_loc.\"\"\"\n    q = deque()\n    height, width = grid.shape\n\n    # Initial seeding: Add valid background neighbors of the seed point to the queue\n    r_start, c_start = start_loc\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r_start + dr, c_start + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbor_loc = (nr, nc)\n            # Check if neighbor is background and not already filled\n            if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:\n                 # Fill it immediately\n                output_grid[neighbor_loc] = seed_color\n                filled_mask[neighbor_loc] = True\n                q.append(neighbor_loc) # Add to queue for further exploration\n\n    # Start BFS from the initial neighbors\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors of the current cell\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbor_loc = (nr, nc)\n                # Check if neighbor is background and not already filled\n                if grid[neighbor_loc] == background_color and not filled_mask[neighbor_loc]:\n                    # Fill the neighbor\n                    output_grid[neighbor_loc] = seed_color\n                    filled_mask[neighbor_loc] = True\n                    q.append(neighbor_loc) # Add to queue\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by performing a competitive flood fill.\n    Regions defined by a boundary color (red, 2) are filled based on \n    'seed' pixels within them. Filling prioritizes seeds by color index, \n    then row, then column. The fill expands into the background color pixels.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_grid = np.copy(input_np)\n\n    # --- Define constants ---\n    boundary_color = 2 \n\n    # --- Identify background color ---\n    background_color = find_background_color(input_np, boundary_color)\n\n    # --- Identify seeds and initialize filled_mask ---\n    seeds = []\n    filled_mask = np.zeros_like(input_np, dtype=bool)\n    for r in range(height):\n        for c in range(width):\n            color = input_np[r, c]\n            if color == boundary_color:\n                filled_mask[r, c] = True\n            elif color != background_color:\n                seeds.append((color, r, c)) # Store color, row, col\n                filled_mask[r, c] = True # Seed locations are considered filled\n\n    # --- Sort seeds by priority: color, then row, then column ---\n    seeds.sort()\n\n    # --- Perform competitive BFS fill for each seed ---\n    for seed_color, r_seed, c_seed in seeds:\n        seed_loc = (r_seed, c_seed)\n        # The BFS function handles filling the adjacent background areas\n        bfs_fill(input_np, output_grid, filled_mask, seed_loc, seed_color, background_color, boundary_color)\n\n    # --- Return the result ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5513,
    "candidates_token_count": 2317,
    "total_token_count": 7830,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.33838,
  "retries": 1
}