
## train_1

**input:**
```
1 1 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 4 8 8 1 8 1 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8
1 1 4 4 8 8 1 1 1 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 2 8 2 8 4 8 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 8 4 8 8 2 2 2 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 8 8 8 8 2 8 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 8 4 8 8 8 8 8 8 2 2 2 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 2 8 2 8 4 8 4 8 4 8 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 8 4 8 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
2 2 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 4 1 1 2 2 2 2 1 3 3 3 3 1 1 6 6 6 6 1 1
2 2 4 4 1 1 2 2 2 2 1 1 3 3 1 1 1 6 6 1 1 1 1
1 1 1 1 1 1 2 1 2 2 1 3 3 3 3 1 1 6 6 1 1 1 1
3 3 8 8 1 1 2 1 2 2 1 3 1 1 3 1 1 6 6 6 6 1 1
3 3 3 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 3 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
6 6 7 7 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
6 6 6 7 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
6 6 7 7 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 1 1 1 1 8 8 1 1 5
5 1 4 1 4 4 1 7 7 1 1 1 8 8 8 8 1 5
5 1 4 1 4 4 1 7 7 7 7 1 8 1 1 8 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 1 8 8 1 1 4 4 4 4 1 7 7 1 1 1 5
5 1 8 8 8 8 1 4 1 4 4 1 7 7 1 1 1 5
5 1 8 1 1 8 1 4 1 4 4 1 7 7 7 7 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```

Okay, let's analyze the provided examples to understand the transformation logic.

**Perception**

1.  **Input Structure**: The input grids contain two main distinct regions:
    *   An area in the top-left containing small, usually rectangular blocks of color, often arranged in adjacent pairs. These seem to act as a "key" or "legend".
    *   A larger rectangular frame made of gray (5) pixels, typically located elsewhere in the grid. This frame encloses various patterns or objects made of different colors.
    *   There's a background/separator color used both in the "key" area and within the gray frame, although this color might differ between the two regions in some cases (need to verify). In `train_1`, azure (8) is prevalent both outside and inside the frame. In `train_2`, blue (1) is prevalent both outside (in the key area) and inside the frame.

2.  **Output Structure**: The output grid is significantly smaller than the input. It appears to directly correspond to the gray frame and its contents from the input. The output retains the gray frame structure. The patterns inside the frame are present but their colors have changed.

3.  **Transformation**: The core transformation involves:
    *   **Identifying the target area**: Locating the gray (5) frame in the input.
    *   **Cropping**: Extracting the subgrid corresponding to the bounding box of the gray frame. The output dimensions match this cropped area.
    *   **Identifying color mapping rules**: Analyzing the adjacent color pairs in the "key" area (outside the gray frame) to determine how colors should be transformed. Each pair `(Color A, Color B)` implies that pixels of `Color A` inside the frame should become `Color B` in the output.
    *   **Identifying invariant colors**: The gray (5) frame color remains unchanged. The background/separator color used within the frame (which is usually the same as the separator color in the key area) also remains unchanged.
    *   **Applying the mapping**: Iterating through the pixels of the cropped (frame) area and applying the derived color mappings, leaving the frame and background colors as they are.

**Facts**


```yaml
elements:
  - object: Frame
    properties:
      - color: gray (5)
      - shape: rectangle
      - role: defines the region of interest for the output

  - object: MappingKeyArea
    properties:
      - location: outside the Frame's bounding box
      - contains: MappingPairs and SeparatorPixels

  - object: MappingPair
    properties:
      - structure: two adjacent, distinct colored blocks (often rectangles)
      - role: defines a color transformation rule (color_A -> color_B)
      - location: within MappingKeyArea

  - object: InnerContent
    properties:
      - location: inside the Frame
      - composition: pixels potentially subject to color transformation
      - includes: BackgroundPixels

  - object: SeparatorPixel / BackgroundPixel
    properties:
      - color: varies by task (e.g., azure(8) in train_1, blue(1) in train_2)
      - location: separates MappingPairs in MappingKeyArea, acts as background/separator within InnerContent
      - behavior: remains unchanged during transformation

actions:
  - name: locate_frame
    input: input_grid
    output: bounding_box_of_gray_frame

  - name: extract_mapping_rules
    input: input_grid, frame_bounding_box
    process: scan area outside frame_bounding_box for adjacent color blocks (MappingPairs)
    output: dictionary_of_color_maps {color_A: color_B, ...}

  - name: identify_invariant_background
    input: input_grid, frame_bounding_box
    process: determine the dominant non-mapping color in the MappingKeyArea (outside the frame)
    output: invariant_background_color

  - name: crop_region
    input: input_grid, frame_bounding_box
    output: cropped_subgrid

  - name: apply_transformation
    input: cropped_subgrid, color_maps, invariant_background_color, frame_color (gray 5)
    process: iterate through cropped_subgrid pixels, apply color_maps, keep invariant_background_color and frame_color unchanged
    output: output_grid

relationships:
  - The Frame's bounding box determines the area to be cropped and transformed.
  - The MappingPairs outside the Frame define the color changes applied inside the Frame.
  - The SeparatorPixel color found outside the Frame identifies the color that remains unchanged inside the Frame (along with the Frame color itself).
  - The dimensions of the output grid are identical to the dimensions of the Frame's bounding box in the input.
```


**Natural Language Program**

1.  **Find the Frame**: Scan the input grid to identify the largest contiguous rectangular object composed solely of gray (5) pixels. Determine its bounding box (top-left and bottom-right coordinates).
2.  **Extract Mapping Rules and Invariant Background**:
    *   Examine the region of the input grid *outside* the Frame's bounding box.
    *   Identify pairs of distinctly colored, adjacent rectangular objects (typically small, like 2x2 or 1xN). For each pair `(Object A, Object B)` with `Color A` and `Color B`, record a mapping rule: `Color A` transforms to `Color B`.
    *   Identify the color that acts as a separator or background in this outside region, distinct from the colors in the mapping pairs. This is the `invariant_background_color`.
3.  **Crop**: Create a new grid by copying the portion of the input grid defined by the Frame's bounding box (including the frame itself).
4.  **Transform Colors**: Iterate through each pixel `(r, c)` in the cropped grid:
    *   Get the `current_color` of the pixel.
    *   If `current_color` is gray (5) (the frame color), keep it as gray (5) in the output.
    *   If `current_color` is the `invariant_background_color`, keep it as `invariant_background_color` in the output.
    *   If `current_color` matches the key (`Color A`) in any identified mapping rule (`Color A -> Color B`), change the pixel's color to the corresponding value (`Color B`) in the output.
    *   (Assumption: Any other color encountered inside the frame will be part of a mapping rule).
5.  **Output**: The resulting transformed grid is the final output.
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid based on color mapping rules derived from key blocks outside a gray frame.

The transformation logic involves several steps:
1. Identifying a rectangular frame made of a specific color (gray, value 5) in the input grid by finding the minimum and maximum row and column indices of pixels with this color.
2. Locating key-value color pairs outside this frame by examining adjacent pixels. The logic prioritizes horizontal (left->right) adjacency, then vertical (top->down) adjacency to establish a mapping rule (Color A -> Color B). The frame color and the determined background color are ignored when searching for these pairs.
3. Determining the background color that should remain invariant during the transformation. This is identified as the most frequent color found in the area outside the frame, excluding the frame color itself and any colors that become part of a mapping rule (either as a key or a value). Fallback mechanisms are included if this primary identification method is ambiguous or fails.
4. Cropping the input grid to the exact region defined by the frame's bounding box (inclusive).
5. Creating the output grid by applying the derived mapping rules to the pixels within this cropped region. Pixels matching a key color (Color A) are changed to the corresponding value color (Color B). The frame color (5) and the identified invariant background color are preserved in their original positions. Any other pixel colors within the frame that are not part of the mapping rules also remain unchanged.
"""

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    """
    Finds the bounding box coordinates (min_row, min_col, max_row, max_col) 
    of the pixels matching the specified frame color using their minimum and maximum indices.
    Returns None if the frame color is not present in the grid.
    """
    # Find all coordinates where the grid matches the frame color
    coords = np.argwhere(grid_np == frame_color)
    
    # If no coordinates are found, the frame color doesn't exist; return None
    if coords.size == 0:
        return None 
        
    # Determine the minimum and maximum row and column indices from the coordinates
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)
    
    # Return the bounding box coordinates
    return (r_min, c_min, r_max, c_max)


def find_mapping_rules_and_background(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int] | None, frame_color: int = 5) -> tuple[dict[int, int], int]:
    """
    Identifies color mapping rules (as a dictionary {key_color: value_color}) 
    and the invariant background color (as an integer) by analyzing the region 
    of the grid outside the provided frame bounding box.
    """
    rows, cols = grid_np.shape
    
    # If the frame bounding box is not provided, return default empty mappings and background color 0
    if frame_bbox is None:
         print("Warning: Frame bounding box is None in find_mapping_rules. Returning defaults.")
         return {}, 0 

    r_min, c_min, r_max, c_max = frame_bbox

    outside_colors_counter = Counter()
    outside_coords = []
    # Iterate through each cell of the grid
    for r in range(rows):
        for c in range(cols):
            # Determine if the current cell is outside the frame's bounding box
            is_outside = not (r >= r_min and r <= r_max and c >= c_min and c <= c_max)
            if is_outside:
                color = grid_np[r, c]
                # Count the frequency of non-frame colors outside the frame
                if color != frame_color:
                    outside_colors_counter[color] += 1
                # Store the coordinates of all cells outside the frame
                outside_coords.append((r, c))

    # --- Determine Potential Background Color ---
    potential_background = -1
    # Sort the counted outside colors by frequency (descending) and then by color value (ascending)
    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    # The most frequent color is the initial candidate for the background
    if sorted_colors:
        potential_background = sorted_colors[0][0] 
    else:
        # If no non-frame colors were found outside, default the background to 0
        potential_background = 0 

    # --- Find Mapping Rules by Checking Adjacency ---
    mappings = {} # Dictionary to store color_a -> color_b mappings
    mapped_colors = set() # Set to track colors involved in any mapping (key or value)
    processed_pairs = set() # Set to track unique pairs (a,b) to avoid redundant checks

    # Iterate through the coordinates identified as being outside the frame
    for r, c in outside_coords:
        color_a = grid_np[r, c]
        # Skip if the color is the frame color, the potential background, or already a mapping key
        if color_a == frame_color or color_a == potential_background or color_a in mappings:
            continue

        # Check the neighbor to the right
        if c + 1 < cols:
             nr, nc = r, c + 1
             # Check if the right neighbor is also outside the frame
             is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
             if is_neighbor_outside:
                 color_b = grid_np[nr, nc]
                 # Check if color_b is a valid target for mapping (different from A, not frame, not background)
                 if color_b != color_a and color_b != frame_color and color_b != potential_background:
                     # Create a sorted tuple to uniquely identify the pair regardless of order
                     pair = tuple(sorted((color_a, color_b)))
                     # If this pair hasn't been processed and color_a hasn't been mapped yet
                     if pair not in processed_pairs and color_a not in mappings:
                         # Establish the mapping A -> B (horizontal priority)
                         mappings[color_a] = color_b
                         mapped_colors.add(color_a)
                         mapped_colors.add(color_b)
                         processed_pairs.add(pair)
                         # Once color_a is mapped, move to the next coordinate in outside_coords
                         continue 

        # If no horizontal mapping was found, check the neighbor below
        if r + 1 < rows:
             nr, nc = r + 1, c
             # Check if the bottom neighbor is also outside the frame
             is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
             if is_neighbor_outside:
                  color_b = grid_np[nr, nc]
                  # Check if color_b is a valid target for mapping
                  if color_b != color_a and color_b != frame_color and color_b != potential_background:
                      pair = tuple(sorted((color_a, color_b)))
                      # If this pair hasn't been processed and color_a hasn't been mapped yet
                      if pair not in processed_pairs and color_a not in mappings:
                           # Establish the mapping A -> B (vertical)
                           mappings[color_a] = color_b
                           mapped_colors.add(color_a)
                           mapped_colors.add(color_b)
                           processed_pairs.add(pair)
                           # Loop continues to the next coordinate

    # --- Finalize Background Color ---
    actual_background = potential_background
    # If the initial potential background color was used in a mapping
    if potential_background in mapped_colors:
        actual_background = -1 # Reset the background color
        # Find the next most frequent outside color that *wasn't* mapped
        for color, count in sorted_colors: 
            if color not in mapped_colors:
                actual_background = color
                break # Found a suitable background color

        # Fallback if all outside non-frame colors were involved in mappings
        if actual_background == -1:
            # Check inside the frame (excluding the border) for the most frequent color
            # that isn't the frame color and wasn't mapped.
            inside_counter = Counter()
            # Check if frame has an interior (width and height > 1 pixel excluding borders)
            if r_max > r_min and c_max > c_min: 
                 for r_in in range(r_min + 1, r_max):
                     for c_in in range(c_min + 1, c_max):
                         color = grid_np[r_in, c_in]
                         # Count frequency if not frame color and not already mapped
                         if color != frame_color and color not in mapped_colors:
                             inside_counter[color] += 1
            
            # Sort the inside colors by frequency
            sorted_inside = sorted(inside_counter.items(), key=lambda item: (-item[1], item[0]))
            if sorted_inside:
                 # The most frequent unmapped inside color becomes the background
                 actual_background = sorted_inside[0][0] 
            else:
                # If no suitable background found via any method, default to 0
                print("Warning: Could not determine a definitive background color. Defaulting to 0.")
                actual_background = 0 

    # Return the final mapping rules and the determined background color
    return mappings, actual_background


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid according to ARC task logic:
    1. Finds a gray (5) frame.
    2. Derives color mapping rules from adjacent color blocks outside the frame.
    3. Determines the invariant background color.
    4. Crops the grid to the frame's boundaries.
    5. Applies the mappings to the cropped area, preserving frame and background colors.
    """
    # Convert the input list of lists to a NumPy array for efficient operations
    input_np = np.array(input_grid, dtype=int)
    frame_color = 5 # Define the color designated as the frame

    # Step 1: Find the bounding box of the gray frame
    frame_bbox = find_frame_bbox(input_np, frame_color)

    # If no frame is detected, return the original input grid as per ARC convention
    if frame_bbox is None:
        # print("Warning: No frame (color 5) found. Returning input grid unchanged.")
        return input_grid

    r_min, c_min, r_max, c_max = frame_bbox

    # Step 2: Determine the color mapping rules and the invariant background color
    mappings, invariant_background = find_mapping_rules_and_background(input_np, frame_bbox, frame_color)

    # Step 3: Crop the input grid to the area defined by the frame's bounding box.
    # Create a copy to avoid modifying the original input array slice.
    output_np = input_np[r_min:r_max + 1, c_min:c_max + 1].copy()
    output_h, output_w = output_np.shape # Get dimensions of the output grid

    # Step 4: Apply the transformation rules to the cropped grid (output_np)
    for r_out in range(output_h):
        for c_out in range(output_w):
            current_color = output_np[r_out, c_out]

            # Check conditions and apply transformations:
            # If the color is the frame color, do nothing.
            if current_color == frame_color:
                continue 
            # If the color is the invariant background, do nothing.
            elif current_color == invariant_background:
                continue 
            # If the color is a key in the mappings dictionary, change it to the mapped value.
            elif current_color in mappings:
                output_np[r_out, c_out] = mappings[current_color]
            # Otherwise (color is not frame, not background, not a mapping key), it remains unchanged.
            
    # Convert the transformed NumPy array back to a standard Python list of lists
    output_grid = output_np.tolist()

    # Return the final transformed grid
    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Transforms the input grid based on color mapping rules derived from key blocks outside a gray frame.

The transformation logic involves several steps:
1. Identifying a rectangular frame made of a specific color (gray, value 5) in the input grid by finding the minimum and maximum row and column indices of pixels with this color.
2. Locating key-value color pairs outside this frame by examining adjacent pixels. The logic prioritizes horizontal (left->right) adjacency, then vertical (top->down) adjacency to establish a mapping rule (Color A -> Color B). The frame color and the determined background color are ignored when searching for these pairs.
3. Determining the background color that should remain invariant during the transformation. This is identified as the most frequent color found in the area outside the frame, excluding the frame color itself and any colors that become part of a mapping rule (either as a key or a value). Fallback mechanisms are included if this primary identification method is ambiguous or fails.
4. Cropping the input grid to the exact region defined by the frame's bounding box (inclusive).
5. Creating the output grid by applying the derived mapping rules to the pixels within this cropped region. Pixels matching a key color (Color A) are changed to the corresponding value color (Color B). The frame color (5) and the identified invariant background color are preserved in their original positions. Any other pixel colors within the frame that are not part of the mapping rules also remain unchanged.
"""

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    """
    Finds the bounding box coordinates (min_row, min_col, max_row, max_col) 
    of the pixels matching the specified frame color using their minimum and maximum indices.
    Returns None if the frame color is not present in the grid.
    """
    # Find all coordinates where the grid matches the frame color
    coords = np.argwhere(grid_np == frame_color)
    
    # If no coordinates are found, the frame color doesn't exist; return None
    if coords.size == 0:
        return None 
        
    # Determine the minimum and maximum row and column indices from the coordinates
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)
    
    # Return the bounding box coordinates
    return (r_min, c_min, r_max, c_max)


def find_mapping_rules_and_background(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int] | None, frame_color: int = 5) -> tuple[dict[int, int], int]:
    """
    Identifies color mapping rules (as a dictionary {key_color: value_color}) 
    and the invariant background color (as an integer) by analyzing the region 
    of the grid outside the provided frame bounding box.
    """
    rows, cols = grid_np.shape
    
    # If the frame bounding box is not provided, return default empty mappings and background color 0
    if frame_bbox is None:
         print("Warning: Frame bounding box is None in find_mapping_rules. Returning defaults.")
         return {}, 0 

    r_min, c_min, r_max, c_max = frame_bbox

    outside_colors_counter = Counter()
    outside_coords = []
    # Iterate through each cell of the grid
    for r in range(rows):
        for c in range(cols):
            # Determine if the current cell is outside the frame's bounding box
            is_outside = not (r >= r_min and r <= r_max and c >= c_min and c <= c_max)
            if is_outside:
                color = grid_np[r, c]
                # Count the frequency of non-frame colors outside the frame
                if color != frame_color:
                    outside_colors_counter[color] += 1
                # Store the coordinates of all cells outside the frame
                outside_coords.append((r, c))

    # --- Determine Potential Background Color ---
    potential_background = -1
    # Sort the counted outside colors by frequency (descending) and then by color value (ascending)
    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    # The most frequent color is the initial candidate for the background
    if sorted_colors:
        potential_background = sorted_colors[0][0] 
    else:
        # If no non-frame colors were found outside, default the background to 0
        potential_background = 0 

    # --- Find Mapping Rules by Checking Adjacency ---
    mappings = {} # Dictionary to store color_a -> color_b mappings
    mapped_colors = set() # Set to track colors involved in any mapping (key or value)
    processed_pairs = set() # Set to track unique pairs (a,b) to avoid redundant checks

    # Iterate through the coordinates identified as being outside the frame
    for r, c in outside_coords:
        color_a = grid_np[r, c]
        # Skip if the color is the frame color, the potential background, or already a mapping key
        if color_a == frame_color or color_a == potential_background or color_a in mappings:
            continue

        # Check the neighbor to the right
        if c + 1 < cols:
             nr, nc = r, c + 1
             # Check if the right neighbor is also outside the frame
             is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
             if is_neighbor_outside:
                 color_b = grid_np[nr, nc]
                 # Check if color_b is a valid target for mapping (different from A, not frame, not background)
                 if color_b != color_a and color_b != frame_color and color_b != potential_background:
                     # Create a sorted tuple to uniquely identify the pair regardless of order
                     pair = tuple(sorted((color_a, color_b)))
                     # If this pair hasn't been processed and color_a hasn't been mapped yet
                     if pair not in processed_pairs and color_a not in mappings:
                         # Establish the mapping A -> B (horizontal priority)
                         mappings[color_a] = color_b
                         mapped_colors.add(color_a)
                         mapped_colors.add(color_b)
                         processed_pairs.add(pair)
                         # Once color_a is mapped, move to the next coordinate in outside_coords
                         continue 

        # If no horizontal mapping was found, check the neighbor below
        if r + 1 < rows:
             nr, nc = r + 1, c
             # Check if the bottom neighbor is also outside the frame
             is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
             if is_neighbor_outside:
                  color_b = grid_np[nr, nc]
                  # Check if color_b is a valid target for mapping
                  if color_b != color_a and color_b != frame_color and color_b != potential_background:
                      pair = tuple(sorted((color_a, color_b)))
                      # If this pair hasn't been processed and color_a hasn't been mapped yet
                      if pair not in processed_pairs and color_a not in mappings:
                           # Establish the mapping A -> B (vertical)
                           mappings[color_a] = color_b
                           mapped_colors.add(color_a)
                           mapped_colors.add(color_b)
                           processed_pairs.add(pair)
                           # Loop continues to the next coordinate

    # --- Finalize Background Color ---
    actual_background = potential_background
    # If the initial potential background color was used in a mapping
    if potential_background in mapped_colors:
        actual_background = -1 # Reset the background color
        # Find the next most frequent outside color that *wasn't* mapped
        for color, count in sorted_colors: 
            if color not in mapped_colors:
                actual_background = color
                break # Found a suitable background color

        # Fallback if all outside non-frame colors were involved in mappings
        if actual_background == -1:
            # Check inside the frame (excluding the border) for the most frequent color
            # that isn't the frame color and wasn't mapped.
            inside_counter = Counter()
            # Check if frame has an interior (width and height > 1 pixel excluding borders)
            if r_max > r_min and c_max > c_min: 
                 for r_in in range(r_min + 1, r_max):
                     for c_in in range(c_min + 1, c_max):
                         color = grid_np[r_in, c_in]
                         # Count frequency if not frame color and not already mapped
                         if color != frame_color and color not in mapped_colors:
                             inside_counter[color] += 1
            
            # Sort the inside colors by frequency
            sorted_inside = sorted(inside_counter.items(), key=lambda item: (-item[1], item[0]))
            if sorted_inside:
                 # The most frequent unmapped inside color becomes the background
                 actual_background = sorted_inside[0][0] 
            else:
                # If no suitable background found via any method, default to 0
                print("Warning: Could not determine a definitive background color. Defaulting to 0.")
                actual_background = 0 

    # Return the final mapping rules and the determined background color
    return mappings, actual_background


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid according to ARC task logic:
    1. Finds a gray (5) frame.
    2. Derives color mapping rules from adjacent color blocks outside the frame.
    3. Determines the invariant background color.
    4. Crops the grid to the frame's boundaries.
    5. Applies the mappings to the cropped area, preserving frame and background colors.
    """
    # Convert the input list of lists to a NumPy array for efficient operations
    input_np = np.array(input_grid, dtype=int)
    frame_color = 5 # Define the color designated as the frame

    # Step 1: Find the bounding box of the gray frame
    frame_bbox = find_frame_bbox(input_np, frame_color)

    # If no frame is detected, return the original input grid as per ARC convention
    if frame_bbox is None:
        # print("Warning: No frame (color 5) found. Returning input grid unchanged.")
        return input_grid

    r_min, c_min, r_max, c_max = frame_bbox

    # Step 2: Determine the color mapping rules and the invariant background color
    mappings, invariant_background = find_mapping_rules_and_background(input_np, frame_bbox, frame_color)

    # Step 3: Crop the input grid to the area defined by the frame's bounding box.
    # Create a copy to avoid modifying the original input array slice.
    output_np = input_np[r_min:r_max + 1, c_min:c_max + 1].copy()
    output_h, output_w = output_np.shape # Get dimensions of the output grid

    # Step 4: Apply the transformation rules to the cropped grid (output_np)
    for r_out in range(output_h):
        for c_out in range(output_w):
            current_color = output_np[r_out, c_out]

            # Check conditions and apply transformations:
            # If the color is the frame color, do nothing.
            if current_color == frame_color:
                continue 
            # If the color is the invariant background, do nothing.
            elif current_color == invariant_background:
                continue 
            # If the color is a key in the mappings dictionary, change it to the mapped value.
            elif current_color in mappings:
                output_np[r_out, c_out] = mappings[current_color]
            # Otherwise (color is not frame, not background, not a mapping key), it remains unchanged.
            
    # Convert the transformed NumPy array back to a standard Python list of lists
    output_grid = output_np.tolist()

    # Return the final transformed grid
    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
1 1 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 4 8 8 1 8 1 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8
1 1 4 4 8 8 1 1 1 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
```
Expected Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 2 8 2 8 4 8 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 8 4 8 8 2 2 2 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 8 8 8 8 2 8 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 8 4 8 8 8 8 8 8 2 2 2 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 2 8 2 8 4 8 4 8 4 8 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 8 4 8 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Match: False
Pixels Off: 20
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 14.035087719298247

## Example 2:
Input:
```
2 2 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 4 1 1 2 2 2 2 1 3 3 3 3 1 1 6 6 6 6 1 1
2 2 4 4 1 1 2 2 2 2 1 1 3 3 1 1 1 6 6 1 1 1 1
1 1 1 1 1 1 2 1 2 2 1 3 3 3 3 1 1 6 6 1 1 1 1
3 3 8 8 1 1 2 1 2 2 1 3 1 1 3 1 1 6 6 6 6 1 1
3 3 3 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 3 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
6 6 7 7 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
6 6 6 7 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
6 6 7 7 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 1 1 1 1 8 8 1 1 5
5 1 4 1 4 4 1 7 7 1 1 1 8 8 8 8 1 5
5 1 4 1 4 4 1 7 7 7 7 1 8 1 1 8 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 1 8 8 1 1 4 4 4 4 1 7 7 1 1 1 5
5 1 8 8 8 8 1 4 1 4 4 1 7 7 1 1 1 5
5 1 8 1 1 8 1 4 1 4 4 1 7 7 7 7 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Match: False
Pixels Off: 20
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 17.09401709401709
**General Assessment and Strategy**

The initial analysis correctly identified the core components: a gray frame defining the output area, a key area outside the frame providing color mapping rules, and an invariant background color. The initial code successfully implemented frame finding, cropping, background identification, and basic pixel-wise color mapping based on adjacent key pairs.

However, the results show that a simple pixel-wise mapping is insufficient. The errors indicate that the *shape* or internal structure of the colored objects within the frame changes during the transformation, with some pixels becoming the background color.

The refined hypothesis is that the key area *also* contains "template" objects. For each color `A` that maps to color `B`, there's a corresponding template object outside the frame, composed of color `A` and the background color. This template defines the exact shape and internal pattern (including background pixels) of the output object. When a contiguous block of color `A` is found *inside* the frame, it is replaced by its corresponding template shape, substituting `A` with `B` and keeping the background pixels from the template. The placement seems to align with the top-left corner of the original block within the frame, and the dimensions of the output block are determined by the template.

The strategy is to:
1.  Refine the logic for analyzing the key area to extract not only the `A -> B` mapping pairs but also the associated template shape for each color `A`.
2.  Modify the transformation step to identify contiguous blocks of color `A` inside the frame.
3.  For each block, retrieve the corresponding template, perform the `A -> B` color substitution on it, and write this resulting pattern into the output grid at the block's location.

**Gather Metrics**

We will use code execution to verify the components of the refined hypothesis for `train_1`.



*code_execution:*
```python
import numpy as np
from collections import Counter

# --- Data for train_1 ---
input_grid_1 = [
    [1, 1, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [1, 1, 1, 4, 8, 8, 1, 8, 1, 8, 8, 3, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [1, 1, 4, 4, 8, 8, 1, 1, 1, 8, 8, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [3, 3, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [3, 3, 3, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [3, 3, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8],
    [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8],
    [8, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8]
]
input_np_1 = np.array(input_grid_1)
frame_color = 5

# --- Helper Function: Find Frame ---
def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    coords = np.argwhere(grid_np == frame_color)
    if coords.size == 0: return None
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)
    # Basic check for rectangularity (all frame pixels on the border)
    is_rect = True
    for r, c in coords:
        if not (r == r_min or r == r_max or c == c_min or c == c_max):
            is_rect = False
            break
    # More robust check might be needed for complex cases
    return (r_min, c_min, r_max, c_max) if is_rect else None

# --- Helper Function: Find Contiguous Blocks ---
def find_contiguous_blocks(grid, target_colors):
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    blocks = {} # {color: [(r, c, h, w, block_array)]}

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            if color in target_colors and not visited[r, c]:
                block_coords = []
                q = [(r, c)]
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c

                while q:
                    curr_r, curr_c = q.pop(0)
                    block_coords.append((curr_r, curr_c))
                    min_r, min_c = min(min_r, curr_r), min(min_c, curr_c)
                    max_r, max_c = max(max_r, curr_r), max(max_c, curr_c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                h = max_r - min_r + 1
                w = max_c - min_c + 1
                block_arr = grid[min_r:max_r+1, min_c:max_c+1] # This captures the bounding box, might contain other colors if not rectangular

                # Refine block_arr to only contain the actual block pixels relative to top-left
                relative_coords = [(br - min_r, bc - min_c) for br, bc in block_coords]
                refined_block_arr = np.full((h, w), -1) # Use -1 or another placeholder
                for rr, rc in relative_coords:
                    refined_block_arr[rr, rc] = color

                if color not in blocks: blocks[color] = []
                blocks[color].append({'r': min_r, 'c': min_c, 'h': h, 'w': w, 'coords': block_coords, 'array': block_arr, 'refined_array': refined_block_arr})
    return blocks

# --- Helper Function: Find Contiguous Blocks with Background ---
def find_template_blocks(grid, target_colors, background_color):
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    blocks = {} # {color: [(r, c, h, w, block_array)]}
    allowed_colors = set(target_colors) | {background_color}

    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start search from a target_color pixel
            if color in target_colors and not visited[r, c]:
                component_coords = []
                q = [(r, c)]
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c
                has_target_color = {color} # Track which target colors are in this component

                while q:
                    curr_r, curr_c = q.pop(0)
                    component_coords.append((curr_r, curr_c))
                    min_r, min_c = min(min_r, curr_r), min(min_c, curr_c)
                    max_r, max_c = max(max_r, curr_r), max(max_c, curr_c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = curr_r + dr, curr_c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] in allowed_colors:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            if grid[nr, nc] in target_colors:
                                has_target_color.add(grid[nr, nc])

                # Only consider components that contain exactly ONE target color
                if len(has_target_color) == 1:
                    primary_color = list(has_target_color)[0]
                    h = max_r - min_r + 1
                    w = max_c - min_c + 1
                    block_arr = grid[min_r:max_r+1, min_c:max_c+1].copy() # Bounding box subgrid

                    # Ensure only primary and background colors are present
                    valid_template = True
                    for comp_r, comp_c in component_coords:
                        if grid[comp_r, comp_c] not in [primary_color, background_color]:
                            valid_template = False
                            break
                    if not valid_template:
                         continue # Skip this component

                    if primary_color not in blocks: blocks[primary_color] = []
                    # Store the bounding box version as the template
                    blocks[primary_color].append({'r': min_r, 'c': min_c, 'h': h, 'w': w, 'array': block_arr})
                # else: # Component has multiple target colors or only background, ignore
                    # print(f"Skipping component at ({r},{c}) with colors: {has_target_color}")
                    # pass # Reset visited status? No, keep visited.


    # Select the largest template for each color
    final_templates = {}
    for color, template_list in blocks.items():
        if template_list:
            largest_template = max(template_list, key=lambda t: t['array'].size)
            final_templates[color] = largest_template['array']

    return final_templates


# --- Analysis for train_1 ---
print("--- Analyzing Train Example 1 ---")
frame_bbox_1 = find_frame_bbox(input_np_1, frame_color)
print(f"Frame BBox: {frame_bbox_1}")

if frame_bbox_1:
    r_min, c_min, r_max, c_max = frame_bbox_1
    rows, cols = input_np_1.shape
    outside_colors_counter = Counter()
    outside_coords = []
    for r in range(rows):
        for c in range(cols):
            is_outside = not (r >= r_min and r <= r_max and c >= c_min and c <= c_max)
            if is_outside:
                color = input_np_1[r, c]
                if color != frame_color:
                    outside_colors_counter[color] += 1
                outside_coords.append((r, c))

    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    potential_background = sorted_colors[0][0] if sorted_colors else 0
    print(f"Most frequent outside color (potential background): {potential_background}") # Should be 8

    # Find mapping pairs (simple adjacency check)
    mappings = {}
    processed_pairs = set()
    for r, c in outside_coords:
        color_a = input_np_1[r, c]
        if color_a == frame_color or color_a == potential_background or color_a in mappings: continue
        # Check right
        if c + 1 < cols:
            nr, nc = r, c + 1
            is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
            if is_neighbor_outside:
                color_b = input_np_1[nr, nc]
                if color_b != color_a and color_b != frame_color and color_b != potential_background:
                     pair = tuple(sorted((color_a, color_b)))
                     if pair not in processed_pairs and color_a not in mappings:
                         # Simple heuristic: assume smaller blocks map from larger blocks if sizes differ? No, just adjacency.
                         # Let's assume left maps to right for now.
                         mappings[color_a] = color_b
                         processed_pairs.add(pair)
                         continue # Skip vertical check if horizontal found
        # Check down
        if r + 1 < rows:
             nr, nc = r + 1, c
             is_neighbor_outside = not (nr >= r_min and nr <= r_max and nc >= c_min and nc <= c_max)
             if is_neighbor_outside:
                  color_b = input_np_1[nr, nc]
                  if color_b != color_a and color_b != frame_color and color_b != potential_background:
                      pair = tuple(sorted((color_a, color_b)))
                      if pair not in processed_pairs and color_a not in mappings:
                          # Assume top maps to bottom
                          mappings[color_a] = color_b
                          processed_pairs.add(pair)

    # Refine mappings based on block adjacency (using the found pairs)
    # Keys: 1 maps to 4? Or 4 maps to 1? 3 maps to 2? Or 2 maps to 3?
    # Look at pairs: (1,4) found near (0,2). (3,2) found near (4,0).
    # Assume the first color in the pair is the key:
    final_mappings = {}
    mapped_colors = set()
    # Manually identify from visual inspection for train_1: (1,4) and (3,2) are the pairs.
    # Let's assume the order seen (left-to-right, top-to-bottom preference) matters.
    # Pair at (0,0) is 1, (0,2) is 4 -> 1 maps to 4?
    # Pair at (4,0) is 3, (4,2) is 2 -> 3 maps to 2?
    final_mappings = {1: 4, 3: 2} # Based on visual inspection and hypothesis
    mapped_colors = {1, 4, 3, 2}
    print(f"Deduced Mappings: {final_mappings}")

    # Determine actual background
    actual_background = -1
    for color, count in sorted_colors:
        if color not in mapped_colors:
            actual_background = color
            break
    if actual_background == -1: actual_background = potential_background # Fallback
    print(f"Final Background Color: {actual_background}") # Should be 8

    # Find templates outside frame
    outside_grid_np = input_np_1.copy()
    # Mask the inside of the frame to avoid considering it for templates
    outside_grid_np[r_min:r_max+1, c_min:c_max+1] = -99 # Assign a unique ignored value

    template_colors = final_mappings.keys()
    templates = find_template_blocks(outside_grid_np, template_colors, actual_background)

    print("Found Templates:")
    for color, template in templates.items():
        print(f"  Color {color}:")
        print(template)

    # Find blocks inside frame
    inside_grid_np = input_np_1[r_min:r_max+1, c_min:c_max+1]
    inside_blocks = find_contiguous_blocks(inside_grid_np, template_colors) # Find blocks of colors 1 and 3

    print("Found Blocks Inside Frame:")
    for color, block_list in inside_blocks.items():
        print(f"  Color {color}:")
        for i, block in enumerate(block_list):
            # Print only refined array if it exists and looks okay
             print(f"    Block {i} at ({block['r']}, {block['c']}) - Size ({block['h']}x{block['w']})")
             # print(block.get('refined_array', 'N/A')) # Might be too verbose
             # Check if refined_array exists and contains only the target color or -1
             refined = block.get('refined_array')
             if refined is not None:
                 is_pure = np.all((refined == color) | (refined == -1))
                 print(f"      Pure block (only color {color}): {is_pure}")
                 if not is_pure:
                     print("      Contains other colors in bounding box:")
                     print(block['array']) # Print bounding box if refined isn't pure


else:
    print("No frame found.")


```

*code_execution_result:*
outcome: OUTCOME_OK
```
--- Analyzing Train Example 1 ---
Frame BBox: (np.int64(8), np.int64(3), np.int64(22), np.int64(21))
Most frequent outside color (potential background): 8
Deduced Mappings: {1: 4, 3: 2}
Final Background Color: 8
Found Templates:
Found Blocks Inside Frame:
  Color 3:
    Block 0 at (2, 2) - Size (3x3)
      Pure block (only color 3): True
    Block 1 at (2, 10) - Size (3x3)
      Pure block (only color 3): True
    Block 2 at (6, 2) - Size (3x3)
      Pure block (only color 3): True
    Block 3 at (6, 14) - Size (3x3)
      Pure block (only color 3): True
    Block 4 at (10, 6) - Size (3x3)
      Pure block (only color 3): True
  Color 1:
    Block 0 at (2, 6) - Size (3x3)
      Pure block (only color 1): True
    Block 1 at (2, 14) - Size (3x3)
      Pure block (only color 1): True
    Block 2 at (6, 6) - Size (3x3)
      Pure block (only color 1): True
    Block 3 at (10, 10) - Size (3x3)
      Pure block (only color 1): True
    Block 4 at (10, 14) - Size (3x3)
      Pure block (only color 1): True

```
**Analysis of Metrics:**

*   **Frame Detection:** Correctly identified `(r=8, c=3)` to `(r=22, c=21)`.
*   **Background Color:** Correctly identified as `8` (azure).
*   **Mappings:** Correctly deduced as `1 -> 4` and `3 -> 2`.
*   **Template Finding:** The `find_template_blocks` function seems to have failed or didn't find blocks matching the criteria (composed solely of the target color and background color, outside the frame). This needs revision. Looking at the input `train_1` again, the key area has blocks like `[[1, 8, 1], [1, 1, 1], [8, 1, 8]]` and `[[3, 8, 3], [3, 3, 3], [3, 3, 3]]`. These *are* the templates. My helper function needs to correctly isolate these specific blocks. The current `find_template_blocks` might be too restrictive or flawed in how it explores/validates components.
    *   *Correction Strategy:* The template isn't necessarily the *largest* block, but rather a specific block composed of the source color `A` and the background color, located outside the frame. We need a better way to identify these specific template blocks, perhaps by looking for blocks containing *both* the source color and the background color.
*   **Inside Blocks:** The `find_contiguous_blocks` function correctly identified the locations and sizes of the pure blocks of colors `1` and `3` inside the frame's bounding box. The coordinates are relative to the cropped grid (frame area).

**Revised YAML Facts**


```yaml
elements:
  - object: Frame
    properties:
      - color: gray (5)
      - shape: rectangle (hollow)
      - role: defines the region of interest (ROI) for cropping and output

  - object: MappingKeyArea
    properties:
      - location: outside the Frame's bounding box
      - contains: MappingPairs, TemplateBlocks, SeparatorPixels

  - object: MappingPair
    properties:
      - structure: two adjacent, distinct colored blocks (e.g., A next to B)
      - role: defines a color transformation rule (color_A -> color_B)
      - location: within MappingKeyArea

  - object: TemplateBlock
    properties:
      - structure: a contiguous block composed ONLY of a source color (e.g., color_A from mapping A->B) and the BackgroundColor
      - shape: specific pattern defining the output object's shape
      - role: provides the visual template for a transformed object
      - location: within MappingKeyArea
      - association: one unique TemplateBlock exists for each source color_A in the mappings

  - object: SourceBlock
    properties:
      - structure: a contiguous block of a single source color (e.g., color_A)
      - location: inside the Frame
      - role: input object to be transformed

  - object: BackgroundColor
    properties:
      - color: varies by task (most frequent color in MappingKeyArea excluding frame and mapping colors)
      - role: invariant color, used within TemplateBlocks and fills empty space

actions:
  - name: locate_frame
    input: input_grid
    output: bounding_box_of_gray_frame

  - name: analyze_key_area
    input: input_grid, frame_bounding_box
    process:
      - Identify adjacent blocks to find MappingPairs (A -> B).
      - Determine BackgroundColor (most frequent outside color != frame, A, B).
      - For each source color A, find its corresponding TemplateBlock (contiguous block outside frame made of only A and BackgroundColor).
    output: dictionary_of_color_maps {A: B, ...}, BackgroundColor, dictionary_of_templates {A: template_array, ...}

  - name: crop_to_frame
    input: input_grid, frame_bounding_box
    output: cropped_subgrid (initial state of output)

  - name: locate_source_blocks
    input: cropped_subgrid, source_colors (keys from color_maps)
    output: list_of_source_blocks [{r, c, h, w, color}, ...] (coordinates relative to cropped_subgrid)

  - name: apply_templates
    input: cropped_subgrid, list_of_source_blocks, dictionary_of_templates, dictionary_of_color_maps, BackgroundColor
    process:
      - Create an output grid initialized with BackgroundColor, same size as cropped_subgrid.
      - Copy the gray (5) frame pixels from cropped_subgrid to output grid.
      - For each SourceBlock (color A at r, c):
          - Get the TemplateBlock array for color A.
          - Create the target pattern by replacing A with B (from mapping A->B) in the template array, leaving BackgroundColor unchanged.
          - Place this target pattern onto the output grid, aligning its top-left corner with the SourceBlock's top-left corner (r, c).
    output: final_output_grid

relationships:
  - The Frame defines the output dimensions and boundary.
  - MappingPairs define which colors change (A -> B).
  - BackgroundColor defines the invariant fill color.
  - TemplateBlocks define the *shape* of the output for each transformed color.
  - SourceBlocks inside the frame trigger the application of their corresponding transformed TemplateBlock.
```


**Refined Natural Language Program**

1.  **Find the Frame**: Scan the input grid to identify the rectangular boundary composed of gray (5) pixels. Determine its bounding box (top-left `(r_min, c_min)` and bottom-right `(r_max, c_max)`). If no frame is found, return the input unchanged.
2.  **Analyze Key Area (Outside Frame)**:
    *   Identify pairs of adjacent, distinctly colored blocks outside the frame to establish mapping rules (`Color A -> Color B`). Prioritize horizontal adjacency, then vertical.
    *   Count the frequency of all colors outside the frame, excluding the frame color (5). Determine the `BackgroundColor` as the most frequent color that is not part of any mapping rule (neither `Color A` nor `Color B`).
    *   For each source color `A` identified in the mapping rules: Search outside the frame for a contiguous block composed *only* of `Color A` and the `BackgroundColor`. Store this block's array as the `TemplateBlock` for `Color A`. Assume there is one unique template per source color.
3.  **Initialize Output**: Create a new grid (`output_grid`) with the dimensions determined by the frame's bounding box (`height = r_max - r_min + 1`, `width = c_max - c_min + 1`). Initialize it entirely with the `BackgroundColor`.
4.  **Copy Frame**: Copy the gray (5) pixels forming the frame from the input grid (within the bounding box) to the `output_grid` at their corresponding relative positions.
5.  **Identify and Transform Source Blocks**:
    *   Scan the area *inside* the frame in the input grid (from `(r_min+1, c_min+1)` to `(r_max-1, c_max-1)`).
    *   Identify all contiguous blocks composed of a single source color `A` (where `A` is a key in the mapping rules). Record the top-left corner `(r_src, c_src)` (relative to the frame's top-left `(r_min, c_min)`) for each block found. Use a 'visited' marker to process each block only once.
    *   For each identified `SourceBlock` of `Color A` starting at relative coordinates `(r_rel, c_rel)` (where `r_rel = r_src - r_min`, `c_rel = c_src - c_min`):
        *   Retrieve the `TemplateBlock` array associated with `Color A`.
        *   Let `Color B` be the target color from the mapping `A -> B`.
        *   Iterate through the `TemplateBlock` array. For each pixel:
            *   If the template pixel is `Color A`, place `Color B` in the `output_grid`.
            *   If the template pixel is `BackgroundColor`, place `BackgroundColor` in the `output_grid`.
        *   Place these pixels into the `output_grid`, starting at position `(r_rel, c_rel)`, ensuring placement respects the bounds of the `output_grid`. The dimensions of the placed pattern are determined by the `TemplateBlock`.
6.  **Output**: Return the `output_grid`.
```python
import numpy as np
from collections import Counter, deque

"""
Transforms the input grid by:
1. Identifying a rectangular gray (5) frame.
2. Analyzing the area outside the frame to find:
    a. Color mapping rules (A -> B) based on adjacent blocks.
    b. The invariant background color (most frequent outside color not involved in mappings or the frame).
    c. Template blocks for each source color 'A', composed of color 'A' and the background color.
3. Creating an output grid based on the frame size, initialized with the background color.
4. Copying the gray frame to the output.
5. Finding contiguous blocks of source colors 'A' inside the frame.
6. For each source block found, retrieving its corresponding template, substituting color 'A' with 'B', 
   and drawing this transformed template onto the output grid at the source block's location.
"""

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    """
    Finds the bounding box coordinates (min_row, min_col, max_row, max_col) 
    of the largest rectangular frame made of frame_color.
    Checks if the identified structure forms a hollow rectangle.
    Returns None if no such frame is found.
    """
    coords = np.argwhere(grid_np == frame_color)
    if coords.size == 0:
        return None
        
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)

    # Verify it's a hollow rectangle
    # All frame_color pixels must be on the border
    on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \
                (coords[:, 1] == c_min) | (coords[:, 1] == c_max)
    if not np.all(on_border):
        # Could potentially search for smaller frames, but assume largest for now
        return None 

    # Check if the inside is not the frame color (ensure it's hollow)
    # Avoid checking if frame is only 1 or 2 pixels wide/high
    if r_max > r_min + 1 and c_max > c_min + 1:
        inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]
        if np.any(inner_slice == frame_color):
            return None # Frame color found inside, not a simple hollow frame

    return (r_min, c_min, r_max, c_max)

def find_contiguous_blocks(grid_np: np.ndarray, target_colors: set[int], start_coord: tuple[int, int] | None = None) -> list[dict]:
    """
    Finds all contiguous blocks of any single color within target_colors.
    Returns a list of dictionaries, each containing 'color', 'coords' (set), 
    'r_min', 'c_min', 'r_max', 'c_max'.
    If start_coord is provided, only finds the block containing that coordinate.
    """
    rows, cols = grid_np.shape
    visited = np.zeros_like(grid_np, dtype=bool)
    blocks = []
    
    search_coords = []
    if start_coord:
        search_coords = [start_coord]
    else:
        # Generate all coordinates if no start_coord is given
        search_coords = [(r, c) for r in range(rows) for c in range(cols)]

    for r_init, c_init in search_coords:
        color = grid_np[r_init, c_init]
        if color in target_colors and not visited[r_init, c_init]:
            block_coords = set()
            q = deque([(r_init, c_init)])
            visited[r_init, c_init] = True
            r_min, c_min = r_init, c_init
            r_max, c_max = r_init, c_init
            
            while q:
                r, c = q.popleft()
                block_coords.add((r, c))
                r_min, c_min = min(r_min, r), min(c_min, c)
                r_max, c_max = max(r_max, r), max(c_max, c)

                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and \
                       not visited[nr, nc] and grid_np[nr, nc] == color:
                        visited[nr, nc] = True
                        q.append((nr, nc))

            blocks.append({
                'color': color, 
                'coords': block_coords,
                'r_min': r_min, 'c_min': c_min, 
                'r_max': r_max, 'c_max': c_max
            })
            # If we started with a specific coordinate, we found its block, so break
            if start_coord:
                 break 
                 
    return blocks

def find_template_blocks(grid_np: np.ndarray, source_colors: set[int], background_color: int) -> dict[int, np.ndarray]:
    """
    Finds template blocks outside the frame. A template block for source color 'A' 
    is a contiguous component made ONLY of color 'A' and the background_color, 
    containing at least one pixel of color 'A'.
    Returns a dictionary {source_color: template_array}.
    Assumes the relevant template is the first one found for each source color.
    """
    rows, cols = grid_np.shape
    visited = np.zeros_like(grid_np, dtype=bool)
    templates = {}
    allowed_colors = source_colors | {background_color}

    for r_init in range(rows):
        for c_init in range(cols):
            # Start BFS from a source color pixel that hasn't been visited
            start_color = grid_np[r_init, c_init]
            if start_color in source_colors and not visited[r_init, c_init] and start_color not in templates:
                
                component_coords = set()
                q = deque([(r_init, c_init)])
                visited[r_init, c_init] = True
                r_min, c_min = r_init, c_init
                r_max, c_max = r_init, c_init
                found_source_color = False 
                
                while q:
                    r, c = q.popleft()
                    current_color = grid_np[r, c]
                    
                    # Check if the component contains invalid colors
                    if current_color not in allowed_colors:
                        # Mark all visited in this path as invalid? Difficult.
                        # Easier to validate after BFS finds the full component.
                        # For now, just skip adding this coord and continue BFS elsewhere.
                        # A better approach might be needed if templates intermingle badly.
                         continue 

                    component_coords.add((r, c))
                    if current_color == start_color:
                        found_source_color = True
                    
                    r_min, c_min = min(r_min, r), min(c_min, c)
                    r_max, c_max = max(r_max, r), max(c_max, c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid_np[nr, nc] in allowed_colors:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # Post-BFS validation: Ensure component only has start_color & background
                is_valid_template = True
                if not found_source_color: # Should not happen if start_color is source
                    is_valid_template = False
                else:
                    for r_comp, c_comp in component_coords:
                        if grid_np[r_comp, c_comp] not in [start_color, background_color]:
                            is_valid_template = False
                            break
                
                if is_valid_template:
                    # Extract the bounding box as the template
                    template_arr = grid_np[r_min:r_max + 1, c_min:c_max + 1]
                    templates[start_color] = template_arr
                    # Optimization: If we found templates for all source colors, stop.
                    if len(templates) == len(source_colors):
                        break
            
            # If we found templates for all source colors, stop outer loop.
            if len(templates) == len(source_colors):
                 break
                        
    return templates


def analyze_key_area(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int], frame_color: int) -> tuple[dict[int, int], int, dict[int, np.ndarray]]:
    """
    Analyzes the area outside the frame to find mappings, background, and templates.
    """
    rows, cols = grid_np.shape
    r_min, c_min, r_max, c_max = frame_bbox

    outside_colors_counter = Counter()
    outside_coords_map = {} # Store coords for each color
    key_area_mask = np.ones_like(grid_np, dtype=bool)
    key_area_mask[r_min:r_max+1, c_min:c_max+1] = False # Mask out frame area

    for r in range(rows):
        for c in range(cols):
            if key_area_mask[r, c]: # If outside frame
                color = grid_np[r, c]
                if color != frame_color:
                    outside_colors_counter[color] += 1
                    if color not in outside_coords_map:
                        outside_coords_map[color] = []
                    outside_coords_map[color].append((r,c))

    # --- Find Mappings using block adjacency ---
    mappings = {}
    mapped_colors = set()
    potential_keys = set(outside_colors_counter.keys())
    
    # Find blocks for all potential key colors outside the frame
    outside_blocks_map = {} # {color: [block_info, ...]}
    for color in potential_keys:
        if color in outside_coords_map:
            # Create a temporary grid containing only this color and -1 elsewhere
            temp_grid = np.full_like(grid_np, -1)
            for r, c in outside_coords_map[color]:
                 temp_grid[r, c] = color
            
            # Find blocks of this color in the temp grid (ensures only outside blocks)
            blocks = find_contiguous_blocks(temp_grid, {color})
            if blocks:
                 outside_blocks_map[color] = blocks

    # Check adjacency between blocks of different colors
    colors_present = list(outside_blocks_map.keys())
    for i in range(len(colors_present)):
        color_a = colors_present[i]
        if color_a in mapped_colors: continue # Already used as key or value

        for j in range(i + 1, len(colors_present)):
            color_b = colors_present[j]
            if color_b in mapped_colors: continue

            # Check if any block of color_a is adjacent to any block of color_b
            found_adjacency = False
            for block_a in outside_blocks_map[color_a]:
                coords_a = block_a['coords']
                for block_b in outside_blocks_map[color_b]:
                    coords_b = block_b['coords']
                    
                    # Check horizontal/vertical adjacency
                    for r_a, c_a in coords_a:
                        is_adjacent = False
                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                            nr, nc = r_a + dr, c_a + dc
                            if (nr, nc) in coords_b:
                                is_adjacent = True
                                break
                        if is_adjacent:
                            found_adjacency = True
                            break
                if found_adjacency:
                    break
            
            if found_adjacency:
                 # Found an adjacent pair (A, B). Need to decide direction.
                 # Heuristic: Assume the block appearing "first" (min row, then min col) is the key.
                 a_min_r = min(b['r_min'] for b in outside_blocks_map[color_a])
                 a_min_c = min(b['c_min'] for b in outside_blocks_map[color_a] if b['r_min'] == a_min_r)
                 b_min_r = min(b['r_min'] for b in outside_blocks_map[color_b])
                 b_min_c = min(b['c_min'] for b in outside_blocks_map[color_b] if b['r_min'] == b_min_r)

                 key_color, val_color = -1, -1
                 if (a_min_r < b_min_r) or (a_min_r == b_min_r and a_min_c < b_min_c):
                      key_color, val_color = color_a, color_b
                 else:
                      key_color, val_color = color_b, color_a
                      
                 if key_color not in mappings:
                    mappings[key_color] = val_color
                    mapped_colors.add(key_color)
                    mapped_colors.add(val_color)
                    # Break inner loops once a mapping is found for color_a?
                    # Let's assume one mapping pair per distinct visual pair.
                 
                 # Avoid mapping the same colors again
                 break # Move to the next color_a

    # --- Determine Background Color ---
    background_color = -1
    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    for color, count in sorted_colors:
        if color not in mapped_colors:
            background_color = color
            break
            
    if background_color == -1: # Fallback if all outside colors are mapped
        # Check inside frame (excluding border) for most frequent non-mapped, non-frame color
        if r_max > r_min and c_max > c_min:
            inside_counter = Counter()
            for r in range(r_min + 1, r_max):
                for c in range(c_min + 1, c_max):
                    color = grid_np[r, c]
                    if color != frame_color and color not in mapped_colors:
                        inside_counter[color] += 1
            sorted_inside = sorted(inside_counter.items(), key=lambda item: (-item[1], item[0]))
            if sorted_inside:
                background_color = sorted_inside[0][0]
            else:
                background_color = 0 # Ultimate fallback
        else:
             background_color = 0 # Frame too small for interior


    # --- Find Templates ---
    source_colors = set(mappings.keys())
    # Create a copy of the grid where the frame area is marked invalid for template search
    key_area_grid = grid_np.copy()
    # Mark frame and inside with a value not in allowed_colors for find_template_blocks
    invalid_marker = -99 
    key_area_grid[r_min:r_max+1, c_min:c_max+1] = invalid_marker
    
    templates = find_template_blocks(key_area_grid, source_colors, background_color)
    
    # Validation: Ensure templates were found for all source colors
    if len(templates) != len(source_colors):
         print(f"Warning: Could not find templates for all source colors. Found: {templates.keys()}, Needed: {source_colors}")
         # Handle this case? Maybe default to simple color swap? For now, proceed.

    return mappings, background_color, templates


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Main transformation function.
    """
    input_np = np.array(input_grid, dtype=int)
    frame_color = 5

    # --- Step 1: Find the Frame ---
    frame_bbox = find_frame_bbox(input_np, frame_color)
    if frame_bbox is None:
        # print("Warning: No valid frame found. Returning input grid unchanged.")
        return input_grid
    r_min, c_min, r_max, c_max = frame_bbox

    # --- Step 2: Analyze Key Area (Outside Frame) ---
    try:
        mappings, background_color, templates = analyze_key_area(input_np, frame_bbox, frame_color)
    except Exception as e:
        # print(f"Error during key area analysis: {e}. Returning input grid.")
        # Fallback or error handling - return original grid might be safest
        return input_grid # Or raise error

    # --- Step 3: Initialize Output ---
    output_h = r_max - r_min + 1
    output_w = c_max - c_min + 1
    output_np = np.full((output_h, output_w), background_color, dtype=int)

    # --- Step 4: Copy Frame ---
    # Iterate through the frame coordinates found initially
    frame_coords_relative = np.argwhere(input_np[r_min:r_max+1, c_min:c_max+1] == frame_color)
    for r_rel, c_rel in frame_coords_relative:
        output_np[r_rel, c_rel] = frame_color

    # --- Step 5: Identify and Transform Source Blocks ---
    source_colors = set(mappings.keys())
    # Create a grid representing only the inside of the frame
    inside_grid_np = input_np[r_min + 1:r_max, c_min + 1:c_max]
    
    # Need to keep track of visited cells in the *output* grid's coordinate system
    # to avoid overwriting parts of placed templates by later blocks.
    output_visited_mask = np.zeros_like(output_np, dtype=bool) 
    # Mark frame as visited initially
    output_visited_mask[output_np == frame_color] = True 

    # Iterate through potential starting points inside the frame
    for r_in in range(inside_grid_np.shape[0]):
        for c_in in range(inside_grid_np.shape[1]):
            # Map inside coords (r_in, c_in) to output coords (r_out, c_out)
            r_out, c_out = r_in + 1, c_in + 1 
            
            # Check if this output cell has already been processed (part of another template or frame)
            if output_visited_mask[r_out, c_out]:
                continue

            source_color = inside_grid_np[r_in, c_in]

            if source_color in source_colors:
                 # We found a potential start of a source block. 
                 # Find the full block in the *original* input grid, starting from global coords.
                 global_r, global_c = r_in + r_min + 1, c_in + c_min + 1
                 
                 # Find the single block containing this global coordinate
                 source_block_info_list = find_contiguous_blocks(input_np, {source_color}, start_coord=(global_r, global_c))
                 
                 if source_block_info_list: # Should find exactly one block
                     source_block_info = source_block_info_list[0]
                     block_r_min_global = source_block_info['r_min']
                     block_c_min_global = source_block_info['c_min']
                     
                     # Calculate top-left relative to the output grid
                     block_r_rel = block_r_min_global - r_min
                     block_c_rel = block_c_min_global - c_min

                     # Check if we have a template for this color
                     if source_color in templates:
                         template = templates[source_color]
                         target_color = mappings[source_color]
                         t_h, t_w = template.shape

                         # Apply the template
                         for r_t in range(t_h):
                             for c_t in range(t_w):
                                 out_r = block_r_rel + r_t
                                 out_c = block_c_rel + c_t

                                 # Ensure placement is within output bounds
                                 if 0 <= out_r < output_h and 0 <= out_c < output_w:
                                     template_pixel = template[r_t, c_t]
                                     # Only overwrite if not already visited (e.g., by frame or another template)
                                     if not output_visited_mask[out_r, out_c]:
                                         if template_pixel == source_color:
                                             output_np[out_r, out_c] = target_color
                                         elif template_pixel == background_color:
                                             # Already initialized with background, but mark visited
                                             output_np[out_r, out_c] = background_color 
                                         # else: # Should not happen if template is valid
                                         #     print(f"Warning: Unexpected color {template_pixel} in template for {source_color}")
                                         
                                         # Mark this output cell as visited
                                         output_visited_mask[out_r, out_c] = True
                     else:
                         # No template found - what to do? Simple color swap? Skip?
                         # For now, let's mark the block's area as visited to avoid reprocessing
                         # coords_global = source_block_info['coords']
                         # for r_g, c_g in coords_global:
                         #      r_o, c_o = r_g - r_min, c_g - c_min
                         #      if 0 <= r_o < output_h and 0 <= c_o < output_w:
                         #           output_visited_mask[r_o, c_o] = True
                         # print(f"Warning: No template for source color {source_color} at ({block_r_rel}, {block_c_rel}). Skipping block.")
                         pass # Mark as visited below

                     # Mark the entire original source block area in the output as visited,
                     # regardless of template application, to prevent reprocessing pixels
                     # of the same block if the BFS in find_contiguous_blocks was used earlier.
                     # Find the coordinates relative to the output grid.
                     coords_global = source_block_info['coords']
                     for r_g, c_g in coords_global:
                         r_o, c_o = r_g - r_min, c_g - c_min
                         if 0 <= r_o < output_h and 0 <= c_o < output_w:
                              output_visited_mask[r_o, c_o] = True
                 # else: # Should not happen if find_contiguous_blocks works
                 #     print(f"Error: Did not find block for source color {source_color} starting at global ({global_r}, {global_c})")
                 #     output_visited_mask[r_out, c_out] = True # Mark start cell visited anyway

            else:
                # If the cell inside is not a source color, just mark it visited if it's background
                # (Other colors inside that aren't source colors are ignored per the logic)
                if source_color == background_color:
                     output_visited_mask[r_out, c_out] = True


    # --- Step 6: Output ---
    output_grid = output_np.tolist()
    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import Counter, deque

"""
Transforms the input grid by:
1. Identifying a rectangular gray (5) frame.
2. Analyzing the area outside the frame to find:
    a. Color mapping rules (A -> B) based on adjacent blocks.
    b. The invariant background color (most frequent outside color not involved in mappings or the frame).
    c. Template blocks for each source color 'A', composed of color 'A' and the background color.
3. Creating an output grid based on the frame size, initialized with the background color.
4. Copying the gray frame to the output.
5. Finding contiguous blocks of source colors 'A' inside the frame.
6. For each source block found, retrieving its corresponding template, substituting color 'A' with 'B', 
   and drawing this transformed template onto the output grid at the source block's location.
"""

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    """
    Finds the bounding box coordinates (min_row, min_col, max_row, max_col) 
    of the largest rectangular frame made of frame_color.
    Checks if the identified structure forms a hollow rectangle.
    Returns None if no such frame is found.
    """
    coords = np.argwhere(grid_np == frame_color)
    if coords.size == 0:
        return None
        
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)

    # Verify it's a hollow rectangle
    # All frame_color pixels must be on the border
    on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \
                (coords[:, 1] == c_min) | (coords[:, 1] == c_max)
    if not np.all(on_border):
        # Could potentially search for smaller frames, but assume largest for now
        return None 

    # Check if the inside is not the frame color (ensure it's hollow)
    # Avoid checking if frame is only 1 or 2 pixels wide/high
    if r_max > r_min + 1 and c_max > c_min + 1:
        inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]
        if np.any(inner_slice == frame_color):
            return None # Frame color found inside, not a simple hollow frame

    return (r_min, c_min, r_max, c_max)

def find_contiguous_blocks(grid_np: np.ndarray, target_colors: set[int], start_coord: tuple[int, int] | None = None) -> list[dict]:
    """
    Finds all contiguous blocks of any single color within target_colors.
    Returns a list of dictionaries, each containing 'color', 'coords' (set), 
    'r_min', 'c_min', 'r_max', 'c_max'.
    If start_coord is provided, only finds the block containing that coordinate.
    """
    rows, cols = grid_np.shape
    visited = np.zeros_like(grid_np, dtype=bool)
    blocks = []
    
    search_coords = []
    if start_coord:
        search_coords = [start_coord]
    else:
        # Generate all coordinates if no start_coord is given
        search_coords = [(r, c) for r in range(rows) for c in range(cols)]

    for r_init, c_init in search_coords:
        color = grid_np[r_init, c_init]
        if color in target_colors and not visited[r_init, c_init]:
            block_coords = set()
            q = deque([(r_init, c_init)])
            visited[r_init, c_init] = True
            r_min, c_min = r_init, c_init
            r_max, c_max = r_init, c_init
            
            while q:
                r, c = q.popleft()
                block_coords.add((r, c))
                r_min, c_min = min(r_min, r), min(c_min, c)
                r_max, c_max = max(r_max, r), max(c_max, c)

                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and \
                       not visited[nr, nc] and grid_np[nr, nc] == color:
                        visited[nr, nc] = True
                        q.append((nr, nc))

            blocks.append({
                'color': color, 
                'coords': block_coords,
                'r_min': r_min, 'c_min': c_min, 
                'r_max': r_max, 'c_max': c_max
            })
            # If we started with a specific coordinate, we found its block, so break
            if start_coord:
                 break 
                 
    return blocks

def find_template_blocks(grid_np: np.ndarray, source_colors: set[int], background_color: int) -> dict[int, np.ndarray]:
    """
    Finds template blocks outside the frame. A template block for source color 'A' 
    is a contiguous component made ONLY of color 'A' and the background_color, 
    containing at least one pixel of color 'A'.
    Returns a dictionary {source_color: template_array}.
    Assumes the relevant template is the first one found for each source color.
    """
    rows, cols = grid_np.shape
    visited = np.zeros_like(grid_np, dtype=bool)
    templates = {}
    allowed_colors = source_colors | {background_color}

    for r_init in range(rows):
        for c_init in range(cols):
            # Start BFS from a source color pixel that hasn't been visited
            start_color = grid_np[r_init, c_init]
            if start_color in source_colors and not visited[r_init, c_init] and start_color not in templates:
                
                component_coords = set()
                q = deque([(r_init, c_init)])
                visited[r_init, c_init] = True
                r_min, c_min = r_init, c_init
                r_max, c_max = r_init, c_init
                found_source_color = False 
                
                while q:
                    r, c = q.popleft()
                    current_color = grid_np[r, c]
                    
                    # Check if the component contains invalid colors
                    if current_color not in allowed_colors:
                        # Mark all visited in this path as invalid? Difficult.
                        # Easier to validate after BFS finds the full component.
                        # For now, just skip adding this coord and continue BFS elsewhere.
                        # A better approach might be needed if templates intermingle badly.
                         continue 

                    component_coords.add((r, c))
                    if current_color == start_color:
                        found_source_color = True
                    
                    r_min, c_min = min(r_min, r), min(c_min, c)
                    r_max, c_max = max(r_max, r), max(c_max, c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid_np[nr, nc] in allowed_colors:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # Post-BFS validation: Ensure component only has start_color & background
                is_valid_template = True
                if not found_source_color: # Should not happen if start_color is source
                    is_valid_template = False
                else:
                    for r_comp, c_comp in component_coords:
                        if grid_np[r_comp, c_comp] not in [start_color, background_color]:
                            is_valid_template = False
                            break
                
                if is_valid_template:
                    # Extract the bounding box as the template
                    template_arr = grid_np[r_min:r_max + 1, c_min:c_max + 1]
                    templates[start_color] = template_arr
                    # Optimization: If we found templates for all source colors, stop.
                    if len(templates) == len(source_colors):
                        break
            
            # If we found templates for all source colors, stop outer loop.
            if len(templates) == len(source_colors):
                 break
                        
    return templates


def analyze_key_area(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int], frame_color: int) -> tuple[dict[int, int], int, dict[int, np.ndarray]]:
    """
    Analyzes the area outside the frame to find mappings, background, and templates.
    """
    rows, cols = grid_np.shape
    r_min, c_min, r_max, c_max = frame_bbox

    outside_colors_counter = Counter()
    outside_coords_map = {} # Store coords for each color
    key_area_mask = np.ones_like(grid_np, dtype=bool)
    key_area_mask[r_min:r_max+1, c_min:c_max+1] = False # Mask out frame area

    for r in range(rows):
        for c in range(cols):
            if key_area_mask[r, c]: # If outside frame
                color = grid_np[r, c]
                if color != frame_color:
                    outside_colors_counter[color] += 1
                    if color not in outside_coords_map:
                        outside_coords_map[color] = []
                    outside_coords_map[color].append((r,c))

    # --- Find Mappings using block adjacency ---
    mappings = {}
    mapped_colors = set()
    potential_keys = set(outside_colors_counter.keys())
    
    # Find blocks for all potential key colors outside the frame
    outside_blocks_map = {} # {color: [block_info, ...]}
    for color in potential_keys:
        if color in outside_coords_map:
            # Create a temporary grid containing only this color and -1 elsewhere
            temp_grid = np.full_like(grid_np, -1)
            for r, c in outside_coords_map[color]:
                 temp_grid[r, c] = color
            
            # Find blocks of this color in the temp grid (ensures only outside blocks)
            blocks = find_contiguous_blocks(temp_grid, {color})
            if blocks:
                 outside_blocks_map[color] = blocks

    # Check adjacency between blocks of different colors
    colors_present = list(outside_blocks_map.keys())
    for i in range(len(colors_present)):
        color_a = colors_present[i]
        if color_a in mapped_colors: continue # Already used as key or value

        for j in range(i + 1, len(colors_present)):
            color_b = colors_present[j]
            if color_b in mapped_colors: continue

            # Check if any block of color_a is adjacent to any block of color_b
            found_adjacency = False
            for block_a in outside_blocks_map[color_a]:
                coords_a = block_a['coords']
                for block_b in outside_blocks_map[color_b]:
                    coords_b = block_b['coords']
                    
                    # Check horizontal/vertical adjacency
                    for r_a, c_a in coords_a:
                        is_adjacent = False
                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                            nr, nc = r_a + dr, c_a + dc
                            if (nr, nc) in coords_b:
                                is_adjacent = True
                                break
                        if is_adjacent:
                            found_adjacency = True
                            break
                if found_adjacency:
                    break
            
            if found_adjacency:
                 # Found an adjacent pair (A, B). Need to decide direction.
                 # Heuristic: Assume the block appearing "first" (min row, then min col) is the key.
                 a_min_r = min(b['r_min'] for b in outside_blocks_map[color_a])
                 a_min_c = min(b['c_min'] for b in outside_blocks_map[color_a] if b['r_min'] == a_min_r)
                 b_min_r = min(b['r_min'] for b in outside_blocks_map[color_b])
                 b_min_c = min(b['c_min'] for b in outside_blocks_map[color_b] if b['r_min'] == b_min_r)

                 key_color, val_color = -1, -1
                 if (a_min_r < b_min_r) or (a_min_r == b_min_r and a_min_c < b_min_c):
                      key_color, val_color = color_a, color_b
                 else:
                      key_color, val_color = color_b, color_a
                      
                 if key_color not in mappings:
                    mappings[key_color] = val_color
                    mapped_colors.add(key_color)
                    mapped_colors.add(val_color)
                    # Break inner loops once a mapping is found for color_a?
                    # Let's assume one mapping pair per distinct visual pair.
                 
                 # Avoid mapping the same colors again
                 break # Move to the next color_a

    # --- Determine Background Color ---
    background_color = -1
    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    for color, count in sorted_colors:
        if color not in mapped_colors:
            background_color = color
            break
            
    if background_color == -1: # Fallback if all outside colors are mapped
        # Check inside frame (excluding border) for most frequent non-mapped, non-frame color
        if r_max > r_min and c_max > c_min:
            inside_counter = Counter()
            for r in range(r_min + 1, r_max):
                for c in range(c_min + 1, c_max):
                    color = grid_np[r, c]
                    if color != frame_color and color not in mapped_colors:
                        inside_counter[color] += 1
            sorted_inside = sorted(inside_counter.items(), key=lambda item: (-item[1], item[0]))
            if sorted_inside:
                background_color = sorted_inside[0][0]
            else:
                background_color = 0 # Ultimate fallback
        else:
             background_color = 0 # Frame too small for interior


    # --- Find Templates ---
    source_colors = set(mappings.keys())
    # Create a copy of the grid where the frame area is marked invalid for template search
    key_area_grid = grid_np.copy()
    # Mark frame and inside with a value not in allowed_colors for find_template_blocks
    invalid_marker = -99 
    key_area_grid[r_min:r_max+1, c_min:c_max+1] = invalid_marker
    
    templates = find_template_blocks(key_area_grid, source_colors, background_color)
    
    # Validation: Ensure templates were found for all source colors
    if len(templates) != len(source_colors):
         print(f"Warning: Could not find templates for all source colors. Found: {templates.keys()}, Needed: {source_colors}")
         # Handle this case? Maybe default to simple color swap? For now, proceed.

    return mappings, background_color, templates


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Main transformation function.
    """
    input_np = np.array(input_grid, dtype=int)
    frame_color = 5

    # --- Step 1: Find the Frame ---
    frame_bbox = find_frame_bbox(input_np, frame_color)
    if frame_bbox is None:
        # print("Warning: No valid frame found. Returning input grid unchanged.")
        return input_grid
    r_min, c_min, r_max, c_max = frame_bbox

    # --- Step 2: Analyze Key Area (Outside Frame) ---
    try:
        mappings, background_color, templates = analyze_key_area(input_np, frame_bbox, frame_color)
    except Exception as e:
        # print(f"Error during key area analysis: {e}. Returning input grid.")
        # Fallback or error handling - return original grid might be safest
        return input_grid # Or raise error

    # --- Step 3: Initialize Output ---
    output_h = r_max - r_min + 1
    output_w = c_max - c_min + 1
    output_np = np.full((output_h, output_w), background_color, dtype=int)

    # --- Step 4: Copy Frame ---
    # Iterate through the frame coordinates found initially
    frame_coords_relative = np.argwhere(input_np[r_min:r_max+1, c_min:c_max+1] == frame_color)
    for r_rel, c_rel in frame_coords_relative:
        output_np[r_rel, c_rel] = frame_color

    # --- Step 5: Identify and Transform Source Blocks ---
    source_colors = set(mappings.keys())
    # Create a grid representing only the inside of the frame
    inside_grid_np = input_np[r_min + 1:r_max, c_min + 1:c_max]
    
    # Need to keep track of visited cells in the *output* grid's coordinate system
    # to avoid overwriting parts of placed templates by later blocks.
    output_visited_mask = np.zeros_like(output_np, dtype=bool) 
    # Mark frame as visited initially
    output_visited_mask[output_np == frame_color] = True 

    # Iterate through potential starting points inside the frame
    for r_in in range(inside_grid_np.shape[0]):
        for c_in in range(inside_grid_np.shape[1]):
            # Map inside coords (r_in, c_in) to output coords (r_out, c_out)
            r_out, c_out = r_in + 1, c_in + 1 
            
            # Check if this output cell has already been processed (part of another template or frame)
            if output_visited_mask[r_out, c_out]:
                continue

            source_color = inside_grid_np[r_in, c_in]

            if source_color in source_colors:
                 # We found a potential start of a source block. 
                 # Find the full block in the *original* input grid, starting from global coords.
                 global_r, global_c = r_in + r_min + 1, c_in + c_min + 1
                 
                 # Find the single block containing this global coordinate
                 source_block_info_list = find_contiguous_blocks(input_np, {source_color}, start_coord=(global_r, global_c))
                 
                 if source_block_info_list: # Should find exactly one block
                     source_block_info = source_block_info_list[0]
                     block_r_min_global = source_block_info['r_min']
                     block_c_min_global = source_block_info['c_min']
                     
                     # Calculate top-left relative to the output grid
                     block_r_rel = block_r_min_global - r_min
                     block_c_rel = block_c_min_global - c_min

                     # Check if we have a template for this color
                     if source_color in templates:
                         template = templates[source_color]
                         target_color = mappings[source_color]
                         t_h, t_w = template.shape

                         # Apply the template
                         for r_t in range(t_h):
                             for c_t in range(t_w):
                                 out_r = block_r_rel + r_t
                                 out_c = block_c_rel + c_t

                                 # Ensure placement is within output bounds
                                 if 0 <= out_r < output_h and 0 <= out_c < output_w:
                                     template_pixel = template[r_t, c_t]
                                     # Only overwrite if not already visited (e.g., by frame or another template)
                                     if not output_visited_mask[out_r, out_c]:
                                         if template_pixel == source_color:
                                             output_np[out_r, out_c] = target_color
                                         elif template_pixel == background_color:
                                             # Already initialized with background, but mark visited
                                             output_np[out_r, out_c] = background_color 
                                         # else: # Should not happen if template is valid
                                         #     print(f"Warning: Unexpected color {template_pixel} in template for {source_color}")
                                         
                                         # Mark this output cell as visited
                                         output_visited_mask[out_r, out_c] = True
                     else:
                         # No template found - what to do? Simple color swap? Skip?
                         # For now, let's mark the block's area as visited to avoid reprocessing
                         # coords_global = source_block_info['coords']
                         # for r_g, c_g in coords_global:
                         #      r_o, c_o = r_g - r_min, c_g - c_min
                         #      if 0 <= r_o < output_h and 0 <= c_o < output_w:
                         #           output_visited_mask[r_o, c_o] = True
                         # print(f"Warning: No template for source color {source_color} at ({block_r_rel}, {block_c_rel}). Skipping block.")
                         pass # Mark as visited below

                     # Mark the entire original source block area in the output as visited,
                     # regardless of template application, to prevent reprocessing pixels
                     # of the same block if the BFS in find_contiguous_blocks was used earlier.
                     # Find the coordinates relative to the output grid.
                     coords_global = source_block_info['coords']
                     for r_g, c_g in coords_global:
                         r_o, c_o = r_g - r_min, c_g - c_min
                         if 0 <= r_o < output_h and 0 <= c_o < output_w:
                              output_visited_mask[r_o, c_o] = True
                 # else: # Should not happen if find_contiguous_blocks works
                 #     print(f"Error: Did not find block for source color {source_color} starting at global ({global_r}, {global_c})")
                 #     output_visited_mask[r_out, c_out] = True # Mark start cell visited anyway

            else:
                # If the cell inside is not a source color, just mark it visited if it's background
                # (Other colors inside that aren't source colors are ignored per the logic)
                if source_color == background_color:
                     output_visited_mask[r_out, c_out] = True


    # --- Step 6: Output ---
    output_grid = output_np.tolist()
    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
1 1 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
1 1 1 4 8 8 1 8 1 8 8 3 8 3 8 8 8 8 8 8 8 8 8 8
1 1 4 4 8 8 1 1 1 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 1 8 8 8 3 3 3 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 3 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
3 3 2 2 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 3 3 3 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 3 3 3 8 1 1 1 8 8 8 8 8 3 3 3 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 3 3 3 8 1 1 1 8 1 1 1 8 5 8 8
8 8 8 5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5 8 8
8 8 8 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 8 8
```
Expected Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 2 8 2 8 4 8 4 8 5
5 8 2 2 2 8 4 4 4 8 2 2 2 8 4 4 4 8 5
5 8 2 2 2 8 8 4 8 8 2 2 2 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 2 8 2 8 4 8 4 8 8 8 8 8 2 8 2 8 5
5 8 2 2 2 8 4 4 4 8 8 8 8 8 2 2 2 8 5
5 8 2 2 2 8 8 4 8 8 8 8 8 8 2 2 2 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 2 8 2 8 4 8 4 8 4 8 4 8 5
5 8 8 8 8 8 2 2 2 8 4 4 4 8 4 4 4 8 5
5 8 8 8 8 8 2 2 2 8 8 4 8 8 8 4 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Match: False
Pixels Off: 70
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 49.12280701754386

## Example 2:
Input:
```
2 2 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 4 1 1 2 2 2 2 1 3 3 3 3 1 1 6 6 6 6 1 1
2 2 4 4 1 1 2 2 2 2 1 1 3 3 1 1 1 6 6 1 1 1 1
1 1 1 1 1 1 2 1 2 2 1 3 3 3 3 1 1 6 6 1 1 1 1
3 3 8 8 1 1 2 1 2 2 1 3 1 1 3 1 1 6 6 6 6 1 1
3 3 3 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
3 3 8 8 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
6 6 7 7 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
6 6 6 7 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
6 6 7 7 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 2 2 2 2 1 6 6 6 6 1 3 3 3 3 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 3 3 3 3 1 2 2 2 2 1 6 6 6 6 1 5
1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
1 1 1 1 1 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 4 4 4 4 1 7 7 7 7 1 8 8 8 8 1 5
5 1 4 4 4 4 1 7 7 1 1 1 1 8 8 1 1 5
5 1 4 1 4 4 1 7 7 1 1 1 8 8 8 8 1 5
5 1 4 1 4 4 1 7 7 7 7 1 8 1 1 8 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 1 8 8 8 8 1 4 4 4 4 1 7 7 7 7 1 5
5 1 1 8 8 1 1 4 4 4 4 1 7 7 1 1 1 5
5 1 8 8 8 8 1 4 1 4 4 1 7 7 1 1 1 5
5 1 8 1 1 8 1 4 1 4 4 1 7 7 7 7 1 5
5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Transformed Output:
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5
5 4 1 1 4 4 4 7 7 7 7 4 8 8 8 8 4 5
5 4 1 1 1 4 4 7 7 4 4 4 4 8 8 4 4 5
5 4 1 1 4 4 4 7 7 4 4 4 8 8 8 8 4 5
5 4 4 4 4 4 4 7 7 7 7 4 8 4 4 8 4 5
5 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5
5 4 8 8 8 8 4 1 1 4 4 4 7 7 7 7 4 5
5 4 4 8 8 4 4 1 1 1 4 4 7 7 4 4 4 5
5 4 8 8 8 8 4 1 1 4 4 4 7 7 4 4 4 5
5 4 8 4 4 8 4 4 4 4 4 4 7 7 7 7 4 5
5 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```
Match: False
Pixels Off: 110
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 94.01709401709401
**General Assessment and Strategy**

The previous code failed significantly on both training examples. The primary issues appear to be:

1.  **Incorrect Template Identification:** The logic for finding "template blocks" (which define the output shape) was flawed and did not correctly identify these structures in the key area outside the main frame. The assumption about templates being composed of a source color and background was likely misapplied or the search function was incorrect.
2.  **Incorrect Mapping Derivation:** Consequently, the color mapping rules (`A -> B`) derived from adjacency were likely incorrect or incomplete, as they depend on correctly identifying the related blocks (solid source color vs. template shape).
3.  **Background Color Identification:** Errors in mapping can lead to errors in identifying the invariant background color.
4.  **Transformation Logic:** The core transformation step relies heavily on having the correct templates and mappings. With incorrect inputs, the output grid construction failed.

**Strategy:**

1.  **Re-examine the Key Area:** The key area outside the frame contains pairs of related objects. One object is a solid block of a single color (`Source Color`), and the other is a pattern composed of a different color (`Target Color`) mixed with the `Background Color`. This latter object is the `Template`.
2.  **Refine Identification:**
    *   Identify the `Background Color` first (most frequent non-frame color outside).
    *   Identify all `Solid Blocks` (single color `S`, not background, not frame) outside the frame.
    *   Identify all `Template Blocks` (contiguous components made of exactly one non-background/non-frame color `T` plus the `Background Color`) outside the frame.
    *   Establish `Mappings` and `Template Shapes`: Find pairs where a `Solid Block` (color `S`) is directly adjacent (sharing an edge) to a `Template Block` (containing color `T` and background). This defines the mapping `S -> T`. The shape of the `Template Block` is stored as the template associated with the source color `S`.
3.  **Refine Transformation:**
    *   Find solid blocks of `Source Color S` inside the frame.
    *   For each internal block `S` at `(r, c)`, retrieve the `Template Shape` associated with `S`.
    *   Create the `Output Pattern` by taking the `Template Shape`, replacing occurrences of `T` (the target color *from the template's definition*) with `T` (the mapped target color - they are the same in this revised logic) and occurrences of the background color with the background color. This step simplifies: just use the template shape directly after mapping `S` to `T`. Replace the original `S` color in the template with `T`.
    *   Place this `Output Pattern` onto the output grid at `(r, c)`.

**Gather Metrics**

Let's re-analyze the structure of the key area using code execution to verify the new hypotheses about solid blocks, template blocks, and mappings.

*code_execution:*

```python
import numpy as np
from collections import Counter, deque

# --- Data ---
# train_1 input
input_grid_1 = [[1, 1, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 4, 8, 8, 1, 8, 1, 8, 8, 3, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 4, 4, 8, 8, 1, 1, 1, 8, 8, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [3, 3, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [3, 3, 3, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [3, 3, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 3, 3, 3, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8], [8, 8, 8, 5, 8, 3, 3, 3, 8, 1, 1, 1, 8, 8, 8, 8, 8, 3, 3, 3, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 3, 3, 3, 8, 1, 1, 1, 8, 1, 1, 1, 8, 5, 8, 8], [8, 8, 8, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8], [8, 8, 8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8]]
# train_2 input
input_grid_2 = [[2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 4, 1, 1, 2, 2, 2, 2, 1, 3, 3, 3, 3, 1, 1, 6, 6, 6, 6, 1, 1], [2, 2, 4, 4, 1, 1, 2, 2, 2, 2, 1, 1, 3, 3, 1, 1, 1, 6, 6, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 3, 3, 3, 3, 1, 1, 6, 6, 1, 1, 1, 1], [3, 3, 8, 8, 1, 1, 2, 1, 2, 2, 1, 3, 1, 1, 3, 1, 1, 6, 6, 6, 6, 1, 1], [3, 3, 3, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [6, 6, 7, 7, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 7, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5], [6, 6, 7, 7, 1, 5, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 3, 3, 3, 3, 1, 5], [1, 1, 1, 1, 1, 5, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 3, 3, 3, 3, 1, 5], [1, 1, 1, 1, 1, 5, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 3, 3, 3, 3, 1, 5], [1, 1, 1, 1, 1, 5, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 3, 3, 3, 3, 1, 5], [1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5], [1, 1, 1, 1, 1, 5, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 5], [1, 1, 1, 1, 1, 5, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 5], [1, 1, 1, 1, 1, 5, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 1, 6, 6, 6, 6, 1, 5], [1, 1, 1, 1, 1, 5, 1, 3, 3, 3, 3, 1, 2, 2, 2, 2, 1, 6, 6 6, 6, 1, 5], [1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5], [1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

frame_color = 5

# --- Helper Functions (Adapted) ---

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:
    # (Same as previous version - assumed correct for now)
    coords = np.argwhere(grid_np == frame_color)
    if coords.size == 0: return None
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)
    on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \
                (coords[:, 1] == c_min) | (coords[:, 1] == c_max)
    if not np.all(on_border): return None
    if r_max > r_min + 1 and c_max > c_min + 1:
        inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]
        if np.any(inner_slice == frame_color): return None
    return (r_min, c_min, r_max, c_max)

def find_blocks_outside_frame(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int], frame_color: int):
    """Finds solid blocks and template blocks outside the frame."""
    rows, cols = grid_np.shape
    r_min, c_min, r_max, c_max = frame_bbox
    visited = np.zeros_like(grid_np, dtype=bool)
    
    # Mark frame area as visited to ignore it
    visited[r_min:r_max+1, c_min:c_max+1] = True
    
    solid_blocks = [] # {color, coords, r_min, c_min, r_max, c_max}
    template_blocks = [] # {target_color, background_color, coords, r_min, c_min, r_max, c_max, array}
    
    # First pass: Identify potential background color
    outside_colors_counter = Counter()
    for r in range(rows):
        for c in range(cols):
            if not visited[r,c]: # Outside frame
                 color = grid_np[r,c]
                 if color != frame_color: # Should always be true here
                     outside_colors_counter[color]+=1
    
    potential_background = -1
    if outside_colors_counter:
        # Simple most frequent for now, refinement needed later
        potential_background = outside_colors_counter.most_common(1)[0][0] 
    else:
        potential_background = 0 # Default

    # Second pass: BFS to find components outside frame
    for r_init in range(rows):
        for c_init in range(cols):
            if not visited[r_init, c_init]:
                component_coords = set()
                colors_in_component = set()
                q = deque([(r_init, c_init)])
                visited[r_init, c_init] = True
                r_min_comp, c_min_comp = r_init, c_init
                r_max_comp, c_max_comp = r_init, c_init
                
                while q:
                    r, c = q.popleft()
                    color = grid_np[r, c]
                    colors_in_component.add(color)
                    component_coords.add((r,c))
                    r_min_comp, c_min_comp = min(r_min_comp, r), min(c_min_comp, c)
                    r_max_comp, c_max_comp = max(r_max_comp, r), max(c_max_comp, c)

                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        # Check bounds and if outside frame (implicitly true if not visited)
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr, nc]: 
                             # Check if connected pixel has same color OR is potential background
                             # This definition might need adjustment based on examples
                             neighbor_color = grid_np[nr, nc]
                             # *** Crucial Decision: How are components defined? ***
                             # Option 1: Only same color (finds solid blocks easily)
                             # Option 2: Same color OR background (tries to find templates)
                             # Option 3: Any non-frame color (finds all connected stuff)
                             
                             # Let's try Option 3 first to categorize components, then analyze
                             visited[nr, nc] = True
                             q.append((nr, nc))
                             
                # --- Categorize the found component ---
                non_background_colors = colors_in_component - {potential_background}
                
                if len(non_background_colors) == 1:
                    single_color = list(non_background_colors)[0]
                    # Is it a solid block or a template block?
                    if len(colors_in_component) == 1: # Only the single color present
                         solid_blocks.append({
                             'color': single_color, 'coords': component_coords,
                             'r_min': r_min_comp, 'c_min': c_min_comp,
                             'r_max': r_max_comp, 'c_max': c_max_comp
                         })
                    elif len(colors_in_component) == 2 and potential_background in colors_in_component:
                         # Contains the single color and the background -> Template
                         template_arr = grid_np[r_min_comp:r_max_comp+1, c_min_comp:c_max_comp+1]
                         template_blocks.append({
                             'target_color': single_color, 
                             'background_color': potential_background, 
                             'coords': component_coords,
                             'r_min': r_min_comp, 'c_min': c_min_comp,
                             'r_max': r_max_comp, 'c_max': c_max_comp,
                             'array': template_arr
                         })
                    # else: More than 2 colors or just background -> ignore for mapping
                # else: More than 1 non-background color or only background -> ignore

    # --- Refine Background and Find Mappings ---
    mapped_colors = set()
    mappings = {} # source_color -> target_color
    templates = {} # source_color -> template_array

    # Collect colors involved in solid and template blocks
    solid_colors = {b['color'] for b in solid_blocks}
    target_colors = {b['target_color'] for b in template_blocks}
    
    # Find actual background: most frequent OUTSIDE color NOT in solid_colors or target_colors
    actual_background = -1
    sorted_outside = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    possible_mapping_colors = solid_colors | target_colors
    for color, count in sorted_outside:
        if color not in possible_mapping_colors:
             actual_background = color
             break
    if actual_background == -1: # Fallback if conflict
        actual_background = potential_background 
        
    # Re-filter template blocks if potential_background was wrong
    valid_template_blocks = [
        tb for tb in template_blocks if tb['background_color'] == actual_background
    ]
    
    # Find adjacency between SOLID (Source) and TEMPLATE (Target+BG) blocks
    for sb in solid_blocks:
        source_color = sb['color']
        if source_color in mappings: continue # Already mapped

        for tb in valid_template_blocks:
            target_color = tb['target_color']
            if target_color in mappings.values(): continue # Already mapped to

            # Check adjacency (simple check: bounding box proximity + 1 pixel check)
            # A more robust check looks at actual coordinate adjacency
            is_adjacent = False
            for r_s, c_s in sb['coords']:
                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                     nr, nc = r_s + dr, c_s + dc
                     if (nr, nc) in tb['coords']:
                         is_adjacent = True
                         break
                 if is_adjacent: break
                 
            if is_adjacent:
                 mappings[source_color] = target_color
                 templates[source_color] = tb['array']
                 mapped_colors.add(source_color)
                 mapped_colors.add(target_color)
                 break # Found mapping for this source color

    # Final check on background - ensure it wasn't accidentally part of a mapped pair
    if actual_background in mapped_colors:
        # This indicates an issue, try second most frequent non-mapped?
        print(f"Warning: Background color {actual_background} seems to be involved in mapping.")
        # Attempt to find a new background
        new_background = -1
        possible_mapping_colors = set(mappings.keys()) | set(mappings.values())
        for color, count in sorted_outside:
             if color not in possible_mapping_colors:
                 new_background = color
                 break
        if new_background != -1:
            print(f"Switching background to {new_background}")
            actual_background = new_background
        else:
            print("Could not find alternative background. Proceeding with caution.")


    return actual_background, solid_blocks, valid_template_blocks, mappings, templates


# --- Analysis ---
results = {}
for i, grid in enumerate([input_grid_1, input_grid_2]):
    name = f"train_{i+1}"
    print(f"--- Analyzing {name} ---")
    input_np = np.array(grid)
    frame_bbox = find_frame_bbox(input_np, frame_color)
    if frame_bbox:
        print(f"Frame: {frame_bbox}")
        try:
            background, solid, templates_found, mappings, templates_shapes = find_blocks_outside_frame(input_np, frame_bbox, frame_color)
            results[name] = {
                "background": background,
                "mappings": mappings,
                "templates": templates_shapes # {source: array}
            }
            print(f"Background: {background}")
            print(f"Mappings (Source -> Target): {mappings}")
            # print(f"Solid Blocks Found: {len(solid)}")
            # print(f"Template Blocks Found (Target+BG): {len(templates_found)}")
            print(f"Templates Assigned (Source -> Shape): { {k: v.shape for k,v in templates_shapes.items()} }")
            if len(mappings) != len(templates_shapes):
                 print("Warning: Mismatch between mappings found and templates assigned!")

        except Exception as e:
            print(f"Error analyzing {name}: {e}")
            results[name] = {"error": str(e)}
    else:
        print("No frame found.")
        results[name] = {"error": "No frame found"}

# print("\n--- Summary ---")
# print(results)

```


*code_execution_result:*
outcome: OUTCOME_OK

```
--- Analyzing train_1 ---
Frame: (np.int64(8), np.int64(3), np.int64(22), np.int64(21))
Background: 8
Mappings (Source -> Target): {3: 2, 1: 4}
Templates Assigned (Source -> Shape): {3: (3, 3), 1: (3, 3)}
--- Analyzing train_2 ---
Frame: (np.int64(8), np.int64(5), np.int64(20), np.int64(22))
Background: 1
Mappings (Source -> Target): {2: 4, 3: 8, 6: 7}
Templates Assigned (Source -> Shape): {2: (4, 4), 3: (4, 4), 6: (4, 4)}
```

**Metrics Analysis:**

The refined analysis using `code_execution` successfully identified the key components according to the revised hypothesis:

*   **`train_1`**:
    *   Frame: Correctly identified.
    *   Background: Correctly identified as `8` (azure).
    *   Mappings: Correctly identified `3 -> 2` and `1 -> 4`.
    *   Templates: Correctly associated source colors `3` and `1` with template shapes extracted from the key area. Both templates are 3x3.
*   **`train_2`**:
    *   Frame: Correctly identified.
    *   Background: Correctly identified as `1` (blue).
    *   Mappings: Correctly identified `2 -> 4`, `3 -> 8`, `6 -> 7`.
    *   Templates: Correctly associated source colors `2`, `3`, `6` with template shapes. All templates are 4x4.

This confirms the revised understanding of the relationship between solid blocks (source color), template blocks (target color + background), adjacency, and the resulting mapping and template shape.

**YAML Facts**


```yaml
elements:
  - object: Frame
    properties:
      - color: gray (5)
      - shape: hollow rectangle
      - role: defines the region of interest (ROI) for cropping and output

  - object: KeyArea
    properties:
      - location: outside the Frame's bounding box
      - contains: KeyPairs, BackgroundPixels

  - object: KeyPair
    properties:
      - structure: consists of two adjacent blocks - a SolidBlock and a TemplateBlock
      - role: defines a transformation rule (SolidBlock Color -> TemplateBlock Target Color) and the output shape (TemplateBlock shape)
      - location: within KeyArea

  - object: SolidBlock
    properties:
      - structure: contiguous block of a single color ('SourceColor')
      - role: represents the input color/object identifier in a KeyPair
      - location: within KeyArea, adjacent to a TemplateBlock

  - object: TemplateBlock
    properties:
      - structure: contiguous component composed ONLY of a 'TargetColor' and the 'BackgroundColor'
      - shape: specific pattern defining the output object's shape and internal structure
      - role: represents the output shape and target color identifier in a KeyPair
      - location: within KeyArea, adjacent to a SolidBlock

  - object: SourceBlockInstance
    properties:
      - structure: contiguous block of a single 'SourceColor' (matching a color from a SolidBlock in KeyArea)
      - location: inside the Frame
      - role: input object instance to be transformed

  - object: BackgroundColor
    properties:
      - color: varies by task (most frequent color in KeyArea excluding frame, SourceColors, and TargetColors)
      - role: invariant color, used within TemplateBlocks and fills empty space in the output

actions:
  - name: locate_frame
    input: input_grid
    output: bounding_box_of_gray_frame

  - name: analyze_key_area
    input: input_grid, frame_bounding_box
    process:
      - Identify potential BackgroundColor (most frequent outside, non-frame).
      - Find all SolidBlocks outside frame.
      - Find all TemplateBlocks outside frame (TargetColor + BackgroundColor).
      - Identify adjacent (SolidBlock, TemplateBlock) pairs.
      - For each pair (Solid S, Template T): record mapping S_color -> T_target_color, store T_shape as template[S_color].
      - Refine/Confirm BackgroundColor (most frequent outside non-frame, non-S_color, non-T_target_color). Re-validate templates if background changes.
    output: dictionary_of_mappings {S_color: T_target_color, ...}, BackgroundColor, dictionary_of_templates {S_color: template_array, ...}

  - name: initialize_output
    input: frame_bounding_box, BackgroundColor
    output: output_grid (filled with BackgroundColor, sized by frame)

  - name: copy_frame_to_output
    input: input_grid, frame_bounding_box, output_grid
    process: copy gray (5) pixels from input frame location to output grid.
    output: updated_output_grid

  - name: locate_source_block_instances
    input: input_grid, frame_bounding_box, source_colors (keys from mappings)
    output: list_of_source_instances [{color, r_min, c_min, coords}, ...] (coordinates relative to input_grid)

  - name: apply_transformations
    input: output_grid, list_of_source_instances, dictionary_of_templates, dictionary_of_mappings, BackgroundColor, frame_bbox(r_min, c_min)
    process:
      - For each SourceBlockInstance (color S at r_min_abs, c_min_abs):
          - Get the TemplateBlock array 'T_shape' for color S.
          - Get the TargetColor 'T_color' for color S from mappings.
          - Calculate the top-left placement coordinate in output_grid: r_rel = r_min_abs - r_min_frame, c_rel = c_min_abs - c_min_frame.
          - Iterate through T_shape (height h, width w):
              - For pixel at (r_t, c_t) in T_shape:
                  - Determine output pixel color: if T_shape[r_t, c_t] == T_color (the target color *in* the template), use T_color; if T_shape[r_t, c_t] == BackgroundColor, use BackgroundColor.
                  - Calculate output coordinate: out_r = r_rel + r_t, out_c = c_rel + c_t.
                  - If (out_r, out_c) is within output_grid bounds and not part of the frame: place the determined color.
    output: final_output_grid

relationships:
  - The Frame defines the output dimensions and boundary.
  - KeyPairs in the KeyArea define the transformation rules.
  - A SolidBlock's color maps to its adjacent TemplateBlock's target color.
  - A SolidBlock's color determines which TemplateBlock shape to use for transformation.
  - BackgroundColor is invariant and part of TemplateBlocks.
  - SourceBlockInstances inside the frame trigger the application of the transformation rule defined by their color.
```


**Natural Language Program**

1.  **Find the Frame**: Locate the hollow rectangular boundary of gray (5) pixels in the input grid. Determine its bounding box coordinates (`r_min`, `c_min`, `r_max`, `c_max`). If no valid frame is found, return the input grid unchanged.
2.  **Analyze Key Area (Outside Frame)**:
    *   Identify the most frequent color outside the frame area, excluding gray (5), as the initial candidate `BackgroundColor`.
    *   Find all `Solid Blocks`: contiguous blocks outside the frame composed of a single color (`SourceColor`), which is not the candidate `BackgroundColor` or gray (5).
    *   Find all `Template Blocks`: contiguous components outside the frame composed exclusively of the candidate `BackgroundColor` and exactly one other color (`TargetColor`), which is not gray (5). Store the array (shape and content) of each `Template Block`.
    *   Identify `Key Pairs`: Find instances where a `Solid Block` (color `S`) is directly adjacent (shares an edge) to a `Template Block` (containing target color `T`).
    *   Establish `Mappings` and `Template Shapes`: For each adjacent pair found, record a mapping rule `S -> T` and store the array of the corresponding `Template Block` as the template shape for source color `S`.
    *   Refine `BackgroundColor`: Confirm the `BackgroundColor` is the most frequent color outside the frame that is not gray (5) and is not any `SourceColor` (`S`) or `TargetColor` (`T`) involved in the mappings. If the initial candidate was incorrect, update the `BackgroundColor` and re-validate the `Template Blocks` and `Mappings`.
3.  **Initialize Output Grid**: Create a new grid (`output_grid`) with dimensions matching the frame's bounding box (`height = r_max - r_min + 1`, `width = c_max - c_min + 1`). Fill this grid entirely with the final `BackgroundColor`.
4.  **Copy Frame**: Copy the gray (5) pixels from the input grid's frame location to the corresponding positions in the `output_grid`.
5.  **Transform Instances Inside Frame**:
    *   Scan the input grid *inside* the frame boundaries (from `r_min+1` to `r_max-1`, `c_min+1` to `c_max-1`).
    *   Identify all contiguous blocks composed of a single `SourceColor` (`S`) for which a mapping rule exists. Keep track of visited pixels to process each block only once.
    *   For each such `Source Block Instance` found, note its top-left absolute coordinate (`r_abs`, `c_abs`).
    *   Retrieve the `Template Shape` (an array) associated with its color `S`.
    *   Retrieve the `TargetColor` (`T`) from the mapping `S -> T`.
    *   Calculate the top-left placement coordinate relative to the output grid: `r_rel = r_abs - r_min`, `c_rel = c_abs - c_min`.
    *   Iterate through each pixel `(r_t, c_t)` of the `Template Shape`:
        *   Get the color `template_pixel_color` from the `Template Shape` at `(r_t, c_t)`.
        *   Determine the `output_color`: if `template_pixel_color` is the `TargetColor` (`T`), the `output_color` is `T`; if `template_pixel_color` is the `BackgroundColor`, the `output_color` is `BackgroundColor`.
        *   Calculate the target coordinate in the `output_grid`: `out_r = r_rel + r_t`, `out_c = c_rel + c_t`.
        *   If `(out_r, out_c)` is within the bounds of `output_grid` and is not already occupied by a gray (5) frame pixel, place the `output_color` at `output_grid[out_r, out_c]`.
6.  **Return Output**: The final `output_grid` is the result.
```python
import numpy as np
from collections import Counter, deque
from typing import List, Dict, Tuple, Set, Optional

"""
Transforms an input grid based on rules derived from a key area outside a main frame.

The transformation involves:
1. Finding a hollow rectangular frame of gray (5) pixels.
2. Analyzing the area outside the frame (KeyArea) to find:
    a. Solid blocks of unique 'SourceColor'.
    b. Template blocks composed of a 'TargetColor' and the 'BackgroundColor'.
    c. Adjacency between Solid blocks and Template blocks to establish:
        i. Mappings: SourceColor -> TargetColor
        ii. Template Shapes: The array shape/content associated with each SourceColor.
    d. The invariant 'BackgroundColor' (most frequent outside color not part of the frame or mapping pairs).
3. Initializing an output grid based on the frame's dimensions, filled with the BackgroundColor.
4. Copying the gray frame pixels to the output grid.
5. Finding instances of SourceColor blocks within the input frame.
6. For each Source Block Instance found inside the frame:
    a. Retrieve its associated Template Shape and TargetColor using the mapping.
    b. "Paint" the Template Shape onto the output grid at the Source Block Instance's top-left position, replacing the template's original TargetColor pixels with the mapped TargetColor and the template's BackgroundColor pixels with the BackgroundColor.
7. Returning the final output grid.
"""

# --- Helper Functions ---

def find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> Optional[Tuple[int, int, int, int]]:
    """
    Finds the bounding box coords (min_r, min_c, max_r, max_c) of the largest hollow rectangle made of frame_color.
    Returns None if no valid frame is found.
    """
    coords = np.argwhere(grid_np == frame_color)
    if coords.size == 0:
        return None
        
    r_min, c_min = coords.min(axis=0)
    r_max, c_max = coords.max(axis=0)

    # Check if frame is too small to be hollow
    if r_max < r_min + 2 or c_max < c_min + 2:
         # Handle thin "frames" - are they allowed? Assume requires hollow for now.
         # Basic check: all coords must be on border
         on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \
                     (coords[:, 1] == c_min) | (coords[:, 1] == c_max)
         if np.all(on_border):
             # Check if it's just a line or corner, needs at least 4 pixels for a minimal frame?
             # A simple line might be ambiguous. For simplicity, require a hollow potential.
             # Let's assume a valid frame must have potential for interior (size >= 3x3)
             # Or adjust if examples show line frames. Sticking to hollow assumption.
             if r_max >= r_min + 2 and c_max >= c_min + 2: # Potential interior
                 pass # Check below
             else:
                 return None # Too small to be hollow

    # Verify all frame_color pixels are on the border
    on_border_check = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \
                      (coords[:, 1] == c_min) | (coords[:, 1] == c_max)
    if not np.all(on_border_check):
        return None # Pixels with frame color exist *not* on the border defined by min/max

    # Verify the inside is not the frame color (ensure it's hollow)
    inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]
    if np.any(inner_slice == frame_color):
        return None # Frame color found inside, not a simple hollow frame

    return (r_min, c_min, r_max, c_max)


def find_contiguous_blocks(grid_np: np.ndarray, 
                           allowed_colors: Set[int],
                           search_bounds: Optional[Tuple[int, int, int, int]] = None,
                           start_coord: Optional[Tuple[int, int]] = None,
                           ignore_mask: Optional[np.ndarray] = None) -> List[Dict]:
    """
    Finds contiguous blocks of any single color within allowed_colors, optionally within bounds.
    
    Args:
        grid_np: The grid to search.
        allowed_colors: Set of colors to form blocks.
        search_bounds: Optional (r0, c0, r1, c1) exclusive bounds for search.
        start_coord: If provided, only find the block containing this coordinate.
        ignore_mask: Optional boolean array where True means ignore this cell.

    Returns:
        List of dictionaries, each: {'color', 'coords', 'r_min', 'c_min', 'r_max', 'c_max'}
    """
    rows, cols = grid_np.shape
    if search_bounds:
        r_start, c_start, r_end, c_end = search_bounds
    else:
        r_start, c_start, r_end, c_end = 0, 0, rows, cols

    visited = np.zeros_like(grid_np, dtype=bool)
    if ignore_mask is not None:
        visited |= ignore_mask # Pre-mark ignored cells as visited

    blocks = []
    
    search_queue = deque()
    if start_coord:
        # Check if start_coord is valid and within bounds
        sr, sc = start_coord
        if r_start <= sr < r_end and c_start <= sc < c_end and not visited[sr, sc]:
             search_queue.append(start_coord)
    else:
        # Add all valid starting points within bounds
        for r in range(r_start, r_end):
             for c in range(c_start, c_end):
                 if not visited[r, c] and grid_np[r, c] in allowed_colors:
                     search_queue.append((r, c))

    processed_starts = set() # Avoid redundant BFS starts if queue has duplicates initially

    while search_queue:
        r_init, c_init = search_queue.popleft()
        
        if visited[r_init, c_init] or (r_init, c_init) in processed_starts:
            continue
            
        color = grid_np[r_init, c_init]
        if color not in allowed_colors: # Should not happen if queue is built correctly
            continue

        processed_starts.add((r_init, c_init)) # Mark this starting cell as processed for queue

        block_coords = set()
        q = deque([(r_init, c_init)])
        visited[r_init, c_init] = True
        r_min_blk, c_min_blk = r_init, c_init
        r_max_blk, c_max_blk = r_init, c_init
        
        while q:
            r, c = q.popleft()
            block_coords.add((r, c))
            r_min_blk, c_min_blk = min(r_min_blk, r), min(c_min_blk, c)
            r_max_blk, c_max_blk = max(r_max_blk, r), max(c_max_blk, c)

            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                # Check grid bounds and search bounds
                if 0 <= nr < rows and 0 <= nc < cols and \
                   r_start <= nr < r_end and c_start <= nc < c_end and \
                   not visited[nr, nc] and grid_np[nr, nc] == color:
                    visited[nr, nc] = True
                    q.append((nr, nc))

        blocks.append({
            'color': color, 
            'coords': block_coords,
            'r_min': r_min_blk, 'c_min': c_min_blk, 
            'r_max': r_max_blk, 'c_max': c_max_blk
        })
        
        # If we were searching for a specific start coord's block, we found it.
        if start_coord:
            break 
                 
    return blocks


def analyze_key_area(grid_np: np.ndarray, frame_bbox: Tuple[int, int, int, int], frame_color: int) -> Optional[Tuple[Dict[int, int], int, Dict[int, np.ndarray]]]:
    """
    Analyzes the area outside the frame to find mappings, background, and templates.

    Returns:
        Tuple (mappings, background_color, templates) or None if analysis fails.
        mappings: {source_color: target_color}
        background_color: int
        templates: {source_color: template_array}
    """
    rows, cols = grid_np.shape
    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox
    
    # --- Create Mask for Key Area (Outside Frame) ---
    key_area_mask = np.ones_like(grid_np, dtype=bool)
    key_area_mask[r_min_f:r_max_f + 1, c_min_f:c_max_f + 1] = False
    
    # --- Initial Background Color Guess ---
    outside_colors_counter = Counter()
    key_area_coords = np.argwhere(key_area_mask)
    for r, c in key_area_coords:
        color = grid_np[r, c]
        if color != frame_color: # Should always be true if mask is correct
            outside_colors_counter[color] += 1
            
    if not outside_colors_counter:
        print("Warning: No non-frame colors found outside the frame.")
        return None # Cannot determine rules

    # Most frequent color outside is potential background
    # Sort by frequency (desc), then color value (asc) for tie-breaking
    sorted_outside_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))
    potential_background = sorted_outside_colors[0][0]

    # --- Find Components (Solid & Template Candidates) Outside Frame ---
    visited_key = np.zeros_like(grid_np, dtype=bool)
    visited_key[~key_area_mask] = True # Mark frame and inside as visited

    solid_blocks = []
    template_candidates = [] # Store potential template blocks before background is finalized

    for r_init, c_init in key_area_coords:
         if not visited_key[r_init, c_init]:
            component_coords = set()
            colors_in_component = set()
            q = deque([(r_init, c_init)])
            visited_key[r_init, c_init] = True
            r_min_comp, c_min_comp = r_init, c_init
            r_max_comp, c_max_comp = r_init, c_init

            while q:
                r, c = q.popleft()
                color = grid_np[r, c]
                # Check if color is frame color - should not happen if mask is right
                if color == frame_color: continue 
                
                colors_in_component.add(color)
                component_coords.add((r,c))
                r_min_comp, c_min_comp = min(r_min_comp, r), min(c_min_comp, c)
                r_max_comp, c_max_comp = max(r_max_comp, r), max(c_max_comp, c)

                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    # Check bounds and if it's in the key area (i.e., not visited)
                    if 0 <= nr < rows and 0 <= nc < cols and not visited_key[nr, nc]:
                        # Connect components regardless of color initially
                        visited_key[nr, nc] = True
                        q.append((nr, nc))

            # --- Categorize Component ---
            non_background_candidates = colors_in_component - {potential_background}
            
            if len(non_background_candidates) == 1:
                single_color = list(non_background_candidates)[0]
                if len(colors_in_component) == 1: # Solid Block
                    solid_blocks.append({
                        'color': single_color, 'coords': component_coords,
                        'r_min': r_min_comp, 'c_min': c_min_comp,
                        'r_max': r_max_comp, 'c_max': c_max_comp
                    })
                elif len(colors_in_component) == 2 and potential_background in colors_in_component:
                     # Potential Template Block
                     template_arr = grid_np[r_min_comp:r_max_comp+1, c_min_comp:c_max_comp+1].copy()
                     template_candidates.append({
                         'target_color': single_color, 
                         'potential_bg': potential_background,
                         'coords': component_coords,
                         'r_min': r_min_comp, 'c_min': c_min_comp,
                         'r_max': r_max_comp, 'c_max': c_max_comp,
                         'array': template_arr
                     })
            # else: Mixed block or just background - ignore for mapping

    # --- Determine Final Background & Mappings ---
    solid_colors = {b['color'] for b in solid_blocks}
    target_colors = {b['target_color'] for b in template_candidates}
    possible_mapping_colors = solid_colors | target_colors

    background_color = -1
    for color, count in sorted_outside_colors:
        if color not in possible_mapping_colors:
             background_color = color
             break
    if background_color == -1:
         # Fallback: Use the initial potential background if all colors were involved in pairs
         background_color = potential_background
         # print(f"Warning: All outside colors involved in potential pairs. Using initial guess {background_color} as background.")

    # Filter template candidates based on the final background color
    valid_template_blocks = [
        tc for tc in template_candidates if tc['potential_bg'] == background_color
    ]
    
    # Find mappings by adjacency
    mappings = {}
    templates = {}
    mapped_target_colors = set() # Track target colors already used in a mapping

    for sb in solid_blocks:
        source_color = sb['color']
        if source_color in mappings: continue 

        best_match_template = None
        
        for tb in valid_template_blocks:
            target_color = tb['target_color']
            # Ensure this target color hasn't been mapped *to* already
            if target_color in mapped_target_colors: continue 

            # Check adjacency
            is_adjacent = False
            for r_s, c_s in sb['coords']:
                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                     nr, nc = r_s + dr, c_s + dc
                     if (nr, nc) in tb['coords']:
                         is_adjacent = True
                         break
                 if is_adjacent: break
            
            if is_adjacent:
                # Found a potential match. Since a source might be adjacent to multiple
                # things, maybe store first match? Or require unique pairings?
                # Assume first adjacent match is correct for now.
                best_match_template = tb
                break 

        if best_match_template:
            target_color = best_match_template['target_color']
            mappings[source_color] = target_color
            templates[source_color] = best_match_template['array']
            mapped_target_colors.add(target_color) # Mark target as used

    if not mappings:
        # print("Warning: No mappings found between solid and template blocks.")
        return None # Cannot proceed

    return mappings, background_color, templates


# --- Main Transformation Function ---

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the frame-key-template transformation.
    """
    input_np = np.array(input_grid, dtype=int)
    frame_color = 5

    # --- Step 1: Find the Frame ---
    frame_bbox = find_frame_bbox(input_np, frame_color)
    if frame_bbox is None:
        # print("No valid frame found. Returning input grid.")
        return input_grid
    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox

    # --- Step 2: Analyze Key Area ---
    analysis_result = analyze_key_area(input_np, frame_bbox, frame_color)
    if analysis_result is None:
         # print("Failed to analyze key area. Returning input grid.")
         return input_grid # Or handle error differently
    mappings, background_color, templates = analysis_result
    
    if not mappings or not templates:
        # print("Analysis incomplete (no mappings or templates). Returning input grid.")
        return input_grid

    # --- Step 3: Initialize Output Grid ---
    output_h = r_max_f - r_min_f + 1
    output_w = c_max_f - c_min_f + 1
    output_np = np.full((output_h, output_w), background_color, dtype=int)

    # --- Step 4: Copy Frame ---
    # Get coordinates relative to the frame bounding box start
    frame_coords_relative = np.argwhere(input_np[r_min_f:r_max_f+1, c_min_f:c_max_f+1] == frame_color)
    for r_rel, c_rel in frame_coords_relative:
        output_np[r_rel, c_rel] = frame_color

    # --- Step 5: Transform Instances Inside Frame ---
    source_colors = set(mappings.keys())
    # Define search bounds for inside the frame (exclusive of border)
    inner_bounds = (r_min_f + 1, c_min_f + 1, r_max_f, c_max_f)
    # Create ignore mask for frame pixels within the output grid dimensions
    output_ignore_mask = (output_np == frame_color)

    # Find all source blocks within the inner bounds
    source_instances = find_contiguous_blocks(input_np, source_colors, search_bounds=inner_bounds)

    processed_output_cells = output_ignore_mask.copy() # Track painted cells

    for instance in source_instances:
        source_color = instance['color']
        # Use the top-left corner of the block instance for placement
        r_abs = instance['r_min']
        c_abs = instance['c_min']
        
        if source_color in templates:
            template_shape = templates[source_color]
            target_color = mappings[source_color]
            t_h, t_w = template_shape.shape

            # Calculate placement coords relative to output grid
            r_rel = r_abs - r_min_f
            c_rel = c_abs - c_min_f

            # Apply the template
            for r_t in range(t_h):
                for c_t in range(t_w):
                    out_r = r_rel + r_t
                    out_c = c_rel + c_t

                    # Check bounds of output grid
                    if 0 <= out_r < output_h and 0 <= out_c < output_w:
                        # Check if this cell was already painted or is frame
                        if processed_output_cells[out_r, out_c]:
                            continue

                        template_pixel_color = template_shape[r_t, c_t]
                        output_color = -1 # Undefined

                        # Determine output color based on template content
                        # Important: Compare template_pixel_color with the TARGET color 
                        # found *in the template* during analysis, not the mapped target color.
                        # However, our analyze_key_area stores the template array directly.
                        # So, we need to know which color *in the template array* corresponds to the TARGET.
                        # Assumption: the template contains only background_color and the target_color from the mapping.
                        if template_pixel_color == target_color:
                             output_color = target_color
                        elif template_pixel_color == background_color:
                             output_color = background_color
                        # Else: template contains unexpected color? Skip painting this pixel.
                        
                        if output_color != -1:
                             output_np[out_r, out_c] = output_color
                             processed_output_cells[out_r, out_c] = True # Mark as painted
        #else: No template found for this source color, skipped.


    # --- Step 6: Return Output ---
    output_grid = output_np.tolist()
    return output_grid
```
