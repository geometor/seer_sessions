{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying a rectangular gray (5) frame.\n2. Analyzing the area outside the frame to find:\n    a. Color mapping rules (A -> B) based on adjacent blocks.\n    b. The invariant background color (most frequent outside color not involved in mappings or the frame).\n    c. Template blocks for each source color 'A', composed of color 'A' and the background color.\n3. Creating an output grid based on the frame size, initialized with the background color.\n4. Copying the gray frame to the output.\n5. Finding contiguous blocks of source colors 'A' inside the frame.\n6. For each source block found, retrieving its corresponding template, substituting color 'A' with 'B', \n   and drawing this transformed template onto the output grid at the source block's location.\n\"\"\"\n\ndef find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> tuple[int, int, int, int] | None:\n    \"\"\"\n    Finds the bounding box coordinates (min_row, min_col, max_row, max_col) \n    of the largest rectangular frame made of frame_color.\n    Checks if the identified structure forms a hollow rectangle.\n    Returns None if no such frame is found.\n    \"\"\"\n    coords = np.argwhere(grid_np == frame_color)\n    if coords.size == 0:\n        return None\n        \n    r_min, c_min = coords.min(axis=0)\n    r_max, c_max = coords.max(axis=0)\n\n    # Verify it's a hollow rectangle\n    # All frame_color pixels must be on the border\n    on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \\\n                (coords[:, 1] == c_min) | (coords[:, 1] == c_max)\n    if not np.all(on_border):\n        # Could potentially search for smaller frames, but assume largest for now\n        return None \n\n    # Check if the inside is not the frame color (ensure it's hollow)\n    # Avoid checking if frame is only 1 or 2 pixels wide/high\n    if r_max > r_min + 1 and c_max > c_min + 1:\n        inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]\n        if np.any(inner_slice == frame_color):\n            return None # Frame color found inside, not a simple hollow frame\n\n    return (r_min, c_min, r_max, c_max)\n\ndef find_contiguous_blocks(grid_np: np.ndarray, target_colors: set[int], start_coord: tuple[int, int] | None = None) -> list[dict]:\n    \"\"\"\n    Finds all contiguous blocks of any single color within target_colors.\n    Returns a list of dictionaries, each containing 'color', 'coords' (set), \n    'r_min', 'c_min', 'r_max', 'c_max'.\n    If start_coord is provided, only finds the block containing that coordinate.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    blocks = []\n    \n    search_coords = []\n    if start_coord:\n        search_coords = [start_coord]\n    else:\n        # Generate all coordinates if no start_coord is given\n        search_coords = [(r, c) for r in range(rows) for c in range(cols)]\n\n    for r_init, c_init in search_coords:\n        color = grid_np[r_init, c_init]\n        if color in target_colors and not visited[r_init, c_init]:\n            block_coords = set()\n            q = deque([(r_init, c_init)])\n            visited[r_init, c_init] = True\n            r_min, c_min = r_init, c_init\n            r_max, c_max = r_init, c_init\n            \n            while q:\n                r, c = q.popleft()\n                block_coords.add((r, c))\n                r_min, c_min = min(r_min, r), min(c_min, c)\n                r_max, c_max = max(r_max, r), max(c_max, c)\n\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       not visited[nr, nc] and grid_np[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n\n            blocks.append({\n                'color': color, \n                'coords': block_coords,\n                'r_min': r_min, 'c_min': c_min, \n                'r_max': r_max, 'c_max': c_max\n            })\n            # If we started with a specific coordinate, we found its block, so break\n            if start_coord:\n                 break \n                 \n    return blocks\n\ndef find_template_blocks(grid_np: np.ndarray, source_colors: set[int], background_color: int) -> dict[int, np.ndarray]:\n    \"\"\"\n    Finds template blocks outside the frame. A template block for source color 'A' \n    is a contiguous component made ONLY of color 'A' and the background_color, \n    containing at least one pixel of color 'A'.\n    Returns a dictionary {source_color: template_array}.\n    Assumes the relevant template is the first one found for each source color.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    templates = {}\n    allowed_colors = source_colors | {background_color}\n\n    for r_init in range(rows):\n        for c_init in range(cols):\n            # Start BFS from a source color pixel that hasn't been visited\n            start_color = grid_np[r_init, c_init]\n            if start_color in source_colors and not visited[r_init, c_init] and start_color not in templates:\n                \n                component_coords = set()\n                q = deque([(r_init, c_init)])\n                visited[r_init, c_init] = True\n                r_min, c_min = r_init, c_init\n                r_max, c_max = r_init, c_init\n                found_source_color = False \n                \n                while q:\n                    r, c = q.popleft()\n                    current_color = grid_np[r, c]\n                    \n                    # Check if the component contains invalid colors\n                    if current_color not in allowed_colors:\n                        # Mark all visited in this path as invalid? Difficult.\n                        # Easier to validate after BFS finds the full component.\n                        # For now, just skip adding this coord and continue BFS elsewhere.\n                        # A better approach might be needed if templates intermingle badly.\n                         continue \n\n                    component_coords.add((r, c))\n                    if current_color == start_color:\n                        found_source_color = True\n                    \n                    r_min, c_min = min(r_min, r), min(c_min, c)\n                    r_max, c_max = max(r_max, r), max(c_max, c)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] in allowed_colors:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Post-BFS validation: Ensure component only has start_color & background\n                is_valid_template = True\n                if not found_source_color: # Should not happen if start_color is source\n                    is_valid_template = False\n                else:\n                    for r_comp, c_comp in component_coords:\n                        if grid_np[r_comp, c_comp] not in [start_color, background_color]:\n                            is_valid_template = False\n                            break\n                \n                if is_valid_template:\n                    # Extract the bounding box as the template\n                    template_arr = grid_np[r_min:r_max + 1, c_min:c_max + 1]\n                    templates[start_color] = template_arr\n                    # Optimization: If we found templates for all source colors, stop.\n                    if len(templates) == len(source_colors):\n                        break\n            \n            # If we found templates for all source colors, stop outer loop.\n            if len(templates) == len(source_colors):\n                 break\n                        \n    return templates\n\n\ndef analyze_key_area(grid_np: np.ndarray, frame_bbox: tuple[int, int, int, int], frame_color: int) -> tuple[dict[int, int], int, dict[int, np.ndarray]]:\n    \"\"\"\n    Analyzes the area outside the frame to find mappings, background, and templates.\n    \"\"\"\n    rows, cols = grid_np.shape\n    r_min, c_min, r_max, c_max = frame_bbox\n\n    outside_colors_counter = Counter()\n    outside_coords_map = {} # Store coords for each color\n    key_area_mask = np.ones_like(grid_np, dtype=bool)\n    key_area_mask[r_min:r_max+1, c_min:c_max+1] = False # Mask out frame area\n\n    for r in range(rows):\n        for c in range(cols):\n            if key_area_mask[r, c]: # If outside frame\n                color = grid_np[r, c]\n                if color != frame_color:\n                    outside_colors_counter[color] += 1\n                    if color not in outside_coords_map:\n                        outside_coords_map[color] = []\n                    outside_coords_map[color].append((r,c))\n\n    # --- Find Mappings using block adjacency ---\n    mappings = {}\n    mapped_colors = set()\n    potential_keys = set(outside_colors_counter.keys())\n    \n    # Find blocks for all potential key colors outside the frame\n    outside_blocks_map = {} # {color: [block_info, ...]}\n    for color in potential_keys:\n        if color in outside_coords_map:\n            # Create a temporary grid containing only this color and -1 elsewhere\n            temp_grid = np.full_like(grid_np, -1)\n            for r, c in outside_coords_map[color]:\n                 temp_grid[r, c] = color\n            \n            # Find blocks of this color in the temp grid (ensures only outside blocks)\n            blocks = find_contiguous_blocks(temp_grid, {color})\n            if blocks:\n                 outside_blocks_map[color] = blocks\n\n    # Check adjacency between blocks of different colors\n    colors_present = list(outside_blocks_map.keys())\n    for i in range(len(colors_present)):\n        color_a = colors_present[i]\n        if color_a in mapped_colors: continue # Already used as key or value\n\n        for j in range(i + 1, len(colors_present)):\n            color_b = colors_present[j]\n            if color_b in mapped_colors: continue\n\n            # Check if any block of color_a is adjacent to any block of color_b\n            found_adjacency = False\n            for block_a in outside_blocks_map[color_a]:\n                coords_a = block_a['coords']\n                for block_b in outside_blocks_map[color_b]:\n                    coords_b = block_b['coords']\n                    \n                    # Check horizontal/vertical adjacency\n                    for r_a, c_a in coords_a:\n                        is_adjacent = False\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = r_a + dr, c_a + dc\n                            if (nr, nc) in coords_b:\n                                is_adjacent = True\n                                break\n                        if is_adjacent:\n                            found_adjacency = True\n                            break\n                if found_adjacency:\n                    break\n            \n            if found_adjacency:\n                 # Found an adjacent pair (A, B). Need to decide direction.\n                 # Heuristic: Assume the block appearing \"first\" (min row, then min col) is the key.\n                 a_min_r = min(b['r_min'] for b in outside_blocks_map[color_a])\n                 a_min_c = min(b['c_min'] for b in outside_blocks_map[color_a] if b['r_min'] == a_min_r)\n                 b_min_r = min(b['r_min'] for b in outside_blocks_map[color_b])\n                 b_min_c = min(b['c_min'] for b in outside_blocks_map[color_b] if b['r_min'] == b_min_r)\n\n                 key_color, val_color = -1, -1\n                 if (a_min_r < b_min_r) or (a_min_r == b_min_r and a_min_c < b_min_c):\n                      key_color, val_color = color_a, color_b\n                 else:\n                      key_color, val_color = color_b, color_a\n                      \n                 if key_color not in mappings:\n                    mappings[key_color] = val_color\n                    mapped_colors.add(key_color)\n                    mapped_colors.add(val_color)\n                    # Break inner loops once a mapping is found for color_a?\n                    # Let's assume one mapping pair per distinct visual pair.\n                 \n                 # Avoid mapping the same colors again\n                 break # Move to the next color_a\n\n    # --- Determine Background Color ---\n    background_color = -1\n    sorted_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))\n    for color, count in sorted_colors:\n        if color not in mapped_colors:\n            background_color = color\n            break\n            \n    if background_color == -1: # Fallback if all outside colors are mapped\n        # Check inside frame (excluding border) for most frequent non-mapped, non-frame color\n        if r_max > r_min and c_max > c_min:\n            inside_counter = Counter()\n            for r in range(r_min + 1, r_max):\n                for c in range(c_min + 1, c_max):\n                    color = grid_np[r, c]\n                    if color != frame_color and color not in mapped_colors:\n                        inside_counter[color] += 1\n            sorted_inside = sorted(inside_counter.items(), key=lambda item: (-item[1], item[0]))\n            if sorted_inside:\n                background_color = sorted_inside[0][0]\n            else:\n                background_color = 0 # Ultimate fallback\n        else:\n             background_color = 0 # Frame too small for interior\n\n\n    # --- Find Templates ---\n    source_colors = set(mappings.keys())\n    # Create a copy of the grid where the frame area is marked invalid for template search\n    key_area_grid = grid_np.copy()\n    # Mark frame and inside with a value not in allowed_colors for find_template_blocks\n    invalid_marker = -99 \n    key_area_grid[r_min:r_max+1, c_min:c_max+1] = invalid_marker\n    \n    templates = find_template_blocks(key_area_grid, source_colors, background_color)\n    \n    # Validation: Ensure templates were found for all source colors\n    if len(templates) != len(source_colors):\n         print(f\"Warning: Could not find templates for all source colors. Found: {templates.keys()}, Needed: {source_colors}\")\n         # Handle this case? Maybe default to simple color swap? For now, proceed.\n\n    return mappings, background_color, templates\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Main transformation function.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    frame_color = 5\n\n    # --- Step 1: Find the Frame ---\n    frame_bbox = find_frame_bbox(input_np, frame_color)\n    if frame_bbox is None:\n        # print(\"Warning: No valid frame found. Returning input grid unchanged.\")\n        return input_grid\n    r_min, c_min, r_max, c_max = frame_bbox\n\n    # --- Step 2: Analyze Key Area (Outside Frame) ---\n    try:\n        mappings, background_color, templates = analyze_key_area(input_np, frame_bbox, frame_color)\n    except Exception as e:\n        # print(f\"Error during key area analysis: {e}. Returning input grid.\")\n        # Fallback or error handling - return original grid might be safest\n        return input_grid # Or raise error\n\n    # --- Step 3: Initialize Output ---\n    output_h = r_max - r_min + 1\n    output_w = c_max - c_min + 1\n    output_np = np.full((output_h, output_w), background_color, dtype=int)\n\n    # --- Step 4: Copy Frame ---\n    # Iterate through the frame coordinates found initially\n    frame_coords_relative = np.argwhere(input_np[r_min:r_max+1, c_min:c_max+1] == frame_color)\n    for r_rel, c_rel in frame_coords_relative:\n        output_np[r_rel, c_rel] = frame_color\n\n    # --- Step 5: Identify and Transform Source Blocks ---\n    source_colors = set(mappings.keys())\n    # Create a grid representing only the inside of the frame\n    inside_grid_np = input_np[r_min + 1:r_max, c_min + 1:c_max]\n    \n    # Need to keep track of visited cells in the *output* grid's coordinate system\n    # to avoid overwriting parts of placed templates by later blocks.\n    output_visited_mask = np.zeros_like(output_np, dtype=bool) \n    # Mark frame as visited initially\n    output_visited_mask[output_np == frame_color] = True \n\n    # Iterate through potential starting points inside the frame\n    for r_in in range(inside_grid_np.shape[0]):\n        for c_in in range(inside_grid_np.shape[1]):\n            # Map inside coords (r_in, c_in) to output coords (r_out, c_out)\n            r_out, c_out = r_in + 1, c_in + 1 \n            \n            # Check if this output cell has already been processed (part of another template or frame)\n            if output_visited_mask[r_out, c_out]:\n                continue\n\n            source_color = inside_grid_np[r_in, c_in]\n\n            if source_color in source_colors:\n                 # We found a potential start of a source block. \n                 # Find the full block in the *original* input grid, starting from global coords.\n                 global_r, global_c = r_in + r_min + 1, c_in + c_min + 1\n                 \n                 # Find the single block containing this global coordinate\n                 source_block_info_list = find_contiguous_blocks(input_np, {source_color}, start_coord=(global_r, global_c))\n                 \n                 if source_block_info_list: # Should find exactly one block\n                     source_block_info = source_block_info_list[0]\n                     block_r_min_global = source_block_info['r_min']\n                     block_c_min_global = source_block_info['c_min']\n                     \n                     # Calculate top-left relative to the output grid\n                     block_r_rel = block_r_min_global - r_min\n                     block_c_rel = block_c_min_global - c_min\n\n                     # Check if we have a template for this color\n                     if source_color in templates:\n                         template = templates[source_color]\n                         target_color = mappings[source_color]\n                         t_h, t_w = template.shape\n\n                         # Apply the template\n                         for r_t in range(t_h):\n                             for c_t in range(t_w):\n                                 out_r = block_r_rel + r_t\n                                 out_c = block_c_rel + c_t\n\n                                 # Ensure placement is within output bounds\n                                 if 0 <= out_r < output_h and 0 <= out_c < output_w:\n                                     template_pixel = template[r_t, c_t]\n                                     # Only overwrite if not already visited (e.g., by frame or another template)\n                                     if not output_visited_mask[out_r, out_c]:\n                                         if template_pixel == source_color:\n                                             output_np[out_r, out_c] = target_color\n                                         elif template_pixel == background_color:\n                                             # Already initialized with background, but mark visited\n                                             output_np[out_r, out_c] = background_color \n                                         # else: # Should not happen if template is valid\n                                         #     print(f\"Warning: Unexpected color {template_pixel} in template for {source_color}\")\n                                         \n                                         # Mark this output cell as visited\n                                         output_visited_mask[out_r, out_c] = True\n                     else:\n                         # No template found - what to do? Simple color swap? Skip?\n                         # For now, let's mark the block's area as visited to avoid reprocessing\n                         # coords_global = source_block_info['coords']\n                         # for r_g, c_g in coords_global:\n                         #      r_o, c_o = r_g - r_min, c_g - c_min\n                         #      if 0 <= r_o < output_h and 0 <= c_o < output_w:\n                         #           output_visited_mask[r_o, c_o] = True\n                         # print(f\"Warning: No template for source color {source_color} at ({block_r_rel}, {block_c_rel}). Skipping block.\")\n                         pass # Mark as visited below\n\n                     # Mark the entire original source block area in the output as visited,\n                     # regardless of template application, to prevent reprocessing pixels\n                     # of the same block if the BFS in find_contiguous_blocks was used earlier.\n                     # Find the coordinates relative to the output grid.\n                     coords_global = source_block_info['coords']\n                     for r_g, c_g in coords_global:\n                         r_o, c_o = r_g - r_min, c_g - c_min\n                         if 0 <= r_o < output_h and 0 <= c_o < output_w:\n                              output_visited_mask[r_o, c_o] = True\n                 # else: # Should not happen if find_contiguous_blocks works\n                 #     print(f\"Error: Did not find block for source color {source_color} starting at global ({global_r}, {global_c})\")\n                 #     output_visited_mask[r_out, c_out] = True # Mark start cell visited anyway\n\n            else:\n                # If the cell inside is not a source color, just mark it visited if it's background\n                # (Other colors inside that aren't source colors are ignored per the logic)\n                if source_color == background_color:\n                     output_visited_mask[r_out, c_out] = True\n\n\n    # --- Step 6: Output ---\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23831,
    "candidates_token_count": 6535,
    "total_token_count": 30366,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 49.129609,
  "retries": 1
}