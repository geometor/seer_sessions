{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nfrom typing import List, Dict, Tuple, Set, Optional\n\n\"\"\"\nTransforms an input grid based on rules derived from a key area outside a main frame.\n\nThe transformation involves:\n1. Finding a hollow rectangular frame of gray (5) pixels.\n2. Analyzing the area outside the frame (KeyArea) to find:\n    a. Solid blocks of unique 'SourceColor'.\n    b. Template blocks composed of a 'TargetColor' and the 'BackgroundColor'.\n    c. Adjacency between Solid blocks and Template blocks to establish:\n        i. Mappings: SourceColor -> TargetColor\n        ii. Template Shapes: The array shape/content associated with each SourceColor.\n    d. The invariant 'BackgroundColor' (most frequent outside color not part of the frame or mapping pairs).\n3. Initializing an output grid based on the frame's dimensions, filled with the BackgroundColor.\n4. Copying the gray frame pixels to the output grid.\n5. Finding instances of SourceColor blocks within the input frame.\n6. For each Source Block Instance found inside the frame:\n    a. Retrieve its associated Template Shape and TargetColor using the mapping.\n    b. \"Paint\" the Template Shape onto the output grid at the Source Block Instance's top-left position, replacing the template's original TargetColor pixels with the mapped TargetColor and the template's BackgroundColor pixels with the BackgroundColor.\n7. Returning the final output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box coords (min_r, min_c, max_r, max_c) of the largest hollow rectangle made of frame_color.\n    Returns None if no valid frame is found.\n    \"\"\"\n    coords = np.argwhere(grid_np == frame_color)\n    if coords.size == 0:\n        return None\n        \n    r_min, c_min = coords.min(axis=0)\n    r_max, c_max = coords.max(axis=0)\n\n    # Check if frame is too small to be hollow\n    if r_max < r_min + 2 or c_max < c_min + 2:\n         # Handle thin \"frames\" - are they allowed? Assume requires hollow for now.\n         # Basic check: all coords must be on border\n         on_border = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \\\n                     (coords[:, 1] == c_min) | (coords[:, 1] == c_max)\n         if np.all(on_border):\n             # Check if it's just a line or corner, needs at least 4 pixels for a minimal frame?\n             # A simple line might be ambiguous. For simplicity, require a hollow potential.\n             # Let's assume a valid frame must have potential for interior (size >= 3x3)\n             # Or adjust if examples show line frames. Sticking to hollow assumption.\n             if r_max >= r_min + 2 and c_max >= c_min + 2: # Potential interior\n                 pass # Check below\n             else:\n                 return None # Too small to be hollow\n\n    # Verify all frame_color pixels are on the border\n    on_border_check = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \\\n                      (coords[:, 1] == c_min) | (coords[:, 1] == c_max)\n    if not np.all(on_border_check):\n        return None # Pixels with frame color exist *not* on the border defined by min/max\n\n    # Verify the inside is not the frame color (ensure it's hollow)\n    inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]\n    if np.any(inner_slice == frame_color):\n        return None # Frame color found inside, not a simple hollow frame\n\n    return (r_min, c_min, r_max, c_max)\n\n\ndef find_contiguous_blocks(grid_np: np.ndarray, \n                           allowed_colors: Set[int],\n                           search_bounds: Optional[Tuple[int, int, int, int]] = None,\n                           start_coord: Optional[Tuple[int, int]] = None,\n                           ignore_mask: Optional[np.ndarray] = None) -> List[Dict]:\n    \"\"\"\n    Finds contiguous blocks of any single color within allowed_colors, optionally within bounds.\n    \n    Args:\n        grid_np: The grid to search.\n        allowed_colors: Set of colors to form blocks.\n        search_bounds: Optional (r0, c0, r1, c1) exclusive bounds for search.\n        start_coord: If provided, only find the block containing this coordinate.\n        ignore_mask: Optional boolean array where True means ignore this cell.\n\n    Returns:\n        List of dictionaries, each: {'color', 'coords', 'r_min', 'c_min', 'r_max', 'c_max'}\n    \"\"\"\n    rows, cols = grid_np.shape\n    if search_bounds:\n        r_start, c_start, r_end, c_end = search_bounds\n    else:\n        r_start, c_start, r_end, c_end = 0, 0, rows, cols\n\n    visited = np.zeros_like(grid_np, dtype=bool)\n    if ignore_mask is not None:\n        visited |= ignore_mask # Pre-mark ignored cells as visited\n\n    blocks = []\n    \n    search_queue = deque()\n    if start_coord:\n        # Check if start_coord is valid and within bounds\n        sr, sc = start_coord\n        if r_start <= sr < r_end and c_start <= sc < c_end and not visited[sr, sc]:\n             search_queue.append(start_coord)\n    else:\n        # Add all valid starting points within bounds\n        for r in range(r_start, r_end):\n             for c in range(c_start, c_end):\n                 if not visited[r, c] and grid_np[r, c] in allowed_colors:\n                     search_queue.append((r, c))\n\n    processed_starts = set() # Avoid redundant BFS starts if queue has duplicates initially\n\n    while search_queue:\n        r_init, c_init = search_queue.popleft()\n        \n        if visited[r_init, c_init] or (r_init, c_init) in processed_starts:\n            continue\n            \n        color = grid_np[r_init, c_init]\n        if color not in allowed_colors: # Should not happen if queue is built correctly\n            continue\n\n        processed_starts.add((r_init, c_init)) # Mark this starting cell as processed for queue\n\n        block_coords = set()\n        q = deque([(r_init, c_init)])\n        visited[r_init, c_init] = True\n        r_min_blk, c_min_blk = r_init, c_init\n        r_max_blk, c_max_blk = r_init, c_init\n        \n        while q:\n            r, c = q.popleft()\n            block_coords.add((r, c))\n            r_min_blk, c_min_blk = min(r_min_blk, r), min(c_min_blk, c)\n            r_max_blk, c_max_blk = max(r_max_blk, r), max(c_max_blk, c)\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Check grid bounds and search bounds\n                if 0 <= nr < rows and 0 <= nc < cols and \\\n                   r_start <= nr < r_end and c_start <= nc < c_end and \\\n                   not visited[nr, nc] and grid_np[nr, nc] == color:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n\n        blocks.append({\n            'color': color, \n            'coords': block_coords,\n            'r_min': r_min_blk, 'c_min': c_min_blk, \n            'r_max': r_max_blk, 'c_max': c_max_blk\n        })\n        \n        # If we were searching for a specific start coord's block, we found it.\n        if start_coord:\n            break \n                 \n    return blocks\n\n\ndef analyze_key_area(grid_np: np.ndarray, frame_bbox: Tuple[int, int, int, int], frame_color: int) -> Optional[Tuple[Dict[int, int], int, Dict[int, np.ndarray]]]:\n    \"\"\"\n    Analyzes the area outside the frame to find mappings, background, and templates.\n\n    Returns:\n        Tuple (mappings, background_color, templates) or None if analysis fails.\n        mappings: {source_color: target_color}\n        background_color: int\n        templates: {source_color: template_array}\n    \"\"\"\n    rows, cols = grid_np.shape\n    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox\n    \n    # --- Create Mask for Key Area (Outside Frame) ---\n    key_area_mask = np.ones_like(grid_np, dtype=bool)\n    key_area_mask[r_min_f:r_max_f + 1, c_min_f:c_max_f + 1] = False\n    \n    # --- Initial Background Color Guess ---\n    outside_colors_counter = Counter()\n    key_area_coords = np.argwhere(key_area_mask)\n    for r, c in key_area_coords:\n        color = grid_np[r, c]\n        if color != frame_color: # Should always be true if mask is correct\n            outside_colors_counter[color] += 1\n            \n    if not outside_colors_counter:\n        print(\"Warning: No non-frame colors found outside the frame.\")\n        return None # Cannot determine rules\n\n    # Most frequent color outside is potential background\n    # Sort by frequency (desc), then color value (asc) for tie-breaking\n    sorted_outside_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))\n    potential_background = sorted_outside_colors[0][0]\n\n    # --- Find Components (Solid & Template Candidates) Outside Frame ---\n    visited_key = np.zeros_like(grid_np, dtype=bool)\n    visited_key[~key_area_mask] = True # Mark frame and inside as visited\n\n    solid_blocks = []\n    template_candidates = [] # Store potential template blocks before background is finalized\n\n    for r_init, c_init in key_area_coords:\n         if not visited_key[r_init, c_init]:\n            component_coords = set()\n            colors_in_component = set()\n            q = deque([(r_init, c_init)])\n            visited_key[r_init, c_init] = True\n            r_min_comp, c_min_comp = r_init, c_init\n            r_max_comp, c_max_comp = r_init, c_init\n\n            while q:\n                r, c = q.popleft()\n                color = grid_np[r, c]\n                # Check if color is frame color - should not happen if mask is right\n                if color == frame_color: continue \n                \n                colors_in_component.add(color)\n                component_coords.add((r,c))\n                r_min_comp, c_min_comp = min(r_min_comp, r), min(c_min_comp, c)\n                r_max_comp, c_max_comp = max(r_max_comp, r), max(c_max_comp, c)\n\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check bounds and if it's in the key area (i.e., not visited)\n                    if 0 <= nr < rows and 0 <= nc < cols and not visited_key[nr, nc]:\n                        # Connect components regardless of color initially\n                        visited_key[nr, nc] = True\n                        q.append((nr, nc))\n\n            # --- Categorize Component ---\n            non_background_candidates = colors_in_component - {potential_background}\n            \n            if len(non_background_candidates) == 1:\n                single_color = list(non_background_candidates)[0]\n                if len(colors_in_component) == 1: # Solid Block\n                    solid_blocks.append({\n                        'color': single_color, 'coords': component_coords,\n                        'r_min': r_min_comp, 'c_min': c_min_comp,\n                        'r_max': r_max_comp, 'c_max': c_max_comp\n                    })\n                elif len(colors_in_component) == 2 and potential_background in colors_in_component:\n                     # Potential Template Block\n                     template_arr = grid_np[r_min_comp:r_max_comp+1, c_min_comp:c_max_comp+1].copy()\n                     template_candidates.append({\n                         'target_color': single_color, \n                         'potential_bg': potential_background,\n                         'coords': component_coords,\n                         'r_min': r_min_comp, 'c_min': c_min_comp,\n                         'r_max': r_max_comp, 'c_max': c_max_comp,\n                         'array': template_arr\n                     })\n            # else: Mixed block or just background - ignore for mapping\n\n    # --- Determine Final Background & Mappings ---\n    solid_colors = {b['color'] for b in solid_blocks}\n    target_colors = {b['target_color'] for b in template_candidates}\n    possible_mapping_colors = solid_colors | target_colors\n\n    background_color = -1\n    for color, count in sorted_outside_colors:\n        if color not in possible_mapping_colors:\n             background_color = color\n             break\n    if background_color == -1:\n         # Fallback: Use the initial potential background if all colors were involved in pairs\n         background_color = potential_background\n         # print(f\"Warning: All outside colors involved in potential pairs. Using initial guess {background_color} as background.\")\n\n    # Filter template candidates based on the final background color\n    valid_template_blocks = [\n        tc for tc in template_candidates if tc['potential_bg'] == background_color\n    ]\n    \n    # Find mappings by adjacency\n    mappings = {}\n    templates = {}\n    mapped_target_colors = set() # Track target colors already used in a mapping\n\n    for sb in solid_blocks:\n        source_color = sb['color']\n        if source_color in mappings: continue \n\n        best_match_template = None\n        \n        for tb in valid_template_blocks:\n            target_color = tb['target_color']\n            # Ensure this target color hasn't been mapped *to* already\n            if target_color in mapped_target_colors: continue \n\n            # Check adjacency\n            is_adjacent = False\n            for r_s, c_s in sb['coords']:\n                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                     nr, nc = r_s + dr, c_s + dc\n                     if (nr, nc) in tb['coords']:\n                         is_adjacent = True\n                         break\n                 if is_adjacent: break\n            \n            if is_adjacent:\n                # Found a potential match. Since a source might be adjacent to multiple\n                # things, maybe store first match? Or require unique pairings?\n                # Assume first adjacent match is correct for now.\n                best_match_template = tb\n                break \n\n        if best_match_template:\n            target_color = best_match_template['target_color']\n            mappings[source_color] = target_color\n            templates[source_color] = best_match_template['array']\n            mapped_target_colors.add(target_color) # Mark target as used\n\n    if not mappings:\n        # print(\"Warning: No mappings found between solid and template blocks.\")\n        return None # Cannot proceed\n\n    return mappings, background_color, templates\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the frame-key-template transformation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    frame_color = 5\n\n    # --- Step 1: Find the Frame ---\n    frame_bbox = find_frame_bbox(input_np, frame_color)\n    if frame_bbox is None:\n        # print(\"No valid frame found. Returning input grid.\")\n        return input_grid\n    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox\n\n    # --- Step 2: Analyze Key Area ---\n    analysis_result = analyze_key_area(input_np, frame_bbox, frame_color)\n    if analysis_result is None:\n         # print(\"Failed to analyze key area. Returning input grid.\")\n         return input_grid # Or handle error differently\n    mappings, background_color, templates = analysis_result\n    \n    if not mappings or not templates:\n        # print(\"Analysis incomplete (no mappings or templates). Returning input grid.\")\n        return input_grid\n\n    # --- Step 3: Initialize Output Grid ---\n    output_h = r_max_f - r_min_f + 1\n    output_w = c_max_f - c_min_f + 1\n    output_np = np.full((output_h, output_w), background_color, dtype=int)\n\n    # --- Step 4: Copy Frame ---\n    # Get coordinates relative to the frame bounding box start\n    frame_coords_relative = np.argwhere(input_np[r_min_f:r_max_f+1, c_min_f:c_max_f+1] == frame_color)\n    for r_rel, c_rel in frame_coords_relative:\n        output_np[r_rel, c_rel] = frame_color\n\n    # --- Step 5: Transform Instances Inside Frame ---\n    source_colors = set(mappings.keys())\n    # Define search bounds for inside the frame (exclusive of border)\n    inner_bounds = (r_min_f + 1, c_min_f + 1, r_max_f, c_max_f)\n    # Create ignore mask for frame pixels within the output grid dimensions\n    output_ignore_mask = (output_np == frame_color)\n\n    # Find all source blocks within the inner bounds\n    source_instances = find_contiguous_blocks(input_np, source_colors, search_bounds=inner_bounds)\n\n    processed_output_cells = output_ignore_mask.copy() # Track painted cells\n\n    for instance in source_instances:\n        source_color = instance['color']\n        # Use the top-left corner of the block instance for placement\n        r_abs = instance['r_min']\n        c_abs = instance['c_min']\n        \n        if source_color in templates:\n            template_shape = templates[source_color]\n            target_color = mappings[source_color]\n            t_h, t_w = template_shape.shape\n\n            # Calculate placement coords relative to output grid\n            r_rel = r_abs - r_min_f\n            c_rel = c_abs - c_min_f\n\n            # Apply the template\n            for r_t in range(t_h):\n                for c_t in range(t_w):\n                    out_r = r_rel + r_t\n                    out_c = c_rel + c_t\n\n                    # Check bounds of output grid\n                    if 0 <= out_r < output_h and 0 <= out_c < output_w:\n                        # Check if this cell was already painted or is frame\n                        if processed_output_cells[out_r, out_c]:\n                            continue\n\n                        template_pixel_color = template_shape[r_t, c_t]\n                        output_color = -1 # Undefined\n\n                        # Determine output color based on template content\n                        # Important: Compare template_pixel_color with the TARGET color \n                        # found *in the template* during analysis, not the mapped target color.\n                        # However, our analyze_key_area stores the template array directly.\n                        # So, we need to know which color *in the template array* corresponds to the TARGET.\n                        # Assumption: the template contains only background_color and the target_color from the mapping.\n                        if template_pixel_color == target_color:\n                             output_color = target_color\n                        elif template_pixel_color == background_color:\n                             output_color = background_color\n                        # Else: template contains unexpected color? Skip painting this pixel.\n                        \n                        if output_color != -1:\n                             output_np[out_r, out_c] = output_color\n                             processed_output_cells[out_r, out_c] = True # Mark as painted\n        #else: No template found for this source color, skipped.\n\n\n    # --- Step 6: Return Output ---\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 49026,
    "candidates_token_count": 5761,
    "total_token_count": 54787,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 44.931202,
  "retries": 1
}