{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\nfrom typing import List, Dict, Tuple, Set, Optional\n\n\"\"\"\nTransforms an input grid based on rules derived from a key area outside a main frame.\n\nThe process involves:\n1. Finding a hollow rectangular frame of gray (5) pixels.\n2. Analyzing the area outside the frame (KeyArea) to find:\n    a. Source Shapes: Solid blocks of a single 'SourceColor'.\n    b. Output Shapes: Patterned blocks composed of a 'TargetColor' and the 'BackgroundColor'.\n    c. Adjacency between Source Shapes and Output Shapes to establish:\n        i. Mappings: SourceColor -> TargetColor\n        ii. Templates: The array shape/content of the Output Shape associated with each SourceColor.\n    d. The invariant 'BackgroundColor' (most frequent outside color not part of the frame or mapping pairs).\n3. Initializing an output grid based on the frame's dimensions, filled with the BackgroundColor.\n4. Copying the gray frame pixels to the output grid.\n5. Finding instances of SourceColor blocks within the input frame (Source Instances).\n6. For each Source Instance found inside the frame:\n    a. Retrieve its associated Template (Output Shape array) and TargetColor using the mapping.\n    b. \"Paint\" the Template onto the output grid at the Source Instance's top-left position, using the TargetColor and BackgroundColor found within the template.\n7. Returning the final output grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_frame_bbox(grid_np: np.ndarray, frame_color: int = 5) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box coords (min_r, min_c, max_r, max_c) of the largest hollow rectangle made of frame_color.\n    Returns None if no valid frame is found (requires potential for hollow interior, >= 3x3).\n    \"\"\"\n    coords = np.argwhere(grid_np == frame_color)\n    if coords.size < 4: # Need at least 4 pixels for the smallest possible hollow frame (corners)\n        return None\n        \n    r_min, c_min = coords.min(axis=0)\n    r_max, c_max = coords.max(axis=0)\n\n    # Check if frame is too small to be hollow\n    if r_max < r_min + 2 or c_max < c_min + 2: \n         return None # Too small to have a distinct interior\n\n    # Verify all frame_color pixels are on the border\n    on_border_check = (coords[:, 0] == r_min) | (coords[:, 0] == r_max) | \\\n                      (coords[:, 1] == c_min) | (coords[:, 1] == c_max)\n    if not np.all(on_border_check):\n        return None # Pixels with frame color exist *not* on the border defined by min/max\n\n    # Verify the inside is not the frame color (ensure it's hollow)\n    inner_slice = grid_np[r_min + 1:r_max, c_min + 1:c_max]\n    if np.any(inner_slice == frame_color):\n        return None # Frame color found inside, not a simple hollow frame\n\n    return (r_min, c_min, r_max, c_max)\n\n\ndef find_contiguous_blocks(grid_np: np.ndarray, \n                           allowed_colors: Set[int],\n                           search_mask: Optional[np.ndarray] = None, # Mask indicating where to search (True = search here)\n                           start_coord: Optional[Tuple[int, int]] = None\n                           ) -> List[Dict]:\n    \"\"\"\n    Finds contiguous blocks of any single color within allowed_colors, searching only where search_mask is True.\n    \n    Args:\n        grid_np: The grid to search.\n        allowed_colors: Set of colors to form blocks.\n        search_mask: Boolean array where True indicates searchable cells. If None, search entire grid.\n        start_coord: If provided, only find the block containing this coordinate.\n\n    Returns:\n        List of dictionaries, each: {'color', 'coords', 'r_min', 'c_min', 'r_max', 'c_max'}\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    if search_mask is not None:\n        visited[~search_mask] = True # Mark non-searchable areas as visited\n    else:\n        # If no mask, create a mask allowing search everywhere\n        search_mask = np.ones_like(grid_np, dtype=bool) \n\n    blocks = []\n    \n    q_bfs = deque()\n\n    if start_coord:\n        sr, sc = start_coord\n        # Check if start_coord is valid and searchable\n        if 0 <= sr < rows and 0 <= sc < cols and search_mask[sr, sc] and grid_np[sr,sc] in allowed_colors:\n             if not visited[sr, sc]:\n                 q_bfs.append(start_coord)\n                 visited[sr, sc] = True # Mark start coord as visited for BFS queue\n        else:\n             return [] # Start coord invalid or not allowed color/location\n    else:\n        # Add all valid starting points within the search mask\n        search_coords = np.argwhere(search_mask)\n        for r_init, c_init in search_coords:\n             if not visited[r_init, c_init] and grid_np[r_init, c_init] in allowed_colors:\n                 q_bfs.append((r_init, c_init))\n                 visited[r_init, c_init] = True # Mark as visited for BFS queue\n\n    processed_starts = set() # Track actual BFS roots processed\n\n    while q_bfs:\n        r_init, c_init = q_bfs.popleft()\n        \n        # Double check if visited (might happen if added multiple times before processing)\n        # Also check if this specific start was already processed by a previous BFS run\n        if (r_init, c_init) in processed_starts:\n             continue\n             \n        # Perform BFS for the block starting from (r_init, c_init)\n        color = grid_np[r_init, c_init]\n        block_coords = set()\n        q_block = deque([(r_init, c_init)])\n        # Mark the initial cell as the start of this BFS run\n        processed_starts.add((r_init, c_init)) \n        \n        r_min_blk, c_min_blk = r_init, c_init\n        r_max_blk, c_max_blk = r_init, c_init\n        \n        while q_block:\n            r, c = q_block.popleft()\n            block_coords.add((r, c))\n            r_min_blk, c_min_blk = min(r_min_blk, r), min(c_min_blk, c)\n            r_max_blk, c_max_blk = max(r_max_blk, r), max(c_max_blk, c)\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Check grid bounds and if the neighbor is searchable, same color, and not visited by THIS BFS run yet\n                if 0 <= nr < rows and 0 <= nc < cols and \\\n                   search_mask[nr, nc] and \\\n                   grid_np[nr, nc] == color and \\\n                   (nr, nc) not in processed_starts and \\\n                   (nr, nc) not in block_coords : # Check block_coords avoids adding back to q_block within same BFS\n                    \n                    # Check if already visited by the main BFS queue preparation - if so, mark as processed start\n                    if visited[nr,nc]:\n                         processed_starts.add((nr,nc))\n                    else:\n                         # Mark as visited for main BFS queue and add to this block's BFS\n                         visited[nr, nc] = True \n                         q_block.append((nr, nc))\n                         # also mark as processed start to prevent future BFS runs from here\n                         processed_starts.add((nr,nc)) \n                         \n\n        blocks.append({\n            'color': color, \n            'coords': block_coords,\n            'r_min': r_min_blk, 'c_min': c_min_blk, \n            'r_max': r_max_blk, 'c_max': c_max_blk\n        })\n        \n        # If we were searching for a specific start coord's block, we found it.\n        if start_coord:\n            break \n                 \n    return blocks\n\n\ndef analyze_key_area(grid_np: np.ndarray, frame_bbox: Tuple[int, int, int, int], frame_color: int) -> Optional[Tuple[Dict[int, int], int, Dict[int, np.ndarray]]]:\n    \"\"\"\n    Analyzes the area outside the frame to find mappings, background, and templates.\n\n    Returns:\n        Tuple (mappings, background_color, templates) or None if analysis fails.\n        mappings: {source_color: target_color}\n        background_color: int\n        templates: {source_color: template_array}\n    \"\"\"\n    rows, cols = grid_np.shape\n    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox\n    \n    # --- Create Mask for Key Area (Outside Frame) ---\n    key_area_mask = np.ones(grid_np.shape, dtype=bool)\n    key_area_mask[r_min_f:r_max_f + 1, c_min_f:c_max_f + 1] = False\n    \n    if not np.any(key_area_mask): return None # No key area exists\n\n    # --- Initial Background Color Guess ---\n    outside_colors_counter = Counter()\n    key_area_coords = np.argwhere(key_area_mask)\n    for r, c in key_area_coords:\n        outside_colors_counter[grid_np[r, c]] += 1\n            \n    if not outside_colors_counter: return None\n\n    sorted_outside_colors = sorted(outside_colors_counter.items(), key=lambda item: (-item[1], item[0]))\n    potential_background = sorted_outside_colors[0][0]\n\n    # --- Find Components (Solid & Pattern Candidates) Outside Frame ---\n    visited_key = np.zeros_like(grid_np, dtype=bool)\n    visited_key[~key_area_mask] = True # Mark frame and inside as visited\n\n    source_shapes = [] # Solid blocks\n    output_shape_candidates = [] # Pattern blocks (T + potential BG)\n\n    key_area_q = deque([(r,c) for r, c in key_area_coords if not visited_key[r,c]])\n    processed_starts_key = set()\n\n    while key_area_q:\n         r_init, c_init = key_area_q.popleft()\n         \n         if visited_key[r_init, c_init] or (r_init, c_init) in processed_starts_key:\n             continue\n\n         component_coords = set()\n         colors_in_component = set()\n         q_comp = deque([(r_init, c_init)])\n         visited_key[r_init, c_init] = True\n         processed_starts_key.add((r_init, c_init))\n         \n         r_min_comp, c_min_comp = r_init, c_init\n         r_max_comp, c_max_comp = r_init, c_init\n\n         while q_comp:\n             r, c = q_comp.popleft()\n             color = grid_np[r, c]\n             \n             colors_in_component.add(color)\n             component_coords.add((r,c))\n             r_min_comp, c_min_comp = min(r_min_comp, r), min(c_min_comp, c)\n             r_max_comp, c_max_comp = max(r_max_comp, r), max(c_max_comp, c)\n\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n                 # Check bounds and if it's in the key area and not visited\n                 if 0 <= nr < rows and 0 <= nc < cols and key_area_mask[nr, nc] and not visited_key[nr, nc]:\n                     visited_key[nr, nc] = True\n                     processed_starts_key.add((nr, nc)) # Mark as processed start too\n                     q_comp.append((nr, nc))\n\n         # --- Categorize Component ---\n         if len(colors_in_component) == 1:\n             color_s = list(colors_in_component)[0]\n             if color_s != potential_background:\n                 source_shapes.append({\n                     'color': color_s, 'coords': component_coords,\n                     'r_min': r_min_comp, 'c_min': c_min_comp, 'r_max': r_max_comp, 'c_max': c_max_comp\n                 })\n         elif len(colors_in_component) == 2 and potential_background in colors_in_component:\n             color_t = list(colors_in_component - {potential_background})[0]\n             pattern_arr = grid_np[r_min_comp:r_max_comp+1, c_min_comp:c_max_comp+1].copy()\n             output_shape_candidates.append({\n                  'target_color': color_t, \n                  'potential_bg': potential_background,\n                  'coords': component_coords,\n                  'r_min': r_min_comp, 'c_min': c_min_comp, 'r_max': r_max_comp, 'c_max': c_max_comp,\n                  'array': pattern_arr\n              })\n\n    # --- Determine Final Background & Mappings ---\n    source_colors = {s['color'] for s in source_shapes}\n    target_colors = {o['target_color'] for o in output_shape_candidates}\n    \n    background_color = -1\n    for color, count in sorted_outside_colors:\n        if color not in source_colors and color not in target_colors:\n            background_color = color\n            break\n            \n    if background_color == -1: \n        background_color = potential_background \n\n    # Filter output shapes based on final background\n    valid_output_shapes = [o for o in output_shape_candidates if o['potential_bg'] == background_color]\n    \n    mappings = {}\n    templates = {}\n    used_output_shapes_indices = set()\n\n    for ss in source_shapes:\n        source_color = ss['color']\n        if source_color in mappings: continue\n        \n        adjacent_output_shape_idx = -1\n        for idx, os in enumerate(valid_output_shapes):\n             if idx in used_output_shapes_indices: continue # Skip if already paired\n\n             # Check adjacency\n             is_adjacent = False\n             for r_s, c_s in ss['coords']:\n                  for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                      nr, nc = r_s + dr, c_s + dc\n                      if (nr, nc) in os['coords']:\n                          is_adjacent = True\n                          break\n                  if is_adjacent: break\n             \n             if is_adjacent:\n                  adjacent_output_shape_idx = idx\n                  break \n\n        if adjacent_output_shape_idx != -1:\n            matched_os = valid_output_shapes[adjacent_output_shape_idx]\n            target_color = matched_os['target_color']\n            \n            # Check if this target color is already mapped to by another source\n            already_mapped_to = False\n            for mapped_target in mappings.values():\n                 if mapped_target == target_color:\n                     already_mapped_to = True\n                     break\n\n            # Only create mapping if target is not already used and shape index not used\n            if not already_mapped_to:\n                mappings[source_color] = target_color\n                templates[source_color] = matched_os['array']\n                used_output_shapes_indices.add(adjacent_output_shape_idx)\n            # else: print(f\"Conflict: Target color {target_color} already mapped to, skipping pair for source {source_color}\")\n\n    if not mappings: return None\n\n    return mappings, background_color, templates\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:  \n    \"\"\"\n    Transforms the input grid using frame, key area analysis, and template painting.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    frame_color = 5\n\n    # --- Step 1: Find Frame ---\n    frame_bbox = find_frame_bbox(input_np, frame_color)\n    if frame_bbox is None:\n        return input_grid # No valid frame found\n    r_min_f, c_min_f, r_max_f, c_max_f = frame_bbox\n\n    # --- Step 2: Analyze Key Area ---\n    analysis_result = analyze_key_area(input_np, frame_bbox, frame_color)\n    if analysis_result is None:\n         return input_grid # Analysis failed\n    mappings, background_color, templates = analysis_result\n    \n    if not mappings or not templates:\n        return input_grid # Analysis incomplete\n\n    # --- Step 3: Initialize Output Grid ---\n    output_h = r_max_f - r_min_f + 1\n    output_w = c_max_f - c_min_f + 1\n    output_np = np.full((output_h, output_w), background_color, dtype=int)\n\n    # --- Step 4: Copy Frame ---\n    frame_coords_relative = np.argwhere(input_np[r_min_f:r_max_f+1, c_min_f:c_max_f+1] == frame_color)\n    for r_rel, c_rel in frame_coords_relative:\n        # Check bounds just in case, though relative coords should be correct\n        if 0 <= r_rel < output_h and 0 <= c_rel < output_w:\n             output_np[r_rel, c_rel] = frame_color\n\n    # --- Step 5: Transform Source Instances ---\n    source_colors = set(mappings.keys())\n    # Define search mask for inside the frame (exclusive of border)\n    inner_mask = np.zeros_like(input_np, dtype=bool)\n    if r_max_f > r_min_f + 1 and c_max_f > c_min_f + 1: # Check if inner area exists\n        inner_mask[r_min_f + 1:r_max_f, c_min_f + 1:c_max_f] = True\n\n    # Find all source blocks within the inner mask\n    source_instances = find_contiguous_blocks(input_np, source_colors, search_mask=inner_mask)\n\n    # --- Step 6: Apply Templates ---\n    # Create mask of cells already painted (initially just the frame)\n    painted_mask = (output_np == frame_color)\n\n    for instance in source_instances:\n        source_color = instance['color']\n        r_abs = instance['r_min'] # Top-left corner of the source instance\n        c_abs = instance['c_min']\n        \n        if source_color in templates:\n            template_shape = templates[source_color]\n            target_color = mappings[source_color]\n            t_h, t_w = template_shape.shape\n\n            # Calculate placement coords relative to output grid's top-left\n            r_rel = r_abs - r_min_f\n            c_rel = c_abs - c_min_f\n\n            # Apply the template\n            for r_t in range(t_h):\n                for c_t in range(t_w):\n                    out_r = r_rel + r_t\n                    out_c = c_rel + c_t\n\n                    # Check bounds of output grid\n                    if 0 <= out_r < output_h and 0 <= out_c < output_w:\n                        # Check if this cell was already painted\n                        if painted_mask[out_r, out_c]:\n                            continue\n\n                        template_pixel_color = template_shape[r_t, c_t]\n                        \n                        # Determine the color to paint based on the template content\n                        # The template contains the TARGET color and the BACKGROUND color.\n                        if template_pixel_color == target_color:\n                             output_color = target_color\n                        elif template_pixel_color == background_color:\n                             output_color = background_color\n                        else:\n                             # Template contains unexpected color, skip painting this pixel\n                             # This might happen if the component analysis wasn't perfect.\n                             continue \n                        \n                        output_np[out_r, out_c] = output_color\n                        painted_mask[out_r, out_c] = True # Mark as painted\n        # else: No template defined for this source color, instance is ignored.\n\n    # Convert final numpy array back to list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 73285,
    "candidates_token_count": 5539,
    "total_token_count": 78824,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 35.628082,
  "retries": 1
}