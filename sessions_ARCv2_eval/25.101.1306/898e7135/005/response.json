{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Define Color Sets:**\n    *   `Marker_Colors = {Orange(7), Azure(8)}`\n    *   `Content_Colors = {Blue(1), Red(2), Green(3), Yellow(4), Gray(5), Magenta(6), Maroon(9)}` (Potential colors for background and output objects, excluding markers 0, 7, 8).\n2.  **Determine Background Color:**\n    *   Check the color `c` at `input_grid[0, 0]`.\n    *   If `c` is in `Content_Colors`, use `c` as the `background_color`.\n    *   Otherwise (if `c` is 0, 7, or 8), find the color in `Content_Colors` that appears most frequently in the entire `input_grid`. Use this mode color (lowest numerical value in case of ties) as the `background_color`. If no `Content_Colors` exist, default to 0 (White).\n3.  **Identify All Objects:** Find all distinct contiguous objects (colors 1-9) in the input grid. Store their color and pixel coordinates list `[(r1, c1), ...]`.\n4.  **Identify Background Object:** Find the specific object instance that contains the top-most, then left-most pixel matching the determined `background_color`. Mark this object.\n5.  **Identify Marker Locations:** Create a set of `(r, c)` coordinates for all pixels with colors in `Marker_Colors`.\n6.  **Select Content Objects:**\n    *   Iterate through all identified objects (from step 3).\n    *   Skip the marked `background_object`.\n    *   Skip objects whose color is in `Marker_Colors` (7 or 8).\n    *   For remaining objects (color must be in `Content_Colors`): Check if any of the object's pixels `(r_obj, c_obj)` have a direct neighbor (8-way) `(nr, nc)` such that `(nr, nc)` is in the `marker_locations` set.\n    *   If adjacency is found, add the object's data (color, pixel coordinates) to a `selected_objects` list.\n7.  **Calculate Output Canvas:**\n    *   If `selected_objects` is empty, return a 3x3 grid filled with `background_color`.\n    *   Otherwise, find the minimum bounding box (`min_r`, `min_c`, `max_r`, `max_c`) enclosing all pixel coordinates from all `selected_objects`.\n    *   Calculate canvas dimensions: `H = max_r - min_r + 1`, `W = max_c - min_c + 1`.\n8.  **Create and Populate Output Grid:**\n    *   Create the output grid with dimensions `(H + 2) x (W + 2)`, filled with `background_color` (padding = 1).\n    *   For each selected object, iterate through its pixel coordinates `(r, c)`. Calculate the target coordinates `out_r = r - min_r + 1`, `out_c = c - min_c + 1` and set `output_grid[out_r, out_c]` to the object's color.\n9.  **Return:** Return the final output grid.\n\"\"\"\n\n# --- Constants ---\nMARKER_COLORS = {7, 8}\nCONTENT_COLORS = {1, 2, 3, 4, 5, 6, 9}\nBACKGROUND_PIXEL = 0\n\n# --- Helper Functions ---\n\ndef find_objects_and_pixels(grid: np.ndarray, ignore_color=0) -> list[dict]:\n    \"\"\"\n    Finds all contiguous objects for colors not equal to ignore_color.\n\n    Args:\n        grid: Input numpy array.\n        ignore_color: Color to ignore (typically background).\n\n    Returns:\n        A list of dictionaries, where each dict represents an object:\n        {'color': int, 'pixels': list[list[int]]} # pixels is list of [r, c]\n    \"\"\"\n    objects_data = []\n    unique_colors = np.unique(grid)\n\n    for color in unique_colors:\n        if color == ignore_color:\n            continue\n\n        # Create a binary mask for the current color\n        binary_mask = (grid == color)\n\n        # Label connected components for this color\n        # Use 8-connectivity (structure=np.ones((3,3))) implicitly by default\n        labeled_array, num_features = label(binary_mask)\n\n        if num_features > 0:\n            # Find pixel coordinates for each component\n            for i in range(1, num_features + 1):\n                coords = np.argwhere(labeled_array == i)\n                if coords.size > 0:\n                    objects_data.append({\n                        'color': int(color), # Ensure standard int type\n                        'pixels': coords.tolist()\n                    })\n    return objects_data\n\ndef determine_background_color(grid: np.ndarray, content_colors: set) -> int:\n    \"\"\"\n    Determines the background color based on grid[0,0] or frequency\n    of allowed content colors.\n    \"\"\"\n    h, w = grid.shape\n    if h == 0 or w == 0: return BACKGROUND_PIXEL # Handle empty grid\n\n    top_left_color = grid[0, 0]\n\n    # Rule 1: If top-left is a valid content color, use it.\n    if top_left_color in content_colors:\n        return int(top_left_color)\n    # Rule 2: Otherwise, find the most frequent content color.\n    else:\n        flat_grid = grid.flatten()\n        # Filter for pixels that are valid content colors\n        content_pixels = [p for p in flat_grid if p in content_colors]\n\n        if not content_pixels:\n            # Default if no valid content colors are present at all\n            return BACKGROUND_PIXEL\n\n        counts = Counter(content_pixels)\n        max_count = 0\n        modes = []\n\n        # Find the highest frequency count among content colors\n        try:\n            # most_common returns list of (element, count) tuples\n            max_count = counts.most_common(1)[0][1]\n        except IndexError:\n             # Should not happen if content_pixels is not empty, but safety first\n             return BACKGROUND_PIXEL\n\n        # Find all content colors having that maximum frequency\n        for color, count in counts.items():\n             if count == max_count:\n                  modes.append(color)\n\n        # Return the smallest numerical color value among the modes\n        return int(min(modes))\n\ndef is_object_adjacent_to_markers(obj_pixels: list[list[int]], marker_locations_set: set, grid_shape: tuple) -> bool:\n    \"\"\"\n    Checks if any pixel of the object is adjacent (8-way) to any marker location.\n    \"\"\"\n    rows, cols = grid_shape\n    # Iterate through each pixel belonging to the object\n    for r_obj, c_obj in obj_pixels:\n        # Check its 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                nr, nc = r_obj + dr, c_obj + dc\n                # Check if neighbor is within grid bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if this neighbor's coordinate is a marker location\n                    if (nr, nc) in marker_locations_set:\n                        return True # Adjacency found\n    return False # No adjacency found after checking all object pixels\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule: selects objects adjacent to markers (7, 8),\n    places them on a determined background, preserving shapes and relative positions\n    with padding.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    if input_array.size == 0:\n        # Default for empty input\n        return [[BACKGROUND_PIXEL]*3]*3\n\n    # Step 1: Define Color Sets (already defined as constants)\n\n    # Step 2: Determine Background Color\n    background_color = determine_background_color(input_array, CONTENT_COLORS)\n\n    # Step 3: Identify All Objects (colors 1-9)\n    all_objects = find_objects_and_pixels(input_array, ignore_color=BACKGROUND_PIXEL)\n    if not all_objects:\n         # Return 3x3 background if only background color exists\n         return [[background_color]*3]*3\n\n    # Step 4: Identify Background Object\n    background_object_index = -1 # Use index in all_objects list\n    min_r_bg, min_c_bg = float('inf'), float('inf')\n    found_bg_pixel = False\n\n    # Find the coordinate of the top-most, left-most pixel with the background color\n    bg_coords = np.argwhere(input_array == background_color)\n    if bg_coords.size > 0:\n        # lexsort sorts by last column first (c), then previous (r)\n        sorted_indices = np.lexsort((bg_coords[:, 1], bg_coords[:, 0]))\n        min_r_bg, min_c_bg = bg_coords[sorted_indices[0]]\n        found_bg_pixel = True\n\n    # Find which object contains this specific pixel\n    if found_bg_pixel:\n         for i, obj in enumerate(all_objects):\n             # Optimization: Could check bounding box first\n             if obj['color'] == background_color:\n                  # Check if the identified top-left background pixel is in this object's list\n                  if [min_r_bg, min_c_bg] in obj['pixels']:\n                      background_object_index = i\n                      break # Found it\n\n    # Step 5: Identify Marker Locations\n    marker_locations_list = np.argwhere(np.isin(input_array, list(MARKER_COLORS)))\n    marker_locations_set = {tuple(coord) for coord in marker_locations_list} # Set for faster lookup\n\n    # Step 6: Select Content Objects\n    selected_objects = []\n    all_selected_pixels = [] # Collect pixels for bounding box calculation\n\n    for i, obj in enumerate(all_objects):\n        # Skip if it's the designated background object\n        if i == background_object_index:\n            continue\n        # Skip if its color is a marker color (7 or 8)\n        if obj['color'] in MARKER_COLORS:\n            continue\n\n        # Check adjacency to markers for remaining objects (color must be in CONTENT_COLORS)\n        if is_object_adjacent_to_markers(obj['pixels'], marker_locations_set, input_array.shape):\n            selected_objects.append(obj)\n            all_selected_pixels.extend(obj['pixels']) # Add pixels to list\n\n    # Step 7: Calculate Output Canvas\n    if not selected_objects:\n        # Return 3x3 background grid if no objects are selected\n        return [[background_color]*3]*3\n\n    # Find bounding box of all selected pixels\n    if not all_selected_pixels: # Should not happen if selected_objects is not empty\n         return [[background_color]*3]*3 # Safety check\n\n    all_selected_pixels_array = np.array(all_selected_pixels)\n    min_r = np.min(all_selected_pixels_array[:, 0])\n    max_r = np.max(all_selected_pixels_array[:, 0])\n    min_c = np.min(all_selected_pixels_array[:, 1])\n    max_c = np.max(all_selected_pixels_array[:, 1])\n\n    H = max_r - min_r + 1\n    W = max_c - min_c + 1\n    padding = 1\n\n    output_H = H + 2 * padding\n    output_W = W + 2 * padding\n\n    # Step 8: Create and Populate Output Grid\n    output_grid = np.full((output_H, output_W), background_color, dtype=int)\n\n    for obj in selected_objects:\n        obj_color = obj['color']\n        for r, c in obj['pixels']:\n            # Calculate position relative to the top-left of the canvas\n            rel_r = r - min_r\n            rel_c = c - min_c\n            # Add padding to get final output coordinates\n            out_r = rel_r + padding\n            out_c = rel_c + padding\n            # Draw the pixel\n            # Optional: Add bounds check, though should be correct\n            if 0 <= out_r < output_H and 0 <= out_c < output_W:\n                 output_grid[out_r, out_c] = obj_color\n\n    # Step 9: Return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 51007,
    "candidates_token_count": 3310,
    "total_token_count": 54317,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.125849,
  "retries": 1
}