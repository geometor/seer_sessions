{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Define Color Sets:** Identify Marker colors {Orange(7), Azure(8)} and Potential Content colors {Blue(1), Red(2), Green(3), Yellow(4), Gray(5), Magenta(6), Azure(8), Maroon(9)}. Background color is White(0).\n2.  **Determine Background Color:**\n    *   Check the color `c` at input_grid[0,0].\n    *   If `c` is in the Potential Content colors set, use `c` as the `background_color`.\n    *   Otherwise (if `c` is 0 or 7), find the Potential Content color that appears most frequently in the input grid. Use this mode color as the `background_color`. Handle ties by choosing the lowest numerical color value among the tied modes.\n3.  **Identify All Objects:** Find all distinct contiguous objects in the input grid, ignoring the background color (0). Store their color, pixel coordinates, and bounding box slices.\n4.  **Identify Background Object:**\n    *   Find the top-most, then left-most pixel in the grid that has the `background_color`.\n    *   Identify the specific object instance that contains this pixel. This is the `background_object`.\n5.  **Identify Marker Locations:** Find the (row, col) coordinates of all pixels with Marker colors (7 or 8).\n6.  **Select Content Objects:**\n    *   Initialize an empty list `selected_objects_data`.\n    *   Iterate through all objects identified in step 3.\n    *   Skip the object if it is the `background_object`.\n    *   Skip the object if its color is Orange (7) (since 7 is only a marker, not content).\n    *   For the remaining candidate objects (colors 1, 2, 3, 4, 5, 6, 8, 9), check if any of their pixels are adjacent (8-way connectivity) to any marker location found in step 5.\n    *   If an object is adjacent to a marker, add its data (color, pixel coordinates list) to `selected_objects_data`.\n7.  **Calculate Output Canvas:**\n    *   If `selected_objects_data` is empty, return a 3x3 grid filled with `background_color`.\n    *   Otherwise, collect all pixel coordinates from all objects in `selected_objects_data`.\n    *   Find the minimum bounding box (min_r, min_c, max_r, max_c) that encloses all these collected coordinates.\n    *   Calculate canvas dimensions: `H = max_r - min_r + 1`, `W = max_c - min_c + 1`.\n8.  **Create and Populate Output Grid:**\n    *   Create the output grid with dimensions `(H + 2) x (W + 2)`, filled with `background_color`.\n    *   Iterate through each object in `selected_objects_data`. For each pixel `(r, c)` in the object's coordinates list:\n        *   Calculate the target coordinates in the output grid: `out_r = r - min_r + 1`, `out_c = c - min_c + 1`.\n        *   Set `output_grid[out_r, out_c]` to the object's color.\n9.  **Return:** Return the final output grid as a list of lists.\n\"\"\"\n\ndef find_objects_and_pixels(grid: np.ndarray, ignore_color=0) -> list[dict]:\n    \"\"\"Finds all objects, returning their color, slices, and pixel coordinates.\"\"\"\n    objects_data = []\n    unique_colors = np.unique(grid)\n\n    for color in unique_colors:\n        if color == ignore_color:\n            continue\n\n        binary_mask = (grid == color)\n        labeled_array, num_features = label(binary_mask)\n\n        if num_features > 0:\n            slices = find_objects(labeled_array)\n            for i in range(num_features):\n                obj_slice = slices[i]\n                if obj_slice is None: continue\n                \n                # Find coordinates relative to the whole grid\n                coords = np.argwhere(labeled_array == (i + 1))\n                # coords is already Nx2 array of [[r1,c1], [r2,c2], ...]\n                \n                objects_data.append({\n                    'color': color,\n                    'slices': obj_slice,\n                    'pixels': coords.tolist() # Store as list of [r, c] pairs\n                })\n    return objects_data\n\ndef determine_background_color(grid: np.ndarray, content_colors: set) -> int:\n    \"\"\"Determines the background color based on grid[0,0] or frequency.\"\"\"\n    h, w = grid.shape\n    if h == 0 or w == 0: return 0 # Handle empty grid case\n\n    top_left_color = grid[0, 0]\n\n    if top_left_color in content_colors:\n        return int(top_left_color)\n    else:\n        # Flatten grid and count frequencies of content colors\n        flat_grid = grid.flatten()\n        content_pixels = [p for p in flat_grid if p in content_colors]\n        \n        if not content_pixels:\n            return 0 # Default to white if no content colors found\n\n        counts = Counter(content_pixels)\n        max_count = 0\n        modes = []\n        # Find the highest frequency\n        for color, count in counts.items():\n             if count > max_count:\n                 max_count = count\n        # Find all colors with that frequency\n        for color, count in counts.items():\n             if count == max_count:\n                  modes.append(color)\n\n        # Return the smallest color value among modes\n        return int(min(modes))\n\n\ndef is_adjacent_to_markers(obj_pixels: list[list[int]], marker_coords_set: set, grid_shape: tuple) -> bool:\n    \"\"\"Checks if any object pixel is adjacent (8-way) to any marker coordinate.\"\"\"\n    rows, cols = grid_shape\n    for r, c in obj_pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if (nr, nc) in marker_coords_set:\n                        return True\n    return False\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    if input_array.size == 0:\n        return [[0,0,0],[0,0,0],[0,0,0]] # Handle empty input\n\n    # 1. Define Color Sets\n    marker_colors = {7, 8}\n    content_colors = {1, 2, 3, 4, 5, 6, 8, 9} # Includes 8\n\n    # 2. Determine Background Color\n    background_color = determine_background_color(input_array, content_colors)\n\n    # 3. Identify All Objects\n    all_objects = find_objects_and_pixels(input_array, ignore_color=0)\n    if not all_objects:\n         return [[background_color]*3]*3 # Return 3x3 background if no objects\n\n    # 4. Identify Background Object\n    background_object_key = None # Use (color, tuple(slices)) as key? Or just slices? Let's use slices index.\n    min_r_bg, min_c_bg = float('inf'), float('inf')\n    found_bg_pixel = False\n    \n    # Find the top-leftmost coordinate of the background color\n    bg_coords = np.argwhere(input_array == background_color)\n    if bg_coords.size > 0:\n        for r, c in bg_coords:\n             if r < min_r_bg:\n                 min_r_bg = r\n                 min_c_bg = c\n                 found_bg_pixel = True\n             elif r == min_r_bg and c < min_c_bg:\n                 min_c_bg = c\n                 found_bg_pixel = True\n                 \n    # Find which object contains this specific pixel\n    if found_bg_pixel:\n         for i, obj in enumerate(all_objects):\n             if obj['color'] == background_color:\n                  # Check if the top-left background pixel is in this object's pixel list\n                  if [min_r_bg, min_c_bg] in obj['pixels']:\n                      background_object_key = i # Store index of background object\n                      break # Found it\n\n    # 5. Identify Marker Locations\n    marker_coords_list = np.argwhere(np.isin(input_array, list(marker_colors)))\n    marker_coords_set = {tuple(coord) for coord in marker_coords_list} # Set for faster lookup\n\n    # 6. Select Content Objects\n    selected_objects_data = []\n    all_selected_pixels = []\n\n    for i, obj in enumerate(all_objects):\n        # Skip if it's the designated background object\n        if i == background_object_key:\n            continue\n        # Skip if it's color 7 (pure marker)\n        if obj['color'] == 7:\n            continue\n        # Check adjacency to markers\n        if is_adjacent_to_markers(obj['pixels'], marker_coords_set, input_array.shape):\n            selected_objects_data.append(obj)\n            all_selected_pixels.extend(obj['pixels']) # Collect pixels for bounding box\n\n    # 7. Calculate Output Canvas\n    if not selected_objects_data:\n        # Handle cases like only background object exists or no objects selected\n        return [[background_color]*3]*3\n\n    # Find bounding box of all selected pixels\n    if not all_selected_pixels: # Should not happen if selected_objects_data is not empty\n         return [[background_color]*3]*3\n\n    all_selected_pixels_array = np.array(all_selected_pixels)\n    min_r = np.min(all_selected_pixels_array[:, 0])\n    max_r = np.max(all_selected_pixels_array[:, 0])\n    min_c = np.min(all_selected_pixels_array[:, 1])\n    max_c = np.max(all_selected_pixels_array[:, 1])\n\n    H = max_r - min_r + 1\n    W = max_c - min_c + 1\n    padding = 1\n\n    output_H = H + 2 * padding\n    output_W = W + 2 * padding\n\n    # 8. Create and Populate Output Grid\n    output_grid = np.full((output_H, output_W), background_color, dtype=int)\n\n    for obj in selected_objects_data:\n        obj_color = obj['color']\n        for r, c in obj['pixels']:\n            out_r = r - min_r + padding\n            out_c = c - min_c + padding\n            # Check bounds just in case (shouldn't be needed with correct logic)\n            if 0 <= out_r < output_H and 0 <= out_c < output_W:\n                 output_grid[out_r, out_c] = obj_color\n\n    # 9. Return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 33653,
    "candidates_token_count": 3361,
    "total_token_count": 37014,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 25.713997,
  "retries": 1
}