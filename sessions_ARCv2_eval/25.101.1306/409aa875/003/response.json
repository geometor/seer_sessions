{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nTransforms an input grid based on identifying and processing specific 'V' and 'L' shaped patterns.\n\nV-shape Processing:\n- Identifies V-shapes (top pixel + two diagonal bottom pixels of the same non-orange color).\n- Calculates a vertical projection distance 'k' based on the V-shape's row and its horizontal distance from the grid's center.\n- Projects the V-shape upwards by 'k' rows.\n- The projection color depends on the original V-shape color:\n    - White V-shapes project as maroon.\n    - Maroon V-shapes closest to the vertical center project as blue.\n    - Other (non-central) maroon V-shapes project as maroon.\n\nL-shape Processing (triggered only if red L-shapes exist):\n- Identifies L-shapes (3 red pixels: top-left corner, pixel right, pixel below).\n- Applies a fixed global pattern of maroon pixels in rows 1 and 9 at columns 0, 3, 6, 9.\n- Finds the minimum row containing any red L-shape.\n- Identifies the red L-shape in that minimum row which is closest to the vertical center (tie-breaking with the leftmost column).\n- Changes the three pixels composing this specific central L-shape to maroon.\n\"\"\"\n\n# Define Colors and Constants\nORANGE = 7\nMAROON = 9\nWHITE = 0\nRED = 2\nBLUE = 1\nPROJECTION_THRESHOLD_ROW = 13\nPROJECTION_K_NEAR = 6\nPROJECTION_K_FAR = 5\nPROJECTION_DIST_THRESHOLD = 5.0 # Max distance from center for row-based k logic\nL_SHAPE_GLOBAL_ROWS = [1, 9]\nL_SHAPE_GLOBAL_COLS = [0, 3, 6, 9]\n\n\ndef find_v_shapes(grid: np.ndarray, center_col: float) -> List[Dict]:\n    \"\"\"Finds all V-shapes, returning their center, color, and distance from center.\"\"\"\n    v_shapes = []\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(1, width - 1):\n            color = grid[r, c]\n            if color != ORANGE and \\\n               grid[r+1, c-1] == color and \\\n               grid[r+1, c+1] == color:\n                dist = abs(c - center_col)\n                v_shapes.append({'center': (r, c), 'color': color, 'dist': dist})\n    return v_shapes\n\ndef find_red_l_shapes(grid: np.ndarray, center_col: float) -> List[Dict]:\n    \"\"\"Finds all red L-shapes, returning corner, pixels, and distance from center.\"\"\"\n    l_shapes = []\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            if grid[r, c] == RED and \\\n               grid[r, c+1] == RED and \\\n               grid[r+1, c] == RED:\n                dist = abs(c - center_col)\n                pixels = [(r, c), (r, c+1), (r+1, c)]\n                l_shapes.append({'corner': (r, c), 'pixels': pixels, 'dist': dist})\n    return l_shapes\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n    center_col = (width - 1) / 2.0\n\n    # --- Find Shapes ---\n    v_shapes = find_v_shapes(grid, center_col)\n    red_l_shapes = find_red_l_shapes(grid, center_col)\n\n    # --- Process V-shapes ---\n    if v_shapes:\n        # Find minimum distance for maroon V-shapes to identify central ones\n        maroon_v_shapes = [v for v in v_shapes if v['color'] == MAROON]\n        min_dist_maroon = min((v['dist'] for v in maroon_v_shapes), default=float('inf'))\n\n        for v in v_shapes:\n            r, c = v['center']\n            color = v['color']\n            dist = v['dist']\n\n            # Calculate projection offset 'k'\n            k_row = PROJECTION_K_NEAR if r < PROJECTION_THRESHOLD_ROW else PROJECTION_K_FAR\n            k = PROJECTION_K_FAR if dist > PROJECTION_DIST_THRESHOLD else k_row\n            target_r = r - k\n            target_c = c\n\n            # Determine output color\n            output_color = -1 # Default invalid\n            if color == WHITE:\n                output_color = MAROON\n            elif color == MAROON:\n                if dist == min_dist_maroon: # Central maroon V-shape(s)\n                    output_color = BLUE\n                else: # Non-central maroon V-shape\n                    output_color = MAROON\n\n            # Apply the modification if valid color and within bounds\n            if output_color != -1 and 0 <= target_r < height:\n                output_grid[target_r, target_c] = output_color\n\n    # --- Process Red L-shapes ---\n    if red_l_shapes:\n        # Apply global pattern\n        for r_glob in L_SHAPE_GLOBAL_ROWS:\n            for c_glob in L_SHAPE_GLOBAL_COLS:\n                if 0 <= r_glob < height and 0 <= c_glob < width:\n                     output_grid[r_glob, c_glob] = MAROON\n\n        # Find minimum row containing red L-shapes\n        min_r = min(l['corner'][0] for l in red_l_shapes)\n\n        # Filter L-shapes to keep only those at the minimum row\n        top_row_l_shapes = [l for l in red_l_shapes if l['corner'][0] == min_r]\n\n        # Find the central L-shape among those in the minimum row\n        # Sort by distance, then by column for tie-breaking\n        top_row_l_shapes.sort(key=lambda l: (l['dist'], l['corner'][1]))\n        central_l_shape = top_row_l_shapes[0] # The first one after sorting is the target\n\n        # Modify the pixels of the central L-shape\n        for pr, pc in central_l_shape['pixels']:\n            if 0 <= pr < height and 0 <= pc < width:\n                output_grid[pr, pc] = MAROON\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16761,
    "candidates_token_count": 1960,
    "total_token_count": 18721,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.259536,
  "retries": 1
}