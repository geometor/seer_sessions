{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nTransforms an input grid based on the presence, color, and location of specific 3-pixel shapes ('V' and 'L').\n\n1.  Identifies 'V-shapes' (top pixel + two diagonal bottom pixels) and red 'L-shapes' (top-left corner + pixel right + pixel below).\n2.  Processes V-shapes:\n    - White V-shapes trigger a maroon pixel placed vertically above, with the distance determined by the V-shape's row.\n    - The maroon V-shape closest to the grid's vertical center triggers a blue pixel placed vertically above, with the distance determined by its row.\n3.  Processes red L-shapes:\n    - If any red L-shapes exist, a fixed global pattern of maroon pixels is placed in rows 1 and 9.\n    - Additionally, pairs of red L-shapes on the *minimum* row containing L-shapes, horizontally spaced by 4 columns, trigger filling the 3-pixel gap between them with maroon pixels.\n\"\"\"\n\ndef find_v_shapes(grid: np.ndarray) -> List[Dict]:\n    \"\"\"Finds all V-shapes in the grid.\"\"\"\n    v_shapes = []\n    height, width = grid.shape\n    orange = 7\n    for r in range(height - 1):\n        for c in range(1, width - 1):\n            color = grid[r, c]\n            if color != orange and \\\n               grid[r+1, c-1] == color and \\\n               grid[r+1, c+1] == color:\n                v_shapes.append({'center': (r, c), 'color': color})\n    return v_shapes\n\ndef find_red_l_shapes(grid: np.ndarray) -> List[Dict]:\n    \"\"\"Finds all red L-shapes in the grid.\"\"\"\n    l_shapes = []\n    height, width = grid.shape\n    red = 2\n    for r in range(height - 1):\n        for c in range(width - 1):\n            if grid[r, c] == red and \\\n               grid[r, c+1] == red and \\\n               grid[r+1, c] == red:\n                l_shapes.append({'corner': (r, c)})\n    return l_shapes\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n    \n    # Colors\n    white = 0\n    blue = 1\n    red = 2\n    maroon = 9\n\n    # Find shapes\n    v_shapes = find_v_shapes(grid)\n    red_l_shapes = find_red_l_shapes(grid)\n\n    # --- Process V-shapes ---\n    maroon_v_shapes = [v for v in v_shapes if v['color'] == maroon]\n    white_v_shapes = [v for v in v_shapes if v['color'] == white]\n\n    # Process white V-shapes\n    for v in white_v_shapes:\n        r, c = v['center']\n        k = 6 if r < 13 else 5\n        target_r = r - k\n        if 0 <= target_r < height:\n            output_grid[target_r, c] = maroon # Change to maroon\n\n    # Process the central maroon V-shape\n    if maroon_v_shapes:\n        center_col = (width - 1) / 2.0\n        min_dist = float('inf')\n        central_v = None\n        \n        # Find the V-shape closest to the vertical center\n        # If tied, potentially prioritize lower row or lower col, but example 1 only has one clear candidate.\n        # Let's assume only one qualifies if multiple are equidistant.\n        candidates = []\n        for v in maroon_v_shapes:\n            r, c = v['center']\n            dist = abs(c - center_col)\n            candidates.append((dist, r, c, v))\n        \n        candidates.sort() # Sort by distance, then row, then col\n        \n        if candidates:\n             # Check if the closest is uniquely closest or tied\n             closest_dist = candidates[0][0]\n             num_closest = sum(1 for cand in candidates if cand[0] == closest_dist)\n\n             # Apply transformation only if it's uniquely the closest *or* if it's the first among equals based on sort order\n             # The logic seems to target a single central point based on example 1\n             # For simplicity and matching ex1, we'll just take the first one after sorting.\n             _, r, c, central_v = candidates[0]\n             k = 6 if r < 13 else 5\n             target_r = r - k\n             if 0 <= target_r < height:\n                 output_grid[target_r, c] = blue # Change to blue\n\n    # --- Process Red L-shapes ---\n    if red_l_shapes:\n        # Apply global pattern\n        global_pattern_coords = [(1, 0), (1, 3), (1, 6), (1, 9),\n                                 (9, 0), (9, 3), (9, 6), (9, 9)]\n        for r_glob, c_glob in global_pattern_coords:\n            if 0 <= r_glob < height and 0 <= c_glob < width:\n                 output_grid[r_glob, c_glob] = maroon\n\n        # Find minimum row containing red L-shapes\n        min_r = min(l['corner'][0] for l in red_l_shapes)\n\n        # Find L-shapes at the minimum row\n        top_row_l_shapes = [l for l in red_l_shapes if l['corner'][0] == min_r]\n        top_row_l_shapes.sort(key=lambda l: l['corner'][1]) # Sort by column\n\n        # Apply gap filling for pairs separated by 4 columns\n        shape_corners = {l['corner'][1]: l for l in top_row_l_shapes} # Map column to shape for quick lookup\n        for l_shape in top_row_l_shapes:\n            r1, c1 = l_shape['corner']\n            c2 = c1 + 4\n            # Check if a corresponding L-shape exists 4 columns to the right\n            if c2 in shape_corners:\n                # Fill the gap between them\n                fill_c = c1 + 3\n                if 0 <= fill_c < width:\n                    output_grid[r1, fill_c] = maroon\n                    if r1 + 1 < height:\n                         output_grid[r1 + 1, fill_c] = maroon\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5933,
    "candidates_token_count": 2902,
    "total_token_count": 8835,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.021638,
  "retries": 1
}