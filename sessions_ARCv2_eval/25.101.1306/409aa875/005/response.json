{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Tuple\n\n\"\"\"\nTransforms an input grid based on identifying and processing specific 'V' and 'L' shaped patterns.\n\nV-shape Processing:\n1. Identifies V-shapes: three pixels of the same non-orange color C arranged as (r, c), (r+1, c-1), (r+1, c+1).\n2. Calculates the horizontal distance of the center pixel (r, c) from the grid's vertical center line.\n3. Determines if a maroon V-shape is 'central' (has the minimum distance among all maroon V-shapes).\n4. Projects the V-shape vertically upwards by a fixed distance (k=5).\n5. The color of the projected pixel depends on the original V-shape:\n   - White V-shapes project as maroon.\n   - Central maroon V-shapes project as blue.\n   - Non-central maroon V-shapes project as maroon.\n\nL-shape Processing (triggered only if red L-shapes exist):\n1. Identifies L-shapes: three red pixels arranged as (r, c), (r, c+1), (r+1, c).\n2. Applies a fixed global pattern: sets pixels at specific coordinates in rows 1 and 9 to maroon.\n3. Finds the minimum row ('min_r') containing any red L-shape corner (r, c).\n4. Identifies the red L-shape in 'min_r' that is closest to the grid's vertical center line (tie-breaking using the leftmost column).\n5. Changes the three pixels composing this specific central L-shape to maroon.\n\"\"\"\n\n# --- Constants ---\nORANGE = 7\nMAROON = 9\nWHITE = 0\nRED = 2\nBLUE = 1\nV_SHAPE_PROJECTION_K = 5  # Constant vertical offset for V-shapes\nL_SHAPE_GLOBAL_ROWS = [1, 9]\nL_SHAPE_GLOBAL_COLS = [0, 3, 6, 9]\n\n\ndef find_v_shapes(grid: np.ndarray, center_col: float) -> List[Dict]:\n    \"\"\"\n    Finds all V-shapes in the grid.\n\n    A V-shape consists of 3 pixels of the same non-orange color C\n    at (r, c), (r+1, c-1), (r+1, c+1).\n\n    Returns a list of dictionaries, each containing:\n        'center': (r, c) tuple\n        'color': C (integer color value)\n        'dist': Absolute horizontal distance of 'c' from 'center_col'\n    \"\"\"\n    v_shapes = []\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(1, width - 1):\n            color = grid[r, c]\n            # Check if the pixel is not the background color and forms a V-shape\n            if color != ORANGE and \\\n               grid[r+1, c-1] == color and \\\n               grid[r+1, c+1] == color:\n                dist = abs(c - center_col)\n                v_shapes.append({'center': (r, c), 'color': color, 'dist': dist})\n    return v_shapes\n\n\ndef find_red_l_shapes(grid: np.ndarray, center_col: float) -> List[Dict]:\n    \"\"\"\n    Finds all red L-shapes in the grid.\n\n    An L-shape consists of 3 red pixels at (r, c), (r, c+1), (r+1, c).\n\n    Returns a list of dictionaries, each containing:\n        'corner': (r, c) tuple (top-left pixel)\n        'pixels': List of coordinates [(r, c), (r, c+1), (r+1, c)]\n        'dist': Absolute horizontal distance of 'c' from 'center_col'\n    \"\"\"\n    l_shapes = []\n    height, width = grid.shape\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Check if the pixels form a red L-shape\n            if grid[r, c] == RED and \\\n               grid[r, c+1] == RED and \\\n               grid[r+1, c] == RED:\n                dist = abs(c - center_col)\n                pixels = [(r, c), (r, c+1), (r+1, c)]\n                l_shapes.append({'corner': (r, c), 'pixels': pixels, 'dist': dist})\n    return l_shapes\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid based on V and L shapes.\n    \"\"\"\n    # Initialize grid and constants\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n    center_col = (width - 1) / 2.0\n\n    # --- Find Shapes ---\n    v_shapes = find_v_shapes(grid, center_col)\n    red_l_shapes = find_red_l_shapes(grid, center_col)\n\n    # --- Process V-shapes ---\n    if v_shapes:\n        # Find minimum distance for maroon V-shapes to identify central ones\n        maroon_v_shapes = [v for v in v_shapes if v['color'] == MAROON]\n        min_dist_maroon = min((v['dist'] for v in maroon_v_shapes), default=float('inf'))\n\n        # Iterate through all found V-shapes\n        for v in v_shapes:\n            r, c = v['center']\n            color = v['color']\n            dist = v['dist']\n\n            # Calculate target coordinates using the constant projection distance\n            target_r = r - V_SHAPE_PROJECTION_K\n            target_c = c\n\n            # Determine output color based on input color and centrality\n            output_color = -1 # Default invalid color\n            if color == WHITE:\n                output_color = MAROON\n            elif color == MAROON:\n                if dist == min_dist_maroon: # Central maroon V-shape(s)\n                    output_color = BLUE\n                else: # Non-central maroon V-shape\n                    output_color = MAROON\n\n            # Apply the modification if the color is valid and target is within grid bounds\n            if output_color != -1 and 0 <= target_r < height:\n                output_grid[target_r, target_c] = output_color\n\n    # --- Process Red L-shapes ---\n    if red_l_shapes:\n        # 1. Apply global pattern\n        for r_glob in L_SHAPE_GLOBAL_ROWS:\n            for c_glob in L_SHAPE_GLOBAL_COLS:\n                if 0 <= r_glob < height and 0 <= c_glob < width:\n                     output_grid[r_glob, c_glob] = MAROON\n\n        # 2. Find minimum row containing red L-shapes\n        min_r = min(l['corner'][0] for l in red_l_shapes)\n\n        # 3. Filter L-shapes to keep only those at the minimum row\n        top_row_l_shapes = [l for l in red_l_shapes if l['corner'][0] == min_r]\n\n        # 4. Find the central L-shape among those in the minimum row\n        # Sort by distance, then by column index for tie-breaking\n        top_row_l_shapes.sort(key=lambda l: (l['dist'], l['corner'][1]))\n        central_l_shape = top_row_l_shapes[0] # The first one after sorting is the target\n\n        # 5. Modify the pixels of the central L-shape to maroon\n        for pr, pc in central_l_shape['pixels']:\n            if 0 <= pr < height and 0 <= pc < width:\n                output_grid[pr, pc] = MAROON\n\n    # Convert back to list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27385,
    "candidates_token_count": 2282,
    "total_token_count": 29667,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.958273,
  "retries": 1
}