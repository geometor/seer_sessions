{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nThis module transforms an input grid based on the colors and arrangements of specific structures. \n\nThe transformation logic distinguishes between two main cases based on the colors of 'base' objects found beneath 'upper structures' (composed of blue and red pixels):\n\n1. Swap Case: If both Green (3) and Azure (8) bases are present in the input:\n    - All Green bases are changed to Azure.\n    - All Azure bases are changed to Green.\n    - Pixels directly below Red (2) components of the upper structures change color based on the *original* color of the base below them:\n        - If the original base was Green, the pixel below Red becomes Azure.\n        - If the original base was Azure, the pixel below Red becomes Red.\n\n2. Trigger Case: If the Swap Case condition is not met:\n    - Identify 'trigger pixels' - isolated single pixels that are not part of the background, upper structures, or bases.\n    - If trigger pixels exist (assuming they all share the same color, the 'TargetColor'):\n        - All identified bases (regardless of their original color) are changed to the TargetColor.\n        - All trigger pixels are changed to the background color.\n    - If no trigger pixels exist, the grid remains unchanged.\n\nThe background color is determined as the most frequent color in the grid.\nObjects are identified as contiguous blocks of non-background colors.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int) -> list[tuple[int, set[tuple[int, int]]]]:\n    \"\"\"Finds connected components (objects) of non-background colors.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.pop(0)\n                    # Check if pixel color matches the starting color of the object\n                    # This handles cases where BFS might cross into a different colored adjacent pixel\n                    # that hasn't been visited yet as part of another object search.\n                    if grid[row, col] == color:\n                         obj_pixels.add((row, col))\n                         # Explore neighbors (4-connectivity)\n                         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    # Mark as visited even if color doesn't match the *initial* object color, \n                    # to prevent reprocessing if it's a different non-background color.\n                    # The color check above ensures only same-colored pixels are added to the *current* object.\n                    visited[r,c] = True \n\n                if obj_pixels:\n                    objects.append((color, obj_pixels))\n    return objects\n\ndef get_bounding_box(pixels: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the min/max row/col for a set of pixels.\"\"\"\n    if not pixels:\n        return 0, 0, 0, 0\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Identify the background color\n    colors, counts = np.unique(grid, return_counts=True)\n    background_color = colors[np.argmax(counts)]\n\n    # 2. Find all non-background objects\n    all_objects = find_objects(grid, background_color)\n\n    # 3. Identify upper structures and their bases\n    upper_structures = [] # List of tuples: (structure_pixels, red_pixels)\n    bases = [] # List of tuples: (base_color, base_pixels, associated_upper_structure_index)\n    potential_triggers = [] # List of tuples: (color, pixels)\n    \n    processed_pixels = set() # Keep track of pixels belonging to structures or bases\n\n    # First pass: Identify potential upper structures (contain blue and red)\n    struct_candidates = []\n    other_objects = []\n    for color, pixels in all_objects:\n        contains_blue = any(grid[r,c] == 1 for r,c in pixels)\n        contains_red = any(grid[r,c] == 2 for r,c in pixels)\n        \n        # Check if it contains *only* blue and red (or just one of them)\n        is_pure_struct_colors = all(grid[r,c] in [1, 2] for r,c in pixels)\n\n        # A structure must contain blue or red, and only consist of blue/red\n        if (contains_blue or contains_red) and is_pure_struct_colors:\n             struct_candidates.append(pixels)\n        else:\n             other_objects.append((color, pixels))\n\n    # Second pass: Find bases below structures and identify triggers\n    base_colors_found = []\n    struct_pixels_all = set().union(*struct_candidates)\n\n    for i, struct_pixels in enumerate(struct_candidates):\n        processed_pixels.update(struct_pixels)\n        min_r, max_r, min_c, max_c = get_bounding_box(struct_pixels)\n        red_pixels_in_struct = {p for p in struct_pixels if grid[p] == 2}\n        \n        found_base = False\n        # Look for a base directly below the structure\n        for r_offset in range(1, rows - max_r): # Search downwards\n             potential_base_row = max_r + r_offset\n             base_candidate_pixels = set()\n             \n             # Check pixels directly below the lowest part of the structure\n             pixels_to_check_below = {(max_r + 1, c) for r, c in struct_pixels if r == max_r}\n             \n             connected_base_pixels = set()\n             q = []\n\n             # Find starting points for potential base connected to the structure\n             for br, bc in pixels_to_check_below:\n                 if 0 <= br < rows and 0 <= bc < cols and grid[br, bc] != background_color and grid[br, bc] not in [1, 2]:\n                     # Check if this pixel belongs to any known object in other_objects\n                     for obj_color, obj_pixels in other_objects:\n                         if (br, bc) in obj_pixels:\n                            # Found a potential base object, add all its pixels\n                            connected_base_pixels.update(obj_pixels)\n                            base_colors_found.append(obj_color)\n                            bases.append((obj_color, obj_pixels, i)) # Store original color\n                            processed_pixels.update(obj_pixels)\n                            upper_structures.append((struct_pixels, red_pixels_in_struct))\n                            found_base = True\n                            break # Found the base for this structure\n                 if found_base:\n                     break\n             if found_base:\n                 break # Stop searching downwards once a base is found\n\n        # If no base was found, it's just a structure without a base\n        if not found_base:\n             upper_structures.append((struct_pixels, red_pixels_in_struct))\n\n\n    # Identify triggers: single non-background pixels not part of structures or bases\n    trigger_pixels = []\n    trigger_locations = set()\n    trigger_color = -1 \n\n    # Re-evaluate other_objects now that bases are identified and processed\n    remaining_objects = []\n    for color, pixels in other_objects:\n        if not pixels.intersection(processed_pixels): # Check if any part was claimed as a base\n             remaining_objects.append((color, pixels))\n             \n    for color, pixels in remaining_objects:\n         if len(pixels) == 1: # Must be a single pixel\n              # Check if it's adjacent (including diagonals) to any structure or base pixel\n              is_adjacent = False\n              px, py = list(pixels)[0]\n              for dr in [-1, 0, 1]:\n                   for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0: continue\n                        adj_r, adj_c = px + dr, py + dc\n                        if (adj_r, adj_c) in processed_pixels:\n                             is_adjacent = True\n                             break\n                   if is_adjacent: break\n              \n              if not is_adjacent: # Only count if truly isolated from identified structures/bases\n                  trigger_pixels.append((color, pixels))\n                  trigger_locations.update(pixels)\n                  if trigger_color == -1:\n                       trigger_color = color\n                  elif trigger_color != color:\n                       # Assumption violated: multiple trigger colors. Handle error or refine logic.\n                       # For now, we'll proceed assuming the first one found dictates the color.\n                       pass \n    \n    # 4. Determine Transformation Case\n    is_swap_case = (3 in base_colors_found and 8 in base_colors_found)\n\n    # 5. Apply Transformations\n    if is_swap_case:\n        print(\"Applying Swap Case\")\n        pixels_below_red_map = {} # (r, c) -> original_base_color\n        # First pass: identify changes for bases and pixels below red\n        base_changes = {} # original_base_index -> new_color\n        pixels_below_red_changes = {} # (r,c) -> new_color\n        \n        for base_idx, (original_color, base_pixels, struct_idx) in enumerate(bases):\n            struct_pixels, red_pixels_in_struct = upper_structures[struct_idx]\n            new_base_color = -1\n            if original_color == 3:\n                new_base_color = 8\n                base_changes[base_idx] = 8\n            elif original_color == 8:\n                new_base_color = 3\n                base_changes[base_idx] = 3\n            else: # Other base colors remain unchanged in swap case\n                 pass\n\n            # Determine changes for pixels directly below red parts\n            for r_red, c_red in red_pixels_in_struct:\n                pixel_below = (r_red + 1, c_red)\n                if 0 <= pixel_below[0] < rows and 0 <= pixel_below[1] < cols:\n                    # Check if this pixel_below belongs to the current base we're processing\n                    if pixel_below in base_pixels:\n                        if original_color == 3:\n                            pixels_below_red_changes[pixel_below] = 8 # Green base -> Azure below red\n                        elif original_color == 8:\n                            pixels_below_red_changes[pixel_below] = 2 # Azure base -> Red below red\n\n        # Second pass: apply changes to output_grid\n        for base_idx, new_color in base_changes.items():\n            _, base_pixels, _ = bases[base_idx]\n            for r, c in base_pixels:\n                 # Only change if not overridden by a pixel_below_red rule\n                 if (r,c) not in pixels_below_red_changes:\n                      output_grid[r, c] = new_color\n\n        for (r,c), new_color in pixels_below_red_changes.items():\n             output_grid[r, c] = new_color\n             \n    elif trigger_pixels: # Trigger Case\n        print(f\"Applying Trigger Case with TargetColor={trigger_color}\")\n        target_color = trigger_color\n\n        # Change all bases to target color\n        for _, base_pixels, _ in bases:\n            for r, c in base_pixels:\n                output_grid[r, c] = target_color\n\n        # Change trigger pixels to background color\n        for _, pixels in trigger_pixels:\n             for r, c in pixels:\n                 output_grid[r, c] = background_color\n                 \n    else: # No swap, no triggers\n        print(\"No swap condition and no triggers found. No changes applied.\")\n        pass # Output grid remains same as input grid copy\n\n    # Note: The anomaly in train_2 (new yellow pixel) is not handled by this logic.\n\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5348,
    "candidates_token_count": 3874,
    "total_token_count": 9222,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 32.951419,
  "retries": 1
}