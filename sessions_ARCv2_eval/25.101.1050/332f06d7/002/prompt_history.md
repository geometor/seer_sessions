
## train_1

**input:**
```
3 2 2 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 0 0 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 0 0 3 3 3 3 3 3 3 3 3
3 0 0 3 3 3 3 3 3 3 3 3
3 1 1 3 3 3 3 3 3 3 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 1 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 3 3
3 1 1 3 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 1 1 1 1 3
3 1 1 1 1 1 3 3 1 1 3 3
3 1 1 1 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 1 1 3 3
3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 1 1 1 0 0 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 1 1 1 1 1 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 1 1 1 1 1 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 3 3 3 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 1 1 1 0 0 3 3 3 3
3 3 3 3 3 3 3 3 3 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 1 1 1 1 1 1 1 1 1 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
3 2 2 3 3 3 3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 1 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 0 0 0 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 3
2 2 2 1 1 1 1 3 3 1 1 1 1 1 1 3
2 2 2 1 1 3 3 3 3 3 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 3
3 3 3 1 1 1 1 1 1 1 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 3 1 1 1 1 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 0 0 0 3 3 3 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 1 3 1 1 3 3 3 1 1 1 3
3 3 1 1 1 3 3 1 1 3 3 3 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 1 1 1 1 3 3 1 1 1 1 1 1 1 1 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
3 3 3 3 3 3 3 3 3 3
3 0 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 2 3 3 3 3 3
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
3 1 1 1 3 3 3 3 3 3
3 3 3 1 3 1 1 1 3 3
3 3 3 1 3 1 3 1 3 3
3 3 3 1 1 1 3 1 3 3
3 3 3 3 3 3 3 1 3 3
3 3 3 3 1 1 1 1 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 1 3 3 3 3 3
3 3 3 3 0 3 3 3 3 3
```

Okay, let's analyze the task examples.

**Perception of the elements:**

The task involves transforming input grids containing pixels of different colors: green (3), red (2), blue (1), and white (0). The transformation rule appears to depend on the presence and configuration of red (2) pixels. Specifically, the presence or absence of a 3x3 square block composed entirely of red pixels dictates how other colors change.

1.  **Conditional Logic:** There seem to be two main modes of operation. The trigger condition is whether a 3x3 block of red (2) pixels exists anywhere in the input grid.
2.  **Color Swaps:**
    *   White (0) pixels consistently change to blue (1) pixels in all examples.
    *   Red (2) pixels either change to white (0) or remain unchanged, depending on the trigger condition.
    *   Blue (1) pixels either remain unchanged or, under specific conditions (related to the trigger), certain configurations of blue pixels (specifically 3x3 blocks) change to white (0).
3.  **Key Objects:** The primary objects are individual pixels identified by their color and location. A significant derived object is the "3x3 block" of a single color (specifically red and blue).
4.  **Background:** Green (3) pixels seem to act as a background or frame color and are generally unaffected by the transformation rules, except when they are part of the objects being transformed (which doesn't happen in these examples).

**YAML Facts:**


```yaml
task_context:
  description: Transforms grid colors based on the presence or absence of a specific pattern (3x3 red block).
  colors_involved: [white(0), blue(1), red(2), green(3)]
  key_pattern:
    type: block
    shape: 3x3
    color: red(2)
  conditional_branches: 2

branch_1:
  condition: A 3x3 block of red(2) pixels EXISTS in the input grid.
  actions:
    - object: all white(0) pixels
      action: change_color
      to_color: blue(1)
    - object: all 3x3 blocks of blue(1) pixels
      action: change_color
      to_color: white(0)
    - object: all red(2) pixels
      action: remain_unchanged
    - object: all green(3) pixels
      action: remain_unchanged

branch_2:
  condition: A 3x3 block of red(2) pixels DOES NOT EXIST in the input grid.
  actions:
    - object: all white(0) pixels
      action: change_color
      to_color: blue(1)
    - object: all red(2) pixels
      action: change_color
      to_color: white(0)
    - object: all blue(1) pixels
      action: remain_unchanged
    - object: all green(3) pixels
      action: remain_unchanged
```


**Natural Language Program:**

1.  Examine the input grid to determine if there is any 3x3 square block composed entirely of red (2) pixels.
2.  **If a 3x3 red block exists:**
    a.  Create the output grid by copying the input grid.
    b.  Change all white (0) pixels in the output grid to blue (1).
    c.  Identify all 3x3 square blocks composed entirely of blue (1) pixels in the output grid. Change all pixels within these 3x3 blue blocks to white (0).
    d.  Leave all red (2) and green (3) pixels unchanged (unless they were part of a 3x3 blue block identified in step 2c, which is unlikely based on examples but possible).
3.  **If no 3x3 red block exists:**
    a.  Create the output grid by copying the input grid.
    b.  Change all white (0) pixels in the output grid to blue (1).
    c.  Change all red (2) pixels in the output grid to white (0).
    d.  Leave all blue (1) and green (3) pixels unchanged.
4.  Return the modified output grid.
```python
import numpy as np
from typing import List

"""
Transformation Rule:

The transformation depends on whether a 3x3 block of red (2) pixels exists in the input grid.

1. Check for 3x3 Red Block: Scan the input grid to find if any 3x3 area consists entirely of red (2) pixels.

2. Conditional Transformation:
   a. If a 3x3 red block IS found:
      i. Initialize the output grid as a copy of the input grid.
      ii. Identify the top-left coordinates of all 3x3 blocks in the *input* grid that consist entirely of blue (1) pixels.
      iii. Change all white (0) pixels in the output grid to blue (1).
      iv. For each identified 3x3 blue block location from step (ii), change the corresponding 3x3 area in the *output* grid to white (0).
   b. If a 3x3 red block IS NOT found:
      i. Initialize the output grid as a copy of the input grid.
      ii. Change all white (0) pixels in the output grid to blue (1).
      iii. Change all red (2) pixels in the output grid to white (0).

3. Return the modified output grid.
"""

def find_3x3_block(grid: np.ndarray, color: int) -> bool:
    """
    Checks if a 3x3 block of the specified color exists in the grid.

    Args:
        grid: The input grid as a NumPy array.
        color: The color to search for (integer 0-9).

    Returns:
        True if a 3x3 block of the specified color is found, False otherwise.
    """
    height, width = grid.shape
    for r in range(height - 2):
        for c in range(width - 2):
            subgrid = grid[r:r+3, c:c+3]
            if np.all(subgrid == color):
                return True
    return False

def find_all_3x3_block_coords(grid: np.ndarray, color: int) -> List[tuple[int, int]]:
    """
    Finds the top-left coordinates of all 3x3 blocks of the specified color.

    Args:
        grid: The input grid as a NumPy array.
        color: The color to search for.

    Returns:
        A list of (row, col) tuples representing the top-left corners.
    """
    coords = []
    height, width = grid.shape
    for r in range(height - 2):
        for c in range(width - 2):
            subgrid = grid[r:r+3, c:c+3]
            if np.all(subgrid == color):
                coords.append((r, c))
    return coords

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid based on the presence of a 3x3 red block.

    Args:
        input_grid: A list of lists representing the input grid.

    Returns:
        A list of lists representing the transformed output grid.
    """
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array)
    height, width = input_array.shape

    # Check if a 3x3 block of red (2) exists
    has_red_3x3 = find_3x3_block(input_array, 2)

    if has_red_3x3:
        # Branch 1: 3x3 red block exists
        
        # Find locations of original 3x3 blue blocks first
        blue_3x3_coords = find_all_3x3_block_coords(input_array, 1)

        # Change white (0) to blue (1) in the output
        output_array[input_array == 0] = 1
        
        # Change original 3x3 blue blocks to white (0) in the output
        for r, c in blue_3x3_coords:
            output_array[r:r+3, c:c+3] = 0
            
    else:
        # Branch 2: No 3x3 red block exists
        
        # Change white (0) to blue (1)
        output_array[input_array == 0] = 1
        
        # Change red (2) to white (0)
        output_array[input_array == 2] = 0

    # Convert back to list of lists and return
    return output_array.tolist()
```
