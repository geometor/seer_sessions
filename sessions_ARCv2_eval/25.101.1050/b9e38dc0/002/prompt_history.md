
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 1 1 9 1 1 1 3 1 1
1 1 1 1 3 1 1 1 1 3 3 3 1 1 1
1 1 1 1 3 1 1 1 3 1 1 1 1 1 1
1 1 1 1 1 3 1 1 3 1 1 1 1 1 1
1 1 1 1 1 1 3 1 1 3 1 1 1 1 1
1 1 1 1 1 3 1 1 1 1 3 1 1 1 1
1 1 1 1 3 1 1 1 1 1 1 3 1 1 1
1 1 1 1 1 1 1 5 5 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 3 3 3 3 3 3 1 1 1
1 1 1 1 1 3 9 9 9 9 9 9 3 1 1
1 1 1 1 3 9 9 9 9 3 3 3 1 1 1
1 1 1 1 3 9 9 9 3 1 1 1 1 1 1
1 1 1 1 1 3 9 9 3 1 1 1 1 1 1
1 1 1 1 1 1 3 9 9 3 1 1 1 1 1
1 1 1 1 1 3 9 9 9 9 3 1 1 1 1
1 1 1 1 3 9 9 9 9 9 9 3 1 1 1
1 1 1 1 9 9 9 5 5 9 9 9 1 1 1
1 1 1 9 9 9 9 1 1 9 9 9 9 1 1
1 1 9 9 9 9 9 1 1 9 9 9 9 9 1
1 9 9 9 9 9 9 1 1 9 9 9 9 9 9
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 5 5 5 0
0 0 0 0 0 0 0 0 5 0 5 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 4 5 0
0 0 0 0 0 0 0 0 0 0 0 0 0 5 0
0 0 0 0 0 0 0 0 0 5 0 0 0 5 0
0 0 0 0 0 0 0 0 5 0 5 5 5 5 0
```


**output:**
```
4 4 4 4 4 0 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 5 0 0 0 5 5 5 0
4 4 4 4 4 4 4 4 5 0 5 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 4 4 4 4 4 5 0
4 4 4 4 4 4 4 4 4 5 4 4 4 5 0
4 4 4 4 4 4 4 4 5 0 5 5 5 5 0
```


## train_3

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 6 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 9 7 7 7 7 7 9 7 7 7 7 7
7 7 7 7 9 7 7 6 7 7 9 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 9 7 7 7 9 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 7 9 7 7 7 7 7 7 7
7 7 7 7 7 9 7 7 9 9 9 7 7 7 7 7
7 7 7 7 9 7 7 7 7 3 9 7 7 7 7 7
7 7 7 7 9 7 7 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 7 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 3 3 7 3 7 3 3 3 3 7 7 7 7
7 7 7 7 3 6 3 7 3 3 3 7 7 7 7 7
7 7 7 7 3 3 3 7 3 3 3 7 7 7 7 7
7 7 7 7 9 3 3 7 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 6 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 7 9 3 9 7 7 7 7 7 7 7
7 7 7 7 7 9 3 3 9 9 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 9 3 3 3 3 3 9 7 7 7 7 7
7 7 7 7 7 9 3 3 3 9 7 7 7 7 7 7
7 7 7 7 7 7 9 9 9 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 6 7 7
7 7 6 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 8 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

*   **Perception**: The task involves identifying specific regions within a grid and performing a "fill" operation based on the colors present. There seem to be three key color roles: a 'background' color that gets overwritten, a 'fill' color that serves as the starting point (seed) and the replacement color, and 'boundary' colors that limit the extent of the fill. The exact nature of the fill (e.g., standard flood fill vs. directional fill) can vary between examples.

*   **YAML Facts**:
    
```yaml
    task_type: grid_transformation
    transformation_type: conditional_fill
    components:
      - role: background_color
        description: The color of pixels eligible to be filled. Changes between input and output within specific regions.
        examples:
          - train_1: blue (1)
          - train_2: white (0)
          - train_3: orange (7)
      - role: fill_color
        description: The color used to fill the background pixels. Also serves as the starting seed(s) for the fill. Present in small amounts in the input, expands in the output.
        examples:
          - train_1: maroon (9)
          - train_2: yellow (4)
          - train_3: green (3)
      - role: boundary_colors
        description: Colors that block the fill operation. They remain unchanged between input and output and define the limits of the filled area.
        examples:
          - train_1: [green (3), gray (5)]
          - train_2: [gray (5)]
          - train_3: [maroon (9), magenta (6), azure (8)] # All non-background, non-fill colors act as boundaries
      - role: fill_mechanism
        description: The method by which the fill propagates from the seed(s).
        types:
          - flood_fill_4_way: Propagates up, down, left, right to adjacent background pixels. Stops at boundaries or grid edges. (e.g., train_1, train_3)
          - directional_fill_left: Propagates only leftwards to adjacent background pixels. Stops at boundaries or grid edges. (e.g., train_2)
    process_overview:
      - Identify background, fill, and boundary colors by comparing input and output.
      - Locate initial seed pixels (fill color) in the input.
      - Determine the appropriate fill mechanism (flood fill or directional).
      - Execute the fill starting from seeds, replacing background pixels with the fill color, respecting boundaries.
    ```


*   **Natural Language Program**:
    1.  Compare the input and output grids to identify the background color (changes), the fill color (replaces background, starts small), and boundary colors (unchanged, contain the fill).
    2.  Create a copy of the input grid to serve as the working output grid.
    3.  Find the coordinates of all pixels in the input grid that have the fill color (these are the initial seeds).
    4.  Determine the fill type:
        *   If the fill expands outwards in multiple directions (like train_1 and train_3), use a 4-directional flood fill. Initialize a queue with the seed coordinates.
        *   If the fill expands primarily leftwards (like train_2), use a directional left-fill mechanism.
    5.  Execute the fill:
        *   **For Flood Fill:** While the queue is not empty, remove a coordinate `(r, c)`. For each neighbor `(nr, nc)` (up, down, left, right): if the neighbor is within bounds and its color in the working output grid is the background color, change its color to the fill color and add `(nr, nc)` to the queue.
        *   **For Directional Left-Fill:** Repeatedly scan the grid. In each scan, if a pixel `(r, c)` has the fill color and the pixel to its left `(r, c-1)` exists and has the background color, change `(r, c-1)` to the fill color. Continue scanning until a full scan makes no changes.
    6.  Return the final working output grid.
```python
import collections
import numpy as np
from collections import Counter

"""
Identifies the background color, fill color, and boundary colors based on frequency and adjacency.
Performs a fill operation starting from pixels with the fill color.
The fill type is determined by the background color:
- If the background color is 0 (white), a leftward directional fill is performed.
- Otherwise, a 4-directional flood fill is performed.
The fill replaces background-colored pixels with the fill color, stopping at boundary colors or grid edges.

Color Identification Heuristic:
1. Background Color: The most frequent color in the input grid.
2. Interface Colors: Colors adjacent (4-way) to any background pixel.
3. Fill Color: The interface color with the minimum frequency (count) in the input grid.
4. Boundary Colors: All colors present in the input grid except for the background and fill colors.
"""

def get_neighbors(r, c, height, width):
    """Generates valid 4-way neighbors for a given cell."""
    neighbors = []
    if r > 0: neighbors.append((r - 1, c))
    if r < height - 1: neighbors.append((r + 1, c))
    if c > 0: neighbors.append((r, c - 1))
    if c < width - 1: neighbors.append((r, c + 1))
    return neighbors

def flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):
    """Performs a 4-directional flood fill."""
    height = len(grid)
    width = len(grid[0])
    q = collections.deque(start_coords)
    
    # Mark initial seeds as filled if they are on background color 
    # (though typically seeds are already fill_color)
    # Add seeds to queue regardless to start the process.
    processed_seeds = set()
    
    while q:
        r, c = q.popleft()
        
        # Process neighbors
        for nr, nc in get_neighbors(r, c, height, width):
            if grid[nr][nc] == background_color:
                grid[nr][nc] = fill_color
                q.append((nr, nc))
                
    return grid


def left_fill(grid, start_coords, fill_color, background_color, boundary_colors):
    """Performs a directional fill propagating only leftwards."""
    height = len(grid)
    width = len(grid[0])
    
    changed = True
    while changed:
        changed = False
        # Iterate from right to left, top to bottom might be more intuitive for left fill propagation
        for r in range(height):
            for c in range(width): 
                # If a pixel to the right has the fill color, and this pixel is background
                if grid[r][c] == background_color:
                    if c < width - 1 and grid[r][c+1] == fill_color:
                         grid[r][c] = fill_color
                         changed = True
                    # Also consider the case where the initial seed triggers the fill
                    # This check ensures pixels left of initial seeds are filled
                    # Redundant if initial seeds are correctly handled? Let's test.
                    # Simplified: propagate from existing fill_color pixels leftwards.
                    
    # Second pass to ensure propagation from original seeds works correctly
    # The previous loop might only work if a fill_color pixel exists to the right.
    # Need to propagate from initial seeds too.
    
    # Reset and use a different approach: Scan repeatedly leftwards from any fill_color pixel.
    
    # Create a working copy to avoid issues with loop order
    new_grid = [row[:] for row in grid] 
    
    changed = True
    while changed:
        changed = False
        current_grid = [row[:] for row in new_grid] # snapshot before pass
        for r in range(height):
            for c in range(1, width): # Start from second column
                # If the pixel to the right is fill_color and current is background
                if current_grid[r][c] == background_color and current_grid[r][c-1] == fill_color:
                    if new_grid[r][c] != fill_color: # check if already changed in this pass
                         new_grid[r][c] = fill_color
                         changed = True
                         
    # The above logic is backward (fills pixel c if c-1 is filled). Needs correction.
    # Correct logic: Fill pixel c-1 if pixel c is filled.
    
    new_grid = [row[:] for row in grid] # Start fresh with initial grid + seeds
    changed = True
    while changed:
        changed = False
        grid_before_pass = [row[:] for row in new_grid]
        for r in range(height):
            for c in range(1, width): # Iterate columns from left to right
                # If current pixel is fill_color and pixel to the left is background
                if grid_before_pass[r][c] == fill_color and grid_before_pass[r][c-1] == background_color:
                     if new_grid[r][c-1] != fill_color: # Check if not already filled
                        new_grid[r][c-1] = fill_color
                        changed = True
    
    return new_grid


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid based on identified colors and fill logic.
    """
    height = len(input_grid)
    width = len(input_grid[0])
    
    # 1. Calculate color counts and find all unique colors
    color_counts = Counter()
    all_colors = set()
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            color_counts[color] += 1
            all_colors.add(color)
            
    if not color_counts:
        return input_grid # Should not happen with ARC constraints

    # 2. Identify Background Color (most frequent)
    background_color = color_counts.most_common(1)[0][0]
    
    # 3. Find Interface Colors and their frequencies
    interface_colors = {} # color -> count
    background_pixels = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == background_color:
                background_pixels.append((r,c))
                for nr, nc in get_neighbors(r, c, height, width):
                    neighbor_color = input_grid[nr][nc]
                    if neighbor_color != background_color:
                        interface_colors[neighbor_color] = color_counts[neighbor_color]

    if not interface_colors:
         # No interface colors found, maybe grid is single color or only BG + disconnected colors
         # Or maybe the heuristic needs adjustment (e.g. if BG itself is small)
         # For now, assume no fill needed if no interface.
         return [row[:] for row in input_grid] 
         
    # 4. Identify Fill Color (least frequent interface color)
    # Sort interface colors by frequency (ascending)
    sorted_interface_colors = sorted(interface_colors.items(), key=lambda item: item[1])
    
    if not sorted_interface_colors:
         # Should be caught by `if not interface_colors` above, but as safeguard:
         return [row[:] for row in input_grid]
         
    fill_color = sorted_interface_colors[0][0]

    # 5. Identify Boundary Colors
    boundary_colors = all_colors - {background_color, fill_color}

    # 6. Determine Fill Type
    fill_type = "left" if background_color == 0 else "flood"
    
    # 7. Create output grid copy
    output_grid = [row[:] for row in input_grid]

    # 8. Find initial seed coordinates for the fill color
    start_coords = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == fill_color:
                start_coords.append((r, c))
                
    if not start_coords:
        # No fill seeds found, return copy of input
        return output_grid

    # 9. Execute the fill
    if fill_type == "flood":
        output_grid = flood_fill(output_grid, start_coords, fill_color, background_color, boundary_colors)
    elif fill_type == "left":
        # Note: Left fill implementation needs care. Initial seeds are already fill_color.
        # We need to fill background pixels adjacent (left) to fill_color pixels.
        output_grid = left_fill(output_grid, start_coords, fill_color, background_color, boundary_colors)

    return output_grid
```
