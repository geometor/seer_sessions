{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nfrom collections import Counter\n# No other external libraries are strictly necessary for this implementation\n\n# --- Helper Functions ---\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"\n    Generates valid 4-way neighbors (up, down, left, right) for a given cell.\n    Ensures neighbors are within the grid boundaries.\n    \"\"\"\n    neighbors = []\n    # Up\n    if r > 0: neighbors.append((r - 1, c))\n    # Down\n    if r < height - 1: neighbors.append((r + 1, c))\n    # Left\n    if c > 0: neighbors.append((r, c - 1))\n    # Right\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef analyze_and_identify_params(grid):\n    \"\"\"\n    Identifies background, fill, seed, and boundary colors, plus the fill type,\n    using heuristics derived from observations of the training examples.\n\n    Heuristics Used:\n    - Background Color: The most frequent color in the input grid.\n    - Fill Color: The color adjacent to the background color that has the\n                  overall minimum frequency in the grid. (Handles ties by picking one).\n    - Boundary Colors: All other colors present in the grid.\n    - Seed Pixels: The locations of the Fill Color in the input grid.\n    - Fill Type: 'left' if the identified Background Color is 0 (white),\n                 otherwise 'flood'.\n\n    Returns:\n        A dictionary containing the identified parameters, or None if analysis fails\n        (e.g., empty grid, cannot determine distinct colors).\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    if height == 0 or width == 0:\n        return None # Invalid grid\n\n    # 1. Calculate color counts and find all unique colors\n    color_counts = Counter()\n    all_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r][c]\n            color_counts[color] += 1\n            all_colors.add(color)\n\n    if not color_counts or len(all_colors) < 2:\n        # Need at least two colors for a fill operation\n        return None\n\n    # 2. Identify Background Color (most frequent overall)\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 3. Find Interface Colors and their frequencies\n    # Interface colors are non-background colors adjacent to background colors\n    interface_colors_freq = {}\n    processed_neighbors = set() # Track neighbors checked to avoid redundant lookups\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == background_color:\n                for nr, nc in get_neighbors(r, c, height, width):\n                    neighbor_coord = (nr, nc)\n                    if neighbor_coord not in processed_neighbors:\n                        processed_neighbors.add(neighbor_coord)\n                        neighbor_color = grid[nr][nc]\n                        if neighbor_color != background_color:\n                            # Store the overall frequency of this neighbor color\n                            interface_colors_freq[neighbor_color] = color_counts[neighbor_color]\n\n    if not interface_colors_freq:\n         # Fallback: If no interface colors found adjacent to the most frequent color,\n         # maybe the 'background' isn't the most frequent.\n         # Or maybe the 'fill' color seeds aren't adjacent initially.\n         # Try identifying fill as simply the least frequent color overall that isn't background.\n         potential_fills = {color: count for color, count in color_counts.items() if color != background_color}\n         if not potential_fills: return None # Only one color in grid\n         fill_color = min(potential_fills, key=potential_fills.get)\n    else:\n        # 4. Identify Fill Color (least frequent interface color)\n        fill_color = min(interface_colors_freq, key=interface_colors_freq.get)\n\n    # 5. Identify Boundary Colors\n    boundary_colors = all_colors - {background_color, fill_color}\n\n    # 6. Find initial seed coordinates\n    start_coords = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == fill_color:\n                start_coords.append((r, c))\n\n    # 7. Determine Fill Type (heuristic based on BG color)\n    fill_type = \"left\" if background_color == 0 else \"flood\"\n\n    # If no seeds are found for the identified fill color, the parameters might be wrong,\n    # but we proceed, and the fill functions will likely do nothing.\n    # A more robust solution might re-evaluate parameters here.\n\n    return {\n        \"background_color\": background_color,\n        \"fill_color\": fill_color,\n        \"seed_pixels\": start_coords,\n        \"boundary_colors\": boundary_colors,\n        \"fill_type\": fill_type\n    }\n\n\ndef perform_flood_fill(grid, start_coords, fill_color, background_color):\n    \"\"\"\n    Performs a 4-directional flood fill IN PLACE on the grid.\n    Starts from start_coords and replaces background_color with fill_color.\n    Uses a queue and a visited set to handle the fill efficiently.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    if not start_coords: # No seeds, nothing to fill\n        return\n\n    q = collections.deque(start_coords)\n    # Initialize visited with seeds only if they are on background (unlikely)\n    # Or more simply, add seeds to visited to prevent re-adding if they are neighbors of others\n    visited = set(start_coords)\n\n    while q:\n        r, c = q.popleft()\n\n        # The pixel (r,c) itself is already the fill_color (or was an initial seed)\n        # Check its neighbors to see if they should be filled\n        for nr, nc in get_neighbors(r, c, height, width):\n            # Check if the neighbor is within bounds (implicitly handled by get_neighbors)\n            # Check if it hasn't been visited/processed yet\n            if (nr, nc) not in visited:\n                # Check if the neighbor is the background color\n                if grid[nr][nc] == background_color:\n                    visited.add((nr, nc))       # Mark as visited\n                    grid[nr][nc] = fill_color   # Fill the pixel\n                    q.append((nr, nc))          # Add to queue for further expansion\n    # Modification happens in place, no return value needed.\n\n\ndef perform_left_fill(grid, fill_color, background_color):\n    \"\"\"\n    Performs a directional fill propagating only leftwards, IN PLACE.\n    Iteratively scans the grid, changing background pixels to the fill color\n    if the pixel immediately to their right is the fill color.\n    Continues until no more changes can be made in a full pass.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n\n    changed_in_pass = True\n    while changed_in_pass:\n        changed_in_pass = False\n        # Iterate rows from top to bottom\n        for r in range(height):\n            # Iterate columns from right-to-left (second-to-last column to first)\n            # This allows changes to propagate leftwards within a single pass efficiently\n            for c in range(width - 2, -1, -1):\n                 # Check the pixel at (r, c)\n                 # If it's the background color...\n                 if grid[r][c] == background_color:\n                     # ...and the pixel to its right (r, c+1) is the fill color...\n                     if grid[r][c+1] == fill_color:\n                         # ...change the current pixel to the fill color.\n                         grid[r][c] = fill_color\n                         changed_in_pass = True # Mark that a change occurred\n    # Modification happens in place, no return value needed.\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the grid by performing a fill operation based on derived parameters.\n\n    The process involves:\n    1. Analyzing the input grid to heuristically identify the background color (most frequent),\n       fill color (least frequent color adjacent to background), seed pixel locations\n       (initial positions of fill color), and boundary colors (all others).\n    2. Determining the fill type: 'left' fill if the background color is 0 (white),\n       otherwise a 4-directional 'flood' fill.\n    3. Executing the determined fill operation, modifying a copy of the input grid.\n       - Flood fill expands from seed pixels into adjacent background pixels.\n       - Left fill expands leftwards from existing fill pixels into adjacent background pixels.\n    4. Returning the modified grid. If analysis fails or no seed pixels are found\n       for the identified fill color, a copy of the original input grid is returned.\n    \"\"\"\n    # 1. Analyze the input grid to find parameters\n    params = analyze_and_identify_params(input_grid)\n\n    # 2. Check if analysis was successful and seeds were found\n    if params is None or not params[\"seed_pixels\"]:\n        # If analysis fails (e.g., invalid grid, <2 colors) or no seeds found\n        # for the heuristically determined fill color, return a copy of the input.\n        return [row[:] for row in input_grid]\n\n    # Extract parameters\n    background_color = params[\"background_color\"]\n    fill_color = params[\"fill_color\"]\n    seed_pixels = params[\"seed_pixels\"]\n    fill_type = params[\"fill_type\"]\n    # boundary_colors = params[\"boundary_colors\"] # Boundaries implicitly handled by fill logic\n\n    # 3. Create a mutable copy of the input grid to modify\n    output_grid = [row[:] for row in input_grid]\n\n    # 4. Perform the transformation based on fill type\n    if fill_type == \"flood\":\n        perform_flood_fill(output_grid, seed_pixels, fill_color, background_color)\n    elif fill_type == \"left\":\n        # Left fill doesn't strictly need seeds; it propagates from *any* fill_color pixel\n        perform_left_fill(output_grid, fill_color, background_color)\n\n    # 5. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21628,
    "candidates_token_count": 8308,
    "total_token_count": 29936,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 66.297512,
  "retries": 1
}