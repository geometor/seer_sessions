{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid by performing a fill operation.\n\nThe transformation identifies key components heuristically from the input grid:\n1. Background Color: Assumed to be the most frequent color in the grid.\n2. Fill Color: Assumed to be the color adjacent (4-way) to the background color\n   that has the minimum overall frequency in the entire grid. A fallback identifies\n   it as the least frequent non-background color if no adjacent colors are found.\n3. Seed Pixels: The locations of the identified Fill Color in the input grid.\n\nBased on the identified Background Color, a fill type is chosen:\n- If Background Color is 0 (white), a 'left_fill' operation is performed.\n- Otherwise, a 4-directional 'flood_fill' operation is performed.\n\nThe fill operation modifies a copy of the input grid:\n- Flood Fill: Starting from the seed pixels, it replaces adjacent background-colored\n  pixels with the fill color, expanding outwards.\n- Left Fill: It iteratively replaces background-colored pixels with the fill color\n  if the pixel immediately to their right has the fill color, effectively propagating\n  the fill leftwards across the grid.\n\nBoundary colors (all colors other than the identified background and fill colors)\nimplicitly stop the fill propagation. If parameter identification fails or no\nseed pixels are found, the original grid is returned unchanged.\n\"\"\"\n\n\n# --- Helper Functions ---\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\"\n    Generates valid 4-way neighbors (up, down, left, right) for a given cell (r, c).\n    Ensures neighbors are within the grid boundaries (0 <= nr < height, 0 <= nc < width).\n    \"\"\"\n    neighbors = []\n    # Up\n    if r > 0: neighbors.append((r - 1, c))\n    # Down\n    if r < height - 1: neighbors.append((r + 1, c))\n    # Left\n    if c > 0: neighbors.append((r, c - 1))\n    # Right\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _identify_parameters(grid):\n    \"\"\"\n    Identifies background, fill, seed colors/pixels, and fill type using input-only heuristics.\n\n    Returns:\n        A dictionary containing identified parameters ('background_color', 'fill_color',\n        'seed_pixels', 'fill_type'), or None if analysis fails.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    if height == 0 or width == 0:\n        return None # Invalid grid\n\n    # 1. Calculate overall color counts and find all unique colors\n    color_counts = Counter()\n    all_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r][c]\n            color_counts[color] += 1\n            all_colors.add(color)\n\n    if not color_counts or len(all_colors) < 2:\n        # Need at least two colors for a meaningful fill operation\n        return None\n\n    # 2. Identify Background Color (heuristic: most frequent overall)\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 3. Find Interface Colors and their frequencies\n    # Interface colors are non-background colors adjacent to background colors\n    interface_colors_freq = {}\n    processed_neighbors = set() # Track neighbors checked to avoid redundant lookups\n    found_interface = False\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == background_color:\n                for nr, nc in _get_neighbors(r, c, height, width):\n                    neighbor_coord = (nr, nc)\n                    if neighbor_coord not in processed_neighbors:\n                        processed_neighbors.add(neighbor_coord)\n                        neighbor_color = grid[nr][nc]\n                        if neighbor_color != background_color:\n                            # Store the overall grid frequency of this neighbor color\n                            interface_colors_freq[neighbor_color] = color_counts[neighbor_color]\n                            found_interface = True # Mark that at least one interface color found\n\n    # 4. Identify Fill Color\n    if not found_interface:\n         # Fallback: If no interface colors found adjacent to the most frequent color.\n         # This might happen if seeds are not directly adjacent or BG is small.\n         # Try identifying fill as simply the least frequent color overall that isn't background.\n         potential_fills = {color: count for color, count in color_counts.items() if color != background_color}\n         if not potential_fills: return None # Only one color in grid\n         # Choose the color with the absolute minimum count\n         fill_color = min(potential_fills, key=potential_fills.get)\n    else:\n        # Heuristic: least frequent interface color (based on overall count)\n        # Choose the color with the minimum overall count among the interface colors found\n        fill_color = min(interface_colors_freq, key=interface_colors_freq.get)\n\n    # 5. Find initial seed coordinates (locations of the identified fill color)\n    start_coords = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == fill_color:\n                start_coords.append((r, c))\n\n    # 6. Determine Fill Type (heuristic: based on identified background color)\n    fill_type = \"left\" if background_color == 0 else \"flood\"\n\n    # If no seeds are found, parameter identification might be wrong, but return params anyway.\n    # The main transform function will handle the no-seed case.\n    return {\n        \"background_color\": background_color,\n        \"fill_color\": fill_color,\n        \"seed_pixels\": start_coords,\n        \"fill_type\": fill_type\n    }\n\n\ndef _perform_flood_fill(grid, start_coords, fill_color, background_color):\n    \"\"\"\n    Performs a 4-directional flood fill IN PLACE on the grid.\n    Starts from start_coords and replaces background_color with fill_color.\n    Boundary colors (anything not background or fill) implicitly halt the fill.\n    Uses a queue and visited set for correctness and efficiency.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    if not start_coords: # No seeds, nothing to fill\n        return\n\n    q = collections.deque(start_coords)\n    visited = set(start_coords) # Track visited to prevent cycles and redundant checks\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors of the current dequeued pixel\n        for nr, nc in _get_neighbors(r, c, height, width):\n            if (nr, nc) not in visited:\n                # Only fill if the neighbor is the specific background color\n                if grid[nr][nc] == background_color:\n                    visited.add((nr, nc))       # Mark as visited before adding to queue\n                    grid[nr][nc] = fill_color   # Fill the pixel\n                    q.append((nr, nc))          # Add to queue for further expansion\n\ndef _perform_left_fill(grid, fill_color, background_color):\n    \"\"\"\n    Performs a directional fill propagating only leftwards, IN PLACE.\n    Iteratively scans the grid, changing background pixels to the fill color\n    if the pixel immediately to their right is the fill color.\n    Continues until no more changes can be made in a full pass.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n\n    changed_in_pass = True\n    while changed_in_pass:\n        changed_in_pass = False\n        # Iterate rows from top to bottom\n        for r in range(height):\n            # Iterate columns from right-to-left (index width-2 down to 0)\n            # This ensures changes propagate correctly leftward within a pass\n            for c in range(width - 2, -1, -1):\n                 # Check the pixel at (r, c)\n                 # If it's the background color...\n                 if grid[r][c] == background_color:\n                     # ...and the pixel to its right (r, c+1) is the fill color...\n                     if grid[r][c+1] == fill_color:\n                         # ...change the current pixel to the fill color.\n                         grid[r][c] = fill_color\n                         changed_in_pass = True # Mark that a change occurred in this pass\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a fill transformation to the input grid based on heuristically\n    identified parameters derived solely from the input grid.\n    \"\"\"\n    # 1. Analyze the input grid to find heuristic parameters\n    params = _identify_parameters(input_grid)\n\n    # 2. Check if analysis was successful and seeds were found\n    if params is None or not params[\"seed_pixels\"]:\n        # If analysis fails (e.g., invalid grid, <2 colors) or no seeds found\n        # for the heuristically determined fill color, return an unmodified copy.\n        # This prevents errors if the heuristics misidentified the fill color.\n        return [row[:] for row in input_grid]\n\n    # 3. Extract parameters identified from the input grid\n    background_color = params[\"background_color\"]\n    fill_color = params[\"fill_color\"]\n    seed_pixels = params[\"seed_pixels\"]\n    fill_type = params[\"fill_type\"]\n\n    # 4. Create a mutable copy of the input grid to perform the transformation on\n    output_grid = [row[:] for row in input_grid]\n\n    # 5. Perform the transformation based on the determined fill type\n    if fill_type == \"flood\":\n        # Execute 4-directional flood fill starting from seeds\n        _perform_flood_fill(output_grid, seed_pixels, fill_color, background_color)\n    elif fill_type == \"left\":\n        # Execute iterative leftward fill; propagates from *any* fill_color pixel\n        _perform_left_fill(output_grid, fill_color, background_color)\n\n    # 6. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 48432,
    "candidates_token_count": 2669,
    "total_token_count": 51101,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.862231,
  "retries": 1
}