{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid by performing a fill operation based on parameters derived\nheuristically from the input grid itself.\n\nThe process involves:\n1. Analyzing the input grid to heuristically identify:\n    - The background color (assumed to be the most frequent color).\n    - The fill color (assumed to be the least frequent color adjacent to the background color).\n    - Seed pixel locations (initial positions of the identified fill color).\n2. Determining the fill type based on a heuristic:\n    - 'left' fill if the identified background color is 0 (white).\n    - 'flood' fill (4-directional) otherwise.\n3. Executing the determined fill operation on a copy of the input grid:\n    - Flood fill expands from seed pixels into adjacent background pixels.\n    - Left fill expands leftwards from existing fill pixels into adjacent background pixels.\n4. Returning the modified grid. If analysis fails (e.g., cannot determine distinct\n   background/fill colors) or no seed pixels are found for the identified fill color,\n   a copy of the original input grid is returned.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\"\n    Generates valid 4-way neighbors (up, down, left, right) for a given cell (r, c).\n    Ensures neighbors are within the grid boundaries (0 <= nr < height, 0 <= nc < width).\n    \"\"\"\n    neighbors = []\n    # Up\n    if r > 0: neighbors.append((r - 1, c))\n    # Down\n    if r < height - 1: neighbors.append((r + 1, c))\n    # Left\n    if c > 0: neighbors.append((r, c - 1))\n    # Right\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _identify_parameters(grid):\n    \"\"\"\n    Identifies background, fill, seed colors/pixels, and fill type using input-only heuristics.\n\n    Returns:\n        A dictionary containing identified parameters ('background_color', 'fill_color',\n        'seed_pixels', 'fill_type'), or None if analysis fails.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    if height == 0 or width == 0:\n        return None # Invalid grid\n\n    # 1. Calculate color counts and find all unique colors\n    color_counts = Counter()\n    all_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = grid[r][c]\n            color_counts[color] += 1\n            all_colors.add(color)\n\n    if not color_counts or len(all_colors) < 2:\n        # Need at least two colors for a meaningful fill operation\n        return None\n\n    # 2. Identify Background Color (heuristic: most frequent overall)\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 3. Find Interface Colors and their frequencies\n    # Interface colors are non-background colors adjacent to background colors\n    interface_colors_freq = {}\n    processed_neighbors = set() # Track neighbors checked to avoid redundant lookups\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == background_color:\n                for nr, nc in _get_neighbors(r, c, height, width):\n                    neighbor_coord = (nr, nc)\n                    if neighbor_coord not in processed_neighbors:\n                        processed_neighbors.add(neighbor_coord)\n                        neighbor_color = grid[nr][nc]\n                        if neighbor_color != background_color:\n                            # Store the overall grid frequency of this neighbor color\n                            interface_colors_freq[neighbor_color] = color_counts[neighbor_color]\n\n    if not interface_colors_freq:\n         # Fallback: If no interface colors found adjacent to the most frequent color.\n         # Try identifying fill as simply the least frequent color overall that isn't background.\n         potential_fills = {color: count for color, count in color_counts.items() if color != background_color}\n         if not potential_fills: return None # Only one color in grid\n         # Choose the color with the absolute minimum count\n         fill_color = min(potential_fills, key=potential_fills.get)\n    else:\n        # 4. Identify Fill Color (heuristic: least frequent interface color)\n        # Choose the color with the minimum overall count among the interface colors\n        fill_color = min(interface_colors_freq, key=interface_colors_freq.get)\n\n    # 5. Find initial seed coordinates (locations of the identified fill color)\n    start_coords = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == fill_color:\n                start_coords.append((r, c))\n\n    # 6. Determine Fill Type (heuristic: based on identified background color)\n    fill_type = \"left\" if background_color == 0 else \"flood\"\n\n    return {\n        \"background_color\": background_color,\n        \"fill_color\": fill_color,\n        \"seed_pixels\": start_coords,\n        \"fill_type\": fill_type\n    }\n\n\ndef _perform_flood_fill(grid, start_coords, fill_color, background_color):\n    \"\"\"\n    Performs a 4-directional flood fill IN PLACE on the grid.\n    Starts from start_coords and replaces background_color with fill_color.\n    Boundary colors (anything not background or fill) implicitly halt the fill.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    if not start_coords: # No seeds, nothing to fill\n        return\n\n    q = collections.deque(start_coords)\n    visited = set(start_coords) # Track visited to prevent cycles and redundant checks\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors of the current dequeued pixel\n        for nr, nc in _get_neighbors(r, c, height, width):\n            if (nr, nc) not in visited:\n                # Only fill if the neighbor is the specific background color\n                if grid[nr][nc] == background_color:\n                    visited.add((nr, nc))       # Mark as visited\n                    grid[nr][nc] = fill_color   # Fill the pixel\n                    q.append((nr, nc))          # Add to queue for further expansion\n\ndef _perform_left_fill(grid, fill_color, background_color):\n    \"\"\"\n    Performs a directional fill propagating only leftwards, IN PLACE.\n    Iteratively scans the grid, changing background pixels to the fill color\n    if the pixel immediately to their right is the fill color.\n    Continues until no more changes can be made in a full pass.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n\n    changed_in_pass = True\n    while changed_in_pass:\n        changed_in_pass = False\n        # Iterate rows from top to bottom\n        for r in range(height):\n            # Iterate columns from right-to-left (index width-2 down to 0)\n            for c in range(width - 2, -1, -1):\n                 # Check the pixel at (r, c)\n                 # If it's the background color...\n                 if grid[r][c] == background_color:\n                     # ...and the pixel to its right (r, c+1) is the fill color...\n                     if grid[r][c+1] == fill_color:\n                         # ...change the current pixel to the fill color.\n                         grid[r][c] = fill_color\n                         changed_in_pass = True # Mark that a change occurred in this pass\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies a fill transformation to the input grid based on heuristically\n    identified parameters.\n    \"\"\"\n    # 1. Analyze the input grid to find heuristic parameters\n    params = _identify_parameters(input_grid)\n\n    # 2. Check if analysis was successful and seeds were found\n    if params is None or not params[\"seed_pixels\"]:\n        # If analysis fails or no seeds found for the heuristically determined\n        # fill color, return an unmodified copy of the input.\n        return [row[:] for row in input_grid]\n\n    # 3. Extract parameters\n    background_color = params[\"background_color\"]\n    fill_color = params[\"fill_color\"]\n    seed_pixels = params[\"seed_pixels\"]\n    fill_type = params[\"fill_type\"]\n\n    # 4. Create a mutable copy of the input grid to modify\n    output_grid = [row[:] for row in input_grid]\n\n    # 5. Perform the transformation based on fill type\n    if fill_type == \"flood\":\n        _perform_flood_fill(output_grid, seed_pixels, fill_color, background_color)\n    elif fill_type == \"left\":\n        # Left fill propagates from *any* fill_color pixel, not just seeds explicitly\n        _perform_left_fill(output_grid, fill_color, background_color)\n\n    # 6. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32813,
    "candidates_token_count": 2608,
    "total_token_count": 35421,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.177503,
  "retries": 1
}