{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies the background color, fill color, and boundary colors based on frequency and adjacency.\nPerforms a fill operation starting from pixels with the fill color.\nThe fill type is determined by the background color:\n- If the background color is 0 (white), a leftward directional fill is performed.\n- Otherwise, a 4-directional flood fill is performed.\nThe fill replaces background-colored pixels with the fill color, stopping at boundary colors or grid edges.\n\nColor Identification Heuristic:\n1. Background Color: The most frequent color in the input grid.\n2. Interface Colors: Colors adjacent (4-way) to any background pixel.\n3. Fill Color: The interface color with the minimum frequency (count) in the input grid.\n4. Boundary Colors: All colors present in the input grid except for the background and fill colors.\n\"\"\"\n\ndef get_neighbors(r, c, height, width):\n    \"\"\"Generates valid 4-way neighbors for a given cell.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef flood_fill(grid, start_coords, fill_color, background_color, boundary_colors):\n    \"\"\"Performs a 4-directional flood fill.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    q = collections.deque(start_coords)\n    \n    # Mark initial seeds as filled if they are on background color \n    # (though typically seeds are already fill_color)\n    # Add seeds to queue regardless to start the process.\n    processed_seeds = set()\n    \n    while q:\n        r, c = q.popleft()\n        \n        # Process neighbors\n        for nr, nc in get_neighbors(r, c, height, width):\n            if grid[nr][nc] == background_color:\n                grid[nr][nc] = fill_color\n                q.append((nr, nc))\n                \n    return grid\n\n\ndef left_fill(grid, start_coords, fill_color, background_color, boundary_colors):\n    \"\"\"Performs a directional fill propagating only leftwards.\"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    \n    changed = True\n    while changed:\n        changed = False\n        # Iterate from right to left, top to bottom might be more intuitive for left fill propagation\n        for r in range(height):\n            for c in range(width): \n                # If a pixel to the right has the fill color, and this pixel is background\n                if grid[r][c] == background_color:\n                    if c < width - 1 and grid[r][c+1] == fill_color:\n                         grid[r][c] = fill_color\n                         changed = True\n                    # Also consider the case where the initial seed triggers the fill\n                    # This check ensures pixels left of initial seeds are filled\n                    # Redundant if initial seeds are correctly handled? Let's test.\n                    # Simplified: propagate from existing fill_color pixels leftwards.\n                    \n    # Second pass to ensure propagation from original seeds works correctly\n    # The previous loop might only work if a fill_color pixel exists to the right.\n    # Need to propagate from initial seeds too.\n    \n    # Reset and use a different approach: Scan repeatedly leftwards from any fill_color pixel.\n    \n    # Create a working copy to avoid issues with loop order\n    new_grid = [row[:] for row in grid] \n    \n    changed = True\n    while changed:\n        changed = False\n        current_grid = [row[:] for row in new_grid] # snapshot before pass\n        for r in range(height):\n            for c in range(1, width): # Start from second column\n                # If the pixel to the right is fill_color and current is background\n                if current_grid[r][c] == background_color and current_grid[r][c-1] == fill_color:\n                    if new_grid[r][c] != fill_color: # check if already changed in this pass\n                         new_grid[r][c] = fill_color\n                         changed = True\n                         \n    # The above logic is backward (fills pixel c if c-1 is filled). Needs correction.\n    # Correct logic: Fill pixel c-1 if pixel c is filled.\n    \n    new_grid = [row[:] for row in grid] # Start fresh with initial grid + seeds\n    changed = True\n    while changed:\n        changed = False\n        grid_before_pass = [row[:] for row in new_grid]\n        for r in range(height):\n            for c in range(1, width): # Iterate columns from left to right\n                # If current pixel is fill_color and pixel to the left is background\n                if grid_before_pass[r][c] == fill_color and grid_before_pass[r][c-1] == background_color:\n                     if new_grid[r][c-1] != fill_color: # Check if not already filled\n                        new_grid[r][c-1] = fill_color\n                        changed = True\n    \n    return new_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on identified colors and fill logic.\n    \"\"\"\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # 1. Calculate color counts and find all unique colors\n    color_counts = Counter()\n    all_colors = set()\n    for r in range(height):\n        for c in range(width):\n            color = input_grid[r][c]\n            color_counts[color] += 1\n            all_colors.add(color)\n            \n    if not color_counts:\n        return input_grid # Should not happen with ARC constraints\n\n    # 2. Identify Background Color (most frequent)\n    background_color = color_counts.most_common(1)[0][0]\n    \n    # 3. Find Interface Colors and their frequencies\n    interface_colors = {} # color -> count\n    background_pixels = []\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r][c] == background_color:\n                background_pixels.append((r,c))\n                for nr, nc in get_neighbors(r, c, height, width):\n                    neighbor_color = input_grid[nr][nc]\n                    if neighbor_color != background_color:\n                        interface_colors[neighbor_color] = color_counts[neighbor_color]\n\n    if not interface_colors:\n         # No interface colors found, maybe grid is single color or only BG + disconnected colors\n         # Or maybe the heuristic needs adjustment (e.g. if BG itself is small)\n         # For now, assume no fill needed if no interface.\n         return [row[:] for row in input_grid] \n         \n    # 4. Identify Fill Color (least frequent interface color)\n    # Sort interface colors by frequency (ascending)\n    sorted_interface_colors = sorted(interface_colors.items(), key=lambda item: item[1])\n    \n    if not sorted_interface_colors:\n         # Should be caught by `if not interface_colors` above, but as safeguard:\n         return [row[:] for row in input_grid]\n         \n    fill_color = sorted_interface_colors[0][0]\n\n    # 5. Identify Boundary Colors\n    boundary_colors = all_colors - {background_color, fill_color}\n\n    # 6. Determine Fill Type\n    fill_type = \"left\" if background_color == 0 else \"flood\"\n    \n    # 7. Create output grid copy\n    output_grid = [row[:] for row in input_grid]\n\n    # 8. Find initial seed coordinates for the fill color\n    start_coords = []\n    for r in range(height):\n        for c in range(width):\n            if output_grid[r][c] == fill_color:\n                start_coords.append((r, c))\n                \n    if not start_coords:\n        # No fill seeds found, return copy of input\n        return output_grid\n\n    # 9. Execute the fill\n    if fill_type == \"flood\":\n        output_grid = flood_fill(output_grid, start_coords, fill_color, background_color, boundary_colors)\n    elif fill_type == \"left\":\n        # Note: Left fill implementation needs care. Initial seeds are already fill_color.\n        # We need to fill background pixels adjacent (left) to fill_color pixels.\n        output_grid = left_fill(output_grid, start_coords, fill_color, background_color, boundary_colors)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4586,
    "candidates_token_count": 6400,
    "total_token_count": 10986,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 56.928789,
  "retries": 1
}