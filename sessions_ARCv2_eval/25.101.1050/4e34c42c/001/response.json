{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\nimport collections\n\n\"\"\"\nProcesses an input grid based on marker pixels (color 9). It identifies connected \ncomponents of marker pixels. For each unique minimum row (`m_min_r`) associated \nwith any marker component, it defines a potential 5-row high region starting \nfrom `m_min_r`. It then finds the horizontal bounding box of all non-background, \nnon-marker pixels within those 5 rows (or fewer if near the grid bottom). \nThis rectangular slice is extracted. \n\nThese extracted slices are collected, ensuring duplicate regions (defined by \nstart row and column bounds) are not added multiple times. The collected slices \nare then sorted based on the minimum row (`m_min_r`) of the marker component(s) \nthat triggered their generation, in descending order. Finally, the sorted slices \nare padded (if necessary) to have the same height and concatenated horizontally \nto form the output grid. Handles edge cases like empty grids, grid boundaries, \nand missing markers or associated patterns.\n\"\"\"\n\ndef get_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid, returning 0 as default.\"\"\"\n    if grid.size == 0:\n        return 0 # Default background if grid is empty\n    # Use collections.Counter for potentially faster counting on typical grids\n    counts = collections.Counter(grid.flat)\n    if counts:\n         # most_common(1) returns list of tuples [(value, count)]\n         return counts.most_common(1)[0][0]\n    elif grid.size > 0:\n         # Fallback if counter is empty but grid has elements (shouldn't happen)\n         return grid.flat[0] \n    else:\n         return 0 # Default\n\ndef find_components_and_min_rows(grid: np.ndarray, condition_func) -> list[int]:\n    \"\"\"\n    Finds connected components satisfying a condition function and returns a list \n    of the minimum row index for each distinct component found.\n    \"\"\"\n    binary_grid = condition_func(grid)\n    # Use 8-way connectivity (diagnals included)\n    structure = generate_binary_structure(2, 2) \n    labeled_grid, num_components = label(binary_grid, structure=structure)\n    \n    components_min_rows = []\n    if num_components > 0:\n        min_rows_per_label = {}\n        # Iterate through the grid to find the minimum row for each label\n        # This avoids finding all coordinates if only min_row is needed\n        for r in range(labeled_grid.shape[0]):\n            for c in range(labeled_grid.shape[1]):\n                label_id = labeled_grid[r, c]\n                if label_id > 0:\n                    if label_id not in min_rows_per_label:\n                        min_rows_per_label[label_id] = r\n                    # Optimization: if we found the first row instance, \n                    # no need to update further for this label_id's min row.\n                    # However, simpler just to let it find all first occurrences.\n        \n        components_min_rows = list(min_rows_per_label.values())\n                 \n    return components_min_rows # Returns a list of min_rows, one for each component\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on marker pixels (color 9).\n    Extracts 5-row high slices associated with marker components, sorts them \n    by the marker's minimum row (descending), and concatenates horizontally.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=np.int8)\n    h, w = input_np.shape\n\n    # Handle empty input grid\n    if h == 0 or w == 0:\n        return [[]]\n\n    # Identify marker color (fixed at 9) and background color\n    marker_color = 9\n    background_color = get_background_color(input_np)\n\n    # Find the minimum row for each marker component\n    marker_component_min_rows = find_components_and_min_rows(input_np, lambda g: g == marker_color)\n    \n    # If no markers found, return a 1x1 background grid as per interpretation\n    if not marker_component_min_rows:\n         return [[int(background_color)]] \n\n    extracted_regions = []\n    # Track processed regions defined by (start_row, col_min, col_max) to avoid duplicates\n    processed_regions = set() \n\n    # Use unique min_rows associated with markers to define potential slice start rows\n    unique_min_rows = sorted(list(set(marker_component_min_rows)))\n\n    for m_min_r in unique_min_rows:\n        \n        # Define the row slice range (max 5 rows, respecting grid height)\n        start_row = m_min_r\n        end_row = min(start_row + 5, h) \n        \n        # Consider only rows that actually exist in the grid\n        if start_row >= h:\n             continue\n        \n        # Get the data for the rows [start_row, end_row) across the full width\n        row_slice_data = input_np[start_row:end_row, :]\n        \n        # Create a mask for non-background, non-marker pixels within this row slice\n        pattern_mask = (row_slice_data != background_color) & (row_slice_data != marker_color)\n        \n        # Find the column indices where such pattern pixels exist\n        pattern_cols_in_slice = np.where(pattern_mask)[1] # We only need column indices\n        \n        # If no pattern pixels found in these rows, this marker row doesn't yield a slice\n        if pattern_cols_in_slice.size == 0:\n            continue \n            \n        # Determine the horizontal extent (min/max columns) of the pattern in this slice\n        p_min_c = np.min(pattern_cols_in_slice)\n        p_max_c = np.max(pattern_cols_in_slice)\n        \n        # Define the region identifier to check if we already extracted this exact slice\n        region_id = (start_row, p_min_c, p_max_c)\n        if region_id in processed_regions:\n            continue # Skip duplicate region\n        processed_regions.add(region_id)\n\n        # Extract the final slice using defined rows and calculated pattern columns\n        extracted_slice = input_np[start_row:end_row, p_min_c : p_max_c + 1]\n\n        # Store the slice along with the marker row that triggered it (for sorting)\n        # Ensure the slice is not empty before storing\n        if extracted_slice.size > 0:\n             extracted_regions.append({'trigger_row': m_min_r, 'slice': extracted_slice})\n\n    # Sort the collected regions based on the marker row that triggered them, descending order\n    extracted_regions.sort(key=lambda x: x['trigger_row'], reverse=True)\n\n    # If no valid regions were extracted, return background grid\n    if not extracted_regions:\n         return [[int(background_color)]] \n\n    final_slices = [region['slice'] for region in extracted_regions]\n    \n    # Determine the target height (max height found among slices) for padding\n    max_h = 0\n    if final_slices:\n        heights = [s.shape[0] for s in final_slices if s.ndim == 2] # Check shape exists\n        if heights:\n             max_h = max(heights)\n        \n    # Pad slices shorter than max_h at the bottom with the background color\n    padded_slices = []\n    for s in final_slices:\n         # Ensure it's a valid 2D array before padding\n        if s.ndim == 2 and s.shape[0] > 0 and s.shape[1] > 0:\n            if s.shape[0] < max_h:\n                pad_h = max_h - s.shape[0]\n                # Create padding array\n                padding = np.full((pad_h, s.shape[1]), background_color, dtype=s.dtype)\n                # Stack original slice on top of padding\n                padded_s = np.vstack((s, padding))\n                padded_slices.append(padded_s)\n            else:\n                # Slice already has max height\n                padded_slices.append(s)\n        # Optionally handle cases where a slice might be empty or 1D? \n        # The extraction logic should prevent this if size > 0 check works.\n\n    # If after padding, no valid slices remain, return background\n    if not padded_slices:\n         return [[int(background_color)]] \n\n    # Perform horizontal stacking (concatenation)\n    try:\n        output_np = np.hstack(padded_slices)\n    except ValueError as e:\n        # Catch potential errors during hstack (e.g., if somehow heights mismatch despite padding)\n        print(f\"Error during hstack: {e}\")\n        # Return a default error indicator or background grid\n        return [[int(background_color)]]\n\n\n    # Convert final numpy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4990,
    "candidates_token_count": 23414,
    "total_token_count": 28404,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 181.035622,
  "retries": 1
}