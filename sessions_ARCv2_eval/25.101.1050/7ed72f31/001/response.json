{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by applying symmetry operations to specific objects.\n\nThe core transformation identifies objects composed of exactly two colors: red (2)\nand one other color (C). It then determines the geometric shape formed by the\nred pixels within that object.\n\n1.  If the red pixels form a single point (P), the C-colored pixels of that\n    object are reflected through point symmetry around P.\n2.  If the red pixels form a continuous straight horizontal line (L), the\n    C-colored pixels are reflected across line L.\n3.  If the red pixels form a continuous straight vertical line (L), the\n    C-colored pixels are reflected across line L.\n\nReflected pixels are added to the output grid only if their target location\ncontains the background color. Objects that do not contain red, contain only\nred, or contain red and more than one other color are left unchanged. The\nbackground color also remains unchanged. Cases where red pixels form a more\ncomplex shape or where C pixels are already symmetric relative to the red line\nmight not be fully handled by this initial implementation based on observed\ndominant patterns.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef get_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    colors, counts = np.unique(grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef find_objects(grid: np.ndarray, background_color: int) -> list[dict]:\n    \"\"\"\n    Finds connected components (objects) of non-background colors using BFS.\n    Uses 8-way connectivity (includes diagonals).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                # Start BFS for a new object\n                q = [(r, c)]\n                visited[r, c] = True\n                current_object_coords = set()\n                current_object_colors = set()\n                \n                while q:\n                    row, col = q.pop(0)\n                    current_object_coords.add((row, col))\n                    current_object_colors.add(grid[row, col])\n                    \n                    # Explore 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if valid pixel for object\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] != background_color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                objects.append({\n                    'coords': current_object_coords,\n                    'colors': current_object_colors\n                })\n    return objects\n\ndef is_straight_line(coords: set[tuple[int, int]]) -> tuple[str, int] | tuple[None, None]:\n    \"\"\"Checks if coords form a straight horizontal or vertical line of length >= 1.\"\"\"\n    if not coords:\n        return None, None\n        \n    rows = {r for r, c in coords}\n    cols = {c for r, c in coords}\n\n    if len(rows) == 1:\n        # Potentially horizontal\n        min_c, max_c = min(cols), max(cols)\n        # Check continuity\n        if len(cols) == max_c - min_c + 1 and len(coords) == len(cols):\n             # Check all points are on the line\n             line_row = list(rows)[0]\n             expected_coords = {(line_row, c) for c in range(min_c, max_c + 1)}\n             if coords == expected_coords:\n                 return \"horizontal\", line_row\n                 \n    if len(cols) == 1:\n        # Potentially vertical\n        min_r, max_r = min(rows), max(rows)\n        # Check continuity\n        if len(rows) == max_r - min_r + 1 and len(coords) == len(rows):\n            # Check all points are on the line\n            line_col = list(cols)[0]\n            expected_coords = {(r, line_col) for r in range(min_r, max_r + 1)}\n            if coords == expected_coords:\n                return \"vertical\", line_col\n\n    return None, None\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Applies the symmetry transformation.\"\"\"\n    \n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Determine background color\n    background_color = get_background_color(input_np)\n\n    # Find all distinct objects\n    objects = find_objects(input_np, background_color)\n\n    # Process objects that contain red (2) and exactly one other color\n    for obj in objects:\n        colors = obj['colors']\n        coords = obj['coords']\n\n        if len(colors) == 2 and 2 in colors:\n            other_color = list(colors - {2})[0]\n            \n            # Separate coordinates by color\n            red_coords = {coord for coord in coords if input_np[coord] == 2}\n            c_coords = {coord for coord in coords if input_np[coord] == other_color}\n\n            # Case 1: Single red pixel - Point Symmetry\n            if len(red_coords) == 1:\n                center_r, center_c = list(red_coords)[0]\n                for r, c in c_coords:\n                    reflected_r = 2 * center_r - r\n                    reflected_c = 2 * center_c - c\n                    \n                    # Add reflected pixel if within bounds and on background\n                    if 0 <= reflected_r < height and 0 <= reflected_c < width and \\\n                       output_np[reflected_r, reflected_c] == background_color:\n                        output_np[reflected_r, reflected_c] = other_color\n\n            # Case 2 & 3: Red pixels form a straight line - Line Symmetry\n            else:\n                line_type, line_coord = is_straight_line(red_coords)\n                \n                if line_type == \"horizontal\":\n                    line_row = line_coord\n                    for r, c in c_coords:\n                        reflected_r = 2 * line_row - r\n                        reflected_c = c\n                        # Add reflected pixel if within bounds and on background\n                        if 0 <= reflected_r < height and 0 <= reflected_c < width and \\\n                           output_np[reflected_r, reflected_c] == background_color:\n                            output_np[reflected_r, reflected_c] = other_color\n                            \n                elif line_type == \"vertical\":\n                    line_col = line_coord\n                    for r, c in c_coords:\n                        reflected_r = r\n                        reflected_c = 2 * line_col - c\n                        # Add reflected pixel if within bounds and on background\n                        if 0 <= reflected_r < height and 0 <= reflected_c < width and \\\n                           output_np[reflected_r, reflected_c] == background_color:\n                            output_np[reflected_r, reflected_c] = other_color\n                \n                # Else: Red pixels form a complex shape or other configuration.\n                # Based on the analysis, the simple rules cover most cases.\n                # The more complex cases (like T1 Yellow/Red, T1 Azure/Red)\n                # are not explicitly handled by this core logic yet.\n                # If needed, additional rules could be added here.\n                # For now, we do nothing for these complex/unhandled cases.\n\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5401,
    "candidates_token_count": 9425,
    "total_token_count": 14826,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 68.156051,
  "retries": 1
}