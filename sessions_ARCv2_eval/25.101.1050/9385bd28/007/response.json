{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the background color (BG) as the most frequent pixel color in the input grid.\n2.  Identify source colors (S) as non-background colors adjacent to BG. Determine orthogonal adjacencies between different source colors.\n3.  Derive a source-to-fill map (M) using Hypothesis 20:\n    a. For each source color s:\n        i. If s is adjacent to any source color s' where s' > s, map s to the highest such adjacent s'.\n        ii. Otherwise, map s to itself.\n4.  Initialize the output grid as a copy of the input grid.\n5.  Perform an iterative flood fill using the derived map M until no changes occur:\n    a. In each iteration, calculate the next grid state based on the current state.\n    b. For each pixel (r, c):\n        i. Get its current color `current_color`.\n        ii. Examine orthogonal neighbors in the current grid state.\n        iii. Collect \"fill influences\":\n            - If a neighbor has color `C_n` which is a source `s` in map M, the influence is `M[s]`.\n            - If a neighbor has color `C_n` which is a fill color `f` (a value in M), the influence is `f`.\n        iv. If influences exist, find the `winning_fill` color (the influence with the lowest index/highest priority).\n        v. Update the pixel in the *next* grid state to `winning_fill` if:\n            - `current_color` is BG, OR\n            - `winning_fill` has a higher priority (lower index) than `current_color`.\n    c. Update the current grid with the next grid state.\n6.  Return the final stabilized grid.\n\n(Caveat): The map derivation rule (Hypothesis 20) is the best fit found during analysis but is known not to perfectly replicate the mapping for all provided training examples (specifically Examples 1 and 3).\n\"\"\"\n\ndef find_background_color(grid_np: np.ndarray) -> int:\n    \"\"\" Finds the most frequent color in the grid. \"\"\"\n    if grid_np.size == 0:\n        return 0 # Default assumption\n    colors, counts = np.unique(grid_np, return_counts=True)\n    if len(colors) == 0:\n        return 0 # Default assumption\n    return colors[np.argmax(counts)]\n\ndef get_neighbors(h: int, w: int, r: int, c: int) -> list[tuple[int, int]]:\n    \"\"\" Get orthogonal neighbor coordinates within grid bounds. \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < h - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < w - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef get_sources_and_adjacency(grid_np: np.ndarray, background_color: int) -> tuple[set[int], dict[int, set[int]]]:\n    \"\"\"\n    Identifies source colors (non-BG adjacent to BG) and\n    inter-source adjacencies.\n    Returns:\n        - set of source colors (S)\n        - dict mapping S -> set of adjacent different source colors\n    \"\"\"\n    h, w = grid_np.shape\n    sources = set()\n    source_pixel_coords = {} # Store coords for adjacency check\n    all_non_bg_colors = set(np.unique(grid_np)) - {background_color}\n\n    # First pass: identify all non-BG pixel locations and which colors are sources\n    for color in all_non_bg_colors:\n         source_pixel_coords[color] = []\n\n    processed_sources = set() # Track colors checked for BG adjacency\n    for r in range(h):\n        for c in range(w):\n            color = grid_np[r, c]\n            if color != background_color:\n                source_pixel_coords[color].append((r,c))\n                # Check adjacency to background only once per color type\n                if color not in processed_sources:\n                    is_adj_to_bg = False\n                    for nr, nc in get_neighbors(h, w, r, c):\n                        if grid_np[nr, nc] == background_color:\n                            is_adj_to_bg = True\n                            break\n                    if is_adj_to_bg:\n                        sources.add(color)\n                    processed_sources.add(color) # Mark as checked\n\n    # Second pass: determine adjacencies between source colors\n    source_adjacencies = {s: set() for s in sources}\n    for s_color in sources:\n        if s_color not in source_pixel_coords: continue\n        for r, c in source_pixel_coords[s_color]:\n            for nr, nc in get_neighbors(h, w, r, c):\n                neighbor_color = grid_np[nr, nc]\n                # Check if neighbor is a *different* source color\n                if neighbor_color in sources and neighbor_color != s_color:\n                    source_adjacencies[s_color].add(neighbor_color)\n\n    return sources, source_adjacencies\n\n\ndef derive_map_hypothesis20(sources: set[int], source_adjacencies: dict[int, set[int]]) -> dict[int, int]:\n    \"\"\"\n    Derives Source-to-Fill map (M) using Hypothesis 20.\n    Maps S -> max(adjacent S') if adjacent S' > S exists, else S -> S.\n    \"\"\"\n    mapping = {}\n    for s in sources:\n        map_target = s # Default: map to self\n        max_higher_adj = -1\n        # Check adjacent sources\n        if s in source_adjacencies:\n            for adj_s in source_adjacencies[s]:\n                if adj_s > s: # Found adjacent source with higher index\n                    max_higher_adj = max(max_higher_adj, adj_s)\n\n        # If a higher adjacent source was found, map to the highest one\n        if max_higher_adj != -1:\n             map_target = max_higher_adj\n\n        mapping[s] = map_target\n    return mapping\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule described above.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    h, w = input_grid_np.shape\n\n    # Handle edge cases: empty or uniform grid\n    if h == 0 or w == 0:\n        return input_grid\n    unique_colors_input = np.unique(input_grid_np)\n    if len(unique_colors_input) <= 1:\n        return input_grid\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Identify Sources and Adjacencies\n    sources, source_adjacencies = get_sources_and_adjacency(input_grid_np, background_color)\n\n    # Handle edge case: no sources found\n    if not sources:\n        return input_grid # No fill can happen\n\n    # 3. Derive Source-to-Fill Map (Hypothesis 20)\n    source_fill_map = derive_map_hypothesis20(sources, source_adjacencies)\n    fill_colors_set = set(source_fill_map.values()) # Set of colors used for filling\n\n    # 4. Initialize Working Grid\n    working_grid_np = np.copy(input_grid_np)\n\n    # 5. Iterative Filling using Map\n    while True:\n        changed = False\n        next_grid_np = np.copy(working_grid_np)\n\n        # Iterate through each pixel\n        for r in range(h):\n            for c in range(w):\n                current_color = working_grid_np[r, c]\n                influences = []\n\n                # Collect influences from neighbors based on the map\n                for nr, nc in get_neighbors(h, w, r, c):\n                    neighbor_color = working_grid_np[nr, nc]\n\n                    if neighbor_color == background_color:\n                        continue # Background neighbors don't influence\n\n                    # Check if neighbor is a source in our map\n                    if neighbor_color in source_fill_map:\n                        influences.append(source_fill_map[neighbor_color])\n                    # Check if neighbor is already a fill color\n                    elif neighbor_color in fill_colors_set:\n                         influences.append(neighbor_color)\n                    # Else: neighbor is non-BG, non-source, non-fill - acts as barrier only\n\n                # If influenced, determine winning fill and update if needed\n                if influences:\n                    winning_fill = min(influences) # Lowest index = highest priority\n\n                    update_pixel = False\n                    if current_color == background_color:\n                        update_pixel = True\n                    elif winning_fill < current_color: # Priority check\n                        update_pixel = True\n\n                    # Apply update to next state grid if value changes\n                    if update_pixel and next_grid_np[r, c] != winning_fill:\n                        next_grid_np[r, c] = winning_fill\n                        changed = True\n\n        # Update working grid for next iteration\n        working_grid_np = next_grid_np\n\n        # Check for stabilization\n        if not changed:\n            break\n\n    # 6. Return final grid\n    return working_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 65516,
    "candidates_token_count": 2646,
    "total_token_count": 68162,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.051668,
  "retries": 1
}