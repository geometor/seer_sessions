{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the background color (most frequent color in the input grid).\n2.  Determine the source-to-fill color mapping based on color adjacency to the background:\n    a. Find 'source' colors: non-background colors where at least one pixel of that color is orthogonally adjacent to the background color.\n    b. Find 'potential fill-determining' colors (PFDs): non-background colors where *no* pixel of that color is orthogonally adjacent to the background color.\n    c. If PFDs exist:\n        - Each source color maps to the PFD color that is 'closest'. Closeness is defined as the minimum Manhattan distance between any pixel of the source color and any pixel of the PFD color.\n        - Ties in distance are broken by choosing the PFD color with the lower numerical index (color value).\n    d. If no PFDs exist:\n        - Each source color maps to itself (identity map). Source colors that are not adjacent to the background are ignored.\n3.  Initialize the output grid as a copy of the input grid.\n4.  Perform an iterative flood-fill process until no changes occur in a full grid scan:\n    a. In each iteration, calculate the next state of the grid based on the current state.\n    b. For each pixel `(r, c)` in the grid:\n        i.  Examine its orthogonal neighbors in the *current* grid state.\n        ii. Collect 'fill influences' from neighbors:\n            - If a neighbor has a color `N` which is a source color (from step 2a), its influence is the corresponding fill color `F` from the mapping (step 2c/2d).\n            - If a neighbor has a color `N` which is itself one of the fill colors active in the mapping, its influence is `N`.\n        iii. If there are any fill influences, determine the 'winning' fill color: the influencing fill color with the lowest numerical index (highest priority).\n        iv. Consider the current color `C` at `(r, c)`.\n        v.  If `C` is the background color, update the pixel in the *next* grid state to the winning fill color.\n        vi. If `C` is not the background color, update the pixel in the *next* grid state to the winning fill color *only if* the winning fill color's index is strictly lower than `C`'s index (i.e., the winning fill has higher priority).\n    c. After scanning all pixels, update the current grid state to the calculated next state.\n5.  Once an iteration completes with no changes, return the final grid state.\n\"\"\"\n\ndef get_neighbors(h, w, r, c):\n    \"\"\" Get orthogonal neighbor coordinates within grid bounds. \"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < h - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < w - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef find_background_color(grid_np):\n    \"\"\" Finds the most frequent color in the grid. \"\"\"\n    # Faster way for potentially large grids if numpy is available\n    colors, counts = np.unique(grid_np, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef derive_source_fill_map(grid_np, background_color):\n    \"\"\" Derives the source-to-fill color mapping based on adjacency rules. \"\"\"\n    h, w = grid_np.shape\n    unique_colors = np.unique(grid_np)\n    non_background_colors = unique_colors[unique_colors != background_color]\n\n    if len(non_background_colors) == 0:\n        return {} # No non-background colors, no mapping needed\n\n    color_pixels = {c: [] for c in non_background_colors}\n    for r in range(h):\n        for c in range(w):\n            color = grid_np[r, c]\n            if color != background_color:\n                color_pixels[color].append((r, c))\n\n    # Determine which colors are adjacent to background (sources)\n    # and which are not (potential fill determiners - PFDs)\n    sources = set()\n    non_adjacent_fills = set(non_background_colors) # Assume non-adjacent initially\n    for color in non_background_colors:\n        is_adj = False\n        # Check if *any* pixel of this color touches the background\n        if color not in color_pixels: continue # Should not happen\n        for r, c in color_pixels[color]:\n             for nr, nc in get_neighbors(h, w, r, c):\n                 if grid_np[nr, nc] == background_color:\n                     is_adj = True\n                     break\n             if is_adj:\n                 break # Found adjacency, no need to check more pixels for this color\n        if is_adj:\n            sources.add(color)\n            if color in non_adjacent_fills:\n                non_adjacent_fills.remove(color) # Correct its status\n\n    source_map = {}\n    # Case 1: PFDs exist - map sources to closest PFD\n    if non_adjacent_fills:\n        # Calculate all pairwise min distances between source pixels and PFD pixels\n        min_dists = {} # Stores min distance from any pixel of s to any pixel of f: (s, f) -> min_dist\n        for s in sources:\n            if not color_pixels[s]: continue # Skip if source color has no pixels (edge case)\n            for f in non_adjacent_fills:\n                if not color_pixels[f]: continue # Skip if fill color has no pixels (edge case)\n\n                current_min = float('inf')\n                # Find min Manhattan distance between any pixel of s and any pixel of f\n                for r_s, c_s in color_pixels[s]:\n                    for r_f, c_f in color_pixels[f]:\n                        dist = abs(r_s - r_f) + abs(c_s - c_f)\n                        current_min = min(current_min, dist)\n                min_dists[(s, f)] = current_min\n\n        # For each source, find the PFD f with the minimum distance\n        for s in sources:\n            best_f = -1\n            min_dist_for_s = float('inf')\n\n            # Iterate through potential fills 'f' for this source 's'\n            for f in non_adjacent_fills:\n                 dist_key = (s, f)\n                 if dist_key not in min_dists: continue # Should exist if calculated above\n\n                 dist = min_dists[dist_key]\n                 # Check if this f is closer than the current best_f\n                 if dist < min_dist_for_s:\n                      min_dist_for_s = dist\n                      best_f = f\n                 # If distance is the same, tie-break using lower color index\n                 elif dist == min_dist_for_s:\n                      if best_f == -1 or f < best_f:\n                           best_f = f\n\n            # Assign the determined mapping if a best fill was found\n            if best_f != -1:\n                 source_map[s] = best_f\n            # else: If a source couldn't map (e.g., no PFDs reachable?), it won't fill.\n\n    # Case 2: No PFDs exist - use identity map for sources\n    else:\n        for s in sources:\n            source_map[s] = s\n\n    return source_map\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the flood fill transformation based on derived source-fill mapping.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    h, w = input_grid_np.shape\n\n    # Handle edge case of uniform grid or empty grid\n    if h == 0 or w == 0 or len(np.unique(input_grid_np)) <= 1:\n        return input_grid\n\n    # 1. Identify Background Color\n    background_color = find_background_color(input_grid_np)\n\n    # 2. Derive Source-Fill Mapping\n    source_fill_map = derive_source_fill_map(input_grid_np, background_color)\n\n    # If no sources map to anything, return input as no fill can happen\n    if not source_fill_map:\n         return input_grid\n\n    # Get the set of actual fill colors used in the map values\n    fill_colors = set(source_fill_map.values())\n\n    # 3. Initialize Output Grid\n    output_grid_np = np.copy(input_grid_np)\n\n    # 4. Iterative Flood Fill\n    while True:\n        changed = False\n        # Create a grid for the next state based on the current 'output_grid_np'\n        next_grid_np = np.copy(output_grid_np)\n\n        for r in range(h):\n            for c in range(w):\n                current_color = output_grid_np[r, c] # Color in the *current* state\n\n                # Store potential fill colors influencing (r,c) with their priority\n                # We use the color index itself as priority (lower index = higher priority)\n                potential_fills_priority = {} # {priority: color}\n\n                # Check neighbors in the *current* state grid\n                for nr, nc in get_neighbors(h, w, r, c):\n                    neighbor_color = output_grid_np[nr, nc]\n\n                    # Ignore background neighbors\n                    if neighbor_color == background_color:\n                        continue\n\n                    fill_candidate = -1 # Reset for each neighbor\n\n                    # Check if neighbor is a source -> find its fill color\n                    if neighbor_color in source_fill_map:\n                        fill_candidate = source_fill_map[neighbor_color]\n                    # Check if neighbor is already a fill color itself\n                    elif neighbor_color in fill_colors:\n                         fill_candidate = neighbor_color\n\n                    # If this neighbor provides a valid fill influence\n                    if fill_candidate != -1:\n                        priority = fill_candidate # Priority is the color index\n                        # Store the candidate color if it's the best for this priority level found so far\n                        # (Handles cases where multiple neighbors might map to the same fill)\n                        # We only need the lowest color index for any given priority level.\n                        if priority not in potential_fills_priority:\n                             potential_fills_priority[priority] = fill_candidate\n                        # This secondary check shouldn't be needed if priority == color index\n                        # else:\n                        #    potential_fills_priority[priority] = min(fill_candidate, potential_fills_priority[priority])\n\n\n                # If any neighbor provided a fill influence for pixel (r,c)\n                if potential_fills_priority:\n                    # Find the highest priority (lowest index) winning fill color\n                    winning_priority = min(potential_fills_priority.keys())\n                    winning_fill_color = potential_fills_priority[winning_priority]\n\n                    # Decide whether to update the pixel in the *next* grid state\n                    # Case A: Current pixel is background\n                    if current_color == background_color:\n                        # Update if the calculated next state is different\n                        if next_grid_np[r, c] != winning_fill_color:\n                             next_grid_np[r, c] = winning_fill_color\n                             changed = True\n                    # Case B: Current pixel is not background\n                    elif current_color != winning_fill_color: # Avoid self-overwrite checks\n                        current_priority = current_color\n                        # Update only if winning fill has strictly higher priority (lower index)\n                        if winning_priority < current_priority:\n                             if next_grid_np[r, c] != winning_fill_color:\n                                 next_grid_np[r, c] = winning_fill_color\n                                 changed = True\n                        # If winning_priority >= current_priority, the existing color stays or wins.\n\n\n        # Update the grid state for the next iteration\n        output_grid_np = next_grid_np\n\n        # If no pixels were changed in this full iteration, the process has stabilized\n        if not changed:\n            break\n\n    # 5. Return the final grid state\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5785,
    "candidates_token_count": 19461,
    "total_token_count": 25246,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 156.054495,
  "retries": 1
}