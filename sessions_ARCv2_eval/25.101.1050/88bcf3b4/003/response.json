{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation operates on two specific columns determined by the input grid's content: \nC1 (the rightmost column with any non-background pixel) and C2 (the second rightmost column with any non-background pixel).\nIt identifies the topmost non-background pixel in each of these input columns (V_top_C1 at R_top_C1, and V_top_C2 at R_top_C2).\nThe output grid is initialized with the background color.\nThen, column C1 of the output is populated: pixels from input column C1 are copied if they are not background; background pixels in output C1 *above* R_top_C1 are filled with V_top_C2.\nNext, column C2 of the output is populated: pixels from input column C2 are copied if they are not background; background pixels in output C2 *above* R_top_C2 are filled with V_top_C2, but *only if* a condition based on the content of column C1 at the same row is met (specifically, if the already computed output value at C1 is background, OR if the original input value at C1 was V_top_C1).\nAll other columns in the output remain background color.\n\"\"\"\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background if grid is empty\n    # Simplification: Assume most frequent color is background\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_target_columns(grid: np.ndarray, background_color: int) -> tuple[int | None, int | None]:\n    \"\"\"\n    Finds the indices of the rightmost (C1) and second rightmost (C2) columns\n    containing non-background pixels.\n    Returns (C1, C2). Returns None for an index if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    non_bg_cols = set()\n    for c in range(cols):\n        if np.any(grid[:, c] != background_color):\n            non_bg_cols.add(c)\n\n    sorted_cols = sorted(list(non_bg_cols))\n\n    C1 = sorted_cols[-1] if sorted_cols else None\n    C2 = sorted_cols[-2] if len(sorted_cols) > 1 else None\n\n    return C1, C2\n\ndef find_topmost_non_background(grid: np.ndarray, col_idx: int, background_color: int, height: int) -> tuple[int, int]:\n    \"\"\"\n    Finds the row index (R_top) and value (V_top) of the topmost\n    non-background pixel in the specified column.\n    Returns (R_top, V_top). If column is empty or invalid,\n    returns (height, background_color).\n    \"\"\"\n    if col_idx is None or col_idx < 0 or col_idx >= grid.shape[1]:\n        return height, background_color # Indicate no pixel found\n\n    column_data = grid[:, col_idx]\n    non_bg_indices = np.where(column_data != background_color)[0]\n\n    if non_bg_indices.size == 0:\n        return height, background_color # Indicate no pixel found\n\n    R_top = non_bg_indices[0]\n    V_top = grid[R_top, col_idx]\n    return R_top, V_top\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the defined logic involving C1, C2,\n    and upward filling based on topmost pixels V_top_C1 and V_top_C2.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Determine the background color\n    bg = find_background_color(input_np)\n\n    # 2. & 3. Identify target columns C1 and C2\n    C1, C2 = find_target_columns(input_np, bg)\n\n    # Handle edge case: No non-background pixels found\n    if C1 is None:\n        return input_grid # Or return np.full_like(input_np, bg).tolist()\n\n    # 4. Find topmost non-background pixel in C1\n    R_top_C1, V_top_C1 = find_topmost_non_background(input_np, C1, bg, height)\n\n    # 5. Find topmost non-background pixel in C2\n    # Note: If C2 is None, find_topmost_non_background handles it correctly\n    R_top_C2, V_top_C2 = find_topmost_non_background(input_np, C2, bg, height)\n\n    # 6. Create the output grid filled with background color\n    output_np = np.full_like(input_np, bg)\n\n    # 7. Process output column C1\n    for r in range(height):\n        V_current_C1 = input_np[r, C1]\n        if V_current_C1 != bg:\n            # 7b. Copy non-background pixel from input C1\n            output_np[r, C1] = V_current_C1\n        elif r < R_top_C1:\n             # 7c. Fill background cells above R_top_C1 with V_top_C2\n            output_np[r, C1] = V_top_C2\n        # else: leave as background (already initialized)\n\n    # 8. Process output column C2 (only if C2 exists)\n    if C2 is not None:\n        for r in range(height):\n            V_current_C2 = input_np[r, C2]\n            if V_current_C2 != bg:\n                # 8b. Copy non-background pixel from input C2\n                output_np[r, C2] = V_current_C2\n            elif r < R_top_C2:\n                # 8c. Check condition for upward fill\n                # Condition: (output[r, C1] == bg) OR (input[r, C1] == V_top_C1)\n                # Note: Need to handle the case where V_top_C1 might be bg if C1 was empty,\n                # but find_topmost_non_background ensures V_top_C1 is bg only if R_top_C1 is height.\n                # The input[r, C1] == V_top_C1 check only makes sense if V_top_C1 is not bg.\n                condition_met = False\n                if output_np[r, C1] == bg:\n                    condition_met = True\n                # Check second part of OR only if V_top_C1 was actually found\n                elif R_top_C1 < height and input_np[r, C1] == V_top_C1:\n                     condition_met = True\n\n                if condition_met:\n                     # Fill background cells above R_top_C2 with V_top_C2 if condition met\n                    output_np[r, C2] = V_top_C2\n            # else: leave as background (already initialized)\n\n    # 9. Return the result as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14051,
    "candidates_token_count": 2290,
    "total_token_count": 16341,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.266237,
  "retries": 1
}