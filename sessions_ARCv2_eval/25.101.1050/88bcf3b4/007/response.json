{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation rule is conditional, determined by the relative vertical positions of the topmost non-background pixels in the two rightmost columns containing non-background pixels.\n\n1.  Identify the background color (`bg`), the rightmost column with non-background pixels (`C1`), and the second rightmost (`C2`).\n2.  Find the topmost non-background pixel in `C1` (Value `V1` at row `R1`) and in `C2` (Value `V2` at row `R2`).\n3.  **Condition Check:** If both `R1` and `R2` are found AND `R1 < R2`, apply the 'H11c' rule. Otherwise, apply the 'H_DownProp' rule.\n\n**H11c Rule (R1 < R2):**\n   - Initialize the output grid with `bg`.\n   - Process column `C1`: Copy non-`bg` pixels from input `C1`. Fill `bg` pixels in output `C1` *above* `R1` with `V2`.\n   - Process column `C2`: Copy non-`bg` pixels from input `C2`. Fill `bg` pixels in output `C2` *above* `R2` with `V2`, but only if the cell `(r, C1)` in the *output* is `bg` OR the cell `(r, C1)` in the *input* was `V1`.\n   - All other output columns remain `bg`.\n\n**H_DownProp Rule (R1 >= R2 or C2/R1/R2 not found):**\n   - Initialize the output grid as a copy of the input grid.\n   - For every cell `(r, c)` in the output grid: If it's `bg`, search downwards in the *input* column `c` starting from row `r+1`. If a non-`bg` pixel is found at row `r'`, set `output[r, c]` to the value of `input[r', c]`. If no non-`bg` pixel is found below, it remains `bg`. This propagation happens independently for each column.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the background color (most frequent, prioritizing 0 if dominant).\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts: return 0\n    if grid.size > 0:\n        zero_count = counts.get(0, 0)\n        # Safely get most common element, default to (0,0) if counts is empty\n        most_frequent_color, most_frequent_count = counts.most_common(1)[0] if counts else (0, 0)\n        # Prioritize 0 if it's most frequent or covers > 50%\n        if zero_count == most_frequent_count or zero_count > grid.size * 0.5:\n             background_color = 0\n        else:\n             background_color = most_frequent_color\n    else:\n        background_color = 0\n    return background_color\n\ndef find_target_columns(grid: np.ndarray, background_color: int) -> tuple[int | None, int | None]:\n    \"\"\"Finds indices C1 (rightmost) and C2 (second rightmost) with non-bg pixels.\"\"\"\n    rows, cols = grid.shape\n    non_bg_cols = set()\n    if grid.size == 0: return None, None\n    for c in range(cols):\n        if np.any(grid[:, c] != background_color):\n            non_bg_cols.add(c)\n    sorted_cols = sorted(list(non_bg_cols))\n    C1 = sorted_cols[-1] if sorted_cols else None\n    C2 = sorted_cols[-2] if len(sorted_cols) > 1 else None\n    return C1, C2\n\ndef find_topmost_non_background(grid: np.ndarray, col_idx: int | None, background_color: int) -> tuple[int | None, int | None]:\n    \"\"\"Finds row R_top and value V_top of the topmost non-bg pixel in col_idx.\"\"\"\n    if col_idx is None or col_idx < 0 or col_idx >= grid.shape[1]: return None, None\n    height = grid.shape[0]\n    column_data = grid[:, col_idx]\n    non_bg_indices = np.where(column_data != background_color)[0]\n    if non_bg_indices.size == 0: return None, None\n    R_top = non_bg_indices[0]\n    V_top = grid[R_top, col_idx]\n    return R_top, V_top\n\ndef apply_h11c_transformation(input_np: np.ndarray, bg: int, C1: int, R1: int, V1: int, C2: int, R2: int, V2: int) -> np.ndarray:\n    \"\"\"Applies the H11c transformation logic.\"\"\"\n    height, width = input_np.shape\n    output_np = np.full_like(input_np, bg)\n    \n    # Determine fill values, defaulting to bg if V2 is None (shouldn't happen if R2 is not None, but safety check)\n    fill_val_for_c1_gaps = V2 if V2 is not None else bg\n    fill_val_for_c2_gaps = V2 if V2 is not None else bg\n\n    # Process column C1\n    for r in range(height):\n        V_current_C1 = input_np[r, C1]\n        if V_current_C1 != bg:\n            output_np[r, C1] = V_current_C1\n        elif R1 is not None and r < R1: # R1 should not be None here based on calling condition\n            output_np[r, C1] = fill_val_for_c1_gaps\n\n    # Process column C2\n    if C2 is not None and R2 is not None: # R2 should not be None here based on calling condition\n        for r in range(height):\n            V_current_C2 = input_np[r, C2]\n            if V_current_C2 != bg:\n                output_np[r, C2] = V_current_C2\n            elif r < R2:\n                # Condition: (output[r, C1] == bg) OR (input[r, C1] == V1)\n                condition_met = False\n                if output_np[r, C1] == bg:\n                    condition_met = True\n                # V1 should not be None if R1 is not None\n                elif R1 is not None and V1 is not None and input_np[r, C1] == V1: \n                     condition_met = True\n\n                if condition_met:\n                    output_np[r, C2] = fill_val_for_c2_gaps\n                    \n    return output_np\n\ndef apply_h_downprop_transformation(input_np: np.ndarray, bg: int) -> np.ndarray:\n    \"\"\"Applies the H_DownProp transformation logic (propagate first non-bg pixel downwards).\"\"\"\n    height, width = input_np.shape\n    output_np = input_np.copy() # Start with a copy\n\n    for c in range(width):\n        # Find the value to propagate downwards for this column\n        propagate_val = None\n        # Iterate upwards to find the first non-bg value that *would* be propagated down\n        # This is complex. Let's rethink.\n        # Alternative: Iterate downwards, keeping track of the last non-bg value seen.\n        \n        # Correct DownProp: iterate each cell, if bg, look down *in input*\n        for r in range(height):\n            if output_np[r, c] == bg: # Check the current output cell state\n                # Search downwards in the *original input* column starting from r+1\n                found_val = None\n                for r_look in range(r + 1, height):\n                    if input_np[r_look, c] != bg:\n                        found_val = input_np[r_look, c]\n                        break # Found the first non-bg value below\n                \n                # If a value was found below, update the output cell\n                if found_val is not None:\n                    output_np[r, c] = found_val\n                    \n    return output_np\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on a conditional rule determined by the\n    relative positions of the topmost non-background pixels in the two\n    rightmost non-background columns (C1, C2).\n    If R1 < R2, applies H11c rule. Otherwise, applies H_DownProp rule.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    if input_np.size == 0:\n        return []\n    height, width = input_np.shape\n\n    # Step 1: Determine background color\n    bg = find_background_color(input_np)\n\n    # Step 2 & 3: Find target columns C1 and C2\n    C1, C2 = find_target_columns(input_np, bg)\n\n    # If no non-background pixels exist at all, return original grid\n    if C1 is None:\n        return input_grid\n\n    # Step 4 & 5: Find topmost pixels R1, V1 and R2, V2\n    R1, V1 = find_topmost_non_background(input_np, C1, bg)\n    R2, V2 = find_topmost_non_background(input_np, C2, bg)\n\n    # Step 6: Conditional Check\n    apply_h11c = False\n    if R1 is not None and R2 is not None and R1 < R2:\n        apply_h11c = True\n\n    # Step 7 or 8: Apply the chosen transformation\n    if apply_h11c:\n        # We are sure R1, V1, R2, V2, C1, C2 are not None here\n        output_np = apply_h11c_transformation(input_np, bg, C1, R1, V1, C2, R2, V2)\n    else:\n        output_np = apply_h_downprop_transformation(input_np, bg)\n\n    # Step 9: Return result as list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 41382,
    "candidates_token_count": 2799,
    "total_token_count": 44181,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.880106,
  "retries": 1
}