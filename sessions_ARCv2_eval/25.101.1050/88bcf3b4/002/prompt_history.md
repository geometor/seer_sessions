
## train_1

**input:**
```
0 0 0 0 0 0 0
0 0 0 0 0 2 0
0 0 0 0 0 0 0
0 0 0 4 4 8 0
0 0 0 4 0 8 0
0 0 4 4 0 8 0
0 4 0 0 0 8 0
```


**output:**
```
0 0 0 0 0 4 0
0 0 0 0 4 2 0
0 0 0 0 4 0 0
0 0 0 0 4 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
0 0 0 0 0 8 0
```


## train_2

**input:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 7 7 3 7 2 7 7 7 7
7 7 7 3 3 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


**output:**
```
7 7 7 7 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 3 4 7 7 7 7 7 7 7
7 7 7 7 3 7 7 7 7 7 7 7
7 7 7 7 7 3 7 7 7 7 7 7
7 7 7 7 7 7 3 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
7 7 7 7 7 7 7 2 7 7 7 7
```


## train_3

**input:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 7 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 7 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 7 7 1 1 1 1
1 1 1 1 1 1 2 1 7 7 7 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 2 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 9 7 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 7 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 3 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 0 8 0 5 0 0 0 0 0
0 8 8 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


**output:**
```
0 0 0 8 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 8 3 0 0 0 0 0 0 0
0 0 8 3 0 0 0 0 0 0
0 0 0 8 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 9 0 6 0 0 0
9 9 9 0 0 6 0 0 0
9 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 9 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 9 3 0 0 0 0 0
0 0 0 9 0 0 0 0 0
0 0 0 0 9 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
0 0 0 0 0 6 0 0 0
```

**Perception**

The task involves transforming input grids based on the positions of non-background pixels within each row. The transformation seems to focus on the two rightmost pixels in each row of the input grid and maps them to specific columns in the output grid. The background color remains the same, and the grid dimensions are preserved. The core operation appears to be a projection or consolidation of information from each row onto two specific target columns, determined by the overall grid content.

**Facts**


```yaml
task_context:
  problem_type: grid_transformation
  grid_properties:
    - dimensions_preserved: True
    - background_color_preserved: True
    - cell_values: integers 0-9 (colors)
transformation_elements:
  target_columns:
    - identification: Determined by the overall content of the input grid.
    - role: Serve as the destination columns for projected pixels.
    - definition:
        - rightmost_column (max_col): The column with the largest index containing any non-background pixel in the input grid.
        - second_rightmost_column (col_R2): The column with the largest index less than max_col that contains any non-background pixel in the input grid.
  pixel_selection:
    - scope: Performed row by row on the input grid.
    - criteria: Identify the non-background pixels in the current row.
    - focus: Primarily on the one or two rightmost non-background pixels within the row.
  pixel_mapping:
    - scope: Maps selected input pixels to the output grid.
    - logic:
        - The rightmost non-background pixel of input row `r` is mapped to output row `r` at column `max_col`.
        - The second rightmost non-background pixel (if it exists) of input row `r` is mapped to output row `r` at column `col_R2`.
    - collision_handling: Implicitly handled by the selection; only the two rightmost pixels influence the output for that row in the target columns. Other pixels in the row are ignored for this projection.
  background_pixels:
    - handling: Fill all cells in the output grid initially. Cells not overwritten by the mapping remain background color.
objects:
  - type: Pixels
    properties:
      - color (value 0-9)
      - position (row, column)
  - type: Rows
    properties:
      - collection of pixels
      - rightmost non-background pixel
      - second rightmost non-background pixel
  - type: Columns
    properties:
      - index
      - contains_non_background (boolean)
relationships:
  - pixel_in_row: A pixel belongs to a specific row.
  - pixel_in_column: A pixel belongs to a specific column.
  - rightmost_pixel: For a given row, the non-background pixel with the highest column index.
  - second_rightmost_pixel: For a given row, the non-background pixel with the second-highest column index.
actions:
  - find_background_color
  - find_rightmost_column_index (max_col)
  - find_second_rightmost_column_index (col_R2)
  - initialize_output_grid
  - iterate_through_rows
  - find_row_pixels
  - sort_row_pixels_by_column
  - place_pixel_in_output_grid
```


**Natural Language Program**

1.  Determine the background color (the most frequent color in the input grid).
2.  Identify the column index of the rightmost column containing any non-background pixel across the entire input grid. Call this `max_col`.
3.  Identify the column index of the rightmost column *before* `max_col` that contains any non-background pixel across the entire input grid. Call this `col_R2`. If no such column exists (i.e., all non-background pixels are in `max_col`), consider `col_R2` to be undefined or handle as a special case (though examples suggest `col_R2` usually exists).
4.  Create a new output grid of the same dimensions as the input grid, filled entirely with the background color.
5.  Process each row of the input grid individually, from top to bottom (row index `r` from 0 to height-1):
    a.  Find all non-background pixels within the current row `r`.
    b.  If non-background pixels exist in row `r`:
        i.  Sort these pixels based on their column index in descending order.
        ii. Let the pixel with the highest column index be `P1` (the rightmost pixel in the row) with color `V1`. Place color `V1` into the output grid at position (`r`, `max_col`).
        iii. If there is at least one more non-background pixel in the sorted list (i.e., the row had at least two non-background pixels), let the pixel with the second-highest column index be `P2` (the second rightmost) with color `V2`. Place color `V2` into the output grid at position (`r`, `col_R2`).
6.  The final state of the new grid is the result.
```python
import numpy as np
from collections import Counter

"""
The transformation identifies two target columns in the output grid based on the overall distribution of non-background pixels in the input grid. 
Specifically, it finds the rightmost column index ('max_col') containing any non-background pixel and the second rightmost column index ('col_R2') containing any non-background pixel.
It then iterates through each row of the input grid. For each row, it finds the non-background pixels. 
The color of the rightmost non-background pixel in the input row is placed in the corresponding row of the output grid at column 'max_col'.
If there is a second rightmost non-background pixel in the input row, its color is placed in the corresponding row of the output grid at column 'col_R2'.
The rest of the output grid is filled with the background color, which is the most frequent color in the input grid.
"""

def find_background_color(grid: np.ndarray) -> int:
    """Finds the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    if not counts:
        return 0 # Default background if grid is empty
    # Common case: most frequent is background
    # Handle cases where the background might not be the absolute most frequent
    # But typically in ARC, the background (often 0) dominates.
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_target_columns(grid: np.ndarray, background_color: int) -> tuple[int | None, int | None]:
    """
    Finds the indices of the rightmost and second rightmost columns
    containing non-background pixels.
    Returns (max_col, col_R2). Returns None for an index if not found.
    """
    rows, cols = grid.shape
    non_bg_cols = set()
    for c in range(cols):
        if np.any(grid[:, c] != background_color):
            non_bg_cols.add(c)

    sorted_cols = sorted(list(non_bg_cols))

    max_col = sorted_cols[-1] if sorted_cols else None
    col_R2 = sorted_cols[-2] if len(sorted_cols) > 1 else None

    return max_col, col_R2


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by projecting the two rightmost non-background
    pixels of each row onto two specific columns determined by the overall grid content.
    """
    input_np = np.array(input_grid, dtype=int)
    height, width = input_np.shape

    # 1. Determine the background color
    background_color = find_background_color(input_np)

    # 2. & 3. Identify target columns max_col and col_R2
    max_col, col_R2 = find_target_columns(input_np, background_color)

    # Handle cases where target columns might not be found (e.g., grid is all background)
    if max_col is None:
        # If no non-background pixels, return the input grid (or an all-background grid)
        return input_np.tolist() # Or create a new background grid

    # 4. Create the output grid filled with background color
    output_np = np.full_like(input_np, background_color)

    # 5. Process each row
    for r in range(height):
        row = input_np[r, :]
        # 5a. Find non-background pixels and their column indices
        non_bg_indices = np.where(row != background_color)[0]

        # 5b. If non-background pixels exist in the row
        if non_bg_indices.size > 0:
            # Sort indices descending to easily get rightmost and second rightmost
            sorted_non_bg_indices = np.sort(non_bg_indices)[::-1]

            # i. Get the rightmost pixel's color and place it in the output at max_col
            rightmost_col_idx = sorted_non_bg_indices[0]
            rightmost_color = input_np[r, rightmost_col_idx]
            output_np[r, max_col] = rightmost_color

            # iii. If a second rightmost pixel exists and col_R2 is defined
            if len(sorted_non_bg_indices) > 1 and col_R2 is not None:
                second_rightmost_col_idx = sorted_non_bg_indices[1]
                second_rightmost_color = input_np[r, second_rightmost_col_idx]
                output_np[r, col_R2] = second_rightmost_color

    # 6. Return the result as a list of lists
    return output_np.tolist()
```
