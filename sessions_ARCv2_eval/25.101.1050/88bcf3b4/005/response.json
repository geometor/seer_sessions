{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nThe transformation operates on two specific columns determined by the input grid's content: \nC1 (the rightmost column with any non-background pixel) and C2 (the second rightmost column with any non-background pixel).\nIt identifies the topmost non-background pixel in each of these input columns (V_top_C1 at R_top_C1, and V_top_C2 at R_top_C2).\nThe output grid is initialized with the background color.\nThen, column C1 of the output is populated: pixels from input column C1 are copied if they are not background; background pixels in output C1 *above* R_top_C1 are filled with V_top_C2.\nNext, column C2 of the output is populated: pixels from input column C2 are copied if they are not background; background pixels in output C2 *above* R_top_C2 are filled with V_top_C2, but *only if* a condition based on the content of column C1 at the same row is met (specifically, if the already computed output value at C1 is background, OR if the original input value at C1 was V_top_C1).\nAll other columns in the output remain background color.\n\"\"\"\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid, assumed to be the background.\n       More robustly checks if 0 is dominant even if not most frequent.\n    \"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default background if grid is empty\n\n    if grid.size > 0:\n        # Check if 0 is present and covers a large area (e.g., >50% or most frequent)\n        zero_count = counts.get(0, 0)\n        if counts:\n            most_frequent_color, most_frequent_count = counts.most_common(1)[0]\n            # Prioritize 0 if it's the most frequent or covers more than half the grid\n            if zero_count == most_frequent_count or zero_count > grid.size * 0.5:\n                 background_color = 0\n            else:\n                 background_color = most_frequent_color # Fallback to simple mode if 0 isn't dominant\n        else: # Grid has elements but Counter is empty? Should not happen with ndarray\n            background_color = 0\n\n    else: # Grid is empty\n        background_color = 0\n    return background_color\n\ndef find_target_columns(grid: np.ndarray, background_color: int) -> tuple[int | None, int | None]:\n    \"\"\"\n    Finds the indices of the rightmost (C1) and second rightmost (C2) columns\n    containing non-background pixels.\n    Returns (C1, C2). Returns None for an index if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    non_bg_cols = set()\n    if grid.size == 0:\n        return None, None\n    for c in range(cols):\n        # Check if any element in the column is not the background color\n        if np.any(grid[:, c] != background_color):\n            non_bg_cols.add(c)\n\n    # Sort the column indices that contain non-background colors\n    sorted_cols = sorted(list(non_bg_cols))\n\n    # C1 is the largest index (rightmost)\n    C1 = sorted_cols[-1] if sorted_cols else None\n    # C2 is the second largest index (second rightmost)\n    C2 = sorted_cols[-2] if len(sorted_cols) > 1 else None\n\n    return C1, C2\n\ndef find_topmost_non_background(grid: np.ndarray, col_idx: int | None, background_color: int) -> tuple[int | None, int | None]:\n    \"\"\"\n    Finds the row index (R_top) and value (V_top) of the topmost\n    non-background pixel in the specified column.\n    Returns (R_top, V_top). If column is empty, invalid, or None,\n    returns (None, None).\n    \"\"\"\n    height = grid.shape[0]\n    # Check if the column index is valid\n    if col_idx is None or col_idx < 0 or col_idx >= grid.shape[1]:\n        return None, None # Indicate no pixel found / invalid column\n\n    # Extract the column data\n    column_data = grid[:, col_idx]\n    # Find indices of non-background pixels\n    non_bg_indices = np.where(column_data != background_color)[0]\n\n    # If no non-background pixels found in the column\n    if non_bg_indices.size == 0:\n        return None, None # Indicate no pixel found\n\n    # The topmost non-background pixel is the first one found\n    R_top = non_bg_indices[0]\n    V_top = grid[R_top, col_idx]\n    return R_top, V_top\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the defined logic involving C1, C2,\n    and upward filling based on topmost pixels V_top_C1 and V_top_C2.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Handle empty input grid case\n    if input_np.size == 0:\n        return []\n        \n    height, width = input_np.shape\n\n    # Step 1: Determine the background color\n    bg = find_background_color(input_np)\n\n    # Step 2 & 3: Identify target columns C1 and C2\n    C1, C2 = find_target_columns(input_np, bg)\n\n    # Handle edge case: No non-background pixels found at all\n    if C1 is None:\n        # Return a grid filled with background color, or the original grid\n        # Returning original seems safer based on some ARC task behaviors\n        return input_grid\n\n    # Step 4: Find topmost non-background pixel in C1\n    R_top_C1, V_top_C1 = find_topmost_non_background(input_np, C1, bg)\n\n    # Step 5: Find topmost non-background pixel in C2\n    R_top_C2, V_top_C2 = find_topmost_non_background(input_np, C2, bg)\n    \n    # If V_top_C2 wasn't found (e.g., C2 is None or empty), default fill value for C1 gaps might be background\n    # The logic uses V_top_C2 for filling, so we need a defined value. Let's use bg if V_top_C2 is None.\n    fill_val_for_c1_gaps = V_top_C2 if V_top_C2 is not None else bg\n    # Similarly, for C2 gaps\n    fill_val_for_c2_gaps = V_top_C2 if V_top_C2 is not None else bg\n\n    # Step 6: Create the output grid initialized with the background color\n    output_np = np.full_like(input_np, bg)\n\n    # Step 7: Process output column C1\n    for r in range(height):\n        # Get the value from the input grid at this position\n        V_current_C1 = input_np[r, C1]\n        # If the input pixel is not background, copy it to the output\n        if V_current_C1 != bg:\n            output_np[r, C1] = V_current_C1\n        # If the input pixel IS background AND we are above the topmost pixel in C1\n        elif R_top_C1 is not None and r < R_top_C1:\n             # Fill this background cell with the topmost value from C2 (or bg if C2 had no top pixel)\n            output_np[r, C1] = fill_val_for_c1_gaps\n        # Otherwise (it's background at or below R_top_C1), leave it as background (already initialized)\n\n    # Step 8: Process output column C2 (only if C2 exists)\n    if C2 is not None:\n        for r in range(height):\n            # Get the value from the input grid at this position\n            V_current_C2 = input_np[r, C2]\n             # If the input pixel is not background, copy it to the output\n            if V_current_C2 != bg:\n                output_np[r, C2] = V_current_C2\n            # If the input pixel IS background AND we are above the topmost pixel in C2\n            elif R_top_C2 is not None and r < R_top_C2:\n                # Check the condition for upward fill in C2\n                # Condition: (output[r, C1] == bg) OR (input[r, C1] == V_top_C1)\n                condition_met = False\n                # Part 1: Check if the corresponding cell in the *output* C1 is background\n                if output_np[r, C1] == bg:\n                    condition_met = True\n                # Part 2: Check if the corresponding cell in the *input* C1 equals V_top_C1\n                # This check is only valid if V_top_C1 was actually found (R_top_C1 is not None)\n                elif R_top_C1 is not None and input_np[r, C1] == V_top_C1:\n                     condition_met = True\n\n                # If the condition is met, fill this background cell with V_top_C2 (or bg if C2 had no top pixel)\n                if condition_met:\n                    output_np[r, C2] = fill_val_for_c2_gaps\n            # Otherwise (it's background at or below R_top_C2, or condition not met), leave it as background\n\n    # Step 9: Convert the final NumPy array back to a list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27358,
    "candidates_token_count": 2724,
    "total_token_count": 30082,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.271655,
  "retries": 1
}