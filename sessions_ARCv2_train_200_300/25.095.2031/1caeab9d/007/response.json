{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport statistics\nimport math\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\n1. Identifies all contiguous rectangular blocks that are exactly 2 rows high \n   and composed of a single, identical non-zero digit (color).\n2. Determines the height (H) of the input grid.\n3. Applies one of two placement strategies based on H:\n    a. If H >= 10 (Adjacent Placement):\n        - Calculates the target top row: r_target = H // 2.\n        - Sorts the identified blocks by their original leftmost column index (c).\n        - Finds the minimum leftmost column index (c_min) among all blocks.\n        - Places the sorted blocks horizontally adjacent to each other in the \n          output grid, starting at row r_target and column c_min. The block \n          colors fill rows r_target and r_target + 1.\n    b. If H < 10 (Original Position Placement):\n        - Collects the original top row indices (r) of all identified blocks.\n        - Calculates the target top row: r_target = median_low of the sorted \n          list of these starting rows (using the lower median if the count is even).\n        - Places each identified block in the output grid at rows r_target \n          and r_target + 1, maintaining its original horizontal position \n          (original leftmost column c and original width w).\n4. Initializes the output grid with the same dimensions as the input, filled \n   with zeros (background). Cells covered by the placed blocks receive the \n   block's color.\n5. If no 2-row high blocks are found, returns the zero-filled output grid.\n\"\"\"\n\ndef find_blocks_height2(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous rectangular blocks of exactly height 2 with the same non-zero color.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        with keys: 'color', 'r' (top row), 'c' (left col), 'w' (width).\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    # Iterate rows up to H-2 (inclusive) to find blocks starting at row r and ending at r+1\n    for r in range(H - 1):\n        for c in range(W):\n            # Check for the start of a potential block:\n            # - Non-zero color in both rows (r, r+1) at column c\n            # - Same color in both cells\n            # - Neither cell has been visited yet (part of a previously found block)\n            if (grid[r, c] > 0 and \n                grid[r + 1, c] == grid[r, c] and \n                not visited[r, c] and \n                not visited[r + 1, c]):\n                \n                color = grid[r, c]\n                \n                # Found a potential top-left corner (r, c) of a block. Determine its width.\n                width = 0\n                # Scan columns to the right starting from c\n                for c_offset in range(W - c):\n                    current_c = c + c_offset\n                    # Check if the block continues horizontally in both rows r and r+1\n                    # with the same color and hasn't been visited\n                    if (current_c < W and # Boundary check\n                        grid[r, current_c] == color and not visited[r, current_c] and\n                        grid[r + 1, current_c] == color and not visited[r+1, current_c]):\n                        # Increment width and mark cells as visited\n                        width += 1\n                        visited[r, current_c] = True\n                        visited[r + 1, current_c] = True\n                    else:\n                        # Stop scanning horizontally if the block ends, changes color, hits visited cells, or goes out of bounds\n                        break \n\n                # If a valid block (width > 0) was found, add its properties to the list\n                if width > 0:\n                    blocks.append({\n                        'color': int(color), # Store as standard int\n                        'r': int(r),       # Store as standard int\n                        'c': int(c),       # Store as standard int\n                        'w': int(width)    # Store as standard int\n                        # Height is implicitly 2\n                    })\n            \n            # Mark cells as visited if they are non-zero and haven't been visited yet,\n            # even if they weren't the start of a detected block in this pass.\n            # This prevents single cells or parts of blocks from being re-evaluated incorrectly.\n            if grid[r, c] > 0 and not visited[r, c]:\n                visited[r, c] = True\n            if grid[r + 1, c] > 0 and not visited[r + 1, c]:\n                visited[r + 1, c] = True\n\n    # Ensure any non-zero cells in the last row (if grid height > 0) are marked visited\n    # if they weren't part of a block identified above.\n    if H > 0:\n       for c in range(W):\n            if grid[H-1, c] > 0 and not visited[H-1, c]:\n                visited[H-1, c] = True\n                \n    return blocks\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n\n    # Initialize output grid with the background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # Step 1: Identify all 2-row high blocks\n    blocks = find_blocks_height2(input_np)\n\n    # Step 2: Check if any blocks were found\n    if not blocks:\n        # If no blocks, return the empty (all zeros) output grid\n        return output_grid.tolist()\n\n    # Step 3 & 4: Check Grid Height and Apply Conditional Placement Logic\n    if H >= 10:\n        # --- Adjacent Placement Logic ---\n        \n        # Calculate the target top row\n        r_target = H // 2\n        \n        # Sort blocks by their original leftmost column index\n        blocks.sort(key=lambda b: b['c'])\n        \n        # Determine the starting column for the combined strip (minimum 'c' of sorted blocks)\n        c_start = blocks[0]['c'] \n        \n        # Place blocks adjacently\n        current_c = c_start\n        for block in blocks:\n            color = block['color']\n            w = block['w']\n            \n            # Define the horizontal slice for the current block in the output\n            # Ensure the slice does not exceed the grid width\n            col_end = min(current_c + w, W)\n            col_slice = slice(current_c, col_end)\n            \n            # Check if target rows are valid before writing\n            if r_target < H:\n                 output_grid[r_target, col_slice] = color\n            if r_target + 1 < H:\n                 output_grid[r_target + 1, col_slice] = color\n            \n            # Update the starting column for the next block\n            current_c += w # Assumes blocks fit horizontally based on examples\n\n    else: # H < 10\n        # --- Original Position Placement Logic ---\n        \n        # Collect the original top row indices ('r') of all identified blocks\n        start_rows = [b['r'] for b in blocks]\n        \n        # Calculate the target top row using median_low\n        # Handle single block case explicitly for median function\n        if len(start_rows) == 1:\n            r_target = start_rows[0]\n        elif len(start_rows) > 1:\n            sorted_start_rows = sorted(start_rows)\n            r_target = statistics.median_low(sorted_start_rows)\n        else: # Should not happen if blocks list is not empty, but handle defensively\n            r_target = 0 \n\n        # Place each block individually at its original column position in the target rows\n        for block in blocks:\n            color = block['color']\n            c = block['c']  # Original starting column\n            w = block['w']  # Original width\n            \n            # Define the column slice for the block's original horizontal position\n            # Ensure the slice does not exceed the grid width\n            col_end = min(c + w, W)\n            col_slice = slice(c, col_end)\n            \n            # Check if target rows are valid before writing\n            if r_target < H:\n                 output_grid[r_target, col_slice] = color\n            if r_target + 1 < H:\n                 output_grid[r_target + 1, col_slice] = color\n\n    # Step 5: Return Output\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13939,
    "candidates_token_count": 2804,
    "total_token_count": 16743,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.852452,
  "retries": 1
}