{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport statistics\nimport math\n\n\"\"\"\nTransforms an input grid based on the following rules:\n\n1. Identifies all contiguous rectangular blocks that are exactly 2 rows high \n   and composed of a single, identical non-zero digit (color).\n2. Determines the height (H) of the input grid.\n3. Applies one of two placement strategies based on H:\n    a. If H >= 10 (Adjacent Placement):\n        - Calculates the target top row: r_target = H // 2.\n        - Sorts the identified blocks by their original leftmost column index (c).\n        - Finds the minimum leftmost column index (c_min) among all blocks.\n        - Places the sorted blocks horizontally adjacent to each other in the \n          output grid, starting at row r_target and column c_min. The block \n          colors fill rows r_target and r_target + 1.\n    b. If H < 10 (Original Position Placement):\n        - Collects the original top row indices (r) of all identified blocks.\n        - Calculates the target top row: r_target = median_low of the sorted \n          list of these starting rows.\n        - Places each identified block in the output grid at rows r_target \n          and r_target + 1, maintaining its original horizontal position \n          (original leftmost column c and original width w).\n4. Initializes the output grid with the same dimensions as the input, filled \n   with zeros (background). Cells covered by the placed blocks receive the \n   block's color.\n5. If no 2-row high blocks are found, returns the zero-filled output grid.\n\"\"\"\n\ndef find_blocks_height2(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous rectangular blocks of exactly height 2 with the same non-zero color.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        with keys: 'color', 'r' (top row), 'c' (left col), 'w' (width).\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    # Iterate rows up to H-2 (inclusive) to find blocks starting at row r and ending at r+1\n    for r in range(H - 1):\n        for c in range(W):\n            # Check for the start of a potential block:\n            # - Non-zero color in both rows (r, r+1) at column c\n            # - Same color in both cells\n            # - Neither cell has been visited yet (part of a previously found block)\n            if (grid[r, c] > 0 and \n                grid[r + 1, c] == grid[r, c] and \n                not visited[r, c] and \n                not visited[r + 1, c]):\n                \n                color = grid[r, c]\n                \n                # Found a potential top-left corner (r, c) of a block. Determine its width.\n                width = 0\n                # Scan columns to the right starting from c\n                for c_offset in range(W - c):\n                    current_c = c + c_offset\n                    # Check if the block continues horizontally in both rows r and r+1\n                    # with the same color and hasn't been visited\n                    if (grid[r, current_c] == color and not visited[r, current_c] and\n                        grid[r + 1, current_c] == color and not visited[r+1, current_c]):\n                        # Increment width and mark cells as visited\n                        width += 1\n                        visited[r, current_c] = True\n                        visited[r + 1, current_c] = True\n                    else:\n                        # Stop scanning horizontally if the block ends, changes color, or hits visited cells\n                        break \n\n                # If a valid block (width > 0) was found, add its properties to the list\n                if width > 0:\n                    blocks.append({\n                        'color': int(color), # Store as standard int\n                        'r': int(r),       # Store as standard int\n                        'c': int(c),       # Store as standard int\n                        'w': int(width)    # Store as standard int\n                        # Height is implicitly 2\n                    })\n            \n            # Mark any remaining unvisited non-zero cells in these rows as visited\n            # This handles single non-zero cells or cells that are part of a block\n            # but weren't the top-left start identified above.\n            if grid[r, c] > 0 and not visited[r, c]:\n                visited[r, c] = True\n            if grid[r + 1, c] > 0 and not visited[r + 1, c]:\n                visited[r + 1, c] = True\n\n    # Check the last row for any unvisited non-zero cells\n    # (Only relevant if H is odd, ensures all cells considered visited if non-zero)\n    if H > 0:\n       for c in range(W):\n            if grid[H-1, c] > 0 and not visited[H-1, c]:\n                visited[H-1, c] = True\n\n    return blocks\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n\n    # Initialize output grid with the background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # --- Step 1: Identify all 2-row high blocks ---\n    blocks = find_blocks_height2(input_np)\n\n    # --- Step 2: Check if any blocks were found ---\n    if not blocks:\n        # If no blocks, return the empty (all zeros) output grid\n        return output_grid.tolist()\n\n    # --- Step 3 & 4: Check Grid Height and Apply Conditional Placement Logic ---\n    if H >= 10:\n        # --- Adjacent Placement Logic ---\n        \n        # Calculate the target top row\n        r_target = H // 2\n        \n        # Sort blocks by their original leftmost column index\n        blocks.sort(key=lambda b: b['c'])\n        \n        # Determine the starting column for the combined strip\n        c_start = blocks[0]['c'] \n        \n        # Place blocks adjacently\n        current_c = c_start\n        for block in blocks:\n            color = block['color']\n            w = block['w']\n            \n            # Define the horizontal slice for the current block in the output\n            # Ensure the slice does not exceed the grid width\n            col_end = min(current_c + w, W)\n            col_slice = slice(current_c, col_end)\n            \n            # Write the block's color to the output grid at target rows\n            output_grid[r_target, col_slice] = color\n            # Ensure r_target+1 is within bounds (should be if H >= 2)\n            if r_target + 1 < H:\n                 output_grid[r_target + 1, col_slice] = color\n            \n            # Update the starting column for the next block\n            current_c += w # Use actual width placed if col_end capped, but logic assumes fit\n\n    else: # H < 10\n        # --- Original Position Placement Logic ---\n        \n        # Collect the original top row indices ('r') of all identified blocks\n        start_rows = [b['r'] for b in blocks]\n        \n        # Calculate the target top row using median_low\n        # Ensure the list is sorted for median calculation; handle single block case\n        if len(start_rows) == 1:\n            r_target = start_rows[0]\n        else:\n            sorted_start_rows = sorted(start_rows)\n            r_target = statistics.median_low(sorted_start_rows)\n\n        # Place each block individually at its original column position in the target rows\n        for block in blocks:\n            color = block['color']\n            c = block['c']  # Original starting column\n            w = block['w']  # Original width\n            \n            # Define the column slice for the block's original horizontal position\n            # Ensure the slice does not exceed the grid width\n            col_end = min(c + w, W)\n            col_slice = slice(c, col_end)\n            \n            # Write the block's color to the output grid at target rows\n            output_grid[r_target, col_slice] = color\n            # Ensure r_target+1 is within bounds\n            if r_target + 1 < H:\n                 output_grid[r_target + 1, col_slice] = color\n\n    # --- Step 5: Return Output ---\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11739,
    "candidates_token_count": 2793,
    "total_token_count": 14532,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.553748,
  "retries": 1
}