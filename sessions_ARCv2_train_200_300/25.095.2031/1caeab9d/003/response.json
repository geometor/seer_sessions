{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport statistics\nimport math\n\n\"\"\"\nIdentifies contiguous rectangular blocks of height 2 with the same non-zero color in the input grid.\nDetermines a target top row (r_target) for placement in the output grid based on the input grid's height (H) and the median starting row of the identified blocks:\n- If H >= 10, r_target = floor(H / 2).\n- If H < 10, r_target = median_low of the starting rows of all blocks.\nRearranges the identified blocks into the output grid. Each block is placed in rows r_target and r_target + 1, maintaining its original horizontal column position (leftmost column index 'c' and width 'w').\nThe output grid has the same dimensions as the input grid, with all cells not covered by the placed blocks set to 0.\n\"\"\"\n\ndef find_blocks_height2(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous rectangular blocks of exactly height 2 with the same non-zero color.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        with keys: 'color', 'r' (top row), 'c' (left col), 'w' (width).\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    # Iterate rows up to H-2 (inclusive) to find blocks starting at row r and ending at r+1\n    for r in range(H - 1):\n        for c in range(W):\n            # Check for the start of a potential block:\n            # - Non-zero color\n            # - Not yet visited\n            # - Cell below has the same non-zero color\n            if grid[r, c] > 0 and not visited[r, c] and grid[r + 1, c] == grid[r, c] and not visited[r+1,c]:\n                color = grid[r, c]\n                \n                # Found a potential top-left corner (r, c) of a block. Determine its width.\n                width = 0\n                # Scan columns to the right starting from c\n                for c_offset in range(W - c):\n                    current_c = c + c_offset\n                    # Check if the block continues horizontally in both rows r and r+1\n                    if (grid[r, current_c] == color and not visited[r, current_c] and\n                        grid[r + 1, current_c] == color and not visited[r+1, current_c]):\n                        # Increment width and mark cells as visited\n                        width += 1\n                        visited[r, current_c] = True\n                        visited[r + 1, current_c] = True\n                    else:\n                        # Stop scanning horizontally if the block ends or changes color\n                        break \n\n                # If a valid block (width > 0) was found, add its properties to the list\n                if width > 0:\n                    blocks.append({\n                        'color': int(color), # Store as standard int\n                        'r': int(r),       # Store as standard int\n                        'c': int(c),       # Store as standard int\n                        'w': int(width)    # Store as standard int\n                        # Height is implicitly 2\n                    })\n            \n            # Important: Mark any unvisited non-zero cell as visited *after* checking for block start.\n            # This prevents single non-zero cells or parts of already found blocks from being reconsidered.\n            # It also handles cells that might be part of a block but weren't the top-left starting point\n            # found in this specific (r, c) iteration.\n            if grid[r, c] > 0 and not visited[r, c]:\n                visited[r, c] = True\n            if grid[r + 1, c] > 0 and not visited[r+1, c]: # Also mark the cell below if non-zero and unvisited\n                 visited[r+1, c] = True\n\n\n    return blocks\n\n\ndef determine_target_row(grid_height: int, block_start_rows: list[int]) -> int:\n    \"\"\"\n    Determines the target top row for placing blocks in the output grid.\n\n    Args:\n        grid_height: The height (H) of the input grid.\n        block_start_rows: A list of the starting row indices ('r') of all identified blocks.\n\n    Returns:\n        The calculated target top row index (r_target).\n    \"\"\"\n    if grid_height >= 10:\n        # For taller grids, target row is the middle row (floor division)\n        r_target = grid_height // 2\n    else:\n        # For shorter grids, target row is the median_low of the block start rows\n        # Ensure the list is sorted for median calculation\n        sorted_start_rows = sorted(block_start_rows)\n        r_target = statistics.median_low(sorted_start_rows)\n        \n    return r_target\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the specified rules.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n\n    # Initialize output grid with the background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # --- Step 1: Identify all 2-row high blocks ---\n    blocks = find_blocks_height2(input_np)\n\n    # If no blocks are found, return the empty (all zeros) output grid\n    if not blocks:\n        return output_grid.tolist()\n\n    # --- Step 2: Determine the target row for placement ---\n    # Collect the starting row ('r') of each identified block\n    start_rows = [b['r'] for b in blocks]\n    # Calculate the target top row based on grid height and median start row\n    r_target = determine_target_row(H, start_rows)\n    \n    # Ensure target rows are within grid bounds (should be, but good practice)\n    if r_target + 1 >= H: \n        # This case indicates an issue, maybe only 1 row grid or unexpected median.\n        # Handle appropriately, e.g., adjust or log error. For now, cap it.\n        print(f\"Warning: Target rows {r_target}, {r_target+1} may exceed grid height {H}. Adjusting.\")\n        # If r_target is the last row, we can only write to r_target.\n        # But the rule implies height 2, so this shouldn't happen with valid input/logic.\n        # Let's proceed assuming r_target and r_target+1 are valid.\n        pass # Or adjust r_target if needed, e.g. r_target = max(0, H-2) if len(blocks)>0\n\n    # --- Step 3: Place blocks individually in the output grid ---\n    # Iterate through the list of identified blocks (order doesn't matter for placement)\n    for block in blocks:\n        color = block['color']\n        c = block['c']  # Original starting column\n        w = block['w']  # Original width\n        \n        # Define the column slice for the block's original horizontal position\n        # Ensure the slice does not exceed the grid width\n        col_start = c\n        col_end = min(c + w, W) # Prevent writing past the grid width\n        col_slice = slice(col_start, col_end)\n        \n        # Copy the block's color into the output grid at the target rows (r_target, r_target+1)\n        # and its original columns (col_slice)\n        output_grid[r_target, col_slice] = color\n        # Check if r_target+1 is still within bounds before writing\n        if r_target + 1 < H:\n            output_grid[r_target + 1, col_slice] = color\n        # Else: block is height 2 but target is last row - only top half gets written if bounds strictly enforced.\n\n    # Convert the final numpy array back to a list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13557,
    "candidates_token_count": 2261,
    "total_token_count": 15818,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.904829,
  "retries": 1
}