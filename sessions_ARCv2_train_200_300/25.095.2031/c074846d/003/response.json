{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid based on the location of a '5' and an adjacent connected group of '2's.\n\n1. Finds the location of the number 5 (anchor).\n2. Finds any number 2 directly adjacent (horizontally or vertically) to the 5.\n3. If an adjacent 2 is found, performs a search (BFS) starting from that 2 to identify \n   the entire connected component (group) of 2s touching the initial adjacent 2.\n4. Changes all the 2s belonging to this identified group to 3s in the output grid.\n5. Determines the relative position of the group with respect to the 5 (Left, Right, Above, Below) \n   based on the position of the initial adjacent 2 found.\n6. Determines a projection direction orthogonal to the adjacency axis:\n    - Group Left of 5 -> Project Up\n    - Group Right of 5 -> Project Down\n    - Group Above 5 -> Project Right\n    - Group Below 5 -> Project Left\n7. Determines the starting point for the projection, which is always one cell away \n   from the 5 in the projection direction.\n8. Projects a line of 2s, starting from the calculated start point and moving in the\n   projection direction. The length of the projected line is equal to the number \n   of cells in the original group of 2s found in step 3. Projection stops if it hits\n   the grid boundary.\n\"\"\"\n\ndef find_value(grid: list[list[int]], value: int) -> tuple[int | None, int | None]:\n    \"\"\"Finds the first occurrence of a value in the grid.\"\"\"\n    num_rows = len(grid)\n    if num_rows == 0:\n        return None, None\n    num_cols = len(grid[0])\n    for r in range(num_rows):\n        for c in range(num_cols):\n            if grid[r][c] == value:\n                return r, c\n    return None, None\n\ndef find_first_adjacent_coord(grid: list[list[int]], r: int, c: int, target_value: int) -> tuple[int | None, int | None]:\n    \"\"\"Finds coordinates of the first adjacent cell with the target value.\"\"\"\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < num_rows and 0 <= nc < num_cols and grid[nr][nc] == target_value:\n            return nr, nc\n    return None, None\n\ndef find_connected_component(grid: list[list[int]], start_r: int, start_c: int, target_value: int) -> set[tuple[int, int]]:\n    \"\"\"Finds all connected cells with target_value using BFS starting from (start_r, start_c).\"\"\"\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    component = set()\n    queue = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n\n    while queue:\n        r, c = queue.popleft()\n        if grid[r][c] == target_value:\n            component.add((r, c))\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < num_rows and 0 <= nc < num_cols and \\\n                   grid[nr][nc] == target_value and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n    return component\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    num_rows = len(output_grid)\n    if num_rows == 0:\n        return output_grid\n    num_cols = len(output_grid[0])\n    if num_cols == 0:\n        return output_grid\n\n    # 1. Locate the anchor (5)\n    r5, c5 = find_value(input_grid, 5)\n    if r5 is None:\n        return output_grid # No anchor, no transformation\n\n    # 2. Find an initial adjacent target (2)\n    initial_r2, initial_c2 = find_first_adjacent_coord(input_grid, r5, c5, 2)\n\n    # 3. If no adjacent 2, return the grid unchanged\n    if initial_r2 is None:\n        return output_grid\n\n    # 4. Find the connected component of 2s starting from the initial one\n    target_group = find_connected_component(input_grid, initial_r2, initial_c2, 2)\n\n    # 5. If component is somehow empty (shouldn't happen if initial_r2 is found), return\n    if not target_group:\n        return output_grid\n\n    # 6. Change all 2s in the target group to 3s in the output grid\n    for r2, c2 in target_group:\n        output_grid[r2][c2] = 3\n\n    # 7. Determine relative position, projection direction, and start point\n    proj_dr, proj_dc = 0, 0\n    proj_start_r, proj_start_c = -1, -1\n    group_size = len(target_group)\n\n    # Determine relative position based on the first adjacent 2 found\n    if initial_r2 == r5: # Horizontal adjacency\n        if initial_c2 < c5: # Group is LEFT of 5\n            proj_dr, proj_dc = -1, 0 # Project UP\n            proj_start_r, proj_start_c = r5 - 1, c5\n        else: # Group is RIGHT of 5\n            proj_dr, proj_dc = 1, 0 # Project DOWN\n            proj_start_r, proj_start_c = r5 + 1, c5\n    elif initial_c2 == c5: # Vertical adjacency\n        if initial_r2 < r5: # Group is ABOVE 5\n            proj_dr, proj_dc = 0, 1 # Project RIGHT\n            proj_start_r, proj_start_c = r5, c5 + 1\n        else: # Group is BELOW 5\n            proj_dr, proj_dc = 0, -1 # Project LEFT\n            proj_start_r, proj_start_c = r5, c5 - 1\n\n    # 8. Execute projection\n    for i in range(group_size):\n        proj_r = proj_start_r + i * proj_dr\n        proj_c = proj_start_c + i * proj_dc\n\n        # Check boundaries before placing the 2\n        if 0 <= proj_r < num_rows and 0 <= proj_c < num_cols:\n             # Assume projection only onto 0s (consistent with examples)\n            if output_grid[proj_r][proj_c] == 0:\n                 output_grid[proj_r][proj_c] = 2\n            # If we need to stop projection if it hits non-zero:\n            # else:\n            #    break # Stop projection if the path is blocked by non-zero\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8078,
    "candidates_token_count": 4251,
    "total_token_count": 12329,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.261278,
  "retries": 1
}