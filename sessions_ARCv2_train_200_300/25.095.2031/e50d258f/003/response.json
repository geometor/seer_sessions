{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by:\n1. Identifying all distinct connected components of non-zero digits (1, 2, or 8), treating 0 as background.\n2. Calculating the bounding box, area, and cell count for each component.\n3. Filtering to find components that perfectly fill their bounding box (area equals cell count).\n4. Selecting the perfectly filled component with the minimum bounding box area.\n5. Extracting and returning the subgrid corresponding to the selected component's bounding box.\n\"\"\"\n\nfrom collections import deque\nimport sys # Used for float('inf') as initial minimum area\n\ndef _find_components(grid: list[list[int]]) -> list[list[tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of non-zero elements in the grid using BFS.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if cell is non-zero and not visited\n            if grid[r][c] != 0 and (r, c) not in visited:\n                current_component = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_component.append((curr_r, curr_c))\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds and if neighbor is non-zero and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                components.append(current_component) # Add the completed component\n\n    return components\n\ndef _get_bounding_box(component: list[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the minimal bounding box for a component.\n\n    Args:\n        component: A list of (row, col) tuples representing the component.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col). Returns (0, 0, -1, -1) for empty components.\n    \"\"\"\n    if not component:\n        return (0, 0, -1, -1) # Indicate empty or invalid\n\n    # Find min/max row and column from the component's cell coordinates\n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n\n    return min_r, min_c, max_r, max_c\n\ndef _calculate_bbox_area(bbox: tuple[int, int, int, int]) -> int:\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    if min_r > max_r or min_c > max_c: # Handle invalid/empty bbox\n        return 0\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height * width\n\ndef _extract_subgrid(grid: list[list[int]], bbox: tuple[int, int, int, int]) -> list[list[int]]:\n    \"\"\"\n    Extracts the subgrid defined by the bounding box.\n\n    Args:\n        grid: The input grid.\n        bbox: The bounding box tuple (min_row, min_col, max_row, max_col).\n\n    Returns:\n        The extracted subgrid as a list of lists.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    if min_r > max_r or min_c > max_c: # Handle invalid/empty bbox\n        return []\n        \n    subgrid = []\n    for r in range(min_r, max_r + 1):\n        # Extract the row slice corresponding to the bbox columns\n        subgrid.append(grid[r][min_c : max_c + 1])\n    return subgrid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to find and extract the smallest, \n    perfectly filled, non-zero component from the input grid.\n    \"\"\"\n    \n    # 1. Identify Non-Zero Components\n    components = _find_components(input_grid)\n    \n    min_area = sys.float_info.max # Initialize with positive infinity\n    best_bbox = None\n\n    # 2. Calculate Component Properties & 3. Find Perfectly Filled Components\n    for component in components:\n        if not component:\n            continue # Skip empty components if any occur\n\n        cell_count = len(component)\n        bbox = _get_bounding_box(component)\n        bbox_area = _calculate_bbox_area(bbox)\n\n        # Check if the component perfectly fills its bounding box\n        is_perfectly_filled = (bbox_area == cell_count)\n\n        # 4. Select Smallest Perfectly Filled Component\n        if is_perfectly_filled:\n            # If this component is smaller than the current best, update\n            if bbox_area < min_area:\n                min_area = bbox_area\n                best_bbox = bbox\n\n    # Handle case where no perfectly filled component is found\n    if best_bbox is None:\n        return [] \n\n    # 5. Extract Output using the bounding box of the selected component\n    output_grid = _extract_subgrid(input_grid, best_bbox)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10256,
    "candidates_token_count": 1874,
    "total_token_count": 12130,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.794344,
  "retries": 1
}