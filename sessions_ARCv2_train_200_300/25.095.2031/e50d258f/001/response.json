{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies all distinct connected components of non-zero digits (1, 2, or 8) in the input grid, treating 0 as a separator.\nFor each component, calculates its minimal bounding box.\nFinds the single component whose bounding box subgrid in the original input contains *only* non-zero digits (a \"solid\" bounding box).\nExtracts and returns the subgrid corresponding to this solid bounding box.\n\"\"\"\n\nfrom collections import deque\n\ndef _find_components(grid: list[list[int]]) -> list[list[tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of non-zero elements in the grid.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A list of components, where each component is a list of (row, col) tuples.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                # Start BFS to find a new component\n                current_component = []\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_component.append((curr_r, curr_c))\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds and if neighbor is non-zero and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                components.append(current_component)\n\n    return components\n\ndef _get_bounding_box(component: list[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the minimal bounding box for a component.\n\n    Args:\n        component: A list of (row, col) tuples representing the component.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    if not component:\n        return (0, 0, -1, -1) # Indicate empty or invalid\n\n    min_r = min(r for r, c in component)\n    min_c = min(c for r, c in component)\n    max_r = max(r for r, c in component)\n    max_c = max(c for r, c in component)\n\n    return min_r, min_c, max_r, max_c\n\ndef _is_solid(grid: list[list[int]], bbox: tuple[int, int, int, int]) -> bool:\n    \"\"\"\n    Checks if the subgrid defined by the bounding box contains only non-zero elements.\n\n    Args:\n        grid: The input grid.\n        bbox: The bounding box tuple (min_row, min_col, max_row, max_col).\n\n    Returns:\n        True if the bounding box area is solid (no zeros), False otherwise.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    if min_r > max_r or min_c > max_c: # Handle empty case if needed\n        return False\n\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            if grid[r][c] == 0:\n                return False\n    return True\n\ndef _extract_subgrid(grid: list[list[int]], bbox: tuple[int, int, int, int]) -> list[list[int]]:\n    \"\"\"\n    Extracts the subgrid defined by the bounding box.\n\n    Args:\n        grid: The input grid.\n        bbox: The bounding box tuple (min_row, min_col, max_row, max_col).\n\n    Returns:\n        The extracted subgrid as a list of lists.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    subgrid = []\n    for r in range(min_r, max_r + 1):\n        subgrid.append(grid[r][min_c : max_c + 1])\n    return subgrid\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by finding the solid non-zero component and extracting its bounding box.\n\n    Args:\n        input_grid: A 2D list of integers representing the input grid.\n\n    Returns:\n        A 2D list of integers representing the extracted solid subgrid.\n    \"\"\"\n    \n    # 1. Identify Non-Zero Components\n    components = _find_components(input_grid)\n    \n    solid_bbox = None\n\n    # Iterate through components to find the solid one\n    for component in components:\n        if not component:\n            continue\n            \n        # 2. Determine Bounding Boxes for each component\n        bbox = _get_bounding_box(component)\n        \n        # 3. Find Solid Bounding Box\n        if _is_solid(input_grid, bbox):\n            # 4. Select Target Component (assuming only one solid)\n            solid_bbox = bbox\n            break # Found the solid bounding box\n\n    if solid_bbox is None:\n        # Handle case where no solid bounding box is found, though examples suggest one always exists\n        return [] \n\n    # 5. Extract Output\n    output_grid = _extract_subgrid(input_grid, solid_bbox)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2001,
    "candidates_token_count": 2462,
    "total_token_count": 4463,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.288812,
  "retries": 1
}