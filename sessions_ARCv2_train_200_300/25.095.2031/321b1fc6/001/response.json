{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Identify connected components (objects) of non-zero cells using 8-way connectivity.\n2. Categorize objects into 'target_objects' (composed entirely of the digit 8) and 'pattern_objects' (composed of other non-zero digits).\n3. Sort both target_objects and pattern_objects based on their top-most, then left-most cell coordinate.\n4. If no pattern_objects exist, return an empty grid.\n5. Initialize an empty output grid (all zeros).\n6. Iterate through the sorted target_objects. For each target_object, select the next pattern_object from the sorted list, cycling through the patterns if necessary (using modulo arithmetic).\n7. Determine the top-left corner coordinate of the current target_object.\n8. Copy the selected pattern_object onto the output grid, aligning the pattern's top-left corner (relative to its own bounding box) with the target_object's top-left corner coordinate.\n9. The original pattern_objects are not copied to their original locations in the output.\n\"\"\"\n\ndef _find_objects(grid: np.ndarray) -> tuple[list[dict], list[dict]]:\n    \"\"\"\n    Finds and categorizes connected components in the grid.\n\n    Args:\n        grid: The input NumPy array.\n\n    Returns:\n        A tuple containing two lists: (pattern_objects, target_objects).\n        Each object is represented as a dictionary with keys:\n        'cells': list of (row, col, value) tuples\n        'top_left': (min_row, min_col) tuple\n        'is_target': boolean indicating if it's a target (all 8s) object\n    \"\"\"\n    # Define connectivity (8-way)\n    structure = np.array([[1, 1, 1],\n                          [1, 1, 1],\n                          [1, 1, 1]], dtype=bool)\n\n    # Label connected components of non-zero cells\n    labeled_grid, num_labels = label(grid > 0, structure=structure)\n    \n    # Find the locations (slices) of each labeled object\n    object_slices = find_objects(labeled_grid)\n\n    pattern_objects = []\n    target_objects = []\n\n    for i in range(num_labels):\n        label_id = i + 1\n        slices = object_slices[i]\n        \n        # Extract coordinates and values for the current object\n        coords = np.argwhere(labeled_grid[slices] == label_id)\n        min_row = slices[0].start\n        min_col = slices[1].start\n        \n        obj_cells = []\n        is_target_candidate = True\n        \n        for r_rel, c_rel in coords:\n            r_abs = min_row + r_rel\n            c_abs = min_col + c_rel\n            value = grid[r_abs, c_abs]\n            obj_cells.append((r_abs, c_abs, value))\n            if value != 8:\n                is_target_candidate = False\n        \n        # Determine actual top-left based on absolute coords\n        abs_rows = [r for r, c, v in obj_cells]\n        abs_cols = [c for r, c, v in obj_cells]\n        obj_min_row = min(abs_rows)\n        obj_min_col = min(abs_cols)\n        \n        obj_data = {\n            'cells': obj_cells,\n            'top_left': (obj_min_row, obj_min_col),\n            'is_target': is_target_candidate\n        }\n\n        if is_target_candidate:\n            target_objects.append(obj_data)\n        else:\n            # Check if it's actually a pattern (not just background 0 picked up somehow)\n             if any(v != 0 for r,c,v in obj_cells):\n                 pattern_objects.append(obj_data)\n\n\n    # Sort objects based on top-left corner (row, then column)\n    sort_key = lambda obj: obj['top_left']\n    pattern_objects.sort(key=sort_key)\n    target_objects.sort(key=sort_key)\n\n    return pattern_objects, target_objects\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n\n    # Initialize output grid with zeros\n    output_grid_np = np.zeros_like(grid_np)\n\n    # Find and categorize pattern and target objects\n    pattern_objects, target_objects = _find_objects(grid_np)\n\n    # If there are no patterns to use for replacement, return the empty grid\n    if not pattern_objects:\n        return output_grid_np.tolist()\n\n    num_patterns = len(pattern_objects)\n\n    # Iterate through the sorted target objects and replace them with patterns\n    for i, target_obj in enumerate(target_objects):\n        # Select the pattern object to use, cycling through the list\n        pattern_obj = pattern_objects[i % num_patterns]\n\n        target_top_left_row, target_top_left_col = target_obj['top_left']\n        pattern_origin_row, pattern_origin_col = pattern_obj['top_left']\n\n        # Place the selected pattern onto the output grid\n        for r_pat, c_pat, value in pattern_obj['cells']:\n            # Calculate relative position within the pattern object\n            rel_row = r_pat - pattern_origin_row\n            rel_col = c_pat - pattern_origin_col\n\n            # Calculate the destination position in the output grid\n            dest_row = target_top_left_row + rel_row\n            dest_col = target_top_left_col + rel_col\n\n            # Place the pattern cell value if within grid bounds\n            if 0 <= dest_row < rows and 0 <= dest_col < cols:\n                output_grid_np[dest_row, dest_col] = value\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2623,
    "candidates_token_count": 2263,
    "total_token_count": 4886,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.474795,
  "retries": 1
}