{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Define a target value (8).\n2. Identify connected components (objects) composed solely of the target value using 8-way connectivity. These are 'target_objects'.\n3. Independently, identify connected components composed of non-zero, non-target values using 8-way connectivity. These are 'pattern_objects'.\n4. Sort both target_objects and pattern_objects based on their top-most, then left-most cell coordinate.\n5. If no pattern_objects exist, return an empty grid (all zeros).\n6. Initialize an empty output grid (all zeros).\n7. Iterate through the sorted target_objects. For each target_object, select the next pattern_object from the sorted list, cycling through the patterns if necessary (using modulo arithmetic).\n8. Determine the top-left corner coordinate of the current target_object.\n9. Copy the selected pattern_object onto the output grid, aligning the pattern's top-left corner (relative to its own bounding box) with the target_object's top-left corner coordinate. The values copied are the original values from the pattern object.\n10. The original pattern_objects and target_objects are not directly copied to the output grid; only the transformed patterns are placed at target locations.\n\"\"\"\n\ndef _find_objects_by_mask(grid: np.ndarray, mask: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds connected components based on a provided mask and extracts object details.\n\n    Args:\n        grid: The original input NumPy array containing cell values.\n        mask: A boolean NumPy array of the same shape as grid, where True\n              indicates cells belonging to potential objects.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys:\n        'cells': list of (row, col, value) tuples from the original grid.\n        'top_left': (min_row, min_col) tuple, the top-left corner coordinate.\n    \"\"\"\n    # Define 8-way connectivity\n    structure = np.array([[1, 1, 1],\n                          [1, 1, 1],\n                          [1, 1, 1]], dtype=bool)\n\n    # Label connected components in the mask\n    labeled_mask, num_labels = label(mask, structure=structure)\n    \n    # Find the bounding box slices for each labeled object\n    object_slices = find_objects(labeled_mask)\n\n    objects = []\n\n    if object_slices is None: # Handle case with no objects found\n        return objects\n\n    for i in range(num_labels):\n        label_id = i + 1\n        slices = object_slices[i]\n        \n        # Extract coordinates within the bounding box that match the current label\n        local_coords = np.argwhere(labeled_mask[slices] == label_id)\n        \n        # Convert local coordinates to absolute grid coordinates\n        abs_coords = local_coords + np.array([slices[0].start, slices[1].start])\n\n        obj_cells = []\n        abs_rows = []\n        abs_cols = []\n\n        # Get original values and track absolute coordinates\n        for r_abs, c_abs in abs_coords:\n            value = grid[r_abs, c_abs]\n            obj_cells.append((r_abs, c_abs, value))\n            abs_rows.append(r_abs)\n            abs_cols.append(c_abs)\n\n        # If object has cells (it should, but check just in case)\n        if obj_cells:\n            # Determine the actual top-left corner based on absolute coordinates\n            obj_min_row = min(abs_rows)\n            obj_min_col = min(abs_cols)\n            \n            obj_data = {\n                'cells': obj_cells,\n                'top_left': (obj_min_row, obj_min_col),\n            }\n            objects.append(obj_data)\n\n    return objects\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    rows, cols = grid_np.shape\n    target_value = 8\n\n    # Initialize output grid with zeros\n    output_grid_np = np.zeros_like(grid_np)\n\n    # --- Step 1 & 2: Identify Target Objects ---\n    target_mask = (grid_np == target_value)\n    target_objects = _find_objects_by_mask(grid_np, target_mask)\n\n    # --- Step 3: Identify Pattern Objects ---\n    pattern_mask = (grid_np != 0) & (grid_np != target_value)\n    pattern_objects = _find_objects_by_mask(grid_np, pattern_mask)\n\n    # --- Step 5: Handle case with no patterns ---\n    if not pattern_objects:\n        return output_grid_np.tolist() # Return empty grid\n\n    # --- Step 4 & 7: Sort objects ---\n    sort_key = lambda obj: obj['top_left']\n    pattern_objects.sort(key=sort_key)\n    target_objects.sort(key=sort_key)\n\n    # --- Step 8, 9, 10: Perform Transformation ---\n    num_patterns = len(pattern_objects)\n\n    # Iterate through the sorted target objects\n    for i, target_obj in enumerate(target_objects):\n        # Select the pattern object to use, cycling through the list\n        pattern_obj = pattern_objects[i % num_patterns]\n\n        # Get top-left coordinates for placement calculation\n        target_top_left_row, target_top_left_col = target_obj['top_left']\n        pattern_origin_row, pattern_origin_col = pattern_obj['top_left']\n\n        # Place the selected pattern onto the output grid\n        for r_pat, c_pat, value in pattern_obj['cells']:\n            # Calculate relative position within the pattern object\n            rel_row = r_pat - pattern_origin_row\n            rel_col = c_pat - pattern_origin_col\n\n            # Calculate the destination position in the output grid\n            dest_row = target_top_left_row + rel_row\n            dest_col = target_top_left_col + rel_col\n\n            # Place the pattern cell value if within grid bounds\n            if 0 <= dest_row < rows and 0 <= dest_col < cols:\n                output_grid_np[dest_row, dest_col] = value\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8981,
    "candidates_token_count": 1954,
    "total_token_count": 10935,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.306878,
  "retries": 1
}