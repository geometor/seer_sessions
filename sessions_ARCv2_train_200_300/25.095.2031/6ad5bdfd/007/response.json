{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List\n\n\"\"\"\nTransforms an input grid of integers based on the properties of its first and last columns.\n\n1. Analyzes the input grid's first and last columns to determine the transformation type.\n2. If the first column consists of a single, non-zero value repeated for all rows, \n   apply the 'Left Shift Rule'.\n3. Else if the last column consists of a single, non-zero value repeated for all rows,\n   apply the 'Right Shift Rule'.\n4. Otherwise (neither condition is met), apply the 'Gravity Rule'.\n\nRule Descriptions:\n- Left Shift Rule (Row-wise): For each row, keep the first element fixed. Move all other \n  non-zero elements immediately to the right of the first element, preserving \n  their relative order. Fill the remaining positions in the row with zeros.\n- Right Shift Rule (Row-wise): For each row, keep the last element fixed. Move all other \n  non-zero elements immediately to the left of the last element, preserving \n  their relative order. Fill the remaining positions at the beginning of the \n  row with zeros.\n- Gravity Rule (Column-wise): For each column, move all non-zero elements downwards \n  to occupy the lowest possible rows within that column, preserving their relative \n  vertical order. Fill the positions above them in the column with zeros.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef _is_column_constant_non_zero(grid: List[List[int]], col_index: int) -> bool:\n    \"\"\"Checks if a specific column is constant and the constant value is non-zero.\"\"\"\n    # Handle empty grid list\n    if not grid: return False \n    num_rows = len(grid)\n    if num_rows == 0: return False\n    \n    # Check if grid has rows with elements (assume rectangular based on ARC)\n    if not grid[0]: return False \n             \n    num_cols = len(grid[0])\n    # Handle negative index like -1 for last column\n    if col_index < 0:\n        col_index = num_cols + col_index \n        \n    # Check if column index is valid\n    if not (0 <= col_index < num_cols): return False \n\n    # Check if all rows have sufficient length and are rectangular\n    if not all(len(row) == num_cols for row in grid):\n         # Grid is not rectangular, cannot reliably check column constancy\n         return False \n\n    # Get the value from the first row for comparison\n    first_val = grid[0][col_index]\n    # The constant value must be non-zero\n    if first_val == 0: return False \n\n    # Check consistency across all other rows\n    for i in range(1, num_rows):\n        if grid[i][col_index] != first_val:\n            return False # Value is not constant\n\n    # If all checks pass, the column is constant and non-zero\n    return True\n\ndef _apply_left_shift(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Left Shift Rule (Type 1) to each row.\"\"\"\n    output_grid = []\n    # Process each row independently\n    for input_row in grid:\n        # Handle potentially empty rows within the grid if necessary\n        if not input_row:\n            output_grid.append([])\n            continue\n        \n        original_length = len(input_row)\n        # a. Store the first element (fixed element).\n        first_element = input_row[0]\n        \n        # b. Create a list of all non-zero elements from the second position onwards.\n        non_zeros_after_first = [\n            element for element in input_row[1:] if element != 0\n        ]\n        \n        # c. Construct the output row starting with the fixed element.\n        new_row = [first_element]\n        \n        # d. Append the list of non-zero elements.\n        new_row.extend(non_zeros_after_first)\n        \n        # e. Append zeros until the length matches the original input row length.\n        padding_zeros_count = original_length - len(new_row)\n        new_row.extend([0] * padding_zeros_count)\n        \n        # f. Add the transformed row to the output grid.\n        output_grid.append(new_row)\n    return output_grid\n\ndef _apply_right_shift(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Right Shift Rule (Type 3) to each row.\"\"\"\n    output_grid = []\n    # Process each row independently\n    for input_row in grid:\n        # Handle potentially empty rows\n        if not input_row:\n            output_grid.append([])\n            continue\n\n        original_length = len(input_row)\n        if original_length == 0:\n             output_grid.append([])\n             continue\n             \n        # a. Store the last element (fixed element).\n        last_element = input_row[-1]\n        \n        # b. Create a list of all non-zero elements before the last element.\n        non_zeros_before_last = [\n            element for element in input_row[:-1] if element != 0\n        ]\n        \n        # c. Calculate the number of zeros needed for padding at the beginning.\n        num_non_zeros = len(non_zeros_before_last)\n        # -1 accounts for the fixed last element\n        padding_zeros_count = original_length - 1 - num_non_zeros \n        \n        # d. Construct the output row starting with padding zeros.\n        new_row = [0] * padding_zeros_count\n        \n        # e. Append the list of non-zero elements.\n        new_row.extend(non_zeros_before_last)\n        \n        # f. Append the fixed (last) element.\n        new_row.append(last_element)\n        \n        # g. Add the transformed row to the output grid.\n        output_grid.append(new_row)\n    return output_grid\n\ndef _apply_gravity(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Gravity Rule (Type 2) using NumPy for column manipulation.\"\"\"\n    # Handle empty grid case\n    if not grid or not grid[0]:\n        return [] \n\n    try:\n        # Convert to NumPy array for easier column slicing\n        input_np = np.array(grid, dtype=int)\n    except ValueError:\n         # Handle non-rectangular grids - this rule expects rectangular structure\n         # Raising an error might be appropriate, or returning the input unchanged.\n         # Based on ARC task format, assume rectangularity or raise error.\n         raise ValueError(\"Input grid must be rectangular for Gravity rule.\")\n\n    num_rows, num_cols = input_np.shape\n    # a. Create an output grid initialized with zeros.\n    output_np = np.zeros_like(input_np) \n\n    # b. Process each column.\n    for j in range(num_cols):\n        # c. Extract non-zero elements from the current input column.\n        column_data = input_np[:, j]\n        non_zeros = column_data[column_data != 0]\n        \n        # d. Determine the number of non-zero elements.\n        num_non_zeros = len(non_zeros)\n        \n        # e. Place non-zeros at the bottom of the corresponding output column.\n        if num_non_zeros > 0:\n            start_row_index = num_rows - num_non_zeros\n            output_np[start_row_index:, j] = non_zeros\n            \n    # Convert back to list of lists for the standard ARC format\n    return output_np.tolist()\n\n# --- Main Transform Function ---\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the appropriate transformation rule (Left Shift, Right Shift, or Gravity)\n    to the input grid based on the properties of its first and last columns.\n    \"\"\"\n    \n    # Handle edge case of completely empty input list\n    if not input_grid:\n        return []\n        \n    # 1. Analyze Input Grid: Check first and last columns for constancy and non-zero value\n    is_first_col_const_nz = _is_column_constant_non_zero(input_grid, 0)\n    is_last_col_const_nz = _is_column_constant_non_zero(input_grid, -1)\n    \n    # 2. Select Transformation Rule & 3. Execute Selected Rule\n    if is_first_col_const_nz:\n        # Apply Left Shift Rule (Type 1)\n        # This rule applies if the first column is constant and non-zero.\n        output_grid = _apply_left_shift(input_grid)\n    elif is_last_col_const_nz:\n        # Apply Right Shift Rule (Type 3)\n        # This rule applies if the first column condition is false, \n        # AND the last column is constant and non-zero.\n        output_grid = _apply_right_shift(input_grid)\n    else:\n        # Apply Gravity Rule (Type 2)\n        # This is the default rule if neither the first nor the last column \n        # meets the specific conditions for Type 1 or Type 3 rules.\n        output_grid = _apply_gravity(input_grid)\n        \n    # 4. Return Output Grid\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12524,
    "candidates_token_count": 2409,
    "total_token_count": 14933,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.748932,
  "retries": 1
}