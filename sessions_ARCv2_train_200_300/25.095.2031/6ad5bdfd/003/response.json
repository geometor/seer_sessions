{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List\n\n\"\"\"\nTransforms an input grid of integers based on the properties of its first and last columns.\n\n1. Analyzes the input grid's first and last columns.\n2. If the first column consists of a single, non-zero value repeated for all rows, \n   apply the 'Left Shift Rule'.\n3. Else if the last column consists of a single, non-zero value repeated for all rows,\n   apply the 'Right Shift Rule'.\n4. Otherwise (neither condition is met), apply the 'Gravity Rule'.\n\nRule Descriptions:\n- Left Shift Rule: For each row, keep the first element fixed. Move all other \n  non-zero elements immediately to the right of the first element, preserving \n  their relative order. Fill the remaining positions in the row with zeros.\n- Right Shift Rule: For each row, keep the last element fixed. Move all other \n  non-zero elements immediately to the left of the last element, preserving \n  their relative order. Fill the remaining positions at the beginning of the \n  row with zeros.\n- Gravity Rule: For each column, move all non-zero elements downwards to occupy \n  the lowest possible rows within that column, preserving their relative vertical order. \n  Fill the positions above them in the column with zeros.\n\"\"\"\n\ndef _is_column_constant_non_zero(grid: List[List[int]], col_index: int) -> bool:\n    \"\"\"Checks if a specific column is constant and the constant value is non-zero.\"\"\"\n    if not grid or not grid[0]: # Handle empty grid\n        return False\n    num_rows = len(grid)\n    if num_rows == 0:\n        return False\n        \n    # Adjust col_index for negative indexing (like -1 for last column)\n    num_cols = len(grid[0])\n    if col_index < 0:\n        col_index = num_cols + col_index\n        \n    if not (0 <= col_index < num_cols): # Invalid column index\n        return False\n\n    first_val = grid[0][col_index]\n    if first_val == 0:\n        return False # Constant value must be non-zero\n\n    for i in range(1, num_rows):\n        if len(grid[i]) <= col_index or grid[i][col_index] != first_val:\n            return False # Not constant or row is too short\n\n    return True\n\ndef _apply_left_shift(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Left Shift Rule.\"\"\"\n    output_grid = []\n    for input_row in grid:\n        if not input_row:\n            output_grid.append([])\n            continue\n        \n        original_length = len(input_row)\n        first_element = input_row[0]\n        \n        # Collect non-zero elements from the rest of the row\n        non_zeros_after_first = [\n            element for element in input_row[1:] if element != 0\n        ]\n        \n        # Construct the new row\n        new_row = [first_element]\n        new_row.extend(non_zeros_after_first)\n        \n        # Pad with zeros\n        padding_zeros_count = original_length - len(new_row)\n        new_row.extend([0] * padding_zeros_count)\n        \n        output_grid.append(new_row)\n    return output_grid\n\ndef _apply_right_shift(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Right Shift Rule.\"\"\"\n    output_grid = []\n    for input_row in grid:\n        if not input_row:\n            output_grid.append([])\n            continue\n\n        original_length = len(input_row)\n        if original_length == 0:\n             output_grid.append([])\n             continue\n             \n        last_element = input_row[-1]\n        \n        # Collect non-zero elements before the last element\n        non_zeros_before_last = [\n            element for element in input_row[:-1] if element != 0\n        ]\n        \n        # Calculate padding\n        num_non_zeros = len(non_zeros_before_last)\n        padding_zeros_count = original_length - 1 - num_non_zeros\n        \n        # Construct the new row\n        new_row = [0] * padding_zeros_count\n        new_row.extend(non_zeros_before_last)\n        new_row.append(last_element)\n        \n        output_grid.append(new_row)\n    return output_grid\n\ndef _apply_gravity(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the Gravity Rule using NumPy for easier column manipulation.\"\"\"\n    if not grid or not grid[0]:\n        return [] # Handle empty grid case\n\n    input_np = np.array(grid, dtype=int)\n    num_rows, num_cols = input_np.shape\n    output_np = np.zeros_like(input_np) # Initialize output with zeros\n\n    # Process each column\n    for j in range(num_cols):\n        # Extract non-zero elements from the current column\n        column_data = input_np[:, j]\n        non_zeros = column_data[column_data != 0]\n        \n        # Place non-zeros at the bottom of the output column\n        num_non_zeros = len(non_zeros)\n        if num_non_zeros > 0:\n            output_np[num_rows - num_non_zeros:, j] = non_zeros\n            \n    # Convert back to list of lists for the final output format\n    return output_np.tolist()\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on analyzing its first and last columns.\n    Selects and applies one of three rules: Left Shift, Right Shift, or Gravity.\n    \"\"\"\n    \n    # Handle edge case of completely empty input\n    if not input_grid:\n        return []\n        \n    # --- Condition Check ---\n    is_first_col_const_nz = _is_column_constant_non_zero(input_grid, 0)\n    is_last_col_const_nz = _is_column_constant_non_zero(input_grid, -1)\n    \n    # --- Rule Selection and Execution ---\n    if is_first_col_const_nz:\n        # Apply Left Shift Rule (Type 1)\n        output_grid = _apply_left_shift(input_grid)\n    elif is_last_col_const_nz:\n        # Apply Right Shift Rule (Type 3)\n        output_grid = _apply_right_shift(input_grid)\n    else:\n        # Apply Gravity Rule (Type 2)\n        output_grid = _apply_gravity(input_grid)\n        \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8928,
    "candidates_token_count": 2261,
    "total_token_count": 11189,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.304978,
  "retries": 1
}