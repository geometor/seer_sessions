{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms an input grid of digits based on the presence and location of '8's and '2's.\n\nThe rules are applied hierarchically:\n\n1.  If the digit '8' is present:\n    a.  Find the maximum column index (C_max8) where an '8' appears.\n    b.  Calculate the target column (C_target = C_max8 + 2).\n    c.  Find the minimum row index (R_first_any8) containing any '8'.\n    d.  Find the minimum row index (R_first_max8) containing an '8' specifically in column C_max8.\n    e.  If R_first_any8 equals R_first_max8:\n        i.  If the digit '2' is also present:\n            - Find the maximum row index (R_last2) containing a '2'.\n            - Change only the cell at (R_last2, C_target) to '5'.\n        ii. If the digit '2' is NOT present:\n            - Set the starting row R_start = 1.\n            - Change all cells in column C_target from row R_start downwards to '5'.\n    f.  If R_first_any8 is NOT equal to R_first_max8:\n        i.  Set the starting row R_start = R_first_max8 - 1 (clamped at 0).\n        ii. Change all cells in column C_target from row R_start downwards to '5'.\n2.  If the digit '8' is NOT present, but the digit '2' is present:\n    a.  Find the maximum row index (R_last2) where a '2' appears.\n    b.  Find the column index (C_last2) of the first '2' found in row R_last2.\n    c.  Calculate the target column (C_target = C_last2 + 2).\n    d.  Change only the cell at (R_last2, C_target) to '5'.\n3.  If neither '8' nor '2' is present, the grid remains unchanged.\n\nBoundary checks are performed to ensure modifications only happen within the grid dimensions.\n\"\"\"\n\n\ndef _find_digit_locations(grid: list[list[int]], digit: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all (row, col) coordinates of a given digit in the grid.\"\"\"\n    locations = []\n    for r, row in enumerate(grid):\n        for c, cell_value in enumerate(row):\n            if cell_value == digit:\n                locations.append((r, c))\n    return locations\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Handle empty or invalid input\n    if not input_grid or not input_grid[0]:\n        return copy.deepcopy(input_grid) # Return copy or empty list? Returning copy.\n\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0])\n    \n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find locations of '8' and '2'\n    locations_8 = _find_digit_locations(input_grid, 8)\n    locations_2 = _find_digit_locations(input_grid, 2)\n    has_8 = bool(locations_8)\n    has_2 = bool(locations_2)\n\n    # Rule 1: '8' is present\n    if has_8:\n        # Calculate C_max8: maximum column index of any '8'\n        C_max8 = -1\n        for r, c in locations_8:\n            if c > C_max8:\n                C_max8 = c\n        \n        # Calculate C_target from '8'\n        C_target = C_max8 + 2\n\n        # Check if C_target is within grid bounds\n        if C_target < num_cols:\n            # Calculate R_first_any8: minimum row index of any '8'\n            R_first_any8 = num_rows # Initialize higher than possible index\n            for r, c in locations_8:\n                if r < R_first_any8:\n                    R_first_any8 = r\n            \n            # Calculate R_first_max8: minimum row index of '8' in column C_max8\n            R_first_max8 = num_rows # Initialize higher than possible index\n            for r, c in locations_8:\n                if c == C_max8 and r < R_first_max8:\n                    R_first_max8 = r\n\n            # Rule 1.e: R_first_any8 == R_first_max8\n            if R_first_any8 == R_first_max8:\n                # Rule 1.e.i: '2' is also present\n                if has_2:\n                    # Find R_last2: maximum row index of any '2'\n                    R_last2 = -1\n                    for r, c in locations_2:\n                        if r > R_last2:\n                            R_last2 = r\n                    # Modify the single cell at (R_last2, C_target) if R_last2 is valid\n                    if R_last2 != -1 and 0 <= R_last2 < num_rows:\n                         output_grid[R_last2][C_target] = 5\n                # Rule 1.e.ii: '2' is NOT present\n                else:\n                    R_start = 1 # Start modifying from row 1\n                    # Modify column C_target from R_start downwards\n                    for r in range(R_start, num_rows):\n                        output_grid[r][C_target] = 5\n            # Rule 1.f: R_first_any8 != R_first_max8\n            else:\n                # Ensure R_first_max8 is valid before calculating R_start\n                if R_first_max8 < num_rows: \n                   R_start = max(0, R_first_max8 - 1) # Start modifying from R_first_max8 - 1 (clamped at 0)\n                   # Modify column C_target from R_start downwards\n                   for r in range(R_start, num_rows):\n                       output_grid[r][C_target] = 5\n\n    # Rule 2: '8' is NOT present, but '2' IS present\n    elif has_2:\n        # Find R_last2: maximum row index of any '2'\n        R_last2 = -1\n        for r, c in locations_2:\n            if r > R_last2:\n                R_last2 = r\n        \n        # Find C_last2: column index of the first '2' in row R_last2 \n        C_last2 = -1\n        if R_last2 != -1:\n            for r, c in locations_2:\n                if r == R_last2:\n                    C_last2 = c\n                    break # Take the first one found in that row\n        \n        # Proceed if both R_last2 and C_last2 were found\n        if R_last2 != -1 and C_last2 != -1:\n            # Calculate C_target from '2'\n            C_target = C_last2 + 2\n            \n            # Modify the single cell if C_target is within bounds\n            if 0 <= R_last2 < num_rows and 0 <= C_target < num_cols:\n                output_grid[R_last2][C_target] = 5\n\n    # Rule 3: Neither '8' nor '2' is present - No changes needed, output_grid is already a copy\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10865,
    "candidates_token_count": 2390,
    "total_token_count": 13255,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.704501,
  "retries": 1
}