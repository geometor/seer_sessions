{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms an input grid of digits based on the presence and location of '8's and '2's.\n\nThe rules are applied hierarchically:\n\n1.  Initialize the output grid as an identical copy of the input grid.\n2.  Scan the input grid to find all locations of the digit '8' and the digit '2'. Determine if '8' (`has_8`) and '2' (`has_2`) are present.\n3.  If `has_8` is true:\n    a.  Find the maximum column index (`C_max8`) where an '8' appears.\n    b.  Find the minimum row index (`R_first_any8`) containing any '8'.\n    c.  Find the minimum row index (`R_first_max8`) containing an '8' specifically in column `C_max8`.\n    d.  If `R_first_any8` is equal to `R_first_max8`:\n        i.  If `has_2` is also true:\n            1. Find the maximum row index (`R_last2`) containing a '2'.\n            2. Find the column index (`C_last2`) of the first '2' encountered (minimum column index) in row `R_last2`.\n            3. Calculate the target column `C_target = C_last2 + 2`.\n            4. If the cell `(R_last2, C_target)` is within the grid boundaries, change its value to '5' in the output grid.\n        ii. If `has_2` is false:\n            1. Calculate the target column `C_target = C_max8 + 2`.\n            2. Set the starting row index `R_start = 1`.\n            3. Iterate through rows `R` from `R_start` to the last row index. If the cell `(R, C_target)` is within grid boundaries, change its value to '5' in the output grid.\n    e.  If `R_first_any8` is NOT equal to `R_first_max8`:\n        i.  Calculate the target column `C_target = C_max8 + 2`.\n        ii. Calculate the starting row index `R_start = max(0, R_first_max8 - 1)`.\n        iii. Iterate through rows `R` from `R_start` to the last row index. If the cell `(R, C_target)` is within grid boundaries, change its value to '5' in the output grid.\n4.  If `has_8` is false, but `has_2` is true:\n    a.  Find the maximum row index (`R_last2`) containing a '2'.\n    b.  Find the column index (`C_last2`) of the first '2' encountered (minimum column index) in row `R_last2`.\n    c.  Calculate the target column `C_target = C_last2 + 2`.\n    d.  If the cell `(R_last2, C_target)` is within the grid boundaries, change its value to '5' in the output grid.\n5.  If neither '8' nor '2' is present: The output grid remains unchanged.\n6.  Return the final output grid.\n\"\"\"\n\ndef _find_digit_locations(grid: list[list[int]], digit: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all (row, col) coordinates of a given digit in the grid.\"\"\"\n    locations = []\n    for r, row in enumerate(grid):\n        for c, cell_value in enumerate(row):\n            if cell_value == digit:\n                locations.append((r, c))\n    return locations\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Handle empty or invalid input\n    if not input_grid or not input_grid[0]:\n        return copy.deepcopy(input_grid) # Return copy of empty/invalid input\n\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0])\n    \n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find locations of '8' and '2'\n    locations_8 = _find_digit_locations(input_grid, 8)\n    locations_2 = _find_digit_locations(input_grid, 2)\n    has_8 = bool(locations_8)\n    has_2 = bool(locations_2)\n\n    # Rule 1: '8' is present\n    if has_8:\n        # Calculate C_max8: maximum column index of any '8'\n        C_max8 = -1\n        for r, c in locations_8:\n            if c > C_max8:\n                C_max8 = c\n        \n        # Calculate R_first_any8: minimum row index of any '8'\n        R_first_any8 = num_rows # Initialize higher than possible index\n        for r, c in locations_8:\n            if r < R_first_any8:\n                R_first_any8 = r\n        \n        # Calculate R_first_max8: minimum row index of '8' in column C_max8\n        R_first_max8 = num_rows # Initialize higher than possible index\n        for r, c in locations_8:\n            if c == C_max8 and r < R_first_max8:\n                R_first_max8 = r\n        \n        # Check if C_max8 and R_first_max8 were actually found (should be true if has_8)\n        if C_max8 == -1 or R_first_max8 == num_rows:\n            # This case should ideally not happen if has_8 is true, but handle defensively\n            return output_grid\n\n        # Rule 1.d: R_first_any8 == R_first_max8\n        if R_first_any8 == R_first_max8:\n            # Rule 1.d.i: '2' is also present\n            if has_2:\n                # Find R_last2: maximum row index of any '2'\n                R_last2 = -1\n                for r, c in locations_2:\n                    if r > R_last2:\n                        R_last2 = r\n                \n                # Find C_last2: minimum column index of '2' in row R_last2\n                C_last2 = num_cols # Initialize higher than possible index\n                found_c_last2 = False\n                if R_last2 != -1:\n                    for r, c in locations_2:\n                        if r == R_last2 and c < C_last2:\n                            C_last2 = c\n                            found_c_last2 = True\n                \n                # If R_last2 and C_last2 are valid\n                if R_last2 != -1 and found_c_last2:\n                    # Calculate C_target based on '2'\n                    C_target = C_last2 + 2\n                    # Modify the single cell if C_target is within bounds\n                    if 0 <= R_last2 < num_rows and 0 <= C_target < num_cols:\n                        output_grid[R_last2][C_target] = 5\n            # Rule 1.d.ii: '2' is NOT present\n            else:\n                # Calculate C_target based on '8'\n                C_target = C_max8 + 2\n                # Check if C_target is within grid bounds\n                if C_target < num_cols:\n                    # Set start row\n                    R_start = 1 \n                    # Modify column C_target from R_start downwards\n                    for r in range(R_start, num_rows):\n                         # Check row bounds just in case, though range handles upper bound\n                         if 0 <= r < num_rows: # Ensure row is valid\n                            output_grid[r][C_target] = 5\n\n        # Rule 1.e: R_first_any8 != R_first_max8\n        else:\n            # Calculate C_target based on '8'\n            C_target = C_max8 + 2\n            # Check if C_target is within grid bounds\n            if C_target < num_cols:\n                # Calculate start row\n                R_start = max(0, R_first_max8 - 1) \n                # Modify column C_target from R_start downwards\n                for r in range(R_start, num_rows):\n                    # Check row bounds just in case\n                    if 0 <= r < num_rows: # Ensure row is valid\n                        output_grid[r][C_target] = 5\n\n    # Rule 4: '8' is NOT present, but '2' IS present\n    elif has_2:\n        # Find R_last2: maximum row index of any '2'\n        R_last2 = -1\n        for r, c in locations_2:\n            if r > R_last2:\n                R_last2 = r\n        \n        # Find C_last2: minimum column index of '2' in row R_last2 \n        C_last2 = num_cols # Initialize higher than possible index\n        found_c_last2 = False\n        if R_last2 != -1:\n            for r, c in locations_2:\n                if r == R_last2 and c < C_last2:\n                    C_last2 = c\n                    found_c_last2 = True\n        \n        # Proceed if both R_last2 and C_last2 were found\n        if R_last2 != -1 and found_c_last2:\n            # Calculate C_target from '2'\n            C_target = C_last2 + 2\n            \n            # Modify the single cell if C_target is within bounds\n            if 0 <= R_last2 < num_rows and 0 <= C_target < num_cols:\n                output_grid[R_last2][C_target] = 5\n\n    # Rule 5: Neither '8' nor '2' is present - No changes needed\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14724,
    "candidates_token_count": 2920,
    "total_token_count": 17644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.491973,
  "retries": 1
}