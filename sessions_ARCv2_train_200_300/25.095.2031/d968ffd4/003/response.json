{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport math\nfrom copy import deepcopy\n\n\"\"\"\nTransforms a 2D grid by performing the following steps:\n\n1.  **Identify Grid Components:**\n    *   Determines the background color (most frequent integer).\n    *   Locates exactly two distinct, connected non-background objects, identifying their colors and coordinates.\n\n2.  **Determine Object Relationship:**\n    *   Calculates the bounding box for each object.\n    *   Determines if the objects are separated horizontally or vertically.\n    *   Orders the objects as object1 (left/top) and object2 (right/bottom).\n\n3.  **Define Transformation Zones:**\n    *   Calculates the 'Gap Range' (rows/columns strictly between the objects).\n    *   Calculates the 'Overlap Range' (rows/columns where the objects overlap along the non-separation axis).\n    *   Calculates the 'Fill Extent' along the non-separation axis, which is the Overlap Range expanded by one cell outwards (clamped to grid boundaries).\n\n4.  **Calculate Midpoint:** Determines the midpoint boundary within the Gap Range to divide the fill area between the two object colors.\n\n5.  **Apply Transformation:**\n    *   Creates a copy of the input grid.\n    *   Iterates through the cells defined by the intersection of the Gap Range (on the separation axis) and the Fill Extent (on the non-separation axis).\n    *   If a cell in this area contains the background color in the original input grid, it's filled in the output grid with the color of the closer object based on the midpoint boundary.\n\n6.  **Return Result:** Returns the modified grid. Original objects and background cells outside the defined fill area remain unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_background(grid: list[list[int]]) -> int:\n    \"\"\"Finds the most frequent color in the grid, assuming it's the background.\"\"\"\n    counts = collections.Counter()\n    if not grid or not grid[0]:\n        return -1 # Indicate error or empty grid\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            counts[grid[r][c]] += 1\n    if not counts:\n        return -1 # Should not happen if grid is not empty, but safer\n    # Return the most common element\n    return counts.most_common(1)[0][0]\n\ndef find_objects(grid: list[list[int]], background_color: int) -> list[tuple[int, set[tuple[int, int]]]]:\n    \"\"\"Finds connected regions of non-background colors using BFS.\"\"\"\n    if not grid or not grid[0]:\n        return []\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            # Check if cell is part of the grid, not background, and not visited\n            if grid[r][c] != background_color and (r, c) not in visited:\n                obj_color = grid[r][c]\n                obj_coords = set()\n                queue = collections.deque([(r, c)])\n                visited.add((r, c))\n                \n                # Perform BFS to find all connected cells of the same color\n                while queue:\n                    row, col = queue.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and \\\n                           grid[nr][nc] == obj_color:\n                            visited.add((nr, nc))\n                            queue.append((nr, nc))\n                            \n                # Store the found object (color and coordinates)\n                if obj_coords:\n                    objects.append((obj_color, obj_coords))\n                    \n    return objects\n\ndef get_bounding_box(coordinates: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_row, max_row, min_col, max_col) for a set of coordinates.\"\"\"\n    if not coordinates:\n        return (-1, -1, -1, -1) # Return invalid box if no coordinates\n    min_r = min(r for r, c in coordinates)\n    max_r = max(r for r, c in coordinates)\n    min_c = min(c for r, c in coordinates)\n    max_c = max(c for r, c in coordinates)\n    return min_r, max_r, min_c, max_c\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation rule to the input grid.\n    \"\"\"\n    \n    # Handle empty or invalid input\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    \n    # Initialize output_grid as a deep copy of the input\n    output_grid = deepcopy(input_grid)\n\n    # 1. Identify Grid Components\n    background_color = find_background(input_grid)\n    if background_color == -1: return output_grid # Return copy if grid was empty/error\n    \n    objects = find_objects(input_grid, background_color)\n    \n    # Expect exactly two objects based on examples\n    if len(objects) != 2:\n        # If not exactly two objects, return the original grid copy\n        return output_grid\n        \n    obj1_color, obj1_coords = objects[0]\n    obj2_color, obj2_coords = objects[1]\n    \n    # 2. Determine Object Relationship\n    obj1_bbox = get_bounding_box(obj1_coords)\n    obj2_bbox = get_bounding_box(obj2_coords)\n    min_r1, max_r1, min_c1, max_c1 = obj1_bbox\n    min_r2, max_r2, min_c2, max_c2 = obj2_bbox\n\n    # Check for horizontal separation (gap in columns, potential overlap in rows)\n    # Ensure objects are truly separated and not touching or overlapping on the primary axis\n    if max_c1 < min_c2 -1 or max_c2 < min_c1 - 1: \n        separation_axis = 'horizontal'\n        # Ensure obj1 is left, obj2 is right for consistent processing\n        if min_c1 > min_c2:\n            # Swap all properties if obj1 was initially on the right\n            obj1_color, obj2_color = obj2_color, obj1_color\n            min_r1, max_r1, min_c1, max_c1 = obj2_bbox\n            min_r2, max_r2, min_c2, max_c2 = obj1_bbox\n            \n        # 3. Define Transformation Zones\n        # Gap range along the separation axis (columns)\n        gap_start = max_c1 + 1\n        gap_end = min_c2 - 1\n        \n        # Overlap range along the non-separation axis (rows)\n        overlap_min = max(min_r1, min_r2)\n        overlap_max = min(max_r1, max_r2)\n\n        # Fill extent along the non-separation axis (rows), clamped to grid bounds\n        fill_extent_min = max(0, overlap_min - 1)\n        fill_extent_max = min(rows - 1, overlap_max + 1)\n        \n        # 4. Calculate Midpoint boundary along the separation axis (columns)\n        midpoint_boundary = (gap_start + gap_end + 1) / 2 \n        \n        # 5. Apply Transformation\n        # Iterate through the 'Fill Extent' rows\n        for r in range(fill_extent_min, fill_extent_max + 1):\n            # Iterate through the 'Gap Range' columns\n            for c in range(gap_start, gap_end + 1):\n                 # Check if the cell in the *original* grid is background\n                if input_grid[r][c] == background_color:\n                    # Fill with color based on which side of the midpoint the column falls\n                    if c < midpoint_boundary:\n                        output_grid[r][c] = obj1_color\n                    else:\n                        output_grid[r][c] = obj2_color\n                        \n    # Check for vertical separation (gap in rows, potential overlap in columns)\n    # Ensure objects are truly separated and not touching or overlapping on the primary axis\n    elif max_r1 < min_r2 - 1 or max_r2 < min_r1 - 1:\n        separation_axis = 'vertical'\n        # Ensure obj1 is top, obj2 is bottom\n        if min_r1 > min_r2:\n            # Swap all properties if obj1 was initially on the bottom\n            obj1_color, obj2_color = obj2_color, obj1_color\n            min_r1, max_r1, min_c1, max_c1 = obj2_bbox\n            min_r2, max_r2, min_c2, max_c2 = obj1_bbox\n\n        # 3. Define Transformation Zones\n        # Gap range along the separation axis (rows)\n        gap_start = max_r1 + 1\n        gap_end = min_r2 - 1\n\n        # Overlap range along the non-separation axis (columns)\n        overlap_min = max(min_c1, min_c2)\n        overlap_max = min(max_c1, max_c2)\n        \n        # Fill extent along the non-separation axis (columns), clamped to grid bounds\n        fill_extent_min = max(0, overlap_min - 1)\n        fill_extent_max = min(cols - 1, overlap_max + 1)\n\n        # 4. Calculate Midpoint boundary along the separation axis (rows)\n        midpoint_boundary = (gap_start + gap_end + 1) / 2\n\n        # 5. Apply Transformation\n        # Iterate through the 'Fill Extent' columns\n        for c in range(fill_extent_min, fill_extent_max + 1):\n             # Iterate through the 'Gap Range' rows\n             for r in range(gap_start, gap_end + 1):\n                 # Check if the cell in the *original* grid is background\n                if input_grid[r][c] == background_color:\n                    # Fill with color based on which side of the midpoint the row falls\n                    if r < midpoint_boundary:\n                        output_grid[r][c] = obj1_color\n                    else:\n                         output_grid[r][c] = obj2_color\n    else:\n        # Objects might be touching, overlapping, or arranged differently.\n        # Based on the instructions, we return the original grid copy in these cases.\n        pass # output_grid is already a copy\n\n    # 6. Return Result\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11720,
    "candidates_token_count": 3256,
    "total_token_count": 14976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.845057,
  "retries": 1
}