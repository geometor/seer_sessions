{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis module transforms an input 13x13 grid containing four distinct 3-cell L-shapes\ninto a 4x4 output grid. It identifies each L-shape, determines its 2x2 bounding\nbox pattern and its orientation (based on the position of the single zero cell\nwithin the 2x2 box). It then places each 2x2 pattern into a specific quadrant\nof the 4x4 output grid according to the shape's orientation:\n- Top-Left shape (zero at bottom-right) goes to output top-left quadrant.\n- Top-Right shape (zero at bottom-left) goes to output top-right quadrant.\n- Bottom-Left shape (zero at top-right) goes to output bottom-left quadrant.\n- Bottom-Right shape (zero at top-left) goes to output bottom-right quadrant.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_shapes(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all connected components (shapes) of non-zero cells in the grid.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a shape\n        and contains 'color' (int) and 'coords' (list of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    coords.append((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if coords: # Should always be true if we start with a non-zero cell\n                    shapes.append({'color': color, 'coords': coords})\n                    \n    return shapes\n\ndef _get_2x2_pattern(grid: np.ndarray, coords: list[tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Extracts the 2x2 bounding box pattern for a shape.\n\n    Args:\n        grid: The input grid as a NumPy array.\n        coords: List of (row, col) coordinates for the shape.\n\n    Returns:\n        A 2x2 NumPy array representing the shape's pattern.\n    \"\"\"\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    # Since it's an L-shape of 3 cells, the bounding box will be 2x2\n    # The top-left corner of this 2x2 box is (min_r, min_c)\n    pattern = grid[min_r : min_r + 2, min_c : min_c + 2]\n    return pattern\n\ndef _get_orientation(pattern_2x2: np.ndarray) -> str:\n    \"\"\"\n    Determines the orientation of the L-shape based on the zero's position\n    in its 2x2 pattern.\n\n    Args:\n        pattern_2x2: The 2x2 NumPy array pattern.\n\n    Returns:\n        A string representing the orientation: 'TL', 'TR', 'BL', 'BR'.\n        Corresponds to the location where the shape *block* is placed\n        in the output (e.g. 'TL' means the main L is in the top left\n        of its 2x2 square, meaning the zero is at the bottom right).\n    \"\"\"\n    zero_pos = np.where(pattern_2x2 == 0)\n    zero_r, zero_c = zero_pos[0][0], zero_pos[1][0]\n\n    if zero_r == 1 and zero_c == 1: # Zero at bottom-right -> Shape at Top-Left\n        return 'TL'\n    elif zero_r == 1 and zero_c == 0: # Zero at bottom-left -> Shape at Top-Right\n        return 'TR'\n    elif zero_r == 0 and zero_c == 1: # Zero at top-right -> Shape at Bottom-Left\n        return 'BL'\n    elif zero_r == 0 and zero_c == 0: # Zero at top-left -> Shape at Bottom-Right\n        return 'BR'\n    else:\n        # Should not happen for valid L-shapes\n        raise ValueError(\"Invalid L-shape pattern encountered.\")\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms an input 13x13 grid containing four distinct 3-cell L-shapes\n    into a 4x4 output grid by identifying each L-shape, determining its 2x2\n    pattern and orientation, and placing the pattern into the corresponding\n    quadrant of the output grid based on orientation.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and processing\n    grid_np = np.array(input_grid, dtype=int)\n\n    # Initialize output_grid (4x4) with zeros\n    output_grid_np = np.zeros((4, 4), dtype=int)\n\n    # Find all distinct non-zero shapes in the input grid\n    shapes = _find_shapes(grid_np)\n\n    # Process each shape found\n    for shape in shapes:\n        # Get the 2x2 pattern for the current shape\n        pattern = _get_2x2_pattern(grid_np, shape['coords'])\n\n        # Determine the orientation of the shape based on the pattern\n        orientation = _get_orientation(pattern)\n\n        # Place the 2x2 pattern into the correct quadrant of the output grid\n        if orientation == 'TL':\n            output_grid_np[0:2, 0:2] = pattern\n        elif orientation == 'TR':\n            output_grid_np[0:2, 2:4] = pattern\n        elif orientation == 'BL':\n            output_grid_np[2:4, 0:2] = pattern\n        elif orientation == 'BR':\n            output_grid_np[2:4, 2:4] = pattern\n\n    # Convert the numpy output grid back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2780,
    "candidates_token_count": 2527,
    "total_token_count": 5307,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.064324,
  "retries": 1
}