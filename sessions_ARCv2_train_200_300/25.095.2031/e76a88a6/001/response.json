{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\nfrom collections import deque\n\n\"\"\"\nIdentifies the first non-uniform shape (target pattern) found when scanning the grid\ntop-to-bottom, left-to-right, and applies its internal color pattern to all uniform\nshapes composed solely of the number 5. The pattern is applied relative to the\ntop-left corner of both the pattern shape and the target '5' shapes.\n\nWorkflow:\n1.  Find all distinct contiguous shapes formed by non-zero numbers in the input grid.\n    Keep track of the order they are found (scan top-to-bottom, left-to-right).\n2.  For each shape, determine its constituent colors, bounding box, and pixel coordinates.\n3.  Identify the *first* shape found that contains more than one distinct non-zero color.\n    This is the \"target pattern shape\".\n4.  Extract the internal color pattern from the target pattern shape, storing colors\n    relative to its top-left corner coordinate.\n5.  Identify all shapes that are composed *exclusively* of the number 5.\n6.  Create a copy of the input grid to serve as the output grid.\n7.  For each identified shape composed only of 5s:\n    a. Iterate through the pixel coordinates (r, c) belonging to this shape.\n    b. For each pixel, calculate its relative position (dr, dc) from the shape's\n       own top-left corner.\n    c. Look up the color in the target pattern using the same relative position (dr, dc).\n    d. If a color exists at that relative position in the pattern, update the\n       output grid at coordinate (r, c) with this pattern color.\n8.  Return the modified output grid.\n\"\"\"\n\n# Helper function to find connected components (shapes) using Breadth-First Search\ndef find_shapes(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous non-zero shapes in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a shape\n        and contains 'pixels', 'colors', 'is_uniform', 'bounding_box',\n        and 'top_left' keys. Shapes are returned in the order their\n        top-left-most pixel is encountered during scanning.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    shapes = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a non-zero cell that hasn't been visited, start a BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_shape_pixels = set([(r, c)])\n                current_shape_colors = set()\n                min_r, min_c = r, c # Initialize bounding box with the starting cell\n                max_r, max_c = r, c\n\n                # Perform BFS to find all connected pixels of the shape\n                while q:\n                    row, col = q.popleft()\n                    pixel_color = grid[row, col]\n                    current_shape_colors.add(pixel_color)\n\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is part of a shape and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            current_shape_pixels.add((nr, nc))\n\n                # Determine if the shape is uniform (only one non-zero color)\n                is_uniform = len(current_shape_colors) == 1\n                \n                # Store shape information\n                shape_info = {\n                    \"pixels\": current_shape_pixels,\n                    \"colors\": current_shape_colors,\n                    \"is_uniform\": is_uniform,\n                    \"bounding_box\": (min_r, min_c, max_r, max_c),\n                    \"top_left\": (min_r, min_c) # Use min_r, min_c as the reference point\n                }\n                shapes.append(shape_info)\n    return shapes\n\n# Helper function to get the pattern (relative coordinates to color) from a shape\ndef get_pattern(grid: np.ndarray, shape: dict) -> dict:\n    \"\"\"\n    Extracts the color pattern from a shape relative to its top-left corner.\n\n    Args:\n        grid: The numpy array representing the grid.\n        shape: The shape dictionary (output from find_shapes).\n\n    Returns:\n        A dictionary mapping relative coordinates (dr, dc) to colors.\n    \"\"\"\n    pattern = {}\n    min_r, min_c = shape['top_left']\n    for r, c in shape['pixels']:\n        dr = r - min_r # Row difference from top-left\n        dc = c - min_c # Column difference from top-left\n        pattern[(dr, dc)] = grid[r, c]\n    return pattern\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by applying the pattern of the first non-uniform\n    shape found to all uniform shapes made of the color 5.\n    \"\"\"\n    \n    # Convert input list of lists to a NumPy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n    # Create a deep copy for the output grid to avoid modifying the input directly\n    output_grid_np = copy.deepcopy(grid_np) \n    \n    # Step 1 & 2: Find all shapes and their properties\n    all_shapes = find_shapes(grid_np)\n\n    # Step 3: Find the first non-uniform shape to use as the pattern source\n    target_pattern_shape = None\n    for shape in all_shapes:\n        if not shape['is_uniform']:\n            target_pattern_shape = shape\n            break # Found the first one, stop searching\n\n    # Handle the case where no non-uniform shape is found (optional, based on problem constraints)\n    if target_pattern_shape is None:\n        # If the problem guarantees a pattern shape, this won't be reached.\n        # Otherwise, return the original grid or raise an error.\n        return input_grid \n\n    # Step 4: Extract the color pattern from the target shape\n    pattern_map = get_pattern(grid_np, target_pattern_shape)\n\n    # Step 5: Identify all shapes to modify (uniform color 5)\n    shapes_to_modify = []\n    for shape in all_shapes:\n        # Check if the shape is uniform and its only color is 5\n        if shape['is_uniform'] and shape['colors'] == {5}:\n            shapes_to_modify.append(shape)\n\n    # Step 6 & 7: Apply the pattern to each identified '5' shape\n    for shape in shapes_to_modify:\n        shape_min_r, shape_min_c = shape['top_left']\n        \n        # Iterate through each pixel within the current '5' shape\n        for r, c in shape['pixels']:\n            # Calculate the pixel's relative coordinates within this shape\n            dr = r - shape_min_r\n            dc = c - shape_min_c\n            \n            # Find the corresponding color from the pattern using the relative coordinates\n            # If the relative coordinate exists in the pattern map, apply the color\n            if (dr, dc) in pattern_map:\n                output_grid_np[r, c] = pattern_map[(dr, dc)]\n            # Else: Implicitly, if a pixel in the shape doesn't have a corresponding\n            # relative coordinate in the pattern (e.g., shapes have different relative extents),\n            # its value remains unchanged in the output copy. Given the examples,\n            # it seems the shapes are expected to map directly.\n\n    # Step 8: Convert the final NumPy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2004,
    "candidates_token_count": 6433,
    "total_token_count": 8437,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 53.872015,
  "retries": 1
}