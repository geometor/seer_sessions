{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport numpy as np\n\n\"\"\"\nRelocates objects ('5's) in a grid towards the nearest cell of a static 2x2 block ('2's),\nstopping just before colliding with the block. The movement follows the shortest path \n(Manhattan distance) step by step. The final positions of the '5's and the original \nposition of the '2' block are placed in an otherwise zeroed grid.\n\"\"\"\n\ndef find_element_coords(grid: list[list[int]], value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of cells with a specific value.\"\"\"\n    coords = []\n    for r, row in enumerate(grid):\n        for c, cell in enumerate(row):\n            if cell == value:\n                coords.append((r, c))\n    return coords\n\ndef manhattan_distance(p1: tuple[int, int], p2: tuple[int, int]) -> int:\n    \"\"\"Calculates the Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef find_nearest_target(position: tuple[int, int], target_coords: list[tuple[int, int]]) -> tuple[int, int]:\n    \"\"\"Finds the target coordinate closest to the given position.\"\"\"\n    min_dist = float('inf')\n    nearest_target = None\n    for target in target_coords:\n        dist = manhattan_distance(position, target)\n        if dist < min_dist:\n            min_dist = dist\n            nearest_target = target\n        # Optional: Tie-breaking (e.g., prefer smaller row, then smaller col) - not strictly needed based on examples\n        elif dist == min_dist:\n             if nearest_target is None or target[0] < nearest_target[0] or (target[0] == nearest_target[0] and target[1] < nearest_target[1]):\n                 nearest_target = target\n    return nearest_target\n\ndef get_step_direction(current: tuple[int, int], target: tuple[int, int]) -> tuple[int, int]:\n    \"\"\"Calculates the (dr, dc) step direction towards the target.\"\"\"\n    dr = 0\n    if target[0] > current[0]:\n        dr = 1\n    elif target[0] < current[0]:\n        dr = -1\n        \n    dc = 0\n    if target[1] > current[1]:\n        dc = 1\n    elif target[1] < current[1]:\n        dc = -1\n        \n    # Prioritize moving along the axis with greater distance difference?\n    # The description implies moving one step in row and/or column direction simultaneously if needed.\n    # Let's stick to the simple sign calculation for now.\n    # If we want diagonal moves, dr and dc can be non-zero simultaneously.\n    # If we want cardinal moves only, prioritize one axis. The NL program implies simultaneous moves.\n    \n    return dr, dc\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Moves each '5' towards the nearest '2' cell, stopping just before collision.\n    \n    Args:\n        input_grid: A 2D list of integers representing the input state.\n\n    Returns:\n        A 2D list of integers representing the final state after movement.\n    \"\"\"\n    if not input_grid:\n        return []\n        \n    rows = len(input_grid)\n    cols = len(input_grid[0])\n    \n    # Use numpy for easier grid manipulation if allowed, otherwise stick to lists\n    output_grid_np = np.zeros((rows, cols), dtype=int)\n    input_grid_np = np.array(input_grid, dtype=int)\n\n    # Locate the target block ('2's) and the movers ('5's)\n    target_coords = find_element_coords(input_grid, 2)\n    mover_start_coords = find_element_coords(input_grid, 5)\n\n    # Place the static target block in the output grid\n    if target_coords:\n        for r, c in target_coords:\n             if 0 <= r < rows and 0 <= c < cols:\n                output_grid_np[r, c] = 2\n    else:\n        # Handle case with no target block? Return input or empty grid? \n        # Based on examples, target always exists. Assume it does.\n        pass # Or raise an error, depending on requirements\n\n    # Process each mover\n    for start_pos in mover_start_coords:\n        curr_pos = start_pos\n        \n        # Check if the mover starts adjacent to a target\n        is_adjacent_start = False\n        if target_coords:\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]: # Check 8 neighbors\n                 check_r, check_c = start_pos[0] + dr, start_pos[1] + dc\n                 if (check_r, check_c) in target_coords:\n                     is_adjacent_start = True\n                     break\n        \n        # If starting next to a target, it doesn't move\n        if is_adjacent_start:\n            final_pos = start_pos\n        elif not target_coords:\n             # If no target, mover stays put\n             final_pos = start_pos\n        else:\n             # Simulate movement step-by-step\n            while True:\n                # Find the closest target cell from the current position\n                nearest_target = find_nearest_target(curr_pos, target_coords)\n                if nearest_target is None: # Should not happen if target_coords is not empty\n                     break \n\n                # Calculate the next step direction\n                dr, dc = get_step_direction(curr_pos, nearest_target)\n\n                # If no move needed (already at optimal non-colliding spot relative to nearest), break\n                if dr == 0 and dc == 0: \n                    # This case happens if the mover is already at a position where the nearest target\n                    # is in the same row/col and moving would collide, OR if the mover is equidistant \n                    # to multiple targets and the step calculation results in (0,0) - though this shouldn't happen with sign().\n                    # More likely: the mover has reached its closest possible non-adjacent spot.\n                    break \n\n                # Determine the next potential position\n                next_r, next_c = curr_pos[0] + dr, curr_pos[1] + dc\n\n                # Check if the next position is valid and if it contains a target ('2')\n                if not (0 <= next_r < rows and 0 <= next_c < cols):\n                     # Moved off grid - stop at current position (shouldn't happen if target is on grid)\n                     break \n                \n                # Check for collision: Is the *next* cell a target cell?\n                if input_grid_np[next_r, next_c] == 2:\n                    # Stop movement *before* entering the target cell\n                    break \n                else:\n                    # Update current position and continue the loop\n                    curr_pos = (next_r, next_c)\n\n            # The loop terminated, curr_pos holds the final position\n            final_pos = curr_pos\n\n        # Place the mover at its final position in the output grid\n        if 0 <= final_pos[0] < rows and 0 <= final_pos[1] < cols:\n             # Ensure we don't overwrite the target block if a 5 ends up there (shouldn't happen)\n             if output_grid_np[final_pos[0], final_pos[1]] == 0:\n                 output_grid_np[final_pos[0], final_pos[1]] = 5\n             # Handle potential overlap of final positions if multiple '5's land on the same spot?\n             # Current logic: Last one wins. Requirements might specify differently.\n\n\n    # Convert back to list of lists if necessary\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2225,
    "candidates_token_count": 2494,
    "total_token_count": 4719,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.689347,
  "retries": 1
}