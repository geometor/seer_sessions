
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 0 0 0 0 0 0
0 5 0 0 0 5 0 0 0 0 0 0
0 5 0 0 0 5 0 5 5 5 5 0
0 5 0 0 0 5 0 5 0 0 5 0
0 5 0 0 0 5 0 5 0 0 5 0
0 5 5 5 5 5 0 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 0 0 0 0 0 0
0 5 0 0 0 5 0 0 0 0 0 0
0 5 0 0 0 5 0 5 5 5 5 0
0 5 0 0 0 5 0 5 2 2 5 0
0 5 0 0 0 5 0 5 2 2 5 0
0 5 5 5 5 5 0 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 5 5 5 5 5 5
0 5 5 5 5 0 5 0 0 0 0 5
0 0 0 0 0 0 5 0 0 0 0 5
0 0 0 0 0 0 5 0 0 0 0 5
5 5 5 5 5 0 5 0 0 0 0 5
5 5 5 5 5 0 5 5 5 5 5 5
5 0 0 5 5 0 0 0 0 0 0 0
5 0 0 5 5 0 0 0 0 0 0 0
5 5 5 5 5 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 2 5 0 0 0 0 0 0 0
0 5 5 5 5 0 5 5 5 5 5 5
0 5 5 5 5 0 5 2 2 2 2 5
0 0 0 0 0 0 5 2 2 2 2 5
0 0 0 0 0 0 5 2 2 2 2 5
5 5 5 5 5 0 5 2 2 2 2 5
5 5 5 5 5 0 5 5 5 5 5 5
5 2 2 5 5 0 0 0 0 0 0 0
5 2 2 5 5 0 0 0 0 0 0 0
5 5 5 5 5 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 5 5 5 5 0
0 5 5 5 5 0 0 5 0 5 5 0
0 0 0 0 0 0 0 5 0 0 5 0
0 0 0 0 0 0 0 5 5 5 5 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 0 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 2 2 5 0 0 0 0 0 0 0
0 5 2 2 5 0 0 5 5 5 5 0
0 5 5 5 5 0 0 5 0 5 5 0
0 0 0 0 0 0 0 5 0 0 5 0
0 0 0 0 0 0 0 5 5 5 5 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 2 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

**Perception of Elements:**

1.  **Input/Output:** Both are grids (2D arrays) of integers.
2.  **Colors/Values:** The grids use three main integer values:
    *   `0`: Represents the background or empty space.
    *   `5`: Represents foreground elements, forming shapes or boundaries.
    *   `2`: Appears only in the output, replacing some `0`s.
3.  **Structure:** The `5`s form distinct shapes or outlines within the grid. These shapes remain identical between the input and output.
4.  **Transformation:** The core transformation is the selective conversion of some `0`s to `2`s.
5.  **Location of Change:** The `0`s that change to `2`s are always located *inside* regions enclosed by `5`s.
6.  **Condition for Change:** Not all `0`s enclosed by `5`s are changed. Comparing the examples:
    *   In `train_1`, `train_2`, and `train_4`, some enclosed `0` regions are filled with `2`s.
    *   In `train_3`, no `0`s are changed, even though there are enclosed regions.
    *   The unfilled regions in `train_1` (bottom) and `train_3` (both) seem to have boundaries made of thicker lines of `5`s compared to the filled regions. Specifically, the `5`s forming the boundary of unfilled holes often only have other `5`s or internal `0`s as neighbors, lacking adjacent external `0`s. Filled holes appear to have "thin" boundaries where each boundary `5` is adjacent to an external `0`.

**YAML Facts:**


```yaml
Objects:
  - Grid: A 2D array of cells.
  - Cell: An element in the grid with a specific integer value (color).
  - Region: A contiguous area of cells with the same color (e.g., a region of 0s).
  - Shape: A structure formed by connected cells of color 5.
  - Hole: A region of 0s completely surrounded by 5s (not connected to the grid boundary).

Properties:
  - Cell Color: 0 (background), 5 (shape/boundary), 2 (filled hole).
  - Region Connectivity: Cells within a region are adjacent (4-way or 8-way, appears 4-way matters for boundaries).
  - Hole Boundary: The set of 5-valued cells immediately adjacent to a hole.
  - Boundary Thickness (Inferred Property): Whether boundary 5s are adjacent to external 0s.

Actions:
  - Identify Regions: Find connected components of cells with the same color.
  - Identify Holes: Find 0-regions not reachable by flood fill from the grid boundary.
  - Analyze Hole Boundary: For each 5-cell on a hole's boundary, check its neighbors.
  - Fill Hole: Change the color of all 0s within a specific hole region to 2.

Relationships:
  - Adjacency: Cells can be neighbors (up, down, left, right).
  - Containment: Shapes (5s) enclose holes (0s that become 2s).
  - Boundary Condition: The decision to fill a hole (0 -> 2) depends on the neighborhood properties of the 5s forming its boundary.
```


**Natural Language Program:**

1.  Initialize an output grid as a copy of the input grid.
2.  Identify all connected regions of `0` cells in the input grid.
3.  Determine which `0` regions are "holes" â€“ meaning they are not connected to the grid's outer border (i.e., a flood fill starting from all border `0`s would not reach these regions).
4.  For each identified hole (a region of `0`s):
    a.  Assume the hole should be filled (change `0`s to `2`s).
    b.  Find all `5`-valued cells that are directly adjacent (up, down, left, or right) to any `0` cell within this specific hole. Call this set the "boundary `5`s".
    c.  Iterate through each boundary `5` cell. For each such `5` cell, examine all its direct neighbors (up, down, left, right).
    d.  If *any* boundary `5` cell exists such that *all* of its neighbors are either other `5`s or `0`s belonging *only* to the current hole being examined (i.e., it has no adjacent `0`s that are part of the background or a different hole), then this current hole should *not* be filled. Mark this hole as "do not fill" and stop checking its boundary `5`s.
    e.  If the check completes for all boundary `5`s of the hole and the hole was never marked "do not fill", then proceed to fill it.
    f.  To fill the hole, change the value of every `0` cell within that specific hole region to `2` in the output grid.
5.  Return the final output grid.
```python
"""
Identifies enclosed regions of 0s (holes) within shapes formed by 5s in a 2D grid. 
A hole is filled with 2s if and only if every 5-cell forming its immediate boundary 
is adjacent to at least one 0-cell that is *not* part of that hole (i.e., an external 0 or a 0 from a different hole). 
If any boundary 5-cell of a hole is only adjacent to other 5s or 0s belonging exclusively 
to that specific hole, the hole remains unfilled (keeps its 0s).
"""

import numpy as np
from collections import deque
import copy

def _get_neighbors(r, c, rows, cols):
    """ Get valid 4-directional neighbors for a cell. """
    neighbors = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < rows and 0 <= nc < cols:
            neighbors.append((nr, nc))
    return neighbors

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the grid by filling certain enclosed regions of 0s with 2s.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Convert to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    # Visited array to keep track of cells processed during BFS
    visited = np.zeros_like(grid, dtype=bool)
    
    # --- Step 1: Identify all 0s connected to the border ---
    border_connected_zeros = set()
    q = deque()

    # Initialize queue with all border 0s
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
                border_connected_zeros.add((r, c))
    for c in range(cols):
        for r in [0, rows - 1]:
             if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
                border_connected_zeros.add((r, c))

    # Perform BFS from border 0s
    while q:
        r, c = q.popleft()
        for nr, nc in _get_neighbors(r, c, rows, cols):
            if grid[nr, nc] == 0 and not visited[nr, nc]:
                visited[nr, nc] = True
                q.append((nr, nc))
                border_connected_zeros.add((nr, nc))

    # --- Step 2: Identify holes and check fill condition ---
    hole_candidates = []
    # Reset visited for hole finding, but keep track of border zeros
    visited_holes = np.zeros_like(grid, dtype=bool) # Track visited cells during hole search
    
    for r in range(rows):
        for c in range(cols):
            # If it's a 0, not connected to the border, and not yet visited as part of a hole
            if grid[r, c] == 0 and (r, c) not in border_connected_zeros and not visited_holes[r, c]:
                current_hole_zeros = set()
                boundary_fives = set()
                hole_q = deque([(r, c)])
                visited_holes[r, c] = True
                is_valid_hole = True # Assume it's a hole unless proven otherwise

                # Find all connected 0s for this potential hole region using BFS
                while hole_q:
                    hr, hc = hole_q.popleft()
                    current_hole_zeros.add((hr, hc))

                    # Check neighbors
                    for nr, nc in _get_neighbors(hr, hc, rows, cols):
                        neighbor_val = grid[nr, nc]
                        # If neighbor is 0 and not visited/part of border region
                        if neighbor_val == 0 and (nr, nc) not in border_connected_zeros and not visited_holes[nr, nc]:
                             visited_holes[nr, nc] = True
                             hole_q.append((nr, nc))
                        # If neighbor is 5, add it to potential boundary
                        elif neighbor_val == 5:
                            boundary_fives.add((nr, nc))
                        # If it reaches a border-connected 0, it's not an enclosed hole
                        elif neighbor_val == 0 and (nr, nc) in border_connected_zeros:
                           is_valid_hole = False # Should not happen based on initial check, but safeguard
                           # We can potentially break early here if performance needed
                           # break # Break inner neighbor loop
                    # if not is_valid_hole: # Break outer hole_q loop
                    #    break
                        
                if not is_valid_hole:
                    continue # Skip to the next potential starting cell

                # If we found a valid hole region, check its boundary condition
                fill_this_hole = True
                if not boundary_fives: # Hole with no boundary? Should not happen in valid grids.
                    fill_this_hole = False
                    
                for br, bc in boundary_fives:
                    has_external_zero_neighbor = False
                    for nr, nc in _get_neighbors(br, bc, rows, cols):
                        # Check if the neighbor is a 0 that is NOT part of the current hole
                        if grid[nr, nc] == 0 and (nr, nc) not in current_hole_zeros:
                            has_external_zero_neighbor = True
                            break # Found an external 0 neighbor, this 5 is fine

                    # If this boundary 5 *only* has neighbors that are 5s or internal 0s
                    if not has_external_zero_neighbor:
                        fill_this_hole = False # Found a 'thick' boundary point, do not fill
                        break # No need to check other boundary 5s for this hole

                # --- Step 3: Fill the hole if condition met ---
                if fill_this_hole:
                    for hr, hc in current_hole_zeros:
                        output_grid[hr, hc] = 2

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
