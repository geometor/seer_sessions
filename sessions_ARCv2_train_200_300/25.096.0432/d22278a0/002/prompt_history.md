
## train_1

**input:**
```
2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 0 2 0 2 0 2 0 2 0 2 0 2
0 0 2 0 2 0 2 0 2 0 2 0 2
2 2 2 0 2 0 2 0 2 0 2 0 2
0 0 0 0 2 0 2 0 2 0 2 0 2
2 2 2 2 2 0 2 0 2 0 2 0 2
0 0 0 0 0 0 2 0 2 0 2 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 0 4 0 4 0 4
4 4 4 4 4 0 4 0 4 0 4 0 4
0 0 0 0 4 0 4 0 4 0 4 0 4
4 4 4 0 4 0 4 0 4 0 4 0 4
0 0 4 0 4 0 4 0 4 0 4 0 4
4 0 4 0 4 0 4 0 4 0 4 0 4
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 3 0 3 0 3 0 3 0 3 0 3
8 0 0 3 0 3 0 3 0 3 0 0
0 0 0 3 0 3 0 3 0 3 3 3
8 8 8 0 0 3 0 3 0 0 0 0
0 0 0 0 0 3 0 3 3 3 3 3
8 8 8 8 8 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3
8 8 8 8 8 0 8 0 0 0 0 0
0 0 0 0 8 0 8 0 0 3 3 3
8 8 8 0 8 0 8 0 8 0 0 0
0 0 8 0 8 0 8 0 8 0 0 3
8 0 8 0 8 0 8 0 8 0 8 0
```


## train_3

**input:**
```
1 0 0 0 0 0 2
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
8 0 0 0 0 0 0
```


**output:**
```
1 0 1 0 2 0 2
0 0 1 0 2 0 0
1 1 1 0 2 2 2
0 0 0 0 0 0 0
8 8 8 0 0 2 2
0 0 8 0 8 0 0
8 0 8 0 8 0 0
```


## train_4

**input:**
```
1 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
1 0 1 0 1 2 0 2 0 2
0 0 1 0 1 2 0 2 0 0
1 1 1 0 1 2 0 2 2 2
0 0 0 0 1 2 0 0 0 0
1 1 1 1 1 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down the transformation logic for these examples.

## Perception

1.  **Input/Output:** The task takes a 2D grid (matrix) of integers as input and produces another 2D grid of the same dimensions as output.
2.  **Key Elements:** The non-zero integers in the input grid are the primary actors. The zero values represent a background.
3.  **Transformation Goal:** The output grid is generated by "painting" regions based on the non-zero values from the input grid. Each non-zero value in the input seems to claim a territory in the output grid.
4.  **Proximity Rule:** The value assigned to an output cell `(r_out, c_out)` is determined by the value of the *closest* non-zero input cell `(r_in, c_in)`. Closeness is measured using Manhattan distance: `|r_out - r_in| + |c_out - c_in|`.
5.  **Tie-Breaking:** If an output cell is equidistant from two or more non-zero input cells, the value assigned comes from the input cell with the smallest row index (`r_in`). If there's still a tie (multiple closest input cells in the same row), the one with the smallest column index (`c_in`) is chosen.
6.  **Parity Constraint:** There's an additional condition for painting. A non-zero value `v` from the chosen closest input cell `(v, r_in, c_in)` is only placed at the output cell `(r_out, c_out)` if the column index of the output cell (`c_out`) has the same parity (both even or both odd) as the column index of the input cell (`c_in`). That is, `c_out % 2 == c_in % 2`. If the parities do not match, the output cell remains 0, even if it's closest to a non-zero input cell.

## Facts


```yaml
Objects:
  - InputGrid:
      Properties:
        - rows: Integer
        - columns: Integer
        - cells: List[List[Integer]]
  - OutputGrid:
      Properties:
        - rows: Integer
        - columns: Integer
        - cells: List[List[Integer]]
  - InputCell:
      Properties:
        - value: Integer (non-zero)
        - row: Integer
        - column: Integer
  - OutputCell:
      Properties:
        - value: Integer
        - row: Integer
        - column: Integer

Properties:
  - ManhattanDistance: Integer (calculated between an OutputCell and an InputCell)
  - ColumnParity: Integer (0 for even, 1 for odd)

Actions:
  - FindNonZeroInputCells: Identify all InputCells with value > 0 in the InputGrid.
  - CalculateDistances: For a given OutputCell, compute ManhattanDistance to all non-zero InputCells.
  - FindClosestInputCell:
      - Identify the minimum ManhattanDistance for an OutputCell.
      - Select all InputCells matching the minimum distance.
      - ApplyTieBreaking: If multiple InputCells are closest, select based on minimum row, then minimum column.
  - CheckColumnParity: Compare the ColumnParity of an OutputCell's column and the chosen InputCell's column.
  - AssignOutputValue: Set the value of an OutputCell based on the chosen InputCell's value, conditional on the parity check.

Relationships:
  - Each OutputCell's value is derived from exactly one InputCell (the closest one after tie-breaking).
  - The assignment of the value is conditional on the relationship between the OutputCell's column parity and the chosen InputCell's column parity.
```


## Natural Language Program

1.  Identify all non-zero cells in the `InputGrid`. For each, record its value (`v`), row index (`r_in`), and column index (`c_in`). Store these as a list of `InputCell` records.
2.  Create an `OutputGrid` with the same dimensions as the `InputGrid`, initializing all its cells to 0.
3.  Iterate through each cell `(r_out, c_out)` in the `OutputGrid`.
4.  For the current `OutputCell` at `(r_out, c_out)`:
    a.  If there are no non-zero `InputCells`, keep the `OutputCell` value as 0 and proceed to the next `OutputCell`.
    b.  Calculate the Manhattan distance `d = |r_out - r_in| + |c_out - c_in|` from this `OutputCell` to every non-zero `InputCell` `(v, r_in, c_in)`.
    c.  Find the minimum distance calculated in the previous step.
    d.  Identify all `InputCells` that have this minimum distance.
    e.  From this set of closest `InputCells`, select the single "winning" `InputCell` by choosing the one with the smallest `r_in`. If there is still a tie (multiple cells have the same minimum `r_in`), choose the one among them with the smallest `c_in`. Let the chosen winning cell be `(v*, r*_in, c*_in)`.
    f.  Check if the column index of the current `OutputCell` (`c_out`) has the same parity as the column index of the winning `InputCell` (`c*_in`). That is, check if `c_out % 2 == c*_in % 2`.
    g.  If the parities match, set the value of the `OutputCell` at `(r_out, c_out)` to `v*`.
    h.  If the parities do not match, leave the value of the `OutputCell` at `(r_out, c_out)` as 0.
5.  After iterating through all `OutputCells`, the `OutputGrid` is complete. Return it.
```python
import math

"""
Transforms an input grid based on the nearest non-zero input cell, with a column parity constraint.

1.  Find all non-zero cells in the input grid, storing their value, row, and column.
2.  Initialize an output grid of the same dimensions as the input, filled with zeros.
3.  For each cell (r_out, c_out) in the output grid:
    a. Calculate the Manhattan distance to every non-zero input cell (v, r_in, c_in).
    b. Find the minimum Manhattan distance.
    c. Identify all input cells that have this minimum distance.
    d. Apply tie-breaking: Among the closest input cells, select the one with the smallest row index (r_in). If there's still a tie, select the one with the smallest column index (c_in). Let this winning input cell be (v*, r*_in, c*_in).
    e. Check if the output cell's column index (c_out) has the same parity (even/odd) as the winning input cell's column index (c*_in).
    f. If the parities match (c_out % 2 == c*_in % 2), set the output cell's value to v*. Otherwise, leave it as 0.
4. Return the completed output grid.
"""

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the nearest neighbor transformation with column parity check.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # 1. Find all non-zero cells in the input grid
    non_zero_cells = []
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] != 0:
                non_zero_cells.append({'value': input_grid[r][c], 'row': r, 'col': c})

    # Handle case with no non-zero input cells
    if not non_zero_cells:
        return [[0 for _ in range(cols)] for _ in range(rows)]

    # 2. Initialize an output grid
    output_grid = [[0 for _ in range(cols)] for _ in range(rows)]

    # 3. Iterate through each cell in the output grid
    for r_out in range(rows):
        for c_out in range(cols):
            min_dist = float('inf')
            closest_cells = []

            # 3a. Calculate Manhattan distance to every non-zero input cell
            for cell in non_zero_cells:
                r_in, c_in = cell['row'], cell['col']
                dist = abs(r_out - r_in) + abs(c_out - c_in)

                # 3b & 3c. Find minimum distance and identify closest cells
                if dist < min_dist:
                    min_dist = dist
                    closest_cells = [cell]
                elif dist == min_dist:
                    closest_cells.append(cell)

            # 3d. Apply tie-breaking (sort by row, then column)
            # Sorting key uses a tuple: (row, column)
            closest_cells.sort(key=lambda x: (x['row'], x['col']))
            winning_cell = closest_cells[0]
            v_win, r_win, c_win = winning_cell['value'], winning_cell['row'], winning_cell['col']

            # 3e. Check column parity
            if c_out % 2 == c_win % 2:
                 # 3f. If parities match, assign value
                 output_grid[r_out][c_out] = v_win
            # else: leave as 0 (already initialized)


    # 4. Return the completed output grid
    return output_grid
```
