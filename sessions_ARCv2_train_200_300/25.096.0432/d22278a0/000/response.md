Okay, let's break down the transformation logic for these examples.

## Perception

1.  **Input/Output:** The task takes a 2D grid (matrix) of integers as input and produces another 2D grid of the same dimensions as output.
2.  **Key Elements:** The non-zero integers in the input grid are the primary actors. The zero values represent a background.
3.  **Transformation Goal:** The output grid is generated by "painting" regions based on the non-zero values from the input grid. Each non-zero value in the input seems to claim a territory in the output grid.
4.  **Proximity Rule:** The value assigned to an output cell `(r_out, c_out)` is determined by the value of the *closest* non-zero input cell `(r_in, c_in)`. Closeness is measured using Manhattan distance: `|r_out - r_in| + |c_out - c_in|`.
5.  **Tie-Breaking:** If an output cell is equidistant from two or more non-zero input cells, the value assigned comes from the input cell with the smallest row index (`r_in`). If there's still a tie (multiple closest input cells in the same row), the one with the smallest column index (`c_in`) is chosen.
6.  **Parity Constraint:** There's an additional condition for painting. A non-zero value `v` from the chosen closest input cell `(v, r_in, c_in)` is only placed at the output cell `(r_out, c_out)` if the column index of the output cell (`c_out`) has the same parity (both even or both odd) as the column index of the input cell (`c_in`). That is, `c_out % 2 == c_in % 2`. If the parities do not match, the output cell remains 0, even if it's closest to a non-zero input cell.

## Facts


```yaml
Objects:
  - InputGrid:
      Properties:
        - rows: Integer
        - columns: Integer
        - cells: List[List[Integer]]
  - OutputGrid:
      Properties:
        - rows: Integer
        - columns: Integer
        - cells: List[List[Integer]]
  - InputCell:
      Properties:
        - value: Integer (non-zero)
        - row: Integer
        - column: Integer
  - OutputCell:
      Properties:
        - value: Integer
        - row: Integer
        - column: Integer

Properties:
  - ManhattanDistance: Integer (calculated between an OutputCell and an InputCell)
  - ColumnParity: Integer (0 for even, 1 for odd)

Actions:
  - FindNonZeroInputCells: Identify all InputCells with value > 0 in the InputGrid.
  - CalculateDistances: For a given OutputCell, compute ManhattanDistance to all non-zero InputCells.
  - FindClosestInputCell:
      - Identify the minimum ManhattanDistance for an OutputCell.
      - Select all InputCells matching the minimum distance.
      - ApplyTieBreaking: If multiple InputCells are closest, select based on minimum row, then minimum column.
  - CheckColumnParity: Compare the ColumnParity of an OutputCell's column and the chosen InputCell's column.
  - AssignOutputValue: Set the value of an OutputCell based on the chosen InputCell's value, conditional on the parity check.

Relationships:
  - Each OutputCell's value is derived from exactly one InputCell (the closest one after tie-breaking).
  - The assignment of the value is conditional on the relationship between the OutputCell's column parity and the chosen InputCell's column parity.
```


## Natural Language Program

1.  Identify all non-zero cells in the `InputGrid`. For each, record its value (`v`), row index (`r_in`), and column index (`c_in`). Store these as a list of `InputCell` records.
2.  Create an `OutputGrid` with the same dimensions as the `InputGrid`, initializing all its cells to 0.
3.  Iterate through each cell `(r_out, c_out)` in the `OutputGrid`.
4.  For the current `OutputCell` at `(r_out, c_out)`:
    a.  If there are no non-zero `InputCells`, keep the `OutputCell` value as 0 and proceed to the next `OutputCell`.
    b.  Calculate the Manhattan distance `d = |r_out - r_in| + |c_out - c_in|` from this `OutputCell` to every non-zero `InputCell` `(v, r_in, c_in)`.
    c.  Find the minimum distance calculated in the previous step.
    d.  Identify all `InputCells` that have this minimum distance.
    e.  From this set of closest `InputCells`, select the single "winning" `InputCell` by choosing the one with the smallest `r_in`. If there is still a tie (multiple cells have the same minimum `r_in`), choose the one among them with the smallest `c_in`. Let the chosen winning cell be `(v*, r*_in, c*_in)`.
    f.  Check if the column index of the current `OutputCell` (`c_out`) has the same parity as the column index of the winning `InputCell` (`c*_in`). That is, check if `c_out % 2 == c*_in % 2`.
    g.  If the parities match, set the value of the `OutputCell` at `(r_out, c_out)` to `v*`.
    h.  If the parities do not match, leave the value of the `OutputCell` at `(r_out, c_out)` as 0.
5.  After iterating through all `OutputCells`, the `OutputGrid` is complete. Return it.