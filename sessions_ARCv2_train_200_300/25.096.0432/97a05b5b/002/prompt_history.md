
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0
0 2 2 0 2 2 2 2 2 0
0 2 0 0 0 2 2 2 2 0
0 2 2 2 2 2 2 2 2 0
0 2 2 2 2 0 0 2 2 0
0 2 2 2 2 0 2 0 2 0
0 2 2 2 2 2 0 0 2 0
0 2 2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 4 2 4 0 0 0 0 0 0
0 2 2 4 0 0 0 0 0 0
0 4 2 4 0 2 2 3 0 0
0 0 0 0 0 2 3 2 0 0
0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2
2 4 2 4 2 2 2 2
2 2 2 2 2 2 2 2
2 4 4 4 2 2 2 2
2 2 2 2 2 2 3 2
2 2 2 2 2 3 2 2
2 2 2 2 3 2 2 2
2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 0 0 2 2 2 2 0 2 0 0 2 2 2 0 0 0
0 0 2 2 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 0 0 0 2 2 2 0 0 0 2 2 2 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 2 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 8 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 4 4 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 4 2 4 0 0 2 2 2 0 0 0 0 0 0 0 0
0 0 0 2 2 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 4 4 2 2 3 2 3
2 2 2 4 2 2 3 2 3
2 4 4 4 2 2 3 2 3
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
8 2 2 2 2 5 2 5 2
8 8 2 2 2 5 2 5 2
8 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 0 0 0 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```

Okay, let's analyze the task based on the provided examples.

**Perception of Elements:**

1.  **Input/Output Data:** Both inputs and outputs are 2D grids (matrices) containing single-digit integers. The number 0 appears to represent a background or empty space.
2.  **Structure:** The input grids contain one or more distinct "islands" or "blobs" of non-zero numbers, separated by the background color 0.
3.  **Transformation:** The output grid seems to be a sub-grid extracted from the input grid. Specifically, it corresponds to one of the non-zero blobs found in the input.
4.  **Selection Criteria:** By comparing the blobs in the input to the output across the examples:
    *   In `train_1`, the top blob is selected, which is larger than the bottom blob.
    *   In `train_2`, the large, complex blob starting near the top-left is selected, which is significantly larger than the other smaller blobs (containing 1s, 3s, 8s, 4s, 5s).
    *   In `train_3`, the second, larger blob (mostly 2s) is selected, not the smaller first blob (with 8s).
    *   This suggests the rule is to identify the *largest* connected region (blob) of non-zero cells in the input grid. "Largest" most likely refers to the total count of non-zero cells within the blob.
5.  **Extraction Method:** Once the largest blob is identified, the output grid is formed by taking the rectangular bounding box that minimally encloses this largest blob within the input grid. All cells within this bounding box, including any original 0s inside it, are included in the output.

**YAML Facts:**


```yaml
task_type: grid_transformation
input_features:
  - type: grid
  - element_type: integer
  - background_color: 0
  - contains_multiple_objects: true
output_features:
  - type: grid
  - element_type: integer
objects:
  - name: blob
    definition: A connected region of non-zero cells in the input grid.
    connectivity: Assumed 4-connectivity (up, down, left, right neighbours).
    properties:
      - size: The count of non-zero cells in the blob.
      - bounding_box: The minimum rectangle (min_row, max_row, min_col, max_col) enclosing the blob.
relationships:
  - type: selection
    subject: blob
    criteria: The blob with the maximum size (largest count of non-zero cells).
actions:
  - name: identify_blobs
    description: Find all distinct connected regions of non-zero cells in the input grid.
  - name: calculate_blob_size
    description: Count the number of non-zero cells for each identified blob.
  - name: find_largest_blob
    description: Select the blob with the highest cell count. Resolve ties arbitrarily if necessary (though not observed in examples).
  - name: determine_bounding_box
    description: Find the minimum and maximum row and column indices for the selected largest blob.
  - name: extract_subgrid
    description: Create the output grid by copying the portion of the input grid defined by the bounding box of the largest blob.
```


**Natural Language Program:**

1.  Identify all separate connected regions (blobs) of non-zero numbers in the input grid. Assume connectivity means sharing an edge (up, down, left, or right).
2.  For each blob, calculate its size by counting the number of non-zero cells it contains.
3.  Determine which blob has the largest size. If there is a tie, the specific tie-breaking rule is not definitively shown, but selecting the first one encountered (e.g., scanning top-to-bottom, left-to-right) is a plausible default.
4.  Find the minimum bounding box of this largest blob (the smallest rectangle containing all its cells). This is defined by the minimum row, maximum row, minimum column, and maximum column occupied by the blob's cells.
5.  Extract the sub-grid from the input corresponding to this bounding box. The output is this extracted rectangular section, including any original zero values that fall within the bounding box.
```python
"""
Identify all separate connected regions (blobs) of non-zero numbers in the input grid using 4-way connectivity (up, down, left, right).
Calculate the size of each blob by counting its non-zero cells.
Find the blob with the largest size. If there's a tie, the first one encountered during a top-to-bottom, left-to-right scan is chosen implicitly.
Determine the minimum bounding box (min_row, max_row, min_col, max_col) enclosing this largest blob.
Extract the rectangular sub-grid from the input corresponding to this bounding box. The output is this extracted section, including any original zero values within the box.
"""

import numpy as np
from collections import deque

def _find_largest_blob_and_bbox(grid: np.ndarray) -> tuple[int, int, int, int]:
    """
    Finds the largest blob of non-zero cells and its bounding box.

    Args:
        grid: The input grid as a numpy array.

    Returns:
        A tuple (min_row, max_row, min_col, max_col) for the largest blob.
        Returns (0, 0, 0, 0) if the grid is empty or contains only zeros.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    max_blob_size = -1
    best_bbox = (0, 0, 0, 0) # min_row, max_row, min_col, max_col

    for r in range(rows):
        for c in range(cols):
            # If this cell is non-zero and not visited, start a BFS
            if grid[r, c] != 0 and not visited[r, c]:
                q = deque([(r, c)])
                visited[r, c] = True
                current_blob_size = 0
                blob_cells = [] # Store coordinates to calculate bbox later
                
                min_r, max_r = r, r
                min_c, max_c = c, c

                while q:
                    row, col = q.popleft()
                    
                    # This cell is part of the current blob
                    blob_cells.append((row, col))
                    current_blob_size += 1 # Count only non-zero cells for size comparison
                    
                    # Update bounding box for this cell
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    min_c = min(min_c, col)
                    max_c = max(max_c, col)

                    # Explore neighbors (4-connectivity)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc

                        # Check bounds and if neighbor is non-zero and not visited
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] != 0 and not visited[nr, nc]:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                # Finished exploring this blob, compare its size
                if current_blob_size > max_blob_size:
                    max_blob_size = current_blob_size
                    best_bbox = (min_r, max_r, min_c, max_c)
                    
    # Handle edge case where no non-zero cells were found
    if max_blob_size == -1 and rows > 0 and cols > 0:
         return (0, 0, 0, 0) # Or perhaps signal an error / empty output? Examples suggest non-empty. Let's assume valid input. If grid IS all zero, what should happen? Let's assume input guarantees at least one non-zero blob if output is expected. If the largest blob is just one cell, bbox is (r,r,c,c).
    elif max_blob_size == -1: # Empty grid case
        return (0, -1, 0, -1) # Indices that lead to empty slice


    return best_bbox


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by extracting the bounding box of the largest
    connected non-zero blob.
    """
    # Handle empty input case
    if not input_grid or not input_grid[0]:
        return []

    # Convert to numpy array for easier processing
    grid_np = np.array(input_grid, dtype=int)

    # Find the bounding box of the largest blob
    min_row, max_row, min_col, max_col = _find_largest_blob_and_bbox(grid_np)

    # Handle case where no blob was found (e.g., all zeros or empty grid result from helper)
    if max_row < min_row or max_col < min_col:
         # This case needs clarification based on requirements for all-zero inputs.
         # Based on examples, we expect a non-empty output, suggesting inputs have blobs.
         # If an all-zero input IS possible, returning empty list might be appropriate.
         return [] 

    # Extract the subgrid defined by the bounding box
    # Note: slicing includes start index but excludes end index, so add 1 to max indices
    output_grid_np = grid_np[min_row : max_row + 1, min_col : max_col + 1]

    # Convert the resulting numpy array back to a list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
