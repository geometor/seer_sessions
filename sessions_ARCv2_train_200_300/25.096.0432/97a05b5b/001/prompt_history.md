
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0
0 2 2 0 2 2 2 2 2 0
0 2 0 0 0 2 2 2 2 0
0 2 2 2 2 2 2 2 2 0
0 2 2 2 2 0 0 2 2 0
0 2 2 2 2 0 2 0 2 0
0 2 2 2 2 2 0 0 2 0
0 2 2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 4 2 4 0 0 0 0 0 0
0 2 2 4 0 0 0 0 0 0
0 4 2 4 0 2 2 3 0 0
0 0 0 0 0 2 3 2 0 0
0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2
2 4 2 4 2 2 2 2
2 2 2 2 2 2 2 2
2 4 4 4 2 2 2 2
2 2 2 2 2 2 3 2
2 2 2 2 2 3 2 2
2 2 2 2 3 2 2 2
2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 0 0 2 2 2 2 0 2 0 0 2 2 2 0 0 0
0 0 2 2 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 0 0 0 2 2 2 0 0 0 2 2 2 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 2 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 8 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 4 4 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 4 2 4 0 0 2 2 2 0 0 0 0 0 0 0 0
0 0 0 2 2 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 4 4 2 2 3 2 3
2 2 2 4 2 2 3 2 3
2 4 4 4 2 2 3 2 3
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
8 2 2 2 2 5 2 5 2
8 8 2 2 2 5 2 5 2
8 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 0 0 0 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```

Okay, let's analyze the task based on the provided examples.

**Perception of Elements:**

1.  **Input/Output Data:** Both inputs and outputs are 2D grids (matrices) containing single-digit integers. The number 0 appears to represent a background or empty space.
2.  **Structure:** The input grids contain one or more distinct "islands" or "blobs" of non-zero numbers, separated by the background color 0.
3.  **Transformation:** The output grid seems to be a sub-grid extracted from the input grid. Specifically, it corresponds to one of the non-zero blobs found in the input.
4.  **Selection Criteria:** By comparing the blobs in the input to the output across the examples:
    *   In `train_1`, the top blob is selected, which is larger than the bottom blob.
    *   In `train_2`, the large, complex blob starting near the top-left is selected, which is significantly larger than the other smaller blobs (containing 1s, 3s, 8s, 4s, 5s).
    *   In `train_3`, the second, larger blob (mostly 2s) is selected, not the smaller first blob (with 8s).
    *   This suggests the rule is to identify the *largest* connected region (blob) of non-zero cells in the input grid. "Largest" most likely refers to the total count of non-zero cells within the blob.
5.  **Extraction Method:** Once the largest blob is identified, the output grid is formed by taking the rectangular bounding box that minimally encloses this largest blob within the input grid. All cells within this bounding box, including any original 0s inside it, are included in the output.

**YAML Facts:**


```yaml
task_type: grid_transformation
input_features:
  - type: grid
  - element_type: integer
  - background_color: 0
  - contains_multiple_objects: true
output_features:
  - type: grid
  - element_type: integer
objects:
  - name: blob
    definition: A connected region of non-zero cells in the input grid.
    connectivity: Assumed 4-connectivity (up, down, left, right neighbours).
    properties:
      - size: The count of non-zero cells in the blob.
      - bounding_box: The minimum rectangle (min_row, max_row, min_col, max_col) enclosing the blob.
relationships:
  - type: selection
    subject: blob
    criteria: The blob with the maximum size (largest count of non-zero cells).
actions:
  - name: identify_blobs
    description: Find all distinct connected regions of non-zero cells in the input grid.
  - name: calculate_blob_size
    description: Count the number of non-zero cells for each identified blob.
  - name: find_largest_blob
    description: Select the blob with the highest cell count. Resolve ties arbitrarily if necessary (though not observed in examples).
  - name: determine_bounding_box
    description: Find the minimum and maximum row and column indices for the selected largest blob.
  - name: extract_subgrid
    description: Create the output grid by copying the portion of the input grid defined by the bounding box of the largest blob.
```


**Natural Language Program:**

1.  Identify all separate connected regions (blobs) of non-zero numbers in the input grid. Assume connectivity means sharing an edge (up, down, left, or right).
2.  For each blob, calculate its size by counting the number of non-zero cells it contains.
3.  Determine which blob has the largest size. If there is a tie, the specific tie-breaking rule is not definitively shown, but selecting the first one encountered (e.g., scanning top-to-bottom, left-to-right) is a plausible default.
4.  Find the minimum bounding box of this largest blob (the smallest rectangle containing all its cells). This is defined by the minimum row, maximum row, minimum column, and maximum column occupied by the blob's cells.
5.  Extract the sub-grid from the input corresponding to this bounding box. The output is this extracted rectangular section, including any original zero values that fall within the bounding box.
