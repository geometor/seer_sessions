{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid by identifying four quadrants separated by the largest\ncontiguous horizontal and vertical bands of zeros. It then selects one quadrant\nbased on the distribution of non-zero numbers.\n\nSelection Rules:\n1. Identify non-zero numbers unique to a single quadrant.\n2. If unique numbers exist, select the quadrant containing the maximum unique number.\n3. If no numbers are unique to one quadrant, find the overall maximum non-zero\n   number (M) across all quadrants.\n4. Select the quadrant containing M based on priority: Bottom-Right (BR) >\n   Bottom-Left (BL) > Top-Right (TR) > Top-Left (TL).\n\"\"\"\n\ndef find_largest_zero_band_rows(grid: np.ndarray):\n    \"\"\"\n    Finds the start and end row indices of the largest contiguous block of\n    all-zero rows.\n    Returns tuple (start_index, end_index).\n    Raises ValueError if no all-zero row is found.\n    \"\"\"\n    num_rows, _ = grid.shape\n    max_len = 0\n    best_start, best_end = -1, -1\n    current_start, current_len = -1, 0\n\n    for r in range(num_rows):\n        # Check if the entire row is zero\n        if np.all(grid[r, :] == 0):\n            if current_len == 0: # Start of a new potential band\n                current_start = r\n            current_len += 1\n        else: # End of the current zero band (or not in one)\n            if current_len > max_len: # Check if the ended band was the largest so far\n                max_len = current_len\n                best_start = current_start\n                best_end = r - 1\n            current_len = 0 # Reset length for the next potential band\n\n    # After loop, check if the grid ended with the longest zero band\n    if current_len > max_len:\n        # max_len = current_len # Not strictly needed to update max_len here\n        best_start = current_start\n        best_end = num_rows - 1\n\n    # If no zero row was ever found, best_start remains -1\n    if best_start == -1:\n         raise ValueError(\"No horizontal zero band found.\")\n\n    return best_start, best_end\n\ndef find_largest_zero_band_cols(grid: np.ndarray):\n    \"\"\"\n    Finds the start and end column indices of the largest contiguous block of\n    all-zero columns.\n    Returns tuple (start_index, end_index).\n    Raises ValueError if no all-zero column is found.\n    \"\"\"\n    _, num_cols = grid.shape\n    max_len = 0\n    best_start, best_end = -1, -1\n    current_start, current_len = -1, 0\n\n    for c in range(num_cols):\n         # Check if the entire column is zero\n        if np.all(grid[:, c] == 0):\n            if current_len == 0: # Start of a new potential band\n                current_start = c\n            current_len += 1\n        else: # End of the current zero band (or not in one)\n            if current_len > max_len: # Check if the ended band was the largest so far\n                max_len = current_len\n                best_start = current_start\n                best_end = c - 1\n            current_len = 0 # Reset length for the next potential band\n\n    # After loop, check if the grid ended with the longest zero band\n    if current_len > max_len:\n        # max_len = current_len # Not strictly needed\n        best_start = current_start\n        best_end = num_cols - 1\n\n    # If no zero column was ever found, best_start remains -1\n    if best_start == -1:\n         raise ValueError(\"No vertical zero band found.\")\n\n    return best_start, best_end\n\ndef get_unique_non_zeros(subgrid: np.ndarray) -> set:\n    \"\"\"\n    Extracts the set of unique non-zero values from a subgrid (NumPy array).\n    Returns an empty set if the subgrid is empty or contains only zeros.\n    \"\"\"\n    # Return empty set immediately if subgrid has no elements\n    if subgrid.size == 0:\n        return set()\n    # Find unique values in the flattened subgrid\n    unique_vals = np.unique(subgrid)\n    # Filter out zero and return the set of non-zero unique values\n    return set(val for val in unique_vals if val != 0)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    num_rows, num_cols = grid.shape\n\n    # Handle empty input grid\n    if num_rows == 0 or num_cols == 0:\n        return []\n\n    # Find the largest horizontal and vertical zero bands\n    try:\n        hr_start, hr_end = find_largest_zero_band_rows(grid)\n        vc_start, vc_end = find_largest_zero_band_cols(grid)\n    except ValueError as e:\n        # If the expected zero bands are not found, the grid structure is invalid\n        # for this transformation. Return empty list.\n        print(f\"Error: Could not find required zero bands - {e}\")\n        return []\n\n    # Define the four quadrants using NumPy slicing based on band indices\n    # Note: Slicing `[a:b]` includes `a` up to `b-1`.\n    # Note: `vc_end + 1` and `hr_end + 1` give the start of the next section.\n    tl_quad = grid[0:hr_start, 0:vc_start]\n    tr_quad = grid[0:hr_start, vc_end + 1 : num_cols]\n    bl_quad = grid[hr_end + 1 : num_rows, 0:vc_start]\n    br_quad = grid[hr_end + 1 : num_rows, vc_end + 1 : num_cols]\n\n    # Store quadrants and their names for easier access\n    quadrants = {\n        \"TL\": tl_quad, \"TR\": tr_quad,\n        \"BL\": bl_quad, \"BR\": br_quad\n    }\n\n    # Get the set of unique non-zero numbers within each quadrant\n    quadrant_non_zeros = {name: get_unique_non_zeros(q) for name, q in quadrants.items()}\n\n    # Collect all unique non-zero values present across all quadrants\n    all_non_zeros = set().union(*quadrant_non_zeros.values())\n\n    # If no non-zero numbers exist in any quadrant, return an empty list.\n    if not all_non_zeros:\n        # This could happen if quadrants are empty or contain only zeros.\n        return []\n\n    # Determine which non-zero values are unique to a single quadrant\n    value_locations = {} # Dictionary mapping value -> list of quadrant names\n    for val in all_non_zeros:\n        locations = []\n        for name, non_zeros_set in quadrant_non_zeros.items():\n            if val in non_zeros_set:\n                locations.append(name)\n        value_locations[val] = locations\n\n    # Find values that appear in exactly one quadrant\n    unique_values = {val: locs[0] for val, locs in value_locations.items() if len(locs) == 1}\n\n    selected_quad_name = None\n\n    # --- Selection Logic ---\n    if unique_values:\n        # Rule 1: If unique values exist, find the maximum among them\n        max_unique_val = max(unique_values.keys())\n        # The selected quadrant is the one containing this max unique value\n        selected_quad_name = unique_values[max_unique_val]\n    else:\n        # Rule 2: If no unique values, find the overall maximum non-zero value (M)\n        M = max("
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4418,
    "candidates_token_count": 8190,
    "total_token_count": 12608,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 74.485475,
  "retries": 1
}