
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples to understand the transformation logic.

**Perception of Elements:**

1.  **Input/Output Structure:** Both input and output are 2D grids (matrices) of integers.
2.  **Grid Contents:** The grids primarily contain the number 0, representing a background. Non-zero numbers (1, 2, 3, 4, 5, 7, 8) are sparsely distributed.
3.  **Key Feature - Axis:** A distinct feature is the presence of lines (rows or columns) composed entirely of the number 4. These lines act as axes or separators.
    *   In `train_1`, there is a horizontal line of 4s.
    *   In `train_2`, there is both a horizontal line and a vertical line of 4s.
4.  **Transformation Pattern:** The transformation seems to involve rearranging sections of the grid relative to these axes of 4s.
    *   In `train_1` (horizontal axis only): The content *above* the axis in the input appears *below* the axis in the output, and the content *below* the axis in the input appears *above* the axis in the output. The axis itself remains unchanged. This is effectively a swap of the regions across the horizontal axis.
    *   In `train_2` (horizontal and vertical axes): The grid is divided into four quadrants by the axes. The transformation swaps diagonally opposite quadrants. The Top-Left quadrant swaps with the Bottom-Right, and the Top-Right quadrant swaps with the Bottom-Left. The axes themselves remain unchanged.

**YAML Facts:**


```yaml
task_elements:
  - element: grid
    description: A 2D array of integers representing the input and output state.
    properties:
      - dimensions: [rows, columns]
      - values: integers, with 0 as background and other integers (like 1, 2, 3, 4, 5, 7, 8) as foreground elements.
  - element: axis
    description: A line (row or column) within the grid composed entirely of the integer 4. Acts as a reference for transformation.
    properties:
      - type: 'horizontal' or 'vertical'
      - index: The row or column index of the axis.
      - identifier_value: 4
    relationships:
      - divides: the grid into regions (e.g., upper/lower, left/right) or quadrants.
  - element: region
    description: A contiguous section of the grid defined relative to an axis.
    properties:
      - location: 'upper', 'lower', 'left', 'right' relative to the axis.
    relationships:
      - defined_by: axis
  - element: quadrant
    description: A section of the grid defined by the intersection of a horizontal and a vertical axis.
    properties:
      - location: 'top_left', 'top_right', 'bottom_left', 'bottom_right' relative to the intersection point.
    relationships:
      - defined_by: horizontal_axis, vertical_axis
actions:
  - action: identify_axes
    description: Scan the input grid to find rows and columns composed entirely of the number 4.
    inputs: input_grid
    outputs: horizontal_axis_index (if found), vertical_axis_index (if found)
  - action: swap_regions
    description: Exchange the positions of regions across a single axis.
    condition: Only one axis (horizontal or vertical) is present.
    inputs: input_grid, axis_index, axis_type
    outputs: modified_grid
  - action: swap_quadrants
    description: Exchange the positions of diagonally opposite quadrants defined by two axes.
    condition: Both horizontal and vertical axes are present.
    inputs: input_grid, horizontal_axis_index, vertical_axis_index
    outputs: modified_grid
  - action: copy_axis
    description: Ensure the axis line(s) remain unchanged in the output grid.
    inputs: input_grid, axis_index(es)
    outputs: axis line(s) in the output_grid
```


**Natural Language Program:**

1.  Receive the input grid.
2.  Determine the dimensions (number of rows and columns) of the input grid.
3.  Scan the input grid to locate a horizontal axis: a row where all elements are 4. Record its row index if found.
4.  Scan the input grid to locate a vertical axis: a column where all elements are 4. Record its column index if found.
5.  Create an output grid of the same dimensions as the input grid.
6.  **Scenario 1: Both a horizontal axis (at row `h`) and a vertical axis (at column `v`) are found:**
    a.  Copy the horizontal axis row `h` from the input to the output grid at row `h`.
    b.  Copy the vertical axis column `v` from the input to the output grid at column `v`.
    c.  Copy the input grid's Top-Left quadrant (rows `< h`, cols `< v`) to the output grid's Bottom-Right quadrant (rows `> h`, cols `> v`).
    d.  Copy the input grid's Top-Right quadrant (rows `< h`, cols `> v`) to the output grid's Bottom-Left quadrant (rows `> h`, cols `< v`).
    e.  Copy the input grid's Bottom-Left quadrant (rows `> h`, cols `< v`) to the output grid's Top-Right quadrant (rows `< h`, cols `> v`).
    f.  Copy the input grid's Bottom-Right quadrant (rows `> h`, cols `> v`) to the output grid's Top-Left quadrant (rows `< h`, cols `< v`).
7.  **Scenario 2: Only a horizontal axis (at row `h`) is found:**
    a.  Copy the horizontal axis row `h` from the input to the output grid at row `h`.
    b.  Copy the input grid's upper region (all rows `< h`) to the output grid's lower region (all rows `> h`).
    c.  Copy the input grid's lower region (all rows `> h`) to the output grid's upper region (all rows `< h`).
8.  **Scenario 3: Only a vertical axis (at column `v`) is found:** (Inferred logical case)
    a.  Copy the vertical axis column `v` from the input to the output grid at column `v`.
    b.  Copy the input grid's left region (all cols `< v`) to the output grid's right region (all cols `> v`).
    c.  Copy the input grid's right region (all cols `> v`) to the output grid's left region (all cols `< v`).
9.  Return the completed output grid.
```python
import numpy as np
from typing import List, Optional, Tuple

"""
Transforms an input grid based on the presence and location of axes marked by the number 4.

1.  Identifies horizontal and/or vertical axes (rows/columns filled entirely with 4s).
2.  If both a horizontal (at row `h`) and vertical (at column `v`) axis exist:
    - The grid is divided into four quadrants by these axes.
    - The transformation swaps diagonally opposite quadrants:
        - Top-Left swaps with Bottom-Right.
        - Top-Right swaps with Bottom-Left.
    - The axes themselves remain unchanged.
3.  If only a horizontal axis (at row `h`) exists:
    - The transformation swaps the region above the axis with the region below the axis.
    - The axis itself remains unchanged.
4.  If only a vertical axis (at column `v`) exists:
    - The transformation swaps the region to the left of the axis with the region to the right of the axis.
    - The axis itself remains unchanged.
5.  If no axis is found, the grid remains unchanged.
"""

def find_horizontal_axis(grid: np.ndarray) -> Optional[int]:
    """Finds the row index of a horizontal axis (all 4s)."""
    rows, _ = grid.shape
    for r in range(rows):
        if np.all(grid[r, :] == 4):
            return r
    return None

def find_vertical_axis(grid: np.ndarray) -> Optional[int]:
    """Finds the column index of a vertical axis (all 4s)."""
    _, cols = grid.shape
    for c in range(cols):
        if np.all(grid[:, c] == 4):
            return c
    return None

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the transformation rule based on identified axes of 4s.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape

    # Initialize output grid as a copy first (handles cases with no axes)
    output_np = np.copy(input_np)

    # Find axes
    h_axis_idx = find_horizontal_axis(input_np)
    v_axis_idx = find_vertical_axis(input_np)

    # Scenario 1: Both horizontal and vertical axes found
    if h_axis_idx is not None and v_axis_idx is not None:
        h = h_axis_idx
        v = v_axis_idx
        # Create a zero-initialized grid to place swapped quadrants
        # This avoids overwriting parts needed for later swaps if done in-place on a copy
        temp_output_np = np.zeros_like(input_np)

        # Copy axes to the temp output
        temp_output_np[h, :] = input_np[h, :]
        temp_output_np[:, v] = input_np[:, v]

        # Swap quadrants
        # Input Top-Left -> Output Bottom-Right
        if h > 0 and v > 0 and h + 1 < rows and v + 1 < cols:
             temp_output_np[h+1:, v+1:] = input_np[:h, :v]
        # Input Top-Right -> Output Bottom-Left
        if h > 0 and v + 1 < cols and h + 1 < rows and v > 0:
            temp_output_np[h+1:, :v] = input_np[:h, v+1:]
        # Input Bottom-Left -> Output Top-Right
        if h + 1 < rows and v > 0 and h > 0 and v + 1 < cols:
            temp_output_np[:h, v+1:] = input_np[h+1:, :v]
        # Input Bottom-Right -> Output Top-Left
        if h + 1 < rows and v + 1 < cols and h > 0 and v > 0:
             temp_output_np[:h, :v] = input_np[h+1:, v+1:]
             
        # Handle edge cases where quadrants might touch the grid boundary directly
        # (e.g., h=0 or v=0 or h=rows-1 or v=cols-1)
        # The slicing logic generally handles these, but explicit checks can clarify
        # Example: If h=0, input[:h, ...] is empty, which is correct.
        # Example: If h=rows-1, input[h+1:, ...] is empty, which is correct.

        output_np = temp_output_np # Assign the result

    # Scenario 2: Only horizontal axis found
    elif h_axis_idx is not None:
        h = h_axis_idx
        # Create a zero-initialized grid
        temp_output_np = np.zeros_like(input_np)
        
        # Copy the axis
        temp_output_np[h, :] = input_np[h, :]

        # Swap upper and lower regions
        # Input Upper -> Output Lower
        if h > 0 and h + 1 < rows:
             temp_output_np[h+1:, :] = input_np[:h, :]
        # Input Lower -> Output Upper
        if h + 1 < rows and h > 0:
            temp_output_np[:h, :] = input_np[h+1:, :]
            
        output_np = temp_output_np

    # Scenario 3: Only vertical axis found
    elif v_axis_idx is not None:
        v = v_axis_idx
        # Create a zero-initialized grid
        temp_output_np = np.zeros_like(input_np)
        
        # Copy the axis
        temp_output_np[:, v] = input_np[:, v]

        # Swap left and right regions
        # Input Left -> Output Right
        if v > 0 and v + 1 < cols:
            temp_output_np[:, v+1:] = input_np[:, :v]
        # Input Right -> Output Left
        if v + 1 < cols and v > 0:
            temp_output_np[:, :v] = input_np[:, v+1:]

        output_np = temp_output_np

    # Scenario 4: No axis found - output_np remains the initial copy of input_np

    # Convert final numpy array back to list of lists
    return output_np.tolist()
```
```python
import numpy as np
from typing import List, Optional, Tuple

"""
Transforms an input grid based on the presence and location of axes marked by the number 4.

The transformation rule depends on the number of axes found:

1.  **Identify Axes:** Locate a horizontal axis (row `h` where all elements are 4) and/or a vertical axis (column `v` where all elements are 4).

2.  **Transformation Logic:**
    *   **No Axes Found:** The output grid is identical to the input grid.
    *   **Only Horizontal Axis `h` Found:** The content from the upper region (rows < h) of the input is moved to the lower region (rows > h) of the output. The axis row `h` is copied. All other cells in the output are 0.
    *   **Only Vertical Axis `v` Found:** The content from the left region (cols < v) of the input is moved to the right region (cols > v) of the output. The axis column `v` is copied. All other cells in the output are 0. (This case is inferred by symmetry but not explicitly shown in examples).
    *   **Both Horizontal Axis `h` and Vertical Axis `v` Found:** The grid is divided into four quadrants. The transformation swaps diagonally opposite quadrants: Top-Left swaps with Bottom-Right, and Top-Right swaps with Bottom-Left. The axis row `h` and axis column `v` are copied.

3.  **Output:** Return the transformed grid.
"""

def find_horizontal_axis(grid: np.ndarray) -> Optional[int]:
    """Finds the row index of a horizontal axis (all 4s)."""
    rows, _ = grid.shape
    for r in range(rows):
        if np.all(grid[r, :] == 4):
            return r
    return None

def find_vertical_axis(grid: np.ndarray) -> Optional[int]:
    """Finds the column index of a vertical axis (all 4s)."""
    _, cols = grid.shape
    for c in range(cols):
        if np.all(grid[:, c] == 4):
            return c
    return None

def transform(input_grid: List[List[int]]) -> List[List[int]]:
    """
    Applies the transformation rule based on identified axes of 4s.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    rows, cols = input_np.shape

    # Find axes
    h_axis_idx = find_horizontal_axis(input_np)
    v_axis_idx = find_vertical_axis(input_np)

    # Case 4: No axes found - return input unchanged
    if h_axis_idx is None and v_axis_idx is None:
        return input_grid

    # Initialize output grid with zeros for transformation cases
    output_np = np.zeros_like(input_np)

    # Case 1: Both horizontal and vertical axes found (Swap Quadrants)
    if h_axis_idx is not None and v_axis_idx is not None:
        h = h_axis_idx
        v = v_axis_idx

        # Copy axes to the output
        output_np[h, :] = input_np[h, :]
        output_np[:, v] = input_np[:, v] # Note: Intersection point input_np[h,v] is copied twice, which is fine as it's 4.

        # Swap quadrants (copying from input to output's swapped location)
        # Input Top-Left -> Output Bottom-Right
        if h > 0 and v > 0 and h + 1 < rows and v + 1 < cols:
             output_np[h+1:, v+1:] = input_np[:h, :v]
        # Input Top-Right -> Output Bottom-Left
        if h > 0 and v + 1 < cols and h + 1 < rows and v > 0:
            output_np[h+1:, :v] = input_np[:h, v+1:]
        # Input Bottom-Left -> Output Top-Right
        if h + 1 < rows and v > 0 and h > 0 and v + 1 < cols:
            output_np[:h, v+1:] = input_np[h+1:, :v]
        # Input Bottom-Right -> Output Top-Left
        if h + 1 < rows and v + 1 < cols and h > 0 and v > 0:
             output_np[:h, :v] = input_np[h+1:, v+1:]

    # Case 2: Only horizontal axis found (Move Upper to Lower)
    elif h_axis_idx is not None:
        h = h_axis_idx

        # Copy the axis
        output_np[h, :] = input_np[h, :]

        # Move upper region to lower region
        # Input Upper -> Output Lower
        if h > 0 and h + 1 < rows:
             output_np[h+1:, :] = input_np[:h, :]
        # The original upper region and non-axis parts of lower region remain 0

    # Case 3: Only vertical axis found (Move Left to Right)
    elif v_axis_idx is not None:
        v = v_axis_idx

        # Copy the axis
        output_np[:, v] = input_np[:, v]

        # Move left region to right region
        # Input Left -> Output Right
        if v > 0 and v + 1 < cols:
            output_np[:, v+1:] = input_np[:, :v]
        # The original left region and non-axis parts of right region remain 0

    # Convert final numpy array back to list of lists
    return output_np.tolist()
```
