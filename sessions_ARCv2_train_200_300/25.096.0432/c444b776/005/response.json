{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Optional\n\n\"\"\"\nTransforms an input grid based on the presence and location of axes marked by the number 4.\n\nThe transformation rule depends on the axes found:\n1. No Axes: Output is identical to input.\n2. Horizontal Axis Only (at row h): The region above the axis in the input is copied to both the region above and the region below the axis in the output. The axis itself is copied. Other areas remain 0.\n3. Vertical Axis Only (at column v): The region left of the axis in the input is copied to both the region left and the region right of the axis in the output. The axis itself is copied. Other areas remain 0.\n4. Both Axes (at row h, column v): \n   - Input Top-Left quadrant is copied to Output Top-Left.\n   - Input Bottom-Left quadrant is copied to Output Bottom-Left.\n   - Input Bottom-Left quadrant is copied to Output Top-Right.\n   - Output Bottom-Right quadrant remains 0.\n   - Both axes are copied.\n\"\"\"\n\n\ndef find_horizontal_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the row index of a horizontal axis (all 4s). Returns None if not found.\"\"\"\n    rows, _ = grid.shape\n    for r in range(rows):\n        # Check if all elements in the row are equal to 4\n        if np.all(grid[r, :] == 4):\n            return r\n    return None\n\ndef find_vertical_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the column index of a vertical axis (all 4s). Returns None if not found.\"\"\"\n    _, cols = grid.shape\n    for c in range(cols):\n        # Check if all elements in the column are equal to 4\n        if np.all(grid[:, c] == 4):\n            return c\n    return None\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the transformation rule based on identified axes of 4s.\"\"\"\n\n    # Convert input list of lists to a numpy array for efficient slicing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Locate the horizontal and vertical axes\n    h_axis_idx = find_horizontal_axis(input_np)\n    v_axis_idx = find_vertical_axis(input_np)\n\n    # Scenario 1: No axes found\n    if h_axis_idx is None and v_axis_idx is None:\n        # If no axes are present, return the input grid unchanged\n        return input_grid\n\n    # Initialize the output grid with zeros, same shape as input\n    output_np = np.zeros_like(input_np)\n\n    # Scenario 4: Both horizontal and vertical axes found\n    if h_axis_idx is not None and v_axis_idx is not None:\n        h = h_axis_idx\n        v = v_axis_idx\n\n        # Copy the horizontal and vertical axes from input to output\n        output_np[h, :] = input_np[h, :]\n        output_np[:, v] = input_np[:, v] # Note: The intersection cell input_np[h, v] = 4 is copied twice, which is correct.\n\n        # Define source quadrants based on input grid slices\n        # Top-Left quadrant of input\n        source_tl = input_np[0:h, 0:v]\n        # Bottom-Left quadrant of input\n        source_bl = input_np[h+1:rows, 0:v]\n\n        # Perform the quadrant copies/fills based on the rule\n        # Copy Input Top-Left -> Output Top-Left\n        if source_tl.size > 0:  # Check ensures the quadrant exists (h>0 and v>0)\n             output_np[0:h, 0:v] = source_tl\n        # Copy Input Bottom-Left -> Output Bottom-Left\n        if source_bl.size > 0: # Check ensures the quadrant exists (h+1<rows and v>0)\n            output_np[h+1:rows, 0:v] = source_bl\n        # Copy Input Bottom-Left -> Output Top-Right\n        if source_bl.size > 0: # Check ensures source exists\n            if h > 0 and v + 1 < cols: # Check ensures target Top-Right exists\n                 output_np[0:h, v+1:cols] = source_bl\n        # Output Bottom-Right remains zeros (as initialized)\n\n    # Scenario 2: Only horizontal axis found\n    elif h_axis_idx is not None:\n        h = h_axis_idx\n\n        # Copy the horizontal axis from input to output\n        output_np[h, :] = input_np[h, :]\n\n        # Define the source region (area above the axis in the input)\n        source_upper = input_np[0:h, :]\n\n        # Copy the source region to the upper and lower regions of the output\n        if source_upper.size > 0: # Check ensures upper region exists (h>0)\n            # Copy to Output Upper region\n            output_np[0:h, :] = source_upper\n            # Copy to Output Lower region (if it exists)\n            if h + 1 < rows: # Check ensures lower region exists\n                 output_np[h+1:rows, :] = source_upper\n\n    # Scenario 3: Only vertical axis found\n    elif v_axis_idx is not None:\n        v = v_axis_idx\n\n        # Copy the vertical axis from input to output\n        output_np[:, v] = input_np[:, v]\n\n        # Define the source region (area left of the axis in the input)\n        source_left = input_np[:, 0:v]\n\n        # Copy the source region to the left and right regions of the output\n        if source_left.size > 0: # Check ensures left region exists (v>0)\n            # Copy to Output Left region\n            output_np[:, 0:v] = source_left\n            # Copy to Output Right region (if it exists)\n            if v + 1 < cols: # Check ensures right region exists\n                output_np[:, v+1:cols] = source_left\n\n    # Convert the final numpy array back to a list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14027,
    "candidates_token_count": 3822,
    "total_token_count": 17849,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.834897,
  "retries": 1
}