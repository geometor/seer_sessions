{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Optional, Tuple\n\n\"\"\"\nTransforms an input grid based on the presence and location of axes marked by the number 4.\n\n1.  Identifies horizontal and/or vertical axes (rows/columns filled entirely with 4s).\n2.  If both a horizontal (at row `h`) and vertical (at column `v`) axis exist:\n    - The grid is divided into four quadrants by these axes.\n    - The transformation swaps diagonally opposite quadrants:\n        - Top-Left swaps with Bottom-Right.\n        - Top-Right swaps with Bottom-Left.\n    - The axes themselves remain unchanged.\n3.  If only a horizontal axis (at row `h`) exists:\n    - The transformation swaps the region above the axis with the region below the axis.\n    - The axis itself remains unchanged.\n4.  If only a vertical axis (at column `v`) exists:\n    - The transformation swaps the region to the left of the axis with the region to the right of the axis.\n    - The axis itself remains unchanged.\n5.  If no axis is found, the grid remains unchanged.\n\"\"\"\n\ndef find_horizontal_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the row index of a horizontal axis (all 4s).\"\"\"\n    rows, _ = grid.shape\n    for r in range(rows):\n        if np.all(grid[r, :] == 4):\n            return r\n    return None\n\ndef find_vertical_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the column index of a vertical axis (all 4s).\"\"\"\n    _, cols = grid.shape\n    for c in range(cols):\n        if np.all(grid[:, c] == 4):\n            return c\n    return None\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule based on identified axes of 4s.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Initialize output grid as a copy first (handles cases with no axes)\n    output_np = np.copy(input_np)\n\n    # Find axes\n    h_axis_idx = find_horizontal_axis(input_np)\n    v_axis_idx = find_vertical_axis(input_np)\n\n    # Scenario 1: Both horizontal and vertical axes found\n    if h_axis_idx is not None and v_axis_idx is not None:\n        h = h_axis_idx\n        v = v_axis_idx\n        # Create a zero-initialized grid to place swapped quadrants\n        # This avoids overwriting parts needed for later swaps if done in-place on a copy\n        temp_output_np = np.zeros_like(input_np)\n\n        # Copy axes to the temp output\n        temp_output_np[h, :] = input_np[h, :]\n        temp_output_np[:, v] = input_np[:, v]\n\n        # Swap quadrants\n        # Input Top-Left -> Output Bottom-Right\n        if h > 0 and v > 0 and h + 1 < rows and v + 1 < cols:\n             temp_output_np[h+1:, v+1:] = input_np[:h, :v]\n        # Input Top-Right -> Output Bottom-Left\n        if h > 0 and v + 1 < cols and h + 1 < rows and v > 0:\n            temp_output_np[h+1:, :v] = input_np[:h, v+1:]\n        # Input Bottom-Left -> Output Top-Right\n        if h + 1 < rows and v > 0 and h > 0 and v + 1 < cols:\n            temp_output_np[:h, v+1:] = input_np[h+1:, :v]\n        # Input Bottom-Right -> Output Top-Left\n        if h + 1 < rows and v + 1 < cols and h > 0 and v > 0:\n             temp_output_np[:h, :v] = input_np[h+1:, v+1:]\n             \n        # Handle edge cases where quadrants might touch the grid boundary directly\n        # (e.g., h=0 or v=0 or h=rows-1 or v=cols-1)\n        # The slicing logic generally handles these, but explicit checks can clarify\n        # Example: If h=0, input[:h, ...] is empty, which is correct.\n        # Example: If h=rows-1, input[h+1:, ...] is empty, which is correct.\n\n        output_np = temp_output_np # Assign the result\n\n    # Scenario 2: Only horizontal axis found\n    elif h_axis_idx is not None:\n        h = h_axis_idx\n        # Create a zero-initialized grid\n        temp_output_np = np.zeros_like(input_np)\n        \n        # Copy the axis\n        temp_output_np[h, :] = input_np[h, :]\n\n        # Swap upper and lower regions\n        # Input Upper -> Output Lower\n        if h > 0 and h + 1 < rows:\n             temp_output_np[h+1:, :] = input_np[:h, :]\n        # Input Lower -> Output Upper\n        if h + 1 < rows and h > 0:\n            temp_output_np[:h, :] = input_np[h+1:, :]\n            \n        output_np = temp_output_np\n\n    # Scenario 3: Only vertical axis found\n    elif v_axis_idx is not None:\n        v = v_axis_idx\n        # Create a zero-initialized grid\n        temp_output_np = np.zeros_like(input_np)\n        \n        # Copy the axis\n        temp_output_np[:, v] = input_np[:, v]\n\n        # Swap left and right regions\n        # Input Left -> Output Right\n        if v > 0 and v + 1 < cols:\n            temp_output_np[:, v+1:] = input_np[:, :v]\n        # Input Right -> Output Left\n        if v + 1 < cols and v > 0:\n            temp_output_np[:, :v] = input_np[:, v+1:]\n\n        output_np = temp_output_np\n\n    # Scenario 4: No axis found - output_np remains the initial copy of input_np\n\n    # Convert final numpy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4100,
    "candidates_token_count": 1933,
    "total_token_count": 6033,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.58259,
  "retries": 1
}