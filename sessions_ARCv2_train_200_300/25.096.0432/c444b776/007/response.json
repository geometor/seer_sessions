{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Optional\n\n\"\"\"\nTransforms an input grid based on the presence and location of axes marked by the number 4.\n\nThe transformation rule depends on the axes found:\n1. No Axes: Output is identical to input.\n2. Horizontal Axis Only (at row h): The region above the axis in the input is copied to both the region above and the region below the axis in the output. The axis itself is copied. Other areas remain 0.\n3. Vertical Axis Only (at column v): The region left of the axis in the input is copied to both the region left and the region right of the axis in the output. The axis itself is copied. Other areas remain 0.\n4. Both Axes (at row h, column v): \n   - Input Top-Left (TL) quadrant is copied to Output Top-Left (TL).\n   - Input Bottom-Left (BL) quadrant is copied to Output Top-Right (TR).\n   - Input Top-Left (TL) quadrant is copied to Output Bottom-Left (BL).\n   - Input Bottom-Right (BR) quadrant is copied to Output Bottom-Right (BR).\n   - Both axes are copied.\n\"\"\"\n\ndef find_horizontal_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the row index of a horizontal axis (all 4s). Returns None if not found.\"\"\"\n    rows, _ = grid.shape\n    for r in range(rows):\n        # Check if all elements in the row are equal to 4\n        if np.all(grid[r, :] == 4):\n            return r\n    return None\n\ndef find_vertical_axis(grid: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the column index of a vertical axis (all 4s). Returns None if not found.\"\"\"\n    _, cols = grid.shape\n    for c in range(cols):\n        # Check if all elements in the column are equal to 4\n        if np.all(grid[:, c] == 4):\n            return c\n    return None\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Applies the transformation rule based on identified axes of 4s.\"\"\"\n\n    # Convert input list of lists to a numpy array for efficient slicing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Locate the horizontal and vertical axes\n    h_axis_idx = find_horizontal_axis(input_np)\n    v_axis_idx = find_vertical_axis(input_np)\n\n    # Case 1: No axes found\n    if h_axis_idx is None and v_axis_idx is None:\n        # If no axes are present, return the input grid unchanged\n        return input_grid\n\n    # Initialize the output grid with zeros, same shape as input\n    # This is done for all cases where transformation occurs (axes found)\n    output_np = np.zeros_like(input_np)\n\n    # Case 4: Both horizontal and vertical axes found\n    if h_axis_idx is not None and v_axis_idx is not None:\n        h = h_axis_idx\n        v = v_axis_idx\n\n        # Copy the horizontal and vertical axes from input to output\n        output_np[h, :] = input_np[h, :]\n        output_np[:, v] = input_np[:, v] # Note: The intersection cell input_np[h, v] = 4 is correctly handled.\n\n        # Define source quadrants based on input grid slices\n        # Need Input Top-Left (TL), Bottom-Left (BL), Bottom-Right (BR)\n        source_tl = input_np[0:h, 0:v]       # Rows < h, Cols < v\n        source_bl = input_np[h+1:rows, 0:v]   # Rows > h, Cols < v\n        source_br = input_np[h+1:rows, v+1:cols] # Rows > h, Cols > v\n\n        # Perform the quadrant copies based on the rule:\n        # Input TL -> Output TL\n        if source_tl.size > 0: # Check ensures the quadrant exists (h>0 and v>0)\n             output_np[0:h, 0:v] = source_tl\n        # Input BL -> Output TR\n        if source_bl.size > 0: # Check ensures source BL exists (h+1<rows and v>0)\n            if h > 0 and v + 1 < cols: # Check ensures target TR exists\n                 output_np[0:h, v+1:cols] = source_bl\n        # Input TL -> Output BL\n        if source_tl.size > 0: # Check ensures source TL exists (h>0 and v>0)\n            if h + 1 < rows and v > 0: # Check ensures target BL exists\n                output_np[h+1:rows, 0:v] = source_tl\n        # Input BR -> Output BR\n        if source_br.size > 0: # Check ensures source BR exists (h+1<rows and v+1<cols)\n            # Target BR uses the same indices as source BR, check already done\n            output_np[h+1:rows, v+1:cols] = source_br\n\n    # Case 2: Only horizontal axis found\n    elif h_axis_idx is not None:\n        h = h_axis_idx\n\n        # Copy the horizontal axis from input to output\n        output_np[h, :] = input_np[h, :]\n\n        # Define the source region (area above the axis in the input)\n        source_upper = input_np[0:h, :] # Rows < h\n\n        # Copy the source region to the upper and lower regions of the output\n        if source_upper.size > 0: # Check ensures upper region exists (h>0)\n            # Copy to Output Upper region (Rows < h)\n            output_np[0:h, :] = source_upper\n            # Copy to Output Lower region (Rows > h)\n            if h + 1 < rows: # Check ensures lower region exists\n                 output_np[h+1:rows, :] = source_upper\n\n    # Case 3: Only vertical axis found\n    elif v_axis_idx is not None:\n        v = v_axis_idx\n\n        # Copy the vertical axis from input to output\n        output_np[:, v] = input_np[:, v]\n\n        # Define the source region (area left of the axis in the input)\n        source_left = input_np[:, 0:v] # Cols < v\n\n        # Copy the source region to the left and right regions of the output\n        if source_left.size > 0: # Check ensures left region exists (v>0)\n            # Copy to Output Left region (Cols < v)\n            output_np[:, 0:v] = source_left\n            # Copy to Output Right region (Cols > v)\n            if v + 1 < cols: # Check ensures right region exists\n                output_np[:, v+1:cols] = source_left\n\n    # Convert the final numpy array back to a list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23966,
    "candidates_token_count": 2172,
    "total_token_count": 26138,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.070603,
  "retries": 1
}