{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify cells with value '2' as the static boundary.\n2. Identify cells with value '5' as the movable objects.\n3. For each cell containing '5' at position (r, c):\n    a. Find the nearest boundary cell ('2') in each of the four cardinal directions (left, right, up, down).\n    b. Determine the minimum distance among these four directions.\n    c. If the minimum distance corresponds to a horizontal direction (left or right), reflect the '5' horizontally across the nearest vertical boundary line.\n    d. If the minimum distance corresponds to a vertical direction (up or down), reflect the '5' vertically across the nearest horizontal boundary line.\n    e. If there's a tie in minimum distance between horizontal and vertical directions, prioritize horizontal reflection (across the vertical boundary).\n4. In the output grid:\n    a. Set the original position (r, c) of the '5' to '0'.\n    b. Set the calculated reflected position (new_r, new_c) to '5', ensuring it's within the grid boundaries.\n5. Cells with value '0' and '2' remain unchanged in their positions.\n\"\"\"\n\ndef _find_movable_objects(grid: np.ndarray, value: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates of cells with the specified value.\"\"\"\n    rows, cols = np.where(grid == value)\n    return list(zip(rows, cols))\n\ndef _get_nearest_boundary_distances(grid: np.ndarray, r: int, c: int, boundary_value: int) -> dict:\n    \"\"\"\n    Calculates the distance to the nearest boundary cell in each cardinal direction.\n    Returns a dictionary with distances {'left', 'right', 'up', 'down'} \n    and boundary coordinates {'c_left', 'c_right', 'r_up', 'r_down'}.\n    Distances are infinity if no boundary is found in that direction.\n    \"\"\"\n    height, width = grid.shape\n    distances = {\n        'left': float('inf'), 'right': float('inf'),\n        'up': float('inf'), 'down': float('inf'),\n        'c_left': -1, 'c_right': -1, 'r_up': -1, 'r_down': -1\n    }\n\n    # Search Left\n    for search_c in range(c - 1, -1, -1):\n        if grid[r, search_c] == boundary_value:\n            distances['left'] = c - search_c\n            distances['c_left'] = search_c\n            break\n            \n    # Search Right\n    for search_c in range(c + 1, width):\n        if grid[r, search_c] == boundary_value:\n            distances['right'] = search_c - c\n            distances['c_right'] = search_c\n            break\n\n    # Search Up\n    for search_r in range(r - 1, -1, -1):\n        if grid[search_r, c] == boundary_value:\n            distances['up'] = r - search_r\n            distances['r_up'] = search_r\n            break\n            \n    # Search Down\n    for search_r in range(r + 1, height):\n        if grid[search_r, c] == boundary_value:\n            distances['down'] = search_r - r\n            distances['r_down'] = search_r\n            break\n            \n    return distances\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Reflects points with value 5 across the nearest boundary segment \n    formed by points with value 2.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = copy.deepcopy(grid_np)\n    height, width = grid_np.shape\n    \n    movable_value = 5\n    boundary_value = 2\n    background_value = 0\n\n    # Find all initial positions of the movable objects\n    movable_coords = _find_movable_objects(grid_np, movable_value)\n\n    # Store reflection results before modifying the grid\n    reflections = []\n\n    # Calculate reflections for each movable object\n    for r, c in movable_coords:\n        # Find nearest boundary distances\n        distances = _get_nearest_boundary_distances(grid_np, r, c, boundary_value)\n\n        # Determine minimum distance and reflection type\n        min_dist = float('inf')\n        reflect_type = None # 'horizontal' or 'vertical'\n        reflect_coord = -1\n\n        # Check horizontal distances (priority given to horizontal reflection in case of tie)\n        if distances['left'] <= distances['right'] and distances['left'] != float('inf'):\n            min_dist = distances['left']\n            reflect_type = 'horizontal'\n            reflect_coord = distances['c_left']\n        elif distances['right'] < distances['left'] and distances['right'] != float('inf'):\n             min_dist = distances['right']\n             reflect_type = 'horizontal'\n             reflect_coord = distances['c_right']\n             \n        # Check vertical distances\n        min_dist_vert = float('inf')\n        reflect_type_vert = None\n        reflect_coord_vert = -1\n        if distances['up'] <= distances['down'] and distances['up'] != float('inf'):\n             min_dist_vert = distances['up']\n             reflect_type_vert = 'vertical'\n             reflect_coord_vert = distances['r_up']\n        elif distances['down'] < distances['up'] and distances['down'] != float('inf'):\n             min_dist_vert = distances['down']\n             reflect_type_vert = 'vertical'\n             reflect_coord_vert = distances['r_down']\n\n        # Compare min horizontal and min vertical distance\n        if min_dist_vert < min_dist:\n             min_dist = min_dist_vert\n             reflect_type = reflect_type_vert\n             reflect_coord = reflect_coord_vert\n        \n        # Calculate new coordinates if a reflection axis was found\n        new_r, new_c = -1, -1\n        if reflect_type == 'horizontal':\n            # Reflect horizontally across vertical line at reflect_coord (c_b)\n            c_b = reflect_coord\n            new_r = r\n            new_c = c_b + (c_b - c) \n        elif reflect_type == 'vertical':\n            # Reflect vertically across horizontal line at reflect_coord (r_b)\n            r_b = reflect_coord\n            new_r = r_b + (r_b - r)\n            new_c = c\n\n        # Check if reflection occurred and store results\n        if reflect_type is not None:\n           reflections.append(((r, c), (new_r, new_c)))\n\n\n    # Apply reflections to the output grid\n    for original_pos, new_pos in reflections:\n        r_orig, c_orig = original_pos\n        new_r, new_c = new_pos\n        \n        # Set original position to background\n        output_grid_np[r_orig, c_orig] = background_value\n        \n        # Set new position to movable value, checking boundaries\n        if 0 <= new_r < height and 0 <= new_c < width:\n            output_grid_np[new_r, new_c] = movable_value\n        # Else: if reflection goes out of bounds, the object effectively disappears\n\n    # Convert back to list of lists\n    output_grid = output_grid_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4522,
    "candidates_token_count": 3219,
    "total_token_count": 7741,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.140819,
  "retries": 1
}