{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nMirrors foreground patterns from the left half of a grid onto the right half across a vertical separator line, \npreserving the right half's original background color where the left half had its background color.\n\nThe transformation involves the following steps:\n1. Identify the vertical separator column, typically sharing the color of the grid's border.\n2. Determine the background colors of the source (left) and target (right) regions.\n3. Iterate through the target region. For each cell, find its mirrored counterpart in the source region.\n4. If the mirrored source cell contains a foreground color (not the source background), copy that color to the target cell.\n5. If the mirrored source cell contains the source background color, the target cell retains the target region's original background color.\n6. The source region, separator column, and borders remain unchanged.\n\"\"\"\n\ndef find_separator_column(grid_np: np.ndarray) -> int | None:\n    \"\"\"\n    Finds the index of the vertical separator column.\n    Assumes the separator uses the same color as the border and is a solid line\n    within the non-border area of the grid.\n    \"\"\"\n    rows, cols = grid_np.shape\n    if rows <= 2 or cols <= 2:\n        return None # Not enough space for a separator within borders\n\n    border_color = grid_np[0, 0]\n\n    # Look for a column (excluding outer borders) that matches the border color\n    for c in range(1, cols - 1):\n        is_separator = True\n        for r in range(1, rows - 1): # Check only within inner grid\n             if grid_np[r, c] != border_color:\n                 is_separator = False\n                 break\n        if is_separator:\n             # Check if this column separates two distinct background colors\n             # (Simple check: look at colors immediately adjacent in a middle row)\n             mid_row = rows // 2\n             if c > 1 and c < cols - 2: # Ensure there are cells to check on both sides\n                 left_neighbor = grid_np[mid_row, c - 1]\n                 right_neighbor = grid_np[mid_row, c + 1]\n                 # A potential separator should ideally have different colors next to it,\n                 # and these colors shouldn't be the border color itself.\n                 if left_neighbor != border_color and \\\n                    right_neighbor != border_color and \\\n                    left_neighbor != right_neighbor:\n                     return c\n\n    # Fallback or alternative strategy if no solid border-color line found?\n    # For this specific problem, the examples show a clear separator.\n    # Let's try finding the first column from the left (after col 0)\n    # that contains the border color anywhere within the inner grid.\n    for c in range(1, cols - 1):\n        if np.any(grid_np[1:-1, c] == border_color):\n             # Crude check if it looks like a separator based on example structure\n             if c > cols // 4 and c < 3 * cols // 4: # Must be somewhat central\n                 # Check if the column consists *only* of border color (stronger check)\n                 if np.all(grid_np[:, c] == border_color):\n                     return c\n\n    print(\"Warning: Separator column not clearly identified based on border color match.\")\n    # Default guess if no clear separator found (might be brittle)\n    return cols // 2\n\n\ndef get_region_background(region: np.ndarray) -> int:\n    \"\"\"\n    Determines the most frequent color in a region, assuming it's the background.\n    Handles empty regions.\n    \"\"\"\n    if region.size == 0:\n        return -1 # Or raise an error, indicates issue with region definition\n    colors, counts = np.unique(region, return_counts=True)\n    if colors.size > 0:\n        return colors[np.argmax(counts)]\n    return -1 # Should not happen if region is not empty\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the pattern mirroring transformation to the input grid.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = copy.deepcopy(input_np) # Initialize output as a copy of input\n    rows, cols = input_np.shape\n\n    if rows <= 2 or cols <= 2:\n        return input_grid # Grid too small to have distinct regions/separator\n\n    # --- Identify Separator ---\n    separator_index = find_separator_column(input_np)\n    if separator_index is None or separator_index <= 0 or separator_index >= cols - 1:\n        print(f\"Error: Could not reliably find separator column. Guessing middle: {cols // 2}\")\n        # Fallback, might be incorrect for some cases\n        separator_index = cols // 2 \n        # A better fallback might be needed depending on task variations\n\n    # --- Define Regions ---\n    # Source region: columns to the left of the separator (excluding border and separator)\n    # Target region (in input): columns to the right of the separator (excluding border and separator)\n    # Note: indices are [start:stop], stop is exclusive.\n    # We need the background colors *within* the active area (excluding borders)\n    source_region_indices = (slice(1, rows - 1), slice(1, separator_index))\n    target_region_indices = (slice(1, rows - 1), slice(separator_index + 1, cols - 1))\n\n    source_region = input_np[source_region_indices]\n    target_region_input = input_np[target_region_indices] # Use input to find original target bg\n\n    # --- Determine Background Colors ---\n    source_background_color = get_region_background(source_region)\n    # Target background is uniform in examples, take first element if available\n    target_background_color = -1\n    if target_region_input.size > 0:\n        target_background_color = target_region_input[0,0] # Assume uniform background in target input\n        # More robust: check uniformity or use get_region_background\n        # confirmed_target_bg = get_region_background(target_region_input)\n        # if confirmed_target_bg != target_background_color:\n        #     print(\"Warning: Target region background in input is not uniform.\")\n        #     target_background_color = confirmed_target_bg # Use most frequent anyway\n\n    if source_background_color == -1 or target_background_color == -1:\n         print(\"Error: Could not determine background colors.\")\n         return input_grid # Return original if backgrounds are unclear\n\n    # --- Process Target Region for Output ---\n    # Iterate through each cell in the target region of the output grid\n    for r in range(1, rows - 1): # Exclude top/bottom borders\n        for c in range(separator_index + 1, cols - 1): # Exclude side borders and separator\n            # Calculate mirrored source coordinates\n            # Distance from target cell 'c' to separator = c - separator_index\n            # Mirrored column = separator_index - distance\n            mirrored_c = separator_index - (c - separator_index)\n\n            # Ensure mirrored column is within valid source region bounds (should be > 0)\n            if mirrored_c >= 1: # Check it's not the left border\n                source_color = input_np[r, mirrored_c]\n\n                # Apply Transformation Rule\n                if source_color != source_background_color:\n                    # If the source color is a foreground pattern, copy it\n                    output_np[r, c] = source_color\n                else:\n                    # If the source color is the background, keep the target background\n                    # Since output_np started as a copy of input_np, the target cells\n                    # already have the target_background_color. Explicitly setting for clarity:\n                    output_np[r, c] = target_background_color\n            else:\n                # This case shouldn't typically happen with a central separator\n                # but handle it defensively - keep target background\n                 output_np[r, c] = target_background_color\n\n\n    # Convert back to list of lists for the final output\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4328,
    "candidates_token_count": 2758,
    "total_token_count": 7086,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.900549,
  "retries": 1
}