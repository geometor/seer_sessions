
## train_1

**input:**
```
0 0 0 0 5 5 5 5 5 0 0 0 3 0
0 0 0 0 5 5 5 5 5 3 0 0 0 0
0 0 0 3 5 5 5 5 5 0 0 3 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
3 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 3 0 3 0
0 3 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 3 0 5 5 5 5 5 0 0 0 3 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 3 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
```


**output:**
```
0 0 0 0 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 5 5 5 5 5 0 0 0 0
0 0 0 5 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 5 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 5 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
0 0 0 0 5 5 5 5 5 5 0 0 0 0
0 0 0 0 5 5 5 5 5 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 5 0 0 0 0 0 5 0 5 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 5 0 0 5 0 0 0 0 5 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 1 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 0 0
0 0 0 1 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 5 0 0 0 0 0 0
0 0 0 5 0 0 0 5 5 0 0 0 5 0
5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5
0 5 0 5 0 0 0 0 5 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the task based on the provided examples.

## Perception

1.  **Grid Structure:** The input and output are 2D grids of the same dimensions (14x14 in the examples).
2.  **Cell Values (Colors):** The grids contain integer values representing different colors: 0 (background), 5 (a solid block/area), and 1, 2, 3 (active 'trigger' colors).
3.  **Core Transformation:** The transformation modifies the grid based on the locations of the trigger colors (1, 2, or 3) relative to the block(s) of color 5. The trigger colors themselves are removed (effectively turned to 0) in the output unless they are transformed into 5s based on specific rules. The existing 5s generally remain unchanged.
4.  **Two Transformation Patterns:**
    *   **Expansion (Trigger Color 3):** As seen in `train_1`, cells with color 3 change to color 5 *if* they are orthogonally adjacent (sharing an edge) to a cell with color 5 in the input grid. If a cell with color 3 is not adjacent to any cell with color 5, it becomes 0.
    *   **Projection (Trigger Colors 1 and 2):** As seen in `train_2` (color 2) and `train_3` (color 1), the trigger colors act as sources that project the color 5 onto specific target rows.
        *   A contiguous horizontal block of color 5 exists.
        *   Trigger cells located in rows *above* this block project color 5 vertically downwards onto the row immediately *above* the block, in the same column as the trigger cell.
        *   Trigger cells located in rows *below* this block project color 5 vertically upwards onto the row immediately *below* the block, in the same column as the trigger cell.
        *   The original trigger cells become 0 in the output.
5.  **Rule Selection:** The specific transformation rule (Expansion or Projection) is determined by the trigger color present in the input (3 for Expansion, 1 or 2 for Projection). It's assumed only one type of trigger color (1, 2, or 3) will be present in a given input, besides 0 and 5.

## Facts


```yaml
elements:
  - object: grid
    properties:
      - type: 2D array
      - dimensions: variable (14x14 in examples)
      - cells: contains integer values representing colors
  - object: cell
    properties:
      - position: (row, column)
      - color: integer (0, 1, 2, 3, 5)
      - role: based on color
          - 0: background
          - 5: stable block/area
          - 1, 2, 3: trigger/source
relationships:
  - type: adjacency
    between: cells
    definition: Orthogonal neighbors (up, down, left, right)
  - type: relative_position
    between: trigger cell (1, 2, 3) and the block of 5s
    definition: Above, below, or adjacent to the block.
actions:
  - name: identify_trigger_color
    input: input_grid
    output: color (1, 2, or 3) or None
  - name: identify_5_block_rows
    input: input_grid
    output: min_row, max_row (for horizontal block)
    condition: Trigger color is 1 or 2.
  - name: transform_cell_color
    based_on: rules dependent on trigger color and relationship to 5s.
    rules:
      - rule_name: expansion
        trigger_color: 3
        condition: Input cell color is 3.
        effect:
          - If cell is orthogonally adjacent to a 5, output cell color becomes 5.
          - Otherwise, output cell color becomes 0.
      - rule_name: projection
        trigger_color: 1 or 2
        condition: Input cell color is 1 or 2 at position (r, c).
        effect:
          - Initialize output grid by copying input and setting all trigger cells to 0.
          - If r < min_row_5, set output cell (min_row_5 - 1, c) to 5.
          - If r > max_row_5, set output cell (max_row_5 + 1, c) to 5.
      - rule_name: preserve_color
        condition: Input cell color is 0 or 5 and not modified by other rules.
        effect: Output cell color is the same as input cell color.

```


## Natural Language Program

1.  **Analyze Input:** Examine the input grid to identify the predominant non-zero, non-5 'trigger' color (which will be 1, 2, or 3). Assume only one such trigger color exists per grid.
2.  **Select Rule:**
    *   If the trigger color is 3, apply the "Expansion Rule".
    *   If the trigger color is 1 or 2, apply the "Projection Rule".
3.  **Apply Expansion Rule (if trigger is 3):**
    *   Create an output grid initialized with the same values as the input grid.
    *   Iterate through each cell `(r, c)` of the input grid.
    *   If the input cell `(r, c)` contains color 3:
        *   Check its orthogonal neighbors (up, down, left, right) in the *input* grid.
        *   If any neighbor contains color 5, set the output grid cell `(r, c)` to 5.
        *   If no neighbor contains color 5, set the output grid cell `(r, c)` to 0.
    *   Leave all other cells (originally 0 or 5) unchanged in the output grid.
4.  **Apply Projection Rule (if trigger is 1 or 2):**
    *   Identify the minimum row (`min_row_5`) and maximum row (`max_row_5`) containing the contiguous horizontal block of color 5 in the input grid.
    *   Create an output grid initialized with the same values as the input grid, *except* change all cells containing the trigger color (1 or 2) to 0.
    *   Iterate through each cell `(r, c)` of the *input* grid.
    *   If the input cell `(r, c)` contains the trigger color (1 or 2):
        *   If the row `r` is less than `min_row_5`, set the output grid cell at `(min_row_5 - 1, c)` to 5.
        *   If the row `r` is greater than `max_row_5`, set the output grid cell at `(max_row_5 + 1, c)` to 5.
5.  **Final Output:** The resulting grid after applying the selected rule is the final output.
```python
import copy

"""
Transforms an input grid based on the presence of a 'trigger' color (1, 2, or 3) relative to blocks of color 5.

Rule Selection:
- If the trigger color is 3, apply the "Expansion Rule".
- If the trigger color is 1 or 2, apply the "Projection Rule".

Expansion Rule (Trigger 3):
- Cells with color 3 become 5 if they are orthogonally adjacent to a cell with color 5 in the input.
- Otherwise, cells with color 3 become 0.
- All other cells (0 or 5) remain unchanged.

Projection Rule (Triggers 1 or 2):
- Identify the top-most (min_row_5) and bottom-most (max_row_5) rows of the main horizontal block of color 5.
- Trigger cells (1 or 2) located above the block project color 5 onto the row directly above the block (min_row_5 - 1) in the same column.
- Trigger cells (1 or 2) located below the block project color 5 onto the row directly below the block (max_row_5 + 1) in the same column.
- The original trigger cells are changed to 0.
- All other cells (0 or 5) remain unchanged unless modified by the projection.
"""

def _find_trigger_color(grid: list[list[int]]) -> int | None:
    """Finds the first trigger color (1, 2, or 3) in the grid."""
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] in [1, 2, 3]:
                return grid[r][c]
    return None # Should not happen based on problem description

def _find_5_block_rows(grid: list[list[int]]) -> tuple[int | None, int | None]:
    """Finds the minimum and maximum row indices containing the color 5."""
    min_row_5 = None
    max_row_5 = None
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 5:
                if min_row_5 is None:
                    min_row_5 = r
                max_row_5 = r
                # Optimization: once a 5 is found in a row,
                # we know this row contributes to the block boundary
                # calculation, no need to check other cells in this row
                # for the purpose of finding min/max row.
                break 
                
    return min_row_5, max_row_5

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule based on the trigger color found in the input grid.
    """
    if not input_grid or not input_grid[0]:
        return []

    rows = len(input_grid)
    cols = len(input_grid[0])

    # Create a deep copy of the input grid to modify
    output_grid = copy.deepcopy(input_grid)

    # 1. Analyze Input: Identify the trigger color
    trigger_color = _find_trigger_color(input_grid)

    # 2. Select and Apply Rule
    if trigger_color == 3:
        # Apply Expansion Rule
        for r in range(rows):
            for c in range(cols):
                if input_grid[r][c] == 3:
                    # Check orthogonal neighbors in the *input* grid
                    has_5_neighbor = False
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr][nc] == 5:
                            has_5_neighbor = True
                            break
                    
                    # Update the *output* grid
                    if has_5_neighbor:
                        output_grid[r][c] = 5
                    else:
                        output_grid[r][c] = 0
        # Cells originally 0 or 5 are already correct due to the initial deep copy

    elif trigger_color in [1, 2]:
        # Apply Projection Rule
        min_row_5, max_row_5 = _find_5_block_rows(input_grid)

        # Check if a block of 5s was actually found
        if min_row_5 is None or max_row_5 is None:
             # If no 5s, just remove triggers and return
             for r in range(rows):
                for c in range(cols):
                    if output_grid[r][c] == trigger_color:
                         output_grid[r][c] = 0
             return output_grid

        # First pass: Remove original trigger cells from the output grid
        trigger_locations = []
        for r in range(rows):
            for c in range(cols):
                if input_grid[r][c] == trigger_color:
                    output_grid[r][c] = 0 # Remove trigger from its original spot
                    trigger_locations.append((r, c)) # Keep track of where they were

        # Second pass: Apply projections based on original trigger locations
        for r, c in trigger_locations:
             # Project downwards onto row above the block
             if r < min_row_5:
                 target_r = min_row_5 - 1
                 if 0 <= target_r < rows: # Check bounds
                     output_grid[target_r][c] = 5
             
             # Project upwards onto row below the block
             elif r > max_row_5:
                 target_r = max_row_5 + 1
                 if 0 <= target_r < rows: # Check bounds
                     output_grid[target_r][c] = 5
        # Cells originally 0 or 5 are already correct unless projected upon

    # 5. Final Output
    return output_grid
```
