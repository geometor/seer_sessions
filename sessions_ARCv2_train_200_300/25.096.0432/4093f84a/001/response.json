{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms an input grid based on the presence of a 'trigger' color (1, 2, or 3) relative to blocks of color 5.\n\nRule Selection:\n- If the trigger color is 3, apply the \"Expansion Rule\".\n- If the trigger color is 1 or 2, apply the \"Projection Rule\".\n\nExpansion Rule (Trigger 3):\n- Cells with color 3 become 5 if they are orthogonally adjacent to a cell with color 5 in the input.\n- Otherwise, cells with color 3 become 0.\n- All other cells (0 or 5) remain unchanged.\n\nProjection Rule (Triggers 1 or 2):\n- Identify the top-most (min_row_5) and bottom-most (max_row_5) rows of the main horizontal block of color 5.\n- Trigger cells (1 or 2) located above the block project color 5 onto the row directly above the block (min_row_5 - 1) in the same column.\n- Trigger cells (1 or 2) located below the block project color 5 onto the row directly below the block (max_row_5 + 1) in the same column.\n- The original trigger cells are changed to 0.\n- All other cells (0 or 5) remain unchanged unless modified by the projection.\n\"\"\"\n\ndef _find_trigger_color(grid: list[list[int]]) -> int | None:\n    \"\"\"Finds the first trigger color (1, 2, or 3) in the grid.\"\"\"\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] in [1, 2, 3]:\n                return grid[r][c]\n    return None # Should not happen based on problem description\n\ndef _find_5_block_rows(grid: list[list[int]]) -> tuple[int | None, int | None]:\n    \"\"\"Finds the minimum and maximum row indices containing the color 5.\"\"\"\n    min_row_5 = None\n    max_row_5 = None\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 5:\n                if min_row_5 is None:\n                    min_row_5 = r\n                max_row_5 = r\n                # Optimization: once a 5 is found in a row,\n                # we know this row contributes to the block boundary\n                # calculation, no need to check other cells in this row\n                # for the purpose of finding min/max row.\n                break \n                \n    return min_row_5, max_row_5\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on the trigger color found in the input grid.\n    \"\"\"\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # Create a deep copy of the input grid to modify\n    output_grid = copy.deepcopy(input_grid)\n\n    # 1. Analyze Input: Identify the trigger color\n    trigger_color = _find_trigger_color(input_grid)\n\n    # 2. Select and Apply Rule\n    if trigger_color == 3:\n        # Apply Expansion Rule\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == 3:\n                    # Check orthogonal neighbors in the *input* grid\n                    has_5_neighbor = False\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr][nc] == 5:\n                            has_5_neighbor = True\n                            break\n                    \n                    # Update the *output* grid\n                    if has_5_neighbor:\n                        output_grid[r][c] = 5\n                    else:\n                        output_grid[r][c] = 0\n        # Cells originally 0 or 5 are already correct due to the initial deep copy\n\n    elif trigger_color in [1, 2]:\n        # Apply Projection Rule\n        min_row_5, max_row_5 = _find_5_block_rows(input_grid)\n\n        # Check if a block of 5s was actually found\n        if min_row_5 is None or max_row_5 is None:\n             # If no 5s, just remove triggers and return\n             for r in range(rows):\n                for c in range(cols):\n                    if output_grid[r][c] == trigger_color:\n                         output_grid[r][c] = 0\n             return output_grid\n\n        # First pass: Remove original trigger cells from the output grid\n        trigger_locations = []\n        for r in range(rows):\n            for c in range(cols):\n                if input_grid[r][c] == trigger_color:\n                    output_grid[r][c] = 0 # Remove trigger from its original spot\n                    trigger_locations.append((r, c)) # Keep track of where they were\n\n        # Second pass: Apply projections based on original trigger locations\n        for r, c in trigger_locations:\n             # Project downwards onto row above the block\n             if r < min_row_5:\n                 target_r = min_row_5 - 1\n                 if 0 <= target_r < rows: # Check bounds\n                     output_grid[target_r][c] = 5\n             \n             # Project upwards onto row below the block\n             elif r > max_row_5:\n                 target_r = max_row_5 + 1\n                 if 0 <= target_r < rows: # Check bounds\n                     output_grid[target_r][c] = 5\n        # Cells originally 0 or 5 are already correct unless projected upon\n\n    # 5. Final Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4396,
    "candidates_token_count": 2263,
    "total_token_count": 6659,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.688417,
  "retries": 1
}