
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 0 0 0 8 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 0 0 0 0 0 0 0
0 0 0 8 0 0 0 0 0 0 0
8 0 0 0 8 0 0 0 0 0 0
0 8 0 0 0 8 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 0 6 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
6 6 6 0 0 0 0 0 0 0 0
0 6 0 6 0 0 0 0 0 0 0
0 0 6 0 6 0 0 0 0 0 0
0 0 0 6 0 6 0 0 0 0 0
0 0 0 0 6 6 6 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 0 0 3 0 3 0 0 0
0 0 0 0 0 0 3 3 0 3 3 0 0
0 0 0 0 0 0 3 0 0 0 3 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 3 0 3 0 0 0 0 0 0
0 0 0 0 3 3 0 3 3 0 0 0 0
0 0 0 0 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 2 2 2 2 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 2 2 0 0 2 0 0 0 0
0 0 0 0 0 2 0 0 2 2 0 0 0
0 0 0 0 0 2 0 0 0 2 0 0 0
0 0 0 0 0 2 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 0 0 0 0 0 0 0 0 0
2 0 0 0 2 0 0 0 0 0 0 0 0
0 2 2 0 0 2 0 0 0 0 0 0 0
0 0 0 2 0 0 2 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 2 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0
0 8 8 8 0 0 0
0 8 8 8 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0
8 8 8 0 0 0 0
0 8 8 8 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
```

*   **Perception:**
    *   The task involves transforming a 2D grid of digits.
    *   Each input grid contains a background of zeros and a single connected shape made of a non-zero digit (e.g., 8, 6, 3, 2).
    *   The output grid is the same size as the input grid and also contains a background of zeros.
    *   The non-zero shape from the input grid appears in the output grid, preserving its internal structure and the digit it's made of.
    *   The key transformation is the positional shift of the non-zero shape.
    *   By comparing the input and output positions, the shape consistently shifts horizontally to the left.
    *   The amount of the leftward shift appears to be determined by the initial horizontal position of the shape's leftmost point. Specifically, the shape is moved so that its leftmost point aligns with the first column (column index 0) of the grid.

*   **YAML Facts:**
    
```yaml
    Objects:
      - Grid:
          Properties:
            - dimensions: (rows, columns)
            - cells: collection of (row, column, value) tuples
            - background_value: 0
      - Shape:
          Properties:
            - cells: list of (row, column) coordinates with non-zero values
            - color: the non-zero digit value
            - leftmost_column: the minimum column index among all shape cells
    Actions:
      - Identify Shape: Find all connected non-zero cells in the input Grid.
      - Determine Shift: Calculate the horizontal shift required to move the Shape's leftmost_column to column 0. Shift amount = -leftmost_column.
      - Apply Shift: Create a new Grid by moving each cell of the input Shape horizontally by the calculated shift amount.
    Relationships:
      - The output Grid contains the input Shape, shifted horizontally.
      - The shift amount ensures the Shape's leftmost point is at column index 0 in the output Grid.
      - The relative positions of cells within the Shape remain unchanged.
      - The background of the output Grid is filled with the background_value (0).
    ```


*   **Natural Language Program:**
    1.  Identify all cells in the input grid that contain a non-zero value. These cells constitute the 'Shape'. Note the color (the non-zero digit) of the Shape.
    2.  Find the minimum column index among all the cells identified in step 1. Call this `min_col`.
    3.  Create a new output grid with the same dimensions as the input grid, initializing all cells to zero.
    4.  For each cell at `(row, col)` in the input grid that belongs to the Shape (i.e., has a non-zero value):
        a.  Calculate the new column index: `new_col = col - min_col`.
        b.  Place the Shape's color at the corresponding position `(row, new_col)` in the output grid.
    5.  The resulting grid is the final output.
```python
"""
Identifies the connected non-zero shape in the input grid, determines its 
leftmost column index (min_col), and creates an output grid where the shape 
is shifted horizontally such that its leftmost point is at column 0. 
The shape's internal structure and color are preserved. The background 
remains zero.
"""

import numpy as np # Using numpy for easier grid initialization and manipulation

def find_shape_and_min_col(grid: list[list[int]]) -> tuple[list[tuple[int, int]], int | None, int | None]:
    """
    Finds all non-zero cells, their color, and the minimum column index.

    Args:
        grid: The input grid (list of lists).

    Returns:
        A tuple containing:
        - list of (row, col) tuples for non-zero cells.
        - the color (int value) of the shape (None if no shape).
        - the minimum column index (None if no shape).
    """
    shape_cells = []
    shape_color = None
    min_col = None
    rows = len(grid)
    if rows == 0:
        return [], None, None
    cols = len(grid[0])
    if cols == 0:
        return [], None, None

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] != 0:
                shape_cells.append((r, c))
                if shape_color is None:
                    shape_color = grid[r][c] # Assume only one non-zero color
                if min_col is None or c < min_col:
                    min_col = c
                    
    return shape_cells, shape_color, min_col

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Shifts the non-zero shape in the input grid horizontally to the left 
    edge (column 0).

    Args:
        input_grid: A list of lists representing the input grid.

    Returns:
        A list of lists representing the transformed grid.
    """
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)] # Return grid of empty rows if input columns=0

    # Initialize output_grid with zeros using numpy for convenience
    output_grid_np = np.zeros((rows, cols), dtype=int)

    # 1. Identify the shape cells, color, and the minimum column index
    shape_cells, shape_color, min_col = find_shape_and_min_col(input_grid)

    # If no shape is found (all zeros or empty grid), return the zero grid
    if not shape_cells or shape_color is None or min_col is None:
        return output_grid_np.tolist() # Convert back to list of lists

    # 2. Calculate the horizontal shift (which is simply -min_col)
    # No explicit shift variable needed, we use min_col directly in the next step

    # 3. Create the output grid by placing the shifted shape
    # Iterate through the identified shape cells
    for r, c in shape_cells:
        # Calculate the new column after shifting
        new_col = c - min_col
        # Check bounds (though shifting left shouldn't go out of bounds left)
        if 0 <= r < rows and 0 <= new_col < cols:
             # Place the shape's color in the new position in the output grid
            output_grid_np[r, new_col] = shape_color

    # Convert the numpy array back to a list of lists for the final output
    output_grid = output_grid_np.tolist()

    return output_grid
```
