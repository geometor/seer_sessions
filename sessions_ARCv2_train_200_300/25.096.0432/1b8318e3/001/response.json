{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\n\n\"\"\"\nProcesses a 2D grid of integers based on the following rules:\n\n1. Identifies 2x2 blocks of the digit '5' (FiveSquares). These FiveSquares remain \n   static and are copied directly from the input to the output grid.\n2. Identifies all other non-zero digits (SingletonDigits) that are not part of \n   a FiveSquare.\n3. Each SingletonDigit is relocated in the output grid. Its destination is determined \n   by finding the nearest FiveSquare (based on Manhattan distance from the \n   SingletonDigit's original position to the center of the FiveSquare, with \n   top-left tie-breaking).\n4. The SingletonDigit is then placed in one of the 12 cells immediately \n   adjacent (orthogonally or diagonally) to the chosen nearest FiveSquare. \n   The specific adjacent cell chosen is the one closest (Manhattan distance) \n   to the SingletonDigit's *original* position (with top-left tie-breaking).\n5. The original positions of the moved SingletonDigits become '0' in the output grid, \n   unless overwritten by the destination of another SingletonDigit. All other '0' \n   cells from the input remain '0' unless overwritten.\n\"\"\"\n\ndef find_five_squares(grid: list[list[int]]) -> list[tuple[int, int]]:\n    \"\"\"Finds all top-left coordinates of 2x2 squares of 5s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    five_squares_coords = []\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            if (grid[r][c] == 5 and grid[r+1][c] == 5 and\n                    grid[r][c+1] == 5 and grid[r+1][c+1] == 5):\n                five_squares_coords.append((r, c))\n    return five_squares_coords\n\ndef is_part_of_five_square(r: int, c: int, five_squares_coords: list[tuple[int, int]]) -> bool:\n    \"\"\"Checks if a cell (r, c) belongs to any identified FiveSquare.\"\"\"\n    for sq_r, sq_c in five_squares_coords:\n        if sq_r <= r <= sq_r + 1 and sq_c <= c <= sq_c + 1:\n            return True\n    return False\n\ndef find_singleton_digits(grid: list[list[int]], five_squares_coords: list[tuple[int, int]]) -> list[tuple[int, int, int]]:\n    \"\"\"Finds all non-zero digits not part of a FiveSquare, returning (value, r, c).\"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    singletons = []\n    for r in range(rows):\n        for c in range(cols):\n            value = grid[r][c]\n            if value != 0 and not is_part_of_five_square(r, c, five_squares_coords):\n                singletons.append((value, r, c))\n    return singletons\n\ndef manhattan_distance(p1: tuple[float, float], p2: tuple[float, float]) -> float:\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef get_adjacent_cells(sq_r: int, sq_c: int, rows: int, cols: int) -> list[tuple[int, int]]:\n    \"\"\"Gets the 12 adjacent cells around a 2x2 square starting at (sq_r, sq_c).\"\"\"\n    adjacent = []\n    # Cells around the 2x2 square\n    for r_offset in range(-1, 3): # Covers rows from sq_r-1 to sq_r+2\n        for c_offset in range(-1, 3): # Covers cols from sq_c-1 to sq_c+2\n            r, c = sq_r + r_offset, sq_c + c_offset\n            # Check if it's within grid bounds\n            if 0 <= r < rows and 0 <= c < cols:\n                # Check if it's *not* part of the 2x2 square itself\n                is_part_of_square = (0 <= r_offset <= 1 and 0 <= c_offset <= 1)\n                if not is_part_of_square:\n                    adjacent.append((r, c))\n    return adjacent\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by relocating singleton digits towards the nearest\n    2x2 '5' square.\n    \"\"\"\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    # Initialize output_grid with zeros\n    output_grid = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    # 1. Find FiveSquares and copy them to the output\n    five_squares_coords = find_five_squares(input_grid)\n    for r_sq, c_sq in five_squares_coords:\n        for r_offset in range(2):\n            for c_offset in range(2):\n                if 0 <= r_sq + r_offset < rows and 0 <= c_sq + c_offset < cols:\n                     output_grid[r_sq + r_offset][c_sq + c_offset] = 5\n\n    # 2. Find SingletonDigits\n    singletons = find_singleton_digits(input_grid, five_squares_coords)\n\n    # 3. Process each SingletonDigit\n    processed_targets = set() # Keep track of occupied target cells to handle potential overwrites (first wins)\n\n    for value, r_orig, c_orig in singletons:\n        \n        # 4a. Calculate distance to each FiveSquare center\n        nearest_sq_coord = None\n        min_dist_to_sq = float('inf')\n\n        if not five_squares_coords: # Handle case with no five squares\n             # If no FiveSquares, singleton stays put? Or disappears? \n             # Based on examples, they seem to disappear if no FiveSquare exists.\n             # Let's assume they disappear (remain 0 in output).\n             continue \n\n        for r_sq, c_sq in five_squares_coords:\n            # Center of the FiveSquare (using top-left + 0.5 offset)\n            center_sq = (r_sq + 0.5, c_sq + 0.5)\n            dist = manhattan_distance((r_orig, c_orig), center_sq)\n\n            # 4b. Determine nearest FiveSquare with tie-breaking\n            if dist < min_dist_to_sq:\n                min_dist_to_sq = dist\n                nearest_sq_coord = (r_sq, c_sq)\n            elif dist == min_dist_to_sq:\n                # Tie-breaking: top-most (smaller r), then left-most (smaller c)\n                if r_sq < nearest_sq_coord[0]:\n                    nearest_sq_coord = (r_sq, c_sq)\n                elif r_sq == nearest_sq_coord[0] and c_sq < nearest_sq_coord[1]:\n                    nearest_sq_coord = (r_sq, c_sq)\n\n        if nearest_sq_coord is None: \n             # Should not happen if five_squares_coords is not empty, but defensive check\n             continue\n\n        # 4c. Get adjacent cells for the nearest FiveSquare\n        r_sq_nearest, c_sq_nearest = nearest_sq_coord\n        adjacent_cells = get_adjacent_cells(r_sq_nearest, c_sq_nearest, rows, cols)\n\n        # 4d. Find the closest adjacent cell to the singleton's *original* position\n        closest_adj_cell = None\n        min_dist_to_adj = float('inf')\n\n        potential_targets = []\n        for r_adj, c_adj in adjacent_cells:\n            # Only consider cells that are currently 0 in the output grid (available)\n             # Also check if it hasn't been claimed by another singleton already in this loop\n            if output_grid[r_adj][c_adj] == 0 and (r_adj, c_adj) not in processed_targets:\n                dist = manhattan_distance((r_orig, c_orig), (r_adj, c_adj))\n                potential_targets.append(((r_adj, c_adj), dist))\n\n        if not potential_targets:\n            # No available adjacent cell found, the singleton might disappear\n            # Or maybe there's another rule? Based on examples, it seems it lands somewhere.\n            # Re-evaluate: Maybe it can overwrite 0s even if not adjacent? Let's stick to adjacent for now.\n            # It's possible the adjacent cell calculation or the target availability check is slightly off.\n            # Let's assume it must find *one* of the 12, even if occupied by 0.\n            # Re-calculating distances for *all* 12 adjacent cells\n            \n            potential_targets = [] # Reset and recalculate without the output_grid[r_adj][c_adj] == 0 check initially\n            for r_adj, c_adj in adjacent_cells:\n                 dist = manhattan_distance((r_orig, c_orig), (r_adj, c_adj))\n                 potential_targets.append(((r_adj, c_adj), dist))\n\n\n        if not potential_targets: # Still no targets? Something is wrong.\n             # For now, skip placing this singleton if no adjacent cells found\n             # This might indicate an edge case or misunderstanding.\n             print(f\"Warning: No adjacent cells found for singleton {value} at ({r_orig}, {c_orig}) near square at {nearest_sq_coord}\")\n             continue\n\n\n        # Sort potential targets: primary key distance, secondary key row, tertiary key column\n        potential_targets.sort(key=lambda x: (x[1], x[0][0], x[0][1]))\n        \n        # 4e. Determine the best target cell based on sorted list (handles tie-breaking)\n        # Find the first target that hasn't been claimed yet\n        chosen_target = None\n        for target_coord, dist in potential_targets:\n            if target_coord not in processed_targets:\n                 # Check if the target cell is part of another FiveSquare (shouldn't happen with get_adjacent_cells logic, but safety check)\n                 is_target_part_of_sq = False\n                 for sq_r_chk, sq_c_chk in five_squares_coords:\n                     if sq_r_chk <= target_coord[0] <= sq_r_chk + 1 and sq_c_chk <= target_coord[1] <= sq_c_chk + 1:\n                          is_target_part_of_sq = True\n                          break\n                 if not is_target_part_of_sq:\n                    chosen_target = target_coord\n                    break # Found the best available target\n\n        # 4f. Place the SingletonDigit's value in the output grid if a target was found\n        if chosen_target:\n            r_target, c_target = chosen_target\n            output_grid[r_target][c_target] = value\n            processed_targets.add(chosen_target) # Mark this cell as claimed\n        # else:\n            # print(f\"Warning: Could not place singleton {value} from ({r_orig}, {c_orig}) as all preferred adjacent cells were taken or invalid.\")\n\n\n    # 5. Return the completed output grid\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3826,
    "candidates_token_count": 3838,
    "total_token_count": 7664,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.557197,
  "retries": 1
}