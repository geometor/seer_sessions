
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 3 1 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 1 1 1 1 1 1 1 1 1 1
3 1 3 1 1 1 1 1 1 1 1 1 1 1 1
3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 2 8 2 8 8 8 8 8 8
8 8 8 8 8 8 2 8 2 8 8 8 8 8
8 8 8 8 8 8 8 2 8 2 8 8 8 8
8 8 8 8 8 8 8 8 2 8 2 8 8 8
8 8 8 8 8 8 8 8 8 2 8 2 8 8
8 8 8 8 8 8 8 8 8 8 2 8 2 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's analyze the provided examples.

**Perception of Task Elements:**

The task involves transforming an input grid of numbers into an output grid. The transformation appears to depend on the presence of specific numbers (2, 3, 8) within the grid, which act as "sources". These source numbers "propagate" or "paint" diagonally across the grid, changing cells that match the grid's "background" color. The background color is the predominant color in the input grid (1 in train_1, 8 in train_2, 4 in train_3). Other numbers (like 0) seem unaffected and might act as obstacles or simply remain unchanged. The original source numbers also remain in their initial positions. The direction of propagation depends on the source number.

**YAML Facts:**


```yaml
task_type: grid_transformation
grid_properties:
  dimensionality: 2
  cell_content: integers
  background_color: 
    description: The most frequent color in the input grid, excluding 0 perhaps. Specific value varies per example (1, 8, 4).
    role: Acts as the medium/target for propagation.
objects:
  - object_type: source_cell
    identifier: color_value
    properties:
      - color: 2
        action: propagates diagonally down-right
      - color: 3
        action: propagates diagonally down-left
      - color: 8
        action: propagates diagonally up-left AND up-right
    role: Initiates the propagation/painting process.
  - object_type: background_cell
    identifier: color_value (matches grid's background_color)
    role: Can be overwritten by propagation from a source_cell.
  - object_type: inert_cell
    identifier: color_value (e.g., 0)
    role: Not directly involved in propagation; remains unchanged and does not get overwritten.
actions:
  - action_type: propagate_and_paint
    actor: source_cell
    target: background_cell
    constraints:
      - stops_at_grid_boundary
      - follows_specific_diagonal_path (determined by source_cell color)
      - overwrites_only_background_cells_in_path
    result: Target cells change color to match the source cell's color.
relationship:
  - The output grid is a modified version of the input grid.
  - The modification rule depends on the specific color value of identified source cells.
  - Propagation paths extend from each source cell until the grid boundary.
  - Cells retain their input value unless overwritten by a propagation path (and only if they originally contained the background color).
```


**Natural Language Program:**

1.  **Initialization**: Create the output grid as an identical copy of the input grid. Determine the background color by finding the most frequent color in the input grid.
2.  **Identify Sources**: Iterate through each cell `(r, c)` of the input grid.
3.  **Process Source '2'**: If the input cell `(r, c)` contains the color 2:
    *   Trace a path diagonally down and right starting from the cell below and to the right `(r+1, c+1)`.
    *   For each cell `(i, j)` along this path, continue as long as `i` and `j` are within the grid boundaries:
        *   If the input cell `(i, j)` contains the background color, update the output cell `(i, j)` to color 2.
4.  **Process Source '3'**: If the input cell `(r, c)` contains the color 3:
    *   Trace a path diagonally down and left starting from the cell below and to the left `(r+1, c-1)`.
    *   For each cell `(i, j)` along this path, continue as long as `i` and `j` are within the grid boundaries:
        *   If the input cell `(i, j)` contains the background color, update the output cell `(i, j)` to color 3.
5.  **Process Source '8'**: If the input cell `(r, c)` contains the color 8:
    *   **Path 1 (Up-Left)**: Trace a path diagonally up and left starting from `(r-1, c-1)`. For each cell `(i, j)` along this path within grid boundaries, if input cell `(i, j)` is the background color, update output cell `(i, j)` to 8.
    *   **Path 2 (Up-Right)**: Trace a path diagonally up and right starting from `(r-1, c+1)`. For each cell `(i, j)` along this path within grid boundaries, if input cell `(i, j)` is the background color, update output cell `(i, j)` to 8.
6.  **Finalization**: After checking all cells in the input grid, return the modified output grid. Cells not identified as sources and not overwritten during propagation retain their original input values.
```python
import numpy as np
from collections import Counter

"""
Transforms an input grid based on propagation rules associated with specific cell values (2, 3, 8).

1. Determine the background color (most frequent color in the input grid).
2. Initialize the output grid as a copy of the input grid.
3. Iterate through each cell of the input grid:
    - If a cell contains '2', propagate '2' diagonally down-right, overwriting background cells in the output grid.
    - If a cell contains '3', propagate '3' diagonally down-left, overwriting background cells in the output grid.
    - If a cell contains '8', propagate '8' diagonally up-left AND up-right, overwriting background cells in the output grid.
4. Return the modified output grid.
"""

def _get_background_color(grid: np.ndarray) -> int:
    """Finds the most frequent color in the grid."""
    counts = Counter(grid.flatten())
    # Often, the background is the most frequent non-zero color.
    # However, based on examples, simply taking the most frequent seems correct.
    # If 0 were the most frequent, we might need to reconsider, but it's not in the examples.
    if counts:
        # Find the most common element
        background_color = counts.most_common(1)[0][0]
        # Handle potential ties or scenarios where 0 is most common but shouldn't be background
        # For this specific problem, the simple most_common seems sufficient based on examples.
        # Let's refine if needed: Check if 0 is most common and if there's another color.
        if background_color == 0 and len(counts) > 1:
             background_color = counts.most_common(2)[1][0] # take the second most common
        return background_color
    return -1 # Should not happen for non-empty grids


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies diagonal propagation rules to modify the grid.
    """
    input_np = np.array(input_grid, dtype=int)
    output_np = np.copy(input_np)
    height, width = input_np.shape

    # Determine the background color
    background_color = _get_background_color(input_np)
    if background_color == -1: # Handle empty grid case
        return input_grid

    # Iterate through each cell to find sources
    for r in range(height):
        for c in range(width):
            source_color = input_np[r, c]

            # Process Source '2': Propagate down-right
            if source_color == 2:
                cr, cc = r + 1, c + 1 # Start from the next cell diagonally
                while 0 <= cr < height and 0 <= cc < width:
                    # Check if the cell in the *original* grid is background color
                    if input_np[cr, cc] == background_color:
                        output_np[cr, cc] = source_color # Update the output grid
                    # Continue propagation regardless of overwriting, stopping only at boundaries
                    cr += 1
                    cc += 1

            # Process Source '3': Propagate down-left
            elif source_color == 3:
                cr, cc = r + 1, c - 1 # Start from the next cell diagonally
                while 0 <= cr < height and 0 <= cc < width:
                    if input_np[cr, cc] == background_color:
                        output_np[cr, cc] = source_color
                    cr += 1
                    cc -= 1

            # Process Source '8': Propagate up-left and up-right
            elif source_color == 8:
                # Path 1: Up-Left
                cr, cc = r - 1, c - 1
                while 0 <= cr < height and 0 <= cc < width:
                    if input_np[cr, cc] == background_color:
                        output_np[cr, cc] = source_color
                    cr -= 1
                    cc -= 1

                # Path 2: Up-Right
                cr, cc = r - 1, c + 1
                while 0 <= cr < height and 0 <= cc < width:
                    if input_np[cr, cc] == background_color:
                        output_np[cr, cc] = source_color
                    cr -= 1
                    cc += 1

    # Convert back to list of lists
    return output_np.tolist()

```
