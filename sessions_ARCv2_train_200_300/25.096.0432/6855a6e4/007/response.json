{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nThe transformation rule operates on a 2D grid containing integers (0, 2, 5).\nIt identifies a static 'boundary' pattern (value 2) and a mobile 'object' pattern group (value 5).\n\n1.  The boundary pattern (2) remains fixed in its original position in the output grid.\n2.  The object pattern group (5), potentially consisting of multiple disconnected components treated as a single entity based on their combined bounding box, is moved from its original location.\n3.  The original locations occupied by the object group become background (0) in the output.\n4.  An 'internal empty space' is identified. This space consists of all background cells (0) located within the bounding box of the boundary pattern (2) in the input grid.\n5.  The object pattern group (5) is then placed onto the output grid. The placement is determined by aligning the geometric center of the object pattern group's bounding box (from the input) with the geometric center of the bounding box of the identified 'internal empty space'.\n6.  The relative spatial arrangement of all cells within the object group (5) is preserved during the move.\n7.  If essential components (boundary pattern, object pattern, or internal empty space) are missing, the transformation might not fully apply, potentially resulting in an output grid containing only the copied boundary pattern.\n\"\"\"\n\n# =================================\n# Helper Functions\n# =================================\n\ndef find_cells(grid: np.ndarray, value: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of cells with a specific value.\"\"\"\n    rows, cols = np.where(grid == value)\n    # Use tolist() to ensure standard python ints, not numpy ints\n    return list(zip(rows.tolist(), cols.tolist()))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\n    Returns None if the list is empty.\n    \"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef get_relative_pattern_group(grid: np.ndarray, value: int) -> Tuple[List[Tuple[int, int]], Optional[Tuple[int, int, int, int]]]:\n    \"\"\"\n    Finds the pattern of a given value relative to its combined top-left corner.\n    Returns a list of relative coordinates (relative_row, relative_col) and the\n    combined bounding box (min_row, min_col, max_row, max_col) of the pattern in the original grid.\n    Returns ([], None) if no cells of the value are found.\n    \"\"\"\n    coords = find_cells(grid, value)\n    if not coords:\n        return [], None\n\n    bbox = get_bounding_box(coords)\n    # bbox is guaranteed not None here because coords is not empty\n    min_row, min_col, _, _ = bbox # type: ignore\n\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    return relative_coords, bbox\n\ndef find_internal_zeros_bbox(grid: np.ndarray, container_bbox: Optional[Tuple[int, int, int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of the zero cells (0) located strictly within the given container_bbox.\n    Returns (min_row, min_col, max_row, max_col) or None if no container or no zeros inside.\n    \"\"\"\n    if container_bbox is None:\n        return None\n\n    c_min_r, c_min_c, c_max_r, c_max_c = container_bbox\n    zero_coords = find_cells(grid, 0)\n\n    # Filter zero cells to include only those strictly within the container bounding box\n    internal_zeros = [\n        (r, c) for r, c in zero_coords\n        if c_min_r <= r <= c_max_r and c_min_c <= c <= c_max_c\n    ]\n    \n    # Return the bounding box of these internal zero cells\n    return get_bounding_box(internal_zeros)\n\ndef calculate_center(bbox: Optional[Tuple[int, int, int, int]]) -> Optional[Tuple[float, float]]:\n    \"\"\"Calculates the geometric center (row, col) of a bounding box.\"\"\"\n    if bbox is None:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    center_r = min_r + (max_r - min_r) / 2.0\n    center_c = min_c + (max_c - min_c) / 2.0\n    return center_r, center_c\n\n# =================================\n# Main Transformation Function\n# =================================\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    # Initialize output grid with background color 0\n    output_array = np.zeros_like(input_array)\n\n    # --- Step 1 & 2: Identify and copy the boundary pattern (value 2) ---\n    boundary_coords = find_cells(input_array, 2)\n    for r, c in boundary_coords:\n        output_array[r, c] = 2\n    # Calculate the bounding box of the boundary\n    boundary_bbox = get_bounding_box(boundary_coords)\n\n    # --- Step 4 & 5: Identify the object pattern group (value 5) ---\n    object_relative_coords, object_bbox_in = get_relative_pattern_group(input_array, 5)\n\n    # If no object pattern, return the grid with only the (potentially empty) boundary\n    if not object_relative_coords or object_bbox_in is None:\n        return output_array.tolist()\n\n    # --- Step 6 & 7: Identify the bounding box of the internal empty space ---\n    internal_zeros_bbox = find_internal_zeros_bbox(input_array, boundary_bbox)\n\n    # If no internal empty space found (e.g., no boundary, or no zeros inside boundary bbox),\n    # return grid with only the boundary pattern copied.\n    if internal_zeros_bbox is None:\n         return output_array.tolist()\n\n    # --- Step 8 & 9: Calculate centers ---\n    object_center_in = calculate_center(object_bbox_in)\n    internal_zeros_center = calculate_center(internal_zeros_bbox)\n\n    # Defensive check: ensure centers could be calculated\n    if object_center_in is None or internal_zeros_center is None:\n         # This case should technically be covered by earlier checks, but belts and suspenders\n         return output_array.tolist()\n\n    # --- Step 10: Calculate target top-left corner for placing the object group ---\n    # The goal is to align the centers. We calculate the offset required to move\n    # the object's original center to the target center, and apply this offset\n    # to the object's original top-left corner.\n\n    obj_min_r, obj_min_c, _, _ = object_bbox_in # Original top-left\n    obj_center_r, obj_center_c = object_center_in # Original center\n    target_center_r, target_center_c = internal_zeros_center # Target center\n\n    # Calculate the difference (offset) between target and original centers\n    offset_r = target_center_r - obj_center_r\n    offset_c = target_center_c - obj_center_c\n\n    # Apply the offset to the original top-left corner and round to get target top-left\n    target_min_r = int(round(obj_min_r + offset_r))\n    target_min_c = int(round(obj_min_c + offset_c))\n\n    # --- Step 11: Place the object pattern group onto the output grid ---\n    for rel_r, rel_c in object_relative_coords:\n        # Calculate the absolute coordinates in the output grid\n        place_r = target_min_r + rel_r\n        place_c = target_min_c + rel_c\n\n        # Place the object cell (value 5) if it's within the grid boundaries\n        if 0 <= place_r < rows and 0 <= place_c < cols:\n            # Overwrite whatever value is currently at the target location (likely 0)\n            output_array[place_r, place_c] = 5\n\n    # --- Step 12: Return the final grid ---\n    # Convert the NumPy array back to a standard Python list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22780,
    "candidates_token_count": 2592,
    "total_token_count": 25372,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.667906,
  "retries": 1
}