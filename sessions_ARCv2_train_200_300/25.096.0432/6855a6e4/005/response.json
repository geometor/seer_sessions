{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nThe transformation rule operates on a 2D grid containing integers (0, 2, 5).\nIt identifies a static 'boundary' pattern (value 2) and a mobile 'object' pattern group (value 5).\n\n1.  The boundary pattern (2) remains fixed in its original position in the output grid.\n2.  The object pattern group (5), potentially consisting of multiple disconnected components treated as a single entity based on their combined bounding box, is moved from its original location.\n3.  The original locations occupied by the object group become background (0) in the output.\n4.  A 'target zone' is identified within the input grid. This zone is the largest rectangular area consisting entirely of background cells (0) that fits within the bounding box of the boundary pattern (2).\n5.  The object pattern group (5) is then placed onto the output grid. The placement is determined by aligning the center of the object pattern group's bounding box with the center of the identified target zone's bounding box.\n6.  The relative spatial arrangement of all cells within the object group (5) is preserved during the move.\n7.  If no boundary pattern (2), object pattern (5), or target zone (0s within the boundary) is found, the behavior might default to copying only the boundary or returning an empty/unmodified grid, based on necessity. The current implementation assumes all necessary components exist for the transformation to occur meaningfully.\n\"\"\"\n\n# =================================\n# Helper Functions\n# =================================\n\ndef find_cells(grid: np.ndarray, value: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of cells with a specific value.\"\"\"\n    rows, cols = np.where(grid == value)\n    # Use tolist() to ensure standard python ints, not numpy ints\n    return list(zip(rows.tolist(), cols.tolist()))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\n    Returns None if the list is empty.\n    \"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef get_relative_pattern_group(grid: np.ndarray, value: int) -> Tuple[List[Tuple[int, int]], Optional[Tuple[int, int, int, int]]]:\n    \"\"\"\n    Finds the pattern of a given value relative to its combined top-left corner.\n    Returns a list of relative coordinates (relative_row, relative_col) and the\n    combined bounding box (min_row, min_col, max_row, max_col) of the pattern in the original grid.\n    Returns ([], None) if no cells of the value are found.\n    \"\"\"\n    coords = find_cells(grid, value)\n    if not coords:\n        return [], None\n\n    bbox = get_bounding_box(coords)\n    # bbox is guaranteed not None here because coords is not empty\n    min_row, min_col, _, _ = bbox\n\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    return relative_coords, bbox\n\ndef largest_rectangle_in_histogram(heights: List[int]) -> int:\n    \"\"\"Finds the largest rectangle area in a histogram.\"\"\"\n    stack = [-1]\n    max_area = 0\n    for i, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] >= h:\n            height = heights[stack.pop()]\n            width = i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    while stack[-1] != -1:\n        height = heights[stack.pop()]\n        width = len(heights) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    return max_area\n\ndef find_largest_zero_rectangle_bbox(grid: np.ndarray, container_bbox: Optional[Tuple[int, int, int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the bounding box of the largest rectangle composed entirely of zeros\n    within the given container_bbox in the grid.\n    Returns (min_row, min_col, max_row, max_col) or None if no zeros or container.\n    \"\"\"\n    if container_bbox is None:\n        return None\n\n    c_min_r, c_min_c, c_max_r, c_max_c = container_bbox\n    \n    # Extract the subgrid defined by the container_bbox\n    subgrid = grid[c_min_r : c_max_r + 1, c_min_c : c_max_c + 1]\n\n    # Create a binary matrix: 1 for zeros, 0 otherwise\n    binary_mask = (subgrid == 0).astype(int)\n    \n    rows, cols = binary_mask.shape\n    if rows == 0 or cols == 0:\n        return None\n\n    heights = np.zeros(cols, dtype=int)\n    max_area = 0\n    best_bbox_relative = None # (min_r, min_c, max_r, max_c) relative to subgrid\n\n    # Iterate through rows to build histograms and find max rectangle\n    for r in range(rows):\n        # Update heights histogram\n        for c in range(cols):\n            heights[c] = heights[c] + 1 if binary_mask[r, c] == 1 else 0\n\n        # Find largest rectangle ending at this row using histogram method\n        stack = [-1] # Store indices of columns\n        for c_idx, h in enumerate(heights):\n            while stack[-1] != -1 and heights[stack[-1]] >= h:\n                height = heights[stack.pop()]\n                width = c_idx - stack[-1] - 1\n                area = height * width\n                if area > max_area:\n                    max_area = area\n                    # Calculate bbox relative to subgrid\n                    min_r_rel = r - height + 1\n                    min_c_rel = stack[-1] + 1\n                    max_r_rel = r\n                    max_c_rel = c_idx - 1\n                    best_bbox_relative = (min_r_rel, min_c_rel, max_r_rel, max_c_rel)\n            stack.append(c_idx)\n\n        # Process remaining elements in stack\n        while stack[-1] != -1:\n            height = heights[stack.pop()]\n            width = cols - stack[-1] - 1\n            area = height * width\n            if area > max_area:\n                max_area = area\n                min_r_rel = r - height + 1\n                min_c_rel = stack[-1] + 1\n                max_r_rel = r\n                max_c_rel = cols - 1\n                best_bbox_relative = (min_r_rel, min_c_rel, max_r_rel, max_c_rel)\n\n    if max_area == 0 or best_bbox_relative is None:\n        return None # No rectangle of zeros found\n\n    # Convert relative bbox back to absolute grid coordinates\n    rel_min_r, rel_min_c, rel_max_r, rel_max_c = best_bbox_relative\n    abs_min_r = rel_min_r + c_min_r\n    abs_min_c = rel_min_c + c_min_c\n    abs_max_r = rel_max_r + c_min_r\n    abs_max_c = rel_max_c + c_min_c\n\n    return abs_min_r, abs_min_c, abs_max_r, abs_max_c\n\n\ndef calculate_center(bbox: Optional[Tuple[int, int, int, int]]) -> Optional[Tuple[float, float]]:\n    \"\"\"Calculates the geometric center (row, col) of a bounding box.\"\"\"\n    if bbox is None:\n        return None\n    min_r, min_c, max_r, max_c = bbox\n    center_r = min_r + (max_r - min_r) / 2.0\n    center_c = min_c + (max_c - min_c) / 2.0\n    return center_r, center_c\n\n# =================================\n# Main Transformation Function\n# =================================\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    output_array = np.zeros_like(input_array)\n\n    # --- Step 1: Identify and copy the boundary pattern (value 2) ---\n    boundary_coords = find_cells(input_array, 2)\n    for r, c in boundary_coords:\n        output_array[r, c] = 2\n    boundary_bbox = get_bounding_box(boundary_coords)\n\n    # --- Step 2: Identify the object pattern group (value 5) ---\n    object_relative_coords, object_bbox = get_relative_pattern_group(input_array, 5)\n\n    # If no object pattern, return the grid with only the boundary\n    if not object_relative_coords or object_bbox is None:\n        return output_array.tolist()\n\n    # --- Step 3: Identify the target zone (largest rectangle of 0s within boundary bbox) ---\n    target_zone_bbox = find_largest_zero_rectangle_bbox(input_array, boundary_bbox)\n\n    # If no target zone found (e.g., no boundary, or no zeros inside), return grid with only boundary\n    if target_zone_bbox is None:\n         # Fallback: Could potentially place object back in original spot,\n         # but sticking to rule: if no valid target zone, don't place object.\n         return output_array.tolist()\n\n    # --- Step 4: Calculate centers ---\n    object_center = calculate_center(object_bbox)\n    target_zone_center = calculate_center(target_zone_bbox)\n\n    # Should not happen if checks above passed, but defensive check\n    if object_center is None or target_zone_center is None:\n         return output_array.tolist() # Cannot calculate placement\n\n    # --- Step 5: Calculate target top-left corner for the object group ---\n    # We want object_center to align with target_zone_center.\n    # object_center = object_min_row + object_height / 2.0 (and similar for col)\n    # target_top_left_row + object_height / 2.0 = target_zone_center_row\n    # target_top_left_row = target_zone_center_row - object_height / 2.0\n\n    # Let obj_min_r, obj_min_c be the top-left of the object *in its original position*\n    obj_min_r, obj_min_c, obj_max_r, obj_max_c = object_bbox\n    obj_center_r, obj_center_c = object_center\n    target_center_r, target_center_c = target_zone_center\n\n    # Calculate the offset needed to move the object's original top-left\n    # such that its center aligns with the target center.\n    # offset_r = target_center_r - obj_center_r\n    # offset_c = target_center_c - obj_center_c\n    # target_min_r = obj_min_r + offset_r\n    # target_min_c = obj_min_c + offset_c\n\n    # Round to nearest integer for grid coordinates\n    target_min_r = int(round(obj_min_r + (target_center_r - obj_center_r)))\n    target_min_c = int(round(obj_min_c + (target_center_c - obj_center_c)))\n\n    # --- Step 6: Place the object pattern group onto the output grid ---\n    for rel_r, rel_c in object_relative_coords:\n        # Calculate absolute output coordinates based on the target top-left\n        place_r = target_min_r + rel_r\n        place_c = target_min_c + rel_c\n\n        # Place the object cell (5) if within grid bounds\n        if 0 <= place_r < rows and 0 <= place_c < cols:\n            # Overwrite whatever is there (likely 0, but could be 2 if placement overlaps)\n            # Based on examples, it seems to only land on original 0s,\n            # but centering logic might place it over a 2 in edge cases.\n            # Let's assume overwrite is intended for robust centering.\n            output_array[place_r, place_c] = 5\n\n    # --- Step 7: Return the final grid ---\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 12293,
            "end_index": 12569,
            "uri": "https://github.com/opusdeisong/BOJ",
            "license_": ""
          },
          {
            "start_index": 12453,
            "end_index": 12755,
            "uri": "https://github.com/kaivalyakate/Python-Interview-Repo",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20610,
    "candidates_token_count": 6271,
    "total_token_count": 26881,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 149.683367,
  "retries": 2
}