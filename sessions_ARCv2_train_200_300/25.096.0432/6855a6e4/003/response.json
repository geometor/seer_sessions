{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nThe transformation rule operates on a 2D grid containing integers (0, 2, 5).\nIt identifies a static 'boundary' pattern (value 2) and a mobile 'object' pattern group (value 5).\nThe boundary pattern (2) remains fixed in its original position in the output grid.\nThe object pattern group (5), which may consist of multiple disconnected components, is moved from its original location.\nThe original locations occupied by the object group become background (0).\nThe target location for the object group is determined by identifying the region of background cells (0) located within the bounding box of the boundary pattern (2) in the input grid. This region is termed the 'internal empty space'.\nThe object group (5) is then placed onto the output grid such that the center of its combined bounding box aligns with the center of the bounding box of the identified 'internal empty space'.\nThe relative spatial arrangement of all cells within the object group (5) is preserved during the move.\n\"\"\"\n\ndef find_cells(grid: np.ndarray, value: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of cells with a specific value.\"\"\"\n    rows, cols = np.where(grid == value)\n    return list(zip(rows.tolist(), cols.tolist())) # Ensure standard int tuples\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\n    Returns None if the list is empty.\n    \"\"\"\n    if not coords:\n        return None\n    rows, cols = zip(*coords)\n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef get_relative_pattern_group(grid: np.ndarray, value: int) -> Tuple[List[Tuple[int, int]], Optional[Tuple[int, int, int, int]]]:\n    \"\"\"\n    Finds the pattern of a given value relative to its combined top-left corner.\n    Returns a list of relative coordinates and the combined bounding box.\n    Returns ([], None) if no cells of the value are found.\n    \"\"\"\n    coords = find_cells(grid, value)\n    if not coords:\n        return [], None\n\n    bbox = get_bounding_box(coords)\n    # bbox is guaranteed not None here because coords is not empty\n    min_row, min_col, _, _ = bbox\n\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    return relative_coords, bbox\n\ndef find_internal_zeros(grid: np.ndarray, boundary_value: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds zero cells (0) located within the bounding box of the boundary_value pattern.\n    \"\"\"\n    boundary_coords = find_cells(grid, boundary_value)\n    boundary_bbox = get_bounding_box(boundary_coords)\n\n    if boundary_bbox is None:\n        # If there's no boundary, define \"internal\" as empty? Or all zeros?\n        # Based on examples, boundary seems required for the move. So return empty.\n        return []\n\n    b_min_r, b_min_c, b_max_r, b_max_c = boundary_bbox\n    zero_coords = find_cells(grid, 0)\n\n    # Filter zero cells to include only those strictly within the boundary bounding box\n    # Note: Depending on exact definition, boundary cells themselves might block movement.\n    # Let's stick to the bbox definition first.\n    internal_zeros = [\n        (r, c) for r, c in zero_coords\n        if b_min_r <= r <= b_max_r and b_min_c <= c <= b_max_c\n    ]\n    return internal_zeros\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    output_array = np.zeros_like(input_array)\n\n    # 1. Copy the blue boundary pattern (value 2)\n    blue_coords = find_cells(input_array, 2)\n    for r, c in blue_coords:\n        output_array[r, c] = 2\n\n    # 2. Get the red object pattern group (value 5) details\n    red_relative_coords, red_bbox = get_relative_pattern_group(input_array, 5)\n\n    # If there's no red pattern, we're done (only blue is copied)\n    if not red_relative_coords or red_bbox is None:\n        return output_array.tolist()\n\n    # 3. Identify the internal empty space (zeros within blue bbox)\n    internal_zero_coords = find_internal_zeros(input_array, 2)\n\n    # 4. Get the bounding box of the internal empty space\n    internal_zeros_bbox = get_bounding_box(internal_zero_coords)\n\n    # If there's no internal space (e.g., no blue boundary or no zeros inside),\n    # the red pattern cannot be placed according to the rule. Return grid with blue only.\n    if internal_zeros_bbox is None:\n        # Maybe place red back in original position as fallback?\n        # For now, let's strictly follow the rule: if target space invalid, don't place red.\n         return output_array.tolist()\n\n    # 5. Calculate target top-left corner for the red pattern group\n    r_min_r, r_min_c, r_max_r, r_max_c = red_bbox\n    iz_min_r, iz_min_c, iz_max_r, iz_max_c = internal_zeros_bbox\n\n    # Calculate dimensions of red pattern bbox\n    red_height = r_max_r - r_min_r + 1\n    red_width = r_max_c - r_min_c + 1\n\n    # Calculate center of internal zeros bbox\n    iz_center_r = iz_min_r + (iz_max_r - iz_min_r) / 2.0\n    iz_center_c = iz_min_c + (iz_max_c - iz_min_c) / 2.0\n\n    # Calculate target top-left corner to center the red bbox in the internal zeros bbox\n    target_min_r = int(round(iz_center_r - (red_height - 1) / 2.0))\n    target_min_c = int(round(iz_center_c - (red_width - 1) / 2.0))\n\n    # 6. Place the red pattern group onto the output grid\n    for rel_r, rel_c in red_relative_coords:\n        # Calculate absolute output coordinates\n        place_r = target_min_r + rel_r\n        place_c = target_min_c + rel_c\n\n        # Place the red cell if within grid bounds\n        if 0 <= place_r < rows and 0 <= place_c < cols:\n            # Check for overwriting blue? Examples suggest red only lands on 0s.\n            # Let's assume red overwrites whatever is at the target (likely 0 or maybe blue).\n            # If it must only land on 0s, add: if output_array[place_r, place_c] == 0:\n            output_array[place_r, place_c] = 5\n            # Note: If strict non-overwrite of blue is needed, check:\n            # if output_array[place_r, place_c] != 2: output_array[place_r, place_c] = 5\n\n    # 7. Return the final grid\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18856,
    "candidates_token_count": 2915,
    "total_token_count": 21771,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.537171,
  "retries": 1
}