{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation identifies static blue patterns (value 2) and mobile red patterns (value 5) on a grid.\nThe blue pattern remains fixed in the output grid.\nThe red pattern is moved from its original location in the input grid to a new location in the output grid.\nThe new location for the red pattern is determined by centering its bounding box within the bounding box of the blue pattern.\nThe original locations of the red pattern become background (value 0) in the output grid.\nThe shape and relative arrangement of the red pattern cells are preserved during the move.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple\n\ndef find_cells(grid: np.ndarray, value: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of cells with a specific value.\"\"\"\n    rows, cols = np.where(grid == value)\n    return list(zip(rows, cols))\n\ndef get_bounding_box(coords: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a list of coordinates.\"\"\"\n    if not coords:\n        return (0, 0, 0, 0) # Or handle appropriately, maybe raise error or return None\n    rows, cols = zip(*coords)\n    min_row = min(rows)\n    min_col = min(cols)\n    max_row = max(rows)\n    max_col = max(cols)\n    return min_row, min_col, max_row, max_col\n\ndef get_relative_pattern(grid: np.ndarray, value: int) -> Tuple[List[Tuple[int, int]], Tuple[int, int]]:\n    \"\"\"\n    Finds the pattern of a given value relative to its top-left corner.\n    Returns a list of relative coordinates and the top-left corner (min_row, min_col).\n    \"\"\"\n    coords = find_cells(grid, value)\n    if not coords:\n        return [], (0, 0)\n    min_row, min_col, _, _ = get_bounding_box(coords)\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    return relative_coords, (min_row, min_col)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by moving the red pattern (5) to be centered\n    within the bounding box of the blue pattern (2), keeping the blue pattern fixed.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    output_array = np.zeros_like(input_array)\n\n    # 1. Find blue cells (value 2) and copy them to the output grid.\n    blue_coords = find_cells(input_array, 2)\n    for r, c in blue_coords:\n        output_array[r, c] = 2\n\n    # 2. Find red cells (value 5) in the input grid. Store their relative coordinates and original top-left.\n    red_relative_coords, orig_red_top_left = get_relative_pattern(input_array, 5)\n\n    # If there's no red pattern, return the grid with only the blue pattern.\n    if not red_relative_coords:\n        return output_array.tolist()\n\n    # 3. Find the bounding box of the blue pattern.\n    # If there's no blue pattern, we might need a fallback (e.g., center in grid),\n    # but examples suggest blue is always present when red needs moving.\n    if not blue_coords:\n         # Fallback: If no blue, place red where it was? Or center of grid?\n         # Based on examples, let's assume blue is present if red is.\n         # If needed, handle this case explicitly. For now, proceed assuming blue exists.\n         # Let's just place red back where it was for safety, although this might be wrong.\n         target_red_top_left = orig_red_top_left\n\n    else:\n        blue_min_row, blue_min_col, blue_max_row, blue_max_col = get_bounding_box(blue_coords)\n\n        # 4. Calculate the center coordinates of the blue bounding box.\n        # Use floating point for intermediate center calculation for potentially better accuracy\n        blue_center_row = blue_min_row + (blue_max_row - blue_min_row) / 2\n        blue_center_col = blue_min_col + (blue_max_col - blue_min_col) / 2\n\n        # 5. Calculate the dimensions of the red pattern's bounding box.\n        if red_relative_coords:\n             # Need bounding box of *relative* coordinates to get dimensions\n             red_rel_rows, red_rel_cols = zip(*red_relative_coords)\n             red_height = max(red_rel_rows) - min(red_rel_rows) + 1\n             red_width = max(red_rel_cols) - min(red_rel_cols) + 1\n        else: # Should not happen if we checked earlier, but defensively\n             red_height = 0\n             red_width = 0\n\n        # 6. Calculate the target top-left corner for the red pattern to center it.\n        # Subtract half the red pattern's size (using integer division for grid indices)\n        # Note: min() of relative coords is always (0,0) by definition of get_relative_pattern\n        target_row = int(round(blue_center_row - (red_height -1) / 2)) # Adjust center calculation slightly\n        target_col = int(round(blue_center_col - (red_width - 1) / 2))\n        target_red_top_left = (target_row, target_col)\n\n\n    # 7. Place the red pattern onto the output grid at the calculated target position.\n    for rel_r, rel_c in red_relative_coords:\n        place_r, place_c = target_red_top_left[0] + rel_r, target_red_top_left[1] + rel_c\n        # Ensure placement is within grid bounds\n        if 0 <= place_r < rows and 0 <= place_c < cols:\n            # Check if the target cell is currently 0 (background)\n            # Based on examples, red seems to overwrite 0s inside the blue area.\n            # Let's assume red overwrites whatever is at the target location for now.\n            # If conflict resolution (e.g., red doesn't overwrite blue) is needed, add check here.\n             output_array[place_r, place_c] = 5\n        # else: pattern goes out of bounds - decide how to handle (clip, error, etc.)\n        # Clipping seems reasonable based on similar tasks. Current code implicitly clips.\n\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4127,
    "candidates_token_count": 3137,
    "total_token_count": 7264,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.32599,
  "retries": 1
}