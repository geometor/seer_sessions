{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on identifying specific rectangular regions.\n\nThe transformation rule identifies rectangular regions within the input grid that meet the following criteria:\n1. Bounded by a single, non-zero border color `B`.\n2. The interior of the rectangle contains cells of color `B` and exactly one 'special' cell of a different non-zero color `S` at location `(r_s, c_s)`.\n\nFor each such identified region, the transformation modifies its interior in the output grid:\n1. Cells `(r, c)` inside the region's border are updated.\n2. If a cell `(r, c)` lies on a diagonal line passing through the special cell's location `(r_s, c_s)` (i.e., `abs(r - r_s) == abs(c - c_s)`), its value is set to the special cell's color `S`.\n3. All other interior cells are set to 0.\n\nCells outside these identified regions (background and region borders) remain unchanged.\n\"\"\"\n\ndef _find_regions(input_grid: list[list[int]]) -> list[dict]:\n    \"\"\"\n    Finds all valid regions matching the specified criteria in the grid.\n\n    Args:\n        input_grid: The input 2D list of integers.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a valid region\n        and contains keys: 'coords' (set of (r, c) tuples), 'bbox' (r1, c1, r2, c2),\n        'border_color' (B), 'special_color' (S), 'special_pos' (r_s, c_s).\n    \"\"\"\n    height = len(input_grid)\n    width = len(input_grid[0])\n    visited = set()\n    regions = []\n\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r][c] != 0 and (r, c) not in visited:\n                # Start BFS to find connected component of non-zero cells\n                component_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                colors_in_component = {}\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n                    color = input_grid[curr_r][curr_c]\n                    colors_in_component[color] = colors_in_component.get(color, 0) + 1\n                    \n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           input_grid[nr][nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                # Analyze the component\n                non_zero_colors = {k: v for k, v in colors_in_component.items() if k != 0}\n                \n                if len(non_zero_colors) == 2:\n                    color_list = list(non_zero_colors.keys())\n                    count_list = list(non_zero_colors.values())\n                    \n                    special_color = -1\n                    border_color = -1\n                    special_pos = None\n\n                    if count_list[0] == 1:\n                        special_color = color_list[0]\n                        border_color = color_list[1]\n                    elif count_list[1] == 1:\n                        special_color = color_list[1]\n                        border_color = color_list[0]\n                    else:\n                        continue # Skip if neither color count is 1\n\n                    # Find the special cell position\n                    for cr, cc in component_coords:\n                        if input_grid[cr][cc] == special_color:\n                            special_pos = (cr, cc)\n                            break\n                    \n                    if special_pos is None: continue # Should not happen if counts are correct\n\n                    # Validate the region structure (border and interior)\n                    is_valid = True\n                    bbox = (min_r, min_c, max_r, max_c)\n                    r1, c1, r2, c2 = bbox\n                    \n                    # Check if all component cells on the bbox perimeter are border_color\n                    # Check if all interior cells are border_color or the special cell\n                    for br, bc in component_coords:\n                        is_on_perimeter = (br == r1 or br == r2 or bc == c1 or bc == c2)\n                        is_interior = (r1 < br < r2 and c1 < bc < c2)\n                        \n                        cell_color = input_grid[br][bc]\n\n                        if is_on_perimeter:\n                             # Check if part of the rectangle defined by bbox.\n                             # Cells on corners might be tricky, ensure they belong to this component's border.\n                             # A simpler check: ensure all cells *within* the bbox that are *not* part of the component are 0.\n                             pass # Defer comprehensive border check\n                        \n                        if is_interior:\n                            if (br, bc) == special_pos:\n                                if cell_color != special_color:\n                                    is_valid = False\n                                    break\n                            elif cell_color != border_color:\n                                is_valid = False\n                                break\n                        \n                        # If a cell is neither on perimeter nor interior (e.g., concave shape), it might invalidate\n                        # Let's assume rectangularity for now based on examples. A stricter check is needed for general cases.\n\n                    # A more robust check: Iterate all cells within bbox\n                    component_cell_count_in_bbox = 0\n                    for ir in range(r1, r2 + 1):\n                        for ic in range(c1, c2 + 1):\n                             cell_color = input_grid[ir][ic]\n                             is_on_border = (ir == r1 or ir == r2 or ic == c1 or ic == c2)\n\n                             if (ir, ic) in component_coords:\n                                 component_cell_count_in_bbox += 1\n                                 # Check border cells have border_color\n                                 if is_on_border and cell_color != border_color:\n                                     is_valid = False; break\n                                 # Check interior cells\n                                 if not is_on_border:\n                                     if (ir, ic) == special_pos:\n                                         if cell_color != special_color: is_valid = False; break\n                                     elif cell_color != border_color:\n                                         is_valid = False; break\n                             else:\n                                 # Cells within bbox but not in component must be 0\n                                 if cell_color != 0:\n                                     is_valid = False; break\n                        if not is_valid: break\n                    \n                    # Final check: ensure the component size matches the count within bbox\n                    if len(component_coords) != component_cell_count_in_bbox:\n                        is_valid = False\n\n                    if is_valid:\n                        regions.append({\n                            'coords': component_coords,\n                            'bbox': bbox,\n                            'border_color': border_color,\n                            'special_color': special_color,\n                            'special_pos': special_pos\n                        })\n\n    return regions\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    \n    # Find all valid regions in the input grid\n    regions = _find_regions(input_grid)\n\n    # Perform transformations for each identified region\n    for region in regions:\n        r1, c1, r2, c2 = region['bbox']\n        r_s, c_s = region['special_pos']\n        s_color = region['special_color']\n\n        # Iterate through the interior cells of the region's bounding box\n        for r in range(r1 + 1, r2):\n            for c in range(c1 + 1, c2):\n                # Check if the cell belongs to this specific region's interior \n                # (necessary if regions could overlap or be adjacent, though not seen in examples)\n                # This check is implicitly handled by the region finding logic ensuring\n                # components are distinct and structure is valid.\n\n                # Calculate distance from the special cell\n                dr = abs(r - r_s)\n                dc = abs(c - c_s)\n\n                # Apply the 'X' pattern rule\n                if dr == dc:\n                    output_grid[r][c] = s_color\n                else:\n                    output_grid[r][c] = 0  # Set other interior cells to background color\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4124,
    "candidates_token_count": 4329,
    "total_token_count": 8453,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 123.492247,
  "retries": 2
}