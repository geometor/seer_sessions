
## train_1

**input:**
```
0 0 0 0 0 0 0 8 8 8 8
0 0 0 0 0 0 0 8 0 0 8
0 0 8 8 8 0 0 8 8 8 8
0 0 8 0 8 0 0 0 0 0 0
0 0 8 8 8 0 8 8 8 0 0
0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 8 8 8 0 0
```


**output:**
```
0 0 0 0 0 0 0 1 1 1 1
0 0 0 0 0 0 0 1 0 0 1
0 0 1 1 1 0 0 1 1 1 1
0 0 1 0 1 0 0 0 0 0 0
0 0 1 1 1 0 3 3 3 0 0
0 0 0 0 0 0 3 0 3 0 0
0 0 0 0 0 0 3 3 3 0 0
0 0 0 0 0 0 3 0 3 0 0
0 0 0 0 0 0 3 3 3 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 8 0 8 0 0 0 0
0 0 8 8 8 8 8 0 0 0 0
0 0 8 0 8 0 0 0 8 8 8
0 0 8 0 8 0 0 0 8 0 8
0 0 8 8 8 0 0 0 8 8 8
0 0 0 0 0 0 0 0 0 0 0
8 8 8 0 0 0 0 0 0 0 0
8 0 8 0 0 0 8 8 8 8 0
8 8 8 8 8 0 8 0 0 8 0
8 0 0 0 8 0 8 0 0 8 0
8 8 8 8 8 0 8 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0
0 0 2 0 2 0 2 0 0 0 0
0 0 2 2 2 2 2 0 0 0 0
0 0 2 0 2 0 0 0 1 1 1
0 0 2 0 2 0 0 0 1 0 1
0 0 2 2 2 0 0 0 1 1 1
0 0 0 0 0 0 0 0 0 0 0
3 3 3 0 0 0 0 0 0 0 0
3 0 3 0 0 0 1 1 1 1 0
3 3 3 3 3 0 1 0 0 1 0
3 0 0 0 3 0 1 0 0 1 0
3 3 3 3 3 0 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 8 8 8 8 8 0 0 8 0 8 0 0
0 0 8 0 0 0 8 0 0 8 8 8 0 0
0 0 8 8 8 8 8 0 0 8 0 8 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 8 0 8 0 0
0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 8 8 8 0 0 0 0 0 0
0 0 0 8 8 8 0 8 0 0 0 0 0 0
0 0 0 8 0 8 0 8 0 0 0 0 0 0
0 0 0 8 8 8 0 8 0 0 8 8 8 0
0 0 0 0 0 8 8 8 0 0 8 0 8 0
0 0 0 0 0 0 0 0 0 0 8 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 1 1 1 1 1 0 0 2 0 2 0 0
0 0 1 0 0 0 1 0 0 2 2 2 0 0
0 0 1 1 1 1 1 0 0 2 0 2 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 0 0 0 0 0 0 2 0 2 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 3 3 3 0 3 0 0 0 0 0 0
0 0 0 3 0 3 0 3 0 0 0 0 0 0
0 0 0 3 3 3 0 3 0 0 1 1 1 0
0 0 0 0 0 3 3 3 0 0 1 0 1 0
0 0 0 0 0 0 0 0 0 0 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 8 8 8 0 0 0 0 0 0 0 0 0
0 0 8 0 8 8 8 8 8 8 8 8 0 0
0 0 8 8 8 0 8 0 0 8 0 8 0 0
0 0 0 0 8 8 8 8 8 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 0 0 0 0 8 8 8 8 0
0 8 0 0 8 0 0 0 0 8 0 0 8 0
0 8 8 8 8 0 0 0 0 8 0 0 8 0
0 8 0 0 8 0 0 0 8 8 8 8 8 0
0 8 8 8 8 0 0 0 8 0 8 0 0 0
0 0 0 0 0 0 0 0 8 8 8 8 0 0
0 0 8 8 8 0 0 0 8 0 0 8 0 0
0 0 8 0 8 0 0 0 8 8 8 8 0 0
0 0 8 8 8 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 4 4 4 0 0 0 0 0 0 0 0 0
0 0 4 0 4 4 4 4 4 4 4 4 0 0
0 0 4 4 4 0 4 0 0 4 0 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 0 0 0 0 2 2 2 2 0
0 3 0 0 3 0 0 0 0 2 0 0 2 0
0 3 3 3 3 0 0 0 0 2 0 0 2 0
0 3 0 0 3 0 0 0 2 2 2 2 2 0
0 3 3 3 3 0 0 0 2 0 2 0 0 0
0 0 0 0 0 0 0 0 2 2 2 2 0 0
0 0 1 1 1 0 0 0 2 0 0 2 0 0
0 0 1 0 1 0 0 0 2 2 2 2 0 0
0 0 1 1 1 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The input is a 2D grid containing digits 0 and 8. The output is a 2D grid of the same dimensions, containing digits 0, 1, 2, 3, or 4. The digit 8 in the input seems to form distinct shapes or components. These components of 8s are replaced by other digits (1-4) in the output grid, while the 0s generally remain 0s. The key transformation appears to involve identifying these connected components of 8s and assigning a new digit to each component based on some property.

*   **Analysis:** By comparing input and output grids across the examples, we can observe the following:
    *   Connected components of '8' cells (sharing an edge or corner - 8-connectivity seems implied by the shapes) in the input are treated as single units.
    *   Each distinct component of '8's in the input is replaced by a *single*, uniform digit in the output.
    *   The background '0's from the input remain '0's in the output, *unless* they are fully enclosed within a component of 8s.
    *   The digit assigned to replace a component (1, 2, 3, or 4) appears to correspond to the number of '0' cells that are topologically enclosed within that component's boundary.
    *   For instance, in `train_1`, the top-right component encloses one '0' and becomes '1's. The bottom-right component encloses three '0's and becomes '3's. This pattern holds for all examples.

*   **YAML Facts:**
    
```yaml
    Task: Color connected components based on enclosed area count.

    Objects:
      - Grid: A 2D array of cells.
        - Properties: dimensions (rows, cols), cells.
      - Cell: An element within the Grid.
        - Properties: value (digit), position (row, col).
      - Component: A connected group of cells with value 8.
        - Properties: set of cell positions, connectivity (adjacent/diagonal), boundary, enclosed_cells.
      - Enclosed Cell: A cell with value 0 surrounded by a Component.
        - Properties: position.

    Relationships:
      - Cells are part of a Grid.
      - Cells with value 8 can belong to a Component.
      - Cells are connected if they are adjacent horizontally, vertically, or diagonally (8-connectivity).
      - A Component can enclose Cells with value 0.

    Input Properties:
      - Contains cells with values 0 and 8.
      - Cells with value 8 form one or more connected Components.

    Output Properties:
      - Same dimensions as input Grid.
      - Cells originally 0 remain 0.
      - Cells originally 8 are replaced by a digit N (1 to 4).
      - All cells belonging to the same input Component are replaced by the same digit N.
      - The digit N corresponds to the count of 0-valued cells fully enclosed by that specific Component in the input grid.

    Transformation:
      - Identify connected components of cells with value 8 in the input grid.
      - For each identified component:
        - Determine the set of cells with value 0 that are fully enclosed by this component. Treat the grid edges as non-enclosing boundaries.
        - Count the number of these enclosed 0-cells (let the count be N).
        - Create the output grid, initially a copy of the input or filled with 0s.
        - Replace the value of all cells belonging to the current component with the calculated count N in the output grid.
      - Ensure background 0s from the input remain 0s in the output.
    ```


*   **Natural Language Program:**
    1.  Initialize an empty output grid with the same dimensions as the input grid, filled with zeros.
    2.  Create a 'visited' grid of the same dimensions, initialized to false, to keep track of processed '8' cells.
    3.  Iterate through each cell (row `r`, column `c`) of the input grid.
    4.  If the cell at (`r`, `c`) contains an '8' and has not been visited:
        a.  Start a search (e.g., Breadth-First Search or Depth-First Search) from this cell to find all connected '8' cells (using 8-connectivity: horizontal, vertical, and diagonal neighbors). Mark each found '8' cell as visited. Store the coordinates of all cells belonging to this component.
        b.  Identify all '0' cells that are candidates for being enclosed. A simple approach is to consider all '0' cells within the bounding box of the component, or potentially all '0's in the grid.
        c.  For each candidate '0' cell, determine if it is fully enclosed by the current component. This can be done by checking if a path from this '0' cell to the grid boundary exists without crossing any '8' cell of the *current* component. A flood fill starting from the '0' cell, restricted from entering cells of the current component, can check if it reaches the boundary. If it cannot reach the boundary, it is enclosed.
        d.  Count the number of such enclosed '0' cells (let the count be `N`).
        e.  Iterate through all the cell coordinates previously stored for this component and set the value of the corresponding cells in the output grid to `N`.
    5.  After iterating through all cells in the input grid, return the completed output grid.
```python
import numpy as np
from collections import deque

"""
Identifies connected components of '8' cells (using 8-way connectivity) in the input grid.
For each component, it counts the number of '0' cells that are topologically enclosed by that component.
The output grid replaces all cells of a component with the count of its enclosed '0' cells.
'0' cells in the input remain '0' in the output unless they are enclosed. 
However, the standard interpretation is that only the '8's are replaced, and background '0's remain '0'. 
The examples show that enclosed '0's are NOT filled.
The transformation rule is: Find connected components of 8s. For each component, count the number of 0s fully surrounded by it (cannot reach the grid boundary without crossing the component). Replace the 8s of that component with this count. Keep original 0s as 0s.
"""

def find_component(start_r, start_c, grid, visited, rows, cols):
    """Finds all connected '8' cells using BFS (8-connectivity)."""
    if visited[start_r, start_c] or grid[start_r, start_c] != 8:
        return set()

    component_coords = set()
    queue = deque([(start_r, start_c)])
    visited[start_r, start_c] = True

    while queue:
        r, c = queue.popleft()
        component_coords.add((r, c))

        # Check 8 neighbors (horizontal, vertical, diagonal)
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue # Skip self
                nr, nc = r + dr, c + dc

                # Check bounds and if neighbor is an unvisited '8'
                if 0 <= nr < rows and 0 <= nc < cols and \
                   grid[nr, nc] == 8 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    queue.append((nr, nc))

    return component_coords

def count_enclosed_zeros(component_coords, grid, rows, cols):
    """Counts '0' cells enclosed by the component using flood fill from the boundary."""
    # Create a temporary grid where component cells are barriers (1)
    # and other cells (including original 0s and other 8s) are passable (0).
    temp_grid = np.zeros_like(grid)
    component_set = set(component_coords)
    for r in range(rows):
        for c in range(cols):
            if (r, c) in component_set:
                temp_grid[r, c] = 1 # Mark component cells as barriers

    # Initialize reachable grid and queue for BFS (flood fill from outside)
    reachable = np.zeros_like(grid, dtype=bool)
    queue = deque()

    # Add all boundary cells that are NOT part of the component barrier to the queue
    for r in range(rows):
        for c in [0, cols - 1]: # Left and Right edges
            if temp_grid[r, c] == 0 and not reachable[r, c]:
                reachable[r, c] = True
                queue.append((r, c))
    for c in range(1, cols - 1): # Top and Bottom edges (avoid corners again)
        for r in [0, rows - 1]:
             if temp_grid[r, c] == 0 and not reachable[r, c]:
                reachable[r, c] = True
                queue.append((r, c))

    # Perform BFS using 4-connectivity for reachability of '0' spaces
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4 directions
            nr, nc = r + dr, c + dc
            # Check bounds, if passable (not component barrier), and not already reached
            if 0 <= nr < rows and 0 <= nc < cols and \
               temp_grid[nr, nc] == 0 and not reachable[nr, nc]:
                reachable[nr, nc] = True
                queue.append((nr, nc))

    # Count original '0' cells that are not reachable from the outside
    enclosed_count = 0
    for r in range(rows):
        for c in range(cols):
            # Must be originally '0' and not reachable from boundary
            if grid[r, c] == 0 and not reachable[r, c]:
                 enclosed_count += 1

    return enclosed_count


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the grid by replacing connected components of 8s with the count
    of 0s they enclose.
    """
    # Convert to numpy array for easier manipulation
    grid_np = np.array(input_grid, dtype=int)
    rows, cols = grid_np.shape

    # Initialize output grid with zeros
    output_grid = np.zeros_like(grid_np)
    # Keep track of visited '8' cells to avoid processing components multiple times
    visited = np.zeros_like(grid_np, dtype=bool)

    # Iterate through each cell of the grid
    for r in range(rows):
        for c in range(cols):
            # If we find an '8' that hasn't been visited yet, it's the start of a new component
            if grid_np[r, c] == 8 and not visited[r, c]:
                # 1. Find all cells belonging to this component
                component_coords = find_component(r, c, grid_np, visited, rows, cols)

                # 2. Count the number of '0' cells enclosed by this component
                # Make sure component_coords is not empty (shouldn't happen with check above, but safe)
                if component_coords:
                    enclosed_count = count_enclosed_zeros(component_coords, grid_np, rows, cols)

                    # 3. Fill the component's area in the output grid with the count
                    for comp_r, comp_c in component_coords:
                        output_grid[comp_r, comp_c] = enclosed_count

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
