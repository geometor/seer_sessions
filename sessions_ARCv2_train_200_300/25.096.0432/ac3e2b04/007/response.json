{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\n\n\"\"\"\nTransforms the input grid based on connectivity from the border.\nA flood fill (BFS) starts from all background cells (0) on the grid's border.\nThis fill propagates through adjacent background (0) and pattern (3) cells,\nbut is blocked by barrier (2) cells.\nAny background cell (0) that is *not* reached by this fill is considered \"enclosed\".\nThese enclosed background cells (0) are changed to 1 in the output.\nAdditionally, any barrier cell (2) in the input that is adjacent (up, down, left, or right) \nto at least one of these enclosed background cells (originally 0, now becoming 1) is also changed to 1 in the output.\nAll other cells (border-connected 0s, all 3s, and 2s not adjacent to enclosed 0s) \nretain their original values.\n\"\"\"\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid: A 2D list of integers representing the input grid.\n\n    Returns:\n        A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    \n    # Get grid dimensions\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    # --- Step 1: Flood Fill from Border ---\n    # Initialize a grid to keep track of cells reachable from the border\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    # Initialize a queue for Breadth-First Search (BFS)\n    queue = collections.deque()\n\n    # Seed the BFS queue with all '0' cells located on the grid's border\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the cell is on the border\n            is_border = (r == 0 or r == rows - 1 or c == 0 or c == cols - 1)\n            # If it's a border cell, is background (0), and hasn't been visited yet\n            if is_border and input_grid[r][c] == 0 and not visited[r][c]:\n                queue.append((r, c)) # Add to queue for BFS\n                visited[r][c] = True # Mark as visited (reachable from border)\n\n    # Define the four cardinal directions for exploring neighbors\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Perform the BFS to find all cells reachable from border '0's\n    while queue:\n        r, c = queue.popleft() # Get the next cell to explore from\n\n        # Explore neighbors in the four cardinal directions\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor is NOT a barrier (value 2)\n                # Check if the neighbor has NOT been visited yet\n                if input_grid[nr][nc] != 2 and not visited[nr][nc]:\n                    # Mark the neighbor as visited (reachable)\n                    visited[nr][nc] = True\n                    # Add the neighbor to the queue to continue the search from it\n                    # Note: The search propagates through both 0s and 3s if they aren't barriers\n                    queue.append((nr, nc))\n\n    # --- Step 2: Identify Target 0s (Enclosed Background Cells) ---\n    # Create a set to store the coordinates of enclosed '0' cells\n    target_zeros = set()\n    for r in range(rows):\n        for c in range(cols):\n            # If a cell is background (0) in the input AND was NOT visited by the BFS\n            if input_grid[r][c] == 0 and not visited[r][c]:\n                # It's an enclosed '0', add its coordinates to the set\n                target_zeros.add((r, c))\n\n    # --- Step 3: Identify Target 2s (Barrier cells adjacent to enclosed 0s) ---\n    # Create a set to store the coordinates of barrier cells that need changing\n    target_twos = set()\n    for r in range(rows):\n        for c in range(cols):\n            # Consider only barrier cells (value 2)\n            if input_grid[r][c] == 2:\n                # Check its neighbors to see if any are enclosed '0's\n                is_adjacent_to_target_zero = False\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    # Check if the neighbor is within bounds AND its coordinates are in the target_zeros set\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       (nr, nc) in target_zeros:\n                        is_adjacent_to_target_zero = True\n                        break # Found an adjacent enclosed zero, no need to check other neighbors\n\n                # If this barrier cell was adjacent to at least one enclosed '0'\n                if is_adjacent_to_target_zero:\n                    # Add its coordinates to the target_twos set\n                    target_twos.add((r, c))\n\n    # --- Step 4: Create and Modify Output Grid ---\n    # Start with a copy of the input grid. This preserves original 3s, border-connected 0s, and non-adjacent 2s.\n    output_grid = copy.deepcopy(input_grid)\n\n    # Modify the enclosed '0's\n    for r, c in target_zeros:\n        output_grid[r][c] = 1 # Change value to 1\n        \n    # Modify the adjacent '2's\n    for r, c in target_twos:\n        output_grid[r][c] = 1 # Change value to 1\n\n    # --- Step 5: Return the Result ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12602,
    "candidates_token_count": 2201,
    "total_token_count": 14803,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 106.810267,
  "retries": 2
}