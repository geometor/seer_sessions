
## train_1

**input:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 3 3 3 0 0 0
2 2 2 2 3 2 3 2 2 2
0 0 0 0 3 3 3 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0
2 2 2 2 1 2 1 2 2 2
0 0 0 0 1 1 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
```


## train_2

**input:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 3 2 3 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 3 2 3 0
0 0 0 2 0 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


**output:**
```
0 0 0 2 0 0 0 0 0 2 0 0
0 0 3 3 3 0 0 0 1 1 1 0
1 1 3 2 3 1 1 1 1 2 1 1
0 0 3 3 3 0 0 0 1 1 1 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 1 1 1 0 0 0 3 3 3 0
1 1 1 2 1 1 1 1 3 2 3 1
0 0 1 1 1 0 0 0 3 3 3 0
0 0 0 2 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0
```


## train_3

**input:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 3 2 3 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0
1 1 1 3 2 3 1 1 1 1 1 1
0 0 0 3 3 3 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 0 0 0 0 0 0 0 0
2 2 2 3 2 3 2 2 2 2 2 2 2 2
0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 2 2 2 2 2 2 2 2 2 2 2 2 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 0 0
2 2 2 2 2 2 2 2 2 3 2 3 2 2
0 0 0 0 0 0 0 0 0 3 3 3 0 0
```


**output:**
```
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 3 3 3 0 0 0 1 1 1 0 0
2 2 2 3 2 3 2 2 2 1 2 1 2 2
0 0 0 3 3 3 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 1 1 1 0 0
2 2 2 1 2 1 2 2 2 1 2 1 2 2
0 0 0 1 1 1 0 0 0 1 1 1 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 0 1 0 0 0 0 0 1 0 0 0
0 0 0 1 1 1 0 0 0 3 3 3 0 0
2 2 2 1 2 1 2 2 2 3 2 3 2 2
0 0 0 1 1 1 0 0 0 3 3 3 0 0
```

Okay, let's break down this task.

**Perception:**

1.  **Grid Structure:** The task operates on 2D grids containing numerical values (0, 2, 3 initially, with 1 appearing in the output).
2.  **Color Roles:**
    *   `0`: Appears to be the background or empty space.
    *   `2`: Forms solid lines or boundaries within the grid. These lines persist from input to output.
    *   `3`: Forms specific patterns (like small 'H' shapes, often centered around a `2`). These patterns also persist from input to output.
    *   `1`: This color exclusively appears in the output grid. It replaces some of the `0`s from the input.
3.  **Core Transformation:** The fundamental change is the conversion of certain `0` cells into `1` cells.
4.  **Spatial Relationship:** The `1`s appear in regions that seem "enclosed" or "internal". The boundaries of these regions are primarily formed by the `2`s and potentially the grid edges. The `3` patterns exist within or near these regions but don't block the transformation of `0`s to `1`s.
5.  **Mechanism:** The transformation behaves like a "fill" operation. Specifically, it identifies `0` cells that are *not* connected to the outer border of the grid via a path of other `0`s. The `2`s act as impassable barriers for this connectivity check.

**YAML Facts:**


```yaml
task_type: grid_transformation
input_elements:
  - type: grid
    dtype: integer
    colors: [0, 2, 3]
output_elements:
  - type: grid
    dtype: integer
    colors: [0, 1, 2, 3]
objects:
  - id: background
    value: 0
    role: fillable_space, boundary_connected_space
  - id: boundary
    value: 2
    role: immutable_structure, fill_barrier
  - id: pattern
    value: 3
    role: immutable_structure
  - id: filled_space
    value: 1
    role: output_only, indicates_enclosed_background
relationships:
  - type: spatial_connectivity
    from: background (0)
    to: background (0)
    description: Background cells can be adjacent horizontally or vertically.
  - type: blocking
    blocker: boundary (2)
    blocked: spatial_connectivity between background (0) cells
  - type: adjacency
    element1: pattern (3)
    element2: boundary (2)
    description: Patterns (3) are often adjacent to boundaries (2).
actions:
  - action: identify_border_connected_zeros
    description: Find all background (0) cells that can reach the grid edge by moving only through other background (0) cells.
    constraints: Movement is blocked by boundary (2) cells.
  - action: replace_unconnected_zeros
    target: background (0) cells not identified in the previous step
    result: change cell value to filled_space (1)
  - action: preserve_cells
    target: boundary (2) cells, pattern (3) cells, border_connected_zeros
    result: cell value remains unchanged in the output

```


**Natural Language Program:**

1.  Initialize the output grid as an identical copy of the input grid.
2.  Identify all background cells (value `0`) located on the outermost border (top row, bottom row, leftmost column, rightmost column) of the input grid.
3.  Perform a flood fill or connectivity search (like BFS or DFS) starting simultaneously from *all* these border background cells.
4.  This search should only propagate through adjacent (up, down, left, right) background cells (value `0`). Cells with value `2` act as barriers and cannot be entered or traversed. Cells with value `3` do not act as barriers. Mark all reachable background cells during this search.
5.  After the search is complete, iterate through every cell in the input grid.
6.  If a cell contains a background value (`0`) but was *not* marked as reachable during the border flood fill search, change its value in the output grid to `1`.
7.  All other cells (original `2`s, `3`s, and the `0`s that *were* reachable from the border) retain their original values in the output grid.
8.  The final modified grid is the result.
```python
"""
Transforms the input grid by identifying background cells (0) that are not connected 
to the grid's border via a path of other background cells. These unconnected 
background cells are then changed to 1. Cells with value 2 act as barriers, 
blocking the path connection. Cells with values 2 and 3 remain unchanged.
"""

import collections
import copy

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the flood fill transformation rule.

    Args:
        input_grid: A 2D list representing the input grid.

    Returns:
        A 2D list representing the transformed output grid.
    """
    
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # Initialize output_grid as a deep copy of the input
    output_grid = copy.deepcopy(input_grid)
    
    # Create a visited grid to keep track of cells reachable from the border
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    
    # Initialize a queue for Breadth-First Search (BFS)
    queue = collections.deque()

    # Seed the BFS with all '0' cells on the border
    for r in range(rows):
        for c in range(cols):
            # Check if the cell is on the border
            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:
                # Check if the cell is background (0) and not already visited
                if input_grid[r][c] == 0 and not visited[r][c]:
                    queue.append((r, c))
                    visited[r][c] = True

    # Define the four cardinal directions for neighbors
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    # Perform BFS to find all '0' cells connected to the border
    while queue:
        r, c = queue.popleft()

        # Explore neighbors
        for dr, dc in directions:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within grid bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is background (0), not a barrier (2), and not visited
                if input_grid[nr][nc] != 2 and not visited[nr][nc]:
                    visited[nr][nc] = True
                    # Only continue the search from background cells
                    if input_grid[nr][nc] == 0:
                        queue.append((nr, nc))


    # Iterate through the grid and change unconnected '0's to '1's
    for r in range(rows):
        for c in range(cols):
            # If a cell is background (0) in the input but was not visited by the BFS
            if input_grid[r][c] == 0 and not visited[r][c]:
                # Change its value to 1 in the output grid
                output_grid[r][c] = 1

    return output_grid
```
```python
import collections
import copy

"""
Transforms the input grid by identifying background cells (value 0) that are "enclosed" and not connected to the grid's outer border via a path of other background cells (0) or pattern cells (3). Cells with value 2 act as impassable barriers for this connectivity check. All enclosed background cells (0) are changed to value 1 in the output. Cells with values 2 and 3, and background cells connected to the border, remain unchanged.
"""

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies a flood fill from the border to identify and change enclosed '0' cells to '1'.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # Initialize output_grid as a deep copy of the input
    # This ensures that original values (especially 2s and 3s) are preserved unless explicitly changed
    output_grid = copy.deepcopy(input_grid)
    
    # Create a visited grid to keep track of cells reachable from the border
    # Initialize all cells as not visited
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    
    # Initialize a queue for Breadth-First Search (BFS)
    queue = collections.deque()

    # Seed the BFS with all '0' cells located on the border
    # These are the starting points for determining reachability from the outside
    for r in range(rows):
        for c in range(cols):
            # Check if the cell is on the border (first/last row or first/last column)
            is_border = (r == 0 or r == rows - 1 or c == 0 or c == cols - 1)
            # Check if the border cell is background (0) and not already visited (unlikely here, but good practice)
            if is_border and input_grid[r][c] == 0 and not visited[r][c]:
                queue.append((r, c))
                visited[r][c] = True # Mark this border '0' cell as visited

    # Define the four cardinal directions (up, down, left, right) for exploring neighbors
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    # Perform BFS starting from the border '0' cells
    # The goal is to mark all cells (0s and 3s) that are reachable from the border without crossing a '2'
    while queue:
        r, c = queue.popleft() # Get the next cell to explore from

        # Explore its neighbors
        for dr, dc in directions:
            nr, nc = r + dr, c + dc

            # Check 1: Is the neighbor within the grid boundaries?
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check 2: Is the neighbor NOT a barrier (value 2)?
                # Check 3: Has the neighbor NOT been visited yet?
                if input_grid[nr][nc] != 2 and not visited[nr][nc]:
                    # If all checks pass, mark the neighbor as visited
                    visited[nr][nc] = True
                    # Add the neighbor to the queue to continue the search *from* this neighbor
                    # The search propagates through both 0s and 3s
                    queue.append((nr, nc))

    # Iterate through the entire grid after the BFS is complete
    for r in range(rows):
        for c in range(cols):
            # Identify cells that meet two conditions:
            # 1. They were originally background cells (value 0) in the input.
            # 2. They were *not* reached (visited) by the BFS starting from the border.
            # These are the "enclosed" background cells.
            if input_grid[r][c] == 0 and not visited[r][c]:
                # Change the value of these enclosed background cells to 1 in the output grid
                output_grid[r][c] = 1
            # All other cells (original 2s, 3s, and the 0s that *were* visited) 
            # retain their values because output_grid started as a copy.

    # Return the modified grid
    return output_grid
```
```python
import collections
import copy

"""
Transforms the input grid based on connectivity from the border.
A flood fill (BFS) starts from all background cells (0) on the grid's border.
This fill propagates through adjacent background (0) and pattern (3) cells,
but is blocked by barrier (2) cells.
Any background cell (0) that is *not* reached by this fill is considered "enclosed".
These enclosed background cells (0) are changed to 1 in the output.
Additionally, any barrier cell (2) in the input that is adjacent (up, down, left, or right) 
to at least one of these enclosed background cells (0) is also changed to 1 in the output.
All other cells (border-connected 0s, all 3s, and 2s not adjacent to enclosed 0s) 
retain their original values.
"""

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the described transformation to the input grid.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # 1. Flood Fill from Border
    # Initialize a visited grid to keep track of cells reachable from the border
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    # Initialize a queue for Breadth-First Search (BFS)
    queue = collections.deque()

    # Seed the BFS with all '0' cells on the border
    for r in range(rows):
        for c in range(cols):
            is_border = (r == 0 or r == rows - 1 or c == 0 or c == cols - 1)
            if is_border and input_grid[r][c] == 0 and not visited[r][c]:
                queue.append((r, c))
                visited[r][c] = True

    # Define directions for neighbors
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    # Perform BFS
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            # Check bounds, barrier condition (not 2), and visited status
            if 0 <= nr < rows and 0 <= nc < cols and \
               input_grid[nr][nc] != 2 and not visited[nr][nc]:
                visited[nr][nc] = True
                queue.append((nr, nc)) # Continue BFS from this newly visited cell

    # 2. Identify Target 0s (Enclosed 0s)
    target_zeros = set()
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] == 0 and not visited[r][c]:
                target_zeros.add((r, c))

    # 3. Identify Target 2s (Barrier cells adjacent to enclosed 0s)
    target_twos = set()
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] == 2:
                # Check neighbors
                is_adjacent_to_target_zero = False
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    # Check bounds and if neighbor is in target_zeros
                    if 0 <= nr < rows and 0 <= nc < cols and \
                       (nr, nc) in target_zeros:
                        is_adjacent_to_target_zero = True
                        break # Found one adjacent target zero, no need to check more neighbors
                
                if is_adjacent_to_target_zero:
                    target_twos.add((r, c))

    # 4. Create Output Grid
    output_grid = copy.deepcopy(input_grid)

    # 5. Fill Target 0s
    for r, c in target_zeros:
        output_grid[r][c] = 1
        
    # 6. Fill Target 2s
    for r, c in target_twos:
        output_grid[r][c] = 1

    # 7. Return final grid
    return output_grid
```
