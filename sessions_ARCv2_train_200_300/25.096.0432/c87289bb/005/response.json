{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms the input grid by identifying a top block of identical rows and using \npatterns within this block and the locations of '2's below it to determine \nwhich columns should be filled vertically with '8's below the block.\n\n1. Identify the initial block of identical rows at the top ('Header Block').\n2. Find columns containing '8' within this Header Block ('Header8Cols').\n3. Find columns containing '2' anywhere in the grid ('TwoCols').\n4. Find columns immediately adjacent to any column in 'TwoCols' ('NeighboursOfTwoCols').\n5. Determine neighbour columns that don't contain '2's themselves ('NeighboursToFill').\n6. Combine 'Header8Cols' and 'NeighboursToFill' to get the final set of columns \n   to modify ('TargetFillCols').\n7. Below the Header Block, iterate through the 'TargetFillCols' and change any '0's \n   to '8's, preserving existing non-zero values like '2'.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_last_top_row(grid: list[list[int]]) -> int:\n    \"\"\"\n    Finds the index of the last row belonging to the initial block of identical top rows.\n    \"\"\"\n    if not grid:\n        return -1\n    if len(grid) == 1:\n        return 0\n\n    first_row = grid[0]\n    last_top_row = 0\n    for r in range(1, len(grid)):\n        # Check for row length consistency before comparing content\n        if len(grid[r]) == len(first_row) and grid[r] == first_row:\n            last_top_row = r\n        else:\n            break\n    return last_top_row\n\ndef get_cols_with_value_in_rows(grid: list[list[int]], value: int, start_row: int, end_row_inclusive: int) -> set[int]:\n    \"\"\"\n    Finds the indices of columns containing the specified value within the specified row range.\n    \"\"\"\n    cols = set()\n    if not grid or not grid[0]: return cols\n    num_cols = len(grid[0]) # Assume rectangular grid for simplicity based on examples\n    \n    # Adjust end_row_inclusive to be within grid bounds\n    actual_end_row = min(end_row_inclusive, len(grid) - 1)\n    \n    for c in range(num_cols):\n        for r in range(start_row, actual_end_row + 1):\n             # Check column index is valid for the current row\n            if c < len(grid[r]) and grid[r][c] == value:\n                cols.add(c)\n                break # Found in this column, move to next column\n    return cols\n\ndef get_cols_with_value_anywhere(grid: list[list[int]], value: int) -> set[int]:\n    \"\"\"\n    Finds the indices of columns containing the specified value anywhere in the grid.\n    \"\"\"\n    cols = set()\n    if not grid: return cols\n    num_rows = len(grid)\n    if num_rows == 0 or not grid[0]: return cols\n    num_cols = len(grid[0]) # Assume rectangular\n\n    for r in range(num_rows):\n         for c in range(num_cols):\n             # Check column index is valid for the current row\n             if c < len(grid[r]) and grid[r][c] == value:\n                 cols.add(c)\n                 # Optimization: If we only care if the column *ever* contains the value,\n                 # we could potentially break to the next column earlier, but checking\n                 # all rows is safer if we later need counts or positions.\n                 # For just identifying columns, we can make this faster:\n                 # Add c to cols and break the inner loop 'for c in range(num_cols):'\n                 # This requires restructuring the loops (iterate rows first).\n\n    # Alternative (potentially faster if value is sparse)\n    # for c in range(num_cols):\n    #     for r in range(num_rows):\n    #         if c < len(grid[r]) and grid[r][c] == value:\n    #             cols.add(c)\n    #             break # Move to next column\n\n    return cols\n\ndef get_neighbours(cols: set[int], num_total_cols: int) -> set[int]:\n    \"\"\"\n    Finds the set of unique column indices adjacent to the indices in the input set.\n    Handles boundary conditions (column 0 and last column).\n    \"\"\"\n    neighbours = set()\n    if num_total_cols <= 0: return neighbours\n    \n    for c in cols:\n        # Add left neighbour if not the first column\n        if c > 0:\n            neighbours.add(c - 1)\n        # Add right neighbour if not the last column\n        if c < num_total_cols - 1:\n            neighbours.add(c + 1)\n    return neighbours\n\n# === Main Transform Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0]) # Assume rectangular\n\n    # --- Workflow ---\n\n    # 1. Find the extent of the identical top block\n    last_top_row = find_last_top_row(input_grid)\n\n    # 2. Identify columns with '8' in the header block\n    header_8_cols = get_cols_with_value_in_rows(input_grid, 8, 0, last_top_row)\n\n    # 3. Identify columns with '2' anywhere in the grid\n    two_cols = get_cols_with_value_anywhere(input_grid, 2)\n\n    # 4. Find immediate neighbours of the '2' columns\n    neighbours_of_two = get_neighbours(two_cols, num_cols)\n\n    # 5. Filter neighbours: keep only those that DON'T contain '2's themselves\n    neighbours_to_fill = neighbours_of_two - two_cols\n\n    # 6. Determine the final set of columns to fill below the header\n    # Combine columns from header and qualified neighbours\n    target_fill_cols = header_8_cols.union(neighbours_to_fill)\n\n    # 7. Fill downwards in the target columns below the header block\n    start_fill_row = last_top_row + 1\n    for r in range(start_fill_row, num_rows):\n        for c in target_fill_cols:\n            # Ensure column index is valid (safety check)\n            if c < len(output_grid[r]):\n                # Only change the cell if it's currently '0'\n                if output_grid[r][c] == 0:\n                    output_grid[r][c] = 8\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15702,
    "candidates_token_count": 2144,
    "total_token_count": 17846,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.473552,
  "retries": 1
}