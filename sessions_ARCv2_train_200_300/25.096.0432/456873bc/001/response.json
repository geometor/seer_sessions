{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identifies a solid rectangular block of color 3.\n2. Identifies a 'source' pattern block adjacent (below or left, potentially separated by a zero row/column) to the color 3 block, matching its size along the shared dimension.\n3. Copies the source pattern into the area originally occupied by the color 3 block in an intermediate grid.\n4. Iterates through the intermediate grid and creates the final output grid.\n5. Changes the color of '2' cells to '8' in the final output grid if they form a corner in the intermediate grid. A corner '2' has exactly two neighbors (N, S, E, W) that are also '2', and these two neighbors are adjacent to each other (e.g., N and E, not N and S).\n6. All other cells (0s, non-corner 2s) retain their color from the intermediate grid in the final output grid.\n\"\"\"\n\ndef find_color_block(grid_np, color):\n    \"\"\"\n    Finds the bounding box (min_row, max_row, min_col, max_col) of the\n    first contiguous block of the specified color encountered.\n    Assumes the block is rectangular and solid for color 3 based on examples.\n    Returns None if the color is not found.\n    \"\"\"\n    rows, cols = grid_np.shape\n    # Find all coordinates where the grid matches the color\n    coords = np.argwhere(grid_np == color)\n    if coords.size == 0:\n        return None # Color not found\n\n    # Determine the bounding box\n    r_min, c_min = coords.min(axis=0)\n    r_max, c_max = coords.max(axis=0)\n\n    # For color 3, we assume based on examples it forms a solid rectangle.\n    # A simple check verifies if all cells within the bounding box have the target color.\n    block = grid_np[r_min:r_max+1, c_min:c_max+1]\n    if np.all(block == color):\n        return (r_min, r_max, c_min, c_max)\n    else:\n        # This indicates the found coordinates don't form a solid block within their bounding box.\n        # This case is not expected for color 3 based on the provided examples.\n        # We might return the bounding box anyway, or handle as an error.\n        # Returning the bounding box allows processing even if assumption is slightly violated.\n        # print(f\"Warning: Color {color} at {r_min, c_min} to {r_max, c_max} does not form a solid block.\")\n        return (r_min, r_max, c_min, c_max)\n\n\ndef is_corner(grid_np, r, c):\n    \"\"\"\n    Checks if a cell at (r, c) with value 2 is a corner in the grid.\n    A corner has exactly two neighbors (N, S, E, W) with value 2,\n    and those neighbors are adjacent to each other (e.g., North and East,\n    or South and West, but not North and South or East and West).\n    \"\"\"\n    rows, cols = grid_np.shape\n    # Cell itself must be 2\n    if grid_np[r, c] != 2:\n        return False\n\n    # Define neighbor coordinates relative to (r, c)\n    # Indices correspond to: 0:North, 1:South, 2:East, 3:West\n    neighbors_coords = [\n        (r - 1, c), # N (idx 0)\n        (r + 1, c), # S (idx 1)\n        (r, c + 1), # E (idx 2)\n        (r, c - 1)  # W (idx 3)\n    ]\n\n    neighbor_color_2_count = 0\n    # Store indices (0=N, 1=S, 2=E, 3=W) of neighbors that have color 2\n    neighbor_indices_2 = []\n\n    # Check each neighbor\n    for idx, (nr, nc) in enumerate(neighbors_coords):\n        # Check if neighbor is within grid bounds\n        if 0 <= nr < rows and 0 <= nc < cols:\n            # Check if neighbor color is 2\n            if grid_np[nr, nc] == 2:\n                neighbor_color_2_count += 1\n                neighbor_indices_2.append(idx)\n\n    # A corner must have exactly two neighbors with color 2\n    if neighbor_color_2_count != 2:\n        return False\n\n    # Check if the two neighbors are adjacent (i.e., not opposites)\n    # Opposite pairs have indices (0, 1) [N, S] or (2, 3) [E, W]\n    idx1, idx2 = sorted(neighbor_indices_2) # Sort for consistent checking\n\n    # If the pair is (0, 1) or (2, 3), they are opposites, so it's not a corner\n    if (idx1 == 0 and idx2 == 1) or (idx1 == 2 and idx2 == 3):\n        return False\n\n    # If count is 2 and they are not opposites, they must be adjacent neighbors\n    return True\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid according to the identified pattern:\n    Copies a source pattern block (adjacent to the '3' block) onto the\n    location of the '3' block, then converts corner '2's to '8's.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    # Create an intermediate grid based on input to perform the copy operation\n    intermediate_np = input_np.copy()\n\n    # --- Step 1: Find the '3' block ---\n    coords_3 = find_color_block(intermediate_np, 3)\n\n    # If a '3' block exists, perform the copy operation\n    if coords_3 is not None:\n        r_min_3, r_max_3, c_min_3, c_max_3 = coords_3\n        height_3 = r_max_3 - r_min_3 + 1\n        width_3 = c_max_3 - c_min_3 + 1\n        # Define the slice representing the target area (where '3' block is)\n        target_slice = (slice(r_min_3, r_max_3 + 1), slice(c_min_3, c_max_3 + 1))\n\n        # --- Step 2: Determine orientation and find source block ---\n        source_slice = None\n        # Heuristic based on examples: if block width matches grid width, it's horizontal.\n        is_horizontal = (width_3 == cols)\n\n        if is_horizontal:\n            # Block is horizontal, source pattern is below it\n            # Search downwards row by row starting from below the '3' block\n            r_source_start = -1\n            for r in range(r_max_3 + 1, rows):\n                # Check if any cell in the relevant columns of this row (in the *original* grid) is non-zero\n                if np.any(input_np[r, c_min_3:c_max_3+1] != 0):\n                    r_source_start = r\n                    break # Found the first row of the source block\n\n            if r_source_start != -1:\n                # Source block has the same height as the '3' block\n                r_source_end = r_source_start + height_3 - 1\n                # Ensure the calculated source block is within grid bounds\n                if r_source_end < rows:\n                    source_slice = (slice(r_source_start, r_source_end + 1), slice(c_min_3, c_max_3 + 1))\n\n        else: # Block is vertical, source pattern is to the left\n            # Search leftwards column by column starting from left of the '3' block\n            c_source_end = -1\n            for c in range(c_min_3 - 1, -1, -1): # Iterate columns from c_min_3-1 down to 0\n                 # Check if any cell in the relevant rows of this column (in the *original* grid) is non-zero\n                 if np.any(input_np[r_min_3:r_max_3+1, c] != 0):\n                     c_source_end = c\n                     break # Found the last column of the source block\n\n            if c_source_end != -1:\n                # Source block has the same width as the '3' block\n                c_source_start = c_source_end - width_3 + 1\n                # Ensure the calculated source block is within grid bounds\n                if c_source_start >= 0:\n                    source_slice = (slice(r_min_3, r_max_3 + 1), slice(c_source_start, c_source_end + 1))\n\n        # --- Step 3: Copy pattern from source to target in intermediate grid ---\n        if source_slice:\n            try:\n                # Get the data from the source slice in the original input\n                source_data = input_np[source_slice]\n                # Get the shape of the target area\n                target_shape = intermediate_np[target_slice].shape\n\n                # Ensure source and target shapes match before copying\n                if source_data.shape == target_shape:\n                    intermediate_np[target_slice] = source_data\n                else:\n                     # Handle unexpected shape mismatch - clear target area\n                     # print(f\"Shape mismatch error: Target {target_shape}, Source {source_data.shape}\")\n                     intermediate_np[target_slice] = 0\n            except IndexError:\n                 # Handle cases where calculated slices might be out of bounds\n                 # print(f\"IndexError during copy: Target {target_slice}, Source {source_slice}\")\n                 intermediate_np[target_slice] = 0 # Clear target area on error\n        else:\n             # If no source block could be identified (e.g., '3' block at edge)\n             # Clear the target area (replace '3's with '0's)\n             intermediate_np[target_slice] = 0\n\n    # --- Step 4: Apply Corner Transformation ---\n    # Create the final output grid, starting as a copy of the intermediate grid\n    final_output_np = intermediate_np.copy()\n    # Iterate through each cell of the intermediate grid\n    for r in range(rows):\n        for c in range(cols):\n            # Check for corners using the state of the *intermediate* grid\n            if intermediate_np[r, c] == 2:\n                if is_corner(intermediate_np, r, c):\n                    # If it's a corner '2', change it to '8' in the final output\n                    final_output_np[r, c] = 8\n            # Note: If it was '3', it should have been overwritten by copy or set to 0.\n            # If it was '0' or a non-corner '2', it remains as is in final_output_np.\n\n    # Convert final numpy array back to list of lists for the expected output format\n    return final_output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4251,
    "candidates_token_count": 7929,
    "total_token_count": 12180,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 74.496396,
  "retries": 1
}