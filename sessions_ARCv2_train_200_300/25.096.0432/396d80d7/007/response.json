{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying a background color (most frequent), \npattern colors (others), a trigger color (max of pattern colors), and a \nfill color (min of pattern colors). It then iterates through the grid. \nIf a cell has the background color AND is adjacent (including diagonals) \nto a cell with the trigger color in the original input grid AND is NOT \nadjacent (including diagonals) to a cell with the fill color in the \noriginal input grid, its color in the output grid is changed to the \nfill color. Otherwise, the cell retains its original color.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nimport itertools\n\ndef _find_colors(grid: np.ndarray) -> tuple[int | None, set[int], int | None, int | None]:\n    \"\"\"\n    Identifies the background color (most frequent), pattern colors (others),\n    trigger color (max pattern), and fill color (min pattern).\n    \n    Args:\n        grid: The input grid as a numpy array.\n        \n    Returns:\n        A tuple containing:\n        - background_color (int or None if grid is empty/invalid)\n        - pattern_colors (set of int)\n        - trigger_color (int or None if no pattern)\n        - fill_color (int or None if no pattern)\n    \"\"\"\n    # Handle empty grid case\n    if grid.size == 0:\n        return None, set(), None, None\n        \n    flat_grid = grid.flatten()\n    counts = Counter(flat_grid)\n    \n    # Handle case where Counter might be empty (though unlikely with size check)\n    if not counts: \n        return None, set(), None, None\n        \n    # Assume background color is the most frequent one\n    background_color = counts.most_common(1)[0][0]\n    \n    # Pattern colors are all colors except the background\n    pattern_colors = set(counts.keys()) - {background_color}\n    \n    trigger_color = None\n    fill_color = None\n    # Determine trigger and fill colors only if pattern colors exist\n    if pattern_colors:\n        trigger_color = max(pattern_colors)\n        fill_color = min(pattern_colors)\n        \n    return background_color, pattern_colors, trigger_color, fill_color\n\ndef _get_neighbor_colors(grid: np.ndarray, r: int, c: int) -> set[int]:\n    \"\"\"\n    Gets the set of unique colors of the 8 neighbors (Moore neighborhood) of cell (r, c).\n    \n    Args:\n        grid: The input grid (numpy array).\n        r: Row index of the cell.\n        c: Column index of the cell.\n        \n    Returns:\n        A set containing the unique integer colors of the valid neighbors.\n    \"\"\"\n    rows, cols = grid.shape\n    neighbor_colors = set()\n    # Iterate through all 8 relative neighbor coordinates\n    for dr, dc in itertools.product([-1, 0, 1], repeat=2):\n        # Skip the cell itself (dr=0, dc=0)\n        if dr == 0 and dc == 0:  \n            continue\n            \n        # Calculate absolute neighbor coordinates\n        nr, nc = r + dr, c + dc\n        \n        # Check if neighbor coordinates are within grid boundaries\n        if 0 <= nr < rows and 0 <= nc < cols:\n            # Add the neighbor's color to the set\n            neighbor_colors.add(grid[nr, nc])\n                \n    return neighbor_colors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid: A 2D list representing the input grid.\n        \n    Returns:\n        A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle empty input case immediately\n    if input_array.size == 0:\n        return []\n        \n    # Initialize output_grid as a copy of the input. Cells will be modified directly in this copy.\n    output_array = np.copy(input_array) \n    rows, cols = input_array.shape\n\n    # Identify background, pattern, trigger, and fill colors using the helper function\n    background_color, pattern_colors, trigger_color, fill_color = _find_colors(input_array)\n\n    # If essential colors couldn't be determined (e.g., only background color exists), return the original grid\n    if not pattern_colors or trigger_color is None or fill_color is None or background_color is None:\n        return input_grid \n\n    # Iterate through each cell of the input grid by row and column index\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current cell in the *input* grid has the background color\n            if input_array[r, c] == background_color:\n                \n                # Get the set of colors present in the neighbors of the current cell (in the *input* grid)\n                neighbor_colors = _get_neighbor_colors(input_array, r, c)\n                \n                # Check condition 1: Is the cell adjacent to the trigger_color?\n                is_adj_trigger = trigger_color in neighbor_colors\n                \n                # Check condition 2: Is the cell adjacent to the fill_color?\n                is_adj_fill = fill_color in neighbor_colors\n                \n                # Apply the transformation rule: \n                # Change the cell in the output if it's a background cell, \n                # AND it is adjacent to the trigger color, \n                # AND it is NOT adjacent to the fill color.\n                if is_adj_trigger and not is_adj_fill:\n                    # If all conditions are met, update the corresponding cell in the output grid to the fill color\n                    output_array[r, c] = fill_color\n            \n            # If the cell is not background color or the conditions are not met, \n            # the output_array cell retains its originally copied value from the input_array.\n\n    # Convert the final NumPy array back to a list of lists for the expected output format\n    output_grid = output_array.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18512,
    "candidates_token_count": 1734,
    "total_token_count": 20246,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.973662,
  "retries": 1
}