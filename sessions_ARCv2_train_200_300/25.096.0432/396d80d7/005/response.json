{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying a background color (most frequent), pattern colors (others), a trigger color (max of pattern colors), and a fill color (min of pattern colors). \nIt then iterates through the grid. If a cell has the background color AND is adjacent (including diagonals) to a cell with the trigger color in the original input grid AND is NOT adjacent (including diagonals) to a cell with the fill color in the original input grid, its color in the output grid is changed to the fill color. Otherwise, the cell retains its original color.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nimport itertools\n\ndef _find_colors(grid: np.ndarray) -> tuple[int | None, set[int], int | None, int | None]:\n    \"\"\"\n    Identifies the background color (most frequent), pattern colors (others),\n    trigger color (max pattern), and fill color (min pattern).\n    \n    Args:\n        grid: The input grid as a numpy array.\n        \n    Returns:\n        A tuple containing:\n        - background_color (int or None if grid is empty)\n        - pattern_colors (set of int)\n        - trigger_color (int or None if no pattern)\n        - fill_color (int or None if no pattern)\n    \"\"\"\n    if grid.size == 0:\n        return None, set(), None, None\n        \n    flat_grid = grid.flatten()\n    counts = Counter(flat_grid)\n    \n    # Assume background color is the most frequent one\n    if not counts: # Handle case of completely empty grid if passed somehow\n        return None, set(), None, None\n    background_color = counts.most_common(1)[0][0]\n    \n    # Pattern colors are all colors except the background\n    pattern_colors = set(counts.keys()) - {background_color}\n    \n    trigger_color = None\n    fill_color = None\n    if pattern_colors:\n        # Guard against empty set if only background exists\n        trigger_color = max(pattern_colors)\n        fill_color = min(pattern_colors)\n        \n    return background_color, pattern_colors, trigger_color, fill_color\n\ndef _get_neighbor_colors(grid: np.ndarray, r: int, c: int) -> set[int]:\n    \"\"\"\n    Gets the set of unique colors of the 8 neighbors of cell (r, c).\n    \n    Args:\n        grid: The input grid (numpy array).\n        r: Row index of the cell.\n        c: Column index of the cell.\n        \n    Returns:\n        A set containing the unique integer colors of the valid neighbors.\n    \"\"\"\n    rows, cols = grid.shape\n    neighbor_colors = set()\n    # Iterate through all 8 neighbors (Moore neighborhood) including diagonals\n    for dr, dc in itertools.product([-1, 0, 1], repeat=2):\n        if dr == 0 and dc == 0:  # Skip the cell itself\n            continue\n            \n        nr, nc = r + dr, c + dc\n        \n        # Check boundary conditions\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbor_colors.add(grid[nr, nc])\n                \n    return neighbor_colors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid: A 2D list representing the input grid.\n        \n    Returns:\n        A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle empty input case\n    if input_array.size == 0:\n        return []\n        \n    # Initialize output_grid as a copy of the input\n    output_array = np.copy(input_array) \n    rows, cols = input_array.shape\n\n    # Identify background, pattern, trigger, and fill colors\n    background_color, pattern_colors, trigger_color, fill_color = _find_colors(input_array)\n\n    # If there are no pattern colors, or necessary colors are missing, return the original grid unchanged\n    # This handles grids with only background color or invalid states.\n    if not pattern_colors or trigger_color is None or fill_color is None or background_color is None:\n        return input_grid \n\n    # Iterate through each cell of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current cell in the input has the background color\n            if input_array[r, c] == background_color:\n                # Get the colors of all neighbors from the *original* input grid\n                neighbor_colors = _get_neighbor_colors(input_array, r, c)\n                \n                # Check condition: Is the cell adjacent to the trigger_color?\n                is_adj_trigger = trigger_color in neighbor_colors\n                \n                # Check condition: Is the cell adjacent to the fill_color?\n                is_adj_fill = fill_color in neighbor_colors\n                \n                # Apply the transformation rule: \n                # Change the cell in the output if it's a background cell, \n                # adjacent to the trigger color, AND NOT adjacent to the fill color.\n                if is_adj_trigger and not is_adj_fill:\n                    # If conditions met, change the corresponding cell in the output grid to the fill color\n                    output_array[r, c] = fill_color\n            # If the cell is not background or conditions are not met, \n            # it keeps its original value (already copied to output_array)\n\n    # Convert the result back to a list of lists\n    output_grid = output_array.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16809,
    "candidates_token_count": 1757,
    "total_token_count": 18566,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.640141,
  "retries": 1
}