{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation identifies horizontal and vertical grid lines composed of a single, \nrepeating non-zero integer (the 'separator value'). These lines partition the grid \ninto rectangular sections. The transformation then iterates through all pairs of \nvertically adjacent sections. \n\nIf a section in the *input grid* contains only zeros (is 'empty') and its \nimmediate vertical neighbor (above or below) in the *input grid* contains a \n'pattern' (defined as having at least one non-zero value that is different \nfrom the separator value), then the pattern from the neighbor is copied into the \nlocation of the empty section in the *output grid*, but flipped vertically.\n\nSections that are not empty or do not have a patterned neighbor meeting the \ncondition remain unchanged. The grid lines themselves are never modified.\n\"\"\"\n\ndef _find_grid_lines(grid_np: np.ndarray) -> tuple[list[int], list[int], int | None]:\n    \"\"\"\n    Finds the indices of horizontal and vertical grid lines and the separator value.\n    Assumes lines are solid runs of the same non-zero digit. Includes a fallback\n    check on common indices if the primary method fails.\n\n    Args:\n        grid_np: The input grid as a NumPy array.\n\n    Returns:\n        A tuple containing:\n        - list[int]: Indices of horizontal lines.\n        - list[int]: Indices of vertical lines.\n        - int | None: The separator value, or None if not found.\n    \"\"\"\n    rows, cols = grid_np.shape\n    h_lines = []\n    v_lines = []\n    separator_val = None\n    potential_sep_vals = set()\n\n    # Primary check: Look for solid non-zero rows\n    for r in range(rows):\n        unique_vals = np.unique(grid_np[r, :])\n        if len(unique_vals) == 1 and unique_vals[0] != 0:\n            potential_sep_vals.add(unique_vals[0])\n            # Don't break; collect all potential values first in case of ambiguity\n            # break\n\n    # Primary check: Look for solid non-zero columns\n    for c in range(cols):\n        unique_vals = np.unique(grid_np[:, c])\n        if len(unique_vals) == 1 and unique_vals[0] != 0:\n            potential_sep_vals.add(unique_vals[0])\n            # break\n\n    # Determine the separator value\n    if len(potential_sep_vals) == 1:\n        separator_val = potential_sep_vals.pop()\n    elif len(potential_sep_vals) > 1:\n        # Handle ambiguity - perhaps choose the most frequent one?\n        # For now, let's arbitrarily pick the smallest one, but this might need refinement.\n        separator_val = min(potential_sep_vals)\n        # print(f\"Warning: Multiple potential separator values found ({potential_sep_vals}). Using {separator_val}.\")\n    else:\n        # Fallback: Check specific indices if no solid lines found\n        # These indices are derived from the examples (e.g., row 4, col 4)\n        candidate_indices = []\n        if rows > 4: candidate_indices.append((4, 0))\n        if cols > 4: candidate_indices.append((0, 4))\n        if rows > 9: candidate_indices.append((9, 0))\n        if cols > 9: candidate_indices.append((0, 9))\n        if rows > 14: candidate_indices.append((14, 0))\n        if cols > 14: candidate_indices.append((0, 14))\n        \n        non_zero_candidates = [grid_np[r, c] for r, c in candidate_indices if grid_np[r,c] != 0]\n        if non_zero_candidates:\n             # Choose the most frequent candidate, or the first if tied\n             counts = {val: non_zero_candidates.count(val) for val in set(non_zero_candidates)}\n             separator_val = max(counts, key=counts.get)\n             # print(f\"Warning: No solid lines found. Using fallback separator value {separator_val} based on indices.\")\n        else:\n             # No separator found by any method\n             return [], [], None\n\n    # Find horizontal lines using the determined separator value\n    for r in range(rows):\n        if np.all(grid_np[r, :] == separator_val):\n            h_lines.append(r)\n\n    # Find vertical lines using the determined separator value\n    for c in range(cols):\n         if np.all(grid_np[:, c] == separator_val):\n            v_lines.append(c)\n\n    # Sort lines just in case they were found out of order\n    h_lines.sort()\n    v_lines.sort()\n\n    return h_lines, v_lines, separator_val\n\n\ndef _get_section_coords(rows: int, cols: int, h_lines: list[int], v_lines: list[int]) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Determines the content coordinates (excluding boundary lines) of each section.\n\n    Args:\n        rows: Total number of rows in the grid.\n        cols: Total number of columns in the grid.\n        h_lines: List of row indices for horizontal lines.\n        v_lines: List of column indices for vertical lines.\n\n    Returns:\n        List of tuples, where each tuple represents a section's content area:\n        (row_start_inclusive, row_end_exclusive, col_start_inclusive, col_end_exclusive)\n    \"\"\"\n    sections = []\n    # Define boundaries including the edges of the grid\n    row_boundaries = [-1] + h_lines + [rows]\n    col_boundaries = [-1] + v_lines + [cols]\n\n    # Iterate through the gaps between boundaries to define sections\n    for i in range(len(row_boundaries) - 1):\n        # Content starts 1 row after the previous boundary\n        r_start = row_boundaries[i] + 1\n        # Content ends 1 row before the next boundary\n        r_end = row_boundaries[i+1]\n\n        # Skip if the section has zero height (e.g., consecutive lines)\n        if r_start >= r_end: continue\n\n        for j in range(len(col_boundaries) - 1):\n            # Content starts 1 col after the previous boundary\n            c_start = col_boundaries[j] + 1\n            # Content ends 1 col before the next boundary\n            c_end = col_boundaries[j+1]\n\n            # Skip if the section has zero width\n            if c_start >= c_end: continue\n\n            sections.append((r_start, r_end, c_start, c_end))\n\n    return sections\n\ndef _get_section_content(grid_np: np.ndarray, coords: tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the content of a section given its coordinates.\"\"\"\n    r_start, r_end, c_start, c_end = coords\n    # NumPy slicing is exclusive of the end index, matching our coordinate definition\n    return grid_np[r_start:r_end, c_start:c_end]\n\ndef _is_section_empty(content: np.ndarray) -> bool:\n    \"\"\"Checks if a section's content is all zeros.\"\"\"\n    if content.size == 0: # Handle cases where a section might somehow be empty\n        return True\n    return np.all(content == 0)\n\ndef _has_pattern(content: np.ndarray, separator_val: int) -> bool:\n    \"\"\"Checks if a section's content has any non-zero values other than the separator.\"\"\"\n    if content.size == 0: # Empty sections don't have patterns\n        return False\n    # Check if any element is not 0 AND not the separator value\n    return np.any((content != 0) & (content != separator_val))\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the vertical flip-copy transformation based on adjacent empty/patterned sections.\n\n    Args:\n        input_grid: The input grid as a list of lists of integers.\n\n    Returns:\n        The transformed grid as a list of lists of integers.\n    \"\"\"\n    # Convert input to NumPy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = input_np.copy()\n    rows, cols = input_np.shape\n\n    # 1. Identify Grid Structure\n    h_lines, v_lines, separator_val = _find_grid_lines(input_np)\n\n    # If no separator value could be determined, return the original grid\n    if separator_val is None:\n        # print(\"Warning: Could not determine grid separator value. Returning original grid.\")\n        return input_grid\n\n    # 2. Define Sections\n    section_coords = _get_section_coords(rows, cols, h_lines, v_lines)\n\n    # 3. Create a mapping from top-left corner to section index for easy lookup\n    # We use (row_start, col_start) as the key\n    coord_to_index_map = {(r_start, c_start): i\n                          for i, (r_start, r_end, c_start, c_end) in enumerate(section_coords)}\n\n    # 4. Iterate Through Vertical Pairs and Apply Transformation Logic\n    processed_pairs = set() # Keep track of pairs to avoid double processing if logic were different\n    for i, (r_start1, r_end1, c_start1, c_end1) in enumerate(section_coords):\n        # Calculate the expected starting coordinates of the section directly below\n        # It should start 1 row after the current section ends (r_end1)\n        # AND 1 row after the horizontal line (which is at r_end1) -> r_end1 + 1\n        lower_neighbor_start_row = r_end1 # The line is at r_end1 - 1 ? No, line is at r_end1\n        # The section starts at row_boundaries[i+1] + 1. The line is row_boundaries[i+1].\n        # So the lower neighbor starts at row r_end1 + 1.\n        \n        potential_lower_neighbor_key = (r_end1 + 1, c_start1)\n\n        # Check if a section exists at this potential lower neighbor location\n        if potential_lower_neighbor_key in coord_to_index_map:\n            j = coord_to_index_map[potential_lower_neighbor_key]\n            # Ensure we haven't processed this pair from the other direction\n            # (Although current logic only looks down, this prevents issues if logic changes)\n            pair = tuple(sorted((i, j)))\n            if pair in processed_pairs:\n                continue\n            processed_pairs.add(pair)\n\n            # Get coordinates for both sections\n            upper_coords = (r_start1, r_end1, c_start1, c_end1) # Section i\n            lower_coords = section_coords[j]                 # Section j\n\n            # Retrieve content from the ORIGINAL input grid\n            upper_content_from_input = _get_section_content(input_np, upper_coords)\n            lower_content_from_input = _get_section_content(input_np, lower_coords)\n\n            # Check dimensions match - they should in a regular grid\n            if upper_content_from_input.shape != lower_content_from_input.shape:\n                 # print(f\"Warning: Vertically adjacent sections {i} and {j} have different shapes. Skipping.\")\n                 continue\n\n            # 5. Check and Apply Transformation (Upper Empty, Lower Patterned)\n            # Conditions checked against INPUT grid\n            if _is_section_empty(upper_content_from_input) and _has_pattern(lower_content_from_input, separator_val):\n                # Action applied to OUTPUT grid\n                flipped_pattern = np.flipud(lower_content_from_input)\n                output_np[r_start1:r_end1, c_start1:c_end1] = flipped_pattern\n                # print(f\"Applied: Flipped Lower ({j}) to Upper ({i})\")\n\n\n            # 6. Check and Apply Transformation (Lower Empty, Upper Patterned)\n            # Conditions checked against INPUT grid\n            elif _is_section_empty(lower_content_from_input) and _has_pattern(upper_content_from_input, separator_val):\n                # Action applied to OUTPUT grid\n                flipped_pattern = np.flipud(upper_content_from_input)\n                lr_start, lr_end, lc_start, lc_end = lower_coords # Get coords for lower section\n                output_np[lr_start:lr_end, lc_start:lc_end] = flipped_pattern\n                # print(f\"Applied: Flipped Upper ({i}) to Lower ({j})\")\n\n\n    # 7. Finalize\n    # Convert the modified NumPy array back to a list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13406,
    "candidates_token_count": 4086,
    "total_token_count": 17492,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 38.606794,
  "retries": 1
}