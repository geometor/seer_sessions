{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation identifies horizontal and vertical grid lines composed of a single, repeating non-zero integer (G). These lines partition the grid into sections. \nIt then iterates through vertically adjacent sections. \nIf a section contains only zeros (is 'empty') and its immediate vertical neighbor (above or below) contains a pattern (non-zero values other than G), the pattern from the neighbor is copied into the empty section, but flipped vertically. \nGrid lines and sections that do not meet these conditions remain unchanged.\n\"\"\"\n\ndef _find_grid_lines(grid_np: np.ndarray) -> tuple[list[int], list[int], int | None]:\n    \"\"\"\n    Finds the indices of horizontal and vertical grid lines and the separator value.\n    Assumes lines are solid runs of the same non-zero digit.\n    \"\"\"\n    rows, cols = grid_np.shape\n    h_lines = []\n    v_lines = []\n    separator_val = None\n\n    # Find potential separator value (look for solid non-zero rows/cols)\n    potential_sep_vals = set()\n    for r in range(rows):\n        unique_vals = np.unique(grid_np[r, :])\n        if len(unique_vals) == 1 and unique_vals[0] != 0:\n            potential_sep_vals.add(unique_vals[0])\n            break # Assume first found is the one\n    if not potential_sep_vals:\n         for c in range(cols):\n            unique_vals = np.unique(grid_np[:, c])\n            if len(unique_vals) == 1 and unique_vals[0] != 0:\n                potential_sep_vals.add(unique_vals[0])\n                break # Assume first found is the one\n\n    if not potential_sep_vals:\n        # Fallback: Check a few specific points if no solid lines found initially\n        # This might be brittle but covers the example structure\n        candidates = [grid_np[0, 4], grid_np[4, 0], grid_np[0, 9], grid_np[9,0]] # Example locations\n        non_zero_candidates = [c for c in candidates if c != 0]\n        if non_zero_candidates:\n             separator_val = non_zero_candidates[0] # Take the first one\n        else: # No clear separator found\n             return [], [], None\n    else:\n        separator_val = potential_sep_vals.pop()\n\n    # Find horizontal lines\n    for r in range(rows):\n        if np.all(grid_np[r, :] == separator_val):\n            h_lines.append(r)\n\n    # Find vertical lines\n    for c in range(cols):\n         if np.all(grid_np[:, c] == separator_val):\n            v_lines.append(c)\n\n    return h_lines, v_lines, separator_val\n\n\ndef _get_section_coords(rows: int, cols: int, h_lines: list[int], v_lines: list[int]) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Determines the content coordinates (excluding boundary lines) of each section.\n    Returns list of tuples: (row_start, row_end, col_start, col_end)\n    \"\"\"\n    sections = []\n    row_boundaries = [-1] + h_lines + [rows]\n    col_boundaries = [-1] + v_lines + [cols]\n\n    for i in range(len(row_boundaries) - 1):\n        r_start = row_boundaries[i] + 1\n        r_end = row_boundaries[i+1]\n        if r_start >= r_end: continue # Skip if section has zero height\n\n        for j in range(len(col_boundaries) - 1):\n            c_start = col_boundaries[j] + 1\n            c_end = col_boundaries[j+1]\n            if c_start >= c_end: continue # Skip if section has zero width\n\n            sections.append((r_start, r_end, c_start, c_end))\n\n    return sections\n\ndef _get_section_content(grid_np: np.ndarray, coords: tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"Extracts the content of a section given its coordinates.\"\"\"\n    r_start, r_end, c_start, c_end = coords\n    return grid_np[r_start:r_end, c_start:c_end]\n\ndef _is_section_empty(content: np.ndarray) -> bool:\n    \"\"\"Checks if a section's content is all zeros.\"\"\"\n    return np.all(content == 0)\n\ndef _has_pattern(content: np.ndarray, separator_val: int) -> bool:\n    \"\"\"Checks if a section's content has any non-zero values other than the separator.\"\"\"\n    # Check if any element is not 0 AND not the separator value\n    return np.any((content != 0) & (content != separator_val))\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies grid sections separated by lines of a single non-zero digit 'G'.\n    If a section contains only zeros and is vertically adjacent to a section\n    containing a pattern (non-zero, non-G values), the pattern is copied\n    into the zero section, flipped vertically.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy() # Start with a copy\n    rows, cols = input_np.shape\n\n    # Find grid lines and the separator value\n    h_lines, v_lines, separator_val = _find_grid_lines(input_np)\n\n    # If no separator found, return input as is (or handle error)\n    if separator_val is None:\n        print(\"Warning: Could not determine grid separator value.\")\n        return input_grid # Or raise an error\n\n    # Define the sections based on the grid lines\n    section_coords = _get_section_coords(rows, cols, h_lines, v_lines)\n\n    # Create a mapping from starting row/col to section index for easier lookup\n    coord_map = {(r_start, c_start): i for i, (r_start, r_end, c_start, c_end) in enumerate(section_coords)}\n\n    # Iterate through sections to find vertically adjacent pairs\n    for i, (r_start1, r_end1, c_start1, c_end1) in enumerate(section_coords):\n        # Look for a section directly below (starts where current section ends + 1 for the line)\n        lower_neighbor_coord_key = (r_end1 + 1, c_start1)\n        if lower_neighbor_coord_key in coord_map:\n            j = coord_map[lower_neighbor_coord_key]\n            r_start2, r_end2, c_start2, c_end2 = section_coords[j]\n\n            # Ensure columns align (should be guaranteed by grid structure)\n            if c_start1 == c_start2 and c_end1 == c_end2:\n                # Section 1 is upper, Section 2 is lower\n                upper_coords = (r_start1, r_end1, c_start1, c_end1)\n                lower_coords = (r_start2, r_end2, c_start2, c_end2)\n\n                # Get content from the ORIGINAL input grid\n                upper_content = _get_section_content(input_np, upper_coords)\n                lower_content = _get_section_content(input_np, lower_coords)\n\n                # Check conditions and apply transformation to output_np\n\n                # Case 1: Upper is empty, Lower has pattern\n                if _is_section_empty(upper_content) and _has_pattern(lower_content, separator_val):\n                    # Ensure dimensions match before copying\n                    if upper_content.shape == lower_content.shape:\n                        flipped_pattern = np.flipud(lower_content)\n                        output_np[r_start1:r_end1, c_start1:c_end1] = flipped_pattern\n                    # else: print warning or handle mismatch\n\n                # Case 2: Lower is empty, Upper has pattern\n                elif _is_section_empty(lower_content) and _has_pattern(upper_content, separator_val):\n                     # Ensure dimensions match before copying\n                    if upper_content.shape == lower_content.shape:\n                        flipped_pattern = np.flipud(upper_content)\n                        output_np[r_start2:r_end2, c_start2:c_end2] = flipped_pattern\n                    # else: print warning or handle mismatch\n\n\n    # Convert back to list of lists for the final output\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4315,
    "candidates_token_count": 2967,
    "total_token_count": 7282,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.570589,
  "retries": 1
}