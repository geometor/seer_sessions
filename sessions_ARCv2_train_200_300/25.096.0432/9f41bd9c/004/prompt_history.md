
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
1 1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
1 1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
1 1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
1 1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1 1
5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1 1
5 1 5 1 5 1 1 1 1 1 1 1 1 1 1 1 1
1 5 1 5 1 5 1 1 1 1 1 1 1 1 1 1 1
1 1 5 1 5 1 5 1 1 1 1 1 1 1 1 1 1
1 1 1 5 1 5 1 5 1 1 1 1 1 1 1 1 1
1 1 1 1 5 1 5 1 5 1 1 1 1 1 1 1 1
6 6 6 6 6 9 9 9 9 9 9 9 9 9 9 9 9
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1
5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1
5 1 5 1 5 1 1 1 1 1 1 1 1 1 1 1
5 1 5 1 5 1 1 1 1 1 1 1 1 1 1 1
5 1 5 1 5 1 1 1 1 1 1 1 1 1 1 1
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 5 5 5 5 5
1 1 1 1 1 1 1 1 1 1 1 5 1 5 1 5
1 1 1 1 1 1 1 1 1 1 5 1 5 1 5 1
1 1 1 1 1 1 1 1 1 5 1 5 1 5 1 1
9 9 9 9 9 9 9 9 9 9 9 9 9 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```

Okay, let's break down the transformation logic for these grid examples.

**Perception:**

The task involves transforming an input grid containing numbers (primarily 1, 5, 6) into an output grid. The core elements appear to be:

1.  **Grid:** A 2D array of integers. The dimensions vary between examples.
2.  **Background:** The number '1' seems to represent the background or empty space.
3.  **Pattern:** A distinct connected group of cells containing the number '5'. Its position varies (right side in example 1, left side in example 2).
4.  **Barrier:** A block of rows at the bottom filled with the number '6'.
5.  **Movement:** The '5' pattern is moved horizontally to the opposite side of the grid in the output.
6.  **Trace:** A diagonal "smear" or trace of '5's appears in the output, extending from the *original* position of the '5' pattern. The direction of the trace (Down-Left or Down-Right) depends on which side the pattern started on. The trace avoids overwriting the moved pattern and stops when it hits the '6' barrier or goes out of bounds.
7.  **Marker:** The number '9' appears only in the output, specifically within the first row of the '6' barrier. The horizontal extent of these '9's seems determined by where the diagonal traces first hit the barrier and the magnitude/direction of the pattern's movement.

**YAML Facts:**


```python
import numpy as np
from typing import List, Tuple, Dict, Optional

"""
Transforms an input grid based on the following rules:

1.  Identify a connected pattern of '5's and a barrier of '6's at the bottom.
2.  Determine the bounding box of the '5' pattern.
3.  Create an output grid initialized with '1's (background).
4.  Move the '5' pattern horizontally to the opposite side of the grid, keeping its vertical position.
    - If the pattern starts on the left half, move it to the far right.
    - If the pattern starts on the right half, move it to the far left.
5.  Generate a diagonal 'trace' of '5's starting from the *original* position of each '5' in the pattern.
    - The trace goes down and right if the pattern moved right.
    - The trace goes down and left if the pattern moved left.
    - The trace stops if it hits the row just above the '6' barrier, goes out of bounds, or would overwrite the *moved* pattern.
6.  Identify the first row of the '6' barrier.
7.  Replace cells in this first barrier row with '9's. The horizontal span of the '9's depends on the original position and movement distance:
    - If moved right (started left): From the original pattern's start column to `original_start_col + movement_distance + 1`.
    - If moved left (started right): From `original_end_col - movement_distance + 1` to the original pattern's end column.
8.  Copy the remaining rows of the '6' barrier from the input to the output grid below the modified first barrier row.
"""

def find_pattern_bounds(grid: np.ndarray, value: int) -> Optional[Dict[str, int]]:
    """Finds the min/max row/col for all cells matching the given value."""
    rows, cols = np.where(grid == value)
    if rows.size == 0:
        return None
    return {
        'min_row': int(np.min(rows)),
        'max_row': int(np.max(rows)),
        'min_col': int(np.min(cols)),
        'max_col': int(np.max(cols)),
    }

def find_barrier_row(grid: np.ndarray, value: int) -> Optional[int]:
    """Finds the first row index consisting entirely of the barrier value."""
    rows, _ = grid.shape
    for r in range(rows):
        if np.all(grid[r, :] == value):
            return r
    # Fallback if no full row found, look for first row containing the value
    rows_with_value, _ = np.where(grid == value)
    if rows_with_value.size > 0:
        return int(np.min(rows_with_value))
    return None # Should not happen based on examples


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the described transformation to the input grid.
    """
    # Convert input to numpy array for easier manipulation
    input_arr = np.array(input_grid, dtype=int)
    rows, cols = input_arr.shape

    # Initialize output grid with background value '1'
    output_arr = np.ones_like(input_arr) * 1

    # Find the bounds of the '5' pattern
    orig_bounds = find_pattern_bounds(input_arr, 5)
    if not orig_bounds:
        # If no pattern '5' found, return the initial grid or handle as needed
        # For now, assume '5' is always present based on examples
        # Copy the '6' barrier if it exists
        barrier_row_idx = find_barrier_row(input_arr, 6)
        if barrier_row_idx is not None:
             output_arr[barrier_row_idx:, :] = input_arr[barrier_row_idx:, :]
        return output_arr.tolist()


    # Find the first row of the '6' barrier
    barrier_row_idx = find_barrier_row(input_arr, 6)
    if barrier_row_idx is None:
         # Handle case where barrier '6' is missing - assume it's the bottom edge?
         # For now, assume '6' is always present
         barrier_row_idx = rows # Treat as if barrier is off-grid

    # --- Determine movement ---
    orig_width = orig_bounds['max_col'] - orig_bounds['min_col'] + 1
    orig_height = orig_bounds['max_row'] - orig_bounds['min_row'] + 1

    # Heuristic: If the pattern starts in the left half, move right, otherwise move left.
    move_right = orig_bounds['min_col'] < cols // 2
    moved_bounds = {}
    moved_bounds['min_row'] = orig_bounds['min_row']
    moved_bounds['max_row'] = orig_bounds['max_row']

    if move_right:
        moved_bounds['min_col'] = cols - orig_width
        moved_bounds['max_col'] = cols - 1
    else: # move_left
        moved_bounds['min_col'] = 0
        moved_bounds['max_col'] = orig_width - 1

    # --- Copy the moved pattern to the output grid ---
    for r_idx, r in enumerate(range(orig_bounds['min_row'], orig_bounds['max_row'] + 1)):
        for c_idx, c in enumerate(range(orig_bounds['min_col'], orig_bounds['max_col'] + 1)):
            if input_arr[r, c] == 5:
                target_r = moved_bounds['min_row'] + r_idx
                target_c = moved_bounds['min_col'] + c_idx
                if 0 <= target_r < rows and 0 <= target_c < cols:
                     output_arr[target_r, target_c] = 5

    # --- Generate the diagonal trace ---
    trace_dc = 1 if move_right else -1 # Direction of column change for trace

    for r in range(orig_bounds['min_row'], orig_bounds['max_row'] + 1):
        for c in range(orig_bounds['min_col'], orig_bounds['max_col'] + 1):
            # Start trace only from original '5' positions
            if input_arr[r, c] == 5:
                # Start trace one step down diagonally
                cr, cc = r + 1, c + trace_dc
                # Loop while trace is within bounds and above the barrier row
                while 0 <= cr < barrier_row_idx and 0 <= cc < cols:
                    # Check if the trace cell would overlap the moved pattern's bounding box
                    in_moved_box = (moved_bounds['min_row'] <= cr <= moved_bounds['max_row'] and
                                    moved_bounds['min_col'] <= cc <= moved_bounds['max_col'])
                    # Check if the specific cell in the moved area actually contains a 5
                    # This prevents stopping trace just because it enters the moved bounding box if that cell is background
                    # Important if the pattern isn't rectangular filled
                    overlaps_moved_pattern = False
                    if in_moved_box:
                         # Calculate corresponding original position to check if it was a 5
                         orig_r_check = cr - moved_bounds['min_row'] + orig_bounds['min_row']
                         orig_c_check = cc - moved_bounds['min_col'] + orig_bounds['min_col']
                         # Check if this calculated original position is valid and was a 5
                         if (orig_bounds['min_row'] <= orig_r_check <= orig_bounds['max_row'] and
                             orig_bounds['min_col'] <= orig_c_check <= orig_bounds['max_col'] and
                             input_arr[orig_r_check, orig_c_check] == 5):
                               overlaps_moved_pattern = True


                    if overlaps_moved_pattern:
                        break # Stop trace if it hits the actual moved pattern

                    # Place the trace '5'
                    output_arr[cr, cc] = 5

                    # Move to the next diagonal position
                    cr += 1
                    cc += trace_dc

    # --- Generate '9' markers in the first barrier row ---
    if barrier_row_idx < rows: # Check if barrier exists within grid
        move_dist = abs(moved_bounds['min_col'] - orig_bounds['min_col'])
        start_9_col = 0
        end_9_col = 0 # Exclusive end for slicing/range

        if move_right:
            start_9_col = orig_bounds['min_col']
            # End column needs careful check - it should go up to where the trace ends or movement ends
            # Using the formula derived in thought: orig_min_col + move_dist + 1
            end_9_col = orig_bounds['min_col'] + move_dist + 1 # Exclusive index
            # Example 2: start=0, end=0+11+1=12. Fill cols 0..11 -> No, output shows 0..12 filled.
            # Let's try end = start + move_dist + pattern_width ? No..
            # Let's stick to the derived formula end = start + move_dist + 1. This makes range [start, start+move_dist].
            # Example 2: start=0, move_dist=11 -> range [0, 11]. Output has 0..12. Off by one.
            # Maybe end_9_col = moved_bounds['max_col'] - orig_width + 1 + move_dist + 1? No..
            # Revisit calculation: start = 0. end = 0 + 11 = 11. If range is inclusive [start, end+1]? [0, 12]. Yes.
            end_9_col = orig_bounds['min_col'] + move_dist + 1 # Let's try making this inclusive end, so slice needs +1

        else: # move_left
            start_9_col = orig_bounds['max_col'] - move_dist + 1
            # Example 1: start = 16 - 12 + 1 = 5.
            end_9_col = orig_bounds['max_col'] # Inclusive end
            # Example 1: range [5, 16]. Correct.

        # Ensure columns are within grid bounds before slicing
        start_9_col = max(0, start_9_col)
        end_9_col = min(cols, end_9_col + 1) # Add 1 for exclusive slicing index

        if start_9_col < end_9_col: # Check if range is valid
            output_arr[barrier_row_idx, start_9_col:end_9_col] = 9

    # --- Copy the rest of the '6' barrier ---
    if barrier_row_idx is not None and barrier_row_idx + 1 < rows:
        output_arr[barrier_row_idx + 1:, :] = input_arr[barrier_row_idx + 1:, :]

    # Convert back to list of lists for the final output
    return output_arr.tolist()

```
```python
import numpy as np
from typing import List, Dict, Optional, Tuple

"""
Transforms an input grid based on identifying a pattern ('5'), a barrier ('6'), moving the pattern to the opposite side, drawing a diagonal trace from the original pattern's position, and marking the first barrier row with '9's based on the movement.

1.  Initialize a new grid (`output_grid`) with the same dimensions as the `input_grid`, filled entirely with the background color `1`.
2.  Identify the bounding box (`original_bounds`: min/max row/col) of the connected pattern of cells with color `5` in the `input_grid`. Also determine its width.
3.  Identify the starting row index (`barrier_row_idx`) of the solid block of rows containing only color `6` at the bottom of the `input_grid`.
4.  Copy all rows from `barrier_row_idx` to the bottom of the `input_grid` (the barrier) to the corresponding rows in `output_grid`.
5.  Determine the horizontal movement direction: if the `original_bounds['min_col']` is less than half the grid width, the pattern moves right; otherwise, it moves left.
6.  Calculate the bounding box (`moved_bounds`) for the pattern's destination in `output_grid`: maintain the original min/max rows; if moving right, set `min_col` to `grid_cols - width` and `max_col` to `grid_cols - 1`; if moving left, set `min_col` to `0` and `max_col` to `width - 1`.
7.  Copy the `5` colored cells from the `input_grid` within `original_bounds` to their corresponding relative positions within the `moved_bounds` in `output_grid`. Overwrite any existing values.
8.  Generate a diagonal trace:
    *   Set the diagonal step: `dr=1`. If moving right, `dc=1`; if moving left, `dc=-1`.
    *   For each cell `(r, c)` in the `input_grid` that is within `original_bounds` and has color `5`:
        *   Initialize the trace position `(cr, cc)` to `(r + dr, c + dc)`.
        *   While the trace position `(cr, cc)` is within the grid boundaries, is above the barrier (`cr < barrier_row_idx`), AND the cell `output_grid[cr, cc]` does *not* already contain color `5`:
            *   Set `output_grid[cr, cc]` to `5`.
            *   Update the trace position: `cr += dr`, `cc += dc`.
9.  Place the barrier markers:
    *   Calculate `start_col` and `end_col` (inclusive) for the markers based on movement direction and bounds.
    *   Overwrite the cells in `output_grid` at row `barrier_row_idx` from `start_col` to `end_col` (inclusive) with the marker color `9`.
"""


def find_pattern_bounds(grid: np.ndarray, value: int) -> Optional[Dict[str, int]]:
    """Finds the min/max row/col for all cells matching the given value."""
    rows_idx, cols_idx = np.where(grid == value)
    if rows_idx.size == 0:
        return None
    min_row = int(np.min(rows_idx))
    max_row = int(np.max(rows_idx))
    min_col = int(np.min(cols_idx))
    max_col = int(np.max(cols_idx))
    return {
        'min_row': min_row,
        'max_row': max_row,
        'min_col': min_col,
        'max_col': max_col,
        'width': max_col - min_col + 1,
        'height': max_row - min_row + 1
    }

def find_barrier_row(grid: np.ndarray, value: int) -> Optional[int]:
    """Finds the first row index consisting entirely of the barrier value."""
    rows, _ = grid.shape
    for r in range(rows):
        # Check if all elements in the row equal the barrier value
        # Using np.all is robust, but examples suggest barrier might just start
        # Let's find the first row CONTAINING the value, assuming structure
        if value in grid[r, :]:
            # Verify if it's the start of the barrier block
            is_barrier_start = True
            # Check if all rows from here down contain only 6 (or are out of bounds)
            # This is complex, let's simplify: Find first row with ANY 6s, assuming it's the start.
            rows_with_value, _ = np.where(grid == value)
            if rows_with_value.size > 0:
                return int(np.min(rows_with_value))
            else:
                return None # No barrier found
    return None # No barrier found

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """Applies the transformation rules to the input grid."""
    
    # Convert input to numpy array for easier manipulation
    input_arr = np.array(input_grid, dtype=int)
    rows, cols = input_arr.shape

    # 1. Initialize output grid with background value '1'
    output_arr = np.ones_like(input_arr) * 1

    # 2. Find the bounds of the '5' pattern
    original_bounds = find_pattern_bounds(input_arr, 5)
    if not original_bounds:
        # Handle case where pattern '5' is missing - return original or background?
        # Assuming pattern is always present based on examples. If not, copy barrier maybe.
        barrier_row_idx_fallback = find_barrier_row(input_arr, 6)
        if barrier_row_idx_fallback is not None:
            output_arr[barrier_row_idx_fallback:, :] = input_arr[barrier_row_idx_fallback:, :]
        return output_arr.tolist()

    # 3. Find the first row of the '6' barrier
    barrier_row_idx = find_barrier_row(input_arr, 6)
    if barrier_row_idx is None:
         # Handle case where barrier '6' is missing - assume it's off-grid?
         barrier_row_idx = rows # Treat as if barrier starts just after last row

    # 4. Copy the barrier from input to output
    if barrier_row_idx < rows:
        output_arr[barrier_row_idx:, :] = input_arr[barrier_row_idx:, :]

    # 5. Determine movement direction
    move_right = original_bounds['min_col'] < cols / 2
    pattern_width = original_bounds['width']
    pattern_height = original_bounds['height']

    # 6. Calculate moved bounds
    moved_bounds = {}
    moved_bounds['min_row'] = original_bounds['min_row']
    moved_bounds['max_row'] = original_bounds['max_row']
    if move_right:
        moved_bounds['min_col'] = cols - pattern_width
        moved_bounds['max_col'] = cols - 1
    else: # move_left
        moved_bounds['min_col'] = 0
        moved_bounds['max_col'] = pattern_width - 1

    # 7. Copy the moved pattern to the output grid
    # Iterate through the original pattern's bounding box
    for r_idx, r in enumerate(range(original_bounds['min_row'], original_bounds['max_row'] + 1)):
        for c_idx, c in enumerate(range(original_bounds['min_col'], original_bounds['max_col'] + 1)):
            # Check if the cell in the input actually contains the pattern value
            if input_arr[r, c] == 5:
                # Calculate the corresponding target cell in the moved position
                target_r = moved_bounds['min_row'] + r_idx
                target_c = moved_bounds['min_col'] + c_idx
                # Ensure target is within grid bounds before writing
                if 0 <= target_r < rows and 0 <= target_c < cols:
                     output_arr[target_r, target_c] = 5 # Overwrite whatever is there

    # 8. Generate the diagonal trace
    dr = 1
    dc = 1 if move_right else -1

    # Iterate through original pattern cells again
    for r in range(original_bounds['min_row'], original_bounds['max_row'] + 1):
        for c in range(original_bounds['min_col'], original_bounds['max_col'] + 1):
            # Start trace only from original '5' positions
            if input_arr[r, c] == 5:
                # Initialize trace start position (one step down diagonally)
                cr, cc = r + dr, c + dc
                # Loop while trace is valid
                while (0 <= cr < rows and          # within row bounds
                       0 <= cc < cols and          # within col bounds
                       cr < barrier_row_idx and    # above barrier
                       output_arr[cr, cc] != 5):   # does not collide with moved pattern
                    
                    # Place the trace '5'
                    output_arr[cr, cc] = 5
                    
                    # Move to the next diagonal position
                    cr += dr
                    cc += dc

    # 9. Place '9' markers in the first barrier row
    if barrier_row_idx < rows: # Check if barrier exists within grid
        start_9_col = 0
        end_9_col = 0 # Inclusive end column index

        if move_right:
            # Start at original pattern's left edge
            start_9_col = original_bounds['min_col']
            # End just past the moved pattern's left edge (derived from Ex2 metrics)
            end_9_col = moved_bounds['min_col'] + 1
            # Ex2: orig_min=0, moved_min=11. Target [0, 12]. start=0, end=11+1=12. Correct.
        else: # move_left
            # Start just past the moved pattern's right edge (derived from Ex1 metrics)
            start_9_col = moved_bounds['max_col'] + 1
            # End at the original pattern's right edge
            end_9_col = original_bounds['max_col']
            # Ex1: moved_max=4, orig_max=16. Target [5, 16]. start=4+1=5, end=16. Correct.

        # Clip column indices to be within grid bounds
        start_9_col = max(0, start_9_col)
        end_9_col = min(cols - 1, end_9_col) # Ensure end is valid index

        # Place markers if the range is valid
        if start_9_col <= end_9_col:
             output_arr[barrier_row_idx, start_9_col : end_9_col + 1] = 9 # Use end+1 for slicing

    # Convert back to list of lists for the final output
    return output_arr.tolist()
```
