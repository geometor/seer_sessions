{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying pattern components (non-zero, non-8 digits) and template components (digit 8). It maps each template component to the spatially closest pattern component based on the Euclidean distance between their normalized centroids (normalized by overall grid dimensions). The template components in the output grid are then filled with the color of their corresponding mapped pattern component.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, center_of_mass\nfrom scipy.spatial.distance import cdist\nimport math # Added math import\n\ndef find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:\n    \"\"\"\n    Finds connected components in a grid for a specific value or based on a mask.\n    Uses 8-connectivity.\n\n    Args:\n        grid: The input NumPy array.\n        target_value: The integer value to find components of. If None, use mask.\n        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.\n\n    Returns:\n        A list of dictionaries, each representing a component with:\n          'coords': list of (row, col) tuples.\n          'centroid': (row, col) tuple for the component's center of mass.\n          'color': The integer color/value of the component.\n    \"\"\"\n    if mask is None and target_value is not None:\n        binary_mask = (grid == target_value)\n    elif mask is not None:\n        binary_mask = mask\n    else:\n        raise ValueError(\"Either target_value or mask must be provided.\")\n\n    # Define 8-connectivity structure\n    structure = np.ones((3, 3), dtype=bool)\n    \n    # Label connected components\n    labeled_array, num_features = label(binary_mask, structure=structure)\n    \n    components = []\n    if num_features > 0:\n        # Calculate centroids using scipy's center_of_mass for potentially better handling\n        # Needs the original grid for color determination if using a generic mask\n        # Index needs to be a list or tuple for versions >= 1.9\n        component_indices = list(range(1, num_features + 1)) # Ensure it's a list\n        \n        # Calculate geometric centroids (ignoring grid values for position)\n        centroids = center_of_mass(input=binary_mask, labels=labeled_array, index=component_indices)\n        \n        # If only one component, center_of_mass returns a tuple, not a list of tuples\n        if num_features == 1:\n             centroids = [centroids] # Make it a list containing the single tuple\n\n        for i, centroid_coords in enumerate(centroids):\n            component_label = component_indices[i] # The actual label value (1-based)\n            # Get coordinates for the current component\n            coords_raw = np.argwhere(labeled_array == component_label)\n            if coords_raw.size > 0:\n                coords = [tuple(coord) for coord in coords_raw]                \n                \n                component_info = {\n                    'coords': coords,\n                    'centroid': centroid_coords, # Use calculated centroid\n                }\n                # Determine component color\n                if target_value is not None:\n                   component_info['color'] = target_value\n                elif mask is not None: # Assumes single color per component if using mask\n                   # Get color from the first coordinate of the component in the original grid\n                   first_coord = coords[0] \n                   component_info['color'] = grid[first_coord]\n                else: # Should not happen based on initial check\n                    component_info['color'] = -1 # Error indicator\n\n                components.append(component_info)\n                \n    return components\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the pattern-template transformation using normalized centroid mapping.\n\n    Args:\n        input_grid: A 2D list of integers representing the input grid.\n\n    Returns:\n        A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # --- 1. Identify Pattern Components ---\n    pattern_components = []\n    # Identify unique colors in the potential pattern region (non-zero, not 8)\n    unique_colors = np.unique(grid)\n    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]\n\n    # Find connected components for each pattern color\n    for color in pattern_colors:\n        components_for_color = find_connected_components(grid, target_value=color)\n        pattern_components.extend(components_for_color)\n\n    # --- 2. Identify Template Components ---\n    template_components = find_connected_components(grid, target_value=8)\n\n    # --- 3. Handle edge cases: No pattern or no template ---\n    if not pattern_components or not template_components:\n        # If either region is missing, no transformation can be applied\n        return output_grid.tolist() \n\n    # --- 4. Calculate Normalized Centroids ---\n    # Avoid division by zero if rows or cols is 1 (or 0, though unlikely)\n    norm_rows = rows if rows > 0 else 1\n    norm_cols = cols if cols > 0 else 1\n    \n    # Ensure centroids are valid numbers before normalization\n    pattern_centroids = np.array([comp['centroid'] for comp in pattern_components if not (math.isnan(comp['centroid'][0]) or math.isnan(comp['centroid'][1]))])\n    template_centroids = np.array([comp['centroid'] for comp in template_components if not (math.isnan(comp['centroid'][0]) or math.isnan(comp['centroid'][1]))])\n\n    # Check if filtering removed all components\n    if pattern_centroids.shape[0] == 0 or template_centroids.shape[0] == 0:\n         print(\"Warning: Valid centroids not found for all components.\")\n         return output_grid.tolist() # Cannot proceed without centroids\n\n    # Apply normalization\n    pattern_centroids_norm = pattern_centroids / [norm_rows, norm_cols]\n    template_centroids_norm = template_centroids / [norm_rows, norm_cols]\n    \n    # Make sure the number of normalized centroids matches the filtered component lists\n    valid_pattern_components = [comp for comp in pattern_components if not (math.isnan(comp['centroid'][0]) or math.isnan(comp['centroid'][1]))]\n    valid_template_components = [comp for comp in template_components if not (math.isnan(comp['centroid'][0]) or math.isnan(comp['centroid'][1]))]\n\n    # --- 5. Map Template Components to Pattern Components ---\n    # Compute pairwise distances between normalized template and pattern centroids\n    # shape: (num_template_components, num_pattern_components)\n    distances = cdist(template_centroids_norm, pattern_centroids_norm)\n\n    # Find the index of the closest pattern component for each template component\n    # shape: (num_template_components,)\n    closest_pattern_indices = np.argmin(distances, axis=1)\n\n    # --- 6. Apply Color Transformation ---\n    # Iterate through each *valid* template component and apply the mapped color\n    for i, template_comp in enumerate(valid_template_components):\n        # Get the index of the closest *valid* pattern component\n        pattern_idx = closest_pattern_indices[i]\n        # Get the color of that pattern component from the filtered list\n        mapped_color = valid_pattern_components[pattern_idx]['color']\n        \n        # Update the output grid for all coordinates of the current template component\n        for r, c in template_comp['coords']:\n            # Check bounds just in case, though coords should be valid\n            if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = mapped_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15152,
    "candidates_token_count": 2508,
    "total_token_count": 17660,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.130972,
  "retries": 1
}