{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on pattern and template regions.\n\nThe transformation identifies two distinct regions in the input grid:\n1.  Pattern Region: Contains connected components of non-zero digits other than 8.\n2.  Template Region: Contains connected components of the digit 8.\n\nThe transformation logic is as follows:\n1.  Identify all connected components within the pattern region, noting the color (digit) of each component.\n2.  Identify all connected components within the template region (all composed of the digit 8).\n3.  Calculate a representative point (centroid) for each pattern component and each template component, normalized by the grid dimensions.\n4.  For each template component, find the pattern component whose normalized centroid is closest (using Euclidean distance).\n5.  Create an output grid by copying the input grid.\n6.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.\n7.  The pattern region and background (0s) remain unchanged in the output grid.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, center_of_mass\nfrom scipy.spatial.distance import cdist\n\ndef find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:\n    \"\"\"\n    Finds connected components in a grid for a specific value or based on a mask.\n    Uses 8-connectivity.\n\n    Args:\n        grid: The input NumPy array.\n        target_value: The integer value to find components of. If None, use mask.\n        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.\n\n    Returns:\n        A list of dictionaries, each representing a component with:\n          'coords': list of (row, col) tuples.\n          'centroid': (row, col) tuple for the component's center of mass.\n          'color': The integer color/value of the component (if target_value was used).\n    \"\"\"\n    if mask is None and target_value is not None:\n        binary_mask = (grid == target_value)\n    elif mask is not None:\n        binary_mask = mask\n    else:\n        raise ValueError(\"Either target_value or mask must be provided.\")\n\n    # Define 8-connectivity structure\n    structure = np.ones((3, 3), dtype=bool)\n    \n    # Label connected components\n    labeled_array, num_features = label(binary_mask, structure=structure)\n    \n    components = []\n    if num_features > 0:\n        # Calculate centroids (center_of_mass) for all components at once\n        # Note: center_of_mass needs the original grid values if weighting is desired,\n        # but here we just need the geometric center of the mask, so input=labeled_array works.\n        # However, using binary_mask might be more direct for geometric center.\n        # We calculate centroids individually to ensure correct association.\n        \n        component_indices = np.arange(1, num_features + 1)\n        # centroids = center_of_mass(binary_mask, labeled_array, component_indices) # scipy < 1.9\n        # centroids = center_of_mass(input=binary_mask, labels=labeled_array, index=component_indices) # scipy >= 1.9\n\n        for i in component_indices:\n            coords_raw = np.argwhere(labeled_array == i)\n            if coords_raw.size > 0:\n                # coords need to be list of tuples for consistency if used elsewhere\n                coords = [tuple(coord) for coord in coords_raw]\n                \n                # Calculate centroid manually for robustness across scipy versions\n                centroid = np.mean(coords_raw, axis=0)\n\n                component_info = {\n                    'coords': coords,\n                    'centroid': tuple(centroid),\n                }\n                # If finding components of a specific value, store its color\n                if target_value is not None:\n                   component_info['color'] = target_value\n                # If using a mask derived from multiple colors (pattern region),\n                # determine color from the first coordinate. Assumes components are single-colored.\n                elif mask is not None and target_value is None:\n                   first_coord = coords[0]\n                   component_info['color'] = grid[first_coord]\n\n                components.append(component_info)\n                \n    return components\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the pattern-template transformation to the input grid.\n\n    Args:\n        input_grid: A 2D list of integers representing the input grid.\n\n    Returns:\n        A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # --- 1. Identify Pattern Components ---\n    pattern_components = []\n    # Identify unique colors in the potential pattern region (non-zero, not 8)\n    unique_colors = np.unique(grid)\n    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]\n\n    # Find connected components for each pattern color\n    for color in pattern_colors:\n        components_for_color = find_connected_components(grid, target_value=color)\n        pattern_components.extend(components_for_color)\n\n    # --- 2. Identify Template Components ---\n    template_components = find_connected_components(grid, target_value=8)\n\n    # --- Handle edge cases: No pattern or no template ---\n    if not pattern_components or not template_components:\n        # If either region is missing, no transformation can be applied\n        return output_grid.tolist() \n\n    # --- 3. Calculate Normalized Centroids ---\n    # Normalize centroids by grid dimensions for relative positioning\n    pattern_centroids_norm = np.array([\n        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) \n        for comp in pattern_components\n    ])\n    template_centroids_norm = np.array([\n        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) \n        for comp in template_components\n    ])\n\n    # --- 4. Map Template Components to Pattern Components ---\n    # Compute pairwise distances between normalized template and pattern centroids\n    # shape: (num_template_components, num_pattern_components)\n    distances = cdist(template_centroids_norm, pattern_centroids_norm)\n\n    # Find the index of the closest pattern component for each template component\n    # shape: (num_template_components,)\n    closest_pattern_indices = np.argmin(distances, axis=1)\n\n    # --- 5. Apply Color Transformation ---\n    # Iterate through each template component and apply the mapped color\n    for i, template_comp in enumerate(template_components):\n        # Get the index of the closest pattern component\n        pattern_idx = closest_pattern_indices[i]\n        # Get the color of that pattern component\n        mapped_color = pattern_components[pattern_idx]['color']\n        \n        # Update the output grid for all coordinates of the current template component\n        for r, c in template_comp['coords']:\n            output_grid[r, c] = mapped_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3967,
    "candidates_token_count": 2941,
    "total_token_count": 6908,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.222393,
  "retries": 1
}