
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down the task based on the provided examples.

## Perception

1.  **Input Structure:** The input grids contain distinct regions. One region (let's call it the "pattern region") consists of various non-zero digits *other than* 8. Another region (let's call it the "template region") consists *only* of the digit 8. The rest of the grid is filled with 0s (background).
2.  **Output Structure:** The output grids are largely similar to the input grids. The pattern region remains completely unchanged. The background 0s also remain unchanged. The significant change occurs in the template region.
3.  **Transformation:** The areas originally occupied by the digit 8 in the input are filled with the digits found in the pattern region in the output. The digit 8 itself disappears.
4.  **Color Mapping:** The transformation isn't a simple replacement of all 8s with a single color. Instead, the template region (originally all 8s) is segmented into sub-regions in the output, each filled with a specific color from the pattern region.
5.  **Structural Preservation:** The shapes and connectivity of the sub-regions within the template area seem preserved. If the input template region consists of several disconnected components of 8s, the output maintains these disconnected components, but fills each with a color derived from the pattern region.
6.  **Mapping Logic:** The core logic appears to involve mapping the connected components of the pattern region (each with a unique color) to the connected components of the template region (originally color 8). This mapping seems based on the relative spatial positioning of these components within their respective overall regions. For example, a pattern component in the top-left of the pattern region likely dictates the color for the template component(s) in the top-left of the template region.

## Facts


```yaml
task_elements:
  - object: grid
    description: A 2D array of single digits.
    properties:
      - rows: integer
      - columns: integer
      - cells: list of lists of integers (0-9)

  - object: pattern_region
    description: An area within the input grid containing non-zero digits, excluding the digit 8.
    properties:
      - colors: set of integers (1-7, 9) present in the region.
      - location: coordinates of the cells belonging to this region.
      - components: list of connected sub-regions within the pattern region, each associated with a single color.

  - object: template_region
    description: An area within the input grid containing only the digit 8.
    properties:
      - color: 8 (constant)
      - location: coordinates of the cells belonging to this region.
      - components: list of connected sub-regions (using 8-connectivity) within the template region.

  - object: background
    description: Cells in the grid with the value 0.

relationships:
  - type: contains
    source: grid
    target: pattern_region
  - type: contains
    source: grid
    target: template_region
  - type: contains
    source: grid
    target: background
  - type: spatial_mapping
    description: >
      A correspondence exists between the pattern region components and the template region components based on their relative positions within their respective bounding boxes or overall structures.

actions:
  - action: identify_regions
    description: Locate the pattern_region and template_region within the input grid.
  - action: find_components
    description: >
      Identify the connected components within the pattern_region (grouping by color)
      and within the template_region (all color 8). 8-connectivity seems appropriate.
  - action: map_components
    description: >
      Establish a mapping from each template_region component to a pattern_region component.
      This mapping is determined by matching the relative spatial positions (e.g., using normalized centroids or bounding box centers).
  - action: replace_color
    description: >
      Create the output grid by copying the input grid. Then, for each template_region component,
      replace the color (8) of all its cells with the color of the pattern_region component it maps to.
```


## Natural Language Program

1.  **Initialize Output:** Create a copy of the input grid to serve as the basis for the output grid.
2.  **Identify Pattern Components:** Scan the input grid to find all connected components composed of non-zero digits other than 8. For each component, record its constituent cell coordinates and its single color.
3.  **Identify Template Components:** Scan the input grid to find all connected components composed solely of the digit 8. For each component, record its constituent cell coordinates.
4.  **Determine Component Mapping:**
    *   Calculate a representative point (e.g., centroid) for each pattern component and each template component.
    *   Normalize these points relative to the overall extent (e.g., bounding box) of the pattern region and template region, respectively.
    *   For each template component, find the pattern component whose normalized representative point is spatially closest (e.g., minimum Euclidean distance). This establishes the mapping.
5.  **Apply Color Transformation:** Iterate through each identified template component. Use the mapping determined in step 4 to find the corresponding pattern component and its color. Fill all cells belonging to the current template component in the *output grid* with this mapped color.
6.  **Finalize:** The modified output grid, containing the original pattern region, the background, and the color-transformed template region, is the final result.
```python
"""
Transforms an input grid based on pattern and template regions.

The transformation identifies two distinct regions in the input grid:
1.  Pattern Region: Contains connected components of non-zero digits other than 8.
2.  Template Region: Contains connected components of the digit 8.

The transformation logic is as follows:
1.  Identify all connected components within the pattern region, noting the color (digit) of each component.
2.  Identify all connected components within the template region (all composed of the digit 8).
3.  Calculate a representative point (centroid) for each pattern component and each template component, normalized by the grid dimensions.
4.  For each template component, find the pattern component whose normalized centroid is closest (using Euclidean distance).
5.  Create an output grid by copying the input grid.
6.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.
7.  The pattern region and background (0s) remain unchanged in the output grid.
"""

import numpy as np
from scipy.ndimage import label, center_of_mass
from scipy.spatial.distance import cdist

def find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:
    """
    Finds connected components in a grid for a specific value or based on a mask.
    Uses 8-connectivity.

    Args:
        grid: The input NumPy array.
        target_value: The integer value to find components of. If None, use mask.
        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.

    Returns:
        A list of dictionaries, each representing a component with:
          'coords': list of (row, col) tuples.
          'centroid': (row, col) tuple for the component's center of mass.
          'color': The integer color/value of the component (if target_value was used).
    """
    if mask is None and target_value is not None:
        binary_mask = (grid == target_value)
    elif mask is not None:
        binary_mask = mask
    else:
        raise ValueError("Either target_value or mask must be provided.")

    # Define 8-connectivity structure
    structure = np.ones((3, 3), dtype=bool)
    
    # Label connected components
    labeled_array, num_features = label(binary_mask, structure=structure)
    
    components = []
    if num_features > 0:
        # Calculate centroids (center_of_mass) for all components at once
        # Note: center_of_mass needs the original grid values if weighting is desired,
        # but here we just need the geometric center of the mask, so input=labeled_array works.
        # However, using binary_mask might be more direct for geometric center.
        # We calculate centroids individually to ensure correct association.
        
        component_indices = np.arange(1, num_features + 1)
        # centroids = center_of_mass(binary_mask, labeled_array, component_indices) # scipy < 1.9
        # centroids = center_of_mass(input=binary_mask, labels=labeled_array, index=component_indices) # scipy >= 1.9

        for i in component_indices:
            coords_raw = np.argwhere(labeled_array == i)
            if coords_raw.size > 0:
                # coords need to be list of tuples for consistency if used elsewhere
                coords = [tuple(coord) for coord in coords_raw]
                
                # Calculate centroid manually for robustness across scipy versions
                centroid = np.mean(coords_raw, axis=0)

                component_info = {
                    'coords': coords,
                    'centroid': tuple(centroid),
                }
                # If finding components of a specific value, store its color
                if target_value is not None:
                   component_info['color'] = target_value
                # If using a mask derived from multiple colors (pattern region),
                # determine color from the first coordinate. Assumes components are single-colored.
                elif mask is not None and target_value is None:
                   first_coord = coords[0]
                   component_info['color'] = grid[first_coord]

                components.append(component_info)
                
    return components


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the pattern-template transformation to the input grid.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    # Convert input to numpy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # --- 1. Identify Pattern Components ---
    pattern_components = []
    # Identify unique colors in the potential pattern region (non-zero, not 8)
    unique_colors = np.unique(grid)
    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]

    # Find connected components for each pattern color
    for color in pattern_colors:
        components_for_color = find_connected_components(grid, target_value=color)
        pattern_components.extend(components_for_color)

    # --- 2. Identify Template Components ---
    template_components = find_connected_components(grid, target_value=8)

    # --- Handle edge cases: No pattern or no template ---
    if not pattern_components or not template_components:
        # If either region is missing, no transformation can be applied
        return output_grid.tolist() 

    # --- 3. Calculate Normalized Centroids ---
    # Normalize centroids by grid dimensions for relative positioning
    pattern_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in pattern_components
    ])
    template_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in template_components
    ])

    # --- 4. Map Template Components to Pattern Components ---
    # Compute pairwise distances between normalized template and pattern centroids
    # shape: (num_template_components, num_pattern_components)
    distances = cdist(template_centroids_norm, pattern_centroids_norm)

    # Find the index of the closest pattern component for each template component
    # shape: (num_template_components,)
    closest_pattern_indices = np.argmin(distances, axis=1)

    # --- 5. Apply Color Transformation ---
    # Iterate through each template component and apply the mapped color
    for i, template_comp in enumerate(template_components):
        # Get the index of the closest pattern component
        pattern_idx = closest_pattern_indices[i]
        # Get the color of that pattern component
        mapped_color = pattern_components[pattern_idx]['color']
        
        # Update the output grid for all coordinates of the current template component
        for r, c in template_comp['coords']:
            output_grid[r, c] = mapped_color

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```

Previous Code:
```python
"""
Transforms an input grid based on pattern and template regions.

The transformation identifies two distinct regions in the input grid:
1.  Pattern Region: Contains connected components of non-zero digits other than 8.
2.  Template Region: Contains connected components of the digit 8.

The transformation logic is as follows:
1.  Identify all connected components within the pattern region, noting the color (digit) of each component.
2.  Identify all connected components within the template region (all composed of the digit 8).
3.  Calculate a representative point (centroid) for each pattern component and each template component, normalized by the grid dimensions.
4.  For each template component, find the pattern component whose normalized centroid is closest (using Euclidean distance).
5.  Create an output grid by copying the input grid.
6.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.
7.  The pattern region and background (0s) remain unchanged in the output grid.
"""

import numpy as np
from scipy.ndimage import label, center_of_mass
from scipy.spatial.distance import cdist

def find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:
    """
    Finds connected components in a grid for a specific value or based on a mask.
    Uses 8-connectivity.

    Args:
        grid: The input NumPy array.
        target_value: The integer value to find components of. If None, use mask.
        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.

    Returns:
        A list of dictionaries, each representing a component with:
          'coords': list of (row, col) tuples.
          'centroid': (row, col) tuple for the component's center of mass.
          'color': The integer color/value of the component (if target_value was used).
    """
    if mask is None and target_value is not None:
        binary_mask = (grid == target_value)
    elif mask is not None:
        binary_mask = mask
    else:
        raise ValueError("Either target_value or mask must be provided.")

    # Define 8-connectivity structure
    structure = np.ones((3, 3), dtype=bool)
    
    # Label connected components
    labeled_array, num_features = label(binary_mask, structure=structure)
    
    components = []
    if num_features > 0:
        # Calculate centroids (center_of_mass) for all components at once
        # Note: center_of_mass needs the original grid values if weighting is desired,
        # but here we just need the geometric center of the mask, so input=labeled_array works.
        # However, using binary_mask might be more direct for geometric center.
        # We calculate centroids individually to ensure correct association.
        
        component_indices = np.arange(1, num_features + 1)
        # centroids = center_of_mass(binary_mask, labeled_array, component_indices) # scipy < 1.9
        # centroids = center_of_mass(input=binary_mask, labels=labeled_array, index=component_indices) # scipy >= 1.9

        for i in component_indices:
            coords_raw = np.argwhere(labeled_array == i)
            if coords_raw.size > 0:
                # coords need to be list of tuples for consistency if used elsewhere
                coords = [tuple(coord) for coord in coords_raw]
                
                # Calculate centroid manually for robustness across scipy versions
                centroid = np.mean(coords_raw, axis=0)

                component_info = {
                    'coords': coords,
                    'centroid': tuple(centroid),
                }
                # If finding components of a specific value, store its color
                if target_value is not None:
                   component_info['color'] = target_value
                # If using a mask derived from multiple colors (pattern region),
                # determine color from the first coordinate. Assumes components are single-colored.
                elif mask is not None and target_value is None:
                   first_coord = coords[0]
                   component_info['color'] = grid[first_coord]

                components.append(component_info)
                
    return components


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the pattern-template transformation to the input grid.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    # Convert input to numpy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # --- 1. Identify Pattern Components ---
    pattern_components = []
    # Identify unique colors in the potential pattern region (non-zero, not 8)
    unique_colors = np.unique(grid)
    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]

    # Find connected components for each pattern color
    for color in pattern_colors:
        components_for_color = find_connected_components(grid, target_value=color)
        pattern_components.extend(components_for_color)

    # --- 2. Identify Template Components ---
    template_components = find_connected_components(grid, target_value=8)

    # --- Handle edge cases: No pattern or no template ---
    if not pattern_components or not template_components:
        # If either region is missing, no transformation can be applied
        return output_grid.tolist() 

    # --- 3. Calculate Normalized Centroids ---
    # Normalize centroids by grid dimensions for relative positioning
    pattern_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in pattern_components
    ])
    template_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in template_components
    ])

    # --- 4. Map Template Components to Pattern Components ---
    # Compute pairwise distances between normalized template and pattern centroids
    # shape: (num_template_components, num_pattern_components)
    distances = cdist(template_centroids_norm, pattern_centroids_norm)

    # Find the index of the closest pattern component for each template component
    # shape: (num_template_components,)
    closest_pattern_indices = np.argmin(distances, axis=1)

    # --- 5. Apply Color Transformation ---
    # Iterate through each template component and apply the mapped color
    for i, template_comp in enumerate(template_components):
        # Get the index of the closest pattern component
        pattern_idx = closest_pattern_indices[i]
        # Get the color of that pattern component
        mapped_color = pattern_components[pattern_idx]['color']
        
        # Update the output grid for all coordinates of the current template component
        for r, c in template_comp['coords']:
            output_grid[r, c] = mapped_color

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 4 4 4 0 0 0 0 0
0 0 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 4 4 0 0 0 0 0 0 0
0 0 0 0 4 4 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 4 4 0 0 0
0 0 0 0 4 4 4 4 4 4 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 28
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 17.948717948717956

## Example 2:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 4 4 4 4 4 4 0 0 0 0 0
0 4 4 4 4 4 4 0 0 0 0 0
0 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 0 0
0 4 4 4 0 0 0 4 4 4 0 0
0 4 4 4 0 0 0 4 4 4 0 0
0 4 4 4 0 0 0 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 36
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 27.27272727272728
## Assessment and Strategy

**Assessment:**

The initial code correctly identified the pattern region (non-zero, non-8 digits) and the template region (digit 8). It also correctly identified the connected components within each region. However, the mapping strategy, based on the closest normalized centroid relative to the *entire grid*, failed. In both examples, this led to an incorrect assignment of colors to the template components, often favoring a single pattern color (color '4' in the provided outputs).

**Strategy:**

The core issue lies in how the spatial relationship between pattern components and template components is defined and measured. The strategy is to refine the mapping logic:

1.  **Bounding Box Normalization:** Instead of normalizing centroids by the full grid dimensions, normalize them relative to the bounding box of their respective regions (pattern region and template region). This should capture the *relative* position within each cluster of components more accurately.
2.  **Calculate Bounding Boxes:** Determine the minimum and maximum row and column for the pattern region (all cells with colors 1-7 or 9) and the template region (all cells with color 8).
3.  **Normalize Centroids within Bounding Boxes:** For each pattern component centroid `(r, c)`, calculate its normalized position `((r - min_r_pattern) / height_pattern, (c - min_c_pattern) / width_pattern)`. Do the same for template component centroids relative to the template bounding box.
4.  **Re-evaluate Closest Component:** Use the newly normalized centroids to find the closest pattern component for each template component using Euclidean distance.
5.  **Update Documentation:** Reflect this refined mapping strategy in the facts and natural language program.

## Metrics Gathering

Let's calculate the bounding boxes and normalized centroids for the first example to test the refined strategy.

