{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom scipy.spatial.distance import cdist\n\n\"\"\"\nTransforms an input grid based on pattern and template regions using relative spatial mapping within bounding boxes.\n\nThe transformation identifies two distinct regions in the input grid:\n1.  Pattern Region: Contains connected components of non-zero digits other than 8.\n2.  Template Region: Contains connected components of the digit 8.\n\nThe transformation logic is as follows:\n1.  Identify all connected components within the pattern region, noting the color (digit) and centroid of each component.\n2.  Identify all connected components within the template region (all composed of the digit 8), noting the centroid of each component.\n3.  Determine the overall bounding box for the pattern region and the template region.\n4.  Normalize the centroid of each pattern component relative to the pattern region's bounding box.\n5.  Normalize the centroid of each template component relative to the template region's bounding box.\n6.  For each template component, find the pattern component whose normalized centroid (within its respective bounding box) is closest (using Euclidean distance).\n7.  Create an output grid by copying the input grid.\n8.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.\n9.  The pattern region and background (0s) remain unchanged in the output grid.\n\"\"\"\n\ndef find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:\n    \"\"\"\n    Finds connected components in a grid for a specific value or based on a mask.\n    Uses 8-connectivity.\n\n    Args:\n        grid: The input NumPy array.\n        target_value: The integer value to find components of. If None, use mask.\n        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.\n\n    Returns:\n        A list of dictionaries, each representing a component with:\n          'coords': list of (row, col) tuples.\n          'centroid': (row, col) tuple for the component's center of mass.\n          'color': The integer color/value of the component.\n    \"\"\"\n    if mask is None and target_value is not None:\n        binary_mask = (grid == target_value)\n    elif mask is not None:\n        binary_mask = mask\n    else:\n        raise ValueError(\"Either target_value or mask must be provided.\")\n\n    # Define 8-connectivity structure\n    structure = np.ones((3, 3), dtype=bool)\n    \n    # Label connected components\n    labeled_array, num_features = label(binary_mask, structure=structure)\n    \n    components = []\n    if num_features > 0:\n        component_indices = np.arange(1, num_features + 1)\n        for i in component_indices:\n            # Get coordinates for the current component\n            coords_raw = np.argwhere(labeled_array == i)\n            if coords_raw.size > 0:\n                coords = [tuple(coord) for coord in coords_raw]\n                # Calculate centroid (center of mass)\n                centroid = tuple(np.mean(coords_raw, axis=0))\n                \n                component_info = {\n                    'coords': coords,\n                    'centroid': centroid,\n                }\n                # Determine component color\n                if target_value is not None:\n                   component_info['color'] = target_value\n                elif mask is not None: # Assumes single color per component if using mask\n                   first_coord = coords[0]\n                   component_info['color'] = grid[first_coord]\n                else: # Should not happen based on initial check\n                    component_info['color'] = -1 # Error indicator\n\n                components.append(component_info)\n                \n    return components\n\ndef get_bounding_box(coords_list: list[tuple]) -> tuple | None:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\"\"\"\n    if not coords_list:\n        return None\n    rows, cols = zip(*coords_list)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return min_r, min_c, max_r, max_c\n\ndef normalize_centroid(centroid: tuple, bbox: tuple) -> tuple | None:\n    \"\"\"Normalizes a centroid relative to a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    centroid_r, centroid_c = centroid\n    \n    height = max_r - min_r\n    width = max_c - min_c\n    \n    # Handle cases where bounding box has zero height or width\n    norm_r = 0.5 if height == 0 else (centroid_r - min_r) / height\n    norm_c = 0.5 if width == 0 else (centroid_c - min_c) / width\n    \n    # Clamp values between 0 and 1 just in case centroid is exactly on min/max boundary\n    # Although division handles this, explicit clamp adds robustness.\n    norm_r = max(0.0, min(1.0, norm_r))\n    norm_c = max(0.0, min(1.0, norm_c))\n\n    return norm_r, norm_c\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the pattern-template transformation to the input grid using\n    bounding box normalization for spatial mapping.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # --- 1. Identify Pattern Components ---\n    pattern_components = []\n    all_pattern_coords = []\n    unique_colors = np.unique(grid)\n    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]\n\n    for color in pattern_colors:\n        components_for_color = find_connected_components(grid, target_value=color)\n        pattern_components.extend(components_for_color)\n        for comp in components_for_color:\n            all_pattern_coords.extend(comp['coords'])\n\n    # --- 2. Identify Template Components ---\n    template_components = find_connected_components(grid, target_value=8)\n    all_template_coords = []\n    for comp in template_components:\n        all_template_coords.extend(comp['coords'])\n\n    # --- Handle edge cases: No pattern or no template ---\n    if not pattern_components or not template_components:\n        return output_grid.tolist() \n\n    # --- 3. Calculate Bounding Boxes ---\n    pattern_bbox = get_bounding_box(all_pattern_coords)\n    template_bbox = get_bounding_box(all_template_coords)\n\n    # --- Handle edge case: Bounding box calculation failed (empty regions) ---\n    # This check is somewhat redundant due to the component check above, but safe.\n    if pattern_bbox is None or template_bbox is None:\n         return output_grid.tolist()\n\n    # --- 4 & 5. Calculate and Normalize Centroids within Bounding Boxes ---\n    pattern_centroids_norm = []\n    for comp in pattern_components:\n        norm_centroid = normalize_centroid(comp['centroid'], pattern_bbox)\n        if norm_centroid: # Ensure normalization succeeded\n             pattern_centroids_norm.append(norm_centroid)\n        else: # Should not happen if components exist\n            return output_grid.tolist() # Or handle error appropriately\n            \n    template_centroids_norm = []\n    for comp in template_components:\n        norm_centroid = normalize_centroid(comp['centroid'], template_bbox)\n        if norm_centroid: # Ensure normalization succeeded\n            template_centroids_norm.append(norm_centroid)\n        else: # Should not happen if components exist\n             return output_grid.tolist() # Or handle error appropriately\n\n    # Convert lists of normalized centroids to NumPy arrays for cdist\n    pattern_centroids_norm_np = np.array(pattern_centroids_norm)\n    template_centroids_norm_np = np.array(template_centroids_norm)\n    \n    # Ensure we have the same number of normalized centroids as components\n    if len(pattern_centroids_norm_np) != len(pattern_components) or \\\n       len(template_centroids_norm_np) != len(template_components):\n        # This indicates an issue during normalization, potentially zero-sized bbox for a component?\n        # Though handled in normalize_centroid, add a safety return.\n        print(\"Warning: Mismatch between components and normalized centroids.\") \n        return output_grid.tolist()\n\n\n    # --- 6. Map Template Components to Pattern Components ---\n    # Compute pairwise distances between normalized template and pattern centroids\n    distances = cdist(template_centroids_norm_np, pattern_centroids_norm_np)\n\n    # Find the index of the closest pattern component for each template component\n    closest_pattern_indices = np.argmin(distances, axis=1)\n\n    # --- 7. Apply Color Transformation ---\n    # Iterate through each template component and apply the mapped color\n    for i, template_comp in enumerate(template_components):\n        # Get the index of the closest pattern component\n        pattern_idx = closest_pattern_indices[i]\n        # Get the color of that pattern component\n        mapped_color = pattern_components[pattern_idx]['color']\n        \n        # Update the output grid for all coordinates of the current template component\n        for r, c in template_comp['coords']:\n            output_grid[r, c] = mapped_color\n\n    # --- 8. Finalize ---\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11458,
    "candidates_token_count": 2650,
    "total_token_count": 14108,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.64718,
  "retries": 1
}