
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 0 0 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 8 8 0 0 8 8 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 2 0 3 4 0 0 0 0 0 0 0
0 0 2 1 1 0 0 0 0 0 0 0 0
0 0 2 0 0 4 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 0 0 1 1 3 3 3 3 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 4 4 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 8 8 8 8 8 8 0 0 0 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 0 0 0 8 8 8 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 8 8 8 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 1 0 0 0 0 0 0
0 0 0 4 3 0 0 0 0 0 0 0
0 0 0 2 0 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 2 2 2 4 4 4 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 0 0 0 3 3 3 3 3 3 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 4 4 4 0 0 0 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down the task based on the provided examples.

## Perception

1.  **Input Structure:** The input grids contain distinct regions. One region (let's call it the "pattern region") consists of various non-zero digits *other than* 8. Another region (let's call it the "template region") consists *only* of the digit 8. The rest of the grid is filled with 0s (background).
2.  **Output Structure:** The output grids are largely similar to the input grids. The pattern region remains completely unchanged. The background 0s also remain unchanged. The significant change occurs in the template region.
3.  **Transformation:** The areas originally occupied by the digit 8 in the input are filled with the digits found in the pattern region in the output. The digit 8 itself disappears.
4.  **Color Mapping:** The transformation isn't a simple replacement of all 8s with a single color. Instead, the template region (originally all 8s) is segmented into sub-regions in the output, each filled with a specific color from the pattern region.
5.  **Structural Preservation:** The shapes and connectivity of the sub-regions within the template area seem preserved. If the input template region consists of several disconnected components of 8s, the output maintains these disconnected components, but fills each with a color derived from the pattern region.
6.  **Mapping Logic:** The core logic appears to involve mapping the connected components of the pattern region (each with a unique color) to the connected components of the template region (originally color 8). This mapping seems based on the relative spatial positioning of these components within their respective overall regions. For example, a pattern component in the top-left of the pattern region likely dictates the color for the template component(s) in the top-left of the template region.

## Facts


```yaml
task_elements:
  - object: grid
    description: A 2D array of single digits.
    properties:
      - rows: integer
      - columns: integer
      - cells: list of lists of integers (0-9)

  - object: pattern_region
    description: An area within the input grid containing non-zero digits, excluding the digit 8.
    properties:
      - colors: set of integers (1-7, 9) present in the region.
      - location: coordinates of the cells belonging to this region.
      - components: list of connected sub-regions within the pattern region, each associated with a single color.

  - object: template_region
    description: An area within the input grid containing only the digit 8.
    properties:
      - color: 8 (constant)
      - location: coordinates of the cells belonging to this region.
      - components: list of connected sub-regions (using 8-connectivity) within the template region.

  - object: background
    description: Cells in the grid with the value 0.

relationships:
  - type: contains
    source: grid
    target: pattern_region
  - type: contains
    source: grid
    target: template_region
  - type: contains
    source: grid
    target: background
  - type: spatial_mapping
    description: >
      A correspondence exists between the pattern region components and the template region components based on their relative positions within their respective bounding boxes or overall structures.

actions:
  - action: identify_regions
    description: Locate the pattern_region and template_region within the input grid.
  - action: find_components
    description: >
      Identify the connected components within the pattern_region (grouping by color)
      and within the template_region (all color 8). 8-connectivity seems appropriate.
  - action: map_components
    description: >
      Establish a mapping from each template_region component to a pattern_region component.
      This mapping is determined by matching the relative spatial positions (e.g., using normalized centroids or bounding box centers).
  - action: replace_color
    description: >
      Create the output grid by copying the input grid. Then, for each template_region component,
      replace the color (8) of all its cells with the color of the pattern_region component it maps to.
```


## Natural Language Program

1.  **Initialize Output:** Create a copy of the input grid to serve as the basis for the output grid.
2.  **Identify Pattern Components:** Scan the input grid to find all connected components composed of non-zero digits other than 8. For each component, record its constituent cell coordinates and its single color.
3.  **Identify Template Components:** Scan the input grid to find all connected components composed solely of the digit 8. For each component, record its constituent cell coordinates.
4.  **Determine Component Mapping:**
    *   Calculate a representative point (e.g., centroid) for each pattern component and each template component.
    *   Normalize these points relative to the overall extent (e.g., bounding box) of the pattern region and template region, respectively.
    *   For each template component, find the pattern component whose normalized representative point is spatially closest (e.g., minimum Euclidean distance). This establishes the mapping.
5.  **Apply Color Transformation:** Iterate through each identified template component. Use the mapping determined in step 4 to find the corresponding pattern component and its color. Fill all cells belonging to the current template component in the *output grid* with this mapped color.
6.  **Finalize:** The modified output grid, containing the original pattern region, the background, and the color-transformed template region, is the final result.
```python
"""
Transforms an input grid based on pattern and template regions.

The transformation identifies two distinct regions in the input grid:
1.  Pattern Region: Contains connected components of non-zero digits other than 8.
2.  Template Region: Contains connected components of the digit 8.

The transformation logic is as follows:
1.  Identify all connected components within the pattern region, noting the color (digit) of each component.
2.  Identify all connected components within the template region (all composed of the digit 8).
3.  Calculate a representative point (centroid) for each pattern component and each template component, normalized by the grid dimensions.
4.  For each template component, find the pattern component whose normalized centroid is closest (using Euclidean distance).
5.  Create an output grid by copying the input grid.
6.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.
7.  The pattern region and background (0s) remain unchanged in the output grid.
"""

import numpy as np
from scipy.ndimage import label, center_of_mass
from scipy.spatial.distance import cdist

def find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:
    """
    Finds connected components in a grid for a specific value or based on a mask.
    Uses 8-connectivity.

    Args:
        grid: The input NumPy array.
        target_value: The integer value to find components of. If None, use mask.
        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.

    Returns:
        A list of dictionaries, each representing a component with:
          'coords': list of (row, col) tuples.
          'centroid': (row, col) tuple for the component's center of mass.
          'color': The integer color/value of the component (if target_value was used).
    """
    if mask is None and target_value is not None:
        binary_mask = (grid == target_value)
    elif mask is not None:
        binary_mask = mask
    else:
        raise ValueError("Either target_value or mask must be provided.")

    # Define 8-connectivity structure
    structure = np.ones((3, 3), dtype=bool)
    
    # Label connected components
    labeled_array, num_features = label(binary_mask, structure=structure)
    
    components = []
    if num_features > 0:
        # Calculate centroids (center_of_mass) for all components at once
        # Note: center_of_mass needs the original grid values if weighting is desired,
        # but here we just need the geometric center of the mask, so input=labeled_array works.
        # However, using binary_mask might be more direct for geometric center.
        # We calculate centroids individually to ensure correct association.
        
        component_indices = np.arange(1, num_features + 1)
        # centroids = center_of_mass(binary_mask, labeled_array, component_indices) # scipy < 1.9
        # centroids = center_of_mass(input=binary_mask, labels=labeled_array, index=component_indices) # scipy >= 1.9

        for i in component_indices:
            coords_raw = np.argwhere(labeled_array == i)
            if coords_raw.size > 0:
                # coords need to be list of tuples for consistency if used elsewhere
                coords = [tuple(coord) for coord in coords_raw]
                
                # Calculate centroid manually for robustness across scipy versions
                centroid = np.mean(coords_raw, axis=0)

                component_info = {
                    'coords': coords,
                    'centroid': tuple(centroid),
                }
                # If finding components of a specific value, store its color
                if target_value is not None:
                   component_info['color'] = target_value
                # If using a mask derived from multiple colors (pattern region),
                # determine color from the first coordinate. Assumes components are single-colored.
                elif mask is not None and target_value is None:
                   first_coord = coords[0]
                   component_info['color'] = grid[first_coord]

                components.append(component_info)
                
    return components


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the pattern-template transformation to the input grid.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed output grid.
    """
    # Convert input to numpy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # --- 1. Identify Pattern Components ---
    pattern_components = []
    # Identify unique colors in the potential pattern region (non-zero, not 8)
    unique_colors = np.unique(grid)
    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]

    # Find connected components for each pattern color
    for color in pattern_colors:
        components_for_color = find_connected_components(grid, target_value=color)
        pattern_components.extend(components_for_color)

    # --- 2. Identify Template Components ---
    template_components = find_connected_components(grid, target_value=8)

    # --- Handle edge cases: No pattern or no template ---
    if not pattern_components or not template_components:
        # If either region is missing, no transformation can be applied
        return output_grid.tolist() 

    # --- 3. Calculate Normalized Centroids ---
    # Normalize centroids by grid dimensions for relative positioning
    pattern_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in pattern_components
    ])
    template_centroids_norm = np.array([
        (comp['centroid'][0] / rows, comp['centroid'][1] / cols) 
        for comp in template_components
    ])

    # --- 4. Map Template Components to Pattern Components ---
    # Compute pairwise distances between normalized template and pattern centroids
    # shape: (num_template_components, num_pattern_components)
    distances = cdist(template_centroids_norm, pattern_centroids_norm)

    # Find the index of the closest pattern component for each template component
    # shape: (num_template_components,)
    closest_pattern_indices = np.argmin(distances, axis=1)

    # --- 5. Apply Color Transformation ---
    # Iterate through each template component and apply the mapped color
    for i, template_comp in enumerate(template_components):
        # Get the index of the closest pattern component
        pattern_idx = closest_pattern_indices[i]
        # Get the color of that pattern component
        mapped_color = pattern_components[pattern_idx]['color']
        
        # Update the output grid for all coordinates of the current template component
        for r, c in template_comp['coords']:
            output_grid[r, c] = mapped_color

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```
```python
import numpy as np
from scipy.ndimage import label
from scipy.spatial.distance import cdist

"""
Transforms an input grid based on pattern and template regions using relative spatial mapping within bounding boxes.

The transformation identifies two distinct regions in the input grid:
1.  Pattern Region: Contains connected components of non-zero digits other than 8.
2.  Template Region: Contains connected components of the digit 8.

The transformation logic is as follows:
1.  Identify all connected components within the pattern region, noting the color (digit) and centroid of each component.
2.  Identify all connected components within the template region (all composed of the digit 8), noting the centroid of each component.
3.  Determine the overall bounding box for the pattern region and the template region.
4.  Normalize the centroid of each pattern component relative to the pattern region's bounding box.
5.  Normalize the centroid of each template component relative to the template region's bounding box.
6.  For each template component, find the pattern component whose normalized centroid (within its respective bounding box) is closest (using Euclidean distance).
7.  Create an output grid by copying the input grid.
8.  For each template component in the output grid, replace its cells (originally 8) with the color of the closest pattern component identified in the previous step.
9.  The pattern region and background (0s) remain unchanged in the output grid.
"""

def find_connected_components(grid: np.ndarray, target_value: int = None, mask: np.ndarray = None) -> list[dict]:
    """
    Finds connected components in a grid for a specific value or based on a mask.
    Uses 8-connectivity.

    Args:
        grid: The input NumPy array.
        target_value: The integer value to find components of. If None, use mask.
        mask: A boolean mask where True indicates cells belonging to potential components. If None, use target_value.

    Returns:
        A list of dictionaries, each representing a component with:
          'coords': list of (row, col) tuples.
          'centroid': (row, col) tuple for the component's center of mass.
          'color': The integer color/value of the component.
    """
    if mask is None and target_value is not None:
        binary_mask = (grid == target_value)
    elif mask is not None:
        binary_mask = mask
    else:
        raise ValueError("Either target_value or mask must be provided.")

    # Define 8-connectivity structure
    structure = np.ones((3, 3), dtype=bool)
    
    # Label connected components
    labeled_array, num_features = label(binary_mask, structure=structure)
    
    components = []
    if num_features > 0:
        component_indices = np.arange(1, num_features + 1)
        for i in component_indices:
            # Get coordinates for the current component
            coords_raw = np.argwhere(labeled_array == i)
            if coords_raw.size > 0:
                coords = [tuple(coord) for coord in coords_raw]
                # Calculate centroid (center of mass)
                centroid = tuple(np.mean(coords_raw, axis=0))
                
                component_info = {
                    'coords': coords,
                    'centroid': centroid,
                }
                # Determine component color
                if target_value is not None:
                   component_info['color'] = target_value
                elif mask is not None: # Assumes single color per component if using mask
                   first_coord = coords[0]
                   component_info['color'] = grid[first_coord]
                else: # Should not happen based on initial check
                    component_info['color'] = -1 # Error indicator

                components.append(component_info)
                
    return components

def get_bounding_box(coords_list: list[tuple]) -> tuple | None:
    """Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates."""
    if not coords_list:
        return None
    rows, cols = zip(*coords_list)
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    return min_r, min_c, max_r, max_c

def normalize_centroid(centroid: tuple, bbox: tuple) -> tuple | None:
    """Normalizes a centroid relative to a bounding box."""
    min_r, min_c, max_r, max_c = bbox
    centroid_r, centroid_c = centroid
    
    height = max_r - min_r
    width = max_c - min_c
    
    # Handle cases where bounding box has zero height or width
    norm_r = 0.5 if height == 0 else (centroid_r - min_r) / height
    norm_c = 0.5 if width == 0 else (centroid_c - min_c) / width
    
    # Clamp values between 0 and 1 just in case centroid is exactly on min/max boundary
    # Although division handles this, explicit clamp adds robustness.
    norm_r = max(0.0, min(1.0, norm_r))
    norm_c = max(0.0, min(1.0, norm_c))

    return norm_r, norm_c


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the pattern-template transformation to the input grid using
    bounding box normalization for spatial mapping.
    """
    # Convert input to numpy array for efficient processing
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # --- 1. Identify Pattern Components ---
    pattern_components = []
    all_pattern_coords = []
    unique_colors = np.unique(grid)
    pattern_colors = [c for c in unique_colors if c != 0 and c != 8]

    for color in pattern_colors:
        components_for_color = find_connected_components(grid, target_value=color)
        pattern_components.extend(components_for_color)
        for comp in components_for_color:
            all_pattern_coords.extend(comp['coords'])

    # --- 2. Identify Template Components ---
    template_components = find_connected_components(grid, target_value=8)
    all_template_coords = []
    for comp in template_components:
        all_template_coords.extend(comp['coords'])

    # --- Handle edge cases: No pattern or no template ---
    if not pattern_components or not template_components:
        return output_grid.tolist() 

    # --- 3. Calculate Bounding Boxes ---
    pattern_bbox = get_bounding_box(all_pattern_coords)
    template_bbox = get_bounding_box(all_template_coords)

    # --- Handle edge case: Bounding box calculation failed (empty regions) ---
    # This check is somewhat redundant due to the component check above, but safe.
    if pattern_bbox is None or template_bbox is None:
         return output_grid.tolist()

    # --- 4 & 5. Calculate and Normalize Centroids within Bounding Boxes ---
    pattern_centroids_norm = []
    for comp in pattern_components:
        norm_centroid = normalize_centroid(comp['centroid'], pattern_bbox)
        if norm_centroid: # Ensure normalization succeeded
             pattern_centroids_norm.append(norm_centroid)
        else: # Should not happen if components exist
            return output_grid.tolist() # Or handle error appropriately
            
    template_centroids_norm = []
    for comp in template_components:
        norm_centroid = normalize_centroid(comp['centroid'], template_bbox)
        if norm_centroid: # Ensure normalization succeeded
            template_centroids_norm.append(norm_centroid)
        else: # Should not happen if components exist
             return output_grid.tolist() # Or handle error appropriately

    # Convert lists of normalized centroids to NumPy arrays for cdist
    pattern_centroids_norm_np = np.array(pattern_centroids_norm)
    template_centroids_norm_np = np.array(template_centroids_norm)
    
    # Ensure we have the same number of normalized centroids as components
    if len(pattern_centroids_norm_np) != len(pattern_components) or \
       len(template_centroids_norm_np) != len(template_components):
        # This indicates an issue during normalization, potentially zero-sized bbox for a component?
        # Though handled in normalize_centroid, add a safety return.
        print("Warning: Mismatch between components and normalized centroids.") 
        return output_grid.tolist()


    # --- 6. Map Template Components to Pattern Components ---
    # Compute pairwise distances between normalized template and pattern centroids
    distances = cdist(template_centroids_norm_np, pattern_centroids_norm_np)

    # Find the index of the closest pattern component for each template component
    closest_pattern_indices = np.argmin(distances, axis=1)

    # --- 7. Apply Color Transformation ---
    # Iterate through each template component and apply the mapped color
    for i, template_comp in enumerate(template_components):
        # Get the index of the closest pattern component
        pattern_idx = closest_pattern_indices[i]
        # Get the color of that pattern component
        mapped_color = pattern_components[pattern_idx]['color']
        
        # Update the output grid for all coordinates of the current template component
        for r, c in template_comp['coords']:
            output_grid[r, c] = mapped_color

    # --- 8. Finalize ---
    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()

```
```python
import numpy as np

"""
Transforms an input grid by mapping a "pattern" region onto a "template" region based on relative pixel positions within their respective bounding boxes.

1.  Identifies two regions:
    - Pattern Region: Cells with values other than 0 and 8.
    - Template Region: Cells with the value 8.
2.  Calculates the minimum bounding box for both regions.
3.  Iterates through each cell (r, c) marked as template (value 8).
4.  Calculates the normalized position of (r, c) within the template's bounding box.
5.  Maps this normalized position to a corresponding coordinate (src_r, src_c) within the pattern's bounding box.
6.  Determines the nearest integer coordinates to (src_r, src_c) within the pattern bounding box bounds.
7.  Copies the color from the input grid at these nearest source coordinates to the output grid at position (r, c), effectively replacing the original 8.
8.  Cells outside the template region remain unchanged.
"""

def get_bounding_box(coords: np.ndarray) -> tuple | None:
    """
    Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of coordinates.

    Args:
        coords: A NumPy array of shape (N, 2) where N is the number of points,
                and each row is [row, col].

    Returns:
        A tuple (min_r, min_c, max_r, max_c) or None if coords is empty.
    """
    if coords.shape[0] == 0:
        return None
    min_r, min_c = coords.min(axis=0)
    max_r, max_c = coords.max(axis=0)
    return int(min_r), int(min_c), int(max_r), int(max_c)

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the pattern-to-template pixel mapping transformation.

    Args:
        input_grid: The input grid as a list of lists of integers.

    Returns:
        The transformed grid as a list of lists of integers.
    """
    # Convert to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # --- 1. Identify Pattern and Template Cells ---
    pattern_mask = (grid != 0) & (grid != 8)
    template_mask = (grid == 8)

    pattern_coords = np.argwhere(pattern_mask)
    template_coords = np.argwhere(template_mask)

    # --- 2. Handle Empty Regions ---
    if pattern_coords.shape[0] == 0 or template_coords.shape[0] == 0:
        # If either region is missing, no transformation can be applied
        return output_grid.tolist()

    # --- 3. Calculate Bounding Boxes ---
    p_bbox = get_bounding_box(pattern_coords)
    t_bbox = get_bounding_box(template_coords)

    # This check should be redundant due to the check above, but included for safety
    if p_bbox is None or t_bbox is None:
         return output_grid.tolist()

    p_min_r, p_min_c, p_max_r, p_max_c = p_bbox
    t_min_r, t_min_c, t_max_r, t_max_c = t_bbox

    # --- 4. Calculate Bounding Box Dimensions (adding 1 because bounds are inclusive) ---
    # Note: We use max-min directly for scaling factor. Add 1 if thinking about number of pixels.
    # For normalization/scaling, height/width = (max_coord - min_coord) is correct.
    p_height = p_max_r - p_min_r
    p_width = p_max_c - p_min_c
    t_height = t_max_r - t_min_r
    t_width = t_max_c - t_min_c

    # --- 5. Iterate and Map Template Pixels ---
    # Loop only through the template coordinates identified earlier
    for r, c in template_coords:
        # The check 'if grid[r, c] == 8' is implicitly true for these coords

        # --- 6. Calculate Normalized Position within Template BBox ---
        # Avoid division by zero for single-pixel-wide/high boxes
        norm_r = 0.5 if t_height == 0 else (r - t_min_r) / t_height
        norm_c = 0.5 if t_width == 0 else (c - t_min_c) / t_width

        # --- 7. Map to Source Coordinates within Pattern BBox ---
        src_r_float = p_min_r + norm_r * p_height
        src_c_float = p_min_c + norm_c * p_width

        # --- 8. Find Nearest Integer Source Coordinates and Clamp ---
        # Use np.round for nearest integer, then clamp to pattern bbox bounds
        nearest_src_r = int(np.round(src_r_float))
        nearest_src_c = int(np.round(src_c_float))

        # Clamp coordinates to be within the source pattern bounding box
        nearest_src_r = np.clip(nearest_src_r, p_min_r, p_max_r)
        nearest_src_c = np.clip(nearest_src_c, p_min_c, p_max_c)
        
        # --- 9. Get Source Color and Update Output ---
        source_color = grid[nearest_src_r, nearest_src_c]
        
        # Ensure we don't accidentally sample a 0 or 8 if the nearest pixel wasn't part of the original pattern
        # This could happen if the pattern is sparse within its bounding box.
        # A better approach might be needed if sampling background/template is forbidden.
        # Option 1: Use original pattern_mask to ensure sampled pixel is valid pattern
        # Option 2: If sampled pixel is not valid pattern, find nearest *valid* pattern pixel (more complex)
        # Let's stick to simple nearest neighbor for now as per the NL program.
        
        output_grid[r, c] = source_color

    # --- 10. Finalize ---
    return output_grid.tolist()
```
