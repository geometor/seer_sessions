{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms the input grid based on a 3x3 section layout defined by separator lines.\nThe process involves copying specific sections from the input grid to different \nlocations in the output grid, while leaving other sections unchanged.\n\n1.  Initialize the output grid as an identical copy of the input grid.\n2.  Identify the separator lines (rows and columns consisting entirely of a single, non-zero color) and their color.\n3.  Determine the boundaries of the nine rectangular sections delimited by these separators.\n4.  Extract the content of three specific source sections from the *input* grid:\n    - Pattern_A: Content of the section at grid index [1, 0] (Middle-Left).\n    - Pattern_B: Content of the section at grid index [1, 1] (Middle-Middle).\n    - Pattern_C: Content of the section at grid index [2, 1] (Bottom-Middle).\n5.  Overwrite specific sections in the *output* grid with these extracted patterns:\n    - Output Section [0, 0] (Top-Left) is replaced with Pattern_A.\n    - Output Section [0, 1] (Top-Middle) is replaced with Pattern_B.\n    - Output Section [2, 0] (Bottom-Left) is replaced with Pattern_C.\n6.  All other sections in the output grid retain their original content copied from the input grid.\n\"\"\"\n\n# === Helper Functions ===\n\ndef _find_separators(grid_np: np.ndarray) -> tuple[int, list[int], list[int]]:\n    \"\"\"\n    Finds the separator color and the indices of separator rows/columns.\n    Expects exactly two horizontal and two vertical separator lines.\n    Returns (separator_color, list_of_row_indices, list_of_col_indices).\n    Returns (0, [], []) if the expected structure isn't found.\n    \"\"\"\n    sep_color = 0\n    sep_rows = []\n    sep_cols = []\n    rows, cols = grid_np.shape\n\n    # Find horizontal separators\n    for r in range(rows):\n        first_val = grid_np[r, 0]\n        if first_val != 0 and np.all(grid_np[r, :] == first_val):\n            sep_rows.append(r)\n            if sep_color == 0:\n                sep_color = first_val\n            elif sep_color != first_val:\n                 # Inconsistent horizontal separator color\n                 # print(f\"Warning: Inconsistent horizontal separator color at row {r}.\") # Optional warning\n                 return 0, [], [] # Treat as error\n\n    # Find vertical separators\n    temp_sep_color_v = 0\n    for c in range(cols):\n        first_val = grid_np[0, c]\n        if first_val != 0 and np.all(grid_np[:, c] == first_val):\n            sep_cols.append(c)\n            if temp_sep_color_v == 0:\n                 temp_sep_color_v = first_val\n            elif temp_sep_color_v != first_val:\n                 # Inconsistent vertical separator color\n                 # print(f\"Warning: Inconsistent vertical separator color at col {c}.\") # Optional warning\n                 return 0, [], [] # Treat as error\n    \n    # Finalize separator color and validate consistency\n    if sep_color == 0:\n        sep_color = temp_sep_color_v\n    elif temp_sep_color_v != 0 and sep_color != temp_sep_color_v:\n         # Mismatched horizontal and vertical separator colors\n         # print(f\"Warning: Mismatched separator colors ({sep_color}H, {temp_sep_color_v}V).\") # Optional warning\n         return 0, [], [] # Treat as error\n\n    # Validate structure: exactly 2 rows and 2 columns expected\n    if len(sep_rows) != 2 or len(sep_cols) != 2:\n        # print(f\"Warning: Expected 2 separator rows/cols, found {len(sep_rows)}/{len(sep_cols)}.\") # Optional warning\n        return 0, [], [] \n        \n    return sep_color, sorted(sep_rows), sorted(sep_cols)\n\ndef _get_section_bounds(grid_shape: tuple[int, int], sep_rows: list[int], sep_cols: list[int]) -> tuple[list[tuple[int, int]], list[tuple[int, int]]]:\n    \"\"\"\n    Calculates the start/end boundaries for rows and columns of the 9 sections,\n    excluding the separator lines themselves.\n    Returns (list_of_row_bounds, list_of_col_bounds), where each bound is (start, end_exclusive).\n    \"\"\"\n    rows, cols = grid_shape\n    # Define edges including separators\n    row_edges = [0] + sep_rows + [rows]\n    col_edges = [0] + sep_cols + [cols]\n    \n    row_bounds = []\n    col_bounds = []\n\n    # Row bounds [start, end) for sections 0, 1, 2\n    row_bounds.append( (row_edges[0], row_edges[1]) )      # Row 0: 0 to first separator\n    row_bounds.append( (row_edges[1] + 1, row_edges[2]) )  # Row 1: After first separator to second separator\n    row_bounds.append( (row_edges[2] + 1, row_edges[3]) )  # Row 2: After second separator to grid end\n\n    # Column bounds [start, end) for sections 0, 1, 2\n    col_bounds.append( (col_edges[0], col_edges[1]) )      # Col 0: 0 to first separator\n    col_bounds.append( (col_edges[1] + 1, col_edges[2]) )  # Col 1: After first separator to second separator\n    col_bounds.append( (col_edges[2] + 1, col_edges[3]) )  # Col 2: After second separator to grid end\n    \n    return row_bounds, col_bounds\n\n\ndef _get_section(grid_np: np.ndarray, r_idx: int, c_idx: int, row_bounds: list[tuple[int, int]], col_bounds: list[tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Extracts the content (numpy subgrid) of a specific section using pre-calculated bounds.\n    r_idx, c_idx are the section indices (0, 1, or 2).\n    Returns an empty 2D array if bounds are invalid or section is empty.\n    \"\"\"\n    r_start, r_end = row_bounds[r_idx]\n    c_start, c_end = col_bounds[c_idx]\n    \n    # Clamp bounds to grid dimensions as a safety measure\n    r_start = max(0, r_start)\n    r_end = min(grid_np.shape[0], r_end)\n    c_start = max(0, c_start)\n    c_end = min(grid_np.shape[1], c_end)\n\n    # Check for invalid/empty sections after clamping\n    if r_start >= r_end or c_start >= c_end:\n         return np.array([[]], dtype=grid_np.dtype).reshape(0, 0) # Return 2D empty array\n\n    return grid_np[r_start:r_end, c_start:c_end]\n\ndef _set_section(grid_np: np.ndarray, r_idx: int, c_idx: int, row_bounds: list[tuple[int, int]], col_bounds: list[tuple[int, int]], content: np.ndarray):\n    \"\"\"\n    Sets the content of a specific section in the grid using pre-calculated bounds.\n    r_idx, c_idx are the section indices (0, 1, or 2).\n    Handles potential shape mismatches by printing a warning and filling with 0\n    if content is empty but target is not, or skipping if shapes don't match otherwise.\n    \"\"\"\n    r_start, r_end = row_bounds[r_idx]\n    c_start, c_end = col_bounds[c_idx]\n\n    # Clamp bounds to grid dimensions\n    r_start = max(0, r_start)\n    r_end = min(grid_np.shape[0], r_end)\n    c_start = max(0, c_start)\n    c_end = min(grid_np.shape[1], c_end)\n\n    # Check for invalid/empty target sections after clamping\n    if r_start >= r_end or c_start >= c_end:\n        if content.size != 0:\n            # Trying to put content into an empty/invalid section\n            # print(f\"Warning: Target section ({r_idx},{c_idx}) is invalid/empty. Cannot set non-empty content.\") # Optional\n            pass # Skip\n        return\n\n    expected_shape = (r_end - r_start, c_end - c_start)\n    \n    # Check for shape compatibility\n    if content.shape == expected_shape:\n        grid_np[r_start:r_end, c_start:c_end] = content\n    elif content.size == 0 and expected_shape != (0,0):\n         # Copying empty content into a non-empty section: fill with background color (0)\n         # print(f\"Warning: Copying empty content to non-empty section ({r_idx},{c_idx}). Filling with 0.\") # Optional\n         grid_np[r_start:r_end, c_start:c_end] = 0 \n    elif content.shape != expected_shape:\n        # Serious shape mismatch: indicates an issue\n        print(f\"Error: Shape mismatch setting section ({r_idx},{c_idx}). Expected {expected_shape}, got {content.shape}. Skipping assignment.\")\n        # Not assigning to prevent errors, the target section remains unchanged from the initial copy.\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on section copying.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output grid as a copy of the input\n    output_np = input_np.copy()\n\n    # Find grid structure (separator lines and color)\n    sep_color, sep_rows, sep_cols = _find_separators(input_np)\n    \n    # If the expected 3x3 structure wasn't found, return the original grid\n    if sep_color == 0: # Indicates failure in _find_separators\n         # print(\"Warning: Grid structure not detected or invalid. Returning original grid.\") # Optional\n         return input_grid \n\n    # Calculate the boundaries of the 9 sections (excluding separators)\n    row_bounds, col_bounds = _get_section_bounds(input_np.shape, sep_rows, sep_cols)\n\n    # Extract source patterns from the INPUT grid using section indices\n    pattern_A = _get_section(input_np, 1, 0, row_bounds, col_bounds) # Input Middle-Left [1,0]\n    pattern_B = _get_section(input_np, 1, 1, row_bounds, col_bounds) # Input Middle-Middle [1,1]\n    pattern_C = _get_section(input_np, 2, 1, row_bounds, col_bounds) # Input Bottom-Middle [2,1]\n\n    # Copy extracted patterns to their destination sections in the OUTPUT grid\n    _set_section(output_np, 0, 0, row_bounds, col_bounds, pattern_A) # Output Top-Left [0,0] <- Pattern_A\n    _set_section(output_np, 0, 1, row_bounds, col_bounds, pattern_B) # Output Top-Middle [0,1] <- Pattern_B\n    _set_section(output_np, 2, 0, row_bounds, col_bounds, pattern_C) # Output Bottom-Left [2,0] <- Pattern_C\n    \n    # Sections not explicitly set ([0,2], [1,0], [1,1], [1,2], [2,1], [2,2]) \n    # retain their values from the initial copy of the input grid.\n\n    # Convert the final numpy array back to a list of lists for the return value\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20995,
    "candidates_token_count": 4069,
    "total_token_count": 25064,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.575638,
  "retries": 1
}