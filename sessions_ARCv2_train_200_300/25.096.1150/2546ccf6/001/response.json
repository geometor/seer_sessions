{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThe transformation identifies a 3x3 grid structure defined by separator lines of a single color.\nIt then performs conditional copying of sections based on the content color of the central section (1,1).\n\n1.  Copy the input grid to the output grid.\n2.  Identify the separator color and the row/column indices defining the 9 sections.\n3.  Extract the content of the middle-middle section (1,1) from the input.\n4.  Identify the primary content color (non-zero, non-separator) within the middle-middle section.\n5.  Copy the content of the input middle-middle section (1,1) to the output top-middle section (0,1).\n6.  Extract the content and primary color of the input middle-left section (1,0).\n7.  If the primary color of the middle-left section matches the primary color of the middle-middle section (and the middle-middle color exists), copy the content of the input middle-left section (1,0) to the output top-left section (0,0).\n8.  Extract the content and primary color of the input bottom-middle section (2,1).\n9.  If the primary color of the bottom-middle section matches the primary color of the middle-middle section (and the middle-middle color exists), copy the content of the input bottom-middle section (2,1) to the output bottom-left section (2,0).\n10. Return the modified output grid.\n\"\"\"\n\n\ndef _find_separators(grid_np: np.ndarray) -> tuple[int, list[int], list[int]]:\n    \"\"\"Finds the separator color and the indices of separator rows/columns.\"\"\"\n    sep_color = 0\n    sep_rows = []\n    sep_cols = []\n    rows, cols = grid_np.shape\n\n    # Find horizontal separators\n    for r in range(rows):\n        first_val = grid_np[r, 0]\n        if first_val != 0 and np.all(grid_np[r, :] == first_val):\n            sep_rows.append(r)\n            if sep_color == 0:\n                sep_color = first_val\n            elif sep_color != first_val:\n                 # This case should ideally not happen based on examples\n                 # If it does, the logic might need refinement.\n                 # For now, we stick with the first found color.\n                 pass\n\n    # Find vertical separators\n    for c in range(cols):\n        first_val = grid_np[0, c]\n        if first_val != 0 and np.all(grid_np[:, c] == first_val):\n            sep_cols.append(c)\n            if sep_color == 0:\n                sep_color = first_val\n            elif sep_color != first_val:\n                # As above, handle potential inconsistencies if needed.\n                pass\n    \n    # Basic validation - expect 2 separator lines each way\n    if len(sep_rows) != 2 or len(sep_cols) != 2:\n        # Fallback or raise error if grid structure is unexpected\n        # For now, proceed assuming the structure holds for valid inputs\n        pass\n        \n    return sep_color, sorted(sep_rows), sorted(sep_cols)\n\ndef _get_section_bounds(grid_shape: tuple[int, int], sep_rows: list[int], sep_cols: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Calculates the start/end boundaries for rows and columns of the 9 sections.\"\"\"\n    rows, cols = grid_shape\n    row_bounds = [0] + sep_rows + [rows]\n    col_bounds = [0] + sep_cols + [cols]\n    # Adjust bounds to exclude the separator lines themselves from the section content\n    # Section row starts after previous separator, ends before next separator\n    # Section col starts after previous separator, ends before next separator\n    adjusted_row_bounds = [row_bounds[0], row_bounds[1]+1, row_bounds[2]+1]\n    adjusted_row_ends = [sep_rows[0], sep_rows[1], row_bounds[3]]\n    adjusted_col_bounds = [col_bounds[0], col_bounds[1]+1, col_bounds[2]+1]\n    adjusted_col_ends = [sep_cols[0], sep_cols[1], col_bounds[3]]\n    \n    # Return pairs of (start, end) for rows and columns\n    final_row_bounds = [(adjusted_row_bounds[i], adjusted_row_ends[i]) for i in range(3)]\n    final_col_bounds = [(adjusted_col_bounds[i], adjusted_col_ends[i]) for i in range(3)]\n\n    return final_row_bounds, final_col_bounds\n\n\ndef _get_section(grid_np: np.ndarray, r_idx: int, c_idx: int, row_bounds: list[tuple[int, int]], col_bounds: list[tuple[int, int]]) -> np.ndarray:\n    \"\"\"Extracts the content of a specific section.\"\"\"\n    r_start, r_end = row_bounds[r_idx]\n    c_start, c_end = col_bounds[c_idx]\n    return grid_np[r_start:r_end, c_start:c_end]\n\ndef _set_section(grid_np: np.ndarray, r_idx: int, c_idx: int, row_bounds: list[tuple[int, int]], col_bounds: list[tuple[int, int]], content: np.ndarray):\n    \"\"\"Sets the content of a specific section.\"\"\"\n    r_start, r_end = row_bounds[r_idx]\n    c_start, c_end = col_bounds[c_idx]\n    \n    # Ensure content dimensions match section dimensions\n    expected_shape = (r_end - r_start, c_end - c_start)\n    if content.shape == expected_shape:\n        grid_np[r_start:r_end, c_start:c_end] = content\n    else:\n        # Handle dimension mismatch - this might indicate an error in boundary calculation or logic\n        # For robustness, could try resizing/padding, but for now assume match\n        print(f\"Warning: Shape mismatch when setting section ({r_idx},{c_idx}). Expected {expected_shape}, got {content.shape}\")\n        # Attempt assignment anyway if broadcasting allows (e.g., single value fill)\n        if content.size == 1:\n             grid_np[r_start:r_end, c_start:c_end] = content.item()\n        # else: # Or raise an error\n        #     raise ValueError(\"Dimension mismatch in set_section\")\n\n\ndef _get_primary_color(section: np.ndarray, sep_color: int) -> int | None:\n    \"\"\"Finds the single non-zero, non-separator color in the section.\"\"\"\n    unique_vals = np.unique(section)\n    content_colors = [val for val in unique_vals if val != 0 and val != sep_color]\n    \n    if len(content_colors) == 1:\n        return content_colors[0]\n    # If zero or multiple content colors, return None (or handle ambiguity differently if needed)\n    return None\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by identifying a 3x3 structure based on separator lines\n    and conditionally copying sections based on the color found in the central section.\n    Specifically, copies middle-middle to top-middle, and conditionally copies\n    middle-left to top-left and bottom-middle to bottom-left if their primary colors\n    match the middle-middle section's primary color.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy()\n    \n    # Find separator lines and color\n    sep_color, sep_rows, sep_cols = _find_separators(input_np)\n    \n    # If separators weren't found correctly, return the original grid\n    if sep_color == 0 or len(sep_rows) != 2 or len(sep_cols) != 2:\n         print(\"Warning: Could not reliably determine grid structure. Returning original grid.\")\n         return input_grid # Or output_np.tolist() if preferred\n\n    # Determine section boundaries (excluding separators)\n    row_bounds, col_bounds = _get_section_bounds(input_np.shape, sep_rows, sep_cols)\n\n    # --- Core Logic ---\n    \n    # 1. Get Middle-Middle section (1, 1) content and primary color\n    mid_mid_content = _get_section(input_np, 1, 1, row_bounds, col_bounds)\n    mid_mid_color = _get_primary_color(mid_mid_content, sep_color)\n\n    # 2. Copy Middle-Middle (1,1) content to Top-Middle (0,1) in output\n    _set_section(output_np, 0, 1, row_bounds, col_bounds, mid_mid_content)\n\n    # 3. Check Middle-Left section (1, 0)\n    mid_left_content = _get_section(input_np, 1, 0, row_bounds, col_bounds)\n    mid_left_color = _get_primary_color(mid_left_content, sep_color)\n\n    # 4. Conditional copy Middle-Left (1,0) to Top-Left (0,0)\n    if mid_mid_color is not None and mid_left_color == mid_mid_color:\n        _set_section(output_np, 0, 0, row_bounds, col_bounds, mid_left_content)\n\n    # 5. Check Bottom-Middle section (2, 1)\n    bot_mid_content = _get_section(input_np, 2, 1, row_bounds, col_bounds)\n    bot_mid_color = _get_primary_color(bot_mid_content, sep_color)\n\n    # 6. Conditional copy Bottom-Middle (2,1) to Bottom-Left (2,0)\n    if mid_mid_color is not None and bot_mid_color == mid_mid_color:\n        _set_section(output_np, 2, 0, row_bounds, col_bounds, bot_mid_content)\n\n    # Convert the result back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4426,
    "candidates_token_count": 4096,
    "total_token_count": 8522,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.912321,
  "retries": 1
}