
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 0 0 0 0 0 0
0 5 0 0 0 5 0 0 0 0 0 0
0 5 0 0 0 5 0 5 5 5 5 0
0 5 0 0 0 5 0 5 0 0 5 0
0 5 0 0 0 5 0 5 0 0 5 0
0 5 5 5 5 5 0 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 5 0 0 0 0 0 0
0 5 0 0 0 5 0 0 0 0 0 0
0 5 0 0 0 5 0 5 5 5 5 0
0 5 0 0 0 5 0 5 2 2 5 0
0 5 0 0 0 5 0 5 2 2 5 0
0 5 5 5 5 5 0 5 5 5 5 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 0 0 0 0 5 0 0 0
0 0 0 5 5 5 5 5 5 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 5 5 5 5 5 5
0 5 5 5 5 0 5 0 0 0 0 5
0 0 0 0 0 0 5 0 0 0 0 5
0 0 0 0 0 0 5 0 0 0 0 5
5 5 5 5 5 0 5 0 0 0 0 5
5 5 5 5 5 0 5 5 5 5 5 5
5 0 0 5 5 0 0 0 0 0 0 0
5 0 0 5 5 0 0 0 0 0 0 0
5 5 5 5 5 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 2 5 0 0 0 0 0 0 0
0 5 5 5 5 0 5 5 5 5 5 5
0 5 5 5 5 0 5 2 2 2 2 5
0 0 0 0 0 0 5 2 2 2 2 5
0 0 0 0 0 0 5 2 2 2 2 5
5 5 5 5 5 0 5 2 2 2 2 5
5 5 5 5 5 0 5 5 5 5 5 5
5 2 2 5 5 0 0 0 0 0 0 0
5 2 2 5 5 0 0 0 0 0 0 0
5 5 5 5 5 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 5 5 0 0 0 0
0 0 0 5 0 0 0 5 0 0 0 0
0 0 0 5 5 5 5 5 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 0 0 0 0 0
0 5 0 0 5 0 0 5 5 5 5 0
0 5 5 5 5 0 0 5 0 5 5 0
0 0 0 0 0 0 0 5 0 0 5 0
0 0 0 0 0 0 0 5 5 5 5 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 0 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 5 5 5 5 0 0 0 0 0 0 0
0 5 2 2 5 0 0 0 0 0 0 0
0 5 2 2 5 0 0 5 5 5 5 0
0 5 5 5 5 0 0 5 0 5 5 0
0 0 0 0 0 0 0 5 0 0 5 0
0 0 0 0 0 0 0 5 5 5 5 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
0 0 5 2 5 5 0 0 0 0 0 0
0 0 5 5 5 5 0 0 0 0 0 0
```

**Perception of Task Elements:**

1.  **Input/Output:** Both input and output are 2D grids (matrices) of integers.
2.  **Grid Values:** The grids contain three distinct integer values: 0 (black), 5 (orange), and 2 (blue, only in output).
3.  **Transformation:** The core transformation involves changing some '0' cells in the input grid to '2' cells in the output grid.
4.  **Static Elements:** The cells with value '5' remain unchanged between input and output. The grid dimensions also remain constant.
5.  **Key Pattern:** The change from '0' to '2' occurs specifically within regions of '0's that are entirely enclosed or surrounded by cells with the value '5'. If a region of '0's touches the border of the grid or is not completely walled off by '5's, it remains unchanged. Example `train_3` shows a case where no '0' regions are fully enclosed, resulting in an output identical to the input.

**YAML Facts:**


```yaml
Grid:
  Type: 2D Matrix
  Cell_Values: [0, 5, 2] # 0=background, 5=boundary, 2=fill
Input_Grid:
  Alias: input
  Contains: Cells with values 0 and 5
Output_Grid:
  Alias: output
  Derived_From: input
  Contains: Cells with values 0, 5, and 2
Objects:
  - Type: Region
    Description: A connected area of cells with the same value.
    Properties:
      - Value: The integer value of the cells in the region (e.g., 0 or 5).
      - Connectivity: Cells are considered connected if they share an edge (up, down, left, right).
      - Boundary_Connectivity: Whether a region touches the edge of the grid.
Relationship:
  - Type: Enclosure
    Subject: Region (Value=0)
    Object: Region (Value=5)
    Description: A region of '0' cells is enclosed if every path from a cell within that region to the grid boundary must pass through a cell with value '5'.
Action:
  - Type: Fill
    Target: Enclosed '0' Regions
    Condition: The '0' region must be fully enclosed by '5' cells (not connected to the grid boundary except through '5' cells).
    Result: Change the value of all cells within the target region from 0 to 2.
Rule:
  - If a region of '0' cells is fully enclosed by '5' cells, change all '0's in that region to '2's. Otherwise, leave the '0' cells unchanged. '5' cells are never changed.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all distinct connected regions of cells with the value '0' in the input grid.
3.  For each identified region of '0' cells:
    a.  Determine if this region is "enclosed". A region is considered enclosed if none of its cells are on the grid boundary, AND all adjacent neighboring cells *outside* the region have the value '5'. (Alternatively, check if a flood fill starting from any cell in the '0' region can reach the grid boundary without crossing a '5').
    b.  If the region is determined to be enclosed:
        i.  Iterate through all cells belonging to this enclosed region.
        ii. For each cell in the enclosed region, change its value in the *output* grid from '0' to '2'.
4.  Return the modified output grid.
```python
import copy
import collections

"""
Identifies connected regions of '0' cells within a 2D grid. 
If a region of '0's is not connected to the grid boundary (i.e., it's fully enclosed by '5's or other grid contents), 
all '0's within that specific region are changed to '2's. 
Cells with value '5' remain unchanged. '0' regions that touch the boundary remain '0'.
"""

def find_region_and_check_boundary(start_r: int, start_c: int, grid: list[list[int]], visited: list[list[bool]]) -> tuple[set[tuple[int, int]], bool]:
    """
    Performs a Breadth-First Search (BFS) starting from (start_r, start_c) 
    to find a connected region of 0s.

    Args:
        start_r: The starting row index.
        start_c: The starting column index.
        grid: The input grid.
        visited: A grid of booleans to track visited cells.

    Returns:
        A tuple containing:
        - region_cells: A set of (row, col) tuples belonging to the found region.
        - touches_boundary: A boolean indicating if any cell in the region touches the grid boundary.
    """
    rows = len(grid)
    cols = len(grid[0])
    region_cells = set()
    touches_boundary = False
    q = collections.deque([(start_r, start_c)])

    # Mark the starting cell as visited and add it to the region
    visited[start_r][start_c] = True
    region_cells.add((start_r, start_c))

    # Define possible moves (up, down, left, right)
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while q:
        r, c = q.popleft()

        # Check if the current cell is on the boundary
        if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:
            touches_boundary = True  # Mark if the region reaches the edge

        # Explore neighbors
        for dr, dc in moves:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within grid bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is a '0' and hasn't been visited yet
                if grid[nr][nc] == 0 and not visited[nr][nc]:
                    visited[nr][nc] = True
                    region_cells.add((nr, nc))
                    q.append((nr, nc))

    return region_cells, touches_boundary


def transform(input_grid: list[list[int]]) -> list[list[int]]:  
    """
    Transforms the input grid by filling enclosed regions of '0's with '2's.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # Initialize output_grid as a deep copy of the input
    output_grid = copy.deepcopy(input_grid)
    
    # Initialize visited grid to keep track of explored cells
    visited = [[False for _ in range(cols)] for _ in range(rows)]

    # Iterate through each cell of the grid
    for r in range(rows):
        for c in range(cols):
            # If we find an unvisited '0', start exploring its region
            if input_grid[r][c] == 0 and not visited[r][c]:
                # Find the connected region of 0s and check if it touches the boundary
                region_cells, touches_boundary = find_region_and_check_boundary(r, c, input_grid, visited)
                
                # If the region does NOT touch the boundary, it's enclosed
                if not touches_boundary:
                    # Fill the enclosed region with '2's in the output grid
                    for rr, cc in region_cells:
                        output_grid[rr][cc] = 2
                        
    # Return the modified grid
    return output_grid
```
```python
import copy
import collections

"""
Transforms the input grid by filling regions of '0' cells with '2's if and only if 
those regions are not connected to the grid boundary. Connection is defined by 
adjacency (up, down, left, right) through other '0' cells. Cells with value '5' 
act as barriers and remain unchanged. '0' cells connected to the boundary remain '0'.
"""

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies '0' cells reachable from the boundary and fills the unreachable '0's with '2'.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Get grid dimensions
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # Initialize output_grid as a deep copy of the input
    output_grid = copy.deepcopy(input_grid)
    
    # Keep track of visited cells during the boundary flood fill
    visited_from_boundary = [[False for _ in range(cols)] for _ in range(rows)]
    
    # Queue for Breadth-First Search (BFS)
    q = collections.deque()

    # Initialize the queue with all '0' cells on the boundary
    for r in range(rows):
        if input_grid[r][0] == 0 and not visited_from_boundary[r][0]:
            q.append((r, 0))
            visited_from_boundary[r][0] = True
        if input_grid[r][cols-1] == 0 and not visited_from_boundary[r][cols-1]:
            q.append((r, cols-1))
            visited_from_boundary[r][cols-1] = True
            
    for c in range(cols): # Avoid double-adding corners
        if input_grid[0][c] == 0 and not visited_from_boundary[0][c]:
            q.append((0, c))
            visited_from_boundary[0][c] = True
        if input_grid[rows-1][c] == 0 and not visited_from_boundary[rows-1][c]:
             q.append((rows-1, c))
             visited_from_boundary[rows-1][c] = True

    # Define possible moves (up, down, left, right)
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    # Perform BFS from boundary '0's
    while q:
        r, c = q.popleft()
        
        # Explore neighbors
        for dr, dc in moves:
            nr, nc = r + dr, c + dc

            # Check if the neighbor is within grid bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is a '0' and hasn't been visited yet
                if input_grid[nr][nc] == 0 and not visited_from_boundary[nr][nc]:
                    visited_from_boundary[nr][nc] = True
                    q.append((nr, nc))

    # Iterate through the entire grid
    for r in range(rows):
        for c in range(cols):
            # If a cell is '0' in the input BUT was NOT visited by the boundary BFS,
            # it means it's enclosed, so change it to '2' in the output grid.
            if input_grid[r][c] == 0 and not visited_from_boundary[r][c]:
                output_grid[r][c] = 2
                
    # Return the modified grid
    return output_grid
```
```python
import copy
import collections

"""
Transforms the input grid based on the following rule:
Find all connected regions of cells with the value 0.
For each such region, examine its complete perimeter, which includes all cells 
(including diagonals) that are adjacent to any cell within the region but are not 
part of the region itself.
If and only if every cell in this complete perimeter has the value 5, then change 
all the 0s within that specific region to 2s in the output grid.
Otherwise, the 0s in the region remain 0s.
Cells with the value 5 remain unchanged.
Cells on the grid boundary cannot be part of a fillable region because their perimeter 
implicitly includes coordinates outside the grid, which cannot be '5'.
"""

def _find_connected_region(grid: list[list[int]], start_r: int, start_c: int, visited_main: list[list[bool]]) -> set[tuple[int, int]]:
    """
    Finds a connected region of 0s using Breadth-First Search (BFS).

    Args:
        grid: The input grid.
        start_r: The starting row index.
        start_c: The starting column index.
        visited_main: The main visited grid to mark cells as processed.

    Returns:
        A set of (row, col) tuples representing the connected region of 0s.
    """
    rows = len(grid)
    cols = len(grid[0])
    region_cells = set()
    q = collections.deque([(start_r, start_c)])
    
    # Mark the starting cell as visited and add to region
    visited_main[start_r][start_c] = True
    region_cells.add((start_r, start_c))
    
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)] # 4-directional connectivity

    while q:
        r, c = q.popleft()
        
        for dr, dc in moves:
            nr, nc = r + dr, c + dc
            
            # Check bounds and if it's a '0' and not yet visited
            if 0 <= nr < rows and 0 <= nc < cols and \
               grid[nr][nc] == 0 and not visited_main[nr][nc]:
                visited_main[nr][nc] = True
                region_cells.add((nr, nc))
                q.append((nr, nc))
                
    return region_cells

def _get_perimeter(region_cells: set[tuple[int, int]], grid_rows: int, grid_cols: int) -> set[tuple[int, int]]:
    """
    Calculates the complete perimeter (8-directional adjacency) of a region.

    Args:
        region_cells: A set of (row, col) tuples for the region.
        grid_rows: Number of rows in the grid.
        grid_cols: Number of columns in the grid.

    Returns:
        A set of (row, col) tuples representing the perimeter cells.
    """
    perimeter_cells = set()
    # Check all 8 neighbors for each cell in the region
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] 
    
    for r, c in region_cells:
        for dr, dc in moves:
            nr, nc = r + dr, c + dc
            
            # Check if neighbor is within bounds
            if 0 <= nr < grid_rows and 0 <= nc < grid_cols:
                neighbor_coord = (nr, nc)
                # If the neighbor is not part of the original region, it's a perimeter cell
                if neighbor_coord not in region_cells:
                    perimeter_cells.add(neighbor_coord)
            else:
                # If a neighbor would be outside the grid, the region touches the boundary.
                # Add a special marker or handle appropriately later. For now, adding None.
                # (Alternatively, could return an empty set immediately if boundary touched)
                 perimeter_cells.add(None) # Indicate boundary contact


    return perimeter_cells

def _check_perimeter_is_all_5(perimeter_cells: set[tuple[int, int]], grid: list[list[int]]) -> bool:
    """
    Checks if all cells in the perimeter set exist and have the value 5.

    Args:
        perimeter_cells: The set of perimeter cell coordinates. Includes None if boundary touched.
        grid: The input grid.

    Returns:
        True if all perimeter cells are '5', False otherwise.
    """
    if not perimeter_cells: # Empty region? Should not happen if called correctly.
        return False
        
    if None in perimeter_cells: # Touched boundary
        return False
        
    for r, c in perimeter_cells:
        # This check should be redundant if _get_perimeter ensures bounds, but good practice.
        # Check if coordinates are valid (already done by _get_perimeter logic)
        # Now, check the value
        if grid[r][c] != 5:
            return False
            
    return True

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    # initialize output_grid as a deep copy
    output_grid = copy.deepcopy(input_grid)
    rows = len(input_grid)
    if rows == 0:
        return []
    cols = len(input_grid[0])
    if cols == 0:
        return [[] for _ in range(rows)]

    # Keep track of visited cells to avoid re-processing regions
    visited_main = [[False for _ in range(cols)] for _ in range(rows)]

    # Iterate through each cell of the grid
    for r in range(rows):
        for c in range(cols):
            # If we find an unvisited '0' cell, start processing its region
            if input_grid[r][c] == 0 and not visited_main[r][c]:
                
                # 1. Find the connected region of 0s this cell belongs to
                #    The visited_main grid is updated within this function
                region = _find_connected_region(input_grid, r, c, visited_main)
                
                # 2. Get the perimeter of this region
                perimeter = _get_perimeter(region, rows, cols)
                
                # 3. Check if the entire perimeter consists of '5's
                if _check_perimeter_is_all_5(perimeter, input_grid):
                    # 4. If yes, fill the region with '2's in the output grid
                    for rr, cc in region:
                        output_grid[rr][cc] = 2
                # Else (perimeter not all 5s), do nothing, cells remain 0 in the copied output_grid

    return output_grid
```
