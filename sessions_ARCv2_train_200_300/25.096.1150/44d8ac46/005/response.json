{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\n\"\"\"\nTransforms the input grid based on the following rule:\nFind all connected regions of cells with the value 0.\nFor each such region, examine its complete perimeter, which includes all cells \n(including diagonals) that are adjacent to any cell within the region but are not \npart of the region itself.\nIf and only if every cell in this complete perimeter has the value 5, then change \nall the 0s within that specific region to 2s in the output grid.\nOtherwise, the 0s in the region remain 0s.\nCells with the value 5 remain unchanged.\nCells on the grid boundary cannot be part of a fillable region because their perimeter \nimplicitly includes coordinates outside the grid, which cannot be '5'.\n\"\"\"\n\ndef _find_connected_region(grid: list[list[int]], start_r: int, start_c: int, visited_main: list[list[bool]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds a connected region of 0s using Breadth-First Search (BFS).\n\n    Args:\n        grid: The input grid.\n        start_r: The starting row index.\n        start_c: The starting column index.\n        visited_main: The main visited grid to mark cells as processed.\n\n    Returns:\n        A set of (row, col) tuples representing the connected region of 0s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    region_cells = set()\n    q = collections.deque([(start_r, start_c)])\n    \n    # Mark the starting cell as visited and add to region\n    visited_main[start_r][start_c] = True\n    region_cells.add((start_r, start_c))\n    \n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)] # 4-directional connectivity\n\n    while q:\n        r, c = q.popleft()\n        \n        for dr, dc in moves:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds and if it's a '0' and not yet visited\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr][nc] == 0 and not visited_main[nr][nc]:\n                visited_main[nr][nc] = True\n                region_cells.add((nr, nc))\n                q.append((nr, nc))\n                \n    return region_cells\n\ndef _get_perimeter(region_cells: set[tuple[int, int]], grid_rows: int, grid_cols: int) -> set[tuple[int, int]]:\n    \"\"\"\n    Calculates the complete perimeter (8-directional adjacency) of a region.\n\n    Args:\n        region_cells: A set of (row, col) tuples for the region.\n        grid_rows: Number of rows in the grid.\n        grid_cols: Number of columns in the grid.\n\n    Returns:\n        A set of (row, col) tuples representing the perimeter cells.\n    \"\"\"\n    perimeter_cells = set()\n    # Check all 8 neighbors for each cell in the region\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] \n    \n    for r, c in region_cells:\n        for dr, dc in moves:\n            nr, nc = r + dr, c + dc\n            \n            # Check if neighbor is within bounds\n            if 0 <= nr < grid_rows and 0 <= nc < grid_cols:\n                neighbor_coord = (nr, nc)\n                # If the neighbor is not part of the original region, it's a perimeter cell\n                if neighbor_coord not in region_cells:\n                    perimeter_cells.add(neighbor_coord)\n            else:\n                # If a neighbor would be outside the grid, the region touches the boundary.\n                # Add a special marker or handle appropriately later. For now, adding None.\n                # (Alternatively, could return an empty set immediately if boundary touched)\n                 perimeter_cells.add(None) # Indicate boundary contact\n\n\n    return perimeter_cells\n\ndef _check_perimeter_is_all_5(perimeter_cells: set[tuple[int, int]], grid: list[list[int]]) -> bool:\n    \"\"\"\n    Checks if all cells in the perimeter set exist and have the value 5.\n\n    Args:\n        perimeter_cells: The set of perimeter cell coordinates. Includes None if boundary touched.\n        grid: The input grid.\n\n    Returns:\n        True if all perimeter cells are '5', False otherwise.\n    \"\"\"\n    if not perimeter_cells: # Empty region? Should not happen if called correctly.\n        return False\n        \n    if None in perimeter_cells: # Touched boundary\n        return False\n        \n    for r, c in perimeter_cells:\n        # This check should be redundant if _get_perimeter ensures bounds, but good practice.\n        # Check if coordinates are valid (already done by _get_perimeter logic)\n        # Now, check the value\n        if grid[r][c] != 5:\n            return False\n            \n    return True\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    # Keep track of visited cells to avoid re-processing regions\n    visited_main = [[False for _ in range(cols)] for _ in range(rows)]\n\n    # Iterate through each cell of the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If we find an unvisited '0' cell, start processing its region\n            if input_grid[r][c] == 0 and not visited_main[r][c]:\n                \n                # 1. Find the connected region of 0s this cell belongs to\n                #    The visited_main grid is updated within this function\n                region = _find_connected_region(input_grid, r, c, visited_main)\n                \n                # 2. Get the perimeter of this region\n                perimeter = _get_perimeter(region, rows, cols)\n                \n                # 3. Check if the entire perimeter consists of '5's\n                if _check_perimeter_is_all_5(perimeter, input_grid):\n                    # 4. If yes, fill the region with '2's in the output grid\n                    for rr, cc in region:\n                        output_grid[rr][cc] = 2\n                # Else (perimeter not all 5s), do nothing, cells remain 0 in the copied output_grid\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10627,
    "candidates_token_count": 3585,
    "total_token_count": 14212,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.507485,
  "retries": 1
}