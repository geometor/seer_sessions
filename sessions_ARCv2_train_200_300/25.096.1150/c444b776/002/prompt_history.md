
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0
0 0 0 0 0 5 0 2 0
0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0
0 2 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 0 0 0 0 0
0 7 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 0 0 7 0 0 0 4 0 0 0 0 0 7 0 0 0
0 0 0 2 0 0 0 0 0 4 0 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 0 4 0 0 2 0 0 0 0 0 0
0 3 0 0 0 3 0 0 0 4 0 3 0 0 0 3 0 0 0
0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0
0 0 0 8 7 0 0 0 0 4 0 0 0 8 7 0 0 0 0
0 0 0 0 8 0 0 3 0 4 0 0 0 0 8 0 0 3 0
0 7 0 0 0 0 0 0 0 4 0 7 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception of Elements:**

1.  **Grids:** Both input and output are 2D grids containing single-digit integers.
2.  **Separator Lines:** A key feature in both examples is the presence of lines (horizontal or both horizontal and vertical) composed entirely of the number 4. These lines act as dividers or axes of symmetry/replication.
3.  **Source Pattern:** The region(s) of the grid *before* the separator line(s) seem to define a source pattern. In `train_1`, this is the area above the horizontal line. In `train_2`, this is the top-left quadrant defined by both lines.
4.  **Replication:** The transformation involves replicating the source pattern into other regions defined by the separator lines. The separator lines themselves remain unchanged.
5.  **Replication Types:**
    *   `train_1`: The pattern above the horizontal line is copied to the area below the line.
    *   `train_2`: The pattern in the top-left quadrant is copied to the top-right, bottom-left, and bottom-right quadrants.

**YAML Fact Document:**


```yaml
task_type: grid_transformation
elements:
  - object: grid
    properties:
      - type: 2D array
      - content: integers (0-9 observed)
      - features:
          - separator_lines:
              - value: 4
              - orientation: horizontal or vertical or both
              - function: divides grid into regions

  - object: source_pattern
    properties:
      - location: region(s) before separator line(s)
      - content: subgrid from input

  - object: target_regions
    properties:
      - location: region(s) after separator line(s)
      - content: initially may contain different data (or zeros) in input, overwritten in output

actions:
  - action: identify_separators
    inputs: input_grid, separator_value (4)
    outputs: coordinates of horizontal_line (row_index), coordinates of vertical_line (column_index)
    description: Finds the first complete row and column consisting solely of the separator value.

  - action: extract_source_pattern
    inputs: input_grid, separator_coordinates
    outputs: source_subgrid
    description: Extracts the subgrid located before the identified separators (e.g., top-left quadrant if both exist, top section if only horizontal exists).

  - action: replicate_pattern
    inputs: output_grid (initially copy of input), source_subgrid, separator_coordinates
    outputs: modified_output_grid
    description: Copies the source_subgrid into the target regions defined by the separators, overwriting existing content in those regions.

relationships:
  - type: definition
    subject: source_pattern
    object: region before separator(s) in input_grid
  - type: transformation
    subject: target_regions in output_grid
    object: replication of source_pattern
  - type: boundary
    subject: separator_lines
    object: divide input_grid into source/target regions
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Define the separator value as 4.
3.  Identify the row index (`hr`) of the first row composed entirely of the separator value (4). If no such row exists, set `hr` to null.
4.  Identify the column index (`vc`) of the first column composed entirely of the separator value (4). If no such column exists, set `vc` to null.
5.  If both `hr` and `vc` were found:
    a.  Extract the source pattern from the input grid: the subgrid from row 0 to `hr-1` and column 0 to `vc-1`.
    b.  Copy this source pattern to the output grid in the top-right region (rows 0 to `hr-1`, columns `vc+1` to end).
    c.  Copy this source pattern to the output grid in the bottom-left region (rows `hr+1` to end, columns 0 to `vc-1`).
    d.  Copy this source pattern to the output grid in the bottom-right region (rows `hr+1` to end, columns `vc+1` to end).
6.  Else if only `hr` was found:
    a.  Extract the source pattern from the input grid: the subgrid from row 0 to `hr-1` and all columns.
    b.  Copy this source pattern to the output grid in the region below the separator line (rows `hr+1` to end, all columns).
7.  Else if only `vc` was found:
    a.  Extract the source pattern from the input grid: the subgrid from column 0 to `vc-1` and all rows.
    b.  Copy this source pattern to the output grid in the region to the right of the separator line (all rows, columns `vc+1` to end).
8.  Return the modified output grid. (If neither `hr` nor `vc` is found, the original copy of the input is returned).
```python
import numpy as np
import copy

"""
Identifies horizontal and/or vertical separator lines composed entirely of the number 4.
If a horizontal separator is found, the pattern above it is copied to the region below it.
If a vertical separator is found, the pattern to its left is copied to the region to its right.
If both separators are found, the pattern in the top-left quadrant is copied to the top-right, bottom-left, and bottom-right quadrants.
The separator lines themselves remain unchanged.
If no separators are found, the input grid is returned unchanged.
"""

def find_horizontal_separator(grid: np.ndarray, separator_value: int) -> int | None:
    """Finds the row index of the first horizontal separator line."""
    num_rows, num_cols = grid.shape
    for r in range(num_rows):
        if np.all(grid[r, :] == separator_value):
            return r
    return None

def find_vertical_separator(grid: np.ndarray, separator_value: int) -> int | None:
    """Finds the column index of the first vertical separator line."""
    num_rows, num_cols = grid.shape
    for c in range(num_cols):
        if np.all(grid[:, c] == separator_value):
            return c
    return None

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule based on separator lines.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Convert input to numpy array for easier slicing
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Initialize output_grid as a copy
    num_rows, num_cols = grid.shape
    separator_value = 4

    # Find separator lines
    hr = find_horizontal_separator(grid, separator_value)
    vc = find_vertical_separator(grid, separator_value)

    # Case 1: Both horizontal and vertical separators found
    if hr is not None and vc is not None:
        # Extract source pattern (top-left quadrant)
        source_pattern = grid[0:hr, 0:vc]

        # Replicate pattern to other quadrants, checking bounds
        # Top-right
        if hr > 0 and vc + 1 < num_cols:
             output_grid[0:hr, vc + 1:num_cols] = source_pattern[:, 0:min(source_pattern.shape[1], num_cols - (vc + 1))]
        # Bottom-left
        if hr + 1 < num_rows and vc > 0:
            output_grid[hr + 1:num_rows, 0:vc] = source_pattern[0:min(source_pattern.shape[0], num_rows - (hr + 1)), :]
        # Bottom-right
        if hr + 1 < num_rows and vc + 1 < num_cols:
             output_grid[hr + 1:num_rows, vc + 1:num_cols] = source_pattern[0:min(source_pattern.shape[0], num_rows - (hr + 1)), 0:min(source_pattern.shape[1], num_cols - (vc + 1))]


    # Case 2: Only horizontal separator found
    elif hr is not None:
        # Extract source pattern (above the line)
        source_pattern = grid[0:hr, :]
        # Replicate pattern below the line, checking bounds
        if hr + 1 < num_rows:
             output_grid[hr + 1:num_rows, :] = source_pattern[0:min(source_pattern.shape[0], num_rows - (hr + 1)), :]


    # Case 3: Only vertical separator found
    elif vc is not None:
        # Extract source pattern (left of the line)
        source_pattern = grid[:, 0:vc]
        # Replicate pattern to the right of the line, checking bounds
        if vc + 1 < num_cols:
             output_grid[:, vc + 1:num_cols] = source_pattern[:, 0:min(source_pattern.shape[1], num_cols - (vc + 1))]

    # Case 4: No separators found - output_grid remains the same as input

    # Convert back to list of lists before returning
    return output_grid.tolist()
```
