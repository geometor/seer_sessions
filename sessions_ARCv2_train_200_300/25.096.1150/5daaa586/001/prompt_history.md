
## train_1

**input:**
```
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
8 8 4 8 8 8 8 8 8 1 8 8
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 8 0 0 1 0 8
0 0 4 8 0 0 8 0 0 1 0 0
0 0 4 0 0 0 0 0 0 1 0 0
0 0 4 0 0 0 0 8 0 1 0 8
6 6 6 6 6 6 6 6 6 1 6 6
0 0 4 0 0 0 8 0 0 1 0 0
0 8 4 0 0 0 0 8 0 1 0 0
```


**output:**
```
4 8 8 8 8 8 8 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 8 0 0 8 8 0 1
4 0 0 0 0 8 0 1
4 0 0 0 0 8 0 1
6 6 6 6 6 6 6 1
```


## train_2

**input:**
```
0 0 0 0 0 3 0 0 0 2 0 0 0 0 0 0 8 0 0 0 0 0
1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 8 1 1 1 1 1
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 2 8 0 0 0 0 0
0 0 0 2 0 3 0 0 0 0 0 0 0 0 0 0 8 0 2 0 0 0
0 0 0 0 0 3 0 0 0 2 0 0 0 0 0 0 8 0 0 2 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 2 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 2 0 3 0 2 0 0 0 0 0 0 2 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 2 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 2 2 2 2 3 2 2 2 2 2 2 2 2 2 2 8 2 2 2 2 2
0 0 0 0 0 3 0 0 2 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0
2 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 8 0 0 0 2 0
```


**output:**
```
3 1 1 1 1 1 1 1 1 1 1 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 0 8
3 0 0 0 0 0 0 0 0 0 2 8
3 0 0 0 0 0 0 0 0 0 2 8
3 0 0 0 2 0 0 0 0 0 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 0 0 2 0 0 0 0 2 2 8
3 0 2 0 2 0 0 0 0 2 2 8
3 0 2 0 2 0 0 0 0 2 2 8
3 2 2 0 2 0 0 0 0 2 2 8
3 2 2 2 2 2 2 2 2 2 2 8
```


## train_3

**input:**
```
0 0 4 3 0 0 0 4 0 0 0 4 0 0 0
0 0 0 3 0 4 0 0 0 0 0 4 0 0 0
0 0 0 3 0 0 4 0 0 0 0 4 0 0 0
0 0 0 3 0 4 0 0 0 0 0 4 0 0 0
0 0 0 3 0 0 0 0 0 0 4 4 4 0 4
2 2 2 3 2 2 2 2 2 2 2 4 2 2 2
4 0 0 3 4 4 0 4 0 0 0 4 0 0 0
0 0 0 3 0 0 0 0 0 0 0 4 0 0 0
4 0 0 3 0 0 0 0 4 0 4 4 0 0 0
4 0 0 3 0 0 4 0 0 0 4 4 0 0 0
8 8 8 3 8 8 8 8 8 8 8 4 8 8 8
0 0 0 3 0 0 0 0 0 0 4 4 0 0 4
0 0 0 3 4 0 0 4 0 0 0 4 0 0 0
0 0 4 3 0 0 0 0 0 4 0 4 0 0 0
```


**output:**
```
3 2 2 2 2 2 2 2 4
3 4 4 4 4 4 4 4 4
3 0 0 0 0 0 0 0 4
3 0 0 0 0 4 4 4 4
3 0 0 4 4 4 4 4 4
3 8 8 8 8 8 8 8 4
```

Okay, let's analyze the provided examples to understand the transformation logic.

## Perception

The task involves transforming a 2D grid of integers (input) into a smaller 2D grid of integers (output). The core operation appears to be the extraction of a specific rectangular subgrid from the input. The boundaries of this subgrid are determined by identifying two specific columns and two specific rows within the input grid.

1.  **Boundary Columns:** Two columns in the input grid serve as the left and right boundaries. These columns are often characterized by containing a consistent non-zero value vertically (e.g., column of '4's and column of '1's in train_1; column of '3's and '8's in train_2; column of '3's and '4's in train_3). Let's call the index of the leftmost boundary column `col1` and the rightmost `col2`.
2.  **Boundary Rows:** Two rows in the input grid serve as the top and bottom boundaries. These rows are identified as the first (`row1`) and the last (`row2`) rows where *all* the elements between `col1` and `col2` (inclusive) are non-zero.
3.  **Extraction:** The output grid is the subgrid of the input grid defined by the rectangle spanning from `row1` to `row2` (inclusive) and `col1` to `col2` (inclusive).

## Facts


```yaml
objects:
  - name: Input Grid
    properties:
      - type: 2D array of integers
      - dimensions: variable (e.g., 12x12, 22x22, 14x15)
  - name: Output Grid
    properties:
      - type: 2D array of integers
      - dimensions: smaller than Input Grid, determined by extraction rule
  - name: Boundary Columns
    properties:
      - count: 2 (left and right)
      - identification: Based on columns predominantly containing a single distinct non-zero value, marking vertical extents.
      - indices: col1 (leftmost), col2 (rightmost)
  - name: Boundary Rows
    properties:
      - count: 2 (top and bottom)
      - identification: First (row1) and last (row2) rows where all elements between col1 and col2 (inclusive) are non-zero.
      - indices: row1 (topmost), row2 (bottommost)
  - name: Subgrid
    properties:
      - location: Defined by [row1:row2+1, col1:col2+1] slice of Input Grid.
      - content: Becomes the Output Grid.

actions:
  - name: Identify Boundary Columns
    inputs: Input Grid
    outputs: col1, col2
    description: Scan columns to find the leftmost (col1) and rightmost (col2) columns that act as vertical delimiters, often containing a consistent non-zero digit.
  - name: Identify Boundary Rows
    inputs: Input Grid, col1, col2
    outputs: row1, row2
    description: Scan rows to find the first row (row1) and last row (row2) where all elements Input[row, col1:col2+1] are non-zero.
  - name: Extract Subgrid
    inputs: Input Grid, row1, row2, col1, col2
    outputs: Output Grid
    description: Create the Output Grid by selecting the elements from Input Grid within the rectangle defined by row1, row2, col1, and col2.

relationships:
  - Output Grid is a subgrid of Input Grid.
  - The dimensions and content of Output Grid depend on the identified Boundary Rows and Boundary Columns in the Input Grid.
  - Boundary Rows are defined relative to the span between Boundary Columns.
```


## Natural Language Program

1.  **Identify Boundary Columns:** Examine the columns of the input grid. Find the index of the leftmost column (`col1`) and the rightmost column (`col2`) that serve as distinct vertical markers, typically characterized by containing a repeating, unique non-zero digit down the column (allowing for some interspersed zeros).
2.  **Identify Boundary Rows:** Examine the rows of the input grid. Find the index of the first row (`row1`) where all elements from column `col1` to `col2` (inclusive) are non-zero. Then, find the index of the last row (`row2`) where all elements from column `col1` to `col2` (inclusive) are non-zero.
3.  **Extract Output:** Construct the output grid by extracting the rectangular subgrid from the input grid starting at row `row1` and ending at row `row2` (inclusive), and starting at column `col1` and ending at column `col2` (inclusive).
