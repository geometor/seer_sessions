{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\n\n\"\"\"\nExtracts a subgrid defined by the bounding box of the single largest monochromatic\nconnected component (LMC) from the input grid. Within this subgrid (the output grid), \noriginal non-zero colors from the input grid are preserved. Any cells that were \nbackground (0) in the input grid within the bounding box are filled with the \ncolor of the LMC.\n\"\"\"\n\n# Helper function for Breadth-First Search (BFS) to find a single monochromatic connected component\ndef _bfs_mono(grid: list[list[int]], start_row: int, start_col: int, visited_component: set[tuple[int, int]], target_color: int) -> set[tuple[int, int]]:\n    \"\"\"\n    Performs BFS to find a connected component of cells matching a specific target_color.\n    Marks cells visited *within this specific component search*.\n\n    Args:\n        grid: The input grid.\n        start_row: The starting row for the search.\n        start_col: The starting column for the search.\n        visited_component: A set to keep track of visited cells during this specific BFS run. \n                           This set is modified by the function.\n        target_color: The specific color to look for in the component.\n\n    Returns:\n        A set of (row, col) tuples representing the coordinates of the found component.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    component = set() # Stores coordinates of cells in this component\n    queue = collections.deque([(start_row, start_col)]) # Queue for BFS\n\n    # Mark start cell as visited *for this component* and add to component set\n    visited_component.add((start_row, start_col)) \n    component.add((start_row, start_col))\n\n    while queue:\n        r, c = queue.popleft() # Get next cell\n\n        # Explore neighbors (4-directional: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor has the target color and hasn't been visited *for this component* yet\n                if grid[nr][nc] == target_color and (nr, nc) not in visited_component:\n                    visited_component.add((nr, nc)) # Mark visited for this BFS\n                    component.add((nr, nc))       # Add to the component set\n                    queue.append((nr, nc))        # Add to queue for further exploration\n                    \n    return component\n\n# Helper function to find the largest monochromatic component\ndef _find_largest_mono_component(grid: list[list[int]]) -> tuple[set[tuple[int, int]], int]:\n    \"\"\"\n    Finds the largest monochromatic (single-color) connected component in the grid.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing:\n        - A set of (row, col) tuples representing the coordinates of the largest component.\n        - The integer color of the largest component.\n        Returns an empty set and color 0 if no non-zero cells exist.\n    \"\"\"\n    # Handle empty grid case\n    if not grid or not grid[0]:\n        return set(), 0\n        \n    rows, cols = len(grid), len(grid[0])\n    # visited_overall tracks cells that are already part of *any* found component\n    # This prevents re-starting BFS for cells already assigned to a component.\n    visited_overall = set() \n    largest_component_coords = set()\n    largest_size = 0\n    largest_component_color = 0\n\n    # Iterate through each cell of the grid\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r][c]\n            # If it's a non-zero cell and not yet part of any previously found component\n            if color != 0 and (r, c) not in visited_overall:\n                # Use a temporary visited set specifically for the current BFS search\n                # This prevents infinite loops within a single BFS run.\n                visited_component_search = set() \n                \n                # Find the full monochromatic component starting from (r, c)\n                current_component = _bfs_mono(grid, r, c, visited_component_search, color)\n                current_size = len(current_component)\n                \n                # Mark all cells of the found component as visited overall\n                # so we don't start new searches from them later.\n                visited_overall.update(current_component) \n\n                # Check if this component is the largest found so far\n                if current_size > largest_size:\n                    largest_size = current_size\n                    largest_component_coords = current_component\n                    largest_component_color = color\n                    \n    return largest_component_coords, largest_component_color\n\n# Helper function to calculate the bounding box of a component\ndef _get_bounding_box(component_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the minimum bounding box (min_row, max_row, min_col, max_col) \n    for a given set of component coordinates.\n\n    Args:\n        component_coords: A set of (row, col) tuples.\n\n    Returns:\n        A tuple (min_row, max_row, min_col, max_col). \n        Returns (0, -1, 0, -1) if the component_coords set is empty.\n    \"\"\"\n    # Handle empty component case\n    if not component_coords:\n        return 0, -1, 0, -1 # Represents an invalid/empty box\n\n    # Determine the min/max row and column indices from the coordinates\n    min_r = min(r for r, c in component_coords)\n    max_r = max(r for r, c in component_coords)\n    min_c = min(c for r, c in component_coords)\n    max_c = max(c for r, c in component_coords)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on its largest monochromatic component (LMC).\n    1. Finds the LMC and its color.\n    2. Determines the bounding box of the LMC.\n    3. Creates an output grid matching the bounding box size.\n    4. Populates the output grid by copying the input grid's content within the \n       bounding box, replacing background '0's with the LMC's color.\n    \"\"\"\n    \n    # 1. Find the largest monochromatic component and its color\n    largest_component_coords, lmc_color = _find_largest_mono_component(input_grid)\n\n    # Handle edge case: no non-zero components found in the input grid\n    if not largest_component_coords:\n        return [] # Return an empty list if no component exists\n\n    # 2. Calculate the bounding box of the largest component\n    min_r, max_r, min_c, max_c = _get_bounding_box(largest_component_coords)\n    \n    # Handle potential edge case: invalid bounding box (shouldn't typically happen if a component was found)\n    if max_r < min_r or max_c < min_c:\n         return []\n\n    # 3. Calculate output grid dimensions based on the bounding box\n    out_rows = max_r - min_r + 1\n    out_cols = max_c - min_c + 1\n\n    # 4. Create and populate the output grid\n    # Initialize output grid (size based on bounding box) - can initialize with any value, e.g., 0\n    output_grid = [[0 for _ in range(out_cols)] for _ in range(out_rows)] \n\n    # Iterate through the input grid cells that fall *within* the bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Get the color from the original input grid at this location\n            input_color = input_grid[r][c]\n            \n            # Calculate the corresponding coordinates in the output grid\n            # (relative to the top-left corner of the bounding box)\n            out_r = r - min_r\n            out_c = c - min_c\n            \n            # Apply the filling rule:\n            # If the input cell within the bounding box is background (0), \n            # fill the corresponding output cell with the LMC's color.\n            # Otherwise (if it's non-zero), copy the input cell's color directly.\n            if input_color == 0:\n                output_grid[out_r][out_c] = lmc_color\n            else:\n                output_grid[out_r][out_c] = input_color\n                \n    # Return the fully constructed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13247,
    "candidates_token_count": 2977,
    "total_token_count": 16224,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.589561,
  "retries": 1
}