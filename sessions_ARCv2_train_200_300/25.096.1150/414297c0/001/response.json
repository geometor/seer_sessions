{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\n\n\"\"\"\nTransforms the input grid by performing the following steps:\n1. Identifies all connected components of non-zero cells. Connectivity is 4-directional (up, down, left, right).\n   All adjacent non-zero cells are considered connected, regardless of their specific color value.\n2. Selects the component with the largest number of cells. If there's a tie, any of the largest is chosen.\n3. Determines the dominant (most frequent) non-zero color within the largest component.\n4. Calculates the minimum bounding box (smallest rectangle) enclosing the largest component.\n5. Creates an output grid with dimensions matching the bounding box.\n6. Fills the output grid:\n   - Cells that correspond to a cell location within the bounding box *and* belong to the largest component\n     are assigned their original color from the input grid.\n   - All other cells within the output grid (those corresponding to background '0' cells or cells belonging\n     to other components within the input grid's bounding box) are filled with the dominant color found in step 3.\n\"\"\"\n\n# Helper function for Breadth-First Search (BFS) to find a single connected component\ndef _bfs(grid: list[list[int]], start_row: int, start_col: int, visited: set[tuple[int, int]]) -> set[tuple[int, int]]:\n    \"\"\"Performs Breadth-First Search to find a connected component of non-zero cells.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    component = set() # Stores (row, col) tuples of the cells in this component\n    queue = collections.deque([(start_row, start_col)]) # Initialize queue for BFS\n    visited.add((start_row, start_col)) # Mark the starting cell as visited\n    component.add((start_row, start_col)) # Add the starting cell to the component\n\n    while queue:\n        r, c = queue.popleft() # Get the next cell from the front of the queue\n\n        # Explore neighbors (4-directional: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is within the grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor cell is non-zero and has not been visited yet\n                if grid[nr][nc] != 0 and (nr, nc) not in visited:\n                    visited.add((nr, nc)) # Mark the neighbor as visited\n                    component.add((nr, nc)) # Add the neighbor to the current component\n                    queue.append((nr, nc)) # Add the neighbor to the queue to explore its neighbors later\n    return component\n\n# Helper function to find all connected components in the grid\ndef _find_connected_components(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"Finds all distinct connected components of non-zero cells in the grid.\"\"\"\n    # Handle empty grid case\n    if not grid or not grid[0]:\n        return []\n        \n    rows, cols = len(grid), len(grid[0])\n    visited = set() # Keep track of all visited cells across all components\n    components = [] # List to store each found component (a set of coordinates)\n    \n    # Iterate through each cell of the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If a cell is non-zero and hasn't been visited as part of a previous component\n            if grid[r][c] != 0 and (r, c) not in visited:\n                # Start a BFS from this cell to find its entire connected component\n                component = _bfs(grid, r, c, visited)\n                if component: # Should always be true if starting from a non-zero cell\n                    components.append(component)\n    return components\n\n# Helper function to find the dominant color in a component\ndef _get_dominant_color(grid: list[list[int]], component_coords: set[tuple[int, int]]) -> int:\n    \"\"\"Finds the most frequent non-zero color within a given component's coordinates.\"\"\"\n    # Handle empty component case (should not happen with valid input)\n    if not component_coords:\n        return 0 # Default to background color\n\n    # Collect all non-zero colors from the grid at the component's coordinates\n    colors = [grid[r][c] for r, c in component_coords if grid[r][c] != 0]\n\n    # Handle case where component only contained zeros (unlikely given BFS logic)\n    if not colors:\n        return 0\n\n    # Count the frequency of each color\n    count = collections.Counter(colors)\n    # Find the most common color. most_common(1) returns list like [(color, freq)]\n    dominant_color = count.most_common(1)[0][0]\n    return dominant_color\n\n# Helper function to calculate the bounding box of a component\ndef _get_bounding_box(component_coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the minimum bounding box (min_row, max_row, min_col, max_col) for a component.\"\"\"\n    # Handle empty component case\n    if not component_coords:\n        return 0, -1, 0, -1 # Represents an invalid/empty box\n\n    # Determine the min/max row and column indices among the component's cells\n    min_r = min(r for r, c in component_coords)\n    max_r = max(r for r, c in component_coords)\n    min_c = min(c for r, c in component_coords)\n    max_c = max(c for r, c in component_coords)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Extracts the largest connected non-zero region from the input grid and represents \n    it within its bounding box, filling non-region cells with the region's dominant color.\n    \"\"\"\n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # 1. Find all connected components of non-zero cells\n    components = _find_connected_components(input_grid)\n\n    # Handle case where there are no non-zero cells in the input\n    if not components:\n        return [] # Return empty grid if no components found\n\n    # 2. Identify the largest component (based on the number of cells)\n    largest_component = max(components, key=len)\n\n    # 3. Determine the dominant color of the largest component\n    dominant_color = _get_dominant_color(input_grid, largest_component)\n\n    # 4. Calculate the bounding box of the largest component\n    min_r, max_r, min_c, max_c = _get_bounding_box(largest_component)\n\n    # Handle potential invalid bounding box (e.g., if largest_component was somehow empty)\n    if max_r < min_r or max_c < min_c:\n         return []\n\n    # 5. Create the output grid based on bounding box dimensions\n    out_rows = max_r - min_r + 1\n    out_cols = max_c - min_c + 1\n    # Initialize the output grid, pre-filling it with the dominant color.\n    # This takes care of all cells that are NOT part of the largest component.\n    output_grid = [[dominant_color for _ in range(out_cols)] for _ in range(out_rows)]\n\n    # 6. Populate the output grid with the actual colors from the largest component\n    # Iterate through each cell coordinate (r, c) belonging to the largest component\n    for r, c in largest_component:\n        # Calculate the corresponding position (out_r, out_c) in the output grid\n        # by shifting the coordinates relative to the top-left corner of the bounding box.\n        out_r = r - min_r\n        out_c = c - min_c\n\n        # Place the original color from the input grid into the output grid at the calculated position.\n        # This overwrites the pre-filled dominant color for cells that are part of the component.\n        # Bounds check (0 <= out_r < out_rows and 0 <= out_c < out_cols) is implicitly handled\n        # by the bounding box calculation and component definition, but could be added for robustness.\n        output_grid[out_r][out_c] = input_grid[r][c]\n\n    # Return the final constructed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4577,
    "candidates_token_count": 6795,
    "total_token_count": 11372,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 58.362809,
  "retries": 1
}