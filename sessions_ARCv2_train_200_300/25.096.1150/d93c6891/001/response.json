{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nIdentify connected blocks of color 7 in the input grid. Based on the height (H) and width (W) of each block's bounding box, apply specific transformations changing some or all 7s to 5s:\n- If H=1, no change.\n- If H=2 and W=2 or W=3, change all 7s in the block to 5s.\n- If H=2 and W=6, change 7s in the top row of the block to 5s, leave the bottom row as 7s.\n- If H=3 and W=3, change 7s in the first two columns of the block to 5s, leave the third column as 7s.\nAfter processing all 7-blocks, iterate through the grid and change any cell that was originally color 5 to color 4.\n\"\"\"\n\ndef find_connected_components(grid: list[list[int]], target_color: int) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds all connected components of a target color in a grid using BFS.\n    Uses 4-way (cardinal) connectivity.\n    \"\"\"\n    if not grid:\n        return []\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == target_color and (r, c) not in visited:\n                # Start BFS for a new component\n                component = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] == target_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if component:\n                    components.append(component)\n                    \n    return components\n\ndef get_block_properties(block_cells: set[tuple[int, int]]) -> tuple[int, int, int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box, height, and width of a block.\n    Returns (min_row, min_col, max_row, max_col, height, width).\n    \"\"\"\n    if not block_cells:\n        return -1, -1, -1, -1, 0, 0\n        \n    min_row = min(r for r, c in block_cells)\n    min_col = min(c for r, c in block_cells)\n    max_row = max(r for r, c in block_cells)\n    max_col = max(c for r, c in block_cells)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    return min_row, min_col, max_row, max_col, height, width\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    1. Finds blocks of color 7.\n    2. Transforms 7s to 5s based on block dimensions.\n    3. Transforms original 5s to 4s.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input grid\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    # 1. Find all connected blocks of color 7\n    seven_blocks = find_connected_components(input_grid, 7)\n\n    # 2. Process each block of 7s based on its dimensions\n    for block in seven_blocks:\n        min_r, min_c, max_r, max_c, H, W = get_block_properties(block)\n\n        # Apply transformation rules based on height (H) and width (W)\n        if H == 1:\n            # Rule i: If H == 1, leave all 7s in this block unchanged.\n            # No action needed as output_grid starts as a copy.\n            pass \n        elif H == 2 and (W == 2 or W == 3):\n             # Rule ii: If H == 2 and W == 2 or W == 3, change all 7s to 5s.\n             # Iterate within the bounding box, changing only actual block cells.\n             for r, c in block:\n                 output_grid[r][c] = 5\n        elif H == 2 and W == 6:\n            # Rule iii: If H == 2 and W == 6, change top row 7s to 5s, leave bottom row 7s.\n            for r, c in block:\n                 if r == min_r: # Top row of the block\n                     output_grid[r][c] = 5\n                 # else: leave as 7 (already copied)\n        elif H == 3 and W == 3:\n            # Rule iv: If H == 3 and W == 3, change first two columns' 7s to 5s, leave third column 7s.\n             for r, c in block:\n                 if c == min_c or c == min_c + 1: # First two columns of the block\n                     output_grid[r][c] = 5\n                 # else: leave as 7 (already copied)\n        # Add more rules here if discovered from new examples\n\n    # 3. Transform original 5s to 4s\n    # Iterate through the *original* input grid to identify where 5s were.\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r][c] == 5:\n                # Change the corresponding cell in the output grid to 4.\n                # This overwrites any potential 7->5 change if it happened at an original 5 location.\n                output_grid[r][c] = 4\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4377,
    "candidates_token_count": 2502,
    "total_token_count": 6879,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 101.477284,
  "retries": 2
}