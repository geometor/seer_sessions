
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0
0 2 2 0 2 2 2 2 2 0
0 2 0 0 0 2 2 2 2 0
0 2 2 2 2 2 2 2 2 0
0 2 2 2 2 0 0 2 2 0
0 2 2 2 2 0 2 0 2 0
0 2 2 2 2 2 0 0 2 0
0 2 2 2 2 2 2 2 2 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 4 2 4 0 0 0 0 0 0
0 2 2 4 0 0 0 0 0 0
0 4 2 4 0 2 2 3 0 0
0 0 0 0 0 2 3 2 0 0
0 0 0 0 0 3 2 2 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2
2 4 2 4 2 2 2 2
2 2 2 2 2 2 2 2
2 4 4 4 2 2 2 2
2 2 2 2 2 2 3 2
2 2 2 2 2 3 2 2
2 2 2 2 3 2 2 2
2 2 2 2 2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 0 0 2 2 2 2 0 2 0 0 2 2 2 0 0 0
0 0 2 2 2 2 2 2 2 0 2 0 0 1 2 1 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 0 0 0 2 2 2 0 0 0 2 2 2 0 0
0 0 2 2 2 2 0 2 2 2 2 0 0 0 3 3 3 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 2 0 2 2 2 0 2 2 0 0 0 0 0 0 0 0
0 0 2 0 0 2 2 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 2 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 8 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 4 4 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 4 2 4 0 0 2 2 2 0 0 0 0 0 0 0 0
0 0 0 2 2 4 0 0 5 5 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 4 4 2 2 3 2 3
2 2 2 4 2 2 3 2 3
2 4 4 4 2 2 3 2 3
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 1 2 1 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
8 2 2 2 2 5 2 5 2
8 8 2 2 2 5 2 5 2
8 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 8 2 8 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 0 0 0 2 2 2 2 0 0
0 2 2 2 0 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 2 2 2 2 2 2 2 2 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 8 2 8 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2
```

*   **Perception:** The input consists of a grid containing multiple distinct shapes formed by non-zero integers, separated by a background of zeros (0). The output is a smaller grid which appears to be a cropped section of the input grid, specifically corresponding to one of the shapes present in the input. The background zeros are excluded from the output. The key transformation seems to involve identifying a specific shape within the input and extracting it.

*   **YAML Facts:**
    
```yaml
    task_type: grid_transformation
    input_features:
      - grid: 2D array of integers
      - background_value: 0
      - objects: connected components of non-zero integers
    output_features:
      - grid: 2D array of integers (subgrid of input)
      - properties: represents the largest non-zero object from the input
    actions:
      - identify_components: find all connected non-zero regions (objects) in the input grid.
      - calculate_area: determine the number of non-zero cells (area) for each object.
      - select_largest: choose the object with the maximum area.
      - find_bounding_box: determine the minimum rectangular region enclosing the selected object.
      - extract_subgrid: copy the portion of the input grid corresponding to the bounding box.
    relationships:
      - output grid is a subgrid of the input grid.
      - output grid contains the non-zero pattern of the single largest connected component found in the input.
    ```


*   **Natural Language Program:**
    1.  Identify all connected components (shapes) in the input grid consisting of cells with non-zero values. Connectivity is defined by adjacent (up, down, left, right) cells.
    2.  Calculate the area (the total count of non-zero cells) for each identified shape.
    3.  Select the shape that has the largest area.
    4.  Determine the bounding box of the selected shape (the smallest rectangle containing all its non-zero cells). This is defined by the minimum and maximum row and column indices of the shape's cells.
    5.  Extract the subgrid from the input corresponding to this bounding box. This extracted subgrid is the output.
```python
"""
Identify all connected components (shapes) in the input grid consisting of non-zero cells.
Calculate the area (count of non-zero cells) for each shape.
Select the shape with the largest area.
Determine the bounding box (minimum rectangle) containing the selected shape.
Extract the subgrid from the input corresponding to this bounding box as the output.
"""

import numpy as np
from scipy.ndimage import label, find_objects

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Extracts the largest connected non-zero object from the input grid.

    Args:
        input_grid: A list of lists representing the 2D input grid.

    Returns:
        A list of lists representing the subgrid containing the largest object.
        Returns an empty list if the input grid contains no non-zero elements.
    """
    # Convert input to a numpy array for efficient processing
    grid_np = np.array(input_grid, dtype=int)

    # Check if the grid contains any non-zero elements
    if np.sum(grid_np) == 0:
        return [] # Or handle as appropriate, e.g., return [[]] or original

    # Label connected components of non-zero elements
    # structure defines connectivity (4-connectivity in this case)
    structure = np.array([[0,1,0], [1,1,1], [0,1,0]], dtype=bool) 
    labeled_array, num_features = label(grid_np > 0, structure=structure)

    # Handle case where no features are found (should be caught by the sum check, but good practice)
    if num_features == 0:
        return []

    # Calculate the size (area) of each component
    component_sizes = np.bincount(labeled_array.ravel())

    # Find the label of the largest component (ignoring background label 0)
    # component_sizes[0] is the count of background pixels (0s)
    if len(component_sizes) > 1:
        largest_component_label = np.argmax(component_sizes[1:]) + 1
    else:
        # This case should ideally not be reached if num_features > 0 and grid has non-zeros
        # but handles edge cases like a grid with only one non-zero cell labeled '1'.
         largest_component_label = 1 if num_features == 1 else -1 # -1 indicates error or unexpected state
         if largest_component_label == -1:
             # Handle error or return empty if no valid component found despite num_features > 0
             print("Warning: No valid component found despite non-zero elements.")
             return []


    # Find the bounding box of the largest component
    # find_objects returns a list of slice objects for each labeled feature
    objects_slices = find_objects(labeled_array)
    
    # Ensure the largest component label is valid index for objects_slices
    if largest_component_label - 1 < len(objects_slices):
        bounding_box = objects_slices[largest_component_label - 1]
    else:
        # Handle error: label mismatch or issue with find_objects
        print(f"Error: Largest component label {largest_component_label} out of bounds for slices.")
        return []

    # Extract the subgrid corresponding to the bounding box from the *original* input grid
    output_grid_np = grid_np[bounding_box]

    # Convert the numpy array back to a list of lists
    output_grid = output_grid_np.tolist()

    return output_grid
```
