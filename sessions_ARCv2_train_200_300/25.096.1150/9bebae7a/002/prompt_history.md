
## train_1

**input:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 6 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 4 4 4 4 4 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 0 4 4 4 4 0 4 4 0
0 0 0 4 4 4 4 4 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 6 6 6 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 0 4 4 4 4 4 0 0 0
0 0 0 4 4 4 0 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 0 0 0
0 0 0 4 0 0 0 0 0 0
0 4 4 0 0 0 0 0 0 0
0 4 4 4 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 6 0 0
0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 4 0 0 0 0
0 0 0 4 4 0 0 0 0 0
0 4 4 0 0 4 4 0 0 0
0 4 4 4 4 4 4 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 0 0 0
0 0 0 0 4 4 0 0 0 0
0 0 0 0 4 0 4 0 0 0
0 0 0 0 0 4 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 6 6 6 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 4 4 4 0
0 0 0 0 4 4 0 0 4 4
0 0 0 0 4 0 4 4 0 4
0 0 0 0 0 4 0 0 4 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


## train_5

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 6 0 0 0
0 0 0 0 0 0 0 0 6 6 6 6 0
0 0 0 0 0 0 0 0 0 6 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 0 0 4 0 4 0 0 0 0 0
0 0 0 4 0 4 4 4 4 0 0 0 0
0 0 0 0 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The task involves manipulating 2D grids containing integer values. Each input grid features two distinct connected shapes, one composed of the integer '4' and the other of the integer '6', on a background of '0's. The output grid retains only the shape made of '4's, but its position is altered. The shape made of '6's is completely removed in the output. The transformation rule appears to involve using the position of the '6' shape to determine the new location for the '4' shape. Specifically, the '4' shape seems to be translated vertically.

*   **YAML Facts:**
    
```yaml
    objects:
      - object: grid
        properties:
          - type: 2D array of integers
          - dimensions: variable (e.g., 6x10, 12x10, 10x10, 11x10, 11x13)
          - background_value: 0
      - object: shape_4
        properties:
          - color: 4
          - role: primary object, to be moved
          - reference_point: top-most cell (minimum row index), tie-break with minimum column index
      - object: shape_6
        properties:
          - color: 6
          - role: reference object, determines vertical position
          - reference_point: bottom-most cell (maximum row index), tie-break with minimum column index
          - presence_in_output: absent (removed)
    actions:
      - action: identify_shape
        parameters:
          - color_value (4 or 6)
        output: set of coordinates for the shape
      - action: find_reference_point
        parameters:
          - shape_coordinates
          - point_type ('top-most' or 'bottom-most')
        output: reference coordinate (row, column)
      - action: calculate_translation
        parameters:
          - shape_4_reference_point
          - shape_6_reference_point
        output: vertical_shift (delta_row)
      - action: translate_shape
        parameters:
          - shape_4_coordinates
          - vertical_shift
        output: new coordinates for shape_4
      - action: generate_output_grid
        parameters:
          - input_grid_dimensions
          - translated_shape_4_coordinates
        output: final grid with translated shape_4 and background_value elsewhere
    relationships:
      - The vertical position (row index) of the 'shape_6' reference point determines the new vertical position (row index) of the 'shape_4' reference point in the output.
      - The horizontal position (column index) of the 'shape_4' reference point remains unchanged relative to its original position during the translation.
      - The 'shape_6' itself is removed from the output grid.
    ```


*   **Natural Language Program:**
    1.  Initialize an output grid with the same dimensions as the input grid, filled entirely with the background color '0'.
    2.  Identify all cells in the input grid containing the value '4' (shape_4).
    3.  Identify all cells in the input grid containing the value '6' (shape_6).
    4.  Determine the reference point for shape_4: Find the cell(s) with the minimum row index. If there are multiple, select the one among them with the minimum column index. Let this be `(r4_ref, c4_ref)`.
    5.  Determine the reference point for shape_6: Find the cell(s) with the maximum row index. If there are multiple, select the one among them with the minimum column index. Let this be `(r6_ref, c6_ref)`.
    6.  Calculate the vertical shift required: `delta_r = r6_ref - r4_ref`. The horizontal shift `delta_c` is 0.
    7.  For each cell `(r, c)` belonging to shape_4 in the input grid:
        a.  Calculate its new position in the output grid: `new_r = r + delta_r`, `new_c = c + delta_c` (which is just `c`).
        b.  If the `new_r` and `new_c` are within the bounds of the output grid, set the value of the cell at `(new_r, new_c)` in the output grid to '4'.
    8.  Return the modified output grid.
```python
"""
Transforms an input grid by relocating a shape defined by the integer '4' based on the position of a shape defined by the integer '6'.

1. Identifies the coordinates of all cells containing '4' (shape_4) and '6' (shape_6).
2. Finds the reference point for shape_4: the top-most cell (minimum row), breaking ties with the left-most cell (minimum column).
3. Finds the reference point for shape_6: the bottom-most cell (maximum row), breaking ties with the left-most cell (minimum column).
4. Calculates the vertical shift required to move the shape_4 reference point to the row of the shape_6 reference point.
5. Creates a new grid of the same dimensions as the input, filled with '0'.
6. Translates every cell of shape_4 by the calculated vertical shift and places the value '4' at the new coordinates in the output grid, provided the new coordinates are within the grid boundaries.
7. The shape_6 is not present in the output grid.
"""

import numpy as np
from typing import List, Tuple, Set

def _find_shape_coords(grid: np.ndarray, color: int) -> Set[Tuple[int, int]]:
    """Finds all coordinates (row, col) of cells with the specified color."""
    rows, cols = np.where(grid == color)
    return set(zip(rows, cols))

def _find_reference_point_shape4(coords: Set[Tuple[int, int]]) -> Tuple[int, int]:
    """Finds the top-most, then left-most reference point for shape 4."""
    if not coords:
        raise ValueError("Shape 4 coordinates cannot be empty.")
    min_row = min(r for r, c in coords)
    top_coords = [(r, c) for r, c in coords if r == min_row]
    min_col = min(c for r, c in top_coords)
    return (min_row, min_col)

def _find_reference_point_shape6(coords: Set[Tuple[int, int]]) -> Tuple[int, int]:
    """Finds the bottom-most, then left-most reference point for shape 6."""
    if not coords:
       raise ValueError("Shape 6 coordinates cannot be empty.")
    max_row = max(r for r, c in coords)
    bottom_coords = [(r, c) for r, c in coords if r == max_row]
    min_col = min(c for r, c in bottom_coords)
    return (max_row, min_col)

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    Moves shape 4 vertically based on the position of shape 6.
    """
    # Convert input to numpy array for easier processing
    grid_np = np.array(input_grid, dtype=int)
    rows, cols = grid_np.shape

    # Initialize output grid with background color 0
    output_grid = np.zeros_like(grid_np)

    # 1. Identify coordinates for shape 4 and shape 6
    shape_4_coords = _find_shape_coords(grid_np, 4)
    shape_6_coords = _find_shape_coords(grid_np, 6)

    # Handle cases where one or both shapes might be missing (though not in examples)
    if not shape_4_coords:
        return output_grid.tolist() # Return empty grid if no shape 4
    if not shape_6_coords:
         # If no shape 6, maybe shape 4 stays? Or disappears?
         # Based on examples, shape 6 is always present. Assuming shape 4 stays if 6 is absent.
         # Or perhaps the task implies both must exist. Let's assume it stays for now.
         # Revisit if test cases show otherwise.
        for r, c in shape_4_coords:
             output_grid[r, c] = 4
        return output_grid.tolist()


    # 2. Find reference point for shape 4
    r4_ref, c4_ref = _find_reference_point_shape4(shape_4_coords)

    # 3. Find reference point for shape 6
    r6_ref, c6_ref = _find_reference_point_shape6(shape_6_coords)

    # 4. Calculate the vertical shift
    delta_r = r6_ref - r4_ref
    # delta_c = 0 # Horizontal shift is always zero based on the description

    # 5. & 6. Translate shape 4 and place it in the output grid
    for r, c in shape_4_coords:
        new_r = r + delta_r
        new_c = c # No horizontal shift

        # Check if the new position is within the grid bounds
        if 0 <= new_r < rows and 0 <= new_c < cols:
            output_grid[new_r, new_c] = 4

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```
