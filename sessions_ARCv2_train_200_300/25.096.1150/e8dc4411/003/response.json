{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nTransforms the input grid by identifying a source cell, a background color, and a zero cell. \nIt determines a primary diagonal propagation direction (D1) based on the relative position of the source and zero cells.\nIt determines a secondary axis-aligned propagation direction (D2) based on D1 (using patterns observed in training data).\nStarting from the source cell, it performs a fill operation using steps D1 and D2. \nCells are colored with the source color if and only if they are within bounds and their original color in the input grid was the background color.\nThe fill expands like a breadth-first search restricted to D1 and D2 steps.\n\"\"\"\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Identifies the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assuming the background color is the most frequent one\n    if not counts:\n        raise ValueError(\"Grid is empty, cannot determine background color.\")\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:\n    \"\"\"Finds the unique cell that is not the background color and not zero.\"\"\"\n    source_candidates = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color and color != 0:\n                source_candidates.append((r, c, color))\n    \n    if len(source_candidates) == 0:\n         raise ValueError(\"No source cell found (non-background, non-zero).\")\n    if len(source_candidates) > 1:\n         # Depending on task requirements, could try to find the 'most isolated' or use the first one.\n         # For this problem, examples suggest uniqueness.\n         print(f\"Warning: Expected 1 source cell, found {len(source_candidates)}. Using the first one: {source_candidates[0]}\")\n\n    return source_candidates[0] # (row, col, color)\n\ndef find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:\n    \"\"\"Finds the location of any cell containing zero.\"\"\"\n    zero_locations = np.where(grid == 0)\n    if len(zero_locations[0]) == 0:\n         raise ValueError(\"No zero cell found.\")\n    \n    # Return the coordinates of the first zero cell found (numpy returns row indices then col indices)\n    return int(zero_locations[0][0]), int(zero_locations[1][0]) # (row, col)\n\ndef determine_d2(ddr: int, ddc: int) -> tuple[int, int]:\n    \"\"\"\n    Determines the secondary, axis-aligned propagation direction (D2)\n    based on the primary diagonal direction D1 = (ddr, ddc).\n    This rule is derived from observed patterns in the training examples.\n    \"\"\"\n    if (ddr, ddc) == (1, -1): return (1, 0) # Train 1: Down-Left -> D2 is Down\n    if (ddr, ddc) == (1, 1): return (1, 0)  # Train 2: Down-Right -> D2 is Down\n    if (ddr, ddc) == (-1, 1): return (0, 1) # Train 3: Up-Right -> D2 is Right\n    \n    # Fallback/Default for unseen D1 combinations - this is a guess\n    print(f\"Warning: Unseen D1 ({ddr},{ddc}). Defaulting D2 to ({abs(ddr)}, 0) if ddr!=0 else (0, {abs(ddc)}).\")\n    if ddr != 0:\n        return (abs(ddr), 0)\n    elif ddc != 0:\n         return (0, abs(ddc))\n    else:\n        # Should not happen if source != zero and sign handled correctly\n        return (1,0) # Arbitrary fallback\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the parallelogram fill transformation.\n\n    Args:\n        input_grid_list: A 2D list representing the input grid.\n\n    Returns:\n        A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert to numpy array for easier processing\n    grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    if rows == 0 or cols == 0:\n        return [] # Handle empty grid case\n\n    try:\n        # 1. Identify background color, source cell, and a zero cell\n        background_color = find_background_color(grid)\n        source_row, source_col, source_color = find_source_cell(grid, background_color)\n        zero_row, zero_col = find_any_zero_cell(grid)\n\n        # 2. Determine primary diagonal direction (D1)\n        # Direction is *away* from the zero cell relative to the source cell\n        dr = source_row - zero_row\n        dc = source_col - zero_col\n        \n        # np.sign returns 0 for input 0. Examples imply source and zero are not aligned.\n        # If they were, a rule would be needed. Assume non-zero based on examples.\n        ddr = np.sign(dr) \n        ddc = np.sign(dc)\n        \n        if ddr == 0 or ddc == 0:\n             # This case is not covered by examples. The logic assumes diagonal D1.\n             print(f\"Warning: Calculated D1 ({ddr},{ddc}) is not strictly diagonal. Results might be unexpected.\")\n             # Simple recovery: if vertical, make slightly diagonal; if horizontal, make slightly diagonal.\n             # Or just proceed, the BFS might handle it. Let's proceed for now.\n             pass\n\n        d1 = (int(ddr), int(ddc))\n\n        # 3. Determine secondary axis-aligned direction (D2) based on D1\n        d2 = determine_d2(d1[0], d1[1])\n\n        # 4. Fill shape using BFS-like approach restricted by D1, D2\n        # Queue stores cells to visit: (row, col)\n        queue = deque()\n        # Visited set stores cells already added to queue or processed\n        visited = set()\n\n        # Start the process from the source cell. The source cell itself is never recolored.\n        # Add its valid neighbors to the queue if they should be colored.\n        visited.add((source_row, source_col))\n\n        # Check initial steps from source\n        for step_dr, step_dc in [d1, d2]:\n            nr, nc = source_row + step_dr, source_col + step_dc\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                # Check ORIGINAL grid color\n                if grid[nr, nc] == background_color:\n                    output_grid[nr, nc] = source_color\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n                else:\n                    # Even if not background, mark as visited so we don't try this path again from source\n                    visited.add((nr, nc)) \n\n\n        # Continue BFS from the initially colored neighbors\n        while queue:\n            cr, cc = queue.popleft()\n\n            # Explore neighbors using D1 and D2 steps from the current cell\n            for step_dr, step_dc in [d1, d2]:\n                nr, nc = cr + step_dr, cc + step_dc\n\n                # Check if the potential next cell is valid to color and explore further\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    # Check ORIGINAL grid color\n                    if grid[nr, nc] == background_color:\n                        output_grid[nr, nc] = source_color\n                        visited.add((nr, nc))\n                        queue.append((nr, nc))\n                    else:\n                        # Mark non-background cells as visited too, to avoid redundant checks,\n                        # but don't color them or add them to the queue.\n                        visited.add((nr, nc))\n\n    except ValueError as e:\n        print(f\"Error during transformation setup: {e}. Returning original grid.\")\n        # Return the original grid if key elements cannot be identified\n        return input_grid_list\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11688,
    "candidates_token_count": 4811,
    "total_token_count": 16499,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.299441,
  "retries": 1
}