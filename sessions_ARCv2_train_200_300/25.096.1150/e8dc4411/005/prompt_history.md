
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 3 1 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 1 1 1 1 1 1 1 1 1 1
3 1 3 1 1 1 1 1 1 1 1 1 1 1 1
3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 2 8 2 8 8 8 8 8 8
8 8 8 8 8 8 2 8 2 8 8 8 8 8
8 8 8 8 8 8 8 2 8 2 8 8 8 8
8 8 8 8 8 8 8 8 2 8 2 8 8 8
8 8 8 8 8 8 8 8 8 2 8 2 8 8
8 8 8 8 8 8 8 8 8 8 2 8 2 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's analyze the provided examples in the dreamer phase.

**Perception of Elements:**

1.  **Grid Structure:** The input and output are 2D grids containing single-digit integers.
2.  **Background Color:** Each grid has a predominant color acting as a background (1 in train\_1, 8 in train\_2, 4 in train\_3). This color fills most of the grid initially.
3.  **Foreground Objects:** There are distinct "objects" or patterns made of colors different from the background. These often include the color 0 and one other unique non-background color (3 in train\_1, 2 in train\_2, 8 in train\_3).
4.  **Source Cell:** In each input grid, there appears to be a single cell with a unique color (neither background nor 0). This cell seems to be the origin or "source" of the transformation.
5.  **Zero Cells:** Cells with the color 0 are present in the input near the source cell. Their position relative to the source cell seems important.
6.  **Transformation:** The core transformation involves extending a line or path of the "source" color diagonally from the source cell's initial position. The original foreground objects (including the 0s and the initial source cell) remain unchanged.
7.  **Propagation Rule:** The new cells are added iteratively. The direction of propagation (Up-Left, Up-Right, Down-Left, Down-Right) appears determined by the relative position of the source cell to the zero cells. The propagation continues until it hits the grid boundary or a cell that doesn't contain the background color.

**YAML Fact Document:**


```yaml
task_description: Propagate a source color diagonally across the background color, starting from an initial source cell. The direction of propagation is determined by the relative position of the source cell to nearby zero cells.

elements:
  - object: grid
    properties:
      - type: 2D array of integers
      - dimensions: variable (e.g., 13x15, 12x14, 12x16)
  - object: cell
    properties:
      - location: (row, column)
      - color: integer
  - object: background_color
    properties:
      - identified_by: most frequent color in the input grid
  - object: source_cell
    properties:
      - identified_by: the single cell in the input whose color is not the background color and not zero
      - color: source_color (e.g., 3, 2, 8)
      - location: (source_row, source_col)
  - object: zero_cell
    properties:
      - identified_by: cells with color 0 in the input grid
      - location: (zero_row, zero_col)

relationships:
  - type: relative_position
    between: source_cell, zero_cell
    determines: propagation_direction
    details: The sign of the vector (source_row - zero_row, source_col - zero_col) defines the step vector (ddr, ddc) for propagation.
  - type: adjacency
    between: cells along the propagation path
    details: Each new cell is adjacent (diagonally) to the previous one.
  - type: boundary_constraint
    on: propagation_path
    details: Propagation stops if the next step is outside the grid.
  - type: color_constraint
    on: propagation_path
    details: Propagation stops if the next cell does not contain the background_color.

actions:
  - action: identify_background_color
    inputs: input_grid
    outputs: background_color
  - action: find_source_cell
    inputs: input_grid, background_color
    outputs: source_cell (location and color)
  - action: find_any_zero_cell
    inputs: input_grid
    outputs: zero_cell location (any one is sufficient)
  - action: determine_propagation_direction
    inputs: source_cell_location, zero_cell_location
    outputs: step_vector (ddr, ddc)
  - action: propagate_color
    inputs: grid, source_cell, step_vector, background_color
    outputs: modified_grid
    process: Iteratively move from the current cell by the step_vector, changing background cells to the source_color until a boundary or non-background cell is encountered.

output_generation:
  - process: Start with a copy of the input grid. Identify background, source, and zero elements. Determine propagation direction. Execute the propagate_color action. The resulting grid is the output.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the `background_color` by finding the most frequent integer value in the input grid.
3.  Find the `source_cell` by locating the unique cell whose color is neither the `background_color` nor 0. Record its color as `source_color` and its location as (`current_row`, `current_col`).
4.  Find the location (`zero_row`, `zero_col`) of any cell containing the value 0.
5.  Calculate the raw direction vector components: `dr = current_row - zero_row` and `dc = current_col - zero_col`.
6.  Determine the step vector (`ddr`, `ddc`) for propagation: `ddr` is the sign of `dr` (-1 if negative, 1 if positive or zero), and `ddc` is the sign of `dc` (-1 if negative, 1 if positive or zero).
7.  Begin a loop:
    a.  Calculate the coordinates of the next cell in the propagation path: `next_row = current_row + ddr`, `next_col = current_col + ddc`.
    b.  Check if (`next_row`, `next_col`) is within the bounds of the grid. If not, terminate the loop.
    c.  Check the color of the cell at (`next_row`, `next_col`) in the current state of the output grid. If the color is not the `background_color`, terminate the loop.
    d.  If the checks in (b) and (c) pass, change the color of the cell at (`next_row`, `next_col`) in the output grid to `source_color`.
    e.  Update the current position for the next iteration: `current_row = next_row`, `current_col = next_col`.
    f.  Repeat the loop.
8.  Return the final state of the output grid.
```python
import numpy as np
from collections import Counter

"""
Propagates a source color diagonally across the background color, starting from an initial source cell. 
The direction of propagation is determined by the relative position of the source cell to a reference zero cell. 
The propagation continues until it hits the grid boundary or a non-background cell.
"""

def find_background_color(grid: np.ndarray) -> int:
    """Identifies the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Assuming the background color is the most frequent one
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:
    """Finds the unique cell that is not the background color and not zero."""
    source_candidates = []
    for r in range(grid.shape[0]):
        for c in range(grid.shape[1]):
            color = grid[r, c]
            if color != background_color and color != 0:
                source_candidates.append((r, c, color))
    
    if len(source_candidates) != 1:
        # This case should ideally not happen based on the examples
        # If it does, we might need a different way to identify the source
        # For now, let's assume there's always exactly one.
        print(f"Warning: Expected 1 source cell, found {len(source_candidates)}")
        if not source_candidates:
             raise ValueError("No source cell found.") # Or handle appropriately

    return source_candidates[0] # (row, col, color)

def find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:
    """Finds the location of any cell containing zero."""
    zero_locations = np.where(grid == 0)
    if len(zero_locations[0]) == 0:
        # This case should also not happen based on examples
         raise ValueError("No zero cell found.") # Or handle appropriately
    
    # Return the coordinates of the first zero cell found
    return zero_locations[0][0], zero_locations[1][0] # (row, col)


def transform(input_grid: list[list[int]]) -> list[list[int]]:  
    """
    Applies the diagonal color propagation transformation.

    Args:
        input_grid: A 2D list representing the input grid.

    Returns:
        A 2D list representing the transformed output grid.
    """
    # Convert to numpy array for easier processing
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    # 1. Identify background color
    background_color = find_background_color(grid)

    # 2. Find the source cell (location and color)
    try:
        source_row, source_col, source_color = find_source_cell(grid, background_color)
    except ValueError as e:
        print(f"Error finding source cell: {e}")
        # Return input grid if source cannot be determined based on rules
        return input_grid 

    # 3. Find a reference zero cell location
    try:
        zero_row, zero_col = find_any_zero_cell(grid)
    except ValueError as e:
        print(f"Error finding zero cell: {e}")
        # Return input grid if zero cell cannot be found (needed for direction)
        return input_grid

    # 4. Determine the propagation direction vector (ddr, ddc)
    # The direction is away from the zero cell
    dr = source_row - zero_row
    dc = source_col - zero_col
    
    # Use np.sign: sign(+)=1, sign(-)=-1, sign(0)=0
    # Based on examples, propagation seems strictly diagonal, 
    # implying dr and dc are non-zero in practice for valid inputs.
    ddr = np.sign(dr) 
    ddc = np.sign(dc)

    # If either ddr or ddc is 0, it means source and zero are aligned horizontally/vertically.
    # The examples show diagonal propagation. If this happens, the rule might be incomplete.
    # For now, we proceed assuming diagonal. If ddr or ddc is 0, propagation might stop early or behave unexpectedly.
    if ddr == 0 or ddc == 0:
        print(f"Warning: Propagation direction ({ddr}, {ddc}) is not diagonal. Source=({source_row},{source_col}), Zero=({zero_row},{zero_col}).")
        # Depending on desired behavior, we might return input or adjust direction.
        # For now, let's proceed, it might just stop immediately if the next cell isn't background.

    # 5. Propagate the source color diagonally
    current_row, current_col = source_row, source_col
    while True:
        # Calculate the next cell's position
        next_row = current_row + ddr
        next_col = current_col + ddc

        # Check boundaries
        if not (0 <= next_row < rows and 0 <= next_col < cols):
            break # Stop if outside grid

        # Check if the next cell has the background color
        if output_grid[next_row, next_col] != background_color:
            break # Stop if blocked by non-background color

        # If valid, change the color and update current position
        output_grid[next_row, next_col] = source_color
        current_row = next_row
        current_col = next_col

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
```python
import numpy as np
from collections import Counter, deque

"""
Transforms the input grid by identifying a source cell, a background color, and a zero cell. 
It determines a primary diagonal propagation direction (D1) based on the relative position of the source and zero cells.
It determines a secondary axis-aligned propagation direction (D2) based on D1 (using patterns observed in training data).
Starting from the source cell, it performs a fill operation using steps D1 and D2. 
Cells are colored with the source color if and only if they are within bounds and their original color in the input grid was the background color.
The fill expands like a breadth-first search restricted to D1 and D2 steps.
"""

def find_background_color(grid: np.ndarray) -> int:
    """Identifies the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Assuming the background color is the most frequent one
    if not counts:
        raise ValueError("Grid is empty, cannot determine background color.")
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:
    """Finds the unique cell that is not the background color and not zero."""
    source_candidates = []
    for r in range(grid.shape[0]):
        for c in range(grid.shape[1]):
            color = grid[r, c]
            if color != background_color and color != 0:
                source_candidates.append((r, c, color))
    
    if len(source_candidates) == 0:
         raise ValueError("No source cell found (non-background, non-zero).")
    if len(source_candidates) > 1:
         # Depending on task requirements, could try to find the 'most isolated' or use the first one.
         # For this problem, examples suggest uniqueness.
         print(f"Warning: Expected 1 source cell, found {len(source_candidates)}. Using the first one: {source_candidates[0]}")

    return source_candidates[0] # (row, col, color)

def find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:
    """Finds the location of any cell containing zero."""
    zero_locations = np.where(grid == 0)
    if len(zero_locations[0]) == 0:
         raise ValueError("No zero cell found.")
    
    # Return the coordinates of the first zero cell found (numpy returns row indices then col indices)
    return int(zero_locations[0][0]), int(zero_locations[1][0]) # (row, col)

def determine_d2(ddr: int, ddc: int) -> tuple[int, int]:
    """
    Determines the secondary, axis-aligned propagation direction (D2)
    based on the primary diagonal direction D1 = (ddr, ddc).
    This rule is derived from observed patterns in the training examples.
    """
    if (ddr, ddc) == (1, -1): return (1, 0) # Train 1: Down-Left -> D2 is Down
    if (ddr, ddc) == (1, 1): return (1, 0)  # Train 2: Down-Right -> D2 is Down
    if (ddr, ddc) == (-1, 1): return (0, 1) # Train 3: Up-Right -> D2 is Right
    
    # Fallback/Default for unseen D1 combinations - this is a guess
    print(f"Warning: Unseen D1 ({ddr},{ddc}). Defaulting D2 to ({abs(ddr)}, 0) if ddr!=0 else (0, {abs(ddc)}).")
    if ddr != 0:
        return (abs(ddr), 0)
    elif ddc != 0:
         return (0, abs(ddc))
    else:
        # Should not happen if source != zero and sign handled correctly
        return (1,0) # Arbitrary fallback


def transform(input_grid_list: list[list[int]]) -> list[list[int]]:
    """
    Applies the parallelogram fill transformation.

    Args:
        input_grid_list: A 2D list representing the input grid.

    Returns:
        A 2D list representing the transformed output grid.
    """
    # Convert to numpy array for easier processing
    grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    if rows == 0 or cols == 0:
        return [] # Handle empty grid case

    try:
        # 1. Identify background color, source cell, and a zero cell
        background_color = find_background_color(grid)
        source_row, source_col, source_color = find_source_cell(grid, background_color)
        zero_row, zero_col = find_any_zero_cell(grid)

        # 2. Determine primary diagonal direction (D1)
        # Direction is *away* from the zero cell relative to the source cell
        dr = source_row - zero_row
        dc = source_col - zero_col
        
        # np.sign returns 0 for input 0. Examples imply source and zero are not aligned.
        # If they were, a rule would be needed. Assume non-zero based on examples.
        ddr = np.sign(dr) 
        ddc = np.sign(dc)
        
        if ddr == 0 or ddc == 0:
             # This case is not covered by examples. The logic assumes diagonal D1.
             print(f"Warning: Calculated D1 ({ddr},{ddc}) is not strictly diagonal. Results might be unexpected.")
             # Simple recovery: if vertical, make slightly diagonal; if horizontal, make slightly diagonal.
             # Or just proceed, the BFS might handle it. Let's proceed for now.
             pass

        d1 = (int(ddr), int(ddc))

        # 3. Determine secondary axis-aligned direction (D2) based on D1
        d2 = determine_d2(d1[0], d1[1])

        # 4. Fill shape using BFS-like approach restricted by D1, D2
        # Queue stores cells to visit: (row, col)
        queue = deque()
        # Visited set stores cells already added to queue or processed
        visited = set()

        # Start the process from the source cell. The source cell itself is never recolored.
        # Add its valid neighbors to the queue if they should be colored.
        visited.add((source_row, source_col))

        # Check initial steps from source
        for step_dr, step_dc in [d1, d2]:
            nr, nc = source_row + step_dr, source_col + step_dc
            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:
                # Check ORIGINAL grid color
                if grid[nr, nc] == background_color:
                    output_grid[nr, nc] = source_color
                    visited.add((nr, nc))
                    queue.append((nr, nc))
                else:
                    # Even if not background, mark as visited so we don't try this path again from source
                    visited.add((nr, nc)) 


        # Continue BFS from the initially colored neighbors
        while queue:
            cr, cc = queue.popleft()

            # Explore neighbors using D1 and D2 steps from the current cell
            for step_dr, step_dc in [d1, d2]:
                nr, nc = cr + step_dr, cc + step_dc

                # Check if the potential next cell is valid to color and explore further
                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:
                    # Check ORIGINAL grid color
                    if grid[nr, nc] == background_color:
                        output_grid[nr, nc] = source_color
                        visited.add((nr, nc))
                        queue.append((nr, nc))
                    else:
                        # Mark non-background cells as visited too, to avoid redundant checks,
                        # but don't color them or add them to the queue.
                        visited.add((nr, nc))

    except ValueError as e:
        print(f"Error during transformation setup: {e}. Returning original grid.")
        # Return the original grid if key elements cannot be identified
        return input_grid_list

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter, deque

"""
Transforms the input grid by identifying a source cell, a background color, and a zero cell. 
It determines a primary diagonal propagation direction (D1) based on the relative position of the source and zero cells.
It determines a secondary axis-aligned propagation direction (D2) based on D1 (using patterns observed in training data).
Starting from the source cell, it performs a fill operation using steps D1 and D2. 
Cells are colored with the source color if and only if they are within bounds and their original color in the input grid was the background color.
The fill expands like a breadth-first search restricted to D1 and D2 steps.
"""

def find_background_color(grid: np.ndarray) -> int:
    """Identifies the most frequent color in the grid, assumed to be the background."""
    counts = Counter(grid.flatten())
    # Assuming the background color is the most frequent one
    if not counts:
        raise ValueError("Grid is empty, cannot determine background color.")
    background_color = counts.most_common(1)[0][0]
    return background_color

def find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:
    """Finds the unique cell that is not the background color and not zero."""
    source_candidates = []
    for r in range(grid.shape[0]):
        for c in range(grid.shape[1]):
            color = grid[r, c]
            if color != background_color and color != 0:
                source_candidates.append((r, c, color))
    
    if len(source_candidates) == 0:
         raise ValueError("No source cell found (non-background, non-zero).")
    if len(source_candidates) > 1:
         # Depending on task requirements, could try to find the 'most isolated' or use the first one.
         # For this problem, examples suggest uniqueness.
         print(f"Warning: Expected 1 source cell, found {len(source_candidates)}. Using the first one: {source_candidates[0]}")

    return source_candidates[0] # (row, col, color)

def find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:
    """Finds the location of any cell containing zero."""
    zero_locations = np.where(grid == 0)
    if len(zero_locations[0]) == 0:
         raise ValueError("No zero cell found.")
    
    # Return the coordinates of the first zero cell found (numpy returns row indices then col indices)
    return int(zero_locations[0][0]), int(zero_locations[1][0]) # (row, col)

def determine_d2(ddr: int, ddc: int) -> tuple[int, int]:
    """
    Determines the secondary, axis-aligned propagation direction (D2)
    based on the primary diagonal direction D1 = (ddr, ddc).
    This rule is derived from observed patterns in the training examples.
    """
    if (ddr, ddc) == (1, -1): return (1, 0) # Train 1: Down-Left -> D2 is Down
    if (ddr, ddc) == (1, 1): return (1, 0)  # Train 2: Down-Right -> D2 is Down
    if (ddr, ddc) == (-1, 1): return (0, 1) # Train 3: Up-Right -> D2 is Right
    
    # Fallback/Default for unseen D1 combinations - this is a guess
    print(f"Warning: Unseen D1 ({ddr},{ddc}). Defaulting D2 to ({abs(ddr)}, 0) if ddr!=0 else (0, {abs(ddc)}).")
    if ddr != 0:
        return (abs(ddr), 0)
    elif ddc != 0:
         return (0, abs(ddc))
    else:
        # Should not happen if source != zero and sign handled correctly
        return (1,0) # Arbitrary fallback


def transform(input_grid_list: list[list[int]]) -> list[list[int]]:
    """
    Applies the parallelogram fill transformation.

    Args:
        input_grid_list: A 2D list representing the input grid.

    Returns:
        A 2D list representing the transformed output grid.
    """
    # Convert to numpy array for easier processing
    grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(grid)
    rows, cols = grid.shape

    if rows == 0 or cols == 0:
        return [] # Handle empty grid case

    try:
        # 1. Identify background color, source cell, and a zero cell
        background_color = find_background_color(grid)
        source_row, source_col, source_color = find_source_cell(grid, background_color)
        zero_row, zero_col = find_any_zero_cell(grid)

        # 2. Determine primary diagonal direction (D1)
        # Direction is *away* from the zero cell relative to the source cell
        dr = source_row - zero_row
        dc = source_col - zero_col
        
        # np.sign returns 0 for input 0. Examples imply source and zero are not aligned.
        # If they were, a rule would be needed. Assume non-zero based on examples.
        ddr = np.sign(dr) 
        ddc = np.sign(dc)
        
        if ddr == 0 or ddc == 0:
             # This case is not covered by examples. The logic assumes diagonal D1.
             print(f"Warning: Calculated D1 ({ddr},{ddc}) is not strictly diagonal. Results might be unexpected.")
             # Simple recovery: if vertical, make slightly diagonal; if horizontal, make slightly diagonal.
             # Or just proceed, the BFS might handle it. Let's proceed for now.
             pass

        d1 = (int(ddr), int(ddc))

        # 3. Determine secondary axis-aligned direction (D2) based on D1
        d2 = determine_d2(d1[0], d1[1])

        # 4. Fill shape using BFS-like approach restricted by D1, D2
        # Queue stores cells to visit: (row, col)
        queue = deque()
        # Visited set stores cells already added to queue or processed
        visited = set()

        # Start the process from the source cell. The source cell itself is never recolored.
        # Add its valid neighbors to the queue if they should be colored.
        visited.add((source_row, source_col))

        # Check initial steps from source
        for step_dr, step_dc in [d1, d2]:
            nr, nc = source_row + step_dr, source_col + step_dc
            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:
                # Check ORIGINAL grid color
                if grid[nr, nc] == background_color:
                    output_grid[nr, nc] = source_color
                    visited.add((nr, nc))
                    queue.append((nr, nc))
                else:
                    # Even if not background, mark as visited so we don't try this path again from source
                    visited.add((nr, nc)) 


        # Continue BFS from the initially colored neighbors
        while queue:
            cr, cc = queue.popleft()

            # Explore neighbors using D1 and D2 steps from the current cell
            for step_dr, step_dc in [d1, d2]:
                nr, nc = cr + step_dr, cc + step_dc

                # Check if the potential next cell is valid to color and explore further
                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:
                    # Check ORIGINAL grid color
                    if grid[nr, nc] == background_color:
                        output_grid[nr, nc] = source_color
                        visited.add((nr, nc))
                        queue.append((nr, nc))
                    else:
                        # Mark non-background cells as visited too, to avoid redundant checks,
                        # but don't color them or add them to the queue.
                        visited.add((nr, nc))

    except ValueError as e:
        print(f"Error during transformation setup: {e}. Returning original grid.")
        # Return the original grid if key elements cannot be identified
        return input_grid_list

    # Convert back to list of lists for the required output format
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Expected Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 3 1 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 1 1 1 1 1 1 1 1 1 1
3 1 3 1 1 1 1 1 1 1 1 1 1 1 1
3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
```
Transformed Output:
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 1 1 1 1 1 1 1 1 1 1
1 1 3 3 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 3 1 1 1 1 1 1 1 1 1 1
3 3 3 3 3 1 1 1 1 1 1 1 1 1 1
3 3 3 3 3 1 1 1 1 1 1 1 1 1 1
```
Match: False
Pixels Off: 9
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 9.230769230769226

## Example 2:
Input:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```
Expected Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 2 8 2 8 8 8 8 8 8
8 8 8 8 8 8 2 8 2 8 8 8 8 8
8 8 8 8 8 8 8 2 8 2 8 8 8 8
8 8 8 8 8 8 8 8 2 8 2 8 8 8
8 8 8 8 8 8 8 8 8 2 8 2 8 8
8 8 8 8 8 8 8 8 8 8 2 8 2 8
```
Transformed Output:
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 2 2 8 8 8 8 8 8
8 8 8 8 8 8 2 2 2 8 8 8 8 8
8 8 8 8 8 8 2 2 2 2 8 8 8 8
8 8 8 8 8 8 2 2 2 2 2 8 8 8
8 8 8 8 8 8 2 2 2 2 2 2 8 8
8 8 8 8 8 8 2 2 2 2 2 2 2 8
```
Match: False
Pixels Off: 17
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 20.23809523809524

## Example 3:
Input:
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Expected Output:
```
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Transformed Output:
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8
4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8
4 4 4 4 4 4 4 4 4 4 4 4 8 8 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 8 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```
Match: False
Pixels Off: 10
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 10.416666666666686
## Assessment and Strategy

**General Assessment:**

The initial hypothesis of simple diagonal line propagation was incorrect. The comparison between the expected and transformed outputs reveals that the transformation involves filling a 2D area, not just a line. The shape appears to be related to two directions originating from the `source_cell`. The first direction (`D1`) is still determined by the relative position of the `source_cell` and a `zero_cell` (diagonal). The second direction (`D2`) seems to be axis-aligned (horizontal or vertical) and dependent on the primary diagonal direction `D1`. The fill process colors only the cells that originally contained the `background_color`.

**Strategy:**

1.  **Verify Key Elements:** Confirm the identification of `background_color`, `source_cell` (location and color), and `zero_cell` location for each example.
2.  **Determine Directions:** For each example, calculate the primary diagonal direction (`D1`) from the source away from the zero cell. Observe the filled shape in the expected output to deduce the secondary, axis-aligned direction (`D2`). Formulate a general rule to derive `D2` from `D1`.
3.  **Model Fill Process:** Describe the transformation as a fill process (like BFS) starting from the source, using only steps `D1` and `D2`. Crucially, only cells that initially contained the `background_color` should be changed to the `source_color`. The original `source_cell` and `zero_cells` remain unchanged.
4.  **Update Documentation:** Revise the YAML fact document and the natural language program to reflect the two-direction fill mechanism.

## Metrics Analysis


*code_execution:*
```python
import numpy as np
from collections import Counter

def analyze_example(input_grid_list, output_grid_list):
    input_grid = np.array(input_grid_list)
    output_grid = np.array(output_grid_list)
    rows, cols = input_grid.shape

    # Find background color (most frequent)
    counts = Counter(input_grid.flatten())
    background_color = counts.most_common(1)[0][0]

    # Find source cell (non-background, non-zero)
    source_cell = None
    source_color = -1
    source_coords = (-1, -1)
    for r in range(rows):
        for c in range(cols):
            color = input_grid[r, c]
            if color != background_color and color != 0:
                source_color = color
                source_coords = (r, c)
                break
        if source_color != -1:
            break

    # Find a zero cell
    zero_coords_list = np.argwhere(input_grid == 0)
    zero_coords = tuple(zero_coords_list[0]) if len(zero_coords_list) > 0 else (-1, -1)

    # Calculate D1 (primary diagonal direction: sign vector from zero to source)
    if source_coords != (-1, -1) and zero_coords != (-1, -1):
        dr = source_coords[0] - zero_coords[0]
        dc = source_coords[1] - zero_coords[1]
        ddr = np.sign(dr)
        ddc = np.sign(dc)
        d1 = (int(ddr), int(ddc))
    else:
        d1 = (0, 0) # Indicate error or missing element

    # Infer D2 based on observed patterns and D1
    d2 = (0, 0) # Default/unknown
    if d1 == (1, -1): d2 = (1, 0)   # Example 1: Down-Left -> Down
    elif d1 == (1, 1): d2 = (1, 0)  # Example 2: Down-Right -> Down
    elif d1 == (-1, 1): d2 = (0, 1) # Example 3: Up-Right -> Right

    # Count differences between input and output
    diff_count = np.sum(input_grid != output_grid)
    # Count number of cells colored with source_color in the output, excluding the original source cell
    output_source_cells = np.sum(output_grid == source_color)
    input_source_cells = np.sum(input_grid == source_color) # Should be 1
    newly_colored_count = output_source_cells - input_source_cells


    return {
        "dimensions": (rows, cols),
        "background_color": background_color,
        "source_cell_coords": source_coords,
        "source_color": source_color,
        "zero_cell_coords (first found)": zero_coords,
        "direction_D1 (diagonal)": d1,
        "direction_D2 (axis-aligned, inferred)": d2,
        "pixels_changed": diff_count,
        "newly_colored_pixels": newly_colored_count,
    }

# --- Example 1 ---
input_1 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 3, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
output_1 = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 3, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
metrics_1 = analyze_example(input_1, output_1)

# --- Example 2 ---
input_2 = [
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 0, 8, 2, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]
]
output_2 = [
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 0, 8, 2, 8, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 2, 8, 2, 8, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 2, 8, 2, 8, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 8, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 8, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 8, 8],
    [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 2, 8]
]
metrics_2 = analyze_example(input_2, output_2)

# --- Example 3 ---
input_3 = [
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]
]
output_3 = [
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 8, 8],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 8, 8],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 8, 8],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 4, 8, 8],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]
]
metrics_3 = analyze_example(input_3, output_3)

print("--- Metrics Report ---")
print(f"Example 1:\n{metrics_1}\n")
print(f"Example 2:\n{metrics_2}\n")
print(f"Example 3:\n{metrics_3}\n")
```

*code_execution_result:*
outcome: OUTCOME_OK
```
--- Metrics Report ---
Example 1:
{'dimensions': (13, 15), 'background_color': np.int64(1), 'source_cell_coords': (7, 4), 'source_color': np.int64(3), 'zero_cell_coords (first found)': (np.int64(5), np.int64(6)), 'direction_D1 (diagonal)': (1, -1), 'direction_D2 (axis-aligned, inferred)': (1, 0), 'pixels_changed': np.int64(12), 'newly_colored_pixels': np.int64(12)}

Example 2:
{'dimensions': (12, 14), 'background_color': np.int64(8), 'source_cell_coords': (5, 6), 'source_color': np.int64(2), 'zero_cell_coords (first found)': (np.int64(3), np.int64(4)), 'direction_D1 (diagonal)': (1, 1), 'direction_D2 (axis-aligned, inferred)': (1, 0), 'pixels_changed': np.int64(12), 'newly_colored_pixels': np.int64(12)}

Example 3:
{'dimensions': (12, 16), 'background_color': np.int64(4), 'source_cell_coords': (4, 11), 'source_color': np.int64(8), 'zero_cell_coords (first found)': (np.int64(5), np.int64(6)), 'direction_D1 (diagonal)': (-1, 1), 'direction_D2 (axis-aligned, inferred)': (0, 1), 'pixels_changed': np.int64(16), 'newly_colored_pixels': np.int64(16)}


```
## YAML Fact Document


```yaml
task_description: Fill a region originating from a source cell with the source color. The fill propagates using two specific directions (one diagonal, one axis-aligned) determined by the relative position of the source cell and a zero cell. Only cells originally containing the background color are modified.

elements:
  - object: grid
    properties:
      - type: 2D array of integers
      - dimensions: variable
  - object: cell
    properties:
      - location: (row, column)
      - color: integer
  - object: background_color
    properties:
      - identified_by: most frequent color in the input grid
  - object: source_cell
    properties:
      - identified_by: the single cell in the input whose color is not the background color and not zero
      - color: source_color (e.g., 3, 2, 8)
      - location: (source_row, source_col)
  - object: zero_cell
    properties:
      - identified_by: any cell with color 0 in the input grid
      - location: (zero_row, zero_col)

relationships:
  - type: relative_position
    between: source_cell, zero_cell
    determines: primary_direction_D1 (diagonal step vector (ddr, ddc))
    details: ddr = sign(source_row - zero_row), ddc = sign(source_col - zero_col).
  - type: derivation
    from: primary_direction_D1
    determines: secondary_direction_D2 (axis-aligned step vector)
    rules:
      - if D1 is (1, -1) or (1, 1), then D2 is (1, 0)  # Down-Left/Down-Right -> Down
      - if D1 is (-1, 1), then D2 is (0, 1)           # Up-Right -> Right
      # (Hypothesized: if D1 is (-1, -1), then D2 might be (0, -1) # Up-Left -> Left)
  - type: adjacency_constraint
    on: fill_process
    details: Fill expands only via steps D1 and D2 from already filled/source cells.
  - type: boundary_constraint
    on: fill_process
    details: Fill stops at grid boundaries.
  - type: color_constraint
    on: fill_process
    details: Only cells that contained the background_color in the *input* grid can be changed to the source_color.

actions:
  - action: identify_elements
    inputs: input_grid
    outputs: background_color, source_cell (location, color), zero_cell_location
  - action: determine_propagation_directions
    inputs: source_cell_location, zero_cell_location
    outputs: direction_D1, direction_D2
  - action: perform_fill
    inputs: grid, source_cell, background_color, direction_D1, direction_D2
    outputs: modified_grid
    process: Use a fill algorithm (like BFS) starting from neighbors of the source cell reachable via D1/D2. Explore using only steps D1 and D2. Change a cell's color to source_color *only* if it's within bounds and its color in the *original* input grid was the background_color. Keep track of visited cells to avoid cycles and re-processing. The original source cell is not re-colored.

output_generation:
  - process: Start with a copy of the input grid. Identify background, source, and zero elements. Determine propagation directions D1 and D2. Execute the perform_fill action. The resulting grid is the output.
```


## Natural Language Program

1.  Initialize the `output_grid` as a copy of the `input_grid`.
2.  Identify the `background_color` by finding the most frequent integer value in the `input_grid`.
3.  Find the `source_cell` by locating the unique cell whose color is neither the `background_color` nor 0. Record its color as `source_color` and its location as (`source_row`, `source_col`).
4.  Find the location (`zero_row`, `zero_col`) of any cell containing the value 0 in the `input_grid`.
5.  Calculate the primary direction `D1 = (ddr, ddc)`: `ddr` is the sign of (`source_row - zero_row`), and `ddc` is the sign of (`source_col - zero_col`).
6.  Determine the secondary direction `D2` based on `D1`:
    *   If `D1` is (1, -1) or (1, 1), set `D2` to (1, 0).
    *   If `D1` is (-1, 1), set `D2` to (0, 1).
    *   (If other `D1` values occur, apply hypothesized or default rules, e.g., for (-1,-1) use (0,-1)).
7.  Initialize a queue for a Breadth-First Search (BFS) fill process and a set `visited` to store coordinates of cells already processed or added to the queue. Add (`source_row`, `source_col`) to `visited`.
8.  Check the cells reachable from the `source_cell` using one step of `D1` and one step of `D2`:
    *   For each direction (`dr`, `dc`) in {`D1`, `D2`}:
        *   Calculate the neighbor coordinates `nr = source_row + dr`, `nc = source_col + dc`.
        *   If (`nr`, `nc`) is within the grid boundaries and (`nr`, `nc`) is not in `visited`:
            *   If the color of the cell (`nr`, `nc`) in the *original* `input_grid` is the `background_color`:
                *   Change the color of cell (`nr`, `nc`) in the `output_grid` to `source_color`.
                *   Add (`nr`, `nc`) to the `visited` set.
                *   Add (`nr`, `nc`) to the `queue`.
            *   Else (neighbor is not background or out of bounds):
                *   Add (`nr`, `nc`) to `visited` (to prevent revisiting from other paths).
9.  While the `queue` is not empty:
    *   Dequeue a cell coordinate (`cr`, `cc`).
    *   For each direction (`dr`, `dc`) in {`D1`, `D2`}:
        *   Calculate the neighbor coordinates `nr = cr + dr`, `nc = cc + dc`.
        *   If (`nr`, `nc`) is within the grid boundaries and (`nr`, `nc`) is not in `visited`:
            *   If the color of the cell (`nr`, `nc`) in the *original* `input_grid` is the `background_color`:
                *   Change the color of cell (`nr`, `nc`) in the `output_grid` to `source_color`.
                *   Add (`nr`, `nc`) to the `visited` set.
                *   Add (`nr`, `nc`) to the `queue`.
            *   Else (neighbor is not background or out of bounds):
                 *   Add (`nr`, `nc`) to `visited`.
10. Return the final `output_grid`.
