
## train_1

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 0 0 0 1 1 1 1 1 1 1
1 1 1 1 3 1 0 1 1 1 1 1 1 1 1
1 1 1 3 3 3 1 1 1 1 1 1 1 1 1
1 1 3 1 3 1 1 1 1 1 1 1 1 1 1
1 3 3 3 1 1 1 1 1 1 1 1 1 1 1
3 1 3 1 1 1 1 1 1 1 1 1 1 1 1
3 3 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_2

**input:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
```


**output:**
```
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 8 8 8 8 8 8 8
8 8 8 8 0 8 8 8 8 8 8 8 8 8
8 8 8 0 8 0 8 8 8 8 8 8 8 8
8 8 8 8 0 8 2 8 8 8 8 8 8 8
8 8 8 8 8 2 8 2 8 8 8 8 8 8
8 8 8 8 8 8 2 8 2 8 8 8 8 8
8 8 8 8 8 8 8 2 8 2 8 8 8 8
8 8 8 8 8 8 8 8 2 8 2 8 8 8
8 8 8 8 8 8 8 8 8 2 8 2 8 8
8 8 8 8 8 8 8 8 8 8 2 8 2 8
```


## train_3

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 4 4 8 4 4
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 4 4 4 4 4 8 8 4 8 8
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 0 4 4 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 0 0 4 0 0 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's analyze the provided examples in the dreamer phase.

**Perception of Elements:**

1.  **Grid Structure:** The input and output are 2D grids containing single-digit integers.
2.  **Background Color:** Each grid has a predominant color acting as a background (1 in train\_1, 8 in train\_2, 4 in train\_3). This color fills most of the grid initially.
3.  **Foreground Objects:** There are distinct "objects" or patterns made of colors different from the background. These often include the color 0 and one other unique non-background color (3 in train\_1, 2 in train\_2, 8 in train\_3).
4.  **Source Cell:** In each input grid, there appears to be a single cell with a unique color (neither background nor 0). This cell seems to be the origin or "source" of the transformation.
5.  **Zero Cells:** Cells with the color 0 are present in the input near the source cell. Their position relative to the source cell seems important.
6.  **Transformation:** The core transformation involves extending a line or path of the "source" color diagonally from the source cell's initial position. The original foreground objects (including the 0s and the initial source cell) remain unchanged.
7.  **Propagation Rule:** The new cells are added iteratively. The direction of propagation (Up-Left, Up-Right, Down-Left, Down-Right) appears determined by the relative position of the source cell to the zero cells. The propagation continues until it hits the grid boundary or a cell that doesn't contain the background color.

**YAML Fact Document:**


```yaml
task_description: Propagate a source color diagonally across the background color, starting from an initial source cell. The direction of propagation is determined by the relative position of the source cell to nearby zero cells.

elements:
  - object: grid
    properties:
      - type: 2D array of integers
      - dimensions: variable (e.g., 13x15, 12x14, 12x16)
  - object: cell
    properties:
      - location: (row, column)
      - color: integer
  - object: background_color
    properties:
      - identified_by: most frequent color in the input grid
  - object: source_cell
    properties:
      - identified_by: the single cell in the input whose color is not the background color and not zero
      - color: source_color (e.g., 3, 2, 8)
      - location: (source_row, source_col)
  - object: zero_cell
    properties:
      - identified_by: cells with color 0 in the input grid
      - location: (zero_row, zero_col)

relationships:
  - type: relative_position
    between: source_cell, zero_cell
    determines: propagation_direction
    details: The sign of the vector (source_row - zero_row, source_col - zero_col) defines the step vector (ddr, ddc) for propagation.
  - type: adjacency
    between: cells along the propagation path
    details: Each new cell is adjacent (diagonally) to the previous one.
  - type: boundary_constraint
    on: propagation_path
    details: Propagation stops if the next step is outside the grid.
  - type: color_constraint
    on: propagation_path
    details: Propagation stops if the next cell does not contain the background_color.

actions:
  - action: identify_background_color
    inputs: input_grid
    outputs: background_color
  - action: find_source_cell
    inputs: input_grid, background_color
    outputs: source_cell (location and color)
  - action: find_any_zero_cell
    inputs: input_grid
    outputs: zero_cell location (any one is sufficient)
  - action: determine_propagation_direction
    inputs: source_cell_location, zero_cell_location
    outputs: step_vector (ddr, ddc)
  - action: propagate_color
    inputs: grid, source_cell, step_vector, background_color
    outputs: modified_grid
    process: Iteratively move from the current cell by the step_vector, changing background cells to the source_color until a boundary or non-background cell is encountered.

output_generation:
  - process: Start with a copy of the input grid. Identify background, source, and zero elements. Determine propagation direction. Execute the propagate_color action. The resulting grid is the output.
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the `background_color` by finding the most frequent integer value in the input grid.
3.  Find the `source_cell` by locating the unique cell whose color is neither the `background_color` nor 0. Record its color as `source_color` and its location as (`current_row`, `current_col`).
4.  Find the location (`zero_row`, `zero_col`) of any cell containing the value 0.
5.  Calculate the raw direction vector components: `dr = current_row - zero_row` and `dc = current_col - zero_col`.
6.  Determine the step vector (`ddr`, `ddc`) for propagation: `ddr` is the sign of `dr` (-1 if negative, 1 if positive or zero), and `ddc` is the sign of `dc` (-1 if negative, 1 if positive or zero).
7.  Begin a loop:
    a.  Calculate the coordinates of the next cell in the propagation path: `next_row = current_row + ddr`, `next_col = current_col + ddc`.
    b.  Check if (`next_row`, `next_col`) is within the bounds of the grid. If not, terminate the loop.
    c.  Check the color of the cell at (`next_row`, `next_col`) in the current state of the output grid. If the color is not the `background_color`, terminate the loop.
    d.  If the checks in (b) and (c) pass, change the color of the cell at (`next_row`, `next_col`) in the output grid to `source_color`.
    e.  Update the current position for the next iteration: `current_row = next_row`, `current_col = next_col`.
    f.  Repeat the loop.
8.  Return the final state of the output grid.
