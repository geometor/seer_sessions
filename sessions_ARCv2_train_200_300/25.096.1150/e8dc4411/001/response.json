{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nPropagates a source color diagonally across the background color, starting from an initial source cell. \nThe direction of propagation is determined by the relative position of the source cell to a reference zero cell. \nThe propagation continues until it hits the grid boundary or a non-background cell.\n\"\"\"\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Identifies the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    # Assuming the background color is the most frequent one\n    background_color = counts.most_common(1)[0][0]\n    return background_color\n\ndef find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:\n    \"\"\"Finds the unique cell that is not the background color and not zero.\"\"\"\n    source_candidates = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color and color != 0:\n                source_candidates.append((r, c, color))\n    \n    if len(source_candidates) != 1:\n        # This case should ideally not happen based on the examples\n        # If it does, we might need a different way to identify the source\n        # For now, let's assume there's always exactly one.\n        print(f\"Warning: Expected 1 source cell, found {len(source_candidates)}\")\n        if not source_candidates:\n             raise ValueError(\"No source cell found.\") # Or handle appropriately\n\n    return source_candidates[0] # (row, col, color)\n\ndef find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:\n    \"\"\"Finds the location of any cell containing zero.\"\"\"\n    zero_locations = np.where(grid == 0)\n    if len(zero_locations[0]) == 0:\n        # This case should also not happen based on examples\n         raise ValueError(\"No zero cell found.\") # Or handle appropriately\n    \n    # Return the coordinates of the first zero cell found\n    return zero_locations[0][0], zero_locations[1][0] # (row, col)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the diagonal color propagation transformation.\n\n    Args:\n        input_grid: A 2D list representing the input grid.\n\n    Returns:\n        A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify background color\n    background_color = find_background_color(grid)\n\n    # 2. Find the source cell (location and color)\n    try:\n        source_row, source_col, source_color = find_source_cell(grid, background_color)\n    except ValueError as e:\n        print(f\"Error finding source cell: {e}\")\n        # Return input grid if source cannot be determined based on rules\n        return input_grid \n\n    # 3. Find a reference zero cell location\n    try:\n        zero_row, zero_col = find_any_zero_cell(grid)\n    except ValueError as e:\n        print(f\"Error finding zero cell: {e}\")\n        # Return input grid if zero cell cannot be found (needed for direction)\n        return input_grid\n\n    # 4. Determine the propagation direction vector (ddr, ddc)\n    # The direction is away from the zero cell\n    dr = source_row - zero_row\n    dc = source_col - zero_col\n    \n    # Use np.sign: sign(+)=1, sign(-)=-1, sign(0)=0\n    # Based on examples, propagation seems strictly diagonal, \n    # implying dr and dc are non-zero in practice for valid inputs.\n    ddr = np.sign(dr) \n    ddc = np.sign(dc)\n\n    # If either ddr or ddc is 0, it means source and zero are aligned horizontally/vertically.\n    # The examples show diagonal propagation. If this happens, the rule might be incomplete.\n    # For now, we proceed assuming diagonal. If ddr or ddc is 0, propagation might stop early or behave unexpectedly.\n    if ddr == 0 or ddc == 0:\n        print(f\"Warning: Propagation direction ({ddr}, {ddc}) is not diagonal. Source=({source_row},{source_col}), Zero=({zero_row},{zero_col}).\")\n        # Depending on desired behavior, we might return input or adjust direction.\n        # For now, let's proceed, it might just stop immediately if the next cell isn't background.\n\n    # 5. Propagate the source color diagonally\n    current_row, current_col = source_row, source_col\n    while True:\n        # Calculate the next cell's position\n        next_row = current_row + ddr\n        next_col = current_col + ddc\n\n        # Check boundaries\n        if not (0 <= next_row < rows and 0 <= next_col < cols):\n            break # Stop if outside grid\n\n        # Check if the next cell has the background color\n        if output_grid[next_row, next_col] != background_color:\n            break # Stop if blocked by non-background color\n\n        # If valid, change the color and update current position\n        output_grid[next_row, next_col] = source_color\n        current_row = next_row\n        current_col = next_col\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4166,
    "candidates_token_count": 2996,
    "total_token_count": 7162,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.133106,
  "retries": 1
}