{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid by identifying a source cell, a background color, and a reference zero cell. \nTwo directions are determined: a primary diagonal direction (D1) away from the zero cell, and a secondary axis-aligned direction (D2') derived from D1. \nTwo rays are drawn starting from the source cell, one in direction D1 and one in direction D2'. \nA ray colors cells with the source color only if the cell is within bounds and its color in the *original* input grid was the background color. \nThe ray stops extending if it hits the grid boundary or a non-background cell. The original grid content (source, zeros, etc.) remains otherwise unchanged.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Identifies the most frequent color in the grid, assumed to be the background.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        raise ValueError(\"Grid is empty, cannot determine background color.\")\n    # Ensure the background color is returned as a standard Python int\n    background_color = int(counts.most_common(1)[0][0])\n    return background_color\n\ndef find_source_cell(grid: np.ndarray, background_color: int) -> tuple[int, int, int]:\n    \"\"\"Finds the unique cell that is not the background color and not zero.\"\"\"\n    source_candidates = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            color = grid[r, c]\n            if color != background_color and color != 0:\n                # Store row, col, and color as standard Python ints\n                source_candidates.append((r, c, int(color)))\n    \n    if len(source_candidates) == 0:\n         raise ValueError(\"No source cell found (non-background, non-zero).\")\n    if len(source_candidates) > 1:\n         # Based on examples, uniqueness is expected. If not unique, use the first found.\n         print(f\"Warning: Expected 1 source cell, found {len(source_candidates)}. Using the first one: {source_candidates[0]}\")\n\n    return source_candidates[0] # (row, col, color)\n\ndef find_any_zero_cell(grid: np.ndarray) -> tuple[int, int]:\n    \"\"\"Finds the location of any cell containing zero.\"\"\"\n    zero_locations = np.where(grid == 0)\n    if len(zero_locations[0]) == 0:\n         raise ValueError(\"No zero cell found.\")\n    \n    # Return the coordinates of the first zero cell found as standard Python ints\n    return int(zero_locations[0][0]), int(zero_locations[1][0]) # (row, col)\n\ndef draw_ray(input_grid: np.ndarray, output_grid: np.ndarray, \n             start_r: int, start_c: int, dr: int, dc: int, \n             source_color: int, background_color: int):\n    \"\"\"Draws a ray from the start position in the given direction.\"\"\"\n    rows, cols = input_grid.shape\n    current_r, current_c = start_r, start_c\n    \n    while True:\n        # Calculate next position\n        next_r = current_r + dr\n        next_c = current_c + dc\n        \n        # Check boundaries\n        if not (0 <= next_r < rows and 0 <= next_c < cols):\n            break # Stop if out of bounds\n            \n        # Check color condition in the *original* grid\n        if input_grid[next_r, next_c] != background_color:\n            break # Stop if not background color\n            \n        # Draw on the output grid\n        output_grid[next_r, next_c] = source_color\n        \n        # Update current position for the next step\n        current_r, current_c = next_r, next_c\n\n\n# === Main Transformation Function ===\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the two-ray drawing transformation based on source, zero, and background cells.\n    \"\"\"\n    # Convert input list to numpy array for efficient operations\n    input_grid = np.array(input_grid_list, dtype=int)\n    \n    # Handle empty grid edge case\n    if input_grid.size == 0:\n        return [] \n        \n    rows, cols = input_grid.shape\n    \n    # Create a copy of the input grid to modify for the output\n    output_grid = np.copy(input_grid)\n\n    try:\n        # 1. Identify key elements\n        background_color = find_background_color(input_grid)\n        source_row, source_col, source_color = find_source_cell(input_grid, background_color)\n        zero_row, zero_col = find_any_zero_cell(input_grid)\n\n        # 2. Determine primary diagonal direction (D1)\n        # Vector points away from zero relative to source\n        delta_r = source_row - zero_row\n        delta_c = source_col - zero_col\n        d1_dr = int(np.sign(delta_r)) # Primary row step\n        d1_dc = int(np.sign(delta_c)) # Primary col step\n        \n        # Check if D1 is non-diagonal (not expected based on examples)\n        if d1_dr == 0 or d1_dc == 0:\n             print(f\"Warning: Calculated D1 ({d1_dr},{d1_dc}) is not strictly diagonal. Source=({source_row},{source_col}), Zero=({zero_row},{zero_col}). Results might be unexpected.\")\n             # Proceeding anyway, ray drawing might just stop early or work correctly\n\n        # 3. Determine secondary axis-aligned direction (D2') based on D1\n        d2_dr, d2_dc = 0, 0 # Initialize secondary steps\n        if d1_dr == 1:\n            d2_dr = 1  # Secondary step is Down\n            d2_dc = 0\n        elif d1_dr == -1:\n            d2_dr = 0  # Secondary step is horizontal\n            d2_dc = d1_dc # Match horizontal direction of D1\n        else: # d1_dr is 0 (vertical alignment of source and zero)\n             # This case needs a defined rule. Examples don't cover it.\n             # Let's assume if vertically aligned, D2' also goes horizontally like D1's horizontal component.\n             print(f\"Warning: Vertical alignment detected (D1=({d1_dr},{d1_dc})). D2' calculation might be incorrect.\")\n             d2_dr = 0\n             d2_dc = d1_dc # Use D1's horizontal component (could be 0 if source == zero)\n             if d2_dc == 0: # Source and zero at same location - error state\n                 raise ValueError(\"Source and Zero cells are at the same location or D1 is (0,0). Cannot determine directions.\")\n\n\n        # 4. Draw the two rays starting from the source cell\n        # Draw ray using D1\n        draw_ray(input_grid, output_grid, source_row, source_col, d1_dr, d1_dc, source_color, background_color)\n        \n        # Draw ray using D2'\n        draw_ray(input_grid, output_grid, source_row, source_col, d2_dr, d2_dc, source_color, background_color)\n\n    except ValueError as e:\n        # Handle errors during element identification or direction calculation\n        print(f\"Error during transformation: {e}. Returning original grid.\")\n        # Return the original grid (converted back to list) if setup fails\n        return input_grid.tolist()\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18307,
    "candidates_token_count": 2345,
    "total_token_count": 20652,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.292273,
  "retries": 1
}