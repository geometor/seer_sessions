{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport random\nimport numpy as np # Using numpy for convenience but stick to list-of-lists if required\n\n\"\"\"\nGenerates a specific, deterministic perfect maze pattern within a grid for \na given size N, represented by '0' for paths and '3' for walls.\n\nThe transformation follows these steps:\n1.  Initialize an N x N output grid filled entirely with the wall character '3'.\n2.  Seed the random number generator with a fixed value (e.g., 0) to ensure \n    deterministic maze generation.\n3.  Apply a maze generation algorithm (Randomized Depth-First Search - DFS) \n    to the inner grid area (rows 1 to N-2, columns 1 to N-2).\n    a. Start carving paths (changing '3' to '0') from cell (1, 1).\n    b. Use a stack to manage the DFS traversal.\n    c. Iteratively move to unvisited neighboring cells (2 steps away), carving \n       the wall between the current cell and the neighbor. The choice of \n       neighbor is determined by the seeded random number generator.\n    d. Backtrack when a dead end is reached.\n4.  Create an entrance at (1, 0) and an exit at (N-2, 0) by setting these \n    cells to the path character '0'.\n5.  The final grid contains the specific maze structure determined by the \n    grid size N and the fixed seed.\n\"\"\"\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Generates a deterministic maze structure within the input grid dimensions.\n\n    Args:\n        input_grid: An N x N list of lists containing only 0s.\n\n    Returns:\n        An N x N list of lists representing the specific maze for that N, \n        with 0s for paths and 3s for walls.\n    \"\"\"\n    # --- Get grid dimensions ---\n    n = len(input_grid)\n    if n == 0:\n        return []\n    # Assuming square grid based on examples\n    m = len(input_grid[0]) \n    if n != m:\n         raise ValueError(\"Input grid must be square\") \n\n    # --- Step 1: Initialize output_grid with walls (3) ---\n    output_grid = [[3 for _ in range(n)] for _ in range(n)]\n\n    # --- Handle edge cases: grids too small for standard maze structure ---\n    # Examples start at N=6. Need N>=5 for a 1x1 inner carving area.\n    if n < 5: \n        # Still create openings if possible based on the pattern N>=3\n        if n >= 3: \n             if 1 < n: output_grid[1][0] = 0 # Entrance at (1,0)\n             # Exit at (N-2,0), ensuring it's a valid index and different from entrance row\n             if (n-2) >= 1 and (n-2) != 1 : output_grid[n-2][0] = 0 \n        # Return the grid with just boundary walls and potential openings\n        return output_grid \n\n    # --- Step 2: Maze Carving (Deterministic DFS) in the inner grid ---\n    \n    # CRUCIAL STEP: Seed the random number generator for deterministic results\n    # Using seed=0 as a common starting point hypothesis\n    random.seed(0) \n    \n    # Define inner grid boundaries (inclusive) for carving\n    inner_r_min, inner_r_max = 1, n - 2\n    inner_c_min, inner_c_max = 1, n - 2\n\n    # Stack for DFS: stores (row, col) tuples\n    stack = []\n    \n    # Start DFS from a fixed point within the inner grid, e.g., (1, 1)\n    start_r, start_c = 1, 1\n    output_grid[start_r][start_c] = 0  # Mark starting cell as path\n    stack.append((start_r, start_c))\n    \n    # The 'visited' status is implicitly tracked by checking if output_grid[nr][nc] is 0 or 3\n\n    while stack:\n        # Get the current cell from the top of the stack\n        current_r, current_c = stack[-1] \n\n        # Find potential valid neighbors (2 steps away, within inner grid, still a wall)\n        neighbors = []\n        # Define possible moves (2 steps horizontally or vertically)\n        possible_moves = [(0, 2), (0, -2), (2, 0), (-2, 0)]\n        # Shuffle moves using the seeded RNG to ensure deterministic order if multiple valid neighbors exist\n        random.shuffle(possible_moves) \n        \n        for dr, dc in possible_moves:\n            nr, nc = current_r + dr, current_c + dc\n\n            # Check if the potential neighbor (nr, nc) is:\n            # 1. Within the inner grid bounds\n            # 2. Still a wall (output_grid[nr][nc] == 3)\n            if (inner_r_min <= nr <= inner_r_max and\n                inner_c_min <= nc <= inner_c_max and\n                output_grid[nr][nc] == 3):\n                neighbors.append((nr, nc)) # Keep track of valid neighbors found in the shuffled order\n\n        if neighbors:\n            # If there are valid unvisited neighbors, choose the first one found\n            # (due to the deterministic shuffle, this choice is now deterministic)\n            next_r, next_c = neighbors[0] # Changed from random.choice to deterministic selection\n\n            # Calculate the coordinates of the wall cell between current and neighbor\n            wall_r, wall_c = (current_r + next_r) // 2, (current_c + next_c) // 2\n\n            # Carve the path: set the wall cell and the neighbor cell to 0\n            output_grid[wall_r][wall_c] = 0\n            output_grid[next_r][next_c] = 0\n\n            # Add the chosen neighbor to the stack to continue DFS from there\n            stack.append((next_r, next_c))\n        else:\n            # If no unvisited neighbors (dead end), backtrack\n            stack.pop()\n\n    # --- Step 3: Create Entrance and Exit on the left boundary ---\n    # Indices are valid because we checked n >= 5 earlier\n    output_grid[1][0] = 0      # Set entrance at (1, 0)\n    output_grid[n - 2][0] = 0  # Set exit at (n-2, 0)\n\n    # --- Step 4: Final Output ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19514,
    "candidates_token_count": 1754,
    "total_token_count": 21268,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.861349,
  "retries": 1
}