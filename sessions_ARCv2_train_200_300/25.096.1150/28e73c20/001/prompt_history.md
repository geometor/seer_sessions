
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 0 0 0 3 0 3
3 0 3 3 3 3 3 3 3 0 3 0 3
3 0 3 0 0 0 0 0 3 0 3 0 3
3 0 3 0 3 3 3 0 3 0 3 0 3
3 0 3 0 3 0 0 0 3 0 3 0 3
3 0 3 0 3 3 3 3 3 0 3 0 3
3 0 3 0 0 0 0 0 0 0 3 0 3
3 0 3 3 3 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 3
3 3 3 3 3 3 0 3
3 0 0 0 0 3 0 3
3 0 3 3 0 3 0 3
3 0 3 3 3 3 0 3
3 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 0 0 0 0 0 3 0 3
3 0 3 3 3 3 3 3 3 3 3 0 3 0 3
3 0 3 0 0 0 0 0 0 0 3 0 3 0 3
3 0 3 0 3 3 3 3 3 0 3 0 3 0 3
3 0 3 0 3 0 0 0 3 0 3 0 3 0 3
3 0 3 0 3 0 3 3 3 0 3 0 3 0 3
3 0 3 0 3 0 0 0 0 0 3 0 3 0 3
3 0 3 0 3 3 3 3 3 3 3 0 3 0 3
3 0 3 0 0 0 0 0 0 0 0 0 3 0 3
3 0 3 3 3 3 3 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 3 0 3
3 0 3 3 3 3 0 3 0 3
3 0 3 0 3 3 0 3 0 3
3 0 3 0 0 0 0 3 0 3
3 0 3 3 3 3 3 3 0 3
3 0 0 0 0 0 0 0 0 3
3 3 3 3 3 3 3 3 3 3
```


## train_5

**input:**
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
```


**output:**
```
3 3 3 3 3 3
0 0 0 0 0 3
3 3 3 3 0 3
3 0 3 3 0 3
3 0 0 0 0 3
3 3 3 3 3 3
```

Okay, let's break down the task based on the provided examples.

**Perception of Task Elements:**

1.  **Input:** The input is always a square grid (N x N) filled entirely with the digit '0'.
2.  **Output:** The output is a grid of the same N x N dimensions, containing a pattern of '0's and '3's.
3.  **Transformation:** The transformation generates a maze structure within the grid. The '0's in the output represent the paths of the maze, while the '3's represent the walls.
4.  **Key Features:**
    *   The outermost border (top row, bottom row, rightmost column) of the output grid consists entirely of '3's (walls).
    *   The leftmost column consists mostly of '3's but has exactly two '0's: one at row index 1 (the entrance) and one at row index N-2 (the exit).
    *   The inner part of the grid (rows 1 to N-2, columns 1 to N-2) contains the maze pathways ('0') and walls ('3') generated algorithmically.
    *   The specific maze pattern varies but seems consistent with standard maze generation algorithms like Randomized Depth-First Search (DFS).

**YAML Facts:**


```yaml
task_name: maze_generation
description: Generates a perfect maze within a grid, represented by '0' for paths and '3' for walls.

input_features:
  - object: grid
    properties:
      - type: 2D array
      - dimensions: N x N (square)
      - cell_value: always 0
      - data_type: integer

output_features:
  - object: grid
    properties:
      - type: 2D array
      - dimensions: N x N (same as input)
      - cell_values: 0 or 3
      - data_type: integer
    structure:
      - element: maze
        properties:
          - path_char: 0
          - wall_char: 3
          - algorithm: likely Randomized Depth-First Search (DFS)
      - element: boundary_walls
        location: top row (row 0), bottom row (N-1), right column (N-1)
        value: 3
      - element: left_boundary
        location: left column (column 0)
        value: 3, except for entrance and exit
      - element: entrance
        location: (row 1, column 0)
        value: 0
      - element: exit
        location: (row N-2, column 0)
        value: 0
      - element: inner_maze
        location: rows 1 to N-2, columns 1 to N-2
        content: maze path (0) and wall (3) structure generated by the algorithm

transformation:
  - action: initialize_output
    description: Create an N x N grid filled with the wall character '3'.
  - action: generate_maze
    description: Apply a maze generation algorithm (e.g., Randomized DFS) to the inner grid area (rows 1 to N-2, columns 1 to N-2).
    details:
      - Start carving paths (changing '3' to '0') from an initial cell (e.g., (1,1)).
      - Ensure all cells within the inner maze area are potentially reachable via the path ('0').
      - The algorithm carves paths by removing 'wall' cells ('3') between adjacent path cells ('0').
  - action: create_openings
    description: Set the entrance and exit cells on the left boundary to the path character '0'.
    locations:
      - entrance: (1, 0)
      - exit: (N-2, 0)

examples_dimensionality:
  - train_1: 13x13
  - train_2: 8x8
  - train_3: 15x15
  - train_4: 10x10
  - train_5: 6x6
```


**Natural Language Program:**

1.  **Initialization:** Given an input grid of size N x N filled with zeros, create an output grid of the same size N x N and initialize all its cells with the value '3' (representing walls).
2.  **Maze Carving (Inner Grid):**
    a.  Define the inner grid region as rows 1 to N-2 and columns 1 to N-2.
    b.  Select a starting cell within this inner region, for instance, cell (1, 1). Mark this cell as a path by setting its value to '0' in the output grid.
    c.  Use a Randomized Depth-First Search (DFS) approach:
        i.  Maintain a stack of visited cells, initially containing the starting cell.
        ii. Keep track of visited cells within the inner grid to avoid cycles during exploration. Mark the starting cell as visited.
        iii. While the stack is not empty:
            1.  Look at the current cell (r, c) on top of the stack.
            2.  Find all valid neighboring cells (r', c') that are two steps away (horizontally or vertically) from (r, c), are within the inner grid boundaries [1..N-2, 1..N-2], and whose corresponding cell in the output grid is currently '3' (a wall).
            3.  If such unvisited neighbors exist:
                A. Randomly choose one neighbor `(r_next, c_next)`.
                B. Calculate the coordinates of the wall cell `(r_wall, c_wall)` situated between the current cell (r, c) and the chosen neighbor `(r_next, c_next)`.
                C. Change the value of the wall cell `(r_wall, c_wall)` in the output grid to '0' (carve path).
                D. Change the value of the neighbor cell `(r_next, c_next)` in the output grid to '0' (extend path).
                E. Mark the neighbor cell `(r_next, c_next)` as visited.
                F. Push the neighbor cell `(r_next, c_next)` onto the stack.
            4.  If no such unvisited neighbors exist (dead end), pop the current cell (r, c) from the stack (backtrack).
3.  **Create Entrance and Exit:**
    a.  Set the value of the cell at coordinates (1, 0) in the output grid to '0'.
    b.  Set the value of the cell at coordinates (N-2, 0) in the output grid to '0'.
4.  **Final Output:** The resulting output grid now contains the complete maze pattern with walls ('3') and paths ('0').
