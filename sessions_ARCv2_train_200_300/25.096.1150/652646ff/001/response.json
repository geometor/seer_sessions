{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the background digit: Find the most frequent digit in the input grid.\n2. Define the target pattern structure: A 6x6 grid with a specific \"frame\" shape. The frame consists of 8 cells filled with a \"foreground\" digit, and the remaining 28 cells filled with the background digit. The frame structure is:\n   - Rows 0 and 5: F B F F B F\n   - Rows 1 and 4: F F B B F F\n   - Rows 2 and 3: F B B B B F\n   (where F = foreground digit, B = background digit)\n3. Scan the input grid: Iterate through all possible 6x6 subgrids.\n4. Validate subgrids: For each 6x6 subgrid:\n   a. Check if it contains exactly two distinct digits.\n   b. One of these digits must be the background digit identified in step 1.\n   c. The other digit (the foreground digit) must appear exactly 8 times.\n   d. The arrangement of the foreground and background digits must match the target pattern structure defined in step 2.\n5. Collect unique foreground digits: Store the foreground digit of each valid 6x6 pattern found. Keep only the unique foreground digits.\n6. Sort foreground digits: Sort the collected unique foreground digits numerically in ascending order.\n7. Construct the output grid: For each sorted unique foreground digit:\n   a. Create a 6x6 grid representing the target pattern structure using the current foreground digit and the background digit.\n   b. Append this 6x6 grid vertically to the output grid being built.\n8. Return the final constructed output grid.\n\"\"\"\n\ndef _get_background_digit(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent digit in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # Find the digit with the highest count\n    background_digit = counts.most_common(1)[0][0]\n    return background_digit\n\ndef _is_valid_pattern(subgrid: np.ndarray, background_digit: int) -> tuple[bool, int | None]:\n    \"\"\"\n    Checks if a 6x6 subgrid matches the required pattern structure.\n    Returns (True, foreground_digit) if valid, otherwise (False, None).\n    \"\"\"\n    if subgrid.shape != (6, 6):\n        return False, None\n\n    unique_digits = np.unique(subgrid)\n\n    # Must have exactly two digits: background and one foreground\n    if len(unique_digits) != 2:\n        return False, None\n\n    # One of the digits must be the background digit\n    if background_digit not in unique_digits:\n         return False, None\n\n    # Identify the potential foreground digit\n    foreground_digit = unique_digits[0] if unique_digits[1] == background_digit else unique_digits[1]\n\n    # Count occurrences of the foreground digit\n    if np.count_nonzero(subgrid == foreground_digit) != 8:\n        return False, None\n        \n    # Verify the pattern structure exactly\n    for r in range(6):\n        for c in range(6):\n            expected_digit = background_digit\n            # Check positions that should have the foreground digit\n            if (r in [0, 5] and c in [0, 2, 3, 5]) or \\\n               (r in [1, 4] and c in [0, 1, 4, 5]) or \\\n               (r in [2, 3] and c == 0) or \\\n               (r in [2, 3] and c == 5):\n                expected_digit = foreground_digit\n            \n            if subgrid[r, c] != expected_digit:\n                 return False, None\n\n    # If all checks pass, it's a valid pattern\n    return True, foreground_digit\n\ndef _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:\n    \"\"\"Creates a 6x6 grid with the specified foreground/background pattern.\"\"\"\n    pattern = np.full((6, 6), background_digit, dtype=int)\n    # Set foreground digits based on the defined pattern structure\n    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit\n    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit\n    pattern[[2, 3], [0, 5]] = foreground_digit\n    return pattern\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies specific 6x6 patterns in the input grid, extracts their unique \n    foreground digits, sorts them, and constructs an output grid by stacking \n    the corresponding patterns vertically.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # 1. Identify the background digit\n    background_digit = _get_background_digit(input_array)\n    \n    found_foreground_digits = set()\n\n    # 3. Scan the input grid for 6x6 subgrids\n    for r in range(rows - 5):\n        for c in range(cols - 5):\n            subgrid = input_array[r:r+6, c:c+6]\n            \n            # 4. Validate subgrids\n            is_valid, foreground_digit = _is_valid_pattern(subgrid, background_digit)\n            \n            # 5. Collect unique foreground digits\n            if is_valid:\n                found_foreground_digits.add(foreground_digit)\n\n    # 6. Sort foreground digits\n    sorted_foreground_digits = sorted(list(found_foreground_digits))\n\n    # 7. Construct the output grid\n    output_patterns = []\n    for fg_digit in sorted_foreground_digits:\n        pattern_grid = _create_pattern_grid(fg_digit, background_digit)\n        output_patterns.append(pattern_grid)\n\n    # Stack the found patterns vertically\n    if not output_patterns:\n        return [] # Return empty list if no patterns found\n        \n    output_grid_np = np.vstack(output_patterns)\n    \n    # Convert back to list of lists for the expected output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3039,
    "candidates_token_count": 2294,
    "total_token_count": 5333,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 104.759082,
  "retries": 2
}