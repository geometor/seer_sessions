{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on identifying signal digits, locating specific \n6x6 patterns associated with them in the input, determining the order based on \nthese locations, and generating corresponding standard output patterns.\n\n1. Determine the background digit (most frequent).\n2. Identify signal digits: non-background digits with at least one adjacent \n   (including diagonal) neighbor of the same digit.\n3. Define the standard 6x6 pattern structure: a fixed frame of 8 foreground \n   cells against the background digit. The foreground coordinates are:\n   (0,2), (0,3), (1,1), (1,4), (2,0), (2,5), (3,0), (3,5), (4,1), (4,4), (5,2), (5,3).\n4. Locate all occurrences of this standard 6x6 pattern within the input grid \n   for each identified signal digit. Record the top-left corner (row, col) and \n   the signal digit for each match.\n5. Determine the output order: Sort the found pattern occurrences primarily by \n   row, secondarily by column. Extract the unique signal digits based on this \n   sorted order, taking the first occurrence of each digit.\n6. Construct the output grid: For each signal digit in the determined order, \n   create the standard 6x6 pattern using that digit as foreground and the \n   background digit. Stack these patterns vertically.\n7. Return the resulting stacked grid. If no signal digits are found or no \n   pattern instances are located, return an empty grid.\n\"\"\"\n\ndef _get_background_digit(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent digit in the grid.\"\"\"\n    if grid.size == 0:\n        raise ValueError(\"Input grid cannot be empty\") \n    counts = Counter(grid.flatten())\n    background_digit = counts.most_common(1)[0][0]\n    return int(background_digit) \n\ndef _find_signal_digits(grid: np.ndarray, background_digit: int) -> list[int]:\n    \"\"\"Identifies signal digits based on self-adjacency (including diagonals).\"\"\"\n    rows, cols = grid.shape\n    unique_digits = np.unique(grid)\n    candidate_digits = [int(d) for d in unique_digits if d != background_digit] \n    signal_digits = set()\n    neighbors = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n\n    for digit in candidate_digits:\n        locations = np.argwhere(grid == digit)\n        is_signal = False\n        for r, c in locations:\n            for dr, dc in neighbors:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == digit:\n                    signal_digits.add(digit)\n                    is_signal = True; break\n            if is_signal: break\n    # Return sorted list - although order will be determined later, \n    # returning sorted list is consistent\n    return sorted(list(signal_digits))\n\ndef _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:\n    \"\"\"Creates the standard 6x6 grid with the specified foreground/background pattern.\"\"\"\n    pattern = np.full((6, 6), background_digit, dtype=int)\n    # Define the coordinates for the foreground digit (the frame)\n    # using the CORRECTED coordinates based on analysis\n    fg_rows = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5]\n    fg_cols = [2, 3, 1, 4, 0, 5, 0, 5, 1, 4, 2, 3]\n    pattern[fg_rows, fg_cols] = foreground_digit\n    return pattern\n\ndef _find_pattern_occurrences(grid: np.ndarray, signal_digits: list[int], background_digit: int) -> list[tuple[int, int, int]]:\n    \"\"\"\n    Scans the input grid for all occurrences of the standard 6x6 pattern for any signal digit.\n    Returns a list of tuples: (row, column, signal_digit) for each match.\n    \"\"\"\n    rows, cols = grid.shape\n    occurrences = []\n    if not signal_digits:\n        return [] # No signal digits, no patterns to find\n\n    # Pre-generate target patterns for efficiency\n    target_patterns = {\n        sig_digit: _create_pattern_grid(sig_digit, background_digit)\n        for sig_digit in signal_digits\n    }\n\n    # Scan through all possible 6x6 top-left corners\n    for r in range(rows - 5):\n        for c in range(cols - 5):\n            subgrid = grid[r:r+6, c:c+6]\n            \n            # Check if this subgrid matches any of the target patterns\n            for sig_digit, target_pattern in target_patterns.items():\n                if np.array_equal(subgrid, target_pattern):\n                    occurrences.append((r, c, sig_digit))\n                    # Assuming a subgrid matches only one pattern type, break inner loop\n                    break \n                    \n    return occurrences\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid case\n    if input_array.size == 0:\n        return [] \n\n    # Step 1: Identify the background digit (most frequent)\n    background_digit = _get_background_digit(input_array)\n\n    # Step 2: Identify signal digits (non-background, self-adjacent)\n    signal_digits = _find_signal_digits(input_array, background_digit)\n    if not signal_digits:\n        return [] # No signal digits found\n\n    # Step 4: Locate all occurrences of the standard pattern in the input grid\n    pattern_occurrences = _find_pattern_occurrences(input_array, signal_digits, background_digit)\n    if not pattern_occurrences:\n         return [] # No patterns found in the input\n\n    # Step 5: Determine the output order based on occurrence location\n    # Sort occurrences first by row, then by column\n    pattern_occurrences.sort(key=lambda x: (x[0], x[1]))\n\n    # Extract the unique signal digits in the determined order\n    ordered_signal_digits = []\n    seen_digits = set()\n    for r, c, sig_digit in pattern_occurrences:\n        if sig_digit not in seen_digits:\n            ordered_signal_digits.append(sig_digit)\n            seen_digits.add(sig_digit)\n            \n    # Step 6 & 7: Construct the output grid by stacking patterns in order\n    output_patterns = []\n    for fg_digit in ordered_signal_digits:\n        # Create the standard 6x6 pattern for the current signal digit\n        pattern_grid = _create_pattern_grid(fg_digit, background_digit)\n        output_patterns.append(pattern_grid)\n\n    # Stack the generated patterns vertically\n    # vstack requires at least one array, handled by checks above\n    output_grid_np = np.vstack(output_patterns)\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20947,
    "candidates_token_count": 2489,
    "total_token_count": 23436,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.794998,
  "retries": 1
}