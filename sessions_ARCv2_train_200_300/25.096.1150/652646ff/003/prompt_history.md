
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```


**output:**
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```


## train_3

**input:**
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```


**output:**
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```


**output:**
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```

*   **Perception of Elements**:
    *   The input is a 2D grid of single digits.
    *   The output is also a 2D grid of single digits, generally smaller in height but potentially wider or narrower than the input depending on the specific task instance (though consistently 6 wide in the examples).
    *   There is a dominant "background" digit in each input grid (the most frequent one).
    *   Embedded within the input grid are patterns made of other "foreground" digits.
    *   The key patterns appear to occupy a 6x6 area and consist of a specific foreground digit arranged in a consistent "frame" shape (8 cells of the foreground digit, the rest being the background digit) within that 6x6 area.
    *   Some digits in the input seem to be "noise" and do not form part of the extracted patterns (e.g., 5, 7, 9 in various examples).
    *   The output grid is formed by stacking these identified 6x6 patterns vertically.

*   **YAML Facts**:

```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1. Identify the background digit: Find the most frequent digit in the input grid.
2. Define the target pattern structure: A 6x6 grid with a specific "frame" shape. The frame consists of 8 cells filled with a "foreground" digit, and the remaining 28 cells filled with the background digit. The frame structure is:
   - Rows 0 and 5: F B F F B F
   - Rows 1 and 4: F F B B F F
   - Rows 2 and 3: F B B B B F
   (where F = foreground digit, B = background digit)
3. Scan the input grid: Iterate through all possible 6x6 subgrids.
4. Validate subgrids: For each 6x6 subgrid:
   a. Check if it contains exactly two distinct digits.
   b. One of these digits must be the background digit identified in step 1.
   c. The other digit (the foreground digit) must appear exactly 8 times.
   d. The arrangement of the foreground and background digits must match the target pattern structure defined in step 2.
5. Collect unique foreground digits: Store the foreground digit of each valid 6x6 pattern found. Keep only the unique foreground digits.
6. Sort foreground digits: Sort the collected unique foreground digits numerically in ascending order.
7. Construct the output grid: For each sorted unique foreground digit:
   a. Create a 6x6 grid representing the target pattern structure using the current foreground digit and the background digit.
   b. Append this 6x6 grid vertically to the output grid being built.
8. Return the final constructed output grid.
"""

def _get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    counts = Counter(grid.flatten())
    # Find the digit with the highest count
    background_digit = counts.most_common(1)[0][0]
    return background_digit

def _is_valid_pattern(subgrid: np.ndarray, background_digit: int) -> tuple[bool, int | None]:
    """
    Checks if a 6x6 subgrid matches the required pattern structure.
    Returns (True, foreground_digit) if valid, otherwise (False, None).
    """
    if subgrid.shape != (6, 6):
        return False, None

    unique_digits = np.unique(subgrid)

    # Must have exactly two digits: background and one foreground
    if len(unique_digits) != 2:
        return False, None

    # One of the digits must be the background digit
    if background_digit not in unique_digits:
         return False, None

    # Identify the potential foreground digit
    foreground_digit = unique_digits[0] if unique_digits[1] == background_digit else unique_digits[1]

    # Count occurrences of the foreground digit
    if np.count_nonzero(subgrid == foreground_digit) != 8:
        return False, None
        
    # Verify the pattern structure exactly
    for r in range(6):
        for c in range(6):
            expected_digit = background_digit
            # Check positions that should have the foreground digit
            if (r in [0, 5] and c in [0, 2, 3, 5]) or \
               (r in [1, 4] and c in [0, 1, 4, 5]) or \
               (r in [2, 3] and c == 0) or \
               (r in [2, 3] and c == 5):
                expected_digit = foreground_digit
            
            if subgrid[r, c] != expected_digit:
                 return False, None

    # If all checks pass, it's a valid pattern
    return True, foreground_digit

def _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:
    """Creates a 6x6 grid with the specified foreground/background pattern."""
    pattern = np.full((6, 6), background_digit, dtype=int)
    # Set foreground digits based on the defined pattern structure
    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit
    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit
    pattern[[2, 3], [0, 5]] = foreground_digit
    return pattern

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies specific 6x6 patterns in the input grid, extracts their unique 
    foreground digits, sorts them, and constructs an output grid by stacking 
    the corresponding patterns vertically.
    """
    input_array = np.array(input_grid, dtype=int)
    rows, cols = input_array.shape
    
    # 1. Identify the background digit
    background_digit = _get_background_digit(input_array)
    
    found_foreground_digits = set()

    # 3. Scan the input grid for 6x6 subgrids
    for r in range(rows - 5):
        for c in range(cols - 5):
            subgrid = input_array[r:r+6, c:c+6]
            
            # 4. Validate subgrids
            is_valid, foreground_digit = _is_valid_pattern(subgrid, background_digit)
            
            # 5. Collect unique foreground digits
            if is_valid:
                found_foreground_digits.add(foreground_digit)

    # 6. Sort foreground digits
    sorted_foreground_digits = sorted(list(found_foreground_digits))

    # 7. Construct the output grid
    output_patterns = []
    for fg_digit in sorted_foreground_digits:
        pattern_grid = _create_pattern_grid(fg_digit, background_digit)
        output_patterns.append(pattern_grid)

    # Stack the found patterns vertically
    if not output_patterns:
        return [] # Return empty list if no patterns found
        
    output_grid_np = np.vstack(output_patterns)
    
    # Convert back to list of lists for the expected output format
    return output_grid_np.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1. Identify the background digit: Find the most frequent digit in the input grid.
2. Define the target pattern structure: A 6x6 grid with a specific "frame" shape. The frame consists of 8 cells filled with a "foreground" digit, and the remaining 28 cells filled with the background digit. The frame structure is:
   - Rows 0 and 5: F B F F B F
   - Rows 1 and 4: F F B B F F
   - Rows 2 and 3: F B B B B F
   (where F = foreground digit, B = background digit)
3. Scan the input grid: Iterate through all possible 6x6 subgrids.
4. Validate subgrids: For each 6x6 subgrid:
   a. Check if it contains exactly two distinct digits.
   b. One of these digits must be the background digit identified in step 1.
   c. The other digit (the foreground digit) must appear exactly 8 times.
   d. The arrangement of the foreground and background digits must match the target pattern structure defined in step 2.
5. Collect unique foreground digits: Store the foreground digit of each valid 6x6 pattern found. Keep only the unique foreground digits.
6. Sort foreground digits: Sort the collected unique foreground digits numerically in ascending order.
7. Construct the output grid: For each sorted unique foreground digit:
   a. Create a 6x6 grid representing the target pattern structure using the current foreground digit and the background digit.
   b. Append this 6x6 grid vertically to the output grid being built.
8. Return the final constructed output grid.
"""

def _get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    counts = Counter(grid.flatten())
    # Find the digit with the highest count
    background_digit = counts.most_common(1)[0][0]
    return background_digit

def _is_valid_pattern(subgrid: np.ndarray, background_digit: int) -> tuple[bool, int | None]:
    """
    Checks if a 6x6 subgrid matches the required pattern structure.
    Returns (True, foreground_digit) if valid, otherwise (False, None).
    """
    if subgrid.shape != (6, 6):
        return False, None

    unique_digits = np.unique(subgrid)

    # Must have exactly two digits: background and one foreground
    if len(unique_digits) != 2:
        return False, None

    # One of the digits must be the background digit
    if background_digit not in unique_digits:
         return False, None

    # Identify the potential foreground digit
    foreground_digit = unique_digits[0] if unique_digits[1] == background_digit else unique_digits[1]

    # Count occurrences of the foreground digit
    if np.count_nonzero(subgrid == foreground_digit) != 8:
        return False, None
        
    # Verify the pattern structure exactly
    for r in range(6):
        for c in range(6):
            expected_digit = background_digit
            # Check positions that should have the foreground digit
            if (r in [0, 5] and c in [0, 2, 3, 5]) or \
               (r in [1, 4] and c in [0, 1, 4, 5]) or \
               (r in [2, 3] and c == 0) or \
               (r in [2, 3] and c == 5):
                expected_digit = foreground_digit
            
            if subgrid[r, c] != expected_digit:
                 return False, None

    # If all checks pass, it's a valid pattern
    return True, foreground_digit

def _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:
    """Creates a 6x6 grid with the specified foreground/background pattern."""
    pattern = np.full((6, 6), background_digit, dtype=int)
    # Set foreground digits based on the defined pattern structure
    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit
    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit
    pattern[[2, 3], [0, 5]] = foreground_digit
    return pattern

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies specific 6x6 patterns in the input grid, extracts their unique 
    foreground digits, sorts them, and constructs an output grid by stacking 
    the corresponding patterns vertically.
    """
    input_array = np.array(input_grid, dtype=int)
    rows, cols = input_array.shape
    
    # 1. Identify the background digit
    background_digit = _get_background_digit(input_array)
    
    found_foreground_digits = set()

    # 3. Scan the input grid for 6x6 subgrids
    for r in range(rows - 5):
        for c in range(cols - 5):
            subgrid = input_array[r:r+6, c:c+6]
            
            # 4. Validate subgrids
            is_valid, foreground_digit = _is_valid_pattern(subgrid, background_digit)
            
            # 5. Collect unique foreground digits
            if is_valid:
                found_foreground_digits.add(foreground_digit)

    # 6. Sort foreground digits
    sorted_foreground_digits = sorted(list(found_foreground_digits))

    # 7. Construct the output grid
    output_patterns = []
    for fg_digit in sorted_foreground_digits:
        pattern_grid = _create_pattern_grid(fg_digit, background_digit)
        output_patterns.append(pattern_grid)

    # Stack the found patterns vertically
    if not output_patterns:
        return [] # Return empty list if no patterns found
        
    output_grid_np = np.vstack(output_patterns)
    
    # Convert back to list of lists for the expected output format
    return output_grid_np.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```
Expected Output:
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```
Transformed Output:
```

```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 2:
Input:
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```
Expected Output:
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```
Transformed Output:
```

```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 3:
Input:
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```
Expected Output:
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```
Transformed Output:
```

```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None

## Example 4:
Input:
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```
Expected Output:
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```
Transformed Output:
```

```
Match: False
Pixels Off: None
Size Correct: False
Color Palette Correct: True
Color Count Correct: False
Score: None
Okay, let's refine the understanding based on the execution results and the analysis.

**General Assessment & Strategy**

The initial code failed because its core assumption – that the exact 6x6 output patterns exist as clean subgrids within the input – was incorrect. The code produced empty outputs because the `_is_valid_pattern` function never found a subgrid matching its strict criteria (exactly two digits - background and foreground, foreground count of 8, and specific placement).

The new analysis, confirmed by code execution metrics, reveals a different logic:
1.  The input grid contains a background digit and several other digits.
2.  Some non-background digits act as "signals," while others are "noise."
3.  The crucial step is correctly identifying which digits are signals. The initial hypotheses (fixed noise set, count threshold) were insufficient.
4.  The successful hypothesis is that signal digits exhibit *clustering* – at least one instance of a signal digit must be adjacent (horizontally, vertically, or diagonally) to another instance of the *same* digit. Noise digits appear isolated from digits of the same value.
5.  Once the signal digits are identified, they are sorted, and for each one, a *standardized* 6x6 pattern is generated using that digit as foreground and the identified background digit. These generated patterns are then stacked vertically.

**Strategy:**
1.  Implement the logic to identify the background digit.
2.  Implement the logic to identify signal digits based on the self-adjacency criterion.
3.  Retain the logic for sorting signal digits and constructing the standard 6x6 output patterns.
4.  Update the natural language program and YAML facts accordingly.

**Metrics**

Based on the `tool_code` execution:

| Example | Dimensions | Background | Non-Background Counts              | Signal (Self-Adjacent) | Noise (Not Self-Adjacent) | Expected Signal | Match |
| :------ | :--------- | :--------- | :--------------------------------- | :--------------------- | :------------------------ | :-------------- | :---- |
| 1       | (20, 20)   | 2 (361)    | 4:12, 8:10, 3:10, 5:5, 9:2         | {3, 4, 8}              | {5, 9}                    | {3, 4, 8}       | Yes   |
| 2       | (10, 10)   | 3 (67)     | 4:12, 1:10, 8:8, 5:3               | {1, 4, 8}              | {5}                       | {1, 4, 8}       | Yes   |
| 3       | (13, 13)   | 4 (134)    | 3:10, 2:9, 8:9, 5:4, 7:3           | {2, 3, 8}              | {5, 7}                    | {2, 3, 8}       | Yes   |
| 4       | (10, 10)   | 8 (74)     | 4:12, 3:10, 5:2, 2:2               | {3, 4}                 | {2, 5}                    | {3, 4}          | Yes   |

The self-adjacency criterion correctly identifies the signal digits in all training examples.

**YAML Facts**


```yaml
# YAML Facts: Task Understanding

perception:
  input_object:
    type: 2D grid
    description: A grid of single digits.
    properties:
      - Contains a dominant 'background' digit (most frequent).
      - Contains other 'foreground' digits scattered or clustered within.
      - Some foreground digits act as 'signals', others as 'noise'.
  output_object:
    type: 2D grid
    description: A grid composed of stacked 6x6 patterns.
    properties:
      - Width is always 6.
      - Height is 6 times the number of identified signal digits.
      - Each 6x6 pattern follows a fixed structure.

discernment:
  transformation_goal: >
    Identify specific 'signal' digits within the input grid based on adjacency properties,
    then construct and stack standardized 6x6 patterns for each signal digit.

  key_steps:
    - Identify the background digit (most frequent).
    - Identify all unique non-background digits.
    - Filter non-background digits to find 'signal' digits:
        - A digit is a signal if at least one instance of it in the grid is adjacent (including diagonals) to another instance of the same digit.
    - Sort the identified signal digits numerically.
    - For each sorted signal digit:
        - Generate a 6x6 pattern using the signal digit as foreground and the background digit.
        - The pattern structure is fixed: 8 foreground cells in a specific frame shape, 28 background cells.
    - Vertically stack the generated 6x6 patterns in the sorted order.

  pattern_details:
    background_digit_identification: Most frequent digit in the input grid.
    signal_digit_identification: Non-background digits where at least one instance has an identical neighbor (8 directions).
    noise_digit_identification: Non-background digits where no instance has an identical neighbor.
    output_pattern_structure:
      size: 6x6
      foreground_digit: The identified signal digit.
      background_digit: The identified background digit from the input.
      foreground_positions:
        - Rows 0 & 5: Columns 0, 2, 3, 5
        - Rows 1 & 4: Columns 0, 1, 4, 5
        - Rows 2 & 3: Columns 0, 5
      background_positions: All other cells within the 6x6 grid.
    output_assembly: Vertical stacking of generated patterns, ordered by the numerical value of the signal digits.

```


**Natural Language Program**

1.  **Analyze Input Grid**: Read the input 2D grid of digits.
2.  **Identify Background**: Determine the background digit by finding the most frequently occurring digit in the entire input grid.
3.  **Identify Candidate Digits**: Find all unique digits present in the grid that are *not* the background digit.
4.  **Filter for Signal Digits**: Iterate through each candidate digit:
    *   For each instance of the candidate digit in the grid, check its eight neighbors (horizontal, vertical, and diagonal).
    *   If *any* instance of the candidate digit has a neighbor that is the *same* digit, then classify this candidate digit as a "signal" digit.
    *   Collect all identified signal digits.
5.  **Sort Signal Digits**: Sort the collected signal digits in ascending numerical order.
6.  **Construct Output Patterns**: Initialize an empty output grid. For each signal digit in the sorted list:
    *   Create a new 6x6 grid.
    *   Fill this 6x6 grid primarily with the background digit identified in step 2.
    *   Place the current signal digit (as the foreground digit) into the following 8 positions within the 6x6 grid:
        *   Row 0: Columns 0, 2, 3, 5
        *   Row 1: Columns 0, 1, 4, 5
        *   Row 2: Columns 0, 5
        *   Row 3: Columns 0, 5
        *   Row 4: Columns 0, 1, 4, 5
        *   Row 5: Columns 0, 2, 3, 5
    *   Append this newly created 6x6 pattern grid vertically to the bottom of the main output grid being built.
7.  **Return Result**: Return the final assembled output grid. If no signal digits were found, return an empty grid.
