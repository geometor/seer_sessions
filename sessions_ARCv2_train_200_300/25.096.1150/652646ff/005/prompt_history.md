
## train_1

**input:**
```
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 5 2 2 2 2 2 2 2 2 2 2 2 2 2 5 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 2 2 2 2 2 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 3 3 2 2 2 2 2 2
2 4 2 2 2 2 4 5 2 2 2 8 2 2 3 2 2 2 2 2
2 4 2 9 2 2 4 2 2 2 3 8 2 9 2 3 2 2 2 2
2 2 4 2 2 4 2 8 2 2 8 2 2 2 2 3 2 2 2 2
2 2 2 4 4 2 2 2 8 8 2 3 2 2 3 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 3 3 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 5 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
5 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```


**output:**
```
2 2 4 4 2 2
2 4 2 2 4 2
4 2 2 2 2 4
4 2 2 2 2 4
2 4 2 2 4 2
2 2 4 4 2 2
2 2 8 8 2 2
2 8 2 2 8 2
8 2 2 2 2 8
8 2 2 2 2 8
2 8 2 2 8 2
2 2 8 8 2 2
2 2 3 3 2 2
2 3 2 2 3 2
3 2 2 2 2 3
3 2 2 2 2 3
2 3 2 2 3 2
2 2 3 3 2 2
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3
5 3 3 4 4 3 3 3 3 3
3 3 4 3 8 4 3 3 3 3
3 4 3 8 3 3 4 3 3 3
3 4 8 1 3 3 4 8 3 3
3 1 4 3 1 4 3 8 3 3
1 3 3 4 4 1 8 3 3 3
1 3 5 3 8 8 3 3 3 3
3 1 3 3 1 3 3 3 3 3
3 3 1 1 3 3 5 3 3 3
```


**output:**
```
3 3 4 4 3 3
3 4 3 3 4 3
4 3 3 3 3 4
4 3 3 3 3 4
3 4 3 3 4 3
3 3 4 4 3 3
3 3 8 8 3 3
3 8 3 3 8 3
8 3 3 3 3 8
8 3 3 3 3 8
3 8 3 3 8 3
3 3 8 8 3 3
3 3 1 1 3 3
3 1 3 3 1 3
1 3 3 3 3 1
1 3 3 3 3 1
3 1 3 3 1 3
3 3 1 1 3 3
```


## train_3

**input:**
```
4 4 4 4 4 5 4 4 4 4 4 4 4
4 4 4 4 4 4 4 4 4 4 4 7 4
4 4 2 2 4 4 4 4 4 4 4 4 4
4 2 4 4 2 4 4 4 4 4 4 4 4
2 4 4 7 4 2 4 4 4 4 4 4 4
2 4 4 4 4 8 8 4 4 5 4 4 4
4 2 4 4 8 4 4 8 4 4 4 4 4
4 4 2 8 4 4 4 4 8 4 4 4 4
4 4 4 8 4 4 4 4 3 3 4 4 4
4 4 4 4 8 4 4 3 4 4 3 4 4
4 5 4 4 4 8 3 4 4 4 4 3 4
4 4 7 4 4 4 3 4 4 5 4 3 4
4 4 4 4 4 4 4 3 4 4 3 4 4
```


**output:**
```
4 4 3 3 4 4
4 3 4 4 3 4
3 4 4 4 4 3
3 4 4 4 4 3
4 3 4 4 3 4
4 4 3 3 4 4
4 4 8 8 4 4
4 8 4 4 8 4
8 4 4 4 4 8
8 4 4 4 4 8
4 8 4 4 8 4
4 4 8 8 4 4
4 4 2 2 4 4
4 2 4 4 2 4
2 4 4 4 4 2
2 4 4 4 4 2
4 2 4 4 2 4
4 4 2 2 4 4
```


## train_4

**input:**
```
8 8 8 8 8 8 8 8 5 8
8 8 8 8 8 8 8 8 8 8
8 8 8 4 4 8 3 3 8 8
8 8 4 8 8 4 8 8 3 8
8 4 2 8 3 8 4 8 8 3
8 4 8 8 3 8 4 8 8 3
8 8 4 8 8 4 8 8 3 8
8 8 8 4 4 8 3 3 8 8
8 5 8 8 8 8 8 8 8 8
8 8 8 8 8 8 8 2 8 8
```


**output:**
```
8 8 4 4 8 8
8 4 8 8 4 8
4 8 8 8 8 4
4 8 8 8 8 4
8 4 8 8 4 8
8 8 4 4 8 8
8 8 3 3 8 8
8 3 8 8 3 8
3 8 8 8 8 3
3 8 8 8 8 3
8 3 8 8 3 8
8 8 3 3 8 8
```

*   **Perception of Elements**:
    *   The input is a 2D grid of single digits.
    *   The output is also a 2D grid of single digits, generally smaller in height but potentially wider or narrower than the input depending on the specific task instance (though consistently 6 wide in the examples).
    *   There is a dominant "background" digit in each input grid (the most frequent one).
    *   Embedded within the input grid are patterns made of other "foreground" digits.
    *   The key patterns appear to occupy a 6x6 area and consist of a specific foreground digit arranged in a consistent "frame" shape (8 cells of the foreground digit, the rest being the background digit) within that 6x6 area.
    *   Some digits in the input seem to be "noise" and do not form part of the extracted patterns (e.g., 5, 7, 9 in various examples).
    *   The output grid is formed by stacking these identified 6x6 patterns vertically.

*   **YAML Facts**:

```python
import numpy as np
from collections import Counter

"""
Transformation Rule:

1. Identify the background digit: Find the most frequent digit in the input grid.
2. Define the target pattern structure: A 6x6 grid with a specific "frame" shape. The frame consists of 8 cells filled with a "foreground" digit, and the remaining 28 cells filled with the background digit. The frame structure is:
   - Rows 0 and 5: F B F F B F
   - Rows 1 and 4: F F B B F F
   - Rows 2 and 3: F B B B B F
   (where F = foreground digit, B = background digit)
3. Scan the input grid: Iterate through all possible 6x6 subgrids.
4. Validate subgrids: For each 6x6 subgrid:
   a. Check if it contains exactly two distinct digits.
   b. One of these digits must be the background digit identified in step 1.
   c. The other digit (the foreground digit) must appear exactly 8 times.
   d. The arrangement of the foreground and background digits must match the target pattern structure defined in step 2.
5. Collect unique foreground digits: Store the foreground digit of each valid 6x6 pattern found. Keep only the unique foreground digits.
6. Sort foreground digits: Sort the collected unique foreground digits numerically in ascending order.
7. Construct the output grid: For each sorted unique foreground digit:
   a. Create a 6x6 grid representing the target pattern structure using the current foreground digit and the background digit.
   b. Append this 6x6 grid vertically to the output grid being built.
8. Return the final constructed output grid.
"""

def _get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    counts = Counter(grid.flatten())
    # Find the digit with the highest count
    background_digit = counts.most_common(1)[0][0]
    return background_digit

def _is_valid_pattern(subgrid: np.ndarray, background_digit: int) -> tuple[bool, int | None]:
    """
    Checks if a 6x6 subgrid matches the required pattern structure.
    Returns (True, foreground_digit) if valid, otherwise (False, None).
    """
    if subgrid.shape != (6, 6):
        return False, None

    unique_digits = np.unique(subgrid)

    # Must have exactly two digits: background and one foreground
    if len(unique_digits) != 2:
        return False, None

    # One of the digits must be the background digit
    if background_digit not in unique_digits:
         return False, None

    # Identify the potential foreground digit
    foreground_digit = unique_digits[0] if unique_digits[1] == background_digit else unique_digits[1]

    # Count occurrences of the foreground digit
    if np.count_nonzero(subgrid == foreground_digit) != 8:
        return False, None
        
    # Verify the pattern structure exactly
    for r in range(6):
        for c in range(6):
            expected_digit = background_digit
            # Check positions that should have the foreground digit
            if (r in [0, 5] and c in [0, 2, 3, 5]) or \
               (r in [1, 4] and c in [0, 1, 4, 5]) or \
               (r in [2, 3] and c == 0) or \
               (r in [2, 3] and c == 5):
                expected_digit = foreground_digit
            
            if subgrid[r, c] != expected_digit:
                 return False, None

    # If all checks pass, it's a valid pattern
    return True, foreground_digit

def _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:
    """Creates a 6x6 grid with the specified foreground/background pattern."""
    pattern = np.full((6, 6), background_digit, dtype=int)
    # Set foreground digits based on the defined pattern structure
    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit
    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit
    pattern[[2, 3], [0, 5]] = foreground_digit
    return pattern

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies specific 6x6 patterns in the input grid, extracts their unique 
    foreground digits, sorts them, and constructs an output grid by stacking 
    the corresponding patterns vertically.
    """
    input_array = np.array(input_grid, dtype=int)
    rows, cols = input_array.shape
    
    # 1. Identify the background digit
    background_digit = _get_background_digit(input_array)
    
    found_foreground_digits = set()

    # 3. Scan the input grid for 6x6 subgrids
    for r in range(rows - 5):
        for c in range(cols - 5):
            subgrid = input_array[r:r+6, c:c+6]
            
            # 4. Validate subgrids
            is_valid, foreground_digit = _is_valid_pattern(subgrid, background_digit)
            
            # 5. Collect unique foreground digits
            if is_valid:
                found_foreground_digits.add(foreground_digit)

    # 6. Sort foreground digits
    sorted_foreground_digits = sorted(list(found_foreground_digits))

    # 7. Construct the output grid
    output_patterns = []
    for fg_digit in sorted_foreground_digits:
        pattern_grid = _create_pattern_grid(fg_digit, background_digit)
        output_patterns.append(pattern_grid)

    # Stack the found patterns vertically
    if not output_patterns:
        return [] # Return empty list if no patterns found
        
    output_grid_np = np.vstack(output_patterns)
    
    # Convert back to list of lists for the expected output format
    return output_grid_np.tolist()
```
```python
import numpy as np
from collections import Counter

"""
Identify the background digit (most frequent) in the input grid. Then, identify 
'signal' digits, which are non-background digits where at least one instance 
is adjacent (horizontally, vertically, or diagonally) to another instance of 
the same digit. Sort these signal digits numerically. For each sorted signal 
digit, construct a standard 6x6 pattern using the signal digit as foreground 
and the identified background digit. The pattern has a fixed frame structure 
with 8 foreground cells. Finally, stack these generated 6x6 patterns vertically 
in the sorted order to create the output grid.
"""

def _get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    if grid.size == 0:
        # Handle empty input grid case if necessary, though constraints likely prevent this.
        # Returning a default or raising an error might be appropriate.
        # For now, assuming non-empty grids based on examples.
        raise ValueError("Input grid cannot be empty")
    counts = Counter(grid.flatten())
    # Find the digit with the highest count
    background_digit = counts.most_common(1)[0][0]
    return int(background_digit) # Ensure it's a standard int

def _find_signal_digits(grid: np.ndarray, background_digit: int) -> list[int]:
    """Identifies signal digits based on self-adjacency."""
    rows, cols = grid.shape
    unique_digits = np.unique(grid)
    candidate_digits = [d for d in unique_digits if d != background_digit]
    signal_digits = set()

    # Define offsets for 8 neighbors (including diagonals)
    neighbors = [(-1, -1), (-1, 0), (-1, 1),
                 ( 0, -1),          ( 0, 1),
                 ( 1, -1), ( 1, 0), ( 1, 1)]

    # Iterate through each candidate digit
    for digit in candidate_digits:
        # Find all locations of the current candidate digit
        locations = np.argwhere(grid == digit)
        is_signal = False
        # Check neighbors for each location
        for r, c in locations:
            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                # Check if neighbor is within bounds
                if 0 <= nr < rows and 0 <= nc < cols:
                    # Check if neighbor has the same digit
                    if grid[nr, nc] == digit:
                        signal_digits.add(digit)
                        is_signal = True
                        break # Found adjacency for this location, move to next location
            if is_signal:
                break # Found adjacency for this digit, move to next digit

    return sorted(list(signal_digits))


def _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:
    """Creates a standard 6x6 grid with the specified foreground/background pattern."""
    pattern = np.full((6, 6), background_digit, dtype=int)
    # Set foreground digits based on the defined pattern structure
    # Rows 0 & 5: F B F F B F --> indices 0, 2, 3, 5
    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit
    # Rows 1 & 4: F F B B F F --> indices 0, 1, 4, 5
    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit
    # Rows 2 & 3: F B B B B F --> indices 0, 5
    pattern[[2, 3], [0, 5]] = foreground_digit
    return pattern

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by identifying signal digits based on adjacency,
    generating standard 6x6 patterns for them, and stacking these patterns.
    """
    # Convert input to numpy array for efficient processing
    input_array = np.array(input_grid, dtype=int)

    if input_array.size == 0:
        return [] # Handle empty input

    # Step 1: Identify the background digit
    background_digit = _get_background_digit(input_array)

    # Step 2 & 3: Identify Candidate Digits and Filter for Signal Digits
    signal_digits = _find_signal_digits(input_array, background_digit)

    # Step 4: Sort Signal Digits (already sorted by _find_signal_digits)
    # signal_digits are sorted

    # Step 5 & 6: Construct Output Patterns and Stack
    output_patterns = []
    if not signal_digits:
        return [] # Return empty list if no signal digits found

    for fg_digit in signal_digits:
        # Create the standard 6x6 pattern for the current signal digit
        pattern_grid = _create_pattern_grid(fg_digit, background_digit)
        output_patterns.append(pattern_grid)

    # Stack the found patterns vertically
    output_grid_np = np.vstack(output_patterns)

    # Step 7: Return Result as list of lists
    return output_grid_np.tolist()
```

Previous Code:
```python
import numpy as np
from collections import Counter

"""
Identify the background digit (most frequent) in the input grid. Then, identify 
'signal' digits, which are non-background digits where at least one instance 
is adjacent (horizontally, vertically, or diagonally) to another instance of 
the same digit. Sort these signal digits numerically. For each sorted signal 
digit, construct a standard 6x6 pattern using the signal digit as foreground 
and the identified background digit. The pattern has a fixed frame structure 
with 8 foreground cells. Finally, stack these generated 6x6 patterns vertically 
in the sorted order to create the output grid.
"""

def _get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    if grid.size == 0:
        # Handle empty input grid case if necessary, though constraints likely prevent this.
        # Returning a default or raising an error might be appropriate.
        # For now, assuming non-empty grids based on examples.
        raise ValueError("Input grid cannot be empty")
    counts = Counter(grid.flatten())
    # Find the digit with the highest count
    background_digit = counts.most_common(1)[0][0]
    return int(background_digit) # Ensure it's a standard int

def _find_signal_digits(grid: np.ndarray, background_digit: int) -> list[int]:
    """Identifies signal digits based on self-adjacency."""
    rows, cols = grid.shape
    unique_digits = np.unique(grid)
    candidate_digits = [d for d in unique_digits if d != background_digit]
    signal_digits = set()

    # Define offsets for 8 neighbors (including diagonals)
    neighbors = [(-1, -1), (-1, 0), (-1, 1),
                 ( 0, -1),          ( 0, 1),
                 ( 1, -1), ( 1, 0), ( 1, 1)]

    # Iterate through each candidate digit
    for digit in candidate_digits:
        # Find all locations of the current candidate digit
        locations = np.argwhere(grid == digit)
        is_signal = False
        # Check neighbors for each location
        for r, c in locations:
            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                # Check if neighbor is within bounds
                if 0 <= nr < rows and 0 <= nc < cols:
                    # Check if neighbor has the same digit
                    if grid[nr, nc] == digit:
                        signal_digits.add(digit)
                        is_signal = True
                        break # Found adjacency for this location, move to next location
            if is_signal:
                break # Found adjacency for this digit, move to next digit

    return sorted(list(signal_digits))


def _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:
    """Creates a standard 6x6 grid with the specified foreground/background pattern."""
    pattern = np.full((6, 6), background_digit, dtype=int)
    # Set foreground digits based on the defined pattern structure
    # Rows 0 & 5: F B F F B F --> indices 0, 2, 3, 5
    pattern[[0, 5], [0, 2, 3, 5]] = foreground_digit
    # Rows 1 & 4: F F B B F F --> indices 0, 1, 4, 5
    pattern[[1, 4], [0, 1, 4, 5]] = foreground_digit
    # Rows 2 & 3: F B B B B F --> indices 0, 5
    pattern[[2, 3], [0, 5]] = foreground_digit
    return pattern

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by identifying signal digits based on adjacency,
    generating standard 6x6 patterns for them, and stacking these patterns.
    """
    # Convert input to numpy array for efficient processing
    input_array = np.array(input_grid, dtype=int)

    if input_array.size == 0:
        return [] # Handle empty input

    # Step 1: Identify the background digit
    background_digit = _get_background_digit(input_array)

    # Step 2 & 3: Identify Candidate Digits and Filter for Signal Digits
    signal_digits = _find_signal_digits(input_array, background_digit)

    # Step 4: Sort Signal Digits (already sorted by _find_signal_digits)
    # signal_digits are sorted

    # Step 5 & 6: Construct Output Patterns and Stack
    output_patterns = []
    if not signal_digits:
        return [] # Return empty list if no signal digits found

    for fg_digit in signal_digits:
        # Create the standard 6x6 pattern for the current signal digit
        pattern_grid = _create_pattern_grid(fg_digit, background_digit)
        output_patterns.append(pattern_grid)

    # Stack the found patterns vertically
    output_grid_np = np.vstack(output_patterns)

    # Step 7: Return Result as list of lists
    return output_grid_np.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Error: Execution Error: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (4,) 

## Example 2:
Error: Execution Error: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (4,) 

## Example 3:
Error: Execution Error: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (4,) 

## Example 4:
Error: Execution Error: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (4,) 
## General Assessment and Strategy

The previous analysis correctly identified the core concept: finding a background digit, identifying specific "signal" digits based on some criteria, sorting these signal digits, and generating a fixed 6x6 pattern for each, stacking them vertically. The consistent error across all examples (`shape mismatch` during NumPy indexing in `_create_pattern_grid`) points to a specific implementation bug rather than a fundamental flaw in the overall logic.

The error arises from how NumPy handles indexing with lists for multiple dimensions. `pattern[[0, 5], [0, 2, 3, 5]] = fg` attempts to set elements at `(0, 0)` and `(5, 2)`, not all combinations.

**Strategy:**

1.  **Correct Indexing:** Fix the `_create_pattern_grid` function to correctly assign values to the specific cells forming the 6x6 frame pattern. This can be done by assigning columns individually for the relevant rows.
2.  **Verify Logic:** Confirm that the logic for identifying the background digit (most frequent) and signal digits (non-background, self-adjacent including diagonals) holds for all examples.
3.  **Update Documentation:** Refine the YAML facts and natural language program to accurately reflect the confirmed logic and the fixed pattern structure.

## Metrics and Verification

Let's verify the background digit and signal digits (non-background, self-adjacent) for each training example.



*code_execution:*
```python
import numpy as np
from collections import Counter

def get_background_digit(grid: np.ndarray) -> int:
    """Finds the most frequent digit in the grid."""
    if grid.size == 0: return -1 # Indicate error or empty
    counts = Counter(grid.flatten())
    return counts.most_common(1)[0][0]

def find_signal_digits(grid: np.ndarray, background_digit: int) -> list[int]:
    """Identifies signal digits based on self-adjacency (including diagonals)."""
    rows, cols = grid.shape
    unique_digits = np.unique(grid)
    candidate_digits = [d for d in unique_digits if d != background_digit]
    signal_digits = set()
    neighbors = [(-1, -1), (-1, 0), (-1, 1), ( 0, -1), ( 0, 1), ( 1, -1), ( 1, 0), ( 1, 1)]

    for digit in candidate_digits:
        locations = np.argwhere(grid == digit)
        is_signal = False
        for r, c in locations:
            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] == digit:
                    signal_digits.add(digit)
                    is_signal = True
                    break
            if is_signal: break
    return sorted(list(signal_digits))

# --- Data from Examples ---
train_inputs = [
    [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 3, 3, 2, 2, 2, 2, 2, 2],
     [2, 4, 2, 2, 2, 2, 4, 5, 2, 2, 2, 8, 2, 2, 3, 2, 2, 2, 2, 2],
     [2, 4, 2, 9, 2, 2, 4, 2, 2, 2, 3, 8, 2, 9, 2, 3, 2, 2, 2, 2],
     [2, 2, 4, 2, 2, 4, 2, 8, 2, 2, 8, 2, 2, 2, 2, 3, 2, 2, 2, 2],
     [2, 2, 2, 4, 4, 2, 2, 2, 8, 8, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
     [5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]],

    [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
     [5, 3, 3, 4, 4, 3, 3, 3, 3, 3],
     [3, 3, 4, 3, 8, 4, 3, 3, 3, 3],
     [3, 4, 3, 8, 3, 3, 4, 3, 3, 3],
     [3, 4, 8, 1, 3, 3, 4, 8, 3, 3],
     [3, 1, 4, 3, 1, 4, 3, 8, 3, 3],
     [1, 3, 3, 4, 4, 1, 8, 3, 3, 3],
     [1, 3, 5, 3, 8, 8, 3, 3, 3, 3],
     [3, 1, 3, 3, 1, 3, 3, 3, 3, 3],
     [3, 3, 1, 1, 3, 3, 5, 3, 3, 3]],

    [[4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 4],
     [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4],
     [4, 4, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4],
     [4, 2, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4],
     [2, 4, 4, 7, 4, 2, 4, 4, 4, 4, 4, 4, 4],
     [2, 4, 4, 4, 4, 8, 8, 4, 4, 5, 4, 4, 4],
     [4, 2, 4, 4, 8, 4, 4, 8, 4, 4, 4, 4, 4],
     [4, 4, 2, 8, 4, 4, 4, 4, 8, 4, 4, 4, 4],
     [4, 4, 4, 8, 4, 4, 4, 4, 3, 3, 4, 4, 4],
     [4, 4, 4, 4, 8, 4, 4, 3, 4, 4, 3, 4, 4],
     [4, 5, 4, 4, 4, 8, 3, 4, 4, 4, 4, 3, 4],
     [4, 4, 7, 4, 4, 4, 3, 4, 4, 5, 4, 3, 4],
     [4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 3, 4, 4]],

    [[8, 8, 8, 8, 8, 8, 8, 8, 5, 8],
     [8, 8, 8, 8, 8, 8, 8, 8, 8, 8],
     [8, 8, 8, 4, 4, 8, 3, 3, 8, 8],
     [8, 8, 4, 8, 8, 4, 8, 8, 3, 8],
     [8, 4, 2, 8, 3, 8, 4, 8, 8, 3],
     [8, 4, 8, 8, 3, 8, 4, 8, 8, 3],
     [8, 8, 4, 8, 8, 4, 8, 8, 3, 8],
     [8, 8, 8, 4, 4, 8, 3, 3, 8, 8],
     [8, 5, 8, 8, 8, 8, 8, 8, 8, 8],
     [8, 8, 8, 8, 8, 8, 8, 2, 8, 8]]
]

train_outputs = [
    # Output for example 1
    [[2, 2, 4, 4, 2, 2], [2, 4, 2, 2, 4, 2], [4, 2, 2, 2, 2, 4], [4, 2, 2, 2, 2, 4], [2, 4, 2, 2, 4, 2], [2, 2, 4, 4, 2, 2],
     [2, 2, 8, 8, 2, 2], [2, 8, 2, 2, 8, 2], [8, 2, 2, 2, 2, 8], [8, 2, 2, 2, 2, 8], [2, 8, 2, 2, 8, 2], [2, 2, 8, 8, 2, 2],
     [2, 2, 3, 3, 2, 2], [2, 3, 2, 2, 3, 2], [3, 2, 2, 2, 2, 3], [3, 2, 2, 2, 2, 3], [2, 3, 2, 2, 3, 2], [2, 2, 3, 3, 2, 2]],
    # Output for example 2
    [[3, 3, 4, 4, 3, 3], [3, 4, 3, 3, 4, 3], [4, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 4], [3, 4, 3, 3, 4, 3], [3, 3, 4, 4, 3, 3],
     [3, 3, 8, 8, 3, 3], [3, 8, 3, 3, 8, 3], [8, 3, 3, 3, 3, 8], [8, 3, 3, 3, 3, 8], [3, 8, 3, 3, 8, 3], [3, 3, 8, 8, 3, 3],
     [3, 3, 1, 1, 3, 3], [3, 1, 3, 3, 1, 3], [1, 3, 3, 3, 3, 1], [1, 3, 3, 3, 3, 1], [3, 1, 3, 3, 1, 3], [3, 3, 1, 1, 3, 3]],
    # Output for example 3
    [[4, 4, 3, 3, 4, 4], [4, 3, 4, 4, 3, 4], [3, 4, 4, 4, 4, 3], [3, 4, 4, 4, 4, 3], [4, 3, 4, 4, 3, 4], [4, 4, 3, 3, 4, 4],
     [4, 4, 8, 8, 4, 4], [4, 8, 4, 4, 8, 4], [8, 4, 4, 4, 4, 8], [8, 4, 4, 4, 4, 8], [4, 8, 4, 4, 8, 4], [4, 4, 8, 8, 4, 4],
     [4, 4, 2, 2, 4, 4], [4, 2, 4, 4, 2, 4], [2, 4, 4, 4, 4, 2], [2, 4, 4, 4, 4, 2], [4, 2, 4, 4, 2, 4], [4, 4, 2, 2, 4, 4]],
    # Output for example 4
    [[8, 8, 4, 4, 8, 8], [8, 4, 8, 8, 4, 8], [4, 8, 8, 8, 8, 4], [4, 8, 8, 8, 8, 4], [8, 4, 8, 8, 4, 8], [8, 8, 4, 4, 8, 8],
     [8, 8, 3, 3, 8, 8], [8, 3, 8, 8, 3, 8], [3, 8, 8, 8, 8, 3], [3, 8, 8, 8, 8, 3], [8, 3, 8, 8, 3, 8], [8, 8, 3, 3, 8, 8]]
]

results = {}
for i, input_list in enumerate(train_inputs):
    input_array = np.array(input_list, dtype=int)
    bg_digit = get_background_digit(input_array)
    sig_digits = find_signal_digits(input_array, bg_digit)
    
    # Determine expected signal digits from output
    output_array = np.array(train_outputs[i], dtype=int)
    expected_sig_digits = sorted(list(np.unique(output_array[output_array != bg_digit])))

    results[f'Example {i+1}'] = {
        'Background Digit': bg_digit,
        'Calculated Signal Digits': sig_digits,
        'Expected Signal Digits': expected_sig_digits,
        'Match': sig_digits == expected_sig_digits
    }

print(results)
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{'Example 1': {'Background Digit': np.int64(2), 'Calculated Signal Digits': [np.int64(3), np.int64(4), np.int64(8)], 'Expected Signal Digits': [np.int64(3), np.int64(4), np.int64(8)], 'Match': True}, 'Example 2': {'Background Digit': np.int64(3), 'Calculated Signal Digits': [np.int64(1), np.int64(4), np.int64(8)], 'Expected Signal Digits': [np.int64(1), np.int64(4), np.int64(8)], 'Match': True}, 'Example 3': {'Background Digit': np.int64(4), 'Calculated Signal Digits': [np.int64(2), np.int64(3), np.int64(8)], 'Expected Signal Digits': [np.int64(2), np.int64(3), np.int64(8)], 'Match': True}, 'Example 4': {'Background Digit': np.int64(8), 'Calculated Signal Digits': [np.int64(3), np.int64(4)], 'Expected Signal Digits': [np.int64(3), np.int64(4)], 'Match': True}}

```
The metrics confirm that the logic for identifying the background digit (most frequent) and the signal digits (non-background, self-adjacent including diagonals) correctly matches the digits used to construct the output patterns in all training examples.

## YAML Facts


```yaml
Input:
  Type: 2D Grid (List of Lists)
  Element Type: Integer (Single Digit)
  Properties:
    - Contains a dominant "background" digit.
    - Contains other "foreground" digits.
    - Some foreground digits act as "signal" digits.
    - Some foreground digits act as "noise" digits.
    - Dimensions vary.

Output:
  Type: 2D Grid (List of Lists)
  Element Type: Integer (Single Digit)
  Properties:
    - Composed of stacked 6x6 patterns.
    - Each 6x6 pattern uses the input's background digit and one signal digit.
    - The 6x6 patterns have a fixed, identical structure (a frame shape).
    - Width is consistently 6.
    - Height is `6 * number_of_signal_digits`.

Transformation:
  Actions:
    1. Identify Background Digit: Find the most frequent digit in the input grid.
    2. Identify Signal Digits:
       - Find all unique digits in the input grid that are not the background digit.
       - Filter these candidates: keep only those digits where at least one instance is adjacent (horizontally, vertically, or diagonally) to another instance of the *same* digit. These are the signal digits.
    3. Sort Signal Digits: Arrange the identified signal digits in ascending numerical order.
    4. Generate Patterns: For each sorted signal digit:
       - Create a 6x6 grid.
       - Fill the grid with the background digit.
       - Overwrite specific cells with the current signal digit to form a fixed frame pattern:
         - Rows 0 & 5, Columns 0, 2, 3, 5
         - Rows 1 & 4, Columns 0, 1, 4, 5
         - Rows 2 & 3, Columns 0, 5
    5. Stack Patterns: Vertically concatenate the generated 6x6 patterns in the order determined by the sorted signal digits.
    6. Return Result: Output the final stacked grid.

Fixed Pattern Structure (6x6):
  - Uses Background (B) and Foreground (F = Signal Digit)
  - Layout:
    F B F F B F
    F F B B F F
    F B B B B F
    F B B B B F
    F F B B F F
    F B F F B F
```


## Natural Language Program

1.  Determine the **background digit**, which is the most frequently occurring digit in the input grid.
2.  Identify all unique digits present in the input grid that are *not* the background digit. These are candidate foreground digits.
3.  Filter the candidate foreground digits to find the **signal digits**: A digit is a signal digit if at least one instance of it in the input grid has another instance of the *same* digit as an immediate neighbor (horizontally, vertically, or diagonally).
4.  Sort the identified signal digits numerically in ascending order.
5.  For each signal digit in the sorted list:
    a.  Construct a 6x6 grid pattern.
    b.  Initialize the pattern by filling it entirely with the background digit.
    c.  Place the current signal digit into the pattern at the following (row, column) indices (0-based):
        *   (0,0), (0,2), (0,3), (0,5)
        *   (1,0), (1,1), (1,4), (1,5)
        *   (2,0), (2,5)
        *   (3,0), (3,5)
        *   (4,0), (4,1), (4,4), (4,5)
        *   (5,0), (5,2), (5,3), (5,5)
6.  Stack the generated 6x6 patterns vertically, maintaining the order established by the sorted signal digits.
7.  The resulting stacked grid is the final output. If no signal digits are found, the output is an empty grid.
