{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on identifying signal digits and generating fixed patterns.\n1. Determine the background digit (most frequent).\n2. Identify signal digits: non-background digits with at least one adjacent (including diagonal) neighbor of the same digit.\n3. Sort signal digits numerically.\n4. For each sorted signal digit, create a standard 6x6 pattern using it as foreground and the background digit. The pattern is a fixed frame shape.\n5. Stack these 6x6 patterns vertically in the sorted order of signal digits.\n6. Return the resulting stacked grid. If no signal digits are found, return an empty grid.\n\"\"\"\n\ndef _get_background_digit(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent digit in the grid.\"\"\"\n    if grid.size == 0:\n        # Should ideally not happen based on task constraints, but good practice.\n        raise ValueError(\"Input grid cannot be empty\") \n    counts = Counter(grid.flatten())\n    # Find the digit with the highest count\n    background_digit = counts.most_common(1)[0][0]\n    # Ensure standard Python int type, numpy ints can sometimes cause issues\n    return int(background_digit) \n\ndef _find_signal_digits(grid: np.ndarray, background_digit: int) -> list[int]:\n    \"\"\"Identifies signal digits based on self-adjacency (including diagonals).\"\"\"\n    rows, cols = grid.shape\n    unique_digits = np.unique(grid)\n    # Consider only digits that are not the background\n    candidate_digits = [int(d) for d in unique_digits if d != background_digit] \n    signal_digits = set()\n\n    # Define offsets for 8 neighbors (including diagonals)\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    # Iterate through each potential signal digit\n    for digit in candidate_digits:\n        # Find all locations (coordinates) of the current candidate digit\n        locations = np.argwhere(grid == digit)\n        is_signal = False\n        # Check neighbors for each location of the digit\n        for r, c in locations:\n            for dr, dc in neighbors:\n                nr, nc = r + dr, c + dc\n                # Check if the neighbor coordinate is within the grid bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if the neighbor has the same digit\n                    if grid[nr, nc] == digit:\n                        # Found adjacency, mark this digit as signal and stop checking for it\n                        signal_digits.add(digit)\n                        is_signal = True\n                        break # Stop checking neighbors for this location\n            if is_signal:\n                break # Stop checking locations for this digit\n\n    # Return the unique signal digits, sorted numerically\n    return sorted(list(signal_digits))\n\ndef _create_pattern_grid(foreground_digit: int, background_digit: int) -> np.ndarray:\n    \"\"\"Creates a standard 6x6 grid with the specified foreground/background pattern.\"\"\"\n    # Initialize a 6x6 grid filled with the background digit\n    pattern = np.full((6, 6), background_digit, dtype=int)\n    \n    # Define the coordinates for the foreground digit (the frame)\n    # Rows 0 & 5\n    pattern[0, [0, 2, 3, 5]] = foreground_digit\n    pattern[5, [0, 2, 3, 5]] = foreground_digit\n    # Rows 1 & 4\n    pattern[1, [0, 1, 4, 5]] = foreground_digit\n    pattern[4, [0, 1, 4, 5]] = foreground_digit\n    # Rows 2 & 3\n    pattern[2, [0, 5]] = foreground_digit\n    pattern[3, [0, 5]] = foreground_digit\n    \n    return pattern\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid case\n    if input_array.size == 0:\n        return [] \n\n    # Step 1: Identify the background digit (most frequent)\n    background_digit = _get_background_digit(input_array)\n\n    # Step 2 & 3: Identify and sort signal digits (non-background, self-adjacent)\n    signal_digits = _find_signal_digits(input_array, background_digit)\n\n    # Step 4 & 5: Generate patterns for each signal digit and prepare for stacking\n    output_patterns = []\n    if not signal_digits:\n        # If no signal digits are found, return an empty list\n        return [] \n\n    for fg_digit in signal_digits:\n        # Create the standard 6x6 pattern for the current signal digit\n        pattern_grid = _create_pattern_grid(fg_digit, background_digit)\n        output_patterns.append(pattern_grid)\n\n    # Step 6: Stack the generated patterns vertically\n    # vstack requires at least one array, handled by the check for empty signal_digits\n    output_grid_np = np.vstack(output_patterns)\n\n    # Step 7: Convert the final numpy array back to a list of lists for the expected output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13029,
    "candidates_token_count": 1711,
    "total_token_count": 14740,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.838664,
  "retries": 1
}