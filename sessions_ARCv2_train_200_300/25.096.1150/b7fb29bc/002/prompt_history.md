
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 3 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 2 4 4 4 2 4 3 0 0 0
0 0 0 3 4 2 4 3 4 2 4 3 0 0 0
0 0 0 3 4 2 4 4 4 2 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 3 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 2 2 2 2 2 2 4 3 0 0 0
0 0 0 3 4 4 4 4 4 2 4 3 0 0 0
0 0 0 3 2 2 2 2 4 2 4 3 0 0 0
0 0 0 3 4 4 4 2 4 2 4 3 0 0 0
0 0 0 3 4 3 4 2 4 2 4 3 0 0 0
0 0 0 3 4 4 4 2 4 2 4 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 0 0 0 0 0 3 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 0 0 0 0 0 0 0 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 3 4 2 4 2 4 3 4 3 0 0 0
0 0 0 3 4 2 4 2 4 4 4 3 0 0 0
0 0 0 3 4 2 4 2 2 2 2 3 0 0 0
0 0 0 3 4 2 4 4 4 4 4 3 0 0 0
0 0 0 3 4 2 2 2 2 2 2 3 0 0 0
0 0 0 3 4 4 4 4 4 4 4 3 0 0 0
0 0 0 3 2 2 2 2 2 2 2 3 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## Perception

The input and output are both 15x15 grids containing integer values.
The core structure in the input is a rectangular frame defined by the value 3, located consistently across examples (rows 2-10, columns 3-11).
Inside this frame, the input grid contains 0s and potentially some additional 3s which act as internal "obstacles" or "walls". The positions of these internal 3s vary between examples.
The output grid preserves the external 0s, the outer frame of 3s, and the internal obstacles (3s).
The transformation focuses on the cells within the outer frame that originally contained 0 in the input.
These internal 0s are replaced by either 2 or 4 in the output.
The value 4 is assigned to cells that were originally 0 but are orthogonally adjacent (sharing an edge) to any cell containing a 3 (either the outer frame or an internal obstacle).
The value 2 is assigned to cells that were originally 0 and are *not* orthogonally adjacent to any cell containing a 3.

## Facts


```yaml
objects:
  - id: grid
    description: A 2D array of integers representing the input and output state.
  - id: frame
    description: A rectangular boundary within the grid defined by cells with value 3.
    properties:
      - value: 3
      - location: Consistent across examples (rows 2-10, columns 3-11).
  - id: obstacle
    description: Cells with value 3 located inside the boundary defined by the frame.
    properties:
      - value: 3
      - location: Varies between examples, always within the frame boundary.
  - id: background
    description: Cells with value 0 located outside the frame boundary.
    properties:
      - value: 0
  - id: internal_empty_cell
    description: Cells with value 0 located inside the frame boundary in the input grid.
    properties:
      - value: 0
  - id: fill_cell_type_4
    description: Cells in the output grid corresponding to internal_empty_cells that are adjacent to a frame or obstacle cell.
    properties:
      - value: 4
  - id: fill_cell_type_2
    description: Cells in the output grid corresponding to internal_empty_cells that are not adjacent to any frame or obstacle cell.
    properties:
      - value: 2

relationships:
  - type: containment
    description: Obstacles and internal_empty_cells are contained within the frame.
  - type: adjacency
    description: Orthogonal adjacency (up, down, left, right) between cells. Key for determining fill value.
  - type: transformation
    description: internal_empty_cells are transformed into fill_cell_type_4 or fill_cell_type_2 based on adjacency to frame or obstacle cells.

actions:
  - id: identify_frame_region
    description: Determine the area enclosed by the outer frame of 3s.
  - id: check_adjacency
    description: For each internal_empty_cell, check its orthogonal neighbors in the input grid.
  - id: assign_value
    description: Assign 4 if adjacent to any 3, assign 2 otherwise.
  - id: copy_unmodified
    description: Copy background cells, frame cells, and obstacle cells directly from input to output.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Iterate through each cell (`R`, `C`) of the input grid within the boundaries defined by the outer frame (specifically, for rows `r` from 3 to 9 and columns `c` from 4 to 10, check cells `input[r][c]`).
3.  For each cell `(r, c)` within this inner region:
    a.  Check if the value of the cell in the *input* grid `input[r][c]` is 0.
    b.  If it is 0, check its four orthogonal neighbors in the *input* grid: `input[r-1][c]`, `input[r+1][c]`, `input[r][c-1]`, `input[r][c+1]`.
    c.  If *any* of these neighbors has the value 3, set the corresponding cell in the *output* grid `output[r][c]` to 4.
    d.  If *none* of these neighbors has the value 3, set the corresponding cell in the *output* grid `output[r][c]` to 2.
4.  Cells outside this inner region, and cells within the region that were not originally 0 (i.e., the frame cells and internal obstacles), remain unchanged from their input values (already handled by initializing the output as a copy).
5.  Return the modified output grid.
```python
import copy

"""
Transforms an input grid based on the following rules:
1. Initialize the output grid as a copy of the input grid.
2. Iterate through the cells within the inner region defined by the outer frame (rows 3-9, columns 4-10).
3. If a cell in the input grid within this region is 0:
    a. Check its four orthogonal neighbors (up, down, left, right) in the input grid.
    b. If any neighbor has the value 3, set the corresponding cell in the output grid to 4.
    c. Otherwise (if none of the neighbors have the value 3), set the corresponding cell in the output grid to 2.
4. Cells outside this inner region, frame cells (value 3), and internal obstacle cells (value 3) remain unchanged.
5. Return the modified output grid.
"""

def check_neighbors_for_value(grid: list[list[int]], r: int, c: int, value: int) -> bool:
    """
    Checks if any orthogonal neighbor of grid[r][c] has the specified value.

    Args:
        grid: The input grid.
        r: Row index of the cell.
        c: Column index of the cell.
        value: The value to check for in neighbors.

    Returns:
        True if any neighbor has the value, False otherwise.
    """
    rows = len(grid)
    cols = len(grid[0])
    neighbors = []
    # Check up
    if r > 0:
        neighbors.append(grid[r-1][c])
    # Check down
    if r < rows - 1:
        neighbors.append(grid[r+1][c])
    # Check left
    if c > 0:
        neighbors.append(grid[r][c-1])
    # Check right
    if c < cols - 1:
        neighbors.append(grid[r][c+1])

    return value in neighbors

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    Fills internal '0' cells with '2' or '4' based on adjacency to '3' cells.
    """
    # Initialize output_grid as a deep copy of the input grid
    output_grid = copy.deepcopy(input_grid)
    rows = len(input_grid)
    cols = len(input_grid[0])

    # Determine the bounds of the inner region to check
    # Based on examples, the outer frame uses rows 2-10 and cols 3-11.
    # The inner region where 0s can be replaced is rows 3-9 and cols 4-10.
    min_row, max_row = 3, 9  # Inclusive range for rows to potentially change
    min_col, max_col = 4, 10 # Inclusive range for columns to potentially change

    # Iterate through each cell potentially inside the frame
    for r in range(min_row, max_row + 1):
        # Check row bounds just in case grid size varies, although examples are fixed
        if r >= rows: continue 
        for c in range(min_col, max_col + 1):
             # Check col bounds
            if c >= cols: continue

            # Check if the cell in the *input* grid is an internal empty cell (value 0)
            if input_grid[r][c] == 0:
                # Check its orthogonal neighbors in the *input* grid for the value 3
                if check_neighbors_for_value(input_grid, r, c, 3):
                    # If any neighbor is 3, set the output cell to 4
                    output_grid[r][c] = 4
                else:
                    # If no neighbor is 3, set the output cell to 2
                    output_grid[r][c] = 2
            # If input_grid[r][c] is not 0 (e.g., it's a 3 - part of frame or obstacle), 
            # it remains unchanged because output_grid was initialized as a copy.

    # Cells outside the iterated range (r, c) also remain unchanged.
    return output_grid
```
