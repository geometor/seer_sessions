
## train_1

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 4 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 4 4 4 4 7 7 7 7 7
7 7 7 7 7 7 7 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 4 4 4 4 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 1 1 1 1 1 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


## train_2

**input:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 9 9 9 5 9 9 9 9 9 9 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```


**output:**
```
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 9 9 9 9 9 9 9 9 9 9 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 5 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
```

*   **Perception:** The task involves transforming a 2D grid of digits based on the interaction of shapes within the grid. The input grids contain simple geometric shapes (rectangles, lines) drawn with distinct digits (colors) on a uniform background digit (color 7). Where these shapes overlap or intersect, a color change occurs in the output grid. Specifically, the color of a cell at the intersection point is flipped to the color of the *other* shape involved in the intersection.

*   **YAML Facts:**
    
```yaml
    task_type: grid_transformation
    grid_properties:
      - dimensions: 16x16
      - cell_content: single digits (0-9)
      - background_color: 7 (most frequent color)
    objects:
      - type: shape
        properties:
          - color: non-background digit
          - form: contiguous region (rectangle, line)
          - location: set of coordinates
    relationships:
      - type: intersection / overlap
        between: two distinct shapes (S1, S2)
        location: set of coordinates common to both S1 and S2
    actions:
      - identify: background_color
      - identify: shapes (color, coordinates)
      - compute: intersection coordinates between pairs of shapes
      - modify: grid cells
        conditions:
          - cell is within an intersection region of shape S1 (color C1) and shape S2 (color C2)
        effect:
          - if input_color(cell) == C1, output_color(cell) = C2
          - if input_color(cell) == C2, output_color(cell) = C1
    ```


*   **Natural Language Program:**
    1.  Identify the background color (digit 7) in the input grid.
    2.  Identify all distinct contiguous shapes formed by non-background colors. For each shape, record its color (C) and the set of grid coordinates it occupies.
    3.  Create a copy of the input grid to serve as the initial output grid.
    4.  Find all pairs of distinct shapes (Shape1 with color C1, Shape2 with color C2) that intersect or overlap.
    5.  Determine the set of coordinates where Shape1 and Shape2 intersect (i.e., the coordinates occupied by both shapes).
    6.  For each coordinate `(r, c)` in the intersection set:
        *   Check the color of this cell in the *input* grid.
        *   If `input[r][c]` is equal to C1, change the color of the cell `(r, c)` in the *output* grid to C2.
        *   If `input[r][c]` is equal to C2, change the color of the cell `(r, c)` in the *output* grid to C1.
    7.  Return the modified output grid.
```python
import collections
import copy

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Identifies distinct contiguous shapes (non-background color 7) in the input grid.
    For each pair of intersecting shapes (Shape1 of color C1, Shape2 of color C2),
    it finds the intersection coordinates.
    At each intersection coordinate (r, c), if the original color input_grid[r][c] was C1,
    the output_grid[r][c] is changed to C2. If the original color was C2, the
    output_grid[r][c] is changed to C1. Cells not part of any intersection
    retain their original color.
    """

    # Helper function to find connected components (shapes)
    def find_shapes(grid, background_color):
        rows = len(grid)
        cols = len(grid[0])
        visited = set()
        shapes = []

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] != background_color and (r, c) not in visited:
                    color = grid[r][c]
                    current_shape_coords = set()
                    queue = collections.deque([(r, c)])
                    visited.add((r, c))

                    while queue:
                        row, col = queue.popleft()
                        current_shape_coords.add((row, col))

                        # Check neighbors (up, down, left, right)
                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                            nr, nc = row + dr, col + dc
                            if 0 <= nr < rows and 0 <= nc < cols and \
                               (nr, nc) not in visited and \
                               grid[nr][nc] == color:
                                visited.add((nr, nc))
                                queue.append((nr, nc))

                    if current_shape_coords:
                        shapes.append({'color': color, 'coords': current_shape_coords})
        return shapes

    # Initialize output_grid as a deep copy of the input
    output_grid = [row[:] for row in input_grid]
    rows = len(input_grid)
    cols = len(input_grid[0])
    background_color = 7 # Based on observations

    # 1. Identify shapes
    shapes = find_shapes(input_grid, background_color)

    # 2. Find intersections between all pairs of shapes
    intersections = []
    num_shapes = len(shapes)
    for i in range(num_shapes):
        for j in range(i + 1, num_shapes):
            shape1 = shapes[i]
            shape2 = shapes[j]

            # Calculate intersection coordinates
            intersection_coords = shape1['coords'].intersection(shape2['coords'])

            if intersection_coords:
                intersections.append({
                    'coords': intersection_coords,
                    'shape1_color': shape1['color'],
                    'shape2_color': shape2['color']
                })

    # 3. Modify the output grid based on intersections
    for intersection in intersections:
        c1 = intersection['shape1_color']
        c2 = intersection['shape2_color']
        for r, c in intersection['coords']:
            original_color = input_grid[r][c]
            # Apply the color swap rule
            if original_color == c1:
                output_grid[r][c] = c2
            elif original_color == c2:
                 output_grid[r][c] = c1
            # Else (e.g., if somehow a background cell was included, though unlikely with this logic)
            # keep the original color from the copy, which is input_grid[r][c]

    return output_grid
```
