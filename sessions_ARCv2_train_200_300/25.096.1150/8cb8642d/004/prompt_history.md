
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 1 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 2 1 0 0 0 0 1 2 0 0 0 0 0 0
0 2 0 1 0 0 1 0 2 0 0 0 0 0 0
0 2 0 0 1 1 0 0 2 0 0 0 0 0 0
0 2 0 1 0 0 1 0 2 0 0 0 0 0 0
0 2 1 0 0 0 0 1 2 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 6 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 6 0 0 0 0 0 6 3 0 0 0
0 0 3 0 6 0 0 0 6 0 3 0 0 0
0 0 3 0 0 6 0 6 0 0 3 0 0 0
0 0 3 0 0 0 6 0 0 0 3 0 0 0
0 0 3 0 0 0 6 0 0 0 3 0 0 0
0 0 3 0 0 6 0 6 0 0 3 0 0 0
0 0 3 0 6 0 0 0 6 0 3 0 0 0
0 0 3 6 0 0 0 0 0 6 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 2 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 2 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 3 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 3 3 3 3 3 3 0
0 0 1 2 0 0 0 2 1 0 0 3 2 0 0 2 3 0
0 0 1 0 2 0 2 0 1 0 0 3 0 2 2 0 3 0
0 0 1 0 0 2 0 0 1 0 0 3 0 2 2 0 3 0
0 0 1 0 2 0 2 0 1 0 0 3 2 0 0 2 3 0
0 0 1 2 0 0 0 2 1 0 0 3 3 3 3 3 3 0
0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 3 4 0
0 0 0 0 0 0 4 0 3 0 0 0 0 0 3 0 4 0
0 0 0 0 0 0 4 0 0 3 3 3 3 3 0 0 4 0
0 0 0 0 0 0 4 0 3 0 0 0 0 0 3 0 4 0
0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 3 4 0
0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples to understand the transformation.

**Perception of Elements:**

1.  **Grid Structure:** The input and output are both 2D grids of integers.
2.  **Background:** The value 0 consistently represents the background or empty space, which remains unchanged in the transformation.
3.  **Objects/Regions:** The non-zero numbers form distinct connected regions. These regions appear mostly uniform in color, except for one unique cell.
4.  **Region Color (C):** Within each non-zero region, there's a predominant color (e.g., 2 in `train_1`, 3 in `train_2`, 1, 3, 4 in `train_3`).
5.  **Seed Cell:** Each region contains exactly one cell whose color (let's call it `S`) is different from the predominant color `C` of that region. This cell acts as a 'seed' or 'origin' for the transformation within its region.
6.  **Boundary:** The outermost layer of cells in each region (those adjacent to the background 0s) appears to retain its original color `C` in the output.
7.  **Interior:** The cells inside the boundary, excluding the seed cell, undergo a change.
8.  **Pattern:** The change inside the region follows a pattern based on the Manhattan distance (`d = |row_diff| + |col_diff|`) from the seed cell's location `(r_s, c_s)`.
    *   The seed cell itself becomes 0 in the output.
    *   Interior cells at an odd Manhattan distance (`d % 2 == 1`) from the seed become 0.
    *   Interior cells at an even, non-zero Manhattan distance (`d > 0 and d % 2 == 0`) from the seed take on the seed color `S`.

**Facts (YAML):**


```yaml
Grid:
  Type: 2D array of integers
  BackgroundValue: 0

Region:
  Definition: Connected component of non-zero cells
  Properties:
    - ComponentColor (C): Most frequent non-zero value in the region
    - SeedCell:
        Exists: True (one per region)
        Color (S): Value different from ComponentColor C
        Location (r_s, c_s): Coordinates of the SeedCell
    - BoundaryCells: Cells in the region adjacent (8-connectivity) to BackgroundValue 0
    - InteriorCells: Cells in the region that are not BoundaryCells and not the SeedCell

Transformation:
  Scope: Applies independently to each Region
  Unaffected:
    - BackgroundCells (value 0)
    - BoundaryCells (retain ComponentColor C)
  Affected:
    - SeedCell: Output value becomes 0
    - InteriorCells:
        Action: Calculate Manhattan distance 'd' from SeedCell location (r_s, c_s)
        Rule:
          - If d is odd: Output value becomes 0
          - If d is even and d > 0: Output value becomes SeedColor S
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify all distinct connected regions of non-zero cells in the input grid.
3.  For each identified region:
    a.  Determine the most frequent non-zero color within the region; this is the Component Color `C`.
    b.  Find the single cell within the region whose color is not `C`; this is the Seed Color `S`, located at `(r_s, c_s)`.
    c.  Identify the set of Boundary Cells: those cells within the current region that have at least one neighbor (up, down, left, right, or diagonal) with the background value (0).
    d.  Iterate through each cell `(r, c)` belonging to the current region.
    e.  If the cell `(r, c)` is the Seed Cell `(r_s, c_s)`:
        i.  Set the value of `output[r, c]` to 0.
    f.  Else if the cell `(r, c)` is *not* a Boundary Cell:
        i.  Calculate the Manhattan distance `d = |r - r_s| + |c - c_s|`.
        ii. If `d` is odd, set the value of `output[r, c]` to 0.
        iii. If `d` is even (and `d > 0` implicitly, as `d=0` is the seed cell case), set the value of `output[r, c]` to the Seed Color `S`.
    g.  Else (the cell `(r, c)` is a Boundary Cell and not the Seed Cell):
        i.  Leave the value `output[r, c]` unchanged (it remains `C` from the initial copy).
4.  Return the modified output grid.
```python
"""
Transforms an input grid based on connected regions of non-zero numbers.

1. Identifies connected regions of non-zero cells (8-way connectivity).
2. For each region:
   a. Finds the predominant color (C) and the single different 'seed' color (S) and its location (r_s, c_s).
   b. Identifies boundary cells (region cells adjacent to 0s).
   c. Modifies the region in the output grid:
      - The seed cell becomes 0.
      - Boundary cells remain unchanged (keep color C).
      - Interior cells (not seed, not boundary) change based on Manhattan distance 'd' from the seed:
         - If 'd' is odd, the cell becomes 0.
         - If 'd' is even (and > 0), the cell becomes the seed color S.
3. Cells with value 0 remain unchanged.
"""

import numpy as np
from scipy.ndimage import label, find_objects
from collections import Counter

def get_neighbors(r, c, rows, cols):
    """Generates coordinates of 8 neighbors for a cell (r, c)."""
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                yield nr, nc

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the described transformation to the input grid.

    Args:
        input_grid: A list of lists representing the 2D input grid.

    Returns:
        A list of lists representing the transformed 2D output grid.
    """
    # Convert to numpy array for easier processing
    input_array = np.array(input_grid, dtype=int)
    output_array = np.copy(input_array)
    rows, cols = input_array.shape

    # Define the structure for 8-way connectivity
    connectivity_structure = np.ones((3, 3), dtype=bool)

    # Find connected components (regions) of non-zero cells
    labeled_array, num_features = label(input_array > 0, structure=connectivity_structure)

    # Iterate through each found region
    for region_label in range(1, num_features + 1):
        # Get coordinates of cells in the current region
        region_coords = np.argwhere(labeled_array == region_label)
        if len(region_coords) == 0:
            continue # Should not happen with label starting from 1

        # Get the values of cells in the region
        region_values = [input_array[r, c] for r, c in region_coords]

        # Find Component Color (C) and Seed Color (S)
        if not region_values:
             continue # Skip empty regions if any

        value_counts = Counter(region_values)
        if len(value_counts) < 2:
             # Region has only one color type - might be just boundary? Or only seed?
             # Based on examples, seems regions always have C and S.
             # If it's all one color, maybe no transformation needed?
             # Let's assume the problem guarantees distinct C and S.
             # If a region has only one cell, it's both seed and boundary? Let's test.
             # In train_1, the single 1 is seed, it becomes 0. It's not boundary.
             # If the region is just [1], C=None, S=1. Seed becomes 0. Rule works.
             # If the region is [2, 2, 2], C=2, S=None. No seed? This shouldn't happen per problem description.
             # Let's proceed assuming len(value_counts) >= 1. If len==1, that value is S. If len > 1, find C and S.
             if len(value_counts) == 1:
                 seed_color = region_values[0]
                 component_color = None # No component color if only seed exists
             else:
                 # Most common is component color C
                 component_color = value_counts.most_common(1)[0][0]
                 # Find the seed color S (the one that's not C)
                 seed_color = None
                 for val in value_counts:
                     if val != component_color:
                         seed_color = val
                         break
                 if seed_color is None: # Should not happen if len(value_counts) >= 2
                      continue

        # Find Seed Cell location (r_s, c_s)
        seed_coords = None
        for r, c in region_coords:
            if input_array[r, c] == seed_color:
                seed_coords = (r, c)
                break
        
        if seed_coords is None: # Should not happen if seed_color was found
             continue
        r_s, c_s = seed_coords

        # Identify boundary cells for this region
        boundary_cells = set()
        for r, c in region_coords:
            is_boundary = False
            for nr, nc in get_neighbors(r, c, rows, cols):
                # Check if neighbor is outside region (either 0 or belongs to another region)
                if labeled_array[nr, nc] != region_label: # Check against labeled array
                     # Special check for background: ensure the neighbour is truly 0 in input
                     if input_array[nr,nc] == 0:
                          is_boundary = True
                          break # Found a zero neighbor, it's a boundary cell
            if is_boundary:
                boundary_cells.add((r, c))

        # Apply transformation rules to cells in the region
        for r, c in region_coords:
            # Rule 1: Seed cell becomes 0
            if (r, c) == seed_coords:
                output_array[r, c] = 0
            # Rule 2: Boundary cells remain unchanged (already copied)
            elif (r, c) in boundary_cells:
                # output_array[r, c] = component_color # Already holds this value from copy
                pass # No change needed
            # Rule 3: Interior cells change based on Manhattan distance
            else:
                manhattan_distance = abs(r - r_s) + abs(c - c_s)
                if manhattan_distance % 2 == 1: # Odd distance
                    output_array[r, c] = 0
                else: # Even distance (and > 0, since seed case handled)
                    output_array[r, c] = seed_color

    # Convert back to list of lists
    return output_array.tolist()

```
```python
import numpy as np
from scipy.ndimage import label
from collections import Counter

def get_neighbors(r, c, rows, cols):
    """Generates coordinates of 8 neighbors for a cell (r, c) within grid bounds."""
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                yield nr, nc

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the grid by identifying non-zero connected regions.
    For regions containing exactly two distinct non-zero colors (a common 'component'
    color C and a unique 'seed' color S), it applies a pattern based on the
    Manhattan distance from the seed cell:
    1. The seed cell becomes 0.
    2. Boundary cells (adjacent to background 0s) remain unchanged (color C).
    3. Interior cells become 0 if their Manhattan distance from the seed is odd.
    4. Interior cells become the seed color S if their Manhattan distance from the
       seed is even and positive.
    Regions with only one distinct non-zero color or only background cells (0)
    remain unchanged.
    """
    # Convert to numpy array for efficient processing
    input_array = np.array(input_grid, dtype=int)
    # Initialize output_grid as a copy of the input
    output_array = np.copy(input_array)
    rows, cols = input_array.shape

    # Define the structure for 8-way connectivity (including diagonals)
    connectivity_structure = np.ones((3, 3), dtype=bool)

    # Find connected components (regions) of non-zero cells
    # labeled_array assigns a unique integer label to each connected region
    # num_features is the total number of regions found (including background if not excluded)
    labeled_array, num_features = label(input_array > 0, structure=connectivity_structure)

    # Iterate through each found region (labels start from 1)
    for region_label in range(1, num_features + 1):
        # Get coordinates of all cells belonging to the current region
        region_coords = np.argwhere(labeled_array == region_label)
        if len(region_coords) == 0:
            continue # Skip if region is somehow empty

        # Get the integer values of cells within this region from the original input
        region_values = [input_array[r, c] for r, c in region_coords]

        # Count the frequency of each distinct value in the region
        value_counts = Counter(region_values)

        # Transformation rule only applies if there are exactly two distinct non-zero values
        if len(value_counts) < 2:
            # If only one color, or some error, leave this region unchanged and move to the next
            continue

        # Identify Component Color (C) - the most frequent color
        # Identify Seed Color (S) - the other color (less frequent)
        # Assumes exactly two colors based on problem description and examples
        component_color = value_counts.most_common(1)[0][0]
        seed_color = None
        for val in value_counts:
            if val != component_color:
                seed_color = val
                break
        
        # If for some reason a distinct seed color wasn't found (e.g., >2 colors), skip
        if seed_color is None:
             continue

        # Find the location (coordinates) of the Seed Cell (r_s, c_s)
        seed_coords = None
        for r, c in region_coords:
            if input_array[r, c] == seed_color:
                seed_coords = (r, c)
                break

        # If seed coordinates couldn't be found (shouldn't happen if seed_color exists), skip
        if seed_coords is None:
             continue
        r_s, c_s = seed_coords

        # Identify Boundary Cells for this region
        # Boundary cells are cells within the region adjacent (8-way) to a background cell (0)
        boundary_cells = set()
        for r, c in region_coords:
            is_boundary = False
            # Check all 8 neighbors
            for nr, nc in get_neighbors(r, c, rows, cols):
                # If a neighbor is background (value 0 in the original input), this cell is boundary
                if input_array[nr, nc] == 0:
                    is_boundary = True
                    break # Found a zero neighbor, no need to check others
            if is_boundary:
                boundary_cells.add((r, c))

        # Apply transformation rules to cells within this region
        for r, c in region_coords:
            current_coords = (r, c)

            # Rule 1: Seed cell becomes 0
            if current_coords == seed_coords:
                output_array[r, c] = 0
            # Rule 2: Boundary cells remain unchanged (they keep Component Color C)
            elif current_coords in boundary_cells:
                # No change needed, output_array already has the copied value
                pass
            # Rule 3: Interior cells (not seed, not boundary) change based on Manhattan distance
            else:
                manhattan_distance = abs(r - r_s) + abs(c - c_s)
                # Rule 3a: Odd distance -> become 0
                if manhattan_distance % 2 == 1:
                    output_array[r, c] = 0
                # Rule 3b: Even positive distance -> become Seed Color S
                else: # Distance is even and > 0 (since d=0 is the seed cell case)
                    output_array[r, c] = seed_color

    # Convert the final numpy array back to a list of lists
    return output_array.tolist()
```
