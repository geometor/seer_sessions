{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on connected regions of non-zero numbers.\n\n1. Identifies connected regions of non-zero cells (8-way connectivity).\n2. For each region:\n   a. Finds the predominant color (C) and the single different 'seed' color (S) and its location (r_s, c_s).\n   b. Identifies boundary cells (region cells adjacent to 0s).\n   c. Modifies the region in the output grid:\n      - The seed cell becomes 0.\n      - Boundary cells remain unchanged (keep color C).\n      - Interior cells (not seed, not boundary) change based on Manhattan distance 'd' from the seed:\n         - If 'd' is odd, the cell becomes 0.\n         - If 'd' is even (and > 0), the cell becomes the seed color S.\n3. Cells with value 0 remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\"Generates coordinates of 8 neighbors for a cell (r, c).\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the 2D input grid.\n\n    Returns:\n        A list of lists representing the transformed 2D output grid.\n    \"\"\"\n    # Convert to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # Define the structure for 8-way connectivity\n    connectivity_structure = np.ones((3, 3), dtype=bool)\n\n    # Find connected components (regions) of non-zero cells\n    labeled_array, num_features = label(input_array > 0, structure=connectivity_structure)\n\n    # Iterate through each found region\n    for region_label in range(1, num_features + 1):\n        # Get coordinates of cells in the current region\n        region_coords = np.argwhere(labeled_array == region_label)\n        if len(region_coords) == 0:\n            continue # Should not happen with label starting from 1\n\n        # Get the values of cells in the region\n        region_values = [input_array[r, c] for r, c in region_coords]\n\n        # Find Component Color (C) and Seed Color (S)\n        if not region_values:\n             continue # Skip empty regions if any\n\n        value_counts = Counter(region_values)\n        if len(value_counts) < 2:\n             # Region has only one color type - might be just boundary? Or only seed?\n             # Based on examples, seems regions always have C and S.\n             # If it's all one color, maybe no transformation needed?\n             # Let's assume the problem guarantees distinct C and S.\n             # If a region has only one cell, it's both seed and boundary? Let's test.\n             # In train_1, the single 1 is seed, it becomes 0. It's not boundary.\n             # If the region is just [1], C=None, S=1. Seed becomes 0. Rule works.\n             # If the region is [2, 2, 2], C=2, S=None. No seed? This shouldn't happen per problem description.\n             # Let's proceed assuming len(value_counts) >= 1. If len==1, that value is S. If len > 1, find C and S.\n             if len(value_counts) == 1:\n                 seed_color = region_values[0]\n                 component_color = None # No component color if only seed exists\n             else:\n                 # Most common is component color C\n                 component_color = value_counts.most_common(1)[0][0]\n                 # Find the seed color S (the one that's not C)\n                 seed_color = None\n                 for val in value_counts:\n                     if val != component_color:\n                         seed_color = val\n                         break\n                 if seed_color is None: # Should not happen if len(value_counts) >= 2\n                      continue\n\n        # Find Seed Cell location (r_s, c_s)\n        seed_coords = None\n        for r, c in region_coords:\n            if input_array[r, c] == seed_color:\n                seed_coords = (r, c)\n                break\n        \n        if seed_coords is None: # Should not happen if seed_color was found\n             continue\n        r_s, c_s = seed_coords\n\n        # Identify boundary cells for this region\n        boundary_cells = set()\n        for r, c in region_coords:\n            is_boundary = False\n            for nr, nc in get_neighbors(r, c, rows, cols):\n                # Check if neighbor is outside region (either 0 or belongs to another region)\n                if labeled_array[nr, nc] != region_label: # Check against labeled array\n                     # Special check for background: ensure the neighbour is truly 0 in input\n                     if input_array[nr,nc] == 0:\n                          is_boundary = True\n                          break # Found a zero neighbor, it's a boundary cell\n            if is_boundary:\n                boundary_cells.add((r, c))\n\n        # Apply transformation rules to cells in the region\n        for r, c in region_coords:\n            # Rule 1: Seed cell becomes 0\n            if (r, c) == seed_coords:\n                output_array[r, c] = 0\n            # Rule 2: Boundary cells remain unchanged (already copied)\n            elif (r, c) in boundary_cells:\n                # output_array[r, c] = component_color # Already holds this value from copy\n                pass # No change needed\n            # Rule 3: Interior cells change based on Manhattan distance\n            else:\n                manhattan_distance = abs(r - r_s) + abs(c - c_s)\n                if manhattan_distance % 2 == 1: # Odd distance\n                    output_array[r, c] = 0\n                else: # Even distance (and > 0, since seed case handled)\n                    output_array[r, c] = seed_color\n\n    # Convert back to list of lists\n    return output_array.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4227,
    "candidates_token_count": 2259,
    "total_token_count": 6486,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.117846,
  "retries": 1
}