{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom collections import Counter\n\ndef get_neighbors(r, c, rows, cols):\n    \"\"\"Generates coordinates of 8 neighbors for a cell (r, c) within grid bounds.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the grid by identifying non-zero connected regions.\n    For regions containing exactly two distinct non-zero colors (a common 'component'\n    color C and a unique 'seed' color S), it applies a pattern based on the\n    Manhattan distance from the seed cell:\n    1. The seed cell becomes 0.\n    2. Boundary cells (adjacent to background 0s) remain unchanged (color C).\n    3. Interior cells become 0 if their Manhattan distance from the seed is odd.\n    4. Interior cells become the seed color S if their Manhattan distance from the\n       seed is even and positive.\n    Regions with only one distinct non-zero color or only background cells (0)\n    remain unchanged.\n    \"\"\"\n    # Convert to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_array = np.copy(input_array)\n    rows, cols = input_array.shape\n\n    # Define the structure for 8-way connectivity (including diagonals)\n    connectivity_structure = np.ones((3, 3), dtype=bool)\n\n    # Find connected components (regions) of non-zero cells\n    # labeled_array assigns a unique integer label to each connected region\n    # num_features is the total number of regions found (including background if not excluded)\n    labeled_array, num_features = label(input_array > 0, structure=connectivity_structure)\n\n    # Iterate through each found region (labels start from 1)\n    for region_label in range(1, num_features + 1):\n        # Get coordinates of all cells belonging to the current region\n        region_coords = np.argwhere(labeled_array == region_label)\n        if len(region_coords) == 0:\n            continue # Skip if region is somehow empty\n\n        # Get the integer values of cells within this region from the original input\n        region_values = [input_array[r, c] for r, c in region_coords]\n\n        # Count the frequency of each distinct value in the region\n        value_counts = Counter(region_values)\n\n        # Transformation rule only applies if there are exactly two distinct non-zero values\n        if len(value_counts) < 2:\n            # If only one color, or some error, leave this region unchanged and move to the next\n            continue\n\n        # Identify Component Color (C) - the most frequent color\n        # Identify Seed Color (S) - the other color (less frequent)\n        # Assumes exactly two colors based on problem description and examples\n        component_color = value_counts.most_common(1)[0][0]\n        seed_color = None\n        for val in value_counts:\n            if val != component_color:\n                seed_color = val\n                break\n        \n        # If for some reason a distinct seed color wasn't found (e.g., >2 colors), skip\n        if seed_color is None:\n             continue\n\n        # Find the location (coordinates) of the Seed Cell (r_s, c_s)\n        seed_coords = None\n        for r, c in region_coords:\n            if input_array[r, c] == seed_color:\n                seed_coords = (r, c)\n                break\n\n        # If seed coordinates couldn't be found (shouldn't happen if seed_color exists), skip\n        if seed_coords is None:\n             continue\n        r_s, c_s = seed_coords\n\n        # Identify Boundary Cells for this region\n        # Boundary cells are cells within the region adjacent (8-way) to a background cell (0)\n        boundary_cells = set()\n        for r, c in region_coords:\n            is_boundary = False\n            # Check all 8 neighbors\n            for nr, nc in get_neighbors(r, c, rows, cols):\n                # If a neighbor is background (value 0 in the original input), this cell is boundary\n                if input_array[nr, nc] == 0:\n                    is_boundary = True\n                    break # Found a zero neighbor, no need to check others\n            if is_boundary:\n                boundary_cells.add((r, c))\n\n        # Apply transformation rules to cells within this region\n        for r, c in region_coords:\n            current_coords = (r, c)\n\n            # Rule 1: Seed cell becomes 0\n            if current_coords == seed_coords:\n                output_array[r, c] = 0\n            # Rule 2: Boundary cells remain unchanged (they keep Component Color C)\n            elif current_coords in boundary_cells:\n                # No change needed, output_array already has the copied value\n                pass\n            # Rule 3: Interior cells (not seed, not boundary) change based on Manhattan distance\n            else:\n                manhattan_distance = abs(r - r_s) + abs(c - c_s)\n                # Rule 3a: Odd distance -> become 0\n                if manhattan_distance % 2 == 1:\n                    output_array[r, c] = 0\n                # Rule 3b: Even positive distance -> become Seed Color S\n                else: # Distance is even and > 0 (since d=0 is the seed cell case)\n                    output_array[r, c] = seed_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11552,
    "candidates_token_count": 2201,
    "total_token_count": 13753,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.164256,
  "retries": 1
}