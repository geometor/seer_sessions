
## train_1

**input:**
```
0 0 0 0 0 0 0 0 2 2 0 0 0 2 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0 2 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 2 2 3 0 3 2 3 0
2 0 0 0 0 0 0 3 3 3 3 0 3 2 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 2 0 0 0 0 0 3 3
0 0 2 0 0 0 0 0 0 0 2 0 0 2 3 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2
0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 3
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0 0 0
0 0 2 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 2 3 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 0 0 0 0 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2
```

**Perception**

The task involves transforming a 2D grid of numbers. The input grid contains only the numbers 0 and 2. The output grid has the same dimensions as the input grid and contains the numbers 0, 2, and 3.

By comparing the input and output grids in the provided examples, the transformation rule appears to be based on the neighborhood of cells containing the value 2. Specifically:

1.  Cells that contain the value 2 in the input grid retain the value 2 in the output grid.
2.  Cells that contain the value 0 in the input grid are changed to 3 in the output grid if, and only if, at least one of their eight neighboring cells (horizontally, vertically, or diagonally adjacent) in the input grid contains the value 2.
3.  Cells that contain the value 0 in the input grid and do not have any neighbors with the value 2 remain 0 in the output grid.

Essentially, the transformation "marks" the cells adjacent to the '2' cells with a '3', provided those adjacent cells were originally '0'.

**Facts**


```yaml
Objects:
  - Input_Grid: A 2D array representing the initial state.
  - Output_Grid: A 2D array representing the final state, derived from Input_Grid.
  - Cell: An individual element within a grid, defined by its row, column, and value.

Properties:
  - Grid:
    - dimensions: height (number of rows), width (number of columns)
    - cells: A collection of Cell objects.
  - Cell:
    - row: Integer index for the row position.
    - column: Integer index for the column position.
    - value: Integer value (0, 2 in Input_Grid; 0, 2, 3 in Output_Grid).
  - Neighborhood:
    - type: Moore neighborhood (8 adjacent cells including diagonals).
    - context: Defined relative to a central Cell within the Input_Grid.

Relationships:
  - Output_Grid is derived from Input_Grid.
  - The value of a Cell in Output_Grid depends on the value of the corresponding Cell in Input_Grid and the values of its neighboring Cells in Input_Grid.
  - A Cell value of 3 in Output_Grid indicates that the corresponding Input_Grid Cell had a value of 0 and was adjacent (neighbor) to at least one Cell with a value of 2 in the Input_Grid.

Actions:
  - Iterate through each Cell (r, c) of the Input_Grid.
  - Determine the value for the corresponding Cell (r, c) in the Output_Grid based on the following rules:
    - If Input_Grid[r][c] is 2, then Output_Grid[r][c] is 2.
    - If Input_Grid[r][c] is 0:
      - Check all 8 neighbors (nr, nc) of Cell (r, c) in the Input_Grid.
      - If any neighbor Input_Grid[nr][nc] exists and has a value of 2, then Output_Grid[r][c] is 3.
      - Otherwise (if no neighbor has a value of 2), Output_Grid[r][c] is 0.
```


**Natural Language Program**

1.  Initialize the Output Grid as a copy of the Input Grid.
2.  Iterate through each cell `(r, c)` of the Input Grid.
3.  For the current cell `(r, c)`:
    a.  Check if the value of the cell in the Input Grid, `Input_Grid[r][c]`, is 0.
    b.  If `Input_Grid[r][c]` is 0, then check its 8 neighbors (including diagonals) in the Input Grid: `(r-1, c-1)`, `(r-1, c)`, `(r-1, c+1)`, `(r, c-1)`, `(r, c+1)`, `(r+1, c-1)`, `(r+1, c)`, `(r+1, c+1)`.
    c.  For each neighbor `(nr, nc)`:
        i.  Verify that the neighbor coordinates `(nr, nc)` are within the bounds of the Input Grid.
        ii. Check if the value of the neighbor cell `Input_Grid[nr][nc]` is 2.
    d.  If at least one valid neighbor cell in the Input Grid has a value of 2, set the value of the corresponding cell in the Output Grid, `Output_Grid[r][c]`, to 3.
    e.  If `Input_Grid[r][c]` is not 0 (meaning it is 2), or if it is 0 but none of its valid neighbors have a value of 2, the value in the Output Grid `Output_Grid[r][c]` remains unchanged from the initial copy (i.e., it stays 0 if it was 0 and had no '2' neighbors, or it stays 2 if it was 2).
4.  Return the modified Output Grid.
```python
"""
Transforms an input grid based on the proximity of cells with value 0 to cells with value 2.

1. Cells with value 2 in the input grid remain 2 in the output grid.
2. Cells with value 0 in the input grid become 3 in the output grid if they have at least one neighbor (horizontally, vertically, or diagonally) with value 2 in the input grid.
3. Cells with value 0 in the input grid that do not have any neighbors with value 2 remain 0 in the output grid.
"""

import copy

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.

    Args:
        input_grid: A 2D list of integers representing the input state.

    Returns:
        A 2D list of integers representing the transformed output state.
    """
    # Get grid dimensions
    height = len(input_grid)
    if height == 0:
        return []
    width = len(input_grid[0])
    if width == 0:
        return [[] for _ in range(height)]

    # Initialize output_grid as a deep copy of the input_grid
    # This handles rule 1 (2s stay 2s) and the default case for rule 3 (0s stay 0s unless changed)
    output_grid = copy.deepcopy(input_grid)

    # Define the relative coordinates for the 8 neighbors (Moore neighborhood)
    neighbor_offsets = [
        (-1, -1), (-1, 0), (-1, 1),
        ( 0, -1),          ( 0, 1),
        ( 1, -1), ( 1, 0), ( 1, 1),
    ]

    # Iterate through each cell of the input grid
    for r in range(height):
        for c in range(width):
            # Check if the current cell in the input grid is 0 (Rule 2 & 3)
            if input_grid[r][c] == 0:
                # Check its neighbors in the input grid
                found_neighbor_2 = False
                for dr, dc in neighbor_offsets:
                    nr, nc = r + dr, c + dc

                    # Check if the neighbor coordinates are within the grid bounds
                    if 0 <= nr < height and 0 <= nc < width:
                        # Check if the neighbor cell has a value of 2
                        if input_grid[nr][nc] == 2:
                            found_neighbor_2 = True
                            break # Found a neighbor 2, no need to check others

                # If at least one neighbor was 2, update the output grid cell to 3 (Rule 2)
                if found_neighbor_2:
                    output_grid[r][c] = 3
            # If input_grid[r][c] was 2, it remains 2 in the output_grid (handled by initial copy)
            # If input_grid[r][c] was 0 and no neighbor was 2, it remains 0 (handled by initial copy)


    return output_grid
```
