{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy import ndimage\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1.  Identify potential background digits P = {0, 1, 2, 3}.\n2.  Identify \"object\" pixels: cells with values NOT in P.\n3.  Find connected components (8-way) of object pixels.\n4.  Identify the primary frame component:\n    a. Find the component with the largest number of pixels. Store its coordinates (`frame_coords`).\n    b. Determine the `frame_digit`: If the component is uniform, use that digit. If not, use the most frequent digit within the component's coordinates.\n    c. **Fallback:** If no object components were found in step 3 (e.g., frame is made of digit 3), find connected components of *all non-zero* pixels. Iterate through these components from largest to smallest by pixel count. The *first* component found that is *uniform* (all pixels have the same digit) is considered the frame. Update `frame_coords` and `frame_digit`.\n    d. If no frame component is found by either method, return an empty grid.\n5.  Calculate the bounding box (`min_r`, `min_c`, `max_r`, `max_c`) of the final `frame_coords`.\n6.  Define the actual background digits B = {0} union {d in {1, 2, 3} if d is not the `frame_digit`}.\n7.  Create the output grid with dimensions determined by the frame's bounding box.\n8.  Populate the output grid: For each cell within the bounding box in the input grid:\n    a. Get the input value `v` and coordinates `coord`.\n    b. If `v` is in B AND `coord` is NOT in `frame_coords`, the output cell is 0.\n    c. Otherwise, the output cell is `v`.\n9.  Return the output grid as a list of lists.\n\"\"\"\n\ndef find_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a set of (row, col) coordinates.\"\"\"\n    if not coords:\n        return None\n    min_row = min(r for r, c in coords)\n    max_row = max(r for r, c in coords)\n    min_col = min(c for r, c in coords)\n    max_col = max(c for r, c in coords)\n    return min_row, min_col, max_row, max_col\n\ndef get_component_info(labeled_array, num_features, input_grid):\n    \"\"\"Extracts coordinates, size, and digit info for each component.\"\"\"\n    components = {}\n    for label in range(1, num_features + 1):\n        coords_array = np.array(np.where(labeled_array == label)).T\n        coords = set(map(tuple, coords_array)) # Use set of tuples\n        if not coords:\n            continue\n        \n        digits = [input_grid[r, c] for r, c in coords]\n        size = len(coords)\n        is_uniform = len(set(digits)) == 1\n        most_frequent_digit = Counter(digits).most_common(1)[0][0] if digits else -1\n        \n        components[label] = {\n            'coords': coords,\n            'size': size,\n            'is_uniform': is_uniform,\n            'uniform_digit': digits[0] if is_uniform else -1,\n            'most_frequent_digit': most_frequent_digit,\n        }\n    return components\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to extract and modify the framed content.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    potential_bg_digits = {0, 1, 2, 3}\n    frame_coords = set()\n    frame_digit = -1\n\n    # --- 1. Try finding objects excluding potential background ---\n    object_mask = np.isin(input_array, list(potential_bg_digits), invert=True)\n    labeled_obj, num_obj_features = ndimage.label(object_mask, structure=np.ones((3,3), dtype=bool))\n    \n    if num_obj_features > 0:\n        obj_components = get_component_info(labeled_obj, num_obj_features, input_array)\n        # Find largest component by size\n        largest_label = max(obj_components, key=lambda k: obj_components[k]['size'])\n        largest_comp = obj_components[largest_label]\n        frame_coords = largest_comp['coords']\n        frame_digit = largest_comp['uniform_digit'] if largest_comp['is_uniform'] else largest_comp['most_frequent_digit']\n        \n    # --- 2. Fallback: Find largest uniform non-zero component if primary method failed ---\n    if not frame_coords: \n        non_zero_mask = input_array != 0\n        labeled_nz, num_nz_features = ndimage.label(non_zero_mask, structure=np.ones((3,3), dtype=bool))\n        \n        if num_nz_features > 0:\n            nz_components = get_component_info(labeled_nz, num_nz_features, input_array)\n            # Sort by size descending\n            sorted_labels = sorted(nz_components, key=lambda k: nz_components[k]['size'], reverse=True)\n            \n            for label in sorted_labels:\n                comp = nz_components[label]\n                if comp['is_uniform']:\n                    frame_coords = comp['coords']\n                    frame_digit = comp['uniform_digit']\n                    break # Found the largest uniform component\n\n    # --- 3. If no frame identified, return empty ---\n    if not frame_coords or frame_digit == -1:\n        return []\n\n    # --- 4. Calculate bounding box ---\n    bbox = find_bounding_box(frame_coords)\n    if bbox is None:\n         return []\n    min_row, min_col, max_row, max_col = bbox\n\n    # --- 5. Define actual background digits ---\n    background_digits = {0}\n    present_low_digits = potential_bg_digits.intersection(set(input_array.flatten())) - {0}\n    background_digits.update(d for d in present_low_digits if d != frame_digit)\n\n    # --- 6. Create and populate output grid ---\n    output_rows = max_row - min_row + 1\n    output_cols = max_col - min_col + 1\n    output_array = np.zeros((output_rows, output_cols), dtype=int)\n\n    for r_out in range(output_rows):\n        for c_out in range(output_cols):\n            r_in = min_row + r_out\n            c_in = min_col + c_out\n            \n            original_value = input_array[r_in, c_in]\n            original_coord = (r_in, c_in)\n\n            # Check conditions for replacement\n            is_background = original_value in background_digits\n            is_part_of_frame = original_coord in frame_coords\n            \n            if is_background and not is_part_of_frame:\n                output_array[r_out, c_out] = 0\n            else:\n                output_array[r_out, c_out] = original_value\n\n    # --- 7. Return result ---\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32941,
    "candidates_token_count": 2817,
    "total_token_count": 35758,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.07138,
  "retries": 1
}