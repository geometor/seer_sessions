
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 2 5 2 0 0 0 0 0 0 0 0 0 0
0 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 5 2 0
0 0 0 0 0 0 0 0 0 0 0 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 2 5 2 0 0 0 0 0 0 0 0 0 0
0 0 2 4 2 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 2 2 2 0
0 0 0 4 4 4 4 4 4 4 4 4 5 2 0
0 0 0 0 0 0 0 0 0 0 0 2 2 2 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 2 5 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 2 0 0 0 0 0 0 0 0 0 0 0
0 2 5 2 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 2 5 4 4 0 0
0 0 0 0 0 0 0 0 0 2 2 2 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 0 0
0 2 4 2 0 0 0 0 0 0 0 0 0 0 0
0 2 5 2 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 2 0 2 0 0 0 0 0 0 0 0 0 0 0
0 2 5 2 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
0 0 0 0 0 0 0 0 0 2 5 0 0 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
```


**output:**
```
0 0 4 4 4 4 4 4 4 4 4 4 4 0 0
0 2 4 2 4 4 4 4 4 4 4 4 4 0 0
0 2 5 2 4 4 4 4 4 4 4 4 4 0 0
0 2 2 2 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 2 2 2 4 0 0
0 0 0 0 0 0 0 0 0 2 5 4 4 0 0
0 0 0 0 0 0 0 0 0 2 2 2 0 0 0
```

## Perception of Elements:

1.  **Grid Structure:** Both input and output are 2D grids of integers (pixels) with dimensions 15x15.
2.  **Colors/Values:**
    *   `0`: Black (background)
    *   `2`: Blue
    *   `4`: Red (appears only in output)
    *   `5`: Green
3.  **Input Objects:**
    *   Two distinct objects composed primarily of blue (2) pixels.
    *   Each blue object forms a sort of hollow square/rectangle (3x3 in the examples) where one pixel is replaced by green (5) and another single pixel within the 3x3 area is black (0).
    *   The rest of the grid is black (0).
4.  **Output Objects:**
    *   The original blue (2) and green (5) objects are preserved.
    *   A new red (4) shape appears.
5.  **Transformation:**
    *   The transformation identifies specific points associated with each blue/green object. These points seem to be the single black (0) pixels located *within* the immediate 3x3 bounding box defined by each blue shape.
    *   A rectangular area is defined using these two identified black pixels as diagonal corners.
    *   Within this rectangular area, all black (0) pixels from the input grid are changed to red (4) in the output grid.
    *   Pixels that were originally blue (2) or green (5) within this rectangle remain unchanged.
    *   Pixels outside this rectangle remain unchanged.

## YAML Fact Documentation:


```yaml
task_description: Fill a rectangular area between two anchor points derived from input shapes.

elements:
  - object: grid
    properties:
      - type: 2D array
      - dimensions: 15x15 (constant across examples)
      - value_type: integer
      - colors:
          - 0: black (background)
          - 2: blue (shape component)
          - 5: green (shape component)
          - 4: red (fill color, output only)

  - object: blue_shape
    properties:
      - count: 2 per input grid
      - composition: primarily color 2 (blue)
      - structure: forms a boundary (approx 3x3)
      - contains:
          - one pixel of color 5 (green)
          - one pixel of color 0 (black) within its minimal bounding box
    derived_properties:
      - anchor_point: the coordinates of the single black (0) pixel within the shape's bounding box.

  - object: red_fill
    properties:
      - color: 4 (red)
      - presence: only in output grid
      - shape: rectangle
      - location: defined by the anchor points of the two blue_shapes

relationships:
  - relation: defines
    subject: anchor_point (of blue_shape 1)
    object: corner_1 (of red_fill rectangle)
  - relation: defines
    subject: anchor_point (of blue_shape 2)
    object: corner_2 (of red_fill rectangle)
  - relation: transformation
    input_pixels: black (0) within the red_fill rectangle boundary
    output_pixels: red (4)
  - relation: preservation
    input_pixels: blue (2) or green (5) within the red_fill rectangle boundary
    output_pixels: same as input (blue or green)
  - relation: preservation
    input_pixels: all pixels outside the red_fill rectangle boundary
    output_pixels: same as input

actions:
  - action: identify_shapes
    input: input grid
    output: two blue_shape objects
  - action: find_anchor_points
    input: two blue_shape objects, input grid
    output: coordinates P1=(r1, c1), P2=(r2, c2)
  - action: determine_bounding_box
    input: P1, P2
    output: min_row, max_row, min_col, max_col
  - action: fill_rectangle
    input: input grid, bounding_box
    output: output grid (with red fill applied)
```


## Natural Language Program:

1.  Initialize the output grid as a copy of the input grid.
2.  Locate the two distinct connected components formed by blue (2) pixels in the input grid.
3.  For each blue component:
    a.  Determine its minimal bounding box (the smallest rectangle containing all its blue pixels).
    b.  Find the coordinates (row, column) of the single pixel within this bounding box that has the value 0 (black). Let these two points be P1 = (r1, c1) and P2 = (r2, c2).
4.  Define a rectangular region based on these two points:
    a.  `min_row = min(r1, r2)`
    b.  `max_row = max(r1, r2)`
    c.  `min_col = min(c1, c2)`
    d.  `max_col = max(c1, c2)`
5.  Iterate through each cell (r, c) within this rectangular region (from `min_row` to `max_row` and `min_col` to `max_col`, inclusive).
6.  For each cell (r, c) inside the region, check its value in the *input* grid:
    a.  If `input[r, c]` is 0 (black), set the corresponding cell in the *output* grid `output[r, c]` to 4 (red).
7.  All other cells in the output grid (those outside the rectangle, and those inside the rectangle that were not originally black) retain their original values from the input grid.
8.  Return the modified output grid.
```python
import numpy as np
from collections import deque

"""
Identifies two distinct blue shapes in the input grid. 
For each shape, finds the coordinates of the unique black pixel (0) located within the minimal bounding box of the blue pixels of that shape. These two black pixel coordinates serve as anchor points.
Determines the rectangular region defined by these two anchor points as diagonal corners.
Fills this rectangular region in the output grid: if a pixel within the region was black (0) in the input, it becomes red (4) in the output. All other pixels (including the original blue/green shapes and pixels outside the rectangle) retain their original colors.
"""

def find_connected_component(grid, start_row, start_col, target_color, visited):
    """Finds a connected component of target_color starting from (start_row, start_col)."""
    rows, cols = grid.shape
    component_coords = set()
    q = deque([(start_row, start_col)])
    visited[start_row, start_col] = True
    
    min_r, min_c = start_row, start_col
    max_r, max_c = start_row, start_col

    while q:
        r, c = q.popleft()
        component_coords.add((r, c))
        
        min_r = min(min_r, r)
        min_c = min(min_c, c)
        max_r = max(max_r, r)
        max_c = max(max_c, c)

        # Check neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and \
               not visited[nr, nc] and grid[nr, nc] == target_color:
                visited[nr, nc] = True
                q.append((nr, nc))
                
    bounding_box = (min_r, min_c, max_r, max_c)
    return component_coords, bounding_box

def find_anchor_in_bbox(grid, bbox):
    """Finds the coordinates of the first black (0) pixel within the bounding box."""
    min_r, min_c, max_r, max_c = bbox
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            # Check bounds just in case bbox is outside grid (shouldn't happen here)
            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
                if grid[r, c] == 0:
                    return (r, c)
    return None # Should not happen based on problem description


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the input grid by finding two blue shapes, identifying their 
    internal anchor points (black pixels within their bounding boxes), 
    and filling the rectangle defined by these anchors with red color (4) 
    where the input grid was black (0).
    """
    
    # Convert to numpy array for easier processing
    input_np = np.array(input_grid, dtype=int)
    output_np = input_np.copy()
    rows, cols = input_np.shape
    visited = np.zeros_like(input_np, dtype=bool)
    anchor_points = []

    # --- Find the two blue shapes and their anchor points ---
    for r in range(rows):
        for c in range(cols):
            # If we find a blue pixel that hasn't been visited yet, it's the start of a new component
            if input_np[r, c] == 2 and not visited[r, c]:
                # Find the connected component of blue pixels and its bounding box
                component_coords, bbox = find_connected_component(input_np, r, c, 2, visited)
                
                # Find the black anchor pixel within this component's bounding box
                anchor = find_anchor_in_bbox(input_np, bbox)
                if anchor:
                    anchor_points.append(anchor)
                
                # Stop once we've found two anchors
                if len(anchor_points) == 2:
                    break
        if len(anchor_points) == 2:
            break
            
    # Check if exactly two anchor points were found
    if len(anchor_points) != 2:
        # If not, return the original grid or handle error appropriately
        # Based on examples, we expect exactly two.
        print("Warning: Did not find exactly two anchor points. Returning original grid.")
        return input_grid 

    # --- Determine the bounding box for the fill area ---
    (r1, c1), (r2, c2) = anchor_points
    min_row = min(r1, r2)
    max_row = max(r1, r2)
    min_col = min(c1, c2)
    max_col = max(c1, c2)

    # --- Fill the rectangle with red (4) where input was black (0) ---
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            # Check bounds to be safe
            if 0 <= r < rows and 0 <= c < cols:
                # If the pixel in the *input* grid within the rectangle is black (0)
                if input_np[r, c] == 0:
                    # Set the corresponding pixel in the *output* grid to red (4)
                    output_np[r, c] = 4

    # Convert the result back to a list of lists
    output_grid = output_np.tolist()
    
    return output_grid
```
