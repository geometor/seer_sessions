{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport copy\n\n\"\"\"\nThe transformation identifies connected shapes of color 2 within the input grid. \nIt conceptually divides the grid into four quadrants (Top-Left, Top-Right, \nBottom-Left, Bottom-Right). Shapes within each quadrant are grouped, and \ntheir combined patterns (relative positions of '2's) and total sizes (number \nof '2's) are calculated.\n\nComparisons are made between diagonally opposite quadrants:\n1. Top-Left (TL) vs. Bottom-Right (BR):\n   - If patterns match: TL becomes color 2, BR becomes color 3.\n   - If patterns differ:\n     - If TL size > BR size: TL becomes 3, BR becomes 8.\n     - If TL size <= BR size: TL becomes 8, BR becomes 3.\n\n2. Top-Right (TR) vs. Bottom-Left (BL):\n   - If patterns match: TR becomes color 8, BL becomes color 8.\n   - If patterns differ:\n     - If TR size > BL size: TR becomes 8, BL becomes 2.\n     - If TR size <= BL size: TR becomes 2, BL becomes 8.\n\nThe cells of the original shapes in the input grid are then recolored in the \noutput grid according to the color determined for their respective quadrant \nbased on these comparisons. Cells not part of an initial color 2 shape remain \nunchanged.\n\"\"\"\n\ndef find_connected_components(grid: np.ndarray, target_color: int) -> tuple[np.ndarray, int]:\n    \"\"\"Finds connected components of a specific color.\"\"\"\n    labeled_grid, num_features = label(grid == target_color)\n    return labeled_grid, num_features\n\ndef get_shape_properties(labeled_grid: np.ndarray, num_features: int, grid_rows: int, grid_cols: int) -> dict:\n    \"\"\"\n    Calculates properties (coordinates, pattern, size, quadrant) for each shape.\n\n    Returns:\n        A dictionary where keys are quadrant names ('TL', 'TR', 'BL', 'BR')\n        and values are lists of shapes found in that quadrant. Each shape\n        is represented by a dictionary {'coords': set, 'pattern': tuple, 'size': int}.\n    \"\"\"\n    shapes_by_quadrant = {'TL': [], 'TR': [], 'BL': [], 'BR': []}\n    locations = find_objects(labeled_grid)\n    center_row = grid_rows / 2\n    center_col = grid_cols / 2\n\n    for i in range(num_features):\n        label_id = i + 1\n        coords_array = np.argwhere(labeled_grid == label_id)\n        coords_set = set(tuple(coord) for coord in coords_array)\n        \n        if not coords_set:\n            continue\n\n        min_r = min(r for r, c in coords_set)\n        min_c = min(c for r, c in coords_set)\n        \n        # Normalize pattern relative to top-left of bounding box\n        pattern = tuple(sorted((r - min_r, c - min_c) for r, c in coords_set))\n        size = len(coords_set)\n\n        # Determine quadrant based on the center of the shape's coordinates\n        avg_row = np.mean([r for r, c in coords_set])\n        avg_col = np.mean([c for r, c in coords_set])\n\n        quadrant = \"\"\n        if avg_row < center_row and avg_col < center_col:\n            quadrant = 'TL'\n        elif avg_row < center_row and avg_col >= center_col:\n            quadrant = 'TR'\n        elif avg_row >= center_row and avg_col < center_col:\n            quadrant = 'BL'\n        elif avg_row >= center_row and avg_col >= center_col:\n            quadrant = 'BR'\n        \n        if quadrant:\n             shapes_by_quadrant[quadrant].append({\n                 'coords': coords_set, \n                 'pattern': pattern, \n                 'size': size,\n                 'label': label_id # Store original label for recoloring\n                 })\n\n    return shapes_by_quadrant\n\ndef get_quadrant_entity(shapes: list[dict]) -> dict:\n    \"\"\"\n    Combines multiple shapes in a quadrant into a single entity for comparison.\n    Calculates combined pattern (relative to overall bounding box) and total size.\n    Returns {'pattern': tuple, 'size': int} or {'pattern': None, 'size': 0} if empty.\n    \"\"\"\n    if not shapes:\n        return {'pattern': None, 'size': 0}\n\n    all_coords = set().union(*[s['coords'] for s in shapes])\n    if not all_coords:\n         return {'pattern': None, 'size': 0}\n\n    min_r = min(r for r, c in all_coords)\n    min_c = min(c for r, c in all_coords)\n    \n    # Combined pattern relative to the top-left of the overall bounding box\n    combined_pattern = tuple(sorted((r - min_r, c - min_c) for r, c in all_coords))\n    total_size = sum(s['size'] for s in shapes)\n\n    return {'pattern': combined_pattern, 'size': total_size}\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = copy.deepcopy(grid_np)\n    grid_rows, grid_cols = grid_np.shape\n\n    # 1. Identify all distinct connected shapes of color 2\n    labeled_grid, num_features = find_connected_components(grid_np, 2)\n    \n    if num_features == 0:\n        return input_grid # No shapes to transform\n\n    # 2 & 3. Get properties for each shape and assign to quadrants\n    shapes_by_quadrant = get_shape_properties(labeled_grid, num_features, grid_rows, grid_cols)\n\n    # 4. Group shapes by quadrant and get combined properties\n    quadrant_entities = {\n        q: get_quadrant_entity(shapes_by_quadrant[q]) for q in ['TL', 'TR', 'BL', 'BR']\n    }\n\n    # 5. Define shape entities for comparison\n    P_TL = quadrant_entities['TL']['pattern']\n    S_TL = quadrant_entities['TL']['size']\n    P_TR = quadrant_entities['TR']['pattern']\n    S_TR = quadrant_entities['TR']['size']\n    P_BL = quadrant_entities['BL']['pattern']\n    S_BL = quadrant_entities['BL']['size']\n    P_BR = quadrant_entities['BR']['pattern']\n    S_BR = quadrant_entities['BR']['size']\n\n    # Dictionary to store the output color determined for each quadrant\n    quadrant_output_colors = {'TL': 2, 'TR': 2, 'BL': 2, 'BR': 2} # Default to 2 if no comparison applies\n\n    # 6. Compare Top-Left (TL) and Bottom-Right (BR)\n    if P_TL is not None or P_BR is not None: # Only compare if at least one exists\n        if P_TL == P_BR:\n            quadrant_output_colors['TL'] = 2\n            quadrant_output_colors['BR'] = 3\n        else:\n            if S_TL > S_BR:\n                quadrant_output_colors['TL'] = 3\n                quadrant_output_colors['BR'] = 8\n            else: # Covers S_TL <= S_BR \n                quadrant_output_colors['TL'] = 8\n                quadrant_output_colors['BR'] = 3\n    \n    # Handle cases where one quadrant is empty but the other isn't, implicitly handled by size comparison\n    # If TL exists but BR doesn't (size 0), TL > BR -> TL=3, BR=8 (but BR has no shape to color)\n    # If BR exists but TL doesn't (size 0), TL <= BR -> TL=8, BR=3 (but TL has no shape to color)\n\n\n    # 7. Compare Top-Right (TR) and Bottom-Left (BL)\n    if P_TR is not None or P_BL is not None: # Only compare if at least one exists\n        if P_TR == P_BL:\n            quadrant_output_colors['TR'] = 8\n            quadrant_output_colors['BL'] = 8\n        else:\n            if S_TR > S_BL:\n                quadrant_output_colors['TR'] = 8\n                quadrant_output_colors['BL'] = 2\n            else: # Covers S_TR <= S_BL\n                quadrant_output_colors['TR'] = 2\n                quadrant_output_colors['BL'] = 8\n\n    # Handle empty cases similarly to TL/BR\n\n\n    # 8. Recolor the grid\n    # Iterate through the originally identified shapes and recolor based on their quadrant's determined output color\n    for quadrant, shapes in shapes_by_quadrant.items():\n        output_color = quadrant_output_colors[quadrant]\n        for shape in shapes:\n             # Find where the original shape (label) is in the labeled_grid and color those cells in output_grid\n            rows, cols = np.where(labeled_grid == shape['label'])\n            output_grid[rows, cols] = output_color\n            \n            # Alternative using coords stored earlier (less efficient if many shapes)\n            # for r, c in shape['coords']:\n            #     output_grid[r, c] = output_color\n\n\n    # Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4031,
    "candidates_token_count": 3140,
    "total_token_count": 7171,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.868802,
  "retries": 1
}