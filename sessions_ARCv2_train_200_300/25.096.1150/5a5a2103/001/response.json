{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms an input grid by identifying horizontal and vertical separator lines \nof a single color. These lines divide the grid into quadrants. For each \nhorizontal strip of quadrants (defined by horizontal separators or grid edges), \nit finds the first non-background (0), non-separator color in the leftmost \nquadrant of that strip. It then fills all non-separator cells within that \nentire horizontal strip with this identified 'source' color.\n\"\"\"\n\ndef find_separator_color(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds the color that forms complete horizontal and vertical lines.\n    Assumes only one such color exists.\n    \"\"\"\n    rows, cols = grid.shape\n    potential_h_colors = set()\n    potential_v_colors = set()\n\n    # Check horizontal lines\n    for r in range(rows):\n        first_val = grid[r, 0]\n        if first_val != 0 and np.all(grid[r, :] == first_val):\n            potential_h_colors.add(first_val)\n\n    # Check vertical lines\n    for c in range(cols):\n        first_val = grid[0, c]\n        if first_val != 0 and np.all(grid[:, c] == first_val):\n            potential_v_colors.add(first_val)\n\n    # The separator color must form both horizontal and vertical lines\n    separator_colors = potential_h_colors.intersection(potential_v_colors)\n\n    if len(separator_colors) == 1:\n        return separator_colors.pop()\n    elif len(separator_colors) > 1:\n        # Handle ambiguity if needed, for now, return the first found\n        # In the examples, there seems to be only one clear separator.\n         print(f\"Warning: Multiple potential separator colors found: {separator_colors}. Choosing first.\")\n         return list(separator_colors)[0] # This behavior might need adjustment based on more examples\n    else:\n        # Check if any color forms at least one full row and one full col, even if not all rows/cols\n        # This covers cases where separators might not span the entire grid but define the structure\n        color_in_full_row = {} # color -> set of row indices\n        color_in_full_col = {} # color -> set of col indices\n\n        for r in range(rows):\n           unique_colors = np.unique(grid[r, :])\n           if len(unique_colors) == 1 and unique_colors[0] != 0:\n               color = unique_colors[0]\n               if color not in color_in_full_row: color_in_full_row[color] = set()\n               color_in_full_row[color].add(r)\n\n        for c in range(cols):\n            unique_colors = np.unique(grid[:, c])\n            if len(unique_colors) == 1 and unique_colors[0] != 0:\n               color = unique_colors[0]\n               if color not in color_in_full_col: color_in_full_col[color] = set()\n               color_in_full_col[color].add(c)\n\n        common_colors = set(color_in_full_row.keys()).intersection(set(color_in_full_col.keys()))\n        if common_colors:\n             if len(common_colors) == 1:\n                 return common_colors.pop()\n             else:\n                  # Fallback logic: check which color appears most frequently in full rows/cols?\n                  # Or maybe the one with the lowest/highest index?\n                  # For now, return the smallest color value among them as a guess.\n                  print(f\"Warning: Multiple potential separator colors found (partial lines): {common_colors}. Choosing smallest.\")\n                  return min(common_colors)\n        return None # No clear separator found\n\ndef find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns completely filled with the separator color.\"\"\"\n    rows, cols = grid.shape\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]\n    return h_lines, v_lines\n\ndef find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> int:\n    \"\"\"\n    Finds the first non-background, non-separator color in the given grid slice.\n    Searches row by row, then column by column.\n    Returns background_color if no suitable source color is found.\n    \"\"\"\n    rows, cols = grid_slice.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_slice[r, c]\n            if color != background_color and color != separator_color:\n                return color\n    return background_color # Default if no source color found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the grid by filling horizontal strips based on the color found\n    in the leftmost quadrant of each strip, preserving separator lines.\n    \"\"\"\n    # Convert to numpy array for easier slicing and manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy() # Initialize output grid\n    rows, cols = grid.shape\n    background_color = 0\n\n    # --- Identify Separators ---\n    separator_color = find_separator_color(grid)\n    if separator_color is None:\n        # If no separator is found, maybe the transformation doesn't apply?\n        # Return the original grid or handle based on expected behavior.\n        print(\"Warning: No separator color identified. Returning original grid.\")\n        return input_grid # Or output_grid.tolist()\n\n    h_lines, v_lines = find_separator_lines(grid, separator_color)\n\n    # --- Define Horizontal Strips ---\n    # Add grid boundaries to the horizontal line indices\n    h_boundaries = sorted(list(set([0] + h_lines + [rows])))\n\n    # --- Process Each Horizontal Strip ---\n    for i in range(len(h_boundaries) - 1):\n        row_start = h_boundaries[i]\n        row_end = h_boundaries[i+1]\n\n        # Skip if the strip is actually a separator line itself\n        if row_start in h_lines:\n            continue\n            \n        # --- Find Leftmost Quadrant ---\n        # Define the column boundaries for the leftmost quadrant\n        first_v_line_or_edge = cols\n        for v_line_idx in sorted(v_lines):\n             if v_line_idx > 0: # Consider vertical separators not at the very edge\n                 first_v_line_or_edge = v_line_idx\n                 break\n        col_start = 0\n        col_end = first_v_line_or_edge\n\n        # --- Find Source Color in Leftmost Quadrant ---\n        leftmost_quadrant = grid[row_start:row_end, col_start:col_end]\n        source_color = find_source_color(leftmost_quadrant, separator_color, background_color)\n\n        # --- Fill the Strip in the Output Grid ---\n        # Iterate through all cells in the current horizontal strip\n        for r in range(row_start, row_end):\n            for c in range(cols):\n                # Only fill cells that are NOT part of a separator line (horizontal or vertical)\n                is_separator_cell = (grid[r, c] == separator_color)\n                # More robust check: is the cell part of *any* identified separator line?\n                # This handles cases where a cell might be separator color but not part of a *full* line identified earlier.\n                # The core logic from examples seems simpler: if input cell is separator color, keep it. Otherwise, fill.\n                if grid[r, c] != separator_color:\n                     output_grid[r, c] = source_color\n\n\n    # Convert back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3896,
    "candidates_token_count": 2739,
    "total_token_count": 6635,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.902459,
  "retries": 1
}