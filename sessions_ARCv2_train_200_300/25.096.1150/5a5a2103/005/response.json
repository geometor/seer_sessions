{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the grid by recoloring specific cells within horizontal strips defined \nby separator lines.\n\n1. Identifies a unique 'separator_color' that forms complete horizontal and \n   vertical lines across the grid.\n2. Finds the row and column indices of these separator lines.\n3. Defines horizontal strips as the regions between consecutive horizontal \n   separator lines (or grid edges).\n4. For each horizontal strip:\n   a. Identifies the 'leftmost quadrant' (from column 0 up to the first vertical \n      separator line or the right grid edge).\n   b. Scans the leftmost quadrant (row by row, column by column) to find the \n      first cell whose color is *not* the background color (0) and *not* the \n      separator color. This color is the 'source_color' for the strip.\n   c. Iterates through all cells within the current horizontal strip (across \n      the full width of the grid).\n   d. If a cell in the *input* grid at position (r, c) contains a color that \n      is *neither* the background color (0) *nor* the separator color, then \n      the corresponding cell in the *output* grid at (r, c) is set to the \n      'source_color' found for that strip.\n   e. Cells that originally contained the background color (0) or the \n      separator_color remain unchanged in the output grid.\n\"\"\"\n\n\ndef find_separator_color(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds the unique non-zero color that forms complete horizontal rows \n    AND complete vertical columns. Returns None if no such unique color exists.\n    Uses a stricter definition focusing on lines spanning the entire grid.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return None\n        \n    potential_h_colors = set()\n    potential_v_colors = set()\n\n    # Check horizontal lines fully spanning the grid\n    for r in range(rows):\n       first_val = grid[r, 0]\n       if first_val != 0 and np.all(grid[r, :] == first_val):\n           potential_h_colors.add(first_val)\n\n    # Check vertical lines fully spanning the grid\n    for c in range(cols):\n        first_val = grid[0, c]\n        if first_val != 0 and np.all(grid[:, c] == first_val):\n           potential_v_colors.add(first_val)\n\n    # The separator color must form both complete horizontal and vertical lines\n    separator_colors = potential_h_colors.intersection(potential_v_colors)\n\n    if len(separator_colors) == 1:\n        return separator_colors.pop()\n    elif len(separator_colors) > 1:\n         # Heuristic for ambiguity: return the smallest value.\n         print(f\"Warning: Multiple potential separator colors found: {separator_colors}. Choosing smallest.\")\n         return min(separator_colors)\n         \n    # Fallback: Check for colors that form *any* full row and *any* full column\n    # (Less strict than the above, might be needed for other variants)\n    # This part is less likely needed based on current examples but kept for robustness idea.\n    color_in_any_full_row = {} # color -> set of row indices\n    color_in_any_full_col = {} # color -> set of col indices\n\n    for r in range(rows):\n       unique_colors = np.unique(grid[r, :])\n       if len(unique_colors) == 1 and unique_colors[0] != 0:\n           color = unique_colors[0]\n           if color not in color_in_any_full_row: color_in_any_full_row[color] = set()\n           color_in_any_full_row[color].add(r)\n\n    for c in range(cols):\n        unique_colors = np.unique(grid[:, c])\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n           color = unique_colors[0]\n           if color not in color_in_any_full_col: color_in_any_full_col[color] = set()\n           color_in_any_full_col[color].add(c)\n           \n    common_colors_fallback = set(color_in_any_full_row.keys()).intersection(set(color_in_any_full_col.keys()))\n    if len(common_colors_fallback) == 1:\n         print(f\"Warning: Found separator using fallback logic: {common_colors_fallback}\")\n         return common_colors_fallback.pop()\n    elif len(common_colors_fallback) > 1:\n         print(f\"Warning: Multiple potential separator colors found (fallback): {common_colors_fallback}. Choosing smallest.\")\n         return min(common_colors_fallback)\n\n    return None # No single color forms both full rows and columns\n\n\ndef find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns completely filled with the separator color.\"\"\"\n    rows, cols = grid.shape\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]\n    return h_lines, v_lines\n\ndef find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the first non-background, non-separator color in the given grid slice.\n    Searches row by row, then column by column.\n    Returns the color if found, otherwise None.\n    \"\"\"\n    if grid_slice.size == 0: # Handle empty slice case\n        return None\n        \n    rows, cols = grid_slice.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_slice[r, c]\n            if color != background_color and color != separator_color:\n                return color\n    return None # No source color found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    if rows == 0 or cols == 0:\n        return input_grid # Return empty or invalid grid as is\n\n    # Initialize output_grid as a copy of the input grid. This preserves\n    # background and separator cells unless explicitly changed.\n    output_grid = grid.copy()\n    background_color = 0\n\n    # 1. Identify the separator_color\n    separator_color = find_separator_color(grid)\n    if separator_color is None:\n        # If no separator color is found, the transformation likely doesn't apply.\n        print(\"Warning: No unique separator color identified. Returning original grid.\")\n        return input_grid\n\n    # 2. Identify Separator Locations (rows and columns)\n    h_lines, v_lines = find_separator_lines(grid, separator_color)\n\n    # 3. Define Horizontal Boundaries for strips\n    # Include 0 and grid height as implicit boundaries. Use set to remove duplicates.\n    h_boundaries = sorted(list(set([0] + h_lines + [rows])))\n\n    # 4. Iterate through each potential Horizontal Strip defined by boundaries\n    for i in range(len(h_boundaries) - 1):\n        strip_start_row = h_boundaries[i] # Top boundary row index\n        strip_end_row = h_boundaries[i+1]   # Bottom boundary row index (exclusive)\n\n        # Determine the actual row range for content *within* the strip.\n        # If the strip starts exactly on a separator line, the content starts one row below.\n        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row\n        \n        # If the content start row is already at or past the end row,\n        # this \"strip\" is just a separator line itself or an empty gap. Skip it.\n        if content_start_row >= strip_end_row:\n            continue \n\n        # 4c. Define the Leftmost Quadrant's column range\n        col_start = 0\n        col_end = cols # Default to full width if no vertical separators exist\n        # Find the index of the first vertical separator line (if any)\n        for v_line_idx in sorted(v_lines):\n            if v_line_idx >= 0: # Check index validity (>=0 is fine, >0 means not the first col)\n                col_end = v_line_idx\n                break\n        \n        # Ensure the calculated quadrant dimensions are valid before slicing\n        if content_start_row >= strip_end_row or col_start >= col_end:\n             # This case might happen if v_line_idx is 0\n             print(f\"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions (rows {content_start_row}-{strip_end_row-1}, cols {col_start}-{col_end-1}).\")\n             continue\n\n        # 4d. Find the source_color within the defined leftmost quadrant slice\n        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]\n        source_color = find_source_color(leftmost_quadrant_slice, separator_color, background_color)\n\n        # If no source color is found in the leftmost quadrant, this strip doesn't get processed.\n        # (Based on examples, a source color is usually found if there's content)\n        if source_color is None:\n            # print(f\"Debug: No source color found for strip {i+1} (Rows {content_start_row}-{strip_end_row-1}). Skipping fill.\")\n            continue\n\n        # 4e. Recolor the applicable cells within the Strip in the Output Grid\n        # Iterate through all cells within the content rows (content_start_row to strip_end_row-1)\n        # across the *full width* of the grid.\n        for r in range(content_start_row, strip_end_row):\n            for c in range(cols):\n                # Get the color of the cell from the *original* input grid\n                original_cell_color = grid[r, c]\n                \n                # Check if the original cell is *neither* background *nor* separator color\n                if original_cell_color != background_color and original_cell_color != separator_color:\n                    # If it meets the criteria, update the corresponding cell in the output grid\n                    # with the source_color found for this strip.\n                    output_grid[r, c] = source_color\n                # Otherwise (if original cell was background or separator), \n                # the output_grid[r, c] retains its copied value from the input grid.\n\n    # Convert the final numpy array back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13566,
    "candidates_token_count": 3029,
    "total_token_count": 16595,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.732413,
  "retries": 1
}