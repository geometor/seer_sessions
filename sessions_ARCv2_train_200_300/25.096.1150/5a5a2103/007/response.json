{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the grid by filling horizontal strips based on a 'source_color' \nfound in the leftmost quadrant of each strip, while preserving separator lines.\n\n1.  Identifies a unique 'separator_color' that forms complete horizontal and \n    vertical lines across the grid.\n2.  Finds the row and column indices of these separator lines.\n3.  Defines horizontal strips as the regions between consecutive horizontal \n    separator lines (or grid edges).\n4.  For each horizontal strip:\n    a. Determines the content rows (excluding the top separator line if present).\n    b. Identifies the 'leftmost quadrant' (from column 0 up to the first vertical \n       separator line or the right grid edge) within the content rows.\n    c. Scans the leftmost quadrant (row by row, column by column) to find the \n       first cell whose color is *not* the background color (0) and *not* the \n       separator color. This color is the 'source_color' for the strip.\n    d. If a source_color is found, iterates through all cells within the strip's \n       content rows (across the full width of the grid).\n    e. If a cell in the *input* grid at position (r, c) is *not* the \n       separator_color, then the corresponding cell in the *output* grid at (r, c) \n       is set to the 'source_color'.\n    f. Cells that originally contained the separator_color remain unchanged.\n\"\"\"\n\ndef find_separator_color(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds the unique non-zero color that forms complete horizontal rows \n    AND complete vertical columns. Returns None if no such unique color exists.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return None\n        \n    potential_h_colors = set()\n    potential_v_colors = set()\n\n    # Check horizontal lines fully spanning the grid\n    for r in range(rows):\n       first_val = grid[r, 0]\n       if first_val != 0 and np.all(grid[r, :] == first_val):\n           potential_h_colors.add(first_val)\n\n    # Check vertical lines fully spanning the grid\n    for c in range(cols):\n        first_val = grid[0, c]\n        if first_val != 0 and np.all(grid[:, c] == first_val):\n           potential_v_colors.add(first_val)\n\n    # The separator color must form both complete horizontal and vertical lines\n    separator_colors = potential_h_colors.intersection(potential_v_colors)\n\n    if len(separator_colors) == 1:\n        return separator_colors.pop()\n    elif len(separator_colors) > 1:\n         # Heuristic for ambiguity: return the smallest value.\n         # print(f\"Warning: Multiple potential separator colors found: {separator_colors}. Choosing smallest.\")\n         return min(separator_colors)\n         \n    # Optional Fallback (commented out as strict definition seems correct for examples)\n    # color_in_any_full_row = {} # color -> set of row indices\n    # color_in_any_full_col = {} # color -> set of col indices\n    # ... (rest of fallback logic) ...\n    # if len(common_colors_fallback) == 1: return common_colors_fallback.pop()\n    # elif len(common_colors_fallback) > 1: return min(common_colors_fallback)\n\n    return None # No single color forms both full rows and columns\n\n\ndef find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns completely filled with the separator color.\"\"\"\n    rows, cols = grid.shape\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]\n    return h_lines, v_lines\n\ndef find_source_color_in_slice(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the first non-background, non-separator color in the given grid slice.\n    Searches row by row, then column by column. Returns color or None.\n    \"\"\"\n    if grid_slice.size == 0: # Handle empty slice case\n        return None\n        \n    rows, cols = grid_slice.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_slice[r, c]\n            if color != background_color and color != separator_color:\n                return color\n    return None # No source color found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"Applies the transformation rule to the input grid.\"\"\"\n    \n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    if rows == 0 or cols == 0:\n        return input_grid # Return empty or invalid grid as is\n\n    # Initialize output_grid as a copy of the input grid.\n    output_grid = grid.copy()\n    background_color = 0\n\n    # 1. Identify the separator_color\n    separator_color = find_separator_color(grid)\n    if separator_color is None:\n        # If no separator color is found, return the original grid.\n        # print(\"Warning: No unique separator color identified. Returning original grid.\")\n        return input_grid\n\n    # 2. Identify Separator Locations (rows and columns)\n    h_lines, v_lines = find_separator_lines(grid, separator_color)\n\n    # 3. Define Horizontal Boundaries for strips\n    # Include 0 and grid height as implicit boundaries.\n    h_boundaries = sorted(list(set([0] + h_lines + [rows])))\n\n    # 4. Iterate through each potential Horizontal Strip defined by boundaries\n    for i in range(len(h_boundaries) - 1):\n        strip_start_row = h_boundaries[i] # Top boundary row index (inclusive)\n        strip_end_row = h_boundaries[i+1]   # Bottom boundary row index (exclusive)\n\n        # 4a. Determine the actual row range for content *within* the strip.\n        # If the strip starts exactly on a separator line, the content starts one row below.\n        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row\n        \n        # 4b. Skip if strip contains no content rows\n        if content_start_row >= strip_end_row:\n            continue \n\n        # 4c. Define the Leftmost Quadrant's column range\n        col_start = 0\n        col_end = cols # Default to full width if no vertical separators exist\n        # Find the index of the first vertical separator line (if any)\n        for v_line_idx in sorted(v_lines):\n             # Use >= 0 check as a separator could technically be at column 0\n             if v_line_idx >= 0: \n                col_end = v_line_idx\n                break\n        \n        # 4d. Skip if leftmost quadrant has invalid dimensions\n        if content_start_row >= strip_end_row or col_start >= col_end:\n             # This can happen if col_end becomes 0\n             # print(f\"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions.\")\n             continue\n\n        # 4e. Find the source_color within the defined leftmost quadrant slice\n        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]\n        source_color = find_source_color_in_slice(leftmost_quadrant_slice, separator_color, background_color)\n\n        # 4f. If no source color found, skip filling this strip\n        if source_color is None:\n            # print(f\"Debug: No source color found for strip {i+1}. Skipping fill.\")\n            continue\n\n        # 5. Fill the current strip in the output_grid\n        # Iterate through all cells within the content rows across the *full width*.\n        for r in range(content_start_row, strip_end_row):\n            for c in range(cols):\n                # Check the color in the original input grid at (r, c).\n                # If it's NOT the separator color, update the output grid with the source color.\n                if grid[r, c] != separator_color:\n                    output_grid[r, c] = source_color\n                # Implicit else: if grid[r,c] == separator_color, output_grid[r,c] \n                # keeps its original value (which is the separator_color because \n                # output_grid started as a copy).\n\n    # Convert the final numpy array back to a list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18875,
    "candidates_token_count": 2537,
    "total_token_count": 21412,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.209631,
  "retries": 1
}