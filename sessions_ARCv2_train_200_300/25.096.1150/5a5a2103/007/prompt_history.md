
## train_1

**input:**
```
0 0 0 0 8 0 5 5 0 8 0 0 0 0
0 2 2 0 8 0 0 5 0 8 0 0 0 0
0 2 2 0 8 5 5 5 5 8 0 0 0 0
0 0 0 0 8 0 5 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
```


**output:**
```
0 2 2 0 8 0 2 2 0 8 0 2 2 0
0 0 2 0 8 0 0 2 0 8 0 0 2 0
2 2 2 2 8 2 2 2 2 8 2 2 2 2
0 2 0 0 8 0 2 0 0 8 0 2 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 3 3 0 8 0 3 3 0 8 0 3 3 0
0 0 3 0 8 0 0 3 0 8 0 0 3 0
3 3 3 3 8 3 3 3 3 8 3 3 3 3
0 3 0 0 8 0 3 0 0 8 0 3 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 1 1 0 8 0 1 1 0 8 0 1 1 0
0 0 1 0 8 0 0 1 0 8 0 0 1 0
1 1 1 1 8 1 1 1 1 8 1 1 1 1
0 1 0 0 8 0 1 0 0 8 0 1 0 0
```


## train_2

**input:**
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 6 6 0 6 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 0 6 6 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 6 0 3 0 0 0 0 3 0 0 0 0
```


**output:**
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
4 4 0 4 3 4 4 0 4 3 4 4 0 4 3 4 4 0 4
0 4 4 0 3 0 4 4 0 3 0 4 4 0 3 0 4 4 0
0 0 4 0 3 0 0 4 0 3 0 0 4 0 3 0 0 4 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
2 2 0 2 3 2 2 0 2 3 2 2 0 2 3 2 2 0 2
0 2 2 0 3 0 2 2 0 3 0 2 2 0 3 0 2 2 0
0 0 2 0 3 0 0 2 0 3 0 0 2 0 3 0 0 2 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
8 8 0 8 3 8 8 0 8 3 8 8 0 8 3 8 8 0 8
0 8 8 0 3 0 8 8 0 3 0 8 8 0 3 0 8 8 0
0 0 8 0 3 0 0 8 0 3 0 0 8 0 3 0 0 8 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
1 1 0 1 3 1 1 0 1 3 1 1 0 1 3 1 1 0 1
0 1 1 0 3 0 1 1 0 3 0 1 1 0 3 0 1 1 0
0 0 1 0 3 0 0 1 0 3 0 0 1 0 3 0 0 1 0
```

Okay, let's break down the task based on the provided examples.

**Perception of Elements:**

1.  **Grid Structure:** Both inputs and outputs are 2D grids of integers representing colors.
2.  **Separator Lines:** There are distinct horizontal and vertical lines composed of a single color (color `8` in train\_1, color `3` in train\_2). These lines divide the grid into smaller rectangular regions or "quadrants".
3.  **Background Color:** The color `0` acts as a background or empty space.
4.  **Content Colors:** Within the quadrants defined by the separator lines, there are other non-zero colors (e.g., `1`, `2`, `3`, `5` in train\_1; `1`, `2`, `4`, `6`, `8` in train\_2). These often appear as small blocks or individual pixels.
5.  **Transformation Goal:** The transformation fills the non-separator areas of the grid. The fill color for a horizontal "strip" of quadrants seems determined by a specific color found within the leftmost quadrant of that strip.
6.  **Color Propagation:** The color found in the leftmost quadrant of a horizontal strip (between two horizontal separator lines) propagates horizontally across that entire strip, overwriting any background (`0`) or other content colors (`5`, `6` in the examples) within that strip, but stopping at the vertical separator lines.
7.  **Separator Preservation:** The separator lines (horizontal and vertical) remain unchanged in the output.

**YAML Fact Document:**


```yaml
task_description: "Fill regions of a grid based on a color found in the leftmost region of each horizontal strip."
elements:
  - object: grid
    properties:
      - type: 2D array of integers
      - represents: colored cells
  - object: separator_lines
    properties:
      - type: horizontal and vertical lines
      - composition: composed of a single, non-zero 'separator_color'
      - function: divide the grid into rectangular 'quadrants'
  - object: background
    properties:
      - color_value: 0
      - role: empty space within quadrants
  - object: content_pixels
    properties:
      - type: non-zero, non-separator colored cells
      - location: within quadrants
      - role: potential source colors for filling
  - object: quadrants
    properties:
      - type: rectangular subgrids
      - boundaries: defined by separator lines or grid edges
  - object: horizontal_strips
    properties:
      - type: collection of quadrants aligned horizontally between two horizontal separator lines (or grid edge)
actions:
  - action: identify_separator_color
    inputs: [input_grid]
    outputs: [separator_color]
    description: "Find the color that forms complete horizontal and vertical lines across the grid."
  - action: identify_quadrant_strips
    inputs: [input_grid, separator_color]
    outputs: [list_of_strips]
    description: "Identify the horizontal strips of quadrants based on horizontal separator lines."
  - action: find_source_color_for_strip
    inputs: [strip]
    outputs: [source_color]
    description: "Scan the leftmost quadrant of the strip to find the first non-background, non-separator color."
  - action: fill_strip
    inputs: [output_grid, strip, source_color, separator_color]
    outputs: [modified_output_grid]
    description: "Fill all non-separator cells within the strip in the output grid with the source_color."
relationships:
  - relationship: separator_lines_define_quadrants
    entities: [separator_lines, quadrants]
  - relationship: quadrants_form_strips
    entities: [quadrants, horizontal_strips]
  - relationship: leftmost_quadrant_determines_strip_fill
    entities: [quadrants, horizontal_strips, content_pixels]
    details: "The fill color for a strip is determined by a content pixel in its leftmost quadrant."
```


**Natural Language Program:**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the `separator_color` by finding the color that forms solid horizontal and vertical lines spanning the grid dimensions.
3.  Identify the row indices of the horizontal separator lines and the column indices of the vertical separator lines.
4.  Iterate through the horizontal "strips" defined by consecutive horizontal separator lines (or grid edges). For each strip:
    a.  Determine the row range of the current strip.
    b.  Identify the first (leftmost) quadrant within this strip (columns from the start up to the first vertical separator line, or the full width if no vertical separators exist).
    c.  Scan the cells within this leftmost quadrant (e.g., row by row, then column by column). Find the first cell whose color is not the background color (`0`) and not the `separator_color`. Store this color as the `source_color` for the current strip. If no such color is found, the strip might remain unchanged or filled with background (the examples suggest a source color is always found).
    d.  Iterate through all cells `(r, c)` within the row range of the current strip.
    e.  If the cell `(r, c)` in the input grid does *not* contain the `separator_color`, update the corresponding cell `(r, c)` in the output grid with the determined `source_color`.
5.  Return the modified output grid.
```python
import numpy as np
from typing import List, Tuple, Optional

"""
Transforms an input grid by identifying horizontal and vertical separator lines 
of a single color. These lines divide the grid into quadrants. For each 
horizontal strip of quadrants (defined by horizontal separators or grid edges), 
it finds the first non-background (0), non-separator color in the leftmost 
quadrant of that strip. It then fills all non-separator cells within that 
entire horizontal strip with this identified 'source' color.
"""

def find_separator_color(grid: np.ndarray) -> Optional[int]:
    """
    Finds the color that forms complete horizontal and vertical lines.
    Assumes only one such color exists.
    """
    rows, cols = grid.shape
    potential_h_colors = set()
    potential_v_colors = set()

    # Check horizontal lines
    for r in range(rows):
        first_val = grid[r, 0]
        if first_val != 0 and np.all(grid[r, :] == first_val):
            potential_h_colors.add(first_val)

    # Check vertical lines
    for c in range(cols):
        first_val = grid[0, c]
        if first_val != 0 and np.all(grid[:, c] == first_val):
            potential_v_colors.add(first_val)

    # The separator color must form both horizontal and vertical lines
    separator_colors = potential_h_colors.intersection(potential_v_colors)

    if len(separator_colors) == 1:
        return separator_colors.pop()
    elif len(separator_colors) > 1:
        # Handle ambiguity if needed, for now, return the first found
        # In the examples, there seems to be only one clear separator.
         print(f"Warning: Multiple potential separator colors found: {separator_colors}. Choosing first.")
         return list(separator_colors)[0] # This behavior might need adjustment based on more examples
    else:
        # Check if any color forms at least one full row and one full col, even if not all rows/cols
        # This covers cases where separators might not span the entire grid but define the structure
        color_in_full_row = {} # color -> set of row indices
        color_in_full_col = {} # color -> set of col indices

        for r in range(rows):
           unique_colors = np.unique(grid[r, :])
           if len(unique_colors) == 1 and unique_colors[0] != 0:
               color = unique_colors[0]
               if color not in color_in_full_row: color_in_full_row[color] = set()
               color_in_full_row[color].add(r)

        for c in range(cols):
            unique_colors = np.unique(grid[:, c])
            if len(unique_colors) == 1 and unique_colors[0] != 0:
               color = unique_colors[0]
               if color not in color_in_full_col: color_in_full_col[color] = set()
               color_in_full_col[color].add(c)

        common_colors = set(color_in_full_row.keys()).intersection(set(color_in_full_col.keys()))
        if common_colors:
             if len(common_colors) == 1:
                 return common_colors.pop()
             else:
                  # Fallback logic: check which color appears most frequently in full rows/cols?
                  # Or maybe the one with the lowest/highest index?
                  # For now, return the smallest color value among them as a guess.
                  print(f"Warning: Multiple potential separator colors found (partial lines): {common_colors}. Choosing smallest.")
                  return min(common_colors)
        return None # No clear separator found

def find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:
    """Finds the indices of rows and columns completely filled with the separator color."""
    rows, cols = grid.shape
    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]
    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]
    return h_lines, v_lines

def find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> int:
    """
    Finds the first non-background, non-separator color in the given grid slice.
    Searches row by row, then column by column.
    Returns background_color if no suitable source color is found.
    """
    rows, cols = grid_slice.shape
    for r in range(rows):
        for c in range(cols):
            color = grid_slice[r, c]
            if color != background_color and color != separator_color:
                return color
    return background_color # Default if no source color found

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Transforms the grid by filling horizontal strips based on the color found
    in the leftmost quadrant of each strip, preserving separator lines.
    """
    # Convert to numpy array for easier slicing and manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy() # Initialize output grid
    rows, cols = grid.shape
    background_color = 0

    # --- Identify Separators ---
    separator_color = find_separator_color(grid)
    if separator_color is None:
        # If no separator is found, maybe the transformation doesn't apply?
        # Return the original grid or handle based on expected behavior.
        print("Warning: No separator color identified. Returning original grid.")
        return input_grid # Or output_grid.tolist()

    h_lines, v_lines = find_separator_lines(grid, separator_color)

    # --- Define Horizontal Strips ---
    # Add grid boundaries to the horizontal line indices
    h_boundaries = sorted(list(set([0] + h_lines + [rows])))

    # --- Process Each Horizontal Strip ---
    for i in range(len(h_boundaries) - 1):
        row_start = h_boundaries[i]
        row_end = h_boundaries[i+1]

        # Skip if the strip is actually a separator line itself
        if row_start in h_lines:
            continue
            
        # --- Find Leftmost Quadrant ---
        # Define the column boundaries for the leftmost quadrant
        first_v_line_or_edge = cols
        for v_line_idx in sorted(v_lines):
             if v_line_idx > 0: # Consider vertical separators not at the very edge
                 first_v_line_or_edge = v_line_idx
                 break
        col_start = 0
        col_end = first_v_line_or_edge

        # --- Find Source Color in Leftmost Quadrant ---
        leftmost_quadrant = grid[row_start:row_end, col_start:col_end]
        source_color = find_source_color(leftmost_quadrant, separator_color, background_color)

        # --- Fill the Strip in the Output Grid ---
        # Iterate through all cells in the current horizontal strip
        for r in range(row_start, row_end):
            for c in range(cols):
                # Only fill cells that are NOT part of a separator line (horizontal or vertical)
                is_separator_cell = (grid[r, c] == separator_color)
                # More robust check: is the cell part of *any* identified separator line?
                # This handles cases where a cell might be separator color but not part of a *full* line identified earlier.
                # The core logic from examples seems simpler: if input cell is separator color, keep it. Otherwise, fill.
                if grid[r, c] != separator_color:
                     output_grid[r, c] = source_color


    # Convert back to list of lists for the final output
    return output_grid.tolist()
```
```python
import numpy as np
from typing import List, Tuple, Optional

"""
Transforms the grid by filling horizontal strips based on the color found
in the leftmost quadrant of each strip, preserving separator lines.

1. Identifies a unique 'separator_color' that forms complete horizontal and 
   vertical lines.
2. Finds the row and column indices of these separator lines.
3. Defines horizontal strips as the regions between consecutive horizontal 
   separator lines (or grid edges).
4. For each horizontal strip:
   a. Identifies the 'leftmost quadrant' (from column 0 to the first vertical 
      separator line or grid edge).
   b. Finds the first 'source_color' (non-background, non-separator) within 
      this leftmost quadrant.
   c. Fills all cells within the entire horizontal strip (full width) in the 
      output grid with this 'source_color', *unless* the corresponding cell 
      in the input grid contains the 'separator_color'.
"""

def find_separator_color(grid: np.ndarray) -> Optional[int]:
    """
    Finds the unique non-zero color that forms complete horizontal rows 
    AND complete vertical columns. Returns None if no such unique color exists.
    """
    rows, cols = grid.shape
    if rows == 0 or cols == 0:
        return None
        
    color_in_full_row = {} # color -> set of row indices
    color_in_full_col = {} # color -> set of col indices

    # Check horizontal lines
    for r in range(rows):
       # Check if all elements in the row are the same and not zero
       first_val = grid[r, 0]
       if first_val != 0 and np.all(grid[r, :] == first_val):
           color = first_val
           if color not in color_in_full_row: color_in_full_row[color] = set()
           color_in_full_row[color].add(r)

    # Check vertical lines
    for c in range(cols):
        # Check if all elements in the col are the same and not zero
        first_val = grid[0, c]
        if first_val != 0 and np.all(grid[:, c] == first_val):
           color = first_val
           if color not in color_in_full_col: color_in_full_col[color] = set()
           color_in_full_col[color].add(c)

    # Find colors present in both full rows and full columns
    common_colors = set(color_in_full_row.keys()).intersection(set(color_in_full_col.keys()))

    if len(common_colors) == 1:
        return common_colors.pop()
    elif len(common_colors) > 1:
         # Heuristic for ambiguity: return the one with most lines? Or smallest value?
         # Based on ARC tasks, usually there's a single clear separator if this pattern holds.
         # Let's return the smallest color value as a tie-breaker for now.
         print(f"Warning: Multiple potential separator colors found: {common_colors}. Choosing smallest.")
         return min(common_colors)
         
    return None # No single color forms both full rows and columns

def find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:
    """Finds the indices of rows and columns completely filled with the separator color."""
    rows, cols = grid.shape
    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]
    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]
    return h_lines, v_lines

def find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:
    """
    Finds the first non-background, non-separator color in the given grid slice.
    Searches row by row, then column by column.
    Returns the color if found, otherwise None.
    """
    if grid_slice.size == 0: # Handle empty slice case
        return None
        
    rows, cols = grid_slice.shape
    for r in range(rows):
        for c in range(cols):
            color = grid_slice[r, c]
            if color != background_color and color != separator_color:
                return color
    return None # No source color found

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    """
    # Convert input to numpy array for efficient operations
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return input_grid # Return empty or invalid grid as is

    # Initialize output_grid as a copy of the input grid
    output_grid = grid.copy()
    background_color = 0

    # 1. Identify the separator_color
    separator_color = find_separator_color(grid)
    if separator_color is None:
        # If no separator color is found based on the strict definition,
        # return the original grid. (Or apply alternative logic if needed)
        print("Warning: No unique separator color found. Returning original grid.")
        return input_grid

    # 2. Identify Separator Locations
    h_lines, v_lines = find_separator_lines(grid, separator_color)

    # 3. Define Horizontal Boundaries
    h_boundaries = sorted(list(set([0] + h_lines + [rows])))

    # 4. Iterate through Horizontal Strips
    for i in range(len(h_boundaries) - 1):
        strip_start_row = h_boundaries[i]
        strip_end_row = h_boundaries[i+1]

        # 4a. Determine the actual content rows for the strip
        # If the strip starts *on* a separator line, content begins on the next row
        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row
        
        # 4b. Check for valid content strip (must have height > 0)
        if content_start_row >= strip_end_row:
            continue # This is just a separator line row or an empty gap

        # 4c. Define the Leftmost Quadrant column range
        col_start = 0
        col_end = cols # Default to full width
        for v_line_idx in sorted(v_lines):
            if v_line_idx > 0: # Find the first vertical separator after column 0
                col_end = v_line_idx
                break
        
        # Ensure quadrant dimensions are valid before slicing
        if content_start_row >= strip_end_row or col_start >= col_end:
             print(f"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions.")
             continue

        # 4d. Find the source_color in the leftmost quadrant
        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]
        source_color = find_source_color(leftmost_quadrant_slice, separator_color, background_color)

        # If no source color is found in the leftmost quadrant, skip filling this strip
        # (Based on examples, a source color seems expected if the strip has content)
        if source_color is None:
            print(f"Warning: No source color found for strip {i+1} (Rows {content_start_row}-{strip_end_row-1}). Skipping fill.")
            continue

        # 4e. Fill the Strip in Output Grid
        # Iterate through all cells within the content rows of the current strip
        for r in range(content_start_row, strip_end_row):
            for c in range(cols):
                # Check the corresponding cell in the *input* grid
                # Only update the output cell if the input cell is NOT the separator color
                if grid[r, c] != separator_color:
                    output_grid[r, c] = source_color

    # Convert the final numpy array back to a list of lists
    return output_grid.tolist()
```
```python
import numpy as np
from typing import List, Tuple, Optional

"""
Transforms the grid by recoloring specific cells within horizontal strips defined 
by separator lines.

1. Identifies a unique 'separator_color' that forms complete horizontal and 
   vertical lines across the grid.
2. Finds the row and column indices of these separator lines.
3. Defines horizontal strips as the regions between consecutive horizontal 
   separator lines (or grid edges).
4. For each horizontal strip:
   a. Identifies the 'leftmost quadrant' (from column 0 up to the first vertical 
      separator line or the right grid edge).
   b. Scans the leftmost quadrant (row by row, column by column) to find the 
      first cell whose color is *not* the background color (0) and *not* the 
      separator color. This color is the 'source_color' for the strip.
   c. Iterates through all cells within the current horizontal strip (across 
      the full width of the grid).
   d. If a cell in the *input* grid at position (r, c) contains a color that 
      is *neither* the background color (0) *nor* the separator color, then 
      the corresponding cell in the *output* grid at (r, c) is set to the 
      'source_color' found for that strip.
   e. Cells that originally contained the background color (0) or the 
      separator_color remain unchanged in the output grid.
"""


def find_separator_color(grid: np.ndarray) -> Optional[int]:
    """
    Finds the unique non-zero color that forms complete horizontal rows 
    AND complete vertical columns. Returns None if no such unique color exists.
    Uses a stricter definition focusing on lines spanning the entire grid.
    """
    rows, cols = grid.shape
    if rows == 0 or cols == 0:
        return None
        
    potential_h_colors = set()
    potential_v_colors = set()

    # Check horizontal lines fully spanning the grid
    for r in range(rows):
       first_val = grid[r, 0]
       if first_val != 0 and np.all(grid[r, :] == first_val):
           potential_h_colors.add(first_val)

    # Check vertical lines fully spanning the grid
    for c in range(cols):
        first_val = grid[0, c]
        if first_val != 0 and np.all(grid[:, c] == first_val):
           potential_v_colors.add(first_val)

    # The separator color must form both complete horizontal and vertical lines
    separator_colors = potential_h_colors.intersection(potential_v_colors)

    if len(separator_colors) == 1:
        return separator_colors.pop()
    elif len(separator_colors) > 1:
         # Heuristic for ambiguity: return the smallest value.
         print(f"Warning: Multiple potential separator colors found: {separator_colors}. Choosing smallest.")
         return min(separator_colors)
         
    # Fallback: Check for colors that form *any* full row and *any* full column
    # (Less strict than the above, might be needed for other variants)
    # This part is less likely needed based on current examples but kept for robustness idea.
    color_in_any_full_row = {} # color -> set of row indices
    color_in_any_full_col = {} # color -> set of col indices

    for r in range(rows):
       unique_colors = np.unique(grid[r, :])
       if len(unique_colors) == 1 and unique_colors[0] != 0:
           color = unique_colors[0]
           if color not in color_in_any_full_row: color_in_any_full_row[color] = set()
           color_in_any_full_row[color].add(r)

    for c in range(cols):
        unique_colors = np.unique(grid[:, c])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
           color = unique_colors[0]
           if color not in color_in_any_full_col: color_in_any_full_col[color] = set()
           color_in_any_full_col[color].add(c)
           
    common_colors_fallback = set(color_in_any_full_row.keys()).intersection(set(color_in_any_full_col.keys()))
    if len(common_colors_fallback) == 1:
         print(f"Warning: Found separator using fallback logic: {common_colors_fallback}")
         return common_colors_fallback.pop()
    elif len(common_colors_fallback) > 1:
         print(f"Warning: Multiple potential separator colors found (fallback): {common_colors_fallback}. Choosing smallest.")
         return min(common_colors_fallback)

    return None # No single color forms both full rows and columns


def find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:
    """Finds the indices of rows and columns completely filled with the separator color."""
    rows, cols = grid.shape
    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]
    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]
    return h_lines, v_lines

def find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:
    """
    Finds the first non-background, non-separator color in the given grid slice.
    Searches row by row, then column by column.
    Returns the color if found, otherwise None.
    """
    if grid_slice.size == 0: # Handle empty slice case
        return None
        
    rows, cols = grid_slice.shape
    for r in range(rows):
        for c in range(cols):
            color = grid_slice[r, c]
            if color != background_color and color != separator_color:
                return color
    return None # No source color found

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    """
    # Convert input to numpy array for efficient operations
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return input_grid # Return empty or invalid grid as is

    # Initialize output_grid as a copy of the input grid. This preserves
    # background and separator cells unless explicitly changed.
    output_grid = grid.copy()
    background_color = 0

    # 1. Identify the separator_color
    separator_color = find_separator_color(grid)
    if separator_color is None:
        # If no separator color is found, the transformation likely doesn't apply.
        print("Warning: No unique separator color identified. Returning original grid.")
        return input_grid

    # 2. Identify Separator Locations (rows and columns)
    h_lines, v_lines = find_separator_lines(grid, separator_color)

    # 3. Define Horizontal Boundaries for strips
    # Include 0 and grid height as implicit boundaries. Use set to remove duplicates.
    h_boundaries = sorted(list(set([0] + h_lines + [rows])))

    # 4. Iterate through each potential Horizontal Strip defined by boundaries
    for i in range(len(h_boundaries) - 1):
        strip_start_row = h_boundaries[i] # Top boundary row index
        strip_end_row = h_boundaries[i+1]   # Bottom boundary row index (exclusive)

        # Determine the actual row range for content *within* the strip.
        # If the strip starts exactly on a separator line, the content starts one row below.
        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row
        
        # If the content start row is already at or past the end row,
        # this "strip" is just a separator line itself or an empty gap. Skip it.
        if content_start_row >= strip_end_row:
            continue 

        # 4c. Define the Leftmost Quadrant's column range
        col_start = 0
        col_end = cols # Default to full width if no vertical separators exist
        # Find the index of the first vertical separator line (if any)
        for v_line_idx in sorted(v_lines):
            if v_line_idx >= 0: # Check index validity (>=0 is fine, >0 means not the first col)
                col_end = v_line_idx
                break
        
        # Ensure the calculated quadrant dimensions are valid before slicing
        if content_start_row >= strip_end_row or col_start >= col_end:
             # This case might happen if v_line_idx is 0
             print(f"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions (rows {content_start_row}-{strip_end_row-1}, cols {col_start}-{col_end-1}).")
             continue

        # 4d. Find the source_color within the defined leftmost quadrant slice
        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]
        source_color = find_source_color(leftmost_quadrant_slice, separator_color, background_color)

        # If no source color is found in the leftmost quadrant, this strip doesn't get processed.
        # (Based on examples, a source color is usually found if there's content)
        if source_color is None:
            # print(f"Debug: No source color found for strip {i+1} (Rows {content_start_row}-{strip_end_row-1}). Skipping fill.")
            continue

        # 4e. Recolor the applicable cells within the Strip in the Output Grid
        # Iterate through all cells within the content rows (content_start_row to strip_end_row-1)
        # across the *full width* of the grid.
        for r in range(content_start_row, strip_end_row):
            for c in range(cols):
                # Get the color of the cell from the *original* input grid
                original_cell_color = grid[r, c]
                
                # Check if the original cell is *neither* background *nor* separator color
                if original_cell_color != background_color and original_cell_color != separator_color:
                    # If it meets the criteria, update the corresponding cell in the output grid
                    # with the source_color found for this strip.
                    output_grid[r, c] = source_color
                # Otherwise (if original cell was background or separator), 
                # the output_grid[r, c] retains its copied value from the input grid.

    # Convert the final numpy array back to a list of lists for the required output format
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from typing import List, Tuple, Optional

"""
Transforms the grid by recoloring specific cells within horizontal strips defined 
by separator lines.

1. Identifies a unique 'separator_color' that forms complete horizontal and 
   vertical lines across the grid.
2. Finds the row and column indices of these separator lines.
3. Defines horizontal strips as the regions between consecutive horizontal 
   separator lines (or grid edges).
4. For each horizontal strip:
   a. Identifies the 'leftmost quadrant' (from column 0 up to the first vertical 
      separator line or the right grid edge).
   b. Scans the leftmost quadrant (row by row, column by column) to find the 
      first cell whose color is *not* the background color (0) and *not* the 
      separator color. This color is the 'source_color' for the strip.
   c. Iterates through all cells within the current horizontal strip (across 
      the full width of the grid).
   d. If a cell in the *input* grid at position (r, c) contains a color that 
      is *neither* the background color (0) *nor* the separator color, then 
      the corresponding cell in the *output* grid at (r, c) is set to the 
      'source_color' found for that strip.
   e. Cells that originally contained the background color (0) or the 
      separator_color remain unchanged in the output grid.
"""


def find_separator_color(grid: np.ndarray) -> Optional[int]:
    """
    Finds the unique non-zero color that forms complete horizontal rows 
    AND complete vertical columns. Returns None if no such unique color exists.
    Uses a stricter definition focusing on lines spanning the entire grid.
    """
    rows, cols = grid.shape
    if rows == 0 or cols == 0:
        return None
        
    potential_h_colors = set()
    potential_v_colors = set()

    # Check horizontal lines fully spanning the grid
    for r in range(rows):
       first_val = grid[r, 0]
       if first_val != 0 and np.all(grid[r, :] == first_val):
           potential_h_colors.add(first_val)

    # Check vertical lines fully spanning the grid
    for c in range(cols):
        first_val = grid[0, c]
        if first_val != 0 and np.all(grid[:, c] == first_val):
           potential_v_colors.add(first_val)

    # The separator color must form both complete horizontal and vertical lines
    separator_colors = potential_h_colors.intersection(potential_v_colors)

    if len(separator_colors) == 1:
        return separator_colors.pop()
    elif len(separator_colors) > 1:
         # Heuristic for ambiguity: return the smallest value.
         print(f"Warning: Multiple potential separator colors found: {separator_colors}. Choosing smallest.")
         return min(separator_colors)
         
    # Fallback: Check for colors that form *any* full row and *any* full column
    # (Less strict than the above, might be needed for other variants)
    # This part is less likely needed based on current examples but kept for robustness idea.
    color_in_any_full_row = {} # color -> set of row indices
    color_in_any_full_col = {} # color -> set of col indices

    for r in range(rows):
       unique_colors = np.unique(grid[r, :])
       if len(unique_colors) == 1 and unique_colors[0] != 0:
           color = unique_colors[0]
           if color not in color_in_any_full_row: color_in_any_full_row[color] = set()
           color_in_any_full_row[color].add(r)

    for c in range(cols):
        unique_colors = np.unique(grid[:, c])
        if len(unique_colors) == 1 and unique_colors[0] != 0:
           color = unique_colors[0]
           if color not in color_in_any_full_col: color_in_any_full_col[color] = set()
           color_in_any_full_col[color].add(c)
           
    common_colors_fallback = set(color_in_any_full_row.keys()).intersection(set(color_in_any_full_col.keys()))
    if len(common_colors_fallback) == 1:
         print(f"Warning: Found separator using fallback logic: {common_colors_fallback}")
         return common_colors_fallback.pop()
    elif len(common_colors_fallback) > 1:
         print(f"Warning: Multiple potential separator colors found (fallback): {common_colors_fallback}. Choosing smallest.")
         return min(common_colors_fallback)

    return None # No single color forms both full rows and columns


def find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:
    """Finds the indices of rows and columns completely filled with the separator color."""
    rows, cols = grid.shape
    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]
    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]
    return h_lines, v_lines

def find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:
    """
    Finds the first non-background, non-separator color in the given grid slice.
    Searches row by row, then column by column.
    Returns the color if found, otherwise None.
    """
    if grid_slice.size == 0: # Handle empty slice case
        return None
        
    rows, cols = grid_slice.shape
    for r in range(rows):
        for c in range(cols):
            color = grid_slice[r, c]
            if color != background_color and color != separator_color:
                return color
    return None # No source color found

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies the transformation rule to the input grid.
    """
    # Convert input to numpy array for efficient operations
    grid = np.array(input_grid, dtype=int)
    rows, cols = grid.shape
    
    if rows == 0 or cols == 0:
        return input_grid # Return empty or invalid grid as is

    # Initialize output_grid as a copy of the input grid. This preserves
    # background and separator cells unless explicitly changed.
    output_grid = grid.copy()
    background_color = 0

    # 1. Identify the separator_color
    separator_color = find_separator_color(grid)
    if separator_color is None:
        # If no separator color is found, the transformation likely doesn't apply.
        print("Warning: No unique separator color identified. Returning original grid.")
        return input_grid

    # 2. Identify Separator Locations (rows and columns)
    h_lines, v_lines = find_separator_lines(grid, separator_color)

    # 3. Define Horizontal Boundaries for strips
    # Include 0 and grid height as implicit boundaries. Use set to remove duplicates.
    h_boundaries = sorted(list(set([0] + h_lines + [rows])))

    # 4. Iterate through each potential Horizontal Strip defined by boundaries
    for i in range(len(h_boundaries) - 1):
        strip_start_row = h_boundaries[i] # Top boundary row index
        strip_end_row = h_boundaries[i+1]   # Bottom boundary row index (exclusive)

        # Determine the actual row range for content *within* the strip.
        # If the strip starts exactly on a separator line, the content starts one row below.
        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row
        
        # If the content start row is already at or past the end row,
        # this "strip" is just a separator line itself or an empty gap. Skip it.
        if content_start_row >= strip_end_row:
            continue 

        # 4c. Define the Leftmost Quadrant's column range
        col_start = 0
        col_end = cols # Default to full width if no vertical separators exist
        # Find the index of the first vertical separator line (if any)
        for v_line_idx in sorted(v_lines):
            if v_line_idx >= 0: # Check index validity (>=0 is fine, >0 means not the first col)
                col_end = v_line_idx
                break
        
        # Ensure the calculated quadrant dimensions are valid before slicing
        if content_start_row >= strip_end_row or col_start >= col_end:
             # This case might happen if v_line_idx is 0
             print(f"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions (rows {content_start_row}-{strip_end_row-1}, cols {col_start}-{col_end-1}).")
             continue

        # 4d. Find the source_color within the defined leftmost quadrant slice
        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]
        source_color = find_source_color(leftmost_quadrant_slice, separator_color, background_color)

        # If no source color is found in the leftmost quadrant, this strip doesn't get processed.
        # (Based on examples, a source color is usually found if there's content)
        if source_color is None:
            # print(f"Debug: No source color found for strip {i+1} (Rows {content_start_row}-{strip_end_row-1}). Skipping fill.")
            continue

        # 4e. Recolor the applicable cells within the Strip in the Output Grid
        # Iterate through all cells within the content rows (content_start_row to strip_end_row-1)
        # across the *full width* of the grid.
        for r in range(content_start_row, strip_end_row):
            for c in range(cols):
                # Get the color of the cell from the *original* input grid
                original_cell_color = grid[r, c]
                
                # Check if the original cell is *neither* background *nor* separator color
                if original_cell_color != background_color and original_cell_color != separator_color:
                    # If it meets the criteria, update the corresponding cell in the output grid
                    # with the source_color found for this strip.
                    output_grid[r, c] = source_color
                # Otherwise (if original cell was background or separator), 
                # the output_grid[r, c] retains its copied value from the input grid.

    # Convert the final numpy array back to a list of lists for the required output format
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 8 0 5 5 0 8 0 0 0 0
0 2 2 0 8 0 0 5 0 8 0 0 0 0
0 2 2 0 8 5 5 5 5 8 0 0 0 0
0 0 0 0 8 0 5 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
```
Expected Output:
```
0 2 2 0 8 0 2 2 0 8 0 2 2 0
0 0 2 0 8 0 0 2 0 8 0 0 2 0
2 2 2 2 8 2 2 2 2 8 2 2 2 2
0 2 0 0 8 0 2 0 0 8 0 2 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 3 3 0 8 0 3 3 0 8 0 3 3 0
0 0 3 0 8 0 0 3 0 8 0 0 3 0
3 3 3 3 8 3 3 3 3 8 3 3 3 3
0 3 0 0 8 0 3 0 0 8 0 3 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 1 1 0 8 0 1 1 0 8 0 1 1 0
0 0 1 0 8 0 0 1 0 8 0 0 1 0
1 1 1 1 8 1 1 1 1 8 1 1 1 1
0 1 0 0 8 0 1 0 0 8 0 1 0 0
```
Transformed Output:
```
0 0 0 0 8 0 2 2 0 8 0 0 0 0
0 2 2 0 8 0 0 2 0 8 0 0 0 0
0 2 2 0 8 2 2 2 2 8 0 0 0 0
0 0 0 0 8 0 2 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 3 3 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
8 8 8 8 8 8 8 8 8 8 8 8 8 8
0 0 0 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 1 1 0 8 0 0 0 0 8 0 0 0 0
0 0 0 0 8 0 0 0 0 8 0 0 0 0
```
Match: False
Pixels Off: 58
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 59.18367346938774

## Example 2:
Input:
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 6 6 0 6 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 0 6 6 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 6 0 3 0 0 0 0 3 0 0 0 0
```
Expected Output:
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
4 4 0 4 3 4 4 0 4 3 4 4 0 4 3 4 4 0 4
0 4 4 0 3 0 4 4 0 3 0 4 4 0 3 0 4 4 0
0 0 4 0 3 0 0 4 0 3 0 0 4 0 3 0 0 4 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
2 2 0 2 3 2 2 0 2 3 2 2 0 2 3 2 2 0 2
0 2 2 0 3 0 2 2 0 3 0 2 2 0 3 0 2 2 0
0 0 2 0 3 0 0 2 0 3 0 0 2 0 3 0 0 2 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
8 8 0 8 3 8 8 0 8 3 8 8 0 8 3 8 8 0 8
0 8 8 0 3 0 8 8 0 3 0 8 8 0 3 0 8 8 0
0 0 8 0 3 0 0 8 0 3 0 0 8 0 3 0 0 8 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
1 1 0 1 3 1 1 0 1 3 1 1 0 1 3 1 1 0 1
0 1 1 0 3 0 1 1 0 3 0 1 1 0 3 0 1 1 0
0 0 1 0 3 0 0 1 0 3 0 0 1 0 3 0 0 1 0
```
Transformed Output:
```
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 4 4 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 2 2 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 8 8 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 3 0 0 0 0 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 1 1 0 1 3 0 0 0 0 3 0 0 0 0
0 1 1 0 3 0 1 1 0 3 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 1 0 3 0 0 0 0 3 0 0 0 0
```
Match: False
Pixels Off: 82
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 45.42936288088643
**General Assessment and Strategy:**

The previous code implementation failed because it incorrectly applied the filling logic. The analysis revealed that the transformation should fill *all* non-separator cells within a horizontal strip with the determined source color, including cells originally containing the background color (0). The previous logic only overwrote cells that already had a non-zero, non-separator color.

The metrics gathered confirmed this analysis, showing that the majority of pixel errors occurred on cells that were originally background (0) and should have been filled according to the expected output.

The strategy is to revise the Natural Language Program to accurately reflect this "fill-all-non-separators" rule within each strip and ensure the subsequent code implements this corrected logic.

**Metrics:**

*   **Example 1:**
    *   Input Shape: (14, 14)
    *   Output Shape: (14, 14)
    *   Separator Color: 8
    *   Pixels Incorrect (Previous Code): 58
    *   Incorrect Pixels Originally Background (0): 55
    *   Incorrect Pixels Originally Content (non-0, non-8): 3
*   **Example 2:**
    *   Input Shape: (19, 19)
    *   Output Shape: (19, 19)
    *   Separator Color: 3
    *   Pixels Incorrect (Previous Code): 82
    *   Incorrect Pixels Originally Background (0): 78
    *   Incorrect Pixels Originally Content (non-0, non-3): 4

**YAML Fact Document:**


```yaml
task_description: "Fill regions of a grid based on a color found in the leftmost region of each horizontal strip, preserving separator lines."
elements:
  - object: grid
    properties:
      - type: 2D array of integers
      - represents: colored cells
  - object: separator_lines
    properties:
      - type: horizontal and vertical lines
      - composition: composed of a single, non-zero 'separator_color'
      - function: divide the grid into rectangular 'quadrants' and define 'strips'
      - persistence: separator lines remain unchanged in the output
  - object: background
    properties:
      - color_value: 0
      - role: empty space, subject to being filled by a 'source_color'
  - object: content_pixels
    properties:
      - type: non-zero, non-separator colored cells
      - location: within quadrants/strips
      - role: 
        - potential 'source_color' when located in the leftmost quadrant of a strip
        - subject to being overwritten by the 'source_color' when located elsewhere in the strip
  - object: quadrants
    properties:
      - type: rectangular subgrids
      - boundaries: defined by separator lines or grid edges
      - role: specifically, the leftmost quadrant in a strip determines the fill color for that strip
  - object: horizontal_strips
    properties:
      - type: set of rows between horizontal separator lines (or grid edges)
      - boundaries: defined by horizontal separator lines or grid top/bottom edges
      - composition: contains background, content_pixels, and potentially parts of vertical separator lines
      - scope: filling action applies to the entire width of the strip's content rows
actions:
  - action: identify_separator_color
    inputs: [input_grid]
    outputs: [separator_color]
    description: "Find the unique non-zero color that forms complete horizontal and vertical lines spanning the grid."
  - action: identify_separator_line_indices
    inputs: [input_grid, separator_color]
    outputs: [horizontal_line_rows, vertical_line_cols]
    description: "Find the row indices of horizontal separator lines and column indices of vertical separator lines."
  - action: define_horizontal_strips
    inputs: [grid_height, horizontal_line_rows]
    outputs: [list_of_strip_row_ranges]
    description: "Determine the start and end row indices for each horizontal strip based on horizontal separator lines and grid edges."
  - action: find_source_color_for_strip
    inputs: [input_grid, strip_row_range, vertical_line_cols, separator_color, background_color=0]
    outputs: [source_color]
    description: "Scan the leftmost quadrant (from column 0 up to the first vertical separator or grid edge) within the strip's content rows. Find the first cell whose color is not background (0) and not separator_color. Return this color, or None if none found."
  - action: fill_strip
    inputs: [output_grid, input_grid, strip_row_range, source_color, separator_color]
    outputs: [modified_output_grid]
    description: "Iterate through all cells (r, c) within the strip's content row range (full width). If the corresponding input grid cell input_grid[r, c] is *not* the separator_color, set the output grid cell output_grid[r, c] to the source_color. Otherwise (if it is the separator color), leave the output cell unchanged (preserving the separator)."
relationships:
  - relationship: separator_lines_define_strips_and_quadrants
    entities: [separator_lines, horizontal_strips, quadrants]
  - relationship: leftmost_quadrant_determines_strip_fill_color
    entities: [quadrants, horizontal_strips, content_pixels]
    details: "The fill color ('source_color') for a horizontal strip is determined by the first non-background, non-separator content pixel found within its leftmost quadrant."
  - relationship: fill_preserves_separators
    entities: [horizontal_strips, separator_lines, source_color]
    details: "When filling a strip with its source_color, any cell that originally contained the separator_color remains unchanged."
  - relationship: fill_overwrites_others
    entities: [horizontal_strips, background, content_pixels, source_color, separator_lines]
    details: "Within a strip, all cells not containing the separator_color (including background and original content pixels) are replaced by the strip's source_color."
```


**Natural Language Program:**

1.  Initialize an `output_grid` as a direct copy of the `input_grid`.
2.  Identify the `separator_color` by finding the unique non-zero integer that constitutes complete rows *and* complete columns in the `input_grid`. If no such unique color is found, return the original `input_grid`.
3.  Identify the row indices of all horizontal lines composed entirely of the `separator_color` (`h_lines`).
4.  Identify the column indices of all vertical lines composed entirely of the `separator_color` (`v_lines`).
5.  Define horizontal strip boundaries by creating a sorted list containing 0, all indices in `h_lines`, and the total number of rows in the grid.
6.  Iterate through each pair of consecutive boundaries `(strip_start_row, strip_end_row)` from the list in step 5. These define a horizontal strip.
7.  Determine the content rows for the current strip:
    *   Set `content_start_row` to `strip_start_row + 1` if `strip_start_row` is in `h_lines`, otherwise set it to `strip_start_row`.
    *   The content rows range from `content_start_row` up to (but not including) `strip_end_row`.
    *   If `content_start_row` is greater than or equal to `strip_end_row`, this strip contains no content (it's purely a separator line or an empty gap), so continue to the next strip.
8.  Determine the column boundary for the leftmost quadrant:
    *   Set `leftmost_quadrant_col_end` to the grid width.
    *   Iterate through the sorted `v_lines`. If a `v_line_idx` is found where `v_line_idx >= 0`, set `leftmost_quadrant_col_end` to `v_line_idx` and stop this inner iteration.
9.  Find the `source_color` for the current strip:
    *   Iterate through the cells `(r, c)` of the `input_grid` where `r` ranges from `content_start_row` to `strip_end_row` (exclusive) and `c` ranges from 0 to `leftmost_quadrant_col_end` (exclusive).
    *   The first cell encountered whose color is *not* equal to the `background_color` (0) and *not* equal to the `separator_color` provides the `source_color`.
    *   If no such color is found within the leftmost quadrant, store `None` as the `source_color` and continue to the next strip (no filling occurs for this strip).
10. Fill the current strip in the `output_grid`:
    *   If a valid `source_color` was found in step 9:
        *   Iterate through all cells `(r, c)` where `r` ranges from `content_start_row` to `strip_end_row` (exclusive) and `c` ranges from 0 to the grid width (exclusive).
        *   Check the color in the original `input_grid` at `(r, c)`.
        *   If `input_grid[r, c]` is *not* equal to the `separator_color`, then update the corresponding cell in the `output_grid`: `output_grid[r, c] = source_color`.
        *   (If `input_grid[r, c]` *is* the `separator_color`, the `output_grid` cell remains unchanged due to the initial copy).
11. After iterating through all strips, return the modified `output_grid`.
