{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms the grid by filling horizontal strips based on the color found\nin the leftmost quadrant of each strip, preserving separator lines.\n\n1. Identifies a unique 'separator_color' that forms complete horizontal and \n   vertical lines.\n2. Finds the row and column indices of these separator lines.\n3. Defines horizontal strips as the regions between consecutive horizontal \n   separator lines (or grid edges).\n4. For each horizontal strip:\n   a. Identifies the 'leftmost quadrant' (from column 0 to the first vertical \n      separator line or grid edge).\n   b. Finds the first 'source_color' (non-background, non-separator) within \n      this leftmost quadrant.\n   c. Fills all cells within the entire horizontal strip (full width) in the \n      output grid with this 'source_color', *unless* the corresponding cell \n      in the input grid contains the 'separator_color'.\n\"\"\"\n\ndef find_separator_color(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds the unique non-zero color that forms complete horizontal rows \n    AND complete vertical columns. Returns None if no such unique color exists.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return None\n        \n    color_in_full_row = {} # color -> set of row indices\n    color_in_full_col = {} # color -> set of col indices\n\n    # Check horizontal lines\n    for r in range(rows):\n       # Check if all elements in the row are the same and not zero\n       first_val = grid[r, 0]\n       if first_val != 0 and np.all(grid[r, :] == first_val):\n           color = first_val\n           if color not in color_in_full_row: color_in_full_row[color] = set()\n           color_in_full_row[color].add(r)\n\n    # Check vertical lines\n    for c in range(cols):\n        # Check if all elements in the col are the same and not zero\n        first_val = grid[0, c]\n        if first_val != 0 and np.all(grid[:, c] == first_val):\n           color = first_val\n           if color not in color_in_full_col: color_in_full_col[color] = set()\n           color_in_full_col[color].add(c)\n\n    # Find colors present in both full rows and full columns\n    common_colors = set(color_in_full_row.keys()).intersection(set(color_in_full_col.keys()))\n\n    if len(common_colors) == 1:\n        return common_colors.pop()\n    elif len(common_colors) > 1:\n         # Heuristic for ambiguity: return the one with most lines? Or smallest value?\n         # Based on ARC tasks, usually there's a single clear separator if this pattern holds.\n         # Let's return the smallest color value as a tie-breaker for now.\n         print(f\"Warning: Multiple potential separator colors found: {common_colors}. Choosing smallest.\")\n         return min(common_colors)\n         \n    return None # No single color forms both full rows and columns\n\ndef find_separator_lines(grid: np.ndarray, separator_color: int) -> Tuple[List[int], List[int]]:\n    \"\"\"Finds the indices of rows and columns completely filled with the separator color.\"\"\"\n    rows, cols = grid.shape\n    h_lines = [r for r in range(rows) if np.all(grid[r, :] == separator_color)]\n    v_lines = [c for c in range(cols) if np.all(grid[:, c] == separator_color)]\n    return h_lines, v_lines\n\ndef find_source_color(grid_slice: np.ndarray, separator_color: int, background_color: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the first non-background, non-separator color in the given grid slice.\n    Searches row by row, then column by column.\n    Returns the color if found, otherwise None.\n    \"\"\"\n    if grid_slice.size == 0: # Handle empty slice case\n        return None\n        \n    rows, cols = grid_slice.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_slice[r, c]\n            if color != background_color and color != separator_color:\n                return color\n    return None # No source color found\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    \n    if rows == 0 or cols == 0:\n        return input_grid # Return empty or invalid grid as is\n\n    # Initialize output_grid as a copy of the input grid\n    output_grid = grid.copy()\n    background_color = 0\n\n    # 1. Identify the separator_color\n    separator_color = find_separator_color(grid)\n    if separator_color is None:\n        # If no separator color is found based on the strict definition,\n        # return the original grid. (Or apply alternative logic if needed)\n        print(\"Warning: No unique separator color found. Returning original grid.\")\n        return input_grid\n\n    # 2. Identify Separator Locations\n    h_lines, v_lines = find_separator_lines(grid, separator_color)\n\n    # 3. Define Horizontal Boundaries\n    h_boundaries = sorted(list(set([0] + h_lines + [rows])))\n\n    # 4. Iterate through Horizontal Strips\n    for i in range(len(h_boundaries) - 1):\n        strip_start_row = h_boundaries[i]\n        strip_end_row = h_boundaries[i+1]\n\n        # 4a. Determine the actual content rows for the strip\n        # If the strip starts *on* a separator line, content begins on the next row\n        content_start_row = strip_start_row + 1 if strip_start_row in h_lines else strip_start_row\n        \n        # 4b. Check for valid content strip (must have height > 0)\n        if content_start_row >= strip_end_row:\n            continue # This is just a separator line row or an empty gap\n\n        # 4c. Define the Leftmost Quadrant column range\n        col_start = 0\n        col_end = cols # Default to full width\n        for v_line_idx in sorted(v_lines):\n            if v_line_idx > 0: # Find the first vertical separator after column 0\n                col_end = v_line_idx\n                break\n        \n        # Ensure quadrant dimensions are valid before slicing\n        if content_start_row >= strip_end_row or col_start >= col_end:\n             print(f\"Warning: Skipping strip {i+1} due to invalid leftmost quadrant dimensions.\")\n             continue\n\n        # 4d. Find the source_color in the leftmost quadrant\n        leftmost_quadrant_slice = grid[content_start_row:strip_end_row, col_start:col_end]\n        source_color = find_source_color(leftmost_quadrant_slice, separator_color, background_color)\n\n        # If no source color is found in the leftmost quadrant, skip filling this strip\n        # (Based on examples, a source color seems expected if the strip has content)\n        if source_color is None:\n            print(f\"Warning: No source color found for strip {i+1} (Rows {content_start_row}-{strip_end_row-1}). Skipping fill.\")\n            continue\n\n        # 4e. Fill the Strip in Output Grid\n        # Iterate through all cells within the content rows of the current strip\n        for r in range(content_start_row, strip_end_row):\n            for c in range(cols):\n                # Check the corresponding cell in the *input* grid\n                # Only update the output cell if the input cell is NOT the separator color\n                if grid[r, c] != separator_color:\n                    output_grid[r, c] = source_color\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17552,
    "candidates_token_count": 2385,
    "total_token_count": 19937,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.479725,
  "retries": 1
}