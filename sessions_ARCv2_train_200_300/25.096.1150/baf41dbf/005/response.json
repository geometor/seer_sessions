{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Identify marker cells (value 6).\n2. Filter these markers to find \"active\" markers, which are those adjacent (up, down, left, right) to at least one boundary cell (value 3).\n3. Identify potential fill start cells: these are background cells (value 0) that are adjacent to any active marker cell.\n4. For each unique potential fill start cell, if it hasn't already been filled, initiate a flood fill operation.\n5. The flood fill uses color 3, starts from the identified background cell, and propagates through adjacent background cells (value 0).\n6. The fill stops at grid boundaries or any cell that is not a background cell (value 0).\n7. The original marker cells (6) and boundary cells (3) retain their values.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _find_cells(grid, color):\n    \"\"\"Find all cells with a specific color.\"\"\"\n    locations = []\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == color:\n                locations.append((r, c))\n    return locations\n\ndef _is_adjacent_to(grid, r, c, target_color):\n    \"\"\"Check if the cell at (r, c) is adjacent to any cell with target_color.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if _is_valid(nr, nc, rows, cols) and grid[nr][nc] == target_color:\n            return True\n    return False\n\ndef _flood_fill(grid: list[list[int]], start_row: int, start_col: int, fill_color: int, target_color: int):\n    \"\"\"\n    Performs a flood fill on the grid starting from (start_row, start_col).\n    Modifies the grid in place.\n\n    Args:\n        grid: The grid to modify (list of lists of ints).\n        start_row: The starting row index for the fill.\n        start_col: The starting column index for the fill.\n        fill_color: The color to fill with.\n        target_color: The color of cells to be filled.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Check if the starting point itself is the target color. \n    # This should always be true based on how it's called in transform, but good practice.\n    if not _is_valid(start_row, start_col, rows, cols) or grid[start_row][start_col] != target_color:\n        return\n\n    q = deque([(start_row, start_col)])\n    grid[start_row][start_col] = fill_color # Fill the starting cell\n\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds and if the neighbor is the target color\n            if _is_valid(nr, nc, rows, cols) and grid[nr][nc] == target_color:\n                # Change color to fill_color\n                grid[nr][nc] = fill_color\n                # Add neighbor to the queue\n                q.append((nr, nc))\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(output_grid)\n    cols = len(output_grid[0])\n\n    # Define colors\n    marker_color = 6\n    boundary_color = 3\n    background_color = 0\n    fill_color = 3 # Fill uses the boundary color\n\n    # 1. Find all marker cells\n    all_marker_locations = _find_cells(output_grid, marker_color)\n\n    # 2. Filter for active markers (adjacent to a boundary cell)\n    active_marker_locations = []\n    for r_marker, c_marker in all_marker_locations:\n        if _is_adjacent_to(output_grid, r_marker, c_marker, boundary_color):\n            active_marker_locations.append((r_marker, c_marker))\n\n    # 3. Identify potential fill start cells (background cells adjacent to active markers)\n    potential_starts = set()\n    for r_marker, c_marker in active_marker_locations:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_marker + dr, c_marker + dc\n            # Check if neighbor is valid and is a background cell\n            if _is_valid(nr, nc, rows, cols) and output_grid[nr][nc] == background_color:\n                potential_starts.add((nr, nc))\n\n    # 4. Perform flood fill from each unique potential start point\n    for r_start, c_start in potential_starts:\n        # Check if the cell hasn't already been filled by another fill process\n        if output_grid[r_start][c_start] == background_color:\n            _flood_fill(output_grid, r_start, c_start, fill_color, background_color)\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12789,
    "candidates_token_count": 2015,
    "total_token_count": 14804,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.737257,
  "retries": 1
}