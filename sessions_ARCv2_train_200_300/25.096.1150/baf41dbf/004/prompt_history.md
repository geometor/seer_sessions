
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 6 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 6 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 6 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 6 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 0 0 3 0 3 0 0 6 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 6 0 0 3 0 0 3 0 3 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 6 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 6 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```

## Perception

1.  **Grid Structure:** The input and output are 2D grids of numerical values.
2.  **Color Palette:** The grids primarily use colors 0 (background), 3 (boundary/shape color), and 6 (marker color).
3.  **Shapes:** Color 3 is used to define the outlines of shapes, often rectangular or U-shaped structures. These shapes define enclosed or semi-enclosed regions.
4.  **Markers:** Color 6 appears as isolated points within or near the regions defined by color 3.
5.  **Transformation:** The core transformation involves filling areas associated with the shapes defined by color 3.
6.  **Filling Logic:** The filling seems to originate from the location of the color 6 marker. The fill uses color 3 and expands outwards until it encounters cells already containing color 3 or the grid boundaries.
7.  **Preservation:** The original positions of cells with color 3 and color 6 in the input are preserved in the output. The transformation only changes cells with color 0 to color 3 based on the fill logic.
8.  **Multiple Instances:** The process applies independently if multiple color 6 markers and associated shapes exist.

## Facts


```yaml
objects:
  - id: grid
    description: A 2D array of integer values representing pixels or cells.
  - id: boundary_cell
    description: A cell in the grid with the value 3. These cells form the borders of regions.
  - id: marker_cell
    description: A cell in the grid with the value 6. These act as starting points for the fill operation.
  - id: background_cell
    description: A cell in the grid with the value 0. These are candidates for being filled.
  - id: region
    description: An area implicitly defined by boundary_cells, potentially containing a marker_cell.
properties:
  - object: grid
    property: dimensions
    value: rows x columns (variable)
  - object: cell
    property: position
    value: (row, column) coordinates
  - object: cell
    property: color
    value: integer (0, 3, or 6 in input)
actions:
  - id: locate_markers
    description: Find the coordinates of all cells with value 6.
  - id: flood_fill
    description: Starting from a marker_cell's position, change connected background_cells (value 0) to the fill color (value 3).
    constraints: The fill propagates in 4 directions (up, down, left, right) and stops when it encounters a boundary_cell (value 3) or the grid edges. The fill does not change existing boundary_cells or marker_cells.
relationships:
  - type: containment
    subject: marker_cell
    object: region
    description: A marker_cell indicates which region(s) should be filled.
  - type: boundary
    subject: boundary_cell
    object: region
    description: Boundary_cells define the limits of the fill originating from a marker_cell within that region.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the locations (row, column coordinates) of all cells in the input grid that have the value 6 (marker cells).
3.  For each identified marker cell location:
    a.  Initiate a flood fill operation starting from this location.
    b.  Use the color 3 as the fill color.
    c.  The fill should only change cells that currently have the value 0 (background cells).
    d.  The fill propagates to adjacent cells (up, down, left, right).
    e.  The fill stops propagating into a cell if that cell is outside the grid boundaries or if that cell already contains the value 3 (boundary cell).
    f.  Modify the output grid by changing the color of the filled cells to 3.
4.  Return the modified output grid.
```python
import copy
from collections import deque

"""
Transforms an input grid based on the following rules:
1. Finds all cells with the value 6 (marker cells).
2. For each marker cell, initiates a flood fill process starting from its adjacent cells.
3. The flood fill uses the color 3 and fills only cells with the value 0 (background cells).
4. The fill propagates in 4 directions (up, down, left, right).
5. The fill stops when it encounters a cell with value 3 (boundary cell) or the grid edges.
6. The original positions of marker cells (6) and boundary cells (3) are preserved.
7. The transformation modifies a copy of the input grid.
"""

def _flood_fill(grid: list[list[int]], start_row: int, start_col: int, fill_color: int, target_color: int, boundary_color: int):
    """
    Performs a flood fill on the grid starting from (start_row, start_col).

    Args:
        grid: The grid to modify (list of lists of ints).
        start_row: The starting row index for the fill.
        start_col: The starting column index for the fill.
        fill_color: The color to fill with.
        target_color: The color of cells to be filled.
        boundary_color: The color that stops the fill.
    """
    rows = len(grid)
    if rows == 0:
        return
    cols = len(grid[0])
    if cols == 0:
        return

    # Check if the starting point is valid and is the target color
    if not (0 <= start_row < rows and 0 <= start_col < cols and grid[start_row][start_col] == target_color):
        return

    q = deque([(start_row, start_col)])
    grid[start_row][start_col] = fill_color # Mark starting cell as filled

    while q:
        r, c = q.popleft()

        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is the target color (and not implicitly a boundary)
                if grid[nr][nc] == target_color:
                    # Change color to fill_color
                    grid[nr][nc] = fill_color
                    # Add neighbor to the queue to process its neighbors
                    q.append((nr, nc))
                # Note: The fill naturally stops at boundary_color cells because they are not target_color.


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies a flood fill originating from neighbors of marker cells (value 6)
    to fill background cells (value 0) with color 3, stopping at boundary cells (value 3).

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Initialize output_grid as a deep copy of the input
    output_grid = copy.deepcopy(input_grid)
    
    rows = len(output_grid)
    if rows == 0:
        return output_grid
    cols = len(output_grid[0])
    if cols == 0:
        return output_grid

    # Define colors
    marker_color = 6
    fill_color = 3
    target_color = 0
    boundary_color = 3 # Implicit boundary, also the fill color

    # 1. Find all marker cell locations
    marker_locations = []
    for r in range(rows):
        for c in range(cols):
            if output_grid[r][c] == marker_color:
                marker_locations.append((r, c))

    # 2. For each marker, initiate flood fill from adjacent target cells
    for r_marker, c_marker in marker_locations:
        # Check neighbors of the marker
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r_marker + dr, c_marker + dc
            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                 # If the neighbor is a target cell (0), start flood fill from there
                 if output_grid[nr][nc] == target_color:
                     _flood_fill(output_grid, nr, nc, fill_color, target_color, boundary_color)

    # 3. Return the modified grid
    return output_grid
```
```python
import copy
from collections import deque

"""
Transforms an input grid by performing a flood fill operation.
The fill originates from the background cells (value 0) that are adjacent 
(up, down, left, right) to marker cells (value 6).
The fill color is 3.
The fill propagates only through background cells (value 0) and stops 
when it encounters grid boundaries or cells that are not background cells 
(e.g., original boundary cells with value 3, marker cells with value 6, or 
cells already filled during the process).
The original marker cells (6) and boundary cells (3) are preserved.
"""

def _flood_fill(grid: list[list[int]], start_row: int, start_col: int, fill_color: int, target_color: int):
    """
    Performs a flood fill on the grid starting from (start_row, start_col).
    Modifies the grid in place.

    Args:
        grid: The grid to modify (list of lists of ints).
        start_row: The starting row index for the fill.
        start_col: The starting column index for the fill.
        fill_color: The color to fill with.
        target_color: The color of cells to be filled.
    """
    rows = len(grid)
    if rows == 0:
        return
    cols = len(grid[0])
    if cols == 0:
        return

    # Check if the starting point is valid and is the target color
    if not (0 <= start_row < rows and 0 <= start_col < cols and grid[start_row][start_col] == target_color):
        return

    q = deque([(start_row, start_col)])
    # Mark the starting cell immediately only if it's the target color
    # This check is already done above, but included for clarity in the queue setup
    grid[start_row][start_col] = fill_color 

    while q:
        r, c = q.popleft()

        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is the target color 
                if grid[nr][nc] == target_color:
                    # Change color to fill_color
                    grid[nr][nc] = fill_color
                    # Add neighbor to the queue to process its neighbors
                    q.append((nr, nc))
                # The fill naturally stops if grid[nr][nc] is not target_color (e.g., it's a boundary, a marker, or already filled)


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies a flood fill originating from neighbors of marker cells (value 6)
    to fill background cells (value 0) with color 3, stopping at non-background cells.

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Initialize output_grid as a deep copy of the input to avoid modifying the original
    output_grid = copy.deepcopy(input_grid)
    
    rows = len(output_grid)
    if rows == 0:
        return output_grid
    cols = len(output_grid[0])
    if cols == 0:
        return output_grid

    # Define colors
    marker_color = 6
    fill_color = 3
    target_color = 0
    # boundary_color = 3 is implicitly handled as it's not the target_color

    # 1. Find all marker cell locations
    marker_locations = []
    for r in range(rows):
        for c in range(cols):
            if output_grid[r][c] == marker_color:
                marker_locations.append((r, c))

    # 2. For each marker, identify adjacent target cells and initiate flood fill from them
    # Store potential start points to avoid starting multiple fills in the same connected component from the same marker
    potential_starts = set()
    for r_marker, c_marker in marker_locations:
        # Check neighbors of the marker
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r_marker + dr, c_marker + dc
            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                 # If the neighbor is a target cell (0), add it as a potential start point
                 if output_grid[nr][nc] == target_color:
                     potential_starts.add((nr, nc))

    # 3. Perform flood fill from each unique potential start point identified
    # This loop iterates over the set, so even if multiple markers point to the same 
    # starting '0' cell, the fill from that cell only happens once.
    for r_start, c_start in potential_starts:
         # Important: Check if the start cell hasn't already been filled by a previous fill operation
         # originating from a different marker's neighbor but within the same connected component.
         if output_grid[r_start][c_start] == target_color:
             _flood_fill(output_grid, r_start, c_start, fill_color, target_color)

    # 4. Return the modified grid
    return output_grid
```
