
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 6 0 0 0 0 0
0 3 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 6 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 0 3 0 0 0 0 0 0 3 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 6 0 0 3 0 3 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 6 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 0 0 0 3 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 0 0 0 0 0 0 0 0
0 0 0 0 0 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 0 0 3 0 3 0 0 6 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 6 0 0 3 0 0 3 0 3 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 6 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 6 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 0 0 0 0 3 0 0 0 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 0 0 0
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0
```

## Perception

1.  **Grid Structure:** The input and output are 2D grids of numerical values.
2.  **Color Palette:** The grids primarily use colors 0 (background), 3 (boundary/shape color), and 6 (marker color).
3.  **Shapes:** Color 3 is used to define the outlines of shapes, often rectangular or U-shaped structures. These shapes define enclosed or semi-enclosed regions.
4.  **Markers:** Color 6 appears as isolated points within or near the regions defined by color 3.
5.  **Transformation:** The core transformation involves filling areas associated with the shapes defined by color 3.
6.  **Filling Logic:** The filling seems to originate from the location of the color 6 marker. The fill uses color 3 and expands outwards until it encounters cells already containing color 3 or the grid boundaries.
7.  **Preservation:** The original positions of cells with color 3 and color 6 in the input are preserved in the output. The transformation only changes cells with color 0 to color 3 based on the fill logic.
8.  **Multiple Instances:** The process applies independently if multiple color 6 markers and associated shapes exist.

## Facts


```yaml
objects:
  - id: grid
    description: A 2D array of integer values representing pixels or cells.
  - id: boundary_cell
    description: A cell in the grid with the value 3. These cells form the borders of regions.
  - id: marker_cell
    description: A cell in the grid with the value 6. These act as starting points for the fill operation.
  - id: background_cell
    description: A cell in the grid with the value 0. These are candidates for being filled.
  - id: region
    description: An area implicitly defined by boundary_cells, potentially containing a marker_cell.
properties:
  - object: grid
    property: dimensions
    value: rows x columns (variable)
  - object: cell
    property: position
    value: (row, column) coordinates
  - object: cell
    property: color
    value: integer (0, 3, or 6 in input)
actions:
  - id: locate_markers
    description: Find the coordinates of all cells with value 6.
  - id: flood_fill
    description: Starting from a marker_cell's position, change connected background_cells (value 0) to the fill color (value 3).
    constraints: The fill propagates in 4 directions (up, down, left, right) and stops when it encounters a boundary_cell (value 3) or the grid edges. The fill does not change existing boundary_cells or marker_cells.
relationships:
  - type: containment
    subject: marker_cell
    object: region
    description: A marker_cell indicates which region(s) should be filled.
  - type: boundary
    subject: boundary_cell
    object: region
    description: Boundary_cells define the limits of the fill originating from a marker_cell within that region.
```


## Natural Language Program

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the locations (row, column coordinates) of all cells in the input grid that have the value 6 (marker cells).
3.  For each identified marker cell location:
    a.  Initiate a flood fill operation starting from this location.
    b.  Use the color 3 as the fill color.
    c.  The fill should only change cells that currently have the value 0 (background cells).
    d.  The fill propagates to adjacent cells (up, down, left, right).
    e.  The fill stops propagating into a cell if that cell is outside the grid boundaries or if that cell already contains the value 3 (boundary cell).
    f.  Modify the output grid by changing the color of the filled cells to 3.
4.  Return the modified output grid.
```python
import copy
from collections import deque

"""
Transforms an input grid based on the following rules:
1. Finds all cells with the value 6 (marker cells).
2. For each marker cell, initiates a flood fill process starting from its adjacent cells.
3. The flood fill uses the color 3 and fills only cells with the value 0 (background cells).
4. The fill propagates in 4 directions (up, down, left, right).
5. The fill stops when it encounters a cell with value 3 (boundary cell) or the grid edges.
6. The original positions of marker cells (6) and boundary cells (3) are preserved.
7. The transformation modifies a copy of the input grid.
"""

def _flood_fill(grid: list[list[int]], start_row: int, start_col: int, fill_color: int, target_color: int, boundary_color: int):
    """
    Performs a flood fill on the grid starting from (start_row, start_col).

    Args:
        grid: The grid to modify (list of lists of ints).
        start_row: The starting row index for the fill.
        start_col: The starting column index for the fill.
        fill_color: The color to fill with.
        target_color: The color of cells to be filled.
        boundary_color: The color that stops the fill.
    """
    rows = len(grid)
    if rows == 0:
        return
    cols = len(grid[0])
    if cols == 0:
        return

    # Check if the starting point is valid and is the target color
    if not (0 <= start_row < rows and 0 <= start_col < cols and grid[start_row][start_col] == target_color):
        return

    q = deque([(start_row, start_col)])
    grid[start_row][start_col] = fill_color # Mark starting cell as filled

    while q:
        r, c = q.popleft()

        # Explore neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # Check if the neighbor is the target color (and not implicitly a boundary)
                if grid[nr][nc] == target_color:
                    # Change color to fill_color
                    grid[nr][nc] = fill_color
                    # Add neighbor to the queue to process its neighbors
                    q.append((nr, nc))
                # Note: The fill naturally stops at boundary_color cells because they are not target_color.


def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Applies a flood fill originating from neighbors of marker cells (value 6)
    to fill background cells (value 0) with color 3, stopping at boundary cells (value 3).

    Args:
        input_grid: A 2D list of integers representing the input grid.

    Returns:
        A 2D list of integers representing the transformed grid.
    """
    # Initialize output_grid as a deep copy of the input
    output_grid = copy.deepcopy(input_grid)
    
    rows = len(output_grid)
    if rows == 0:
        return output_grid
    cols = len(output_grid[0])
    if cols == 0:
        return output_grid

    # Define colors
    marker_color = 6
    fill_color = 3
    target_color = 0
    boundary_color = 3 # Implicit boundary, also the fill color

    # 1. Find all marker cell locations
    marker_locations = []
    for r in range(rows):
        for c in range(cols):
            if output_grid[r][c] == marker_color:
                marker_locations.append((r, c))

    # 2. For each marker, initiate flood fill from adjacent target cells
    for r_marker, c_marker in marker_locations:
        # Check neighbors of the marker
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r_marker + dr, c_marker + dc
            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                 # If the neighbor is a target cell (0), start flood fill from there
                 if output_grid[nr][nc] == target_color:
                     _flood_fill(output_grid, nr, nc, fill_color, target_color, boundary_color)

    # 3. Return the modified grid
    return output_grid
```
