{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nThe transformation scales an input grid of size H_in x W_in to a fixed output grid of size 12x12.\nThe scaling factors are determined by integer division: scale_h = 12 / H_in and scale_w = 12 / W_in.\nEach pixel Input[i, j] in the input grid corresponds to a block of size scale_h x scale_w in the output grid, starting at Output[i * scale_h, j * scale_w].\nThe color of each pixel Output[r, c] within this block is determined by sampling the color of one of the pixels in the 3x3 neighborhood (including the center pixel itself) of the corresponding input pixel Input[i, j].\nThe specific neighbor (offset dr, dc relative to (i, j)) is chosen based on the relative position (rel_r, rel_c) of the output pixel within its scale_h x scale_w block.\nThe mapping from (rel_r, rel_c) to (dr, dc) is determined by mapping the relative coordinates normalized to the 0-1 range onto a 3x3 grid representing the neighbor offsets (-1, 0, 1).\nNeighbors outside the input grid boundaries are treated as having a default color of 0 (black).\n\nSpecifically, the neighbor offset (dr, dc) for an output pixel Output[r, c] is calculated as follows:\n1. Find the corresponding input pixel: i = floor(r / scale_h), j = floor(c / scale_w).\n2. Find the relative position within the block: rel_r = r % scale_h, rel_c = c % scale_w.\n3. Calculate the normalized position within the 3x3 neighborhood grid:\n   dr = floor((rel_r + 0.5) / scale_h * 3) - 1\n   dc = floor((rel_c + 0.5) / scale_w * 3) - 1\n4. Retrieve the color from the input grid at Input[i + dr, j + dc], handling boundary conditions by returning 0 if the coordinates are out of bounds.\n\"\"\"\n\ndef get_neighbor(grid: np.ndarray, r: int, c: int, dr: int, dc: int, default_color: int = 0) -> int:\n    \"\"\"\n    Safely retrieves the color of a neighbor pixel from the grid.\n\n    Args:\n        grid: The input numpy array.\n        r: The row index of the center pixel.\n        c: The column index of the center pixel.\n        dr: The row offset of the neighbor (-1, 0, or 1).\n        dc: The column offset of the neighbor (-1, 0, or 1).\n        default_color: The color to return if the neighbor is out of bounds.\n\n    Returns:\n        The color of the neighbor pixel or the default color.\n    \"\"\"\n    nr, nc = r + dr, c + dc\n    H, W = grid.shape\n    if 0 <= nr < H and 0 <= nc < W:\n        return grid[nr, nc]\n    else:\n        return default_color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by scaling and sampling neighbors based on relative position.\n\n    Args:\n        input_grid: The input grid as a list of lists.\n\n    Returns:\n        The transformed 12x12 grid as a list of lists.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    H_in, W_in = input_np.shape\n    H_out, W_out = 12, 12\n\n    # Calculate integer scaling factors\n    # Note: Use integer division H_out // H_in and W_out // W_in\n    # This matches the observed block sizes in the examples:\n    # Ex 1: 12 // 6 = 2, 12 // 4 = 3 -> scale_h=2, scale_w=3\n    # Ex 2: 12 // 4 = 3, 12 // 6 = 2 -> scale_h=3, scale_w=2\n    if H_in == 0 or W_in == 0:\n        # Handle empty input grid case if necessary, maybe return empty or black grid?\n        return [[0 for _ in range(W_out)] for _ in range(H_out)]\n        \n    scale_h = H_out // H_in\n    scale_w = W_out // W_in\n\n    # Initialize the output grid (12x12) with black/0\n    output_np = np.zeros((H_out, W_out), dtype=int)\n\n    # Iterate through each pixel of the output grid\n    for r in range(H_out):\n        for c in range(W_out):\n            # Identify the corresponding source input pixel coordinates\n            # Ensure division by zero is avoided if scale factors are 0 (though H_in/W_in > 0 implies scale > 0)\n            i = math.floor(r / scale_h) if scale_h > 0 else 0\n            j = math.floor(c / scale_w) if scale_w > 0 else 0\n            \n            # Handle potential out-of-bounds access for i, j if input dimensions are larger than output/scale\n            # This shouldn't happen if H_out=12, W_out=12 and scale factors are calculated correctly\n            i = min(i, H_in - 1)\n            j = min(j, W_in - 1)\n\n            # Determine the relative position within the conceptual block\n            rel_r = r % scale_h if scale_h > 0 else 0\n            rel_c = c % scale_w if scale_w > 0 else 0\n\n            # Determine the neighbor offset (dr, dc) based on relative position\n            # using the formula: dr = floor((rel_r + 0.5) / scale_h * 3) - 1\n            # Handle division by zero for scale factors\n            dr = math.floor((rel_r + 0.5) / scale_h * 3) - 1 if scale_h > 0 else 0\n            dc = math.floor((rel_c + 0.5) / scale_w * 3) - 1 if scale_w > 0 else 0\n\n            # Get the color from the calculated neighbor\n            color = get_neighbor(input_np, i, j, dr, dc, default_color=0)\n\n            # Assign the color to the output grid pixel\n            output_np[r, c] = color\n\n    # Convert the result back to a list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3008,
    "candidates_token_count": 17317,
    "total_token_count": 20325,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 124.00773,
  "retries": 1
}