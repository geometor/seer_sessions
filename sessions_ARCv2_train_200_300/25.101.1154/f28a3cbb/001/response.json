{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid based on identifying 3x3 solid blocks and surrounding noise pixels.\nThe core logic involves:\n1. Identifying the background color (most frequent).\n2. Locating solid 3x3 blocks of non-background colors.\n3. Identifying 'noise' pixels (non-background pixels not part of solid blocks).\n4. Initializing an output grid with the background color.\n5. Copying the solid 3x3 blocks to the output.\n6. Expanding the blocks by changing adjacent background pixels according to a specific rule:\n   A background pixel 'n' changes to the block's color 'c' if 'n' was originally background,\n   is orthogonally adjacent to the block, and is also orthogonally or diagonally adjacent\n   to at least one 'noise' pixel of the same color 'c'.\n\"\"\"\n\n# Helper function to find the most frequent element (background color)\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    # If grid is empty or has uniform color, handle appropriately\n    if not counts:\n        # Return a default color (e.g., 0) or raise error if grid shouldn't be empty\n        return 0\n    # Return the color with the highest count\n    return counts.most_common(1)[0][0]\n\n# Helper function to find coordinates of neighbors\ndef get_neighbor_coords(r: int, c: int, H: int, W: int, include_diagonal: bool) -> set[tuple[int, int]]:\n    \"\"\"Gets valid neighbor coordinates for a cell (r, c) within grid bounds (H, W).\"\"\"\n    neighbors = set()\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            # Skip self\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonal if not included\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbors.add((nr, nc))\n    return neighbors\n\n# Helper function to find solid 3x3 blocks\ndef find_solid_blocks(grid: np.ndarray, background_color: int) -> tuple[list[tuple[int, set[tuple[int, int]]]], set[tuple[int, int]]]:\n    \"\"\"\n    Finds all solid 3x3 blocks of a single non-background color.\n\n    Returns:\n        A tuple containing:\n        - list_of_blocks: A list of tuples, where each inner tuple is (block_color, block_coords_set).\n        - all_block_coords: A set containing coordinates of all pixels belonging to any found solid block.\n    \"\"\"\n    H, W = grid.shape\n    list_of_blocks = []\n    all_block_coords = set()\n    # Keep track of pixels already assigned to a block to prevent overlap issues or redundant checks\n    visited_block_pixels = set()\n\n    for r in range(H - 2):\n        for c in range(W - 2):\n            # If this cell is already part of a found block, skip\n            if (r, c) in visited_block_pixels:\n                continue\n\n            color = grid[r, c]\n            # Blocks cannot be background color\n            if color == background_color:\n                continue\n\n            # Check if it's the top-left of a 3x3 block of the same color\n            is_solid_block = True\n            current_block_coords = set()\n            for i in range(3):\n                for j in range(3):\n                    coord = (r + i, c + j)\n                    # Check color and if this pixel is already part of another block\n                    # Check grid bounds implicitly via loop range and coord generation\n                    if grid[r + i, c + j] != color or coord in visited_block_pixels:\n                        is_solid_block = False\n                        break\n                    current_block_coords.add(coord)\n                if not is_solid_block:\n                    break\n\n            if is_solid_block:\n                list_of_blocks.append((color, current_block_coords))\n                all_block_coords.update(current_block_coords)\n                visited_block_pixels.update(current_block_coords) # Mark pixels as used\n\n    return list_of_blocks, all_block_coords\n\n# Main transformation function\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n    if H == 0 or W == 0: # Handle empty input case\n        return []\n\n    # Step 1: Identify Background Color\n    background_color = find_background_color(input_np)\n\n    # Step 2: Identify Solid 3x3 Blocks\n    # solid_blocks_list contains tuples: (block_color, set_of_block_coordinates)\n    # all_block_coords is a set containing all coordinates occupied by any solid block\n    solid_blocks_list, all_block_coords = find_solid_blocks(input_np, background_color)\n\n    # Step 3: Identify Noise Pixels\n    # noise_pixels_by_color is a dictionary: {color: set_of_noise_coordinates}\n    noise_pixels_by_color = {}\n    for r in range(H):\n        for c in range(W):\n            coord = (r, c)\n            color = input_np[r, c]\n            # Noise is non-background and not part of any solid block\n            if color != background_color and coord not in all_block_coords:\n                if color not in noise_pixels_by_color:\n                    noise_pixels_by_color[color] = set()\n                noise_pixels_by_color[color].add(coord)\n\n    # Step 4: Initialize Output Grid with the background color\n    output_np = np.full_like(input_np, background_color)\n\n    # Step 5: Preserve Solid Blocks by copying them to the output grid\n    for color, block_coords in solid_blocks_list:\n        for r, c in block_coords:\n            output_np[r, c] = color # Assume block coords are valid within bounds\n\n    # Step 6: Determine and Apply Expansion based on the rules\n    # Store updates in a dictionary to handle potential overlaps (though unlikely needed here)\n    expansion_updates = {} # Store updates as {(r, c): color}\n\n    # Iterate through each solid block to check for potential expansion\n    for block_color, block_coords in solid_blocks_list:\n        # Get the set of noise pixels matching the block's color\n        current_noise_set = noise_pixels_by_color.get(block_color, set())\n        if not current_noise_set:\n            continue # Skip expansion check if no relevant noise exists\n\n        # Find all unique orthogonal neighbors for the entire block\n        # These are the candidate cells 'n' for expansion\n        potential_expansion_coords = set()\n        for r_block, c_block in block_coords:\n            potential_expansion_coords.update(get_neighbor_coords(r_block, c_block, H, W, include_diagonal=False))\n\n        # Check each potential coordinate 'n' against the expansion rules\n        for r_n, c_n in potential_expansion_coords:\n            coord_n = (r_n, c_n)\n\n            # Rule 1: The cell 'n' must be background color in the INPUT grid\n            if input_np[r_n, c_n] != background_color:\n                continue\n\n            # Rule 2: The cell 'n' must be orthogonally adjacent to the block 'b'.\n            # This is implicitly true because potential_expansion_coords was generated\n            # from orthogonal neighbors of the block's coordinates.\n\n            # Rule 3: The cell 'n' must be orthogonally or diagonally adjacent to a noise pixel 'p'\n            # of the same color as the block.\n            neighbors_of_n = get_neighbor_coords(r_n, c_n, H, W, include_diagonal=True)\n            # Check if any of n's 8-way neighbors are in the set of noise pixels for this color\n            if neighbors_of_n.intersection(current_noise_set):\n                # If all rules pass, mark this coordinate for update with the block's color\n                expansion_updates[coord_n] = block_color\n\n    # Apply the collected expansion updates to the output grid\n    for (r, c), color in expansion_updates.items():\n        output_np[r, c] = color\n\n    # Convert the final NumPy array back to a standard Python list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2913,
    "candidates_token_count": 23889,
    "total_token_count": 26802,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 167.381615,
  "retries": 1
}