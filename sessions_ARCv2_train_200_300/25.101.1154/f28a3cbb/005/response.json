{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule Description (Hypothesis 8: Strict Bound + Row/Column Alignment):\n\n1.  **Identify Background:** Determine the most frequent color in the input grid; this is the background color.\n2.  **Find Solid Blocks:** Locate all solid 3x3 squares composed of a single non-background color. Record their color, coordinates, and bounding box (min/max row/col).\n3.  **Find Noise Pixels:** Identify all non-background pixels that are not part of any solid 3x3 block. Group these noise pixels by their color.\n4.  **Initialize Output:** Create an output grid of the same dimensions as the input, filled entirely with the background color.\n5.  **Copy Blocks:** Copy the identified solid 3x3 blocks from the input grid to the output grid at their original locations.\n6.  **Determine Block Expansion:**\n    a.  For each solid block `b` with color `c`, bounds (`r_min`, `r_max`, `c_min`, `c_max`), and corresponding noise pixels `P`:\n        i.  Find all background pixels `n = (r_n, c_n)` in the *input* grid orthogonally adjacent to any *edge* pixel of block `b`.\n        ii. For each candidate `n`, determine the side(s) `S` it is adjacent to relative to block `b` (\"Above\", \"Below\", \"Left\", \"Right\").\n        iii. Check if `n` should change color: Iterate through each side `s` in `S`. Does there exist *at least one* noise pixel `p = (r_p, c_p)` in `P` such that `p` is strictly outside the block boundary on side `s` AND `p` is aligned with `n` (same column for Above/Below sides, same row for Left/Right sides)?\n        iv. If the condition in (iii) is met for *any* side `s` in `S`, mark pixel `n` to change to color `c`.\n7.  **Apply Expansion:** Update the output grid by changing the color of all marked pixels.\n8.  **Return Output:** The final output grid contains the preserved blocks and the expanded regions. Noise pixels are implicitly removed.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nfrom typing import List, Tuple, Dict, Set\n\n# === Helper Functions ===\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default for empty grid\n    # Ensure key is standard int\n    return int(counts.most_common(1)[0][0])\n\ndef find_solid_blocks_and_noise(grid: np.ndarray) -> tuple[int, list[tuple[int, tuple[int, int, int, int], set[tuple[int, int]]]], dict[int, set[tuple[int, int]]]]:\n    \"\"\"\n    Finds the background color, all solid 3x3 blocks, and noise pixels.\n\n    Returns:\n        - background_color (int)\n        - list_of_blocks: List of (color, (r_min, r_max, c_min, c_max), coords_set)\n        - noise_pixels_by_color: Dict {color: set_of_noise_coords}\n    \"\"\"\n    H, W = grid.shape\n    background_color = find_background_color(grid)\n    list_of_blocks = []\n    all_block_coords = set()\n    visited_block_pixels = set() # To handle potential overlaps or faster checks\n\n    # Find blocks\n    for r in range(H - 2):\n        for c in range(W - 2):\n            if (r, c) in visited_block_pixels: continue\n            color = grid[r, c]\n            if color == background_color: continue\n\n            is_solid_block = True\n            current_block_coords = set()\n            for i in range(3):\n                for j in range(3):\n                    coord = (r + i, c + j)\n                    # Check bounds explicitly\n                    if r+i >= H or c+j >= W or grid[r + i, c + j] != color or coord in visited_block_pixels:\n                        is_solid_block = False\n                        break\n                    current_block_coords.add(coord)\n                if not is_solid_block: break\n\n            if is_solid_block:\n                bounds = (r, r + 2, c, c + 2)\n                # Ensure color is standard int\n                list_of_blocks.append((int(color), bounds, current_block_coords))\n                all_block_coords.update(current_block_coords)\n                visited_block_pixels.update(current_block_coords)\n\n    # Find noise\n    noise_pixels_by_color = {}\n    for r in range(H):\n        for c in range(W):\n            coord = (r, c)\n            color = grid[r, c]\n            if color != background_color and coord not in all_block_coords:\n                noise_color_key = int(color) # Ensure key is standard int\n                if noise_color_key not in noise_pixels_by_color:\n                    noise_pixels_by_color[noise_color_key] = set()\n                noise_pixels_by_color[noise_color_key].add(coord)\n\n    return background_color, list_of_blocks, noise_pixels_by_color\n\ndef get_edge_adjacent_background_candidates(grid: np.ndarray, background_color: int, block_bounds: tuple[int, int, int, int], block_coords: set[tuple[int, int]]) -> dict[tuple[int, int], set[str]]:\n    \"\"\"\n    Finds background pixels orthogonally adjacent to block edges and notes which side(s).\n\n    Returns:\n        Dict {(r, c): set_of_sides} e.g., {(3, 0): {\"Below\"}}\n    \"\"\"\n    H, W = grid.shape\n    r_min, r_max, c_min, c_max = block_bounds\n    candidates = {} # {(r, c): {\"Above\", \"Below\", \"Left\", \"Right\"}}\n\n    # Identify edge pixels of the block\n    edge_pixels = {\n        (r, c) for r, c in block_coords\n        if r == r_min or r == r_max or c == c_min or c == c_max\n    }\n\n    # Check orthogonal neighbors of edge pixels\n    for r_edge, c_edge in edge_pixels:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal steps\n            r_n, c_n = r_edge + dr, c_edge + dc\n            coord_n = (r_n, c_n)\n\n            # Check bounds, ensure it's background color in INPUT, and not part of the block itself\n            if 0 <= r_n < H and 0 <= c_n < W and grid[r_n, c_n] == background_color and coord_n not in block_coords:\n                if coord_n not in candidates:\n                    candidates[coord_n] = set()\n                # Determine side(s) n is on relative to block bounds\n                if r_n < r_min: candidates[coord_n].add(\"Above\")\n                if r_n > r_max: candidates[coord_n].add(\"Below\")\n                if c_n < c_min: candidates[coord_n].add(\"Left\")\n                if c_n > c_max: candidates[coord_n].add(\"Right\")\n\n    # Filter out any candidates that didn't end up on a side\n    final_candidates = {coord: sides for coord, sides in candidates.items() if sides}\n    return final_candidates\n\ndef check_expansion_condition(candidate_coord: tuple[int, int], candidate_sides: set[str], block_bounds: tuple[int, int, int, int], noise_coords: set[tuple[int, int]]) -> bool:\n    \"\"\"\n    Checks if a candidate background pixel should change color based on H8:\n    Strict Bound + Row/Column Alignment with noise.\n    \"\"\"\n    r_n, c_n = candidate_coord\n    r_min, r_max, c_min, c_max = block_bounds\n\n    if not noise_coords: return False # No noise, no expansion\n\n    # Check each side the candidate is adjacent to\n    for side in candidate_sides:\n        # Check if any noise pixel satisfies the condition for this side\n        for r_p, c_p in noise_coords:\n            # Condition 1: Noise is strictly outside the boundary on this side\n            # Condition 2: Noise is aligned with candidate (same col for Up/Down, same row for Left/Right)\n            if side == \"Above\" and r_p < r_min and c_p == c_n: return True\n            if side == \"Below\" and r_p > r_max and c_p == c_n: return True\n            if side == \"Left\"  and c_p < c_min and r_p == r_n: return True\n            if side == \"Right\" and c_p > c_max and r_p == r_n: return True\n            \n    return False # No noise pixel satisfied the condition for any adjacent side\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n    if H == 0 or W == 0: # Handle empty input case\n        return []\n\n    # Step 1, 2, 3: Find background, blocks, and noise\n    background_color, solid_blocks_list, noise_pixels_by_color = find_solid_blocks_and_noise(input_np)\n\n    # Step 4: Initialize Output Grid with the background color\n    output_np = np.full_like(input_np, background_color)\n\n    # Step 5: Preserve Solid Blocks by copying them to the output grid\n    for color, bounds, block_coords in solid_blocks_list:\n        for r, c in block_coords:\n            # Bounds check might be redundant if find_solid_blocks is correct, but safe\n            if 0 <= r < H and 0 <= c < W:\n                output_np[r, c] = color\n\n    # Step 6: Determine Expansion based on H8\n    expansion_updates = {} # Store updates as {(r, c): color}\n\n    # Iterate through each solid block found\n    for block_color, block_bounds, block_coords in solid_blocks_list:\n        # Get noise pixels matching the current block's color\n        current_noise_set = noise_pixels_by_color.get(block_color, set())\n        if not current_noise_set:\n            continue # Skip if no relevant noise exists for this block color\n\n        # Find candidate background pixels adjacent to the block's edges\n        candidate_pixels = get_edge_adjacent_background_candidates(input_np, background_color, block_bounds, block_coords)\n\n        # Check each candidate against the expansion condition (H8)\n        for coord_n, adjacent_sides in candidate_pixels.items():\n            # Check if the condition is met using the relevant noise set\n            if check_expansion_condition(coord_n, adjacent_sides, block_bounds, current_noise_set):\n                # If the condition is met, mark this pixel for update\n                expansion_updates[coord_n] = block_color\n\n    # Step 7: Apply the collected expansion updates to the output grid\n    for (r, c), color in expansion_updates.items():\n        output_np[r, c] = color\n\n    # Step 8: Convert the final NumPy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 42606,
    "candidates_token_count": 3159,
    "total_token_count": 45765,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.800805,
  "retries": 1
}