{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom typing import List, Tuple, Dict, Set\n\n\"\"\"\nTransformation Rule Description:\n\n1.  **Identify Background:** Determine the most frequent color in the input grid; this is the background color.\n2.  **Find Solid Blocks:** Locate all solid 3x3 squares composed of a single non-background color. Record their color, coordinates, and bounding box (min/max row/col).\n3.  **Find Noise Pixels:** Identify all non-background pixels that are not part of any solid 3x3 block. Group these noise pixels by their color.\n4.  **Initialize Output:** Create an output grid of the same dimensions as the input, filled entirely with the background color.\n5.  **Copy Blocks:** Copy the identified solid 3x3 blocks from the input grid to the output grid at their original locations.\n6.  **Determine Block Expansion (Hypothesis 7):**\n    a.  For each solid block:\n        i.  Identify the noise pixels that share the same color as the block.\n        ii. Determine the \"active directions\" (Up, Down, Left, Right) relative to the block's bounding box based on whether any same-colored noise pixels exist strictly outside the block's boundaries in those directions.\n        iii. Find all background pixels in the *input* grid that are orthogonally adjacent to any *edge* pixel of the current block. These are the \"candidate\" pixels for expansion. For each candidate, note which side(s) of the block it is adjacent to (Above, Below, Left, Right).\n        iv. A candidate pixel changes color in the output grid if at least one of the sides it's adjacent to matches an \"active direction\" determined in step ii. The pixel's new color is the color of the adjacent block.\n7.  **Apply Expansion:** Update the output grid by changing the color of the identified candidate pixels according to the rule in step 6.iv.\n8.  **Return Output:** The final output grid contains the preserved blocks and the expanded regions. Noise pixels are implicitly removed as they are not copied, and non-expanded background pixels remain as background.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_background_color(grid: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid.flatten())\n    if not counts:\n        return 0 # Default for empty grid\n    # Ensure key is standard int\n    return int(counts.most_common(1)[0][0])\n\ndef find_solid_blocks_and_noise(grid: np.ndarray) -> tuple[int, list[tuple[int, tuple[int, int, int, int], set[tuple[int, int]]]], dict[int, set[tuple[int, int]]]]:\n    \"\"\"\n    Finds the background color, all solid 3x3 blocks, and noise pixels.\n\n    Returns:\n        - background_color (int)\n        - list_of_blocks: List of (color, (r_min, r_max, c_min, c_max), coords_set)\n        - noise_pixels_by_color: Dict {color: set_of_noise_coords}\n    \"\"\"\n    H, W = grid.shape\n    background_color = find_background_color(grid)\n    list_of_blocks = []\n    all_block_coords = set()\n    visited_block_pixels = set() # To handle potential overlaps or faster checks\n\n    # Find blocks\n    for r in range(H - 2):\n        for c in range(W - 2):\n            if (r, c) in visited_block_pixels: continue\n            color = grid[r, c]\n            if color == background_color: continue\n\n            is_solid_block = True\n            current_block_coords = set()\n            for i in range(3):\n                for j in range(3):\n                    coord = (r + i, c + j)\n                    # Check bounds explicitly\n                    if r+i >= H or c+j >= W or grid[r + i, c + j] != color or coord in visited_block_pixels:\n                        is_solid_block = False\n                        break\n                    current_block_coords.add(coord)\n                if not is_solid_block: break\n\n            if is_solid_block:\n                bounds = (r, r + 2, c, c + 2)\n                # Ensure color is standard int\n                list_of_blocks.append((int(color), bounds, current_block_coords))\n                all_block_coords.update(current_block_coords)\n                visited_block_pixels.update(current_block_coords)\n\n    # Find noise\n    noise_pixels_by_color = {}\n    for r in range(H):\n        for c in range(W):\n            coord = (r, c)\n            color = grid[r, c]\n            if color != background_color and coord not in all_block_coords:\n                noise_color_key = int(color) # Ensure key is standard int\n                if noise_color_key not in noise_pixels_by_color:\n                    noise_pixels_by_color[noise_color_key] = set()\n                noise_pixels_by_color[noise_color_key].add(coord)\n\n    return background_color, list_of_blocks, noise_pixels_by_color\n\ndef get_edge_adjacent_background_candidates(grid: np.ndarray, background_color: int, block_bounds: tuple[int, int, int, int], block_coords: set[tuple[int, int]]) -> dict[tuple[int, int], set[str]]:\n    \"\"\"\n    Finds background pixels orthogonally adjacent to block edges and notes which side(s).\n\n    Returns:\n        Dict {(r, c): set_of_sides} e.g., {(3, 0): {\"Below\"}}\n    \"\"\"\n    H, W = grid.shape\n    r_min, r_max, c_min, c_max = block_bounds\n    candidates = {} # {(r, c): {\"Above\", \"Below\", \"Left\", \"Right\"}}\n\n    # Identify edge pixels of the block\n    edge_pixels = {\n        (r, c) for r, c in block_coords\n        if r == r_min or r == r_max or c == c_min or c == c_max\n    }\n\n    # Check orthogonal neighbors of edge pixels\n    for r_edge, c_edge in edge_pixels:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal steps\n            r_n, c_n = r_edge + dr, c_edge + dc\n            coord_n = (r_n, c_n)\n\n            # Check bounds, ensure it's background color in INPUT, and not part of the block itself\n            if 0 <= r_n < H and 0 <= c_n < W and grid[r_n, c_n] == background_color and coord_n not in block_coords:\n                if coord_n not in candidates:\n                    candidates[coord_n] = set()\n                # Determine side(s) n is on relative to block bounds\n                # Candidate is \"Above\" if its row is less than block's min row, etc.\n                if r_n < r_min: candidates[coord_n].add(\"Above\")\n                if r_n > r_max: candidates[coord_n].add(\"Below\")\n                if c_n < c_min: candidates[coord_n].add(\"Left\")\n                if c_n > c_max: candidates[coord_n].add(\"Right\")\n\n    # Filter out any candidates that didn't end up on a side (e.g. inside a concave region - shouldn't happen for 3x3)\n    final_candidates = {coord: sides for coord, sides in candidates.items() if sides}\n    return final_candidates\n\ndef get_active_directions(noise_coords: set[tuple[int, int]], block_bounds: tuple[int, int, int, int]) -> set[str]:\n    \"\"\"\n    Determines active expansion directions based on noise pixels existing strictly outside block bounds.\n\n    Returns:\n        Set of directions: {\"Up\", \"Down\", \"Left\", \"Right\"}\n    \"\"\"\n    r_min, r_max, c_min, c_max = block_bounds\n    active_dirs = set()\n    if not noise_coords: # Handle case with no noise\n        return active_dirs\n    for r_p, c_p in noise_coords:\n        if r_p < r_min: active_dirs.add(\"Up\")\n        if r_p > r_max: active_dirs.add(\"Down\")\n        if c_p < c_min: active_dirs.add(\"Left\")\n        if c_p > c_max: active_dirs.add(\"Right\")\n    return active_dirs\n\n\n# === Main Transformation Function ===\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by preserving 3x3 blocks and expanding them based\n    on adjacent background pixels that are 'activated' by nearby noise pixels\n    of the same color existing beyond the block's boundaries.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    H, W = input_np.shape\n    if H == 0 or W == 0: # Handle empty input case\n        return []\n\n    # Step 1, 2, 3: Find background, blocks, and noise\n    background_color, solid_blocks_list, noise_pixels_by_color = find_solid_blocks_and_noise(input_np)\n\n    # Step 4: Initialize Output Grid with the background color\n    output_np = np.full_like(input_np, background_color)\n\n    # Step 5: Preserve Solid Blocks by copying them to the output grid\n    for color, bounds, block_coords in solid_blocks_list:\n        for r, c in block_coords:\n            # Check bounds just in case, though find_solid_blocks should ensure this\n            if 0 <= r < H and 0 <= c < W:\n                output_np[r, c] = color\n\n    # Step 6 & 7: Determine and Apply Expansion based on Hypothesis 7\n    expansion_updates = {} # Store updates as {(r, c): color} to handle potential overlaps if needed\n\n    # Iterate through each solid block found\n    for block_color, block_bounds, block_coords in solid_blocks_list:\n        # Get noise pixels matching the current block's color\n        current_noise_set = noise_pixels_by_color.get(block_color, set())\n\n        # Determine active directions based on this noise and block bounds\n        active_directions = get_active_directions(current_noise_set, block_bounds)\n        if not active_directions:\n            continue # Skip if no noise activates any direction\n\n        # Find candidate background pixels adjacent to the block's edges\n        candidate_pixels = get_edge_adjacent_background_candidates(input_np, background_color, block_bounds, block_coords)\n\n        # Check each candidate against the active directions\n        for (r_n, c_n), adjacent_sides in candidate_pixels.items():\n            coord_n = (r_n, c_n)\n            should_change = False\n            # Check if any side the candidate is adjacent to matches an active direction\n            for side in adjacent_sides:\n                # Map the side name (\"Above\", \"Below\", \"Left\", \"Right\") to the direction name (\"Up\", \"Down\", \"Left\", \"Right\")\n                direction = side\n                if side == \"Above\": direction = \"Up\"\n                elif side == \"Below\": direction = \"Down\"\n                # Left and Right map directly\n\n                if direction in active_directions:\n                    should_change = True\n                    break # Found a matching active direction, no need to check other sides\n\n            # If the candidate should change, record the update\n            if should_change:\n                # Store the coordinate and the color it should change to (block's color)\n                # Using dict handles cases where a pixel might be candidate for multiple blocks (unlikely here)\n                # or adjacent to multiple sides activated by different directions (possible).\n                expansion_updates[coord_n] = block_color\n\n    # Apply the collected expansion updates to the output grid\n    for (r, c), color in expansion_updates.items():\n        output_np[r, c] = color\n\n    # Step 8: Convert the final NumPy array back to list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 27935,
    "candidates_token_count": 3264,
    "total_token_count": 31199,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.65489,
  "retries": 1
}