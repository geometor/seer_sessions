{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Identify a solid boundary line (row or column) of red (2) pixels. This line determines the direction of movement for other objects (towards the boundary).\n2. Identify all distinct contiguous objects composed of colors other than white (0) or red (2).\n3. Sort these objects based on their proximity to the boundary in the direction of movement (objects closer to the boundary are processed first).\n4. Initialize an output grid of the same dimensions as the input, filled with white (0), and place the red boundary line onto it.\n5. Process the sorted objects one by one:\n   a. Simulate moving the entire object as a single unit, one step at a time, in the determined direction.\n   b. Movement stops when *any* part of the object would collide with the grid edges, the red boundary, or any part of an object already placed on the output grid.\n   c. Place the object onto the output grid at its final resting position.\n6. Return the completed output grid.\n\"\"\"\n\ndef find_boundary_and_direction(grid: np.ndarray) -> tuple[str | None, int | None, tuple[int, int] | None]:\n    \"\"\"\n    Finds a solid red line (row or column) and determines the movement direction towards it.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (orientation, index, direction), where orientation is 'row' or 'col',\n        index is the row/column index, and direction is a tuple (dr, dc).\n        Returns (None, None, None) if no boundary found.\n    \"\"\"\n    height, width = grid.shape\n    red_color = 2\n    direction = None\n\n    # Check rows\n    for r in range(height):\n        if np.all(grid[r, :] == red_color):\n            orientation = 'row'\n            index = r\n            if index == 0:  # Top boundary, move up\n                direction = (-1, 0)\n            elif index == height - 1: # Bottom boundary, move down\n                direction = (1, 0)\n            # Consider edge case where boundary might not be at edge, though examples don't show this.\n            # If needed, determine direction based on centroid distance or similar.\n            # For now, assume boundary is always at an edge determining direction.\n            if direction: return orientation, index, direction\n\n\n    # Check columns\n    for c in range(width):\n        if np.all(grid[:, c] == red_color):\n            orientation = 'col'\n            index = c\n            if index == 0:  # Left boundary, move left\n                direction = (0, -1)\n            elif index == width - 1: # Right boundary, move right\n                direction = (0, 1)\n            if direction: return orientation, index, direction\n\n    # Fallback if boundary isn't at an edge (not expected based on examples)\n    # or if no boundary is found\n    return None, None, None\n\n\ndef get_objects(grid: np.ndarray, background_color: int, boundary_color: int) -> list[tuple[int, list[tuple[int, int]]]]:\n    \"\"\"\n    Finds all contiguous objects of colors other than background or boundary.\n\n    Args:\n        grid: The input grid as a numpy array.\n        background_color: The color to ignore (usually white 0).\n        boundary_color: The boundary color to ignore (usually red 2).\n\n    Returns:\n        A list of objects, where each object is a tuple: (color, list_of_pixel_coords).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and color != boundary_color and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_color = color # Record the color of the object being explored\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels: # Should always be true if we entered the loop\n                    objects.append((current_color, obj_pixels))\n    return objects\n\ndef sort_objects(objects: list[tuple[int, list[tuple[int, int]]]], direction: tuple[int, int]) -> list[tuple[int, list[tuple[int, int]]]]:\n    \"\"\"Sorts objects based on proximity to the boundary in the direction of movement.\"\"\"\n    dr, dc = direction\n\n    def sort_key(obj):\n        color, pixels = obj\n        if dr > 0: # Moving down\n            return max(r for r, c in pixels)\n        elif dr < 0: # Moving up\n            return min(r for r, c in pixels)\n        elif dc > 0: # Moving right\n            return max(c for r, c in pixels)\n        elif dc < 0: # Moving left\n            return min(c for r, c in pixels)\n        else: # No movement (should not happen with valid direction)\n            return 0\n\n    # Determine reverse sort based on direction\n    # Move towards higher index (down/right) -> process higher indices first (reverse=True)\n    # Move towards lower index (up/left) -> process lower indices first (reverse=False)\n    reverse_sort = (dr > 0 or dc > 0)\n\n    return sorted(objects, key=sort_key, reverse=reverse_sort)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Shifts non-white, non-red objects towards a solid red boundary line\n    until they collide with the boundary or another settled object.\n    Objects move as whole units and maintain their shape.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    white_color = 0\n    red_color = 2\n\n    # 1. Identify Boundary and Direction\n    orientation, boundary_index, direction = find_boundary_and_direction(input_np)\n\n    if direction is None:\n        # If no boundary or direction found (unexpected based on examples), return original grid.\n        # Or potentially raise an error depending on requirements.\n        return input_grid\n\n    dr, dc = direction\n\n    # 2. Identify Objects\n    objects = get_objects(input_np, white_color, red_color)\n\n    # 3. Sort Objects\n    sorted_objects = sort_objects(objects, direction)\n\n    # 4. Initialize Output Grid and Place Boundary\n    output_np = np.full_like(input_np, white_color)\n    if orientation == 'row':\n        output_np[boundary_index, :] = red_color\n    else: # orientation == 'col'\n        output_np[:, boundary_index] = red_color\n\n    # 5. Process Sorted Objects\n    for color, initial_pixels in sorted_objects:\n        current_pixels = list(initial_pixels) # Copy to modify\n\n        # 5a. Simulate movement\n        while True:\n            can_move = True\n            next_pixels = []\n            for r, c in current_pixels:\n                next_r, next_c = r + dr, c + dc\n\n                # 5b. Check for collisions (boundary, grid edge, other objects)\n                if not (0 <= next_r < height and 0 <= next_c < width):\n                    can_move = False # Hit grid edge (should be stopped by boundary first ideally)\n                    break\n                if output_np[next_r, next_c] != white_color:\n                    can_move = False # Hit boundary or already settled object\n                    break\n                next_pixels.append((next_r, next_c))\n\n            if can_move:\n                # If all pixels can move, update current position\n                current_pixels = next_pixels\n            else:\n                # If any pixel cannot move, the whole object stops\n                break\n\n        # 5c. Place the object onto the output grid at its final position\n        for r, c in current_pixels:\n            # Sanity check for bounds, though collision logic should prevent out of bounds\n            if 0 <= r < height and 0 <= c < width:\n                 output_np[r, c] = color\n            # else:\n                # Optional: Log or handle unexpected out-of-bounds placement\n                # print(f\"Warning: Attempted to place pixel out of bounds at ({r}, {c})\")\n\n\n    # 6. Return the completed output grid\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10363,
    "candidates_token_count": 2790,
    "total_token_count": 13153,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.413255,
  "retries": 1
}