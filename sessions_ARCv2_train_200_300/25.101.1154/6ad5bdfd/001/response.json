{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a solid red (2) line (row or column) acting as a boundary.\nAll other non-white (0) objects are shifted towards this boundary.\nThe shifting continues until an object reaches the cell adjacent to the boundary \nor the cell adjacent to another object that has already been shifted and settled.\nThe space vacated by the shifted objects becomes white (0).\nThe red boundary itself remains static.\n\"\"\"\n\ndef find_boundary(grid: np.ndarray) -> tuple[str | None, int | None]:\n    \"\"\"\n    Finds a solid red line (row or column).\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (orientation, index) where orientation is 'row' or 'col',\n        and index is the row/column index. Returns (None, None) if no boundary found.\n    \"\"\"\n    height, width = grid.shape\n    red_color = 2\n\n    # Check rows\n    for r in range(height):\n        if np.all(grid[r, :] == red_color):\n            return 'row', r\n\n    # Check columns\n    for c in range(width):\n        if np.all(grid[:, c] == red_color):\n            return 'col', c\n\n    return None, None\n\ndef determine_direction(orientation: str, index: int, height: int, width: int) -> tuple[int, int] | None:\n    \"\"\"\n    Determines the direction vector (dr, dc) towards the boundary.\n\n    Args:\n        orientation: 'row' or 'col'.\n        index: The index of the boundary row/column.\n        height: Grid height.\n        width: Grid width.\n\n    Returns:\n        A tuple (dr, dc) representing the movement direction (e.g., (-1, 0) for up),\n        or None if orientation is invalid.\n    \"\"\"\n    if orientation == 'row':\n        if index == 0:  # Top boundary, move up\n            return (-1, 0)\n        elif index == height - 1: # Bottom boundary, move down\n            return (1, 0)\n    elif orientation == 'col':\n        if index == 0:  # Left boundary, move left\n            return (0, -1)\n        elif index == width - 1: # Right boundary, move right\n            return (0, 1)\n    # Should not happen with valid boundaries, but good practice\n    return None # Or perhaps default to down (1, 0)? Example 1 has bottom row implicit boundary? No, the red is explicit.\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Shifts non-white, non-red objects towards a solid red boundary line until\n    they hit the boundary or another settled object.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    white_color = 0\n    red_color = 2\n\n    # Find the boundary\n    orientation, boundary_index = find_boundary(input_np)\n\n    if orientation is None:\n        # Handle cases where no boundary is found (though examples suggest one always exists)\n        # Maybe return input unchanged or raise an error? Returning unchanged for now.\n        return input_grid\n\n    # Determine movement direction\n    dr, dc = determine_direction(orientation, boundary_index, height, width)\n\n    # Initialize output grid with white\n    output_np = np.full_like(input_np, white_color)\n\n    # Copy the boundary to the output grid\n    if orientation == 'row':\n        output_np[boundary_index, :] = red_color\n    else: # orientation == 'col'\n        output_np[:, boundary_index] = red_color\n\n    # Determine iteration order based on direction to process objects closer to the boundary first\n    rows = range(height)\n    cols = range(width)\n\n    if dr > 0: # Moving down\n        rows = range(height - 1, -1, -1)\n    elif dr < 0: # Moving up\n        rows = range(height) # Default order is fine\n    \n    if dc > 0: # Moving right\n        cols = range(width - 1, -1, -1)\n    elif dc < 0: # Moving left\n        cols = range(width) # Default order is fine\n\n    # Iterate through input grid cells based on calculated order\n    for r in rows:\n        for c in cols:\n            color = input_np[r, c]\n\n            # Skip background, boundary, and already processed parts of the output grid\n            if color == white_color or color == red_color:\n                continue\n\n            # This pixel belongs to a movable object\n            current_r, current_c = r, c\n\n            # Simulate movement step-by-step until collision\n            while True:\n                next_r, next_c = current_r + dr, current_c + dc\n\n                # Check boundary conditions\n                if not (0 <= next_r < height and 0 <= next_c < width):\n                    break # Hit grid edge (shouldn't happen before hitting boundary)\n\n                # Check collision with boundary or already settled object in output\n                if output_np[next_r, next_c] != white_color:\n                     break # Hit boundary or another object\n\n                # Move is valid, update current position\n                current_r, current_c = next_r, next_c\n\n            # Place the object's color at the final settled position\n            output_np[current_r, current_c] = color\n\n    # Convert back to list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2872,
    "candidates_token_count": 2368,
    "total_token_count": 5240,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.733021,
  "retries": 1
}