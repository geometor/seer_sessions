{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nPreserve azure (8) pixels and selectively modify other color regions based on an alternating pattern and border detection.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Find contiguous regions of the same color, excluding white (0).\n    Returns a dictionary of objects keyed by color.\n    \"\"\"\n    objects = {}\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_coords):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        obj_coords.append((r, c))\n        dfs(r + 1, c, color, obj_coords)\n        dfs(r - 1, c, color, obj_coords)\n        dfs(r, c + 1, color, obj_coords)\n        dfs(r, c - 1, color, obj_coords)\n        dfs(r + 1, c+1, color, obj_coords)\n        dfs(r + 1, c-1, color, obj_coords)\n        dfs(r - 1, c+1, color, obj_coords)\n        dfs(r - 1, c-1, color, obj_coords)\n\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and (r, c) not in visited:\n                obj_coords = []\n                dfs(r, c, color, obj_coords)\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(obj_coords)\n    return objects\n\ndef get_borders(grid, objects):\n    \"\"\"\n    Identifies border pixels for each object.\n    \"\"\"\n    rows, cols = grid.shape\n    borders = {}\n\n    for color, obj_list in objects.items():\n        for obj_coords in obj_list:\n            obj_borders = []\n            for r, c in obj_coords:\n                is_border = False\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            if grid[nr, nc] != color:\n                                is_border = True\n                                break  # optimization\n                    if is_border:\n                        break  # optimization\n                if is_border:\n                    obj_borders.append((r,c))\n            if color not in borders:\n                borders[color] = []\n\n            borders[color].extend(obj_borders)\n\n    return borders\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the observed rule.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Objects\n    objects = get_objects(input_grid)\n\n    # 2. Find Borders\n    borders = get_borders(input_grid, objects)\n    # print(borders)\n\n    # 3. Preserve Azure (8)\n    #  - Already handled by copying the input grid\n\n    # 4. Alternate and Transform\n    for color, obj_list in objects.items():\n        if color != 8: # Not azure\n              for obj in obj_list:\n                for r, c in obj:\n                    output_grid[r,c] = 0\n              border_color = None\n\n              for obj in obj_list:\n                min_r = min(r for r, c in obj)\n                max_r = max(r for r, c in obj)\n                min_c = min(c for r, c in obj)\n                max_c = max(c for r, c in obj)\n\n                for r, c in obj:\n                    if border_color is None:\n                        for dr in [-1,0,1]:\n                            for dc in [-1,0,1]:\n                                if (dr != 0 or dc !=0):\n                                    new_r = r + dr\n                                    new_c = c + dc\n                                    if new_r >= 0 and new_r < rows and new_c >= 0 and new_c < cols:\n                                        if (new_r, new_c) not in obj:\n                                          neighbor_color = input_grid[new_r, new_c]\n                                          if neighbor_color != 0 and neighbor_color != 8:\n                                            border_color = neighbor_color\n\n                    if (r-min_r) % 2 == 0 and (c - min_c) %2 == 0:\n                        output_grid[r,c] = color if border_color is None else border_color\n                    elif (r-min_r) % 2 == 1 and (c - min_c) %2 == 1:\n                        output_grid[r,c] = color if border_color is None else border_color\n                    elif (r-min_r) % 2 == 1 and (c - min_c) %2 == 0:\n                        if color in [2,3]:\n                          output_grid[r,c] = 0\n\n                    elif (r-min_r) % 2 == 0 and (c - min_c) %2 == 1:\n                        if color in [2,3]:\n                          output_grid[r,c] = 0\n\n\n    for color, border_coords in borders.items():\n      if color != 8:\n          for r,c in border_coords:\n              output_grid[r,c] = 0\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7771,
    "candidates_token_count": 1365,
    "total_token_count": 9136,
    "cached_content_token_count": 0
  },
  "response_time": 12.202498,
  "response_file": "004-response.json"
}