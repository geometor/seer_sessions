{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nExpands colored blocks vertically based on their height. If a different colored\nblock is horizontally adjacent to the original block, the adjacent block also\nexpands vertically next to the original block, maintaining their relative\npositions. The expansion amount of any object is based on its own height.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Finds contiguous blocks of non-zero pixels in the grid.\n    Returns a dictionary of objects, keyed by color, with a list of their coordinates.\n    \"\"\"\n    objects = {}\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, coords):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        coords.append((r, c))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dfs(r + dr, c + dc, color, coords)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                coords = []\n                dfs(r, c, grid[r, c], coords)\n                if grid[r,c] not in objects:\n                    objects[grid[r,c]] = []\n\n                objects[grid[r,c]].append(coords)\n    return objects\n\ndef get_object_height(object_coords):\n    \"\"\"Calculates the height of an object given its coordinates.\"\"\"\n    rows = [r for r, _ in object_coords]\n    return max(rows) - min(rows) + 1\n\ndef get_horizontally_adjacent_block(grid, object_coords):\n    \"\"\"\n    Finds a horizontally adjacent block of a different color.\n\n    Returns:\n        A tuple (adjacent_color, adjacent_coords_list) or (None, None) if no adjacent block is found.\n    \"\"\"\n    rows, cols = grid.shape\n    main_color = grid[object_coords[0][0], object_coords[0][1]]\n    adjacent_blocks = {}\n\n    # Check for horizontal adjacency only\n    for r, c in object_coords:\n        for dr, dc in [(0, 1), (0, -1)]:  # Check right and left\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] != 0 and grid[nr, nc] != main_color:\n                neighbor_color = grid[nr, nc]\n                if neighbor_color not in adjacent_blocks:\n                    adjacent_blocks[neighbor_color] = []\n                if (nr, nc) not in adjacent_blocks[neighbor_color]:\n                    adjacent_blocks[neighbor_color].append((nr, nc))\n\n\n    # DFS to get all coords of horizontally adjacent objects\n    adjacent_coords_by_color = {}\n    for color in adjacent_blocks:\n            visited_adj = set()\n            adjacent_coords_list = []\n\n            def dfs_adjacent(r, c, adj_color):\n                if (r,c) in visited_adj:\n                    return\n                if not (0 <= r < rows and 0 <= c < cols) or grid[r,c] != adj_color:\n                    return\n                \n                visited_adj.add((r,c))\n                adjacent_coords_list.append((r,c))\n\n                for dr, dc, in [(0,1), (1,0), (0, -1), (-1, 0)]:  # Include vertical neighbors in DFS\n                    dfs_adjacent(r+dr, c+dc, adj_color)\n            \n\n            # start the DFS from each coordinate of this adjacent color\n            for r,c in adjacent_blocks[color]:\n                 dfs_adjacent(r,c, color)\n\n            adjacent_coords_by_color[color] = adjacent_coords_list\n\n    if adjacent_coords_by_color:\n        first_key = list(adjacent_coords_by_color.keys())[0]\n        return first_key, adjacent_coords_by_color[first_key] # Return the first horizontally adjacent object.\n    else:\n        return None, None\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the rules.\"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid)\n    objects = get_objects(input_grid)\n\n    for color, object_coords_list in objects.items():\n        for object_coords in object_coords_list:\n            object_height = get_object_height(object_coords)\n            min_row = min(r for r, _ in object_coords)\n            min_col = min(c for _, c in object_coords)\n\n            # Vertical expansion of the main object\n            for r, c in object_coords:\n                for i in range(object_height):\n                    if r + i < rows:\n                        output_grid[r + i, c] = color\n\n            # Check for horizontally adjacent blocks\n            adjacent_color, adjacent_coords = get_horizontally_adjacent_block(input_grid, object_coords)\n            if adjacent_color:\n                adjacent_height = get_object_height(adjacent_coords)\n                adj_min_row = min( r for r,_ in adjacent_coords)\n                adj_min_col = min(c for _,c in adjacent_coords)\n\n                # Vertical expansion of adjacent object\n                \n                #find relative position of adjacent to main\n                rel_col = adj_min_col - min_col #should always be -1 or 1\n\n                for r,c in object_coords:\n                    for i in range(adjacent_height):\n                        if r + i < rows and c + rel_col < cols and c + rel_col >= 0:\n                            output_grid[r + i][c + rel_col] = adjacent_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12791,
    "candidates_token_count": 1441,
    "total_token_count": 14232,
    "cached_content_token_count": 0
  },
  "response_time": 12.84591,
  "response_file": "012-response.json"
}