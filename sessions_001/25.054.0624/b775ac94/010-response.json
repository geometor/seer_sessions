{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nExpands colored blocks based on their size and adjacency.  A colored block expands\nvertically by a factor of its size. If a different colored block is adjacent\nto the original block, the adjacent block also expands vertically next to the\noriginal block, maintaining their relative positions.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Finds contiguous blocks of non-zero pixels in the grid.\n    Returns a dictionary of objects, keyed by color, with their bounding box coordinates.\n    \"\"\"\n    objects = {}\n    visited = set()\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, coords):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        coords.append((r, c))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dfs(r + dr, c + dc, color, coords)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                coords = []\n                dfs(r, c, grid[r, c], coords)\n                if grid[r,c] not in objects:\n                    objects[grid[r,c]] = []\n\n                objects[grid[r,c]].append(coords)\n    return objects\n\ndef get_adjacent_block(grid, object_coords):\n    \"\"\"\n    Finds an adjacent block of a different color, if any.  Prioritizes\n    horizontal adjacency (left or right).\n\n    Returns:\n        A tuple (adjacent_color, adjacent_coords_list) or (None, None) if no adjacent block is found.\n    \"\"\"\n    rows, cols = grid.shape\n    main_color = grid[object_coords[0][0], object_coords[0][1]]\n    adjacent_blocks = {}\n\n    # Check for horizontal adjacency first, building a dictionary of adjacent blocks\n    for r, c in object_coords:\n        for dr, dc in [(0, 1), (0, -1)]:  # Check right and left\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] != 0 and grid[nr, nc] != main_color:\n                neighbor_color = grid[nr, nc]\n                if neighbor_color not in adjacent_blocks:\n                    adjacent_blocks[neighbor_color] = []\n                if (nr, nc) not in adjacent_blocks[neighbor_color]:\n                    adjacent_blocks[neighbor_color].append((nr, nc))\n\n\n    # Now, find *all* coordinates that comprises the adjacent block by performing\n    # another DFS for each of the adjacent colors found\n\n    adjacent_coords_by_color = {}\n    for color in adjacent_blocks:\n            visited_adj = set()\n            adjacent_coords_list = []\n\n            def dfs_adjacent(r, c, adj_color):\n                if (r,c) in visited_adj:\n                    return\n                if not (0 <= r < rows and 0 <= c < cols) or grid[r,c] != adj_color:\n                    return\n                \n                visited_adj.add((r,c))\n                adjacent_coords_list.append((r,c))\n\n                for dr, dc, in [(0,1), (1,0), (0, -1), (-1, 0)]:\n                    dfs_adjacent(r+dr, c+dc, adj_color)\n            \n\n            # start the DFS from each coordinate of this adjacent color\n            for r,c in adjacent_blocks[color]:\n                 dfs_adjacent(r,c, color)\n\n            adjacent_coords_by_color[color] = adjacent_coords_list\n\n\n\n    if adjacent_coords_by_color:  #return the coordinates of the first adjacent object\n        first_key = list(adjacent_coords_by_color.keys())[0]\n        return first_key, adjacent_coords_by_color[first_key]\n    else:\n        return None, None\n\ndef transform(input_grid):\n    # initialize output_grid\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid)\n    objects = get_objects(input_grid)\n\n\n    # iterate through all objects\n    for color, object_coords_list in objects.items():\n      for object_coords in object_coords_list:\n        # Number of copies of pixels\n        object_count = len(object_coords)\n\n        # get minimum row, col for object - used for positioning copied pixels\n        min_row = min(r for r, _ in object_coords)\n        min_col = min(c for _, c in object_coords)\n        \n        # iterate through all coordinates of object\n        for i in range(len(object_coords)):\n            # get coordinates of object\n            rx,ry = object_coords[i]\n\n            # change output pixels\n            for j in range(object_count):\n                if rx + j < rows: # prevent out of bounds\n                  output_grid[rx+j][ry]=color\n\n        # Check for an adjacent block\n        adjacent_color, adjacent_coords = get_adjacent_block(input_grid, object_coords)\n        if adjacent_color is not None:\n              adjacent_count = len(adjacent_coords)\n              \n              #get minimum row and col for adjacent object\n              adj_min_row = min( r for r, _ in adjacent_coords)\n              adj_min_col = min( c for _, c in adjacent_coords)\n\n\n              for i in range(len(object_coords)):\n                  rx, ry = object_coords[i]\n                  \n                  #find relative position of adjacent to main object\n                  rel_col = adj_min_col - ry # should always be -1 or 1\n                  \n                  for j in range(adjacent_count):\n                    #place relative to main object\n                    if rx + j < rows and ry + rel_col < cols and ry+rel_col >=0:  # prevent out of bounds access\n                        output_grid[rx+j][ry + rel_col] = adjacent_color\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19049,
    "candidates_token_count": 1501,
    "total_token_count": 20550,
    "cached_content_token_count": 0
  },
  "response_time": 15.710154,
  "response_file": "010-response.json"
}