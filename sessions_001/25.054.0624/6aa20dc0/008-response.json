{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by expanding colored shapes based on their adjacency to other shapes.\n\n1. **Identify Objects:** Locate all contiguous regions of non-yellow pixels. These are the \"colored shapes.\" Each shape is identified by its unique color (1, 2, or 6).\n\n2. **Detect Contact Points:** For each colored shape, examine its perimeter (both side-by-side and diagonal neighbors). Identify any pixels where different colored shapes are adjacent.\n\n3. **Conditional Expansion - Blue (1):** If a blue shape touches another blue shape, do not expand the blue shape at that adjacency. If a blue shape touches shapes of a *different* color, then fill all adjacent yellow cells in the *entire grid* with the same color and value as the original colored shape.\n\n4. **Conditional Expansion - Red (2):** If a red shape touches other shapes of a *different* color, then extend a single continuous perimeter of the red shape around the the touching shape.\n\n5. **Conditional Expansion - Magenta (6):** If a magenta shape touches shapes of a *different* color, then fill any immediately adjacent yellow cells with the color of the magenta shape.\n\n6. **Background:** All remaining pixels retain their original yellow (4) color.\n\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Finds all contiguous regions of non-yellow pixels, identifying them as distinct objects.\n    \"\"\"\n    objects = {}\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj_id):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or visited[r, c] or grid[r, c] != color):\n            return\n        visited[r, c] = True\n        objects[obj_id]['pixels'].append((r, c))\n        dfs(r + 1, c, color, obj_id)\n        dfs(r - 1, c, color, obj_id)\n        dfs(r, c + 1, color, obj_id)\n        dfs(r, c - 1, color, obj_id)\n        dfs(r + 1, c + 1, color, obj_id)\n        dfs(r - 1, c - 1, color, obj_id)\n        dfs(r + 1, c - 1, color, obj_id)\n        dfs(r - 1, c + 1, color, obj_id)\n\n\n    obj_id_counter = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 4 and not visited[r, c]:\n                objects[obj_id_counter] = {'color': grid[r, c], 'pixels': []}\n                dfs(r, c, grid[r, c], obj_id_counter)\n                obj_id_counter += 1\n    return objects\n\ndef get_neighbors(grid, r, c):\n    \"\"\"Returns a list of (row, col) tuples for all 8 neighbors of a pixel.\"\"\"\n    rows, cols = grid.shape\n    neighbors = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i == 0 and j == 0:\n                continue\n            nr, nc = r + i, c + j\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef expand_blue(grid, output_grid, objects):\n   \"\"\"Expands blue shapes based on the contact with different colored shapes.\"\"\"\n   for obj_id, obj_data in objects.items():\n       if obj_data['color'] == 1:  # Blue object\n           for r, c in obj_data['pixels']:\n               neighbors = get_neighbors(grid, r, c)\n               for nr, nc in neighbors:\n                  if grid[nr,nc] != 4 and grid[nr,nc] != 1:\n                     for r_out in range(output_grid.shape[0]):\n                        for c_out in range(output_grid.shape[1]):\n                           if output_grid[r_out, c_out] == 4:\n                              for nr_out, nc_out in get_neighbors(output_grid, r_out, c_out):\n                                 if (nr_out, nc_out) in obj_data['pixels']:\n                                      output_grid[r_out,c_out] = 1\n\ndef expand_red(grid, output_grid, objects):\n\n    for obj_id, obj_data in objects.items():\n        if obj_data['color'] == 2:  # Red object\n            for r, c in obj_data['pixels']:\n                neighbors = get_neighbors(grid, r, c)\n                for nr, nc in neighbors:\n                    if grid[nr, nc] != 4 and grid[nr, nc] != 2:\n                        #find contiguous shape\n                        output_grid[r,c] = 2\n                        target_obj = None\n                        for other_id, other_data in objects.items():\n                           if (nr,nc) in other_data['pixels']:\n                              target_obj = other_data\n                              break\n                        #extend perimeter\n                        if target_obj:\n                            for tr, tc in target_obj['pixels']:\n                                 target_neighbors = get_neighbors(grid, tr, tc)\n                                 for tnr, tnc in target_neighbors:\n                                    if grid[tnr,tnc] == 4:\n                                        output_grid[tnr, tnc] = 2\n                                        break\n\n\ndef expand_magenta(grid, output_grid, objects):\n    \"\"\"Expands magenta shapes by filling immediately adjacent yellow cells.\"\"\"\n    for obj_id, obj_data in objects.items():\n        if obj_data['color'] == 6:  # Magenta object\n            for r, c in obj_data['pixels']:\n                neighbors = get_neighbors(grid, r, c)\n                for nr, nc in neighbors:\n                    if grid[nr, nc] == 4:  # Adjacent to yellow\n                        output_grid[nr, nc] = 6\n\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.copy(input_grid)\n    objects = get_objects(input_grid)\n    expand_blue(input_grid, output_grid, objects)\n    expand_red(input_grid, output_grid, objects)\n    expand_magenta(input_grid, output_grid, objects)\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3865,
    "candidates_token_count": 1535,
    "total_token_count": 5400,
    "cached_content_token_count": 0
  },
  "response_time": 15.004338,
  "response_file": "008-response.json"
}