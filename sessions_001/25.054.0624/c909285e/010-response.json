{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Potential Frame:** Inspect the input grid and identify potential frame colors by looking at pixels at the edges, checking for the largest contiguous blocks of the same color.\n\n2.  **Determine Frame Color:** If a frame color is found, determine the frame color. If more than one exists, analyze inside each frame and select the frame that completely contains another object.\n\n3. **Locate Inner Object:** Locate the largest rectangular object contained completely within the frame.\n\n4.  **Extract Sub-grid:** Extract the inner object (rectangle) from the input grid.\n\n5.  **Return Sub-grid:** Return the extracted sub-grid. If no frame is found or if the frame does not contain a complete rectangular object, return an empty grid.\n\"\"\"\n\nimport numpy as np\n\ndef get_perimeter_colors(grid):\n    \"\"\"Gets the colors present on the perimeter of the grid.\"\"\"\n    rows, cols = grid.shape\n    perimeter_colors = set()\n\n    # Top and bottom rows\n    for c in range(cols):\n        perimeter_colors.add(grid[0, c])\n        perimeter_colors.add(grid[rows - 1, c])\n\n    # Left and right columns (excluding corners)\n    for r in range(1, rows - 1):\n        perimeter_colors.add(grid[r, 0])\n        perimeter_colors.add(grid[r, cols - 1])\n\n    return list(perimeter_colors)\n\ndef find_framed_region(grid, frame_color):\n    \"\"\"Finds the largest rectangular region enclosed by a frame of the specified color.\"\"\"\n    rows, cols = grid.shape\n    top_left = None\n    bottom_right = None\n\n    # Find top-left corner of frame\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == frame_color:\n                # Check if this is a valid top-left corner\n                if (c + 1 < cols and grid[r, c+1] == frame_color) or (r + 1 < rows and grid[r+1,c] == frame_color):\n                    top_left = (r, c)\n                    break\n        if top_left:\n            break\n    \n    if not top_left:\n        return None, None\n\n    # Find bottom-right corner\n    r = top_left[0]\n    c = top_left[1]\n    \n    # get width\n    while c < cols and grid[r,c] == frame_color:\n      c += 1\n    width = c - top_left[1]\n\n    #get height\n    c = top_left[1]\n    while r < rows and grid[r, c] == frame_color:\n        r += 1\n    height = r - top_left[0]  \n    \n    bottom_right = (top_left[0] + height -1, top_left[1] + width -1 )\n\n    #check full frame is valid\n    for i in range(top_left[1], bottom_right[1] + 1):\n        if not (grid[top_left[0], i] == frame_color and grid[bottom_right[0],i] == frame_color):\n            return None, None\n    for i in range(top_left[0], bottom_right[0] + 1):\n      if not (grid[i, top_left[1]] == frame_color and grid[i, bottom_right[1]] == frame_color ):\n          return None, None\n    \n    return top_left, (bottom_right[0], bottom_right[1] )\n\ndef find_inner_rectangle(grid, top_left, bottom_right):\n    \"\"\"Finds the largest rectangle inside the frame.\"\"\"\n    \n    if not top_left:\n        return None\n    \n    inner_top_left = (top_left[0] + 1, top_left[1] + 1)\n    inner_bottom_right = (bottom_right[0] - 1, bottom_right[1] -1)\n\n    #check not out of bounds\n    if inner_top_left[0] > inner_bottom_right[0] or inner_top_left[1] > inner_bottom_right[1]:\n        return None\n    \n    return inner_top_left, inner_bottom_right\n\ndef transform(input_grid):\n    \"\"\"Extracts the rectangular region enclosed by a dynamically determined frame.\"\"\"\n    grid = np.array(input_grid)\n    perimeter_colors = get_perimeter_colors(grid)\n    \n    best_frame_color = None\n    best_top_left = None\n    best_bottom_right = None\n    \n    for frame_color in perimeter_colors:\n        top_left, bottom_right = find_framed_region(grid, frame_color)\n        inner_top_left, inner_bottom_right = find_inner_rectangle(grid, top_left, bottom_right)\n\n        if inner_top_left: # frame and inner object exist\n\n            if best_top_left is None: #first found\n                best_frame_color = frame_color\n                best_top_left = top_left\n                best_bottom_right = bottom_right\n            else:\n                # compare areas\n                current_area = (inner_bottom_right[0] - inner_top_left[0] + 1) * (inner_bottom_right[1] - inner_top_left[1] + 1)\n                best_area = (best_bottom_right[0] - best_top_left[0] -1 ) * (best_bottom_right[1] - best_top_left[1] - 1)\n                if current_area > best_area:\n                    best_frame_color = frame_color\n                    best_top_left = top_left\n                    best_bottom_right = bottom_right\n\n    if best_top_left:\n        inner_top_left, inner_bottom_right = find_inner_rectangle(grid, best_top_left, best_bottom_right)\n        output_grid = grid[inner_top_left[0]:inner_bottom_right[0]+1, inner_top_left[1]:inner_bottom_right[1]+1].tolist()\n    else:\n      output_grid = []\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7728,
    "candidates_token_count": 1469,
    "total_token_count": 9197,
    "cached_content_token_count": 0
  },
  "response_time": 13.175734,
  "response_file": "010-response.json"
}