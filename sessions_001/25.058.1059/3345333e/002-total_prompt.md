# 3345333e • 002 • example_2 • investigate_coder

---

## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 6 6 0 0 0 0 0 0 0
0 0 0 6 6 0 1 1 1 1 0 0 0 0 0 0
0 0 0 0 6 6 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 6 1 1 1 1 0 0 0 0 0 0
0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 6 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 6 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 6 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1024x1024 at 0x7DBFF219E530>

**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 6 0 0 6 6 0 0 0 0 0 0 0
0 0 0 6 6 0 0 6 6 0 0 0 0 0 0 0
0 0 0 0 6 6 6 6 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 6 0 0 0 0 0 0 0 0
0 0 0 0 6 0 0 6 0 0 0 0 0 0 0 0
0 0 0 0 6 6 6 6 0 0 0 0 0 0 0 0
0 0 0 0 0 6 6 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1024x1024 at 0x7DBFF21C1A90>

## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0
3 3 3 3 2 2 2 2 0 0 0 0 0 0 0 0
3 3 3 3 2 2 2 2 2 0 0 0 0 0 0 0
3 3 3 3 2 2 0 2 0 0 0 0 0 0 0 0
3 3 3 3 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 2 2 0 2 2 0 2 2 0 0 0 0 0 0 0
0 2 2 0 0 0 0 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1024x1024 at 0x7DBFF21C1C70>

**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0
0 0 2 0 2 2 0 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0
0 2 2 0 2 2 0 2 2 0 0 0 0 0 0 0
0 2 2 0 0 0 0 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

<PIL.Image.Image image mode=RGB size=1024x1024 at 0x7DBFF21C1BD0>
<PIL.Image.Image image mode=RGB size=2108x2098 at 0x7DBFF21C2170>Okay, here's a breakdown of my observations and proposed transformation rule for the provided examples:

**Perception of Elements:**

The task involves 2D grids containing colored pixels. The primary colors involved are white (0), magenta (6), blue (1), red (2), and green (3).  The core transformation seems to involve removing certain colored objects, leaving behind only one color while maintaining the shape.

**YAML Fact Documentation:**


```yaml
facts:
  - object: shape_1
    color: magenta (6) / red (2)
    property: contiguous
    action: retained
  - object: shape_2
    color: blue (1) / green(3)
    property: contiguous
    action: removed
  - relation:
    - object: shape_1 and shape_2 are overlapping or adjacent in the input
    - description: shape_2 is inside shape_1

```


**Natural Language Program:**

1.  **Identify Objects:** Find all contiguous blocks of non-white pixels. Each block represents a separate object.
2. **Determine Interior shape:** Identify whether or not their is an object completely surrounded by another object.
3.  **Remove Interior Shape:** Remove from the input all pixels that compose an object determined to be surrounded by another object.
4. **Retain Exterior Shape:** Keep remaining object.

In simple terms: Remove a shape that is within another shape.

**INSTRUCTIONS**

- generate a Python module to represent the natural language program 
- follow the template below
- all common math and science libraries are available
- create docstring only at top - but comment the workflow in the function
- use helper functions for common operations like finding objects, counting,
  measuring, moving, etc. 

remember - we are working iteratively - so this code will inform your future
self as we converge on the solution

*template:*

```python
"""
{{ natural language description of the transformation rule }}
"""

{{ imports }}

def transform(input_grid):
    # initialize output_grid

    # change output pixels 

    return output_grid

```
