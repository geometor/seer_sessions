{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Find all the non-zero pixels in the input grid. Each of these is considered an \"object\". Note their color and initial position.\n\n2.  **Determine the Axis of Extension**:\n    *   If all objects are in one row, then the axis of extension is `column`.\n    *   If all objects are in one column, then the axis of extension is `row`.\n    *   Otherwise, if there is an initial pattern in rows, extend by `row`, else if the pattern is in columns, extend by `column`\n\n3.  **Identify the Color Pattern**:\n    *   Create an ordered list of the unique colors, this establishes the replication pattern.\n    *   If the objects span multiple rows and/or columns, consider their initial relative positions to maintain the pattern during extension.\n\n4.  **Extend the Pattern:**\n    *   **Horizontal Extension (Column Axis):** For each object, extend its color horizontally along its row, creating copies to the left and right, maintaining the original pattern spacing and order with other colors. The pattern is continued to the edge of the grid.\n    *   **Vertical Extension (Row Axis):** For each object, extend its color vertically along its column, creating copies above and below, maintaining the original pattern spacing and order with other colors. The pattern is continued to the edge of the grid.\n\n5.  **Maintain Relative Positions**: When extending, if objects had initial relative positions (e.g., color A was two columns to the left of color B), ensure this relative positioning is maintained during the extension.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Finds all unique non-zero colored pixels and their positions.\"\"\"\n    objects = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i, j] != 0:\n                objects.append((grid[i, j], (i, j)))\n    # remove duplicate color entries\n    unique_objects = []\n    seen_colors = set()\n    for color, pos in objects:\n        if color not in seen_colors:\n            unique_objects.append((color, pos))\n            seen_colors.add(color)\n\n    return unique_objects\n\ndef determine_axis(objects):\n    \"\"\"Determines the axis of replication (row or column).\"\"\"\n    if not objects:\n        return \"row\"  # Default to row if no objects\n\n    rows = set()\n    cols = set()\n    for _, (row, col) in objects:\n        rows.add(row)\n        cols.add(col)\n\n    if len(rows) == 1:\n        return \"column\"\n    elif len(cols) == 1:\n        return \"row\"\n    else:\n        # Check for an initial row or column pattern\n        row_diffs = []\n        col_diffs = []\n\n        if len(objects) > 1:\n             # Sort objects by row and then by column\n            objects.sort(key=lambda x: (x[1][0], x[1][1]))\n\n            for i in range(len(objects) - 1):\n                row_diffs.append(objects[i+1][1][0] - objects[i][1][0])\n                col_diffs.append(objects[i+1][1][1] - objects[i][1][1])\n\n            if all(c == 0 for c in col_diffs):\n                return \"row\" # Pattern in rows\n            elif all(r == 0 for r in row_diffs):\n                return \"column\" # Pattern in columns\n        return \"row\"\n\ndef extend_pattern(grid, objects, axis):\n    \"\"\"Extends the pattern horizontally or vertically.\"\"\"\n    output_grid = np.zeros_like(grid)\n    \n    if axis == \"column\":\n        # Horizontal extension\n        for color, (row, col) in objects:\n            output_grid[row, :] = color\n            \n            # Get all object of same row\n            row_objects = [obj for obj in objects if obj[1][0] == row]\n            row_objects.sort(key=lambda x: x[1][1]) # sort by column\n            \n            if len(row_objects) > 1:\n                # extend between each object\n                for i in range(len(row_objects)-1):\n                    color1, (_, col1) = row_objects[i]\n                    color2, (_, col2) = row_objects[i+1]\n                    \n                    for j in range(col1+1, col2):\n                        output_grid[row, j] = color2 if (j - col1) % 2 == 1 else color1\n\n                \n                first_color = row_objects[0][0]\n                last_color = row_objects[-1][0]\n                \n                _, first_col = row_objects[0][1]\n                _, last_col = row_objects[-1][1]\n                \n                # extend to the edges\n                color = first_color\n                for j in range(first_col -1, -1, -1):\n                    color = (last_color if color == first_color else first_color) if len(row_objects) > 1 else color\n                    output_grid[row, j] = color\n\n                color = last_color\n                for j in range(last_col + 1, grid.shape[1]):\n                    color = (first_color if color == last_color else last_color) if len(row_objects) > 1 else color\n                    output_grid[row, j] = color\n\n    elif axis == \"row\":\n        # Vertical extension\n        for color, (row, col) in objects:\n            output_grid[:, col] = color\n\n            # Get all object of same column\n            col_objects = [obj for obj in objects if obj[1][1] == col]\n            col_objects.sort(key=lambda x: x[1][0]) # sort by row\n            if len(col_objects) > 1:\n\n                # extend between each objects\n                for i in range(len(col_objects)-1):\n                    color1, (row1, _) = col_objects[i]\n                    color2, (row2, _) = col_objects[i+1]\n\n                    for i in range(row1 + 1, row2):\n                        output_grid[i, col] = color2 if (i - row1) % 2 == 1 else color1\n\n                first_color = col_objects[0][0]\n                last_color = col_objects[-1][0]\n                \n                first_row,_ = col_objects[0][1]\n                last_row, _ = col_objects[-1][1]\n\n                # extend to the edge\n                color = first_color\n                for i in range(first_row - 1, -1, -1):\n                    color = (last_color if color == first_color else first_color) if len(col_objects) > 1 else color\n                    output_grid[i, col] = color\n\n                color = last_color\n                for i in range(last_row + 1, grid.shape[0]):\n                    color = (first_color if color == last_color else last_color) if len(col_objects) > 1 else color\n                    output_grid[i, col] = color\n\n    return output_grid\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all non-zero colored pixels (objects)\n    objects = find_objects(input_grid)\n\n    if not objects:\n        return output_grid\n\n    # Determine the axis of replication\n    axis = determine_axis(objects)\n\n    # Extend pattern\n    output_grid = extend_pattern(input_grid, objects, axis)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8412,
    "candidates_token_count": 1824,
    "total_token_count": 10236,
    "cached_content_token_count": 0
  },
  "response_time": 15.142012,
  "response_file": "016-response.json"
}