{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:**\n    *   Locate the contiguous block of red pixels (color 2).\n    *   Locate all green pixels (color 3).\n\n2.  **Analyze Red Object Shape:**\n    *   Determine if the red block forms a horizontal line, a vertical line, or another shape.\n    *   Calculate the center of the red block.\n\n3.  **Analyze Green Object Positions:**\n    *  Determine the number of green pixels.\n    *  Check their positions relative to the red block (e.g. surrounding, below, etc.)\n\n4.  **Transformation Rules:**\n\n    *   **Rule 1 (Rotation):** If the red block is a horizontal line, and there is *at least* one green pixel directly above, and one green pixel directly below the center of the red line, then the red block rotates 90 degrees clockwise around its center.\n    *   **Rule 2 (No Transformation):** If the red block is a vertical line and the green pixels form a horizontal line directly below *and are equal in length*, there is no transformation. The red block stays in place.\n    *   **Rule 3 (Horizontal Translation):** If the red block is a vertical line, and the green pixels are in a line below the red block, and the green pixels extend at least one pixel beyond the width of the red block on either side, then the red block translates horizontally. The leftmost pixel of the translated red block aligns with the column of the original rightmost red pixel.\n    *   **Rule 4 (Default - No Change):**  If none of the above conditions are met, the red object does not move.\n\n5.  **Output:**\n    *   Create a new grid, retaining all original green pixels.\n    *  Apply the determined transformation (or no transformation) of the red block to the new grid.\n\"\"\"\n\nimport numpy as np\n\ndef get_red_block(grid):\n    # Find coordinates of all red pixels\n    return np.argwhere(grid == 2)\n\ndef get_green_pixels(grid):\n    # Find coordinates of all green pixels\n    return np.argwhere(grid == 3)\n\ndef is_horizontal(coords):\n    #check that all coordinates are on the same row\n    return all([coords[0][0] == c[0] for c in coords])\n\ndef is_vertical(coords):\n    #check that all coordinates are on the same column\n    return all([coords[0][1] == c[1] for c in coords])\n\ndef calculate_center(coords):\n    min_x = min(coords[:, 0])\n    max_x = max(coords[:, 0])\n    min_y = min(coords[:, 1])\n    max_y = max(coords[:, 1])\n    return np.array([(min_x + max_x) / 2.0, (min_y + max_y) / 2.0])\n\ndef rotate_90(coords, center):\n    # Rotate coordinates 90 degrees clockwise around a center point\n    centered_coords = coords - center\n    rotated_coords = np.array([[-y, x] for x, y in centered_coords])\n    return rotated_coords + center\n\ndef check_green_above_below(red_center, green_pixels):\n    #check that green pixels are above and below the center\n    above = False\n    below = False\n    for gx, gy in green_pixels:\n        if gy == int(red_center[1]) and gx < int(red_center[0]):\n            above = True\n        if gy == int(red_center[1]) and gx > int(red_center[0]):\n            below = True\n    return above and below\n\ndef green_line_below(red_block, green_pixels):\n    #check that green pixels are only below the red block\n\n    #all green must be below red\n    red_rows = set(red_block[:,0])\n    green_rows = set(green_pixels[:,0])\n\n    if(len(green_rows) > 0 and max(green_rows) <= min(red_rows)):\n      return False\n\n    #check that its a line\n    if(len(green_rows) != 1):\n        return False;\n\n    return True\n\ndef is_green_line_extended(red_block, green_pixels):\n    #return if green line extends beyond edges of the red block\n    if(len(green_pixels) == 0):\n        return False\n\n    red_cols = sorted(red_block[:, 1])\n    green_cols = sorted(green_pixels[:,1])\n\n    return green_cols[0] < red_cols[0] and green_cols[-1] > red_cols[-1]\n    \n\ndef transform(input_grid):\n    # Initialize output grid with the original colors\n    output_grid = np.copy(input_grid)\n\n    # Get the red block and green pixels coordinates\n    red_block = get_red_block(input_grid)\n    green_pixels = get_green_pixels(input_grid)\n\n    #if no red block return\n    if(len(red_block) == 0):\n        return output_grid\n\n    #remove original red pixels\n    output_grid[output_grid == 2] = 0\n\n    # Rule 1: Horizontal Rotation\n    if is_horizontal(red_block):\n        red_center = calculate_center(red_block)\n        if check_green_above_below(red_center, green_pixels):\n            rotated_red_block = rotate_90(red_block, red_center)\n            rotated_red_block = np.round(rotated_red_block).astype(int) #convert back\n             #place back into array\n            for x, y in rotated_red_block:\n                if 0 <= x < output_grid.shape[0] and 0 <= y < output_grid.shape[1]:\n                    output_grid[x,y] = 2\n            return output_grid\n\n    # Rule 2 & 3: Vertical line (translation or no change)\n    elif is_vertical(red_block):\n        if green_line_below(red_block, green_pixels):\n            if len(green_pixels) == len(red_block):  # Rule 2: No change\n                #place original red block\n                for x, y in red_block:\n                    output_grid[x,y] = 2\n                return output_grid\n            elif is_green_line_extended(red_block, green_pixels):  #Rule 3 translate\n                rightmost_col = max(red_block[:,1])\n                translated_red_block = []\n                for x,y in red_block:\n                    new_y = rightmost_col\n                    translated_red_block.append( (x,new_y) )\n\n                for x, y in translated_red_block:\n                    if 0 <= x < output_grid.shape[0] and 0 <= y < output_grid.shape[1]:\n                        output_grid[x,y]=2\n                return output_grid\n\n    # Rule 4: Default, no change\n    for x, y in red_block:\n        output_grid[x,y] = 2\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5334,
    "candidates_token_count": 1670,
    "total_token_count": 7004,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 14.661394,
  "response_file": "014-response.json"
}