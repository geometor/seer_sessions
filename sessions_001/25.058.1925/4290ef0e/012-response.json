{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  Identify Target Pixels: Examine the input grid and identify all pixels that are not azure (color 8).\n2. Create Output Grid: If there is one and only one non-azure color, create a 7x7 output grid filled with black (color 0) and place the single pixel of the found color in the bottom right corner.\n3. Handle Multiple Target Colors**: If there are multiple non-azure pixel colors, the program should determine their locations relative to each other, and re-create that relative positioning and color in the output grid, with black (color 0) used for empty cells. If it would overflow the 7x7 grid, then fallback to placing the pixel that is farthest down and to the right, and fill the output grid according to instruction 2.\n\"\"\"\n\nimport numpy as np\n\ndef find_target_pixels(grid):\n    \"\"\"Finds all pixels that are not azure (color 8) and returns their coordinates and colors.\"\"\"\n    rows, cols = grid.shape\n    target_pixels = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 8:\n                target_pixels.append(((r, c), grid[r, c]))\n    return target_pixels\n\ndef transform(input_grid):\n    # Find target pixels (non-azure pixels).\n    target_pixels = find_target_pixels(input_grid)\n\n    # initialize output_grid\n    output_grid = np.zeros((7, 7), dtype=int)\n\n\n    # If only one target pixel color, place it in the bottom-right corner.\n    if len(set(color for _, color in target_pixels)) == 1:\n      if len(target_pixels) > 0:\n        output_grid[6, 6] = target_pixels[0][1]\n\n    # handle more than one target pixel color\n    elif len(target_pixels) > 1:\n        # get the coordinates of the target pixels\n        coords = [coord for coord, _ in target_pixels]\n        # calculate row and col min/max\n        min_r = min(r for r, _ in coords)\n        max_r = max(r for r, _ in coords)\n        min_c = min(c for _, c in coords)\n        max_c = max(c for _, c in coords)\n\n        # calculate the size of the area to copy\n        height = max_r - min_r + 1\n        width = max_c - min_c + 1\n\n        # if we can fit the identified rectangle, copy it\n        if height <= 7 and width <=7:\n            for (r,c), color in target_pixels:\n                # shift the input to the output grid\n                output_grid[r-min_r, c-min_c] = color\n        else: # fallback: find pixel farthest down and right\n          # find bottom-right most pixel by sorting by row and then by column\n          target_pixels.sort(key=lambda item: (item[0][0], item[0][1]), reverse=True)\n          output_grid[6,6] = target_pixels[0][1]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5681,
    "candidates_token_count": 732,
    "total_token_count": 6413,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 7.789382,
  "response_file": "012-response.json"
}