{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Initialize:** Create an output grid filled with white (0).\n2.  **Identify Central Square:** Find the largest square of uniform color centered within the input grid. Note its color (which will be blue in these cases) and size.\n3. **Determine Corner Regions:** Identify colored regions (pixels that are not white and not the central square's color) in the four quadrants (top-left, top_right, bottom-left, bottom-right) relative to the *input grid's* central square. Note their colors and positions relative to the central square.\n4.  **Calculate Output Size:** The output grid size should be large enough to accommodate the expanded central square and the corner regions. The central square expands by 2. Calculate the output size such that the positions of all corner regions, after being positioned relative to the *center of the output*, are within the output grid bounds. A minimum output grid size should be the expanded central_square size + 2.\n5.  **Expand Central Square:** Expand the central square by 2 in the output grid, centered.\n6.  **Place Corner Regions:** Position the corner regions in the output grid. Maintain their original relative positions (quadrant and offset) to the *center of the output grid*, mirroring the input grid's layout relative to *its* central square.\n7.  **Create Gray Frame:** Iterate through the output grid. If a cell is white (0) and is adjacent (horizontally, vertically, or diagonally) to any cell that is not white and not gray, set it to gray (5).\n8. **Return:** The transformed output grid.\n\"\"\"\n\nimport numpy as np\n\ndef get_central_square(grid):\n    \"\"\"Finds the largest central square of the same color.\"\"\"\n    rows, cols = grid.shape\n    center_row, center_col = rows // 2, cols // 2\n    center_color = grid[center_row, center_col]\n    size = 0\n\n    for i in range(min(center_row, center_col) + 1):\n        is_square = True\n        for r in range(center_row - i, center_row + i + 1):\n            for c in range(center_col - i, center_col + i + 1):\n                if not (0 <= r < rows and 0 <= c < cols and grid[r,c] == center_color):\n                    is_square = False\n                    break\n            if not is_square:\n                break\n        if is_square:\n            size = 2 * i + 1\n        else:\n            break\n\n    start_row, start_col = center_row - (size - 1) // 2, center_col - (size - 1) // 2\n\n    return start_row, start_col, size, center_color\n\ndef get_corner_regions(input_grid, start_row, start_col, size):\n    \"\"\"Identifies colored regions in the corners relative to the central square.\"\"\"\n    corner_regions = {\n        \"top_left\": [],\n        \"top_right\": [],\n        \"bottom_left\": [],\n        \"bottom_right\": []\n    }\n    rows, cols = input_grid.shape\n    center_color = input_grid[start_row, start_col]\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            if color != 0 and color != center_color:\n                if r < start_row and c < start_col:  # Top Left\n                    corner_regions[\"top_left\"].append((r, c, color))\n                elif r < start_row and c >= start_col + size:  # Top Right\n                    corner_regions[\"top_right\"].append((r, c, color))\n                elif r >= start_row + size and c < start_col:  # Bottom Left\n                    corner_regions[\"bottom_left\"].append((r, c, color))\n                elif r >= start_row + size and c >= start_col + size:  # Bottom Right\n                    corner_regions[\"bottom_right\"].append((r, c, color))\n    return corner_regions\n\ndef calculate_output_size(input_grid, central_square_size, corner_regions):\n    \"\"\"Calculates the output size based on the expanded central square and corner regions.\"\"\"\n    start_row, start_col, size, _ = get_central_square(input_grid)\n    expanded_size = central_square_size + 2\n\n    max_offset_row = 0\n    max_offset_col = 0\n\n    # Calculate offsets of the corner regions relative to the central square.\n    for region, pixels in corner_regions.items():\n        for r, c, _ in pixels:\n            if region == \"top_left\":\n                row_offset = start_row - r\n                col_offset = start_col - c\n            elif region == \"top_right\":\n                row_offset = start_row-r\n                col_offset = c - (start_col + size -1)\n            elif region == \"bottom_left\":\n                row_offset = r - (start_row + size - 1)\n                col_offset = start_col -c\n            elif region == \"bottom_right\":\n                row_offset = r - (start_row + size - 1)\n                col_offset = c - (start_col + size - 1)\n            max_offset_row = max(max_offset_row, row_offset)\n            max_offset_col = max(max_offset_col, col_offset)\n\n\n    output_size = max(expanded_size + 2 * max_offset_row, expanded_size + 2* max_offset_col)\n\n    return output_size\n\ndef is_adjacent_to_non_white_non_gray(grid, r, c):\n    \"\"\"Checks if a cell is adjacent to a non-white, non-gray cell.\"\"\"\n    rows, cols = grid.shape\n    for i in range(max(0, r - 1), min(rows, r + 2)):\n        for j in range(max(0, c - 1), min(cols, c + 2)):\n            if (i != r or j != c) and grid[i, j] != 0 and grid[i, j] != 5:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the described rules.\"\"\"\n\n    # 1. Initialize output grid with white.\n    start_row, start_col, size, center_color = get_central_square(input_grid)\n    corner_regions = get_corner_regions(input_grid, start_row, start_col, size)\n    output_size = calculate_output_size(input_grid, size, corner_regions)\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n\n\n    # 2. Expand Central Square\n    expanded_size = size + 2\n    output_center = output_size // 2\n    expanded_start_row = output_center - expanded_size // 2\n    expanded_start_col = output_center - expanded_size // 2\n\n    for r in range(expanded_size):\n        for c in range(expanded_size):\n            output_grid[expanded_start_row + r, expanded_start_col + c] = center_color\n\n    # 3. Position Colored Regions\n    input_center_row, input_center_col = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n\n    for region, pixels in corner_regions.items():\n        for r, c, color in pixels:\n            # Calculate the offset relative to the input center\n            row_offset = r - input_center_row\n            col_offset = c - input_center_col\n\n            # Place the pixel in output grid, maintaining the offset relative to the output center\n            output_row = output_center + row_offset\n            output_col = output_center + col_offset\n            output_grid[output_row, output_col] = color\n\n\n    # 4. Create Gray Frame\n    for r in range(output_size):\n        for c in range(output_size):\n            if output_grid[r, c] == 0 and is_adjacent_to_non_white_non_gray(output_grid, r, c):\n                output_grid[r, c] = 5\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5467,
    "candidates_token_count": 1963,
    "total_token_count": 7430,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 17.641117,
  "response_file": "020-response.json"
}