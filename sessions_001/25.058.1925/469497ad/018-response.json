{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe input grid is transformed into a larger output grid. The central blue square in the input is expanded and centered in the output.\nOther colored regions from the input are placed on the corresponding borders of the output grid.\nA gray frame surrounds the expanded blue region and other non-white, non-blue colored regions. The background is white.\n\"\"\"\n\nimport numpy as np\n\ndef get_central_square(grid):\n    \"\"\"Finds the largest central square of the same color.\"\"\"\n    rows, cols = grid.shape\n    center_row, center_col = rows // 2, cols // 2\n    center_color = grid[center_row, center_col]\n    size = 0\n\n    for i in range(min(center_row, center_col) + 1):\n        is_square = True\n        for r in range(center_row - i, center_row + i + 1):\n            for c in range(center_col - i, center_col + i + 1):\n                if not (0 <= r < rows and 0 <= c < cols and grid[r,c] == center_color):\n                    is_square = False\n                    break\n            if not is_square:\n                break\n        if is_square:\n            size = 2 * i + 1\n        else:\n            break\n\n    start_row, start_col = center_row - (size - 1) // 2, center_col - (size - 1) // 2\n\n    return start_row, start_col, size, center_color\n\ndef get_corner_regions(input_grid, start_row, start_col, size):\n    \"\"\"Identifies colored regions in the corners relative to the central square.\"\"\"\n    corner_regions = {\n        \"top_left\": [],\n        \"top_right\": [],\n        \"bottom_left\": [],\n        \"bottom_right\": []\n    }\n    rows, cols = input_grid.shape\n    center_color = input_grid[start_row, start_col]\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c]\n            if color != 0 and color != center_color:\n                if r < start_row and c < start_col:  # Top Left\n                    corner_regions[\"top_left\"].append((r, c, color))\n                elif r < start_row and c >= start_col + size:  # Top Right\n                    corner_regions[\"top_right\"].append((r, c, color))\n                elif r >= start_row + size and c < start_col:  # Bottom Left\n                    corner_regions[\"bottom_left\"].append((r, c, color))\n                elif r >= start_row + size and c >= start_col + size:  # Bottom Right\n                    corner_regions[\"bottom_right\"].append((r, c, color))\n    return corner_regions\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the described rules.\"\"\"\n\n    # 1. Determine Output Grid Size and Central Square\n    start_row, start_col, size, center_color = get_central_square(input_grid)\n    corner_regions = get_corner_regions(input_grid, start_row, start_col, size)\n\n    # Calculate output size based on central square and corner objects\n    max_x_offset = 0\n    max_y_offset = 0\n\n    for region in corner_regions:\n        for x,y,color in corner_regions[region]:\n            if region == \"top_right\" or region == \"bottom_right\":\n                if y > max_x_offset:\n                    max_x_offset = y\n            if region == \"bottom_left\" or region == \"bottom_right\":\n                if x > max_y_offset:\n                    max_y_offset = x\n\n    output_size = max(max_x_offset,max_y_offset) * 2 + 2\n    if output_size < size + 2:\n        output_size = size + 2\n\n    # Ensure a minimum size for the output and expanded central square.\n    expanded_size = size + 2 # expand\n    if expanded_size + 2 > output_size:\n         output_size = expanded_size + 2\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n    output_center = output_size // 2\n\n\n    # 2. Expand Central Square\n    expanded_start_row = output_center - expanded_size // 2\n    expanded_start_col = output_center - expanded_size // 2\n\n    for r in range(expanded_size):\n        for c in range(expanded_size):\n            output_grid[expanded_start_row + r, expanded_start_col + c] = center_color\n\n\n    # 3. Position Colored Regions\n    input_rows, input_cols = input_grid.shape\n\n    for region, pixels in corner_regions.items():\n      for r, c, color in pixels:\n        if region == \"top_left\":\n            output_grid[r, c] = color\n        elif region == \"top_right\":\n            output_grid[r, output_size - (input_cols - c)] = color\n        elif region == \"bottom_left\":\n            output_grid[output_size - (input_rows - r), c] = color\n        elif region == \"bottom_right\":\n            output_grid[output_size - (input_rows - r), output_size - (input_cols - c)] = color\n            \n\n    # 4. Add Gray Frame\n    for r in range(output_size):\n        for c in range(output_size):\n            if output_grid[r,c] == 0:\n               if r == expanded_start_row -1  and c >= expanded_start_col -1 and c <= expanded_start_col + expanded_size:\n                    output_grid[r,c] = 5\n               elif r == expanded_start_row + expanded_size and c >= expanded_start_col -1 and c <= expanded_start_col + expanded_size:\n                   output_grid[r,c] = 5\n               elif c == expanded_start_col - 1 and r >= expanded_start_row -1 and r <= expanded_start_row + expanded_size:\n                    output_grid[r,c] = 5\n               elif c == expanded_start_col + expanded_size and r >= expanded_start_row -1 and r <= expanded_start_row + expanded_size:\n                   output_grid[r,c] = 5\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7421,
    "candidates_token_count": 1544,
    "total_token_count": 8965,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 16.13193,
  "response_file": "018-response.json"
}