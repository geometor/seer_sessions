{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Magenta Rectangles:** Locate all rectangular shapes formed by contiguous magenta (6) pixels.\n\n2.  **Conditional Outline Modification:**\n    *   If a magenta rectangle *does not* enclose any azure (8) pixels, change all its magenta (6) pixels to green (3).\n    *   If a magenta rectangle *does* enclose one or more azure (8) pixels, proceed to step 3, but do not change it's outline to green.\n\n3.  **Conditional Center Filling:** If a magenta rectangle completely encloses one or more azure (8) pixels, replace the \"center\" azure (8) pixels with a yellow (4) square. The \"center\" is defined as the largest possible square of azure pixels within the magenta rectangle, maintaining equal distance from all four sides of the outer magenta rectangle. If an equal distance cannot be created because the rectangle's inner area is not large enough, then do not fill.\n\n4.  **Background Color Change:** Any azure (8) pixel that is directly adjacent (horizontally or vertically, not diagonally) to a green (3) or yellow (4) pixel is changed to green (3).\n\n5. **Preserve Unchanged:** any azure(8) pixels not adjacent to other colors remain unchanged, and any magenta(6) rectangles that enclose other colors, remain unchanged.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid, color):\n    objects = []\n    visited = set()\n\n    def is_valid(r, c):\n        return 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]\n\n    def dfs(r, c, current_object):\n        if (r, c) in visited or not is_valid(r, c) or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        current_object.append((r, c))\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dfs(r + dr, c + dc, current_object)\n\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r, c] == color and (r, c) not in visited:\n                current_object = []\n                dfs(r, c, current_object)\n                if current_object:\n                    objects.append(current_object)\n    return objects\n\ndef is_rectangle(obj):\n    rows, cols = zip(*obj)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return len(obj) == (max_row - min_row + 1) * (max_col - min_col + 1)\n\ndef get_rectangle_bounds(obj):\n    rows, cols = zip(*obj)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return min_row, max_row, min_col, max_col\n\ndef encloses_color(grid, obj, color):\n    min_row, max_row, min_col, max_col = get_rectangle_bounds(obj)\n    for r in range(min_row + 1, max_row):\n        for c in range(min_col + 1, max_col):\n            if grid[r,c] == color:\n                return True\n    return False\n\ndef get_center_square(obj, grid):\n    min_row, max_row, min_col, max_col = get_rectangle_bounds(obj)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    if height < 3 or width < 3:\n        return []  # No center if smaller than 3x3\n    \n    center_min_row = min_row + 1\n    center_max_row = max_row - 1\n    center_min_col = min_col + 1\n    center_max_col = max_col - 1\n    \n\n    # Adjust to the center if there's even size (keep equal size from borders)\n    while (center_max_row - center_min_row) > 1 and grid[center_min_row:center_max_row+1, center_min_col:center_max_col+1].all() == 8 :\n       center_min_row +=1\n       center_max_row -=1\n       \n    while (center_max_col - center_min_col) > 1 and grid[center_min_row:center_max_row+1, center_min_col:center_max_col+1].all() == 8:\n       center_min_col +=1\n       center_max_col -=1\n\n    center_square = []\n    for r in range(center_min_row, center_max_row + 1):\n        for c in range(center_min_col, center_max_col + 1):\n            center_square.append((r, c))\n    return center_square\n\ndef is_adjacent(grid, r, c, colors):\n    for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < grid.shape[0] and 0 <= nc < grid.shape[1] and grid[nr, nc] in colors:\n            return True\n    return False\n    \n\ndef transform(input_grid):\n    output_grid = np.copy(input_grid)\n    magenta_objects = find_objects(input_grid, 6)\n    rectangles = [obj for obj in magenta_objects if is_rectangle(obj)]\n    \n    for rect in rectangles:\n        #Outline Modification\n        if not encloses_color(input_grid, rect, 8):\n             for r, c in rect:\n                output_grid[r, c] = 3  # Change to green\n        #Fill Interior\n        elif encloses_color(input_grid,rect, 8):\n            center_square = get_center_square(rect, input_grid)\n            for r, c in center_square:\n                output_grid[r,c] = 4\n\n    #Background Modification\n    for r in range(output_grid.shape[0]):\n        for c in range(output_grid.shape[1]):\n            if output_grid[r,c] == 8:\n                if is_adjacent(output_grid, r, c, [3, 4]):\n                  output_grid[r,c] = 3\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6318,
    "candidates_token_count": 1587,
    "total_token_count": 7905,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 11.374396,
  "response_file": "004-response.json"
}