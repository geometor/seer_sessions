import numpy as np

def code_execution(input_grid, output_grid, predicted_grid):
    input_grid = np.array(input_grid)
    output_grid = np.array(output_grid)
    predicted_grid = np.array(predicted_grid)

    print("Input Grid:")
    print(input_grid)
    print("Output Grid:")
    print(output_grid)
    print("Predicted Grid:")
    print(predicted_grid)
    
    input_objects = {}
    output_objects = {}

    #very simplistic object counting, but ok for now
    for color in np.unique(input_grid):
        input_objects[color] = np.sum(input_grid == color)
    for color in np.unique(output_grid):
        output_objects[color] = np.sum(output_grid == color)    

    print("Input object counts:", input_objects)
    print("Output object counts:", output_objects)
    print("Prediction matches output?", np.array_equal(output_grid, predicted_grid))
    print("-" * 20)


# Example Usage (using provided task data - train pairs 1-3)
task = {
  "train": [
    {
      "input": [[8, 1, 1, 8, 1, 1, 1, 8, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 8, 1, 8, 1, 8, 1, 8, 8, 8, 1, 8, 1], [8, 1, 8, 1, 8, 1, 1, 8, 8, 1, 8, 8, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 8, 8, 8, 8, 1, 1, 8, 1], [8, 8, 1, 1, 8, 1, 1, 8, 1, 8, 1, 1, 1, 8, 8, 8, 1, 8, 1, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1], [1, 8, 8, 8, 8, 1, 1, 1, 1, 8, 8, 1, 8, 1, 1, 1, 1, 8, 8, 8, 8, 1, 8, 1, 1, 1, 8, 1, 8, 1], [1, 8, 1, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 1, 8, 1, 1, 1, 1, 8, 1, 8, 1, 1, 8], [1, 8, 8, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 1, 8, 8, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 1], [8, 1, 1, 8, 1, 1, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 1, 8, 1, 8, 1, 1, 1, 8, 1, 8], [1, 1, 8, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 1, 1, 1, 1, 8, 1, 1, 8, 8]],
      "output": [[8, 1, 1, 8, 1, 1, 1, 8, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 8, 1, 8, 1, 8, 1, 8, 8, 8, 1, 8, 1], [8, 1, 8, 1, 8, 1, 1, 8, 8, 1, 8, 8, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 8, 8, 8, 8, 1, 1, 8, 1], [8, 8, 1, 1, 8, 1, 1, 8, 1, 8, 1, 1, 1, 8, 8, 8, 1, 8, 1, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1], [1, 8, 8, 8, 8, 1, 1, 1, 1, 8, 8, 1, 8, 1, 1, 1, 1, 8, 8, 8, 8, 1, 8, 1, 1, 1, 8, 1, 8, 1], [1, 8, 1, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 1, 8, 1, 1, 1, 1, 8, 1, 8, 1, 1, 8], [1, 8, 8, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 1, 8, 8, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 1], [8, 1, 1, 8, 1, 1, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 8, 1, 8, 1, 8, 1, 1, 1, 8, 1, 8], [1, 1, 8, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 1, 1, 1, 1, 8, 1, 1, 8, 8]]
    },
    {
      "input": [[1, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 1], [1, 8, 8, 1, 8, 8, 8, 8, 8, 1, 1, 8, 1, 8, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 8], [8, 8, 8, 1, 8, 1, 8, 1, 1, 1, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 1, 1, 8, 1, 1, 1], [8, 1, 8, 8, 1, 1, 1, 1, 8, 8, 8, 8, 8, 1, 1, 1, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 1, 8, 1, 1], [8, 1, 8, 8, 8, 1, 1, 8, 8, 1, 8, 1, 1, 8, 8, 8, 1, 8, 8, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 1], [1, 8, 1, 1, 1, 8, 1, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 8, 8, 8, 1, 1, 1, 1, 8, 8], [1, 8, 8, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1, 8, 1, 1, 8, 1, 8, 1], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 1, 8, 1, 8, 1, 8, 1, 1, 8, 8, 1, 8, 8]],
      "output": [[1, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 1], [1, 8, 8, 1, 8, 8, 8, 8, 8, 1, 1, 8, 1, 8, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 8, 1, 8, 1, 1, 8], [8, 8, 8, 1, 8, 1, 8, 1, 1, 1, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 1, 1, 8, 1, 1, 1], [8, 1, 8, 8, 1, 1, 1, 1, 8, 8, 8, 8, 8, 1, 1, 1, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 1, 8, 1, 1], [8, 1, 8, 8, 8, 1, 1, 8, 8, 1, 8, 1, 1, 8, 8, 8, 1, 8, 8, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 1], [1, 8, 1, 1, 1, 8, 1, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 8, 1, 1, 8, 8, 8, 8, 1, 1, 1, 1, 8, 8], [1, 8, 8, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1, 8, 1, 1, 8, 1, 8, 1], [8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 1, 1, 8, 8, 1, 8, 1, 8, 1, 8, 1, 1, 8, 8, 1, 8, 8]]
    },
    {
      "input": [[8, 8, 1, 8, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 1, 1, 1, 1, 8, 1, 8, 8], [8, 1, 1, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 1, 8, 8, 8, 1, 1, 8, 1], [8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 8, 1, 1, 1, 8, 8, 8, 1, 8, 1], [8, 8, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 4, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8], [8, 1, 1, 8, 1, 8, 8, 8, 8, 1, 8, 8, 1, 1, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 8, 1, 1], [1, 1, 8, 1, 1, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 1, 1, 1, 8, 8, 1, 1, 1, 8, 8, 8, 8, 1, 8, 1], [8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8, 8, 1, 1, 8, 1, 8, 1, 1, 1], [1, 8, 8, 1, 8, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1, 1, 8, 1, 8, 1, 8, 8, 8, 8, 1, 1, 1, 8, 1, 1]],
      "output": [[8, 8, 1, 8, 1, 8, 8, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 1, 1, 1, 1, 8, 1, 8, 8], [8, 1, 1, 1, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 1, 8, 8, 8, 1, 1, 8, 1], [8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 8, 8, 8, 1, 8, 8, 1, 1, 1, 8, 8, 8, 1, 8, 1], [8, 8, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 4, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8], [8, 1, 1, 8, 1, 8, 8, 8, 8, 1, 8, 8, 1, 1, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 1, 8, 1, 1], [1, 1, 8, 1, 1, 1, 8, 8, 8, 8, 8, 8, 1, 1, 8, 1, 1, 1, 8, 8, 1, 1, 1, 8, 8, 8, 8, 1, 8, 1], [8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8, 8, 8, 8, 1, 1, 8, 8, 1, 8, 8, 1, 1, 8, 1, 8, 1, 1, 1], [1, 8, 8, 1, 8, 8, 8, 8, 1, 1, 1, 8, 1, 8, 1, 1, 8, 1, 8, 1, 8, 8, 8, 8, 1, 1, 1, 8, 1, 1]]
    }    
  ]
}

import numpy as np

def transform(input_grid):
    # Convert input grid to a NumPy array
    input_grid = np.array(input_grid)
    rows, cols = input_grid.shape

    # find all blue and azure cells
    blue_azure_indices = np.where((input_grid == 1) | (input_grid == 8))
    blue_azure_coords = list(zip(blue_azure_indices[0], blue_azure_indices[1]))
    
    # compute the minimum bounding box
    min_row = np.min(blue_azure_indices[0])
    max_row = np.max(blue_azure_indices[0])
    min_col = np.min(blue_azure_indices[1])
    max_col = np.max(blue_azure_indices[1])    

    output_grid = np.zeros((max_row-min_row+1, max_col-min_col+1),dtype=int)    
    for r,c in blue_azure_coords:
        output_grid[r-min_row,c-min_col]=input_grid[r,c]

    return output_grid


for i, example in enumerate(task['train']):
    predicted_output = transform(example['input'])
    code_execution(example['input'], example['output'], predicted_output)