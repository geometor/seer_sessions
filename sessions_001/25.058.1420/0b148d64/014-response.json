{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Green Regions:** Locate all contiguous regions of green (3) pixels in the input grid.\n2.  **Check for Context:** For each green region:\n    *   Check if it's surrounded by a contiguous region of white (0) pixels.\n    *   If white surrounds the green, check if the white region is surrounded by a contiguous region of red (2) pixels.\n3. **Conditional Extraction**\n    *   If the green is surrounded by white, and the white is surrounded by red, extract the *entire* region (green, white, and red).\n    *    If green is surrounded by only white, extract green and surrounding white.\n    *   Otherwise, extract only the green region.\n4.  **Create Square:** If extracted object is not square, pad with the background color of the extracted region to make a square. If the extracted region includes the red and white context, the output is already the correctly cropped portion of the input.\n\"\"\"\n\nimport numpy as np\n\ndef find_contiguous_regions(grid, color):\n    \"\"\"Finds all contiguous regions of a given color.\"\"\"\n    visited = set()\n    regions = []\n\n    def dfs(row, col):\n        \"\"\"Depth-first search to find contiguous pixels.\"\"\"\n        if (row, col) in visited or not (0 <= row < grid.shape[0] and 0 <= col < grid.shape[1]) or grid[row, col] != color:\n            return []\n        \n        visited.add((row, col))\n        region = [(row, col)]\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            region.extend(dfs(row + dr, col + dc))\n        \n        return region\n\n    for row in range(grid.shape[0]):\n        for col in range(grid.shape[1]):\n            if (row, col) not in visited and grid[row, col] == color:\n                regions.append(dfs(row, col))\n\n    return regions\n\ndef find_object_with_context(grid, color):\n    \"\"\"Finds objects and some context\"\"\"\n    regions = find_contiguous_regions(grid, color)\n    objects = []\n    for region in regions:\n        min_row = min(r[0] for r in region)\n        max_row = max(r[0] for r in region)\n        min_col = min(r[1] for r in region)\n        max_col = max(r[1] for r in region)\n\n        objects.append( {\n            \"coords\": region,\n            \"bounding_box\": (min_row, max_row, min_col, max_col)\n            } )\n    return objects\n\ndef get_surrounding_context(grid, obj, color):\n    \"\"\"Gets the contiguous region of a given color surrounding the object.\"\"\"\n    min_row, max_row, min_col, max_col = obj['bounding_box']\n    context = []\n    visited = set(obj['coords'])\n\n    def dfs(row, col):\n        if (row, col) in visited or not (0 <= row < grid.shape[0] and 0 <= col < grid.shape[1]) or grid[row, col] != color:\n            return []\n\n        visited.add((row,col))\n        current_context = [(row,col)]\n\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n          current_context.extend(dfs(row+dr, col+dc))\n        return current_context\n      \n    # Check the boundary around the object's bounding box\n    for r in range(min_row - 1, max_row + 2):\n        for c in range(min_col - 1, max_col + 2):\n            if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:  # Within grid bounds\n                if (r, c) not in obj['coords'] and grid[r,c] == color: #not part of obj, and correct color\n                  context.extend(dfs(r,c))\n    return list(set(context))\n\ndef extract_region_with_context(grid, green_obj):\n    \"\"\"Extracts region including context\"\"\"\n    min_row, max_row, min_col, max_col = green_obj['bounding_box']\n\n    white_context = get_surrounding_context(grid, green_obj, 0)\n    if not white_context:\n        # No white context, return only the green region, expanded to include.\n      \n        coords = green_obj['coords']\n        rows, cols = zip(*coords)\n        min_row, max_row = min(rows), max(rows)\n        min_col, max_col = min(cols), max(cols)\n      \n        return grid[min_row:max_row+1, min_col:max_col+1], 3 #green background\n\n    red_context = get_surrounding_context(grid, {'coords': white_context, 'bounding_box': bounding_box(white_context)}, 2)\n\n    if not red_context: #white but no red\n        #expand to white\n        all_coords = green_obj['coords'] + white_context\n        rows, cols = zip(*all_coords)\n        min_row, max_row = min(rows), max(rows)\n        min_col, max_col = min(cols), max(cols)\n        return grid[min_row:max_row+1, min_col:max_col+1], 0 #white background\n    else: #white and red context\n        all_coords = green_obj['coords'] + white_context + red_context\n        rows, cols = zip(*all_coords)\n        min_row, max_row = min(rows), max(rows)\n        min_col, max_col = min(cols), max(cols)\n        return grid[min_row:max_row + 1, min_col:max_col+1], 2 #red background\n\ndef bounding_box(coords):\n    \"\"\"calculate bounding box from coords\"\"\"\n    rows, cols = zip(*coords)\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    return (min_row, max_row, min_col, max_col)\n\ndef pad_to_square(grid, fill_color):\n    \"\"\"Pads a region to a square, filling with the background\"\"\"\n    height, width = grid.shape\n    side = max(height, width)\n    padded_grid = np.full((side, side), fill_color, dtype=grid.dtype)\n    row_offset = (side - height) // 2\n    col_offset = (side - width) // 2\n    padded_grid[row_offset:row_offset + height, col_offset:col_offset + width] = grid\n    return padded_grid\n\ndef transform(input_grid):\n    # Convert to numpy array\n    input_grid = np.array(input_grid)\n\n    # Find green objects.\n    green_objects = find_object_with_context(input_grid, 3)\n\n    # Handle no green objects\n    if not green_objects:\n        return [[]]\n        \n    # Extract and process.\n    extracted_grids = []\n    backgrounds = []\n    for obj in green_objects:\n        extracted_region, background = extract_region_with_context(input_grid, obj)\n        extracted_grids.append(extracted_region)\n        backgrounds.append(background)\n\n\n    if len(extracted_grids) > 0:\n        output_grid = pad_to_square(extracted_grids[0], backgrounds[0])\n    else:\n        return [[]] #nothing green\n    \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7258,
    "candidates_token_count": 1849,
    "total_token_count": 9107,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 15.627041,
  "response_file": "014-response.json"
}