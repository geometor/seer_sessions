{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify objects in the grid. If the object is an \"L\" shape, rotate the \"L\" shape 90 degrees clockwise. If the object is a diagonal, do nothing.\n\"\"\"\n\nimport numpy as np\n\ndef get_objects(grid):\n    \"\"\"\n    Extracts non-zero objects from the grid.\n    Returns a list of objects, where each object is a tuple of (coordinates, color).\n    \"\"\"\n    objects = []\n    visited = set()\n    rows, cols = len(grid), len(grid[0])\n\n    def dfs(r, c, current_object, color):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != color:\n            return\n        visited.add((r, c))\n        current_object.append((r, c))\n        dfs(r + 1, c, current_object, color)\n        dfs(r - 1, c, current_object, color)\n        dfs(r, c + 1, current_object, color)\n        dfs(r, c - 1, current_object, color)\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                current_object = []\n                color = grid[r][c]\n                dfs(r, c, current_object, color)\n                objects.append((current_object, color))\n    return objects\n\ndef rotate_point_around_center(point, rows, cols):\n    \"\"\"Rotates a point 90 degrees clockwise around the center of the grid.\"\"\"\n    r, c = point\n    center_r = (rows - 1) / 2.0\n    center_c = (cols - 1) / 2.0\n    new_r = c - center_c + center_r\n    new_c = -(r - center_r) + center_c\n    return int(round(new_r)), int(round(new_c))\n\ndef is_L_shape(coords, rows, cols):\n    \"\"\"Checks if the coordinates form an L shape (regular or mirrored).\"\"\"\n    if len(coords) != 3:\n        return False\n\n    coords_np = np.array(coords)\n    diffs = np.diff(coords_np, axis=0)\n\n    if len(diffs) < 2:\n      return False\n    \n    if (diffs[0][0] == 0 or diffs[0][1] == 0) and (diffs[1][0] == 0 or diffs[1][1] == 0) :\n        if (diffs[0][0] == 0 and diffs[1][1] == 0) or (diffs[0][1] == 0 and diffs[1][0] == 0):\n           return True\n\n    return False\n\ndef classify_l_shape(coords, rows, cols):\n    \"\"\"\n    Classifies the orientation of an L-shape.\n    Returns a string representing the orientation.\n    \"\"\"\n    if not is_L_shape(coords, rows, cols):\n        return \"not_l\"\n\n    # Find the \"corner\" of the L\n    corner = None\n    for i in range(len(coords)):\n        count = 0\n        for j in range(len(coords)):\n            if i != j:\n                if abs(coords[i][0] - coords[j][0]) + abs(coords[i][1] - coords[j][1]) == 1:\n                    count += 1\n        if count == 2:\n            corner = coords[i]\n            break\n\n    # Find the two points that are not the corner\n    other_points = [p for p in coords if p != corner]\n\n    # Determine the orientation based on the relative positions of the other points\n    if other_points[0][0] == other_points[1][0]:  # Vertical leg\n        if other_points[0][1] < corner[1]:\n            if other_points[0][0] < corner[0]:\n                return \"upright\" # upright\n            else:\n                return \"rotated_180\"\n        else: # other_points[0][1] > corner[1]:\n            if other_points[0][0] < corner[0]:\n                return \"rotated_270\"  # L\n            else:\n                return \"mirrored_horizontal\"\n\n    elif other_points[0][1] == other_points[1][1]:  # Horizontal leg\n        if other_points[0][0] < corner[0]:\n            if other_points[0][1] < corner[1]:\n                return \"rotated_90\"\n            else:\n                return \"mirrored_vertical\"\n        else:\n            if other_points[0][1] < corner[1]:\n                return \"mirrored_270\"\n            else:\n                return \"mirrored_180\" # mirrored and rotated\n            \n    return \"unknown\"  # Should not reach here for valid L-shapes\n\ndef rotate_l_shape(coords, rows, cols, l_type):\n    \"\"\"\n    Rotates an L-shape 90 degrees clockwise, taking into account its specific orientation.\n    \"\"\"\n\n    # helper maps for rotations\n    rotation_map = {\n        \"upright\": \"rotated_90\",\n        \"rotated_90\": \"rotated_180\",\n        \"rotated_180\": \"rotated_270\",\n        \"rotated_270\": \"upright\",\n        \"mirrored_horizontal\": \"mirrored_90\",\n        \"mirrored_90\": \"mirrored_180\",\n        \"mirrored_180\":\"mirrored_270\",\n        \"mirrored_270\": \"mirrored_horizontal\",\n        \"mirrored_vertical\": \"mirrored_270\",  # Adjust as needed\n        \"mirrored_270\": \"rotated_180\",     # Adjust as needed\n    }\n    \n    new_l_type = rotation_map[l_type]\n\n    if new_l_type == \"upright\":\n      # find top left and build from there\n      min_r = min(c[0] for c in coords)\n      min_c = min(c[1] for c in coords)\n      return [(min_r,min_c), (min_r+1, min_c), (min_r+2, min_c), (min_r+2, min_c+1)]\n    elif new_l_type == \"rotated_90\":\n      min_r = min(c[0] for c in coords)\n      min_c = min(c[1] for c in coords)\n      return [(min_r, min_c), (min_r, min_c+1), (min_r, min_c+2), (min_r-1,min_c+2)]\n    elif new_l_type == \"rotated_180\":\n        min_r = min(c[0] for c in coords)\n        min_c = min(c[1] for c in coords)\n        # find the top-right\n        return [(min_r+2, min_c+1), (min_r, min_c+1), (min_r+1, min_c+1), (min_r, min_c)]\n    elif new_l_type == \"rotated_270\":\n      # find bottom-right, and build\n      max_r = max(c[0] for c in coords)\n      max_c = max(c[1] for c in coords)\n      return [(max_r, max_c), (max_r, max_c-1), (max_r, max_c-2), (max_r+1, max_c-2)]\n    elif new_l_type == \"mirrored_horizontal\":\n        min_r = min(c[0] for c in coords)\n        max_c = max(c[1] for c in coords)\n        return [(min_r, max_c), (min_r+1, max_c), (min_r+2, max_c), (min_r+2, max_c-1)]\n    elif new_l_type == \"mirrored_90\":\n        min_r = min(c[0] for c in coords)\n        max_c = max(c[1] for c in coords)\n        return [(min_r, max_c), (min_r-1, max_c), (min_r-2, max_c), (min_r - 2, max_c-1)]\n    elif new_l_type == \"mirrored_180\":\n        min_r = min(c[0] for c in coords)\n        min_c = min(c[1] for c in coords)\n        return [(min_r,min_c), (min_r+1, min_c), (min_r+2, min_c), (min_r,min_c+1)] # check\n    elif new_l_type == \"mirrored_270\":\n        max_r = max(c[0] for c in coords)\n        min_c = min(c[1] for c in coords)\n        return [(max_r,min_c), (max_r-1, min_c), (max_r - 2, min_c), (max_r-2, min_c+1)]\n    elif new_l_type == \"mirrored_vertical\":\n        max_r = max(c[0] for c in coords)\n        max_c = max(c[1] for c in coords)\n        return [(max_r, max_c), (max_r, max_c -1), (max_r, max_c - 2), (max_r-1, max_c-2)]\n\n    # return original if not mapped\n    return coords\n\ndef is_diagonal(coords, rows, cols):\n    \"\"\"Checks if the coordinates form a diagonal and returns its type (\"main\" or \"anti\").\"\"\"\n    if len(coords) != rows:\n      return False\n\n    coords_set = set(coords)\n\n    # Check for main diagonal\n    is_main_diagonal = all((i, i) in coords_set for i in range(rows))\n    if is_main_diagonal:\n        return \"main\"\n\n    # check for anti diagonal\n    is_anti_diagonal = all((i, cols - 1 - i) in coords_set for i in range(rows))\n    if is_anti_diagonal:\n        return \"anti\"\n\n    return False\n\ndef transform(input_grid):\n    # Convert the input list of lists to a NumPy array.\n    input_np = np.array(input_grid)\n    rows, cols = input_np.shape\n\n    # Get objects\n    objects = get_objects(input_np)\n\n    # initialize output grid\n    output_np = np.zeros_like(input_np)\n\n    for coords, color in objects:\n        if is_L_shape(coords, rows, cols):\n            # Classify and rotate L shape\n            l_type = classify_l_shape(coords, rows, cols)\n            new_coords = rotate_l_shape(coords, rows, cols, l_type)\n            for r, c in new_coords:\n                if 0 <= r < rows and 0 <= c < cols:\n                    output_np[r, c] = color\n        elif is_diagonal(coords, rows, cols):\n          # diagonals don't change\n            for r, c in coords:\n              output_np[r,c] = color\n        else:\n          # everything else stays put\n          for r, c in coords:\n            output_np[r,c] = color\n\n    # Convert the NumPy array back to a list of lists.\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3852,
    "candidates_token_count": 2820,
    "total_token_count": 6672,
    "cached_content_token_count": 0
  },
  "response_time": 22.567237,
  "response_file": "018-response.json"
}