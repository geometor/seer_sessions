"""
The output grid has the same dimensions as the input grid. The output grid uses
only azure (8) and blue (1) pixels. The output is generated by alternating runs
of azure and blue pixels, both horizontally and vertically. The lengths of these
runs follow a repeating, but yet-to-be-determined sequence that appears to apply
independently to rows and columns. It's hypothesized that the run length sequence
may be '1, 3, 2, 2, 3, 1', and the start of the sequence may shift by the row/column
index.
"""

import numpy as np

def transform(input_grid):
    # Initialize output grid with the same dimensions as the input grid.
    rows = len(input_grid)
    cols = len(input_grid[0])
    output_grid = np.zeros((rows, cols), dtype=int)

    # Run-length sequence (hypothesis).
    run_lengths = [3, 1, 2]  # Simplified pattern from observation
    run_len_idx = 0
    
    # Iterate through rows and columns.
    for i in range(rows):
        run_len_idx = i % len(run_lengths) # shift the starting point
        color = 8  # Start with azure (8).
        col_idx = 0
        
        while col_idx < cols:
            run_len = run_lengths[run_len_idx % len(run_lengths)] # use the run length
            
            for k in range(run_len):
                if col_idx + k < cols:
                  output_grid[i, col_idx + k] = color
            
            col_idx += run_len
            color = 1 if color == 8 else 8  # Switch color.
            run_len_idx+=1 # go to next run length

    return output_grid