{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1.  **Identify Objects:** Identify all distinct objects in the input grid. An object is a contiguous group of pixels of the same color.\n2.  **Preserve Diagonal:** If there is a gray (5) object in a diagonal line starting from the top-left, maintain its starting position.\n3.  **Move Color Objects:** If there is azure (8) object, place to row 0. Place its leftmost pixel at column index 2. If there is red (2) object, place it to the right of azure object, on the same row.\n4.  **Move Magenta:** If there is magenta (6) object, stack all pixels on top row starting from column index 2.\n5. **Gray Fills:** If gray object is present and is split, the lowest and rightmost pixel of the object, will move to the left, staying on its row, occupying next empty cell, only if no same color pixel is present.\n6.  **Fill Gaps:** Other color (0/white) objects fill empty spaces left by the movement of the objects above.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Identifies distinct objects in the grid.\"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    rows, cols = grid.shape\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def dfs(r, c, color, current_object):\n        if not is_valid(r, c) or visited[r, c] or grid[r, c] != color:\n            return\n        visited[r, c] = True\n        current_object.append((r, c))\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(r + dr, c + dc, color, current_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c]:\n                current_object = []\n                dfs(r, c, grid[r, c], current_object)\n                objects.append((grid[r, c], current_object))\n    return objects\n\ndef move_object(grid, object_pixels, target_row, target_col_start):\n    \"\"\"Moves an object to a new location within the grid, filling with 0\"\"\"\n    new_grid = np.copy(grid)\n\n    # Clear old positions, filling with 0\n    for r, c in object_pixels:\n        new_grid[r, c] = 0\n\n    # Compute and set new positions\n    min_col = min([c for _, c in object_pixels])\n    for r, c in object_pixels:\n        new_col = target_col_start + (c - min_col)\n        if 0 <= target_row < new_grid.shape[0] and 0 <= new_col < new_grid.shape[1]:\n          new_grid[target_row, new_col] = grid[r, c]\n\n    return new_grid\n\ndef move_object_stack(grid, object_pixels, target_row, target_col_start):\n    \"\"\"Moves and stacks object's pixel to target location\"\"\"\n\n    new_grid = np.copy(grid)\n\n    #clear old positions\n    for r, c in object_pixels:\n        new_grid[r,c] = 0\n\n    for i, (r,c) in enumerate(object_pixels):\n       if 0 <= target_row < new_grid.shape[0] and 0 <= target_col_start + i < new_grid.shape[1]:\n            new_grid[target_row, target_col_start + i] = grid[r,c]\n\n    return new_grid\n\ndef move_gray_left(grid, object_pixels):\n    \"\"\"Moves the lowest, rightmost pixel of a gray object to the left.\"\"\"\n    new_grid = np.copy(grid)\n\n    if not object_pixels:\n        return new_grid\n\n    # Find lowest, rightmost pixel\n    lowest_row = -1\n    rightmost_col = -1\n    for r, c in object_pixels:\n        if r > lowest_row:\n            lowest_row = r\n            rightmost_col = c\n        elif r == lowest_row and c > rightmost_col:\n            rightmost_col = c\n\n    # Check for an empty cell to the left\n    if rightmost_col > 0 and new_grid[lowest_row, rightmost_col - 1] == 0:\n        new_grid[lowest_row, rightmost_col] = 0\n        new_grid[lowest_row, rightmost_col - 1] = 5\n\n    return new_grid\n\n\ndef fill_gaps(grid, objects):\n    \"\"\"Fills gaps in the grid with pixels from object 0 (white).\"\"\"\n    rows, cols = grid.shape\n    new_grid = np.copy(grid)\n\n    # Create a set of occupied positions\n    occupied = set()\n    for r in range(rows):\n        for c in range(cols):\n            if new_grid[r,c] != 0:\n                occupied.add((r,c))\n\n\n    white_object = None\n    for color, pixels in objects:\n      if color == 0:\n        white_object = pixels\n        break\n\n    if white_object is None:\n      return new_grid\n    \n    white_pixels_available = list(white_object)\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in occupied and white_pixels_available:\n                # Find the closest white pixel and swap\n              \n                new_r, new_c = white_pixels_available.pop(0)  #remove first\n                new_grid[r,c] = new_grid[new_r,new_c] #move\n                new_grid[new_r, new_c] = 0 #clear\n\n    return new_grid\n\ndef transform(input_grid):\n    # initialize output_grid\n    output_grid = np.zeros_like(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Objects\n    objects = find_objects(input_grid)\n\n    #2. Preserve Diagonal Gray\n    gray_diagonal = []\n    for color, pixels in objects:\n        if color == 5:  # Gray\n            is_diagonal = True\n            for i in range(min(rows,cols)):\n               if (i,i) not in pixels:\n                  is_diagonal = False\n                  break\n\n            if is_diagonal:\n                for r,c in pixels:\n                  output_grid[r,c] = 5\n            else:\n               gray_diagonal = pixels #not diagonal from top left\n    \n\n    # 3. Move Azure and Red Objects\n    azure_object = None\n    red_object = None\n    for color, pixels in objects:\n        if color == 8:\n            azure_object = pixels\n        elif color == 2:\n            red_object = pixels\n\n    if azure_object is not None:\n        output_grid = move_object(output_grid, azure_object, 0, 2)\n    if red_object is not None:\n        if azure_object is not None:\n            max_azure_col = -1\n            for r,c in azure_object:\n               if c > max_azure_col:\n                  max_azure_col = c\n            if max_azure_col > -1:\n              output_grid = move_object(output_grid, red_object, 0, max_azure_col + 1)\n        else:\n            output_grid = move_object(output_grid, red_object, 0, 2)\n\n\n    # 4. Move Magenta Objects\n    magenta_object = None\n    for color, pixels in objects:\n       if color == 6:\n          magenta_object = pixels\n          break\n\n    if magenta_object is not None:\n       output_grid = move_object_stack(output_grid, magenta_object, 0, 2)\n\n\n    #5. Gray Filling\n    if len(gray_diagonal) > 0:\n      output_grid = move_gray_left(output_grid, gray_diagonal)\n\n    # 6. Fill gaps\n    updated_objects = find_objects(output_grid)\n    output_grid = fill_gaps(output_grid, updated_objects)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7021,
    "candidates_token_count": 1991,
    "total_token_count": 9012,
    "cached_content_token_count": 0
  },
  "response_time": 18.214447,
  "response_file": "018-response.json"
}