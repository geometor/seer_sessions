{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by repositioning and replicating specific color patterns.  The \"L\" shaped azure pattern with an enclosed red pixel is moved, and the blue-green stacked pairs are replicated. The isolated red pixel is also repositioned.\n\"\"\"\n\nimport numpy as np\n\ndef find_objects(grid):\n    \"\"\"Finds and groups contiguous non-zero pixels.\"\"\"\n    objects = []\n    visited = set()\n    rows, cols = grid.shape\n\n    def dfs(r, c, color, obj):\n        if (r, c) in visited or r < 0 or r >= rows or c < 0 or c >= cols or grid[r, c] != color:\n            return\n        visited.add((r, c))\n        obj.append((r, c))\n        dfs(r + 1, c, color, obj)\n        dfs(r - 1, c, color, obj)\n        dfs(r, c + 1, color, obj)\n        dfs(r, c - 1, color, obj)\n        dfs(r+1,c+1,color,obj) # diagonal\n        dfs(r-1,c-1,color,obj) # diagonal\n        dfs(r-1,c+1,color,obj) # diagonal\n        dfs(r+1,c-1,color,obj) # diagonal\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                obj = []\n                dfs(r, c, grid[r, c], obj)\n                objects.append((grid[r,c], obj)) # (color, list of positions)\n    return objects\n\ndef find_l_shape(objects):\n    \"\"\"find l shape\"\"\"\n    for color, positions in objects:\n        if color == 8: # azure\n            rows = [pos[0] for pos in positions]\n            cols = [pos[1] for pos in positions]\n            if len(positions) == 3:\n                min_col = min(cols)\n                max_col = max(cols)\n                min_row = min(rows)\n                max_row = max(rows)\n                \n                if max_col - min_col == 1 and max_row - min_row == 1:\n                    #this is for detecting the 2x2 azure\n                    return (color,positions)\n\n                \n                \n                if (max_col - min_col == 2 and rows.count(min(rows)) == 1) or \\\n                   (max_row - min_row == 2 and cols.count(min(cols)) == 1):\n                      return (color, positions)\n    return (None, []) # return empty\n\ndef find_enclosed_red(objects, l_positions):\n    \"\"\"Finds the red pixel enclosed by the L-shape.\"\"\"\n\n    if not l_positions:\n        return (None,None) # early exit\n\n    l_rows = [pos[0] for pos in l_positions]\n    l_cols = [pos[1] for pos in l_positions]\n    for color, positions in objects:\n      if color == 2: # check if its the red pixel\n        for r,c in positions:\n          if min(l_rows) <= r <= max(l_rows) and min(l_cols) <= c <= max(l_cols):\n            return (color, (r,c)) # color value and coordinate\n\n    return (None,None)\n\ndef find_blue_green_pairs(objects):\n    \"\"\"find blue green stack\"\"\"\n    pairs = []\n    for color, positions in objects:\n        if color == 1:  # Blue\n            for r, c in positions:\n                if (r + 1, c) in [pos for _, pos_list in objects for pos in pos_list] and \\\n                   any(grid[r+1,c] == 3 for grid_color, pos_list in objects for pos in pos_list if (r+1,c) in pos_list and grid_color == 3):\n                    pairs.append(((r, c), (r + 1, c)))  # (blue_pos, green_pos)\n    return pairs\n\ndef find_isolated_red(objects):\n  \"\"\"Find the isloated red pixel\"\"\"\n  for color, positions in objects:\n    if color == 2 and len(positions) == 1:\n      return (color,positions[0])\n\ndef transform(input_grid):\n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_grid)\n\n    # Find objects in the input grid\n    objects = find_objects(input_grid)\n\n    # Find the L-shaped azure object\n    l_color, l_positions = find_l_shape(objects)\n\n    # Find the enclosed red pixel within the L-shape\n    enclosed_red_color, enclosed_red_position = find_enclosed_red(objects, l_positions)\n    \n    # Find blue-green pairs\n    blue_green_pairs = find_blue_green_pairs(objects)\n\n    # Find the isolated red\n    isolated_red_color, isolated_red_pos = find_isolated_red(objects)\n\n    # --- Transformation Logic ---\n\n    # 1. Replicate and move the L-shape and enclosed red\n    if l_positions and enclosed_red_position:\n      # original position\n      for r,c in l_positions:\n          output_grid[r,c] = 8\n      output_grid[enclosed_red_position] = 2\n\n      # new l shape position - shifted\n      new_l_positions = []\n      dr = enclosed_red_position[0] - min([pos[0] for pos in l_positions]) # shift down\n      dc = min([pos[1] for pos in l_positions]) - enclosed_red_position[1]    # shift left\n      for r, c in l_positions:\n          new_r = r + dr\n          new_c = c - dc - 1 #additional offset needed\n          if 0 <= new_r < output_grid.shape[0] and 0 <= new_c < output_grid.shape[1]:\n              output_grid[new_r, new_c] = 8\n              new_l_positions.append((new_r,new_c))\n\n      # new enclosed position\n      new_red_r = enclosed_red_position[0] + dr\n      new_red_c = enclosed_red_position[1] - dc - 1\n      if 0 <= new_red_r < output_grid.shape[0] and 0 <= new_red_c < output_grid.shape[1]:\n        output_grid[new_red_r,new_red_c] = 2\n        \n\n    # 2. Transform and replicate blue-green stacks\n\n    for (blue_r, blue_c), (green_r, green_c) in blue_green_pairs:\n        # original\n        output_grid[blue_r, blue_c] = 1\n        output_grid[green_r, green_c] = 3\n\n        # Shifted down\n        new_blue_r = blue_r + 2\n        new_green_r = green_r + 2\n        if new_blue_r < output_grid.shape[0] and new_green_r < output_grid.shape[0]:\n          output_grid[new_blue_r, new_blue_c] = 1\n          output_grid[new_green_r,new_green_c] = 3\n\n    # 3. reposition isolate red pixel\n    if isolated_red_color:\n      #shift to left\n      new_isolated_red_r = isolated_red_pos[0]\n      new_isolated_red_c = isolated_red_pos[1] -2\n      if 0 <= new_isolated_red_c < output_grid.shape[1]:\n          output_grid[new_isolated_red_r,new_isolated_red_c] = 2\n      \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3295,
    "candidates_token_count": 1890,
    "total_token_count": 5185,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.0-pro-exp-02-05",
  "response_time": 21.746029,
  "response_file": "016-response.json"
}