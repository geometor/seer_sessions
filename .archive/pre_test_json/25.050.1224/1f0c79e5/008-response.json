{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule can be summarized as follows:\n\n1. Identify single-cell objects (any color).\n2. Identify L-shaped objects (any color, 3 contiguous pixels forming an \"L\").\n3. If an L-shape and a single cell of different colors coexist:\n   - Remove the L-shaped object.\n   - Expand the single-cell object into a partial tilted 5x5 square.\n4. The expansion direction of the square depends on relative position between single-cell and the \"corner\" of the L-shape:\n      * cell has row major than corner row and col major than corner col: expand down-right, top-left 3x3 sub-square is missing.\n      * cell has row major than corner row and col minor than corner col: expand down-left, top-right 3x3 sub-square is missing.\n      * cell has row minor than corner row and col major than corner col: expand up-right, bottom-left 3x3 sub-square is missing.\n      * cell has row minor than corner row and col minor than corner col: expand up-left, bottom-right 3x3 sub-square is missing.\n    If the single-cell has same row or same col of corner, we assume same expansion direction of cases where row or col are major.\n\"\"\"\n\nimport numpy as np\n\ndef find_object(grid, color):\n    \"\"\"Finds coordinates of cells with a specific color.\"\"\"\n    coords = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r,c] == color:\n                coords.append((r, c))\n    return coords\n\ndef detect_l_shape(coords):\n    \"\"\"Detects if the given coordinates form an L-shape and determines its orientation.\"\"\"\n    if len(coords) != 3:\n        return None  # Not an L-shape\n\n    # sorting coords to handle different input L orders\n    coords = sorted(coords, key=lambda x: (x[0],x[1]))\n    coords = np.array(coords)\n    diffs = np.diff(coords, axis=0)\n    if (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, 1])) or \\\n        (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [1, 0])) :\n      # case 1:  _|_\n      return 'down_right', coords[0]\n    elif (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [-1, 0])) or \\\n      (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, 1])) :\n      # case 2:   _|\n      return 'down_left', coords[0] if (np.all(diffs[0] == [-1, 0])) else coords[2]\n    elif (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [-1, 0])) or \\\n      (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, -1])) :\n      # case 3: |_\n      return 'up_left',  coords[0] if (np.all(diffs[0] == [-1, 0])) else coords[2]\n    elif (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, -1])) or \\\n        (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [1, 0])) :\n      # case 4:  -|\n      return 'up_right', coords[0]\n\n    return None\n\ndef get_expansion_direction(l_corner, cell_coord):\n    \"\"\"Determines the expansion direction based on L-shape corner and single cell position.\"\"\"\n    row_c, col_c = l_corner\n    row_s, col_s = cell_coord\n    \n    # Determine expansion direction\n    if row_s > row_c and col_s > col_c:\n      return 'down_right'\n    elif row_s > row_c and col_s < col_c:\n      return 'down_left'\n    elif row_s < row_c and col_s > col_c:\n      return 'up_right'\n    elif row_s < row_c and col_s < col_c:\n      return 'up_left'\n    else:\n      # same row or col\n      if row_s == row_c:\n        if col_s > col_c: return 'down_right' # same row, col maj\n        else: return 'up_left' # same row, col min\n      else:\n        if row_s > row_c: return 'down_right' # col is the same, row maj\n        else: return 'up_left' # col is the same, row min\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the final rule.\"\"\"\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Identify Objects and their properties\n    single_cells = []\n    l_shapes = []\n    for color in range(10):\n      coords = find_object(input_grid, color)\n      \n      # Single cell\n      if len(coords) == 1:\n        single_cells.append((color,coords[0]))\n      \n      # L shape\n      l_shape = detect_l_shape(coords)\n      if l_shape is not None:\n        l_shapes.append((color, l_shape))\n\n    # 2 & 3. Expand Single cell based on L position and remove L\n    for color_cell, cell in single_cells:\n        for color_l, l_shape in l_shapes:\n            if color_cell != color_l:\n              orientation, corner = l_shape\n              expansion_dir = get_expansion_direction(corner, cell)\n              start_row, start_col = cell\n\n              if expansion_dir == 'down_right':\n                  for i in range(5):\n                      for j in range(5):\n                          row = start_row + i - j\n                          col = start_col + i + j - 1\n                          if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i < 3 and j < 3):\n                              output_grid[row, col] = color_cell\n\n              elif expansion_dir == 'down_left':\n                  for i in range(5):\n                      for j in range(5):\n                          row = start_row + i + j -3\n                          col = start_col - i + j -1\n                          if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i >= 2 and j < 3):\n                              output_grid[row, col] = color_cell\n              \n              elif expansion_dir == 'up_right':\n                  for i in range(5):\n                      for j in range(5):\n                          row = start_row - i - j + 1\n                          col = start_col + i - j - 1\n                          if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i < 3 and j >= 2):\n                              output_grid[row, col] = color_cell\n\n              elif expansion_dir == 'up_left':\n                  for i in range(5):\n                      for j in range(5):\n                          row = start_row - 4 + i + j\n                          col = start_col + 4 - i - 3 + j\n                          if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i >= 2 and j >= 2):\n                              output_grid[row, col] = color_cell\n\n    return output_grid\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15533,
    "candidates_token_count": 1936,
    "total_token_count": 17469,
    "cached_content_token_count": 0
  },
  "timing": {
    "response_time": 16.62396
  },
  "response_file": "008-response.json"
}