{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule can be summarized as follows:\n\n1. Identify the L-shaped object (any color).\n2. Identify the single red objects.\n3. Remove the red cells.\n4. Expand the L-shaped object into a tilted 5x5 square:\n   - Determine the \"corner\" of the L-shape.\n   - Based on relative position of the red cells, expand as follow:\n    - If the red cells are placed to have both a cell with same row of a pixel of the L and a cell with same col of a pixel of the L, the L expands into a tilted, partial 5x5 square as follow:\n      * red cells contains a cell with row major than corner row and col major than corner col: expand down-right, top-left 3x3 sub-square is missing.\n      * red cells contains a cell with row major than corner row and col minor than corner col: expand down-left, top-right 3x3 sub-square is missing.\n      * red cells contains a cell with row minor than corner row and col major than corner col: expand up-right, bottom-left 3x3 sub-square is missing.\n      * red cells contains a cell with row minor than corner row and col minor than corner col: expand up-left, bottom-right 3x3 sub-square is missing.\n\n\"\"\"\n\nimport numpy as np\n\ndef find_object(grid, color):\n    \"\"\"Finds coordinates of cells with a specific color.\"\"\"\n    coords = []\n    for r in range(grid.shape[0]):\n        for c in range(grid.shape[1]):\n            if grid[r,c] == color:\n                coords.append((r, c))\n    return coords\n\ndef detect_l_shape(coords):\n    \"\"\"Detects if the given coordinates form an L-shape and determines its orientation.\"\"\"\n    if len(coords) != 3:\n        return None  # Not an L-shape\n\n    # Convert to numpy array for easier calculations\n    coords = np.array(coords)\n\n    # Calculate differences between coordinates\n    diffs = np.diff(coords, axis=0)\n\n    # Check if it's an L-shape\n    if (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [1, 0])) or \\\n       (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, 1])) :\n      # case 1:  _|_  \n      return 'down_right', coords[0]\n    elif (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [-1, 0])) or \\\n       (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, 1])) :\n      # case 2:   _|\n      return 'down_left',  coords[0] if  (np.all(diffs[0] == [0, 1])) else coords[1]\n    elif (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [-1, 0])) or \\\n       (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, -1])) :\n       # case 3: |_\n       return 'up_left', coords[0] if  (np.all(diffs[0] == [0, -1])) else coords[1]\n    elif (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [1, 0])) or \\\n       (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, -1])) :\n       # case 4:  -|\n       return 'up_right',  coords[1] if  (np.all(diffs[0] == [1, 0])) else coords[0]\n    else:\n      # sorting coords to handle different input L orders\n      coords = sorted(coords, key=lambda x: (x[0],x[1]))\n      coords = np.array(coords)\n      diffs = np.diff(coords, axis=0)\n      if (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, 1])) or \\\n         (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [1, 0])) :\n        # case 1:  _|_\n        return 'down_right', coords[0]\n      elif (np.all(diffs[0] == [0, 1]) and np.all(diffs[1] == [-1, 0])) or \\\n        (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, 1])) :\n        # case 2:   _|\n        return 'down_left', coords[0] if (np.all(diffs[0] == [-1, 0])) else coords[2]\n      elif (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [-1, 0])) or \\\n        (np.all(diffs[0] == [-1, 0]) and np.all(diffs[1] == [0, -1])) :\n        # case 3: |_\n        return 'up_left',  coords[0] if (np.all(diffs[0] == [-1, 0])) else coords[2]\n      elif (np.all(diffs[0] == [1, 0]) and np.all(diffs[1] == [0, -1])) or \\\n         (np.all(diffs[0] == [0, -1]) and np.all(diffs[1] == [1, 0])) :\n        # case 4:  -|\n        return 'up_right', coords[0]\n\n    return None\n\ndef get_expansion_direction(l_corner, red_coords):\n    \"\"\"Determines the expansion direction based on L-shape corner and red cells positions.\"\"\"\n    row_c, col_c = l_corner\n    \n    # Check existence and relative position of red cells\n    row_major = False\n    row_minor = False\n    col_major = False\n    col_minor = False\n    for r_coord in red_coords:\n      row_r, col_r = r_coord\n      row_major = row_major or row_r > row_c\n      row_minor = row_minor or row_r < row_c\n      col_major = col_major or col_r > col_c\n      col_minor = col_minor or col_r < col_c\n    \n    # Determine expansion direction\n    if row_major and col_major:\n      return 'down_right'\n    elif row_major and col_minor:\n      return 'down_left'\n    elif row_minor and col_major:\n      return 'up_right'\n    elif row_minor and col_minor:\n      return 'up_left'\n    else: return None\n\ndef transform(input_grid):\n    \"\"\"Transforms the input grid according to the final rule.\"\"\"\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Identify Objects and their properties\n    l_colors = []\n    for color in range(10):  # Check all possible colors\n        l_coords = find_object(input_grid, color)\n        l_shape = detect_l_shape(l_coords)\n        if l_shape is not None:\n            l_colors.append((color, l_shape))\n\n    red_coords = find_object(input_grid, 2)\n\n    # 2 & 3. Expand L-shape based on red position and remove red\n    for color, l_shape in l_colors:\n        orientation, corner = l_shape\n        expansion_dir = get_expansion_direction(corner, red_coords)\n        start_row, start_col = corner\n\n        if expansion_dir == 'down_right':\n            for i in range(5):\n                for j in range(5):\n                    row = start_row + i - j\n                    col = start_col + i + j - 1\n                    if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i < 3 and j < 3):\n                        output_grid[row, col] = color\n\n        elif expansion_dir == 'down_left':\n            for i in range(5):\n                for j in range(5):\n                    row = start_row + i + j -3\n                    col = start_col - i + j -1\n                    if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i >= 2 and j < 3):\n                        output_grid[row, col] = color\n        \n        elif expansion_dir == 'up_right':\n            for i in range(5):\n                for j in range(5):\n                    row = start_row - i - j + 1\n                    col = start_col + i - j - 1\n                    if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i < 3 and j >= 2):\n                        output_grid[row, col] = color\n\n        elif expansion_dir == 'up_left':\n            for i in range(5):\n                for j in range(5):\n                    row = start_row - 4 + i + j\n                    col = start_col + 4 - i - 3 + j\n                    if 0 <= row < output_grid.shape[0] and 0 <= col < output_grid.shape[1] and not(i >= 2 and j >= 2):\n                        output_grid[row, col] = color\n\n    return output_grid\n```\n"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9984,
    "candidates_token_count": 2402,
    "total_token_count": 12386,
    "cached_content_token_count": 0
  },
  "timing": {
    "response_time": 19.486978
  },
  "response_file": "006-response.json"
}