{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nProcesses a 2D grid (5x5 based on examples) containing three distinct non-zero structures:\n1. A horizontal segment: Contiguous non-zero cells in a single row.\n2. A vertical segment: Contiguous non-zero cells in a single column, all with the same value.\n3. An isolated cell: A single non-zero cell not part of the other two segments.\n\nThe transformation rules are:\n- Horizontal Segment: If it contains exactly two unique non-zero values (A, B), swap them (A becomes B, B becomes A). Otherwise, values remain unchanged.\n- Vertical Segment: All cells in this segment take the original value of the isolated cell.\n- Isolated Cell: This cell takes the original value of the vertical segment.\n- Zero cells remain zero.\n\"\"\"\n\ndef find_non_zero_cells(grid):\n    \"\"\"Finds all non-zero cells and returns their coordinates and values.\"\"\"\n    non_zero_coords = np.argwhere(grid > 0)\n    return [(r, c, grid[r, c]) for r, c in non_zero_coords]\n\ndef find_segments(non_zero_cells):\n    \"\"\"\n    Identifies the horizontal segment, vertical segment, and isolated cell\n    based on their structural properties from the list of non-zero cells.\n    \"\"\"\n    rows = Counter(r for r, c, v in non_zero_cells)\n    cols = Counter(c for r, c, v in non_zero_cells)\n\n    h_segment_coords = set()\n    h_segment_values = []\n    v_segment_coords = set()\n    v_segment_value = None\n    isolated_cell_coord = None\n    isolated_cell_value = None\n\n    # Identify potential horizontal segment row (most frequent row)\n    # Identify potential vertical segment column (most frequent col with uniform value potential)\n    \n    potential_h_row = max(rows, key=rows.get) if rows else -1\n    potential_v_col = -1\n    max_col_count = 0\n    \n    # Find potential vertical segment column more carefully, checking value uniformity\n    for c, count in cols.items():\n        if count > 1: # A vertical segment must have length > 1 based on examples\n            col_cells = [(r_v, c_v, v) for r_v, c_v, v in non_zero_cells if c_v == c]\n            if len(set(v for r_v, c_v, v in col_cells)) == 1: # Check for uniform value\n                 # Check for vertical contiguity\n                 rows_in_col = sorted([r_v for r_v, c_v, v in col_cells])\n                 is_contiguous = all(rows_in_col[i] == rows_in_col[0] + i for i in range(len(rows_in_col)))\n                 if is_contiguous and count > max_col_count:\n                     potential_v_col = c\n                     max_col_count = count\n\n    # Refine segment identification based on properties\n    temp_h_coords = set()\n    temp_v_coords = set()\n\n    # Build vertical segment first if found\n    if potential_v_col != -1:\n         col_cells = [(r_v, c_v, v) for r_v, c_v, v in non_zero_cells if c_v == potential_v_col]\n         # Verify again it's likely the vertical segment (uniform value, length > 1)\n         if len(col_cells) > 1 and len(set(v for _, _, v in col_cells)) == 1:\n             v_segment_coords = set((r_v, c_v) for r_v, c_v, v in col_cells)\n             v_segment_value = col_cells[0][2] # Get the uniform value\n\n    # Build horizontal segment\n    row_cells = [(r_h, c_h, v) for r_h, c_h, v in non_zero_cells if r_h == potential_h_row]\n     # Check for horizontal contiguity\n    if row_cells:\n        cols_in_row = sorted([c_h for r_h, c_h, v in row_cells])\n        is_contiguous = all(cols_in_row[i] == cols_in_row[0] + i for i in range(len(cols_in_row)))\n        if is_contiguous:\n             # Ensure these cells are not part of the identified vertical segment\n             potential_h_coords = set((r_h, c_h) for r_h, c_h, v in row_cells)\n             if not (potential_h_coords & v_segment_coords): # Check for overlap\n                h_segment_coords = potential_h_coords\n                h_segment_values = [v for r_h, c_h, v in row_cells]\n\n\n    # Find the isolated cell (the one not in H or V segments)\n    all_non_zero_coords = set((r, c) for r, c, v in non_zero_cells)\n    segment_coords = h_segment_coords.union(v_segment_coords)\n    isolated_coords = all_non_zero_coords - segment_coords\n\n    if len(isolated_coords) == 1:\n        iso_r, iso_c = isolated_coords.pop()\n        isolated_cell_coord = (iso_r, iso_c)\n        isolated_cell_value = [v for r, c, v in non_zero_cells if r == iso_r and c == iso_c][0]\n    else:\n        # This case shouldn't happen based on assumptions, but handle defensively\n        # Or raise an error if assumptions must hold strictly\n        print(f\"Warning: Expected 1 isolated cell, found {len(isolated_coords)}. Grid analysis might be incorrect.\")\n        # Attempt to find a single cell if others failed\n        if not h_segment_coords or not v_segment_coords:\n             potential_isolated = [ (r,c,v) for r,c,v in non_zero_cells if (r,c) not in h_segment_coords and (r,c) not in v_segment_coords]\n             if len(potential_isolated) == 1:\n                 iso_r, iso_c, iso_v = potential_isolated[0]\n                 isolated_cell_coord = (iso_r, iso_c)\n                 isolated_cell_value = iso_v\n                 # Need to re-evaluate h/v segments if they weren't fully ID'd before\n                 if not h_segment_coords:\n                    # Find the remaining group likely being horizontal\n                     remaining_coords = all_non_zero_coords - v_segment_coords - set([isolated_cell_coord])\n                     if remaining_coords:\n                         h_segment_coords = remaining_coords\n                         h_segment_values = [v for r, c, v in non_zero_cells if (r,c) in h_segment_coords]\n                 if not v_segment_coords:\n                    # Find the remaining group likely being vertical\n                     remaining_coords = all_non_zero_coords - h_segment_coords - set([isolated_cell_coord])\n                     if remaining_coords:\n                         vals = [v for r, c, v in non_zero_cells if (r,c) in remaining_coords]\n                         if len(set(vals)) == 1:\n                             v_segment_coords = remaining_coords\n                             v_segment_value = vals[0]\n\n\n    # Final check for robustness - ensure segments were found\n    if not h_segment_coords or not v_segment_coords or not isolated_cell_coord:\n         raise ValueError(\"Could not definitively identify all three required structures (horizontal, vertical, isolated).\")\n\n\n    return (list(h_segment_coords), h_segment_values,\n            list(v_segment_coords), v_segment_value,\n            isolated_cell_coord, isolated_cell_value)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    Identifies horizontal segment, vertical segment, and isolated cell.\n    Swaps values in horizontal segment if two unique values exist.\n    Sets vertical segment cells to the original isolated cell value.\n    Sets the isolated cell to the original vertical segment value.\n    \"\"\"\n    # Convert input to numpy array for easier handling\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid) # Start with a copy\n\n    # Find all non-zero cells\n    non_zero_cells = find_non_zero_cells(grid)\n    if not non_zero_cells:\n        return output_grid # Return original if grid is empty or all zeros\n\n    # Identify the three structures and their properties\n    try:\n        h_coords, h_values, v_coords, v_value_orig, iso_coord, iso_value_orig = find_segments(non_zero_cells)\n    except ValueError as e:\n        print(f\"Error during segment identification: {e}\")\n        # Decide how to handle error: return original, return empty, etc.\n        # For now, returning original grid seems safest if structure isn't as expected.\n        return grid # Or output_grid if you prefer the copy\n\n    # --- Apply transformations ---\n\n    # 1. Horizontal Segment Transformation\n    unique_h_values = sorted(list(set(h_values)))\n    h_value_map = {}\n    if len(unique_h_values) == 2:\n        # Swap values if exactly two unique values\n        val_a, val_b = unique_h_values\n        h_value_map[val_a] = val_b\n        h_value_map[val_b] = val_a\n    else:\n        # Otherwise, map values to themselves (no change)\n        for val in unique_h_values:\n            h_value_map[val] = val\n\n    # Apply map to horizontal segment cells in output grid\n    for r, c in h_coords:\n        original_val = grid[r, c]\n        if original_val in h_value_map: # Ensure value exists in map\n             output_grid[r, c] = h_value_map[original_val]\n        # else: # Should not happen if h_values are derived correctly\n        #    print(f\"Warning: Value {original_val} at {r,c} not in h_value_map\")\n\n\n    # 2. Vertical Segment Transformation\n    # Set all vertical segment cells to the original value of the isolated cell\n    for r, c in v_coords:\n        output_grid[r, c] = iso_value_orig\n\n    # 3. Isolated Cell Transformation\n    # Set the isolated cell to the original value of the vertical segment\n    iso_r, iso_c = iso_coord\n    output_grid[iso_r, iso_c] = v_value_orig\n\n    # 4. Zero cells remain zero (handled by starting with a copy)\n\n    # Convert back to list of lists if necessary, otherwise return numpy array\n    # return output_grid.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2038,
    "candidates_token_count": 2606,
    "total_token_count": 4644,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.981086,
  "retries": 1
}