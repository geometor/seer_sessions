{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nProcesses a 2D grid containing three distinct non-zero structures:\n1. A horizontal segment: Contiguous non-zero cells in a single row.\n2. A vertical segment: Contiguous non-zero cells in a single column, all with the same value.\n3. An isolated cell: A single non-zero cell not part of the other two segments.\n\nThe transformation rules are:\n- Horizontal Segment: If it contains exactly two unique non-zero values (A, B), swap them (A becomes B, B becomes A). Otherwise, values remain unchanged.\n- Vertical Segment: All cells in this segment take the original value of the isolated cell.\n- Isolated Cell: This cell takes the original value of the vertical segment.\n- Zero cells remain zero.\n\"\"\"\n\ndef find_non_zero_cells(grid):\n    \"\"\"Finds all non-zero cells and returns their coordinates and values.\"\"\"\n    # Use numpy's argwhere to efficiently find coordinates of non-zero elements\n    non_zero_coords = np.argwhere(grid > 0)\n    # Return a list of tuples: (row, column, value)\n    return [(r, c, grid[r, c]) for r, c in non_zero_coords]\n\ndef find_segments(non_zero_cells):\n    \"\"\"\n    Identifies the horizontal segment, vertical segment, and isolated cell\n    based on their structural properties from the list of non-zero cells.\n    This version uses frequency analysis and structural checks.\n    \"\"\"\n    # Count occurrences of each row and column index among non-zero cells\n    rows = Counter(r for r, c, v in non_zero_cells)\n    cols = Counter(c for r, c, v in non_zero_cells)\n\n    h_segment_coords = set()\n    h_segment_values = []\n    v_segment_coords = set()\n    v_segment_value = None\n    isolated_cell_coord = None\n    isolated_cell_value = None\n\n    # --- Identify Vertical Segment ---\n    # A vertical segment should have multiple cells in the same column with the same value.\n    potential_v_cols = {} # Store potential vertical columns: col_index -> (coords, value)\n    for c, count in cols.items():\n        if count > 1: # Segments usually have more than one cell\n            col_cells = [(r_v, c_v, v) for r_v, c_v, v in non_zero_cells if c_v == c]\n            col_values = set(v for _, _, v in col_cells)\n            # Check for uniform value\n            if len(col_values) == 1:\n                rows_in_col = sorted([r_v for r_v, _, _ in col_cells])\n                # Check for vertical contiguity\n                is_contiguous = all(rows_in_col[i] == rows_in_col[0] + i for i in range(len(rows_in_col)))\n                if is_contiguous:\n                    potential_v_cols[c] = (set((r_v, c_v) for r_v, c_v, v in col_cells), col_cells[0][2])\n\n    # Assume only one such structure exists per the problem description\n    if len(potential_v_cols) == 1:\n        v_col_index = list(potential_v_cols.keys())[0]\n        v_segment_coords, v_segment_value = potential_v_cols[v_col_index]\n    # Add handling if zero or multiple potential V segments found, maybe raise error or use longest?\n    elif len(potential_v_cols) > 1:\n         # If multiple, pick the longest one as the most likely candidate\n         longest_v_col = -1\n         max_len = 0\n         for c, (coords, val) in potential_v_cols.items():\n             if len(coords) > max_len:\n                 max_len = len(coords)\n                 longest_v_col = c\n         if longest_v_col != -1:\n             v_segment_coords, v_segment_value = potential_v_cols[longest_v_col]\n\n\n    # --- Identify Horizontal Segment ---\n    # A horizontal segment should have multiple cells in the same row.\n    potential_h_rows = {} # Store potential horizontal rows: row_index -> (coords, values)\n    for r, count in rows.items():\n         if count > 1:\n             row_cells = [(r_h, c_h, v) for r_h, c_h, v in non_zero_cells if r_h == r]\n             cols_in_row = sorted([c_h for _, c_h, _ in row_cells])\n             # Check for horizontal contiguity\n             is_contiguous = all(cols_in_row[i] == cols_in_row[0] + i for i in range(len(cols_in_row)))\n             if is_contiguous:\n                  potential_h_rows[r] = (set((r_h, c_h) for r_h, c_h, v in row_cells), [v for _, _, v in row_cells])\n\n    # Filter out any potential H segment that overlaps with the identified V segment\n    valid_h_rows = {}\n    for r, (coords, values) in potential_h_rows.items():\n        if not (coords & v_segment_coords): # Check for intersection\n             valid_h_rows[r] = (coords, values)\n\n    # Assume only one valid H segment remains\n    if len(valid_h_rows) == 1:\n         h_row_index = list(valid_h_rows.keys())[0]\n         h_segment_coords, h_segment_values = valid_h_rows[h_row_index]\n    # Add handling if zero or multiple potential H segments found\n    elif len(valid_h_rows) > 1:\n         # If multiple valid ones, maybe pick based on row frequency or length?\n         # Picking the one corresponding to the most frequent row index might be robust\n         most_frequent_r = max(rows, key=rows.get)\n         if most_frequent_r in valid_h_rows:\n              h_segment_coords, h_segment_values = valid_h_rows[most_frequent_r]\n         else: # Fallback: pick the longest non-overlapping one\n             longest_h_row = -1\n             max_len = 0\n             for r, (coords, vals) in valid_h_rows.items():\n                 if len(coords) > max_len:\n                     max_len = len(coords)\n                     longest_h_row = r\n             if longest_h_row != -1:\n                 h_segment_coords, h_segment_values = valid_h_rows[longest_h_row]\n\n\n    # --- Identify Isolated Cell ---\n    # The isolated cell is the non-zero cell not belonging to H or V segments.\n    all_non_zero_coords = set((r, c) for r, c, v in non_zero_cells)\n    segment_coords = h_segment_coords.union(v_segment_coords)\n    isolated_coords_set = all_non_zero_coords - segment_coords\n\n    if len(isolated_coords_set) == 1:\n        iso_r, iso_c = isolated_coords_set.pop()\n        isolated_cell_coord = (iso_r, iso_c)\n        # Find the value corresponding to the isolated coordinate\n        isolated_cell_value = [v for r, c, v in non_zero_cells if r == iso_r and c == iso_c][0]\n    # Add handling if zero or multiple isolated cells are found\n\n\n    # Final check: Ensure all three components were successfully identified\n    if not h_segment_coords or not v_segment_coords or not isolated_cell_coord:\n        # This indicates the input structure didn't match assumptions\n        # Log detailed info for debugging\n        # print(f\"DEBUG: Failed Identification! H={h_segment_coords}, V={v_segment_coords}, Iso={isolated_cell_coord}\")\n        # print(f\"Potential V Segments: {potential_v_cols}\")\n        # print(f\"Potential H Segments: {potential_h_rows}\")\n        # print(f\"Valid H Segments (no V overlap): {valid_h_rows}\")\n        # print(f\"Isolated Candidates: {isolated_coords_set}\")\n        raise ValueError(\"Could not definitively identify all three required structures (horizontal, vertical, isolated).\")\n\n    # Return identified structures' details\n    return (list(h_segment_coords), h_segment_values,\n            list(v_segment_coords), v_segment_value,\n            isolated_cell_coord, isolated_cell_value)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid by identifying\n    horizontal/vertical segments and an isolated cell, then swapping/assigning\n    values based on the rules.\n    \"\"\"\n    # Convert input to a NumPy array for efficient element access and manipulation\n    grid = np.array(input_grid)\n    # Create a copy to modify, preserving the original input grid\n    output_grid = np.copy(grid)\n\n    # Find all non-zero cells in the grid\n    non_zero_cells = find_non_zero_cells(grid)\n\n    # If there are no non-zero cells, return the grid as is\n    if not non_zero_cells:\n        return output_grid.tolist() # Return as list of lists\n\n    try:\n        # Identify the coordinates and original values of the three structures\n        h_coords, h_values_orig, v_coords, v_value_orig, iso_coord, iso_value_orig = find_segments(non_zero_cells)\n    except ValueError as e:\n        # If segments can't be identified according to assumptions, return the original grid\n        # This might happen if the input doesn't contain the expected three structures.\n        print(f\"Error during segment identification: {e}. Returning original grid.\")\n        return grid.tolist() # Return original as list of lists\n\n    # --- Apply transformations to the output grid ---\n\n    # 1. Horizontal Segment Transformation:\n    # Find the unique values present in the horizontal segment\n    unique_h_values = sorted(list(set(h_values_orig)))\n    h_value_map = {}\n    # If exactly two unique values exist, create a map to swap them\n    if len(unique_h_values) == 2:\n        val_a, val_b = unique_h_values\n        h_value_map[val_a] = val_b\n        h_value_map[val_b] = val_a\n    # Otherwise (one unique value), create a map where values map to themselves (no change)\n    else:\n        for val in unique_h_values:\n            h_value_map[val] = val\n\n    # Iterate through the coordinates of the horizontal segment\n    for r, c in h_coords:\n        original_val = grid[r, c] # Get the original value from the input grid\n        if original_val in h_value_map:\n            # Apply the transformation using the map\n            output_grid[r, c] = h_value_map[original_val]\n\n    # 2. Vertical Segment Transformation:\n    # Set all cells in the vertical segment to the original value of the isolated cell\n    for r, c in v_coords:\n        output_grid[r, c] = iso_value_orig\n\n    # 3. Isolated Cell Transformation:\n    # Set the isolated cell to the original value of the vertical segment\n    iso_r, iso_c = iso_coord\n    output_grid[iso_r, iso_c] = v_value_orig\n\n    # 4. Zero cells remain zero (this is implicitly handled by starting with a copy\n    #    and only modifying the non-zero cells identified in the segments)\n\n    # Convert the final NumPy array back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12137,
    "candidates_token_count": 2813,
    "total_token_count": 14950,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.438892,
  "retries": 1
}