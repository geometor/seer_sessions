{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nProcesses a 2D grid containing non-zero integers forming specific structures. \nIt identifies a unique vertical segment (contiguous, uniform value, length>1), \na unique horizontal segment (contiguous, length>1, values can vary), \nwhich do not overlap spatially, and a unique isolated non-zero cell \n(not part of either identified segment). It then swaps/assigns values:\n- Horizontal Segment: If it originally had exactly two unique non-zero values (A, B), \n  they are swapped (A->B, B->A) in the output. Otherwise, values remain unchanged.\n- Vertical Segment: Its cells in the output take the original value of the isolated cell.\n- Isolated Cell: Its cell in the output takes the original value of the vertical segment.\n- Zero cells remain zero.\nThe identification relies on finding the unique non-overlapping pair of \npotential vertical and horizontal segments.\n\"\"\"\n\ndef find_non_zero_cells(grid):\n    \"\"\"Finds all non-zero cells and returns their coordinates and values.\"\"\"\n    non_zero_coords = np.argwhere(grid > 0)\n    return [(r, c, grid[r, c]) for r, c in non_zero_coords]\n\ndef find_potential_vertical_segments(grid, non_zero_cells):\n    \"\"\"\n    Finds all potential vertical segments (contiguous, uniform value, length > 1).\n    Returns a list of dictionaries, each with 'coords' (set) and 'value'.\n    \"\"\"\n    non_zero_coords_set = set((r, c) for r, c, v in non_zero_cells)\n    potential_segments = []\n    processed_coords = set()\n\n    # Sort cells primarily by column, then row to help processing\n    sorted_cells = sorted(non_zero_cells, key=lambda x: (x[1], x[0]))\n\n    for r_start, c_start, v_start in sorted_cells:\n        if (r_start, c_start) in processed_coords:\n            continue\n\n        # Check downwards for contiguous cells with the same value\n        current_segment_coords = [(r_start, c_start)]\n        current_r = r_start + 1\n        while (current_r, c_start) in non_zero_coords_set and grid[current_r, c_start] == v_start:\n            current_segment_coords.append((current_r, c_start))\n            current_r += 1\n\n        # Store if it's a valid segment (length > 1)\n        if len(current_segment_coords) > 1:\n            segment_set = set(current_segment_coords)\n            potential_segments.append({\"coords\": segment_set, \"value\": v_start})\n            processed_coords.update(segment_set) # Mark all segment cells as processed\n        else:\n             processed_coords.add((r_start, c_start)) # Mark single cell as processed\n\n    return potential_segments\n\ndef find_potential_horizontal_segments(grid, non_zero_cells):\n    \"\"\"\n    Finds all potential horizontal segments (contiguous, length > 1). Values can vary.\n    Returns a list of dictionaries, each with 'coords' (set) and 'values' (list).\n    \"\"\"\n    non_zero_coords_set = set((r, c) for r, c, v in non_zero_cells)\n    potential_segments = []\n    processed_coords = set()\n\n    # Sort cells primarily by row, then column\n    sorted_cells = sorted(non_zero_cells, key=lambda x: (x[0], x[1]))\n\n    for r_start, c_start, v_start in sorted_cells:\n        if (r_start, c_start) in processed_coords:\n            continue\n\n        # Check rightwards for contiguous cells\n        current_segment_coords = [(r_start, c_start)]\n        current_c = c_start + 1\n        while (r_start, current_c) in non_zero_coords_set:\n            current_segment_coords.append((r_start, current_c))\n            current_c += 1\n\n        # Store if it's a valid segment (length > 1)\n        if len(current_segment_coords) > 1:\n            segment_set = set(current_segment_coords)\n            # Ensure coords are sorted by column for consistent 'values' list\n            sorted_coords_list = sorted(list(segment_set), key=lambda x: x[1])\n            values = [grid[r, c] for r, c in sorted_coords_list]\n            potential_segments.append({\"coords\": segment_set, \"values\": values})\n            processed_coords.update(segment_set)\n        else:\n            processed_coords.add((r_start, c_start))\n\n    return potential_segments\n\ndef find_correct_segments(potential_v, potential_h):\n    \"\"\"\n    Finds the unique non-overlapping pair of vertical and horizontal segments.\n    Returns (v_segment, h_segment) or (None, None) if not found or ambiguous.\n    \"\"\"\n    non_overlapping_pairs = []\n    for v_seg in potential_v:\n        for h_seg in potential_h:\n            # Check for disjoint sets of coordinates\n            if not (v_seg['coords'] & h_seg['coords']):\n                non_overlapping_pairs.append((v_seg, h_seg))\n\n    # Expect exactly one non-overlapping pair based on problem constraints\n    if len(non_overlapping_pairs) == 1:\n        return non_overlapping_pairs[0]\n    else:\n        # Log error or warning if 0 or >1 pairs found\n        # print(f\"Warning/Error: Found {len(non_overlapping_pairs)} non-overlapping segment pairs.\")\n        return None, None # Indicate failure\n\ndef find_isolated_cell(grid, all_nz_coords_set, v_coords, h_coords):\n    \"\"\"\n    Finds the single non-zero cell not belonging to the identified segments.\n    Returns {'coord': (r, c), 'value': val} or None if not found/ambiguous.\n    \"\"\"\n    segment_coords = v_coords.union(h_coords)\n    isolated_coords_set = all_nz_coords_set - segment_coords\n\n    if len(isolated_coords_set) == 1:\n        iso_coord = isolated_coords_set.pop()\n        iso_value = grid[iso_coord[0], iso_coord[1]]\n        return {\"coord\": iso_coord, \"value\": iso_value}\n    else:\n        # Log error or warning\n        # print(f\"Warning/Error: Found {len(isolated_coords_set)} isolated cell candidates.\")\n        return None # Indicate failure\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules after identifying the unique non-overlapping\n    vertical segment, horizontal segment, and isolated cell.\n    \"\"\"\n    # Initialize grid using numpy for convenience\n    grid = np.array(input_grid)\n    output_grid = np.copy(grid)\n\n    # --- Identification Phase ---\n    non_zero_cells = find_non_zero_cells(grid)\n    if not non_zero_cells:\n        return output_grid.tolist() # Return original if empty\n\n    all_nz_coords_set = set((r, c) for r, c, v in non_zero_cells)\n\n    # Find all potential segments\n    potential_v = find_potential_vertical_segments(grid, non_zero_cells)\n    potential_h = find_potential_horizontal_segments(grid, non_zero_cells)\n\n    # Find the correct, non-overlapping pair\n    true_v_segment, true_h_segment = find_correct_segments(potential_v, potential_h)\n\n    # If the correct pair wasn't found, return original (robustness)\n    if not true_v_segment or not true_h_segment:\n        # print(\"Failed to identify unique non-overlapping segments. Returning original grid.\")\n        return grid.tolist()\n\n    # Find the isolated cell using the coordinates of the true segments\n    isolated_cell = find_isolated_cell(grid, all_nz_coords_set, true_v_segment['coords'], true_h_segment['coords'])\n\n    # If isolated cell wasn't found uniquely, return original\n    if not isolated_cell:\n        # print(\"Failed to identify unique isolated cell. Returning original grid.\")\n        return grid.tolist()\n\n    # Extract original values needed for transformation\n    v_val_orig = true_v_segment['value']\n    h_vals_orig = true_h_segment['values']\n    i_val_orig = isolated_cell['value']\n    v_coords = true_v_segment['coords']\n    h_coords = true_h_segment['coords']\n    iso_coord = isolated_cell['coord']\n\n    # --- Transformation Phase ---\n\n    # 1. Determine Horizontal Segment transformation map\n    unique_h_values = sorted(list(set(h_vals_orig)))\n    h_value_map = {}\n    if len(unique_h_values) == 2:\n        val_a, val_b = unique_h_values\n        h_value_map[val_a] = val_b\n        h_value_map[val_b] = val_a\n    else:\n        # Only one unique value, or more than two -> map to self (no change)\n        for val in unique_h_values:\n            h_value_map[val] = val\n\n    # 2. Apply transformations to output_grid\n\n    # Apply Horizontal transformation\n    for r, c in h_coords:\n        original_val = grid[r, c]\n        if original_val in h_value_map: # Should always be true if logic is correct\n            output_grid[r, c] = h_value_map[original_val]\n\n    # Apply Vertical transformation\n    for r, c in v_coords:\n        output_grid[r, c] = i_val_orig\n\n    # Apply Isolated Cell transformation\n    iso_r, iso_c = iso_coord\n    output_grid[iso_r, iso_c] = v_val_orig\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19495,
    "candidates_token_count": 2415,
    "total_token_count": 21910,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.380368,
  "retries": 1
}