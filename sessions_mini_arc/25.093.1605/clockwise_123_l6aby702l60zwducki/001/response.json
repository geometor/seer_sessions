{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis program transforms a 2D grid of integers based on identified patterns.\nThe transformation involves two potential rules, prioritized as follows:\n\nRule 1 (Isolated Trigger Fall & Spread):\nIf there is an \"isolated trigger\" element (a non-zero cell that is the only non-zero element in its row, and this row is below the topmost row containing any non-zero elements), the rule applies. The trigger chosen is the one in the lowest row, breaking ties by choosing the rightmost one. The fill color is determined by the leftmost non-zero element in the topmost populated row. This fill color \"falls\" vertically downwards from below the trigger through consecutive 0s, and then \"spreads\" horizontally leftwards from the bottom of the fall path through consecutive 0s.\n\nRule 2 (Top Row Extension & Drip):\nIf no isolated trigger exists, this rule applies. The fill color is determined as in Rule 1. Any 0s in the topmost populated row to the right of the rightmost non-zero element are filled with the fill color. If any cells were filled this way, the cell directly below the rightmost newly filled cell is also filled with the fill color, provided it's within bounds and is currently 0.\n\nExisting non-zero cells in the input grid are preserved in the output.\n\"\"\"\n\nimport numpy as np\n\ndef _find_top_row_params(grid):\n    \"\"\"Finds the topmost row with non-zero elements and its parameters.\"\"\"\n    rows, cols = grid.shape\n    r_top = -1\n    fill_color = -1\n    c_left = -1\n    c_right = -1\n\n    for r in range(rows):\n        non_zeros = np.where(grid[r] != 0)[0]\n        if len(non_zeros) > 0:\n            r_top = r\n            c_left = non_zeros[0]\n            fill_color = grid[r, c_left]\n            c_right = non_zeros[-1]\n            break # Found the topmost row\n\n    if r_top == -1:\n        return None # No non-zero elements in the grid\n    \n    return r_top, fill_color, c_right\n\ndef _find_isolated_trigger(grid, r_top):\n    \"\"\"Finds the specific isolated trigger element based on the rules.\"\"\"\n    rows, cols = grid.shape\n    potential_triggers = []\n\n    for r in range(r_top + 1, rows):\n        non_zeros_indices = np.where(grid[r] != 0)[0]\n        if len(non_zeros_indices) == 1:\n            c = non_zeros_indices[0]\n            potential_triggers.append((r, c))\n\n    if not potential_triggers:\n        return None # No isolated triggers found\n\n    # Sort triggers: primary key is row (descending), secondary key is col (descending)\n    potential_triggers.sort(key=lambda item: (item[0], item[1]), reverse=True)\n    \n    # The best trigger is the first one after sorting\n    return potential_triggers[0]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    output_grid = np.array(input_grid, copy=True)\n    rows, cols = output_grid.shape\n\n    # 1. Identify Top Row Parameters\n    top_params = _find_top_row_params(output_grid)\n    if top_params is None:\n        return output_grid # No non-zeros, return copy of input\n    \n    r_top, fill_color, c_right = top_params\n\n    # 2. Check for Isolated Trigger\n    trigger = _find_isolated_trigger(output_grid, r_top)\n\n    if trigger:\n        # 3. Perform Fall & Spread (Rule 2)\n        r_trigger, c_trigger = trigger\n        \n        # Falling Path\n        fall_path = []\n        y_stop = r_trigger # Keep track of the last row reached by falling\n        for r in range(r_trigger + 1, rows):\n            if output_grid[r, c_trigger] == 0:\n                fall_path.append((r, c_trigger))\n                y_stop = r\n            else:\n                break # Hit boundary or non-zero\n\n        # Spreading Path (only if fall path existed or starts right below trigger)\n        spread_path = []\n        # Start spreading from the row where the fall stopped (or trigger row if no fall)\n        # But check if the fall path actually moved down first\n        if fall_path:\n            start_spread_row = y_stop\n        else:\n             # If nothing to fall into, check if we can spread from directly below trigger\n             start_spread_row = r_trigger + 1\n             if start_spread_row >= rows or output_grid[start_spread_row, c_trigger] != 0:\n                 start_spread_row = -1 # Cannot start spread\n\n        # Calculate spread only if we have a valid row to start from\n        if start_spread_row != -1:\n           for c in range(c_trigger - 1, -1, -1):\n               if output_grid[start_spread_row, c] == 0:\n                   spread_path.append((start_spread_row, c))\n               else:\n                   break # Hit boundary or non-zero\n\n        # Fill paths\n        for r, c in fall_path:\n            output_grid[r, c] = fill_color\n        for r, c in spread_path:\n            output_grid[r, c] = fill_color\n\n    else:\n        # 4. Perform Top Row Extension & Drip (Rule 1)\n        filled_top_row = False\n        c_new_right = -1\n        # Iterate from column after the rightmost element to the end\n        for c in range(c_right + 1, cols):\n            if output_grid[r_top, c] == 0:\n                output_grid[r_top, c] = fill_color\n                filled_top_row = True\n                c_new_right = c # Track the last column filled\n\n        # Perform drip if top row was extended\n        if filled_top_row:\n            r_drip = r_top + 1\n            c_drip = c_new_right\n            # Check bounds and if the cell below is 0\n            if r_drip < rows and output_grid[r_drip, c_drip] == 0:\n                output_grid[r_drip, c_drip] = fill_color\n\n    # 5. Finalize\n    return output_grid.tolist() # Return as list of lists as per typical format\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2460,
    "candidates_token_count": 1563,
    "total_token_count": 4023,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.145663,
  "retries": 1
}