{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set, Optional\n\n\"\"\"\nTransformation Rule:\n1. Identify distinct objects in the grid based on digit values:\n   - Background: Digit 0.\n   - Target: Digit 7 (static).\n   - Movable Object: A contiguous block of identical digits (not 0 or 7). Heuristically identified as the least frequent non-0, non-7 digit, excluding potential simple border digits. Assumed unique type per grid.\n   - Static Obstacles: All other non-zero digits (typically the border) that are not the target or the movable object.\n2. Determine the primary cardinal direction (Up, Down, Left, Right) from the centroid of the Movable Object towards the centroid of the Target Object(s).\n3. Simulate the Movable Object sliding one step at a time in the determined direction.\n4. Before each step, check if the *next potential position* would result in:\n   a) Any part of the Movable Object going out of grid bounds.\n   b) Any part of the Movable Object colliding with a Static Obstacle cell.\n   c) Any part of the Movable Object becoming adjacent (sharing an edge) to a Target (7) cell.\n5. If any of conditions (a, b, c) are met for the *potential* next step, the movement stops, and the *current* position is the final position.\n6. If the move is valid (none of the stop conditions met), update the grid: erase the Movable Object from its current position (fill with 0) and draw it in the new position. Update the current coordinates and repeat step 4.\n7. If no Target Object (7) exists or the direction is ambiguous (e.g., centroids overlap), no movement occurs.\n\"\"\"\n\ndef find_digit_coords(grid: np.ndarray, digit: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of a specific digit.\"\"\"\n    coords = np.argwhere(grid == digit)\n    return [tuple(coord) for coord in coords]\n\ndef identify_objects(grid: np.ndarray) -> Tuple[Optional[int], List[Tuple[int, int]], List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Identifies the movable digit/coords, target coords (7), and static obstacle coords.\n    Returns: (movable_digit, movable_coords, target_coords, static_obstacle_coords)\n    \"\"\"\n    rows, cols = grid.shape\n    unique_digits = np.unique(grid)\n\n    target_coords = find_digit_coords(grid, 7)\n    \n    potential_movable_digits = [d for d in unique_digits if d != 0 and d != 7]\n    if not potential_movable_digits:\n        # No potential movable objects found (only 0s and 7s, or just 0s)\n        all_non_zero_coords = [tuple(c) for c in np.argwhere(grid != 0) if grid[c[0], c[1]] != 7]\n        return None, [], target_coords, all_non_zero_coords\n\n    counts = {d: np.sum(grid == d) for d in potential_movable_digits}\n\n    # Simple border check heuristic\n    border_digit = grid[0, 0]\n    is_simple_border = False\n    if border_digit != 0 and border_digit != 7:\n       is_simple_border = True\n       # Check corners\n       if grid[0, -1] != border_digit or grid[-1, 0] != border_digit or grid[-1, -1] != border_digit:\n          is_simple_border = False\n       # Check some edge points (crude check)\n       if is_simple_border:\n           for r in range(rows):\n               if grid[r, 0] != border_digit and grid[r,0]!=0 : is_simple_border = False; break\n               if grid[r, cols-1] != border_digit and grid[r,cols-1]!=0: is_simple_border = False; break\n           if is_simple_border:\n                for c in range(cols):\n                   if grid[0, c] != border_digit and grid[0,c]!=0: is_simple_border = False; break\n                   if grid[rows-1, c] != border_digit and grid[rows-1,c]!=0: is_simple_border = False; break\n\n    # Filter out the border digit if it's identified\n    if is_simple_border and border_digit in potential_movable_digits:\n        potential_movable_digits = [d for d in potential_movable_digits if d != border_digit]\n        \n    movable_digit = None\n    movable_coords = []\n    static_obstacle_coords = []\n\n    if not potential_movable_digits:\n         # Only border and target/background exist\n         movable_digit = None \n         movable_coords = []\n    elif len(potential_movable_digits) == 1:\n        movable_digit = potential_movable_digits[0]\n        movable_coords = find_digit_coords(grid, movable_digit)\n    else:\n        # Ambiguous: Use frequency heuristic (least frequent non-border/non-target/non-zero)\n        # Re-calculate counts for remaining potentials\n        counts = {d: np.sum(grid == d) for d in potential_movable_digits}\n        sorted_counts = sorted(counts.items(), key=lambda item: item[1])\n        if sorted_counts:\n            movable_digit = sorted_counts[0][0]\n            movable_coords = find_digit_coords(grid, movable_digit)\n        else: # Should not happen if potential_movable_digits is not empty\n             movable_digit = None\n             movable_coords = []\n\n\n    # Identify all static obstacles (non-0, non-7, non-movable)\n    all_non_zero_coords = np.argwhere(grid != 0)\n    movable_set = set(movable_coords)\n    target_set = set(target_coords)\n    \n    static_obstacle_coords = []\n    for r, c in all_non_zero_coords:\n        coord = (r, c)\n        if coord not in movable_set and coord not in target_set:\n            static_obstacle_coords.append(coord)\n            \n    return movable_digit, movable_coords, target_coords, static_obstacle_coords\n\n\ndef calculate_center(coords: List[Tuple[int, int]]) -> Tuple[float, float]:\n    \"\"\"Calculates the geometric center (average row, col) of coordinates.\"\"\"\n    if not coords:\n        # Return center of grid? Or just origin? Let's use origin.\n        return (0.0, 0.0) \n    avg_row = sum(r for r, c in coords) / len(coords)\n    avg_col = sum(c for r, c in coords) / len(coords)\n    return (avg_row, avg_col)\n\ndef determine_direction(movable_center: Tuple[float, float], target_center: Tuple[float, float]) -> Tuple[int, int]:\n    \"\"\"Determines the primary cardinal direction (dr, dc) from movable to target.\"\"\"\n    dr_f = target_center[0] - movable_center[0]\n    dc_f = target_center[1] - movable_center[1]\n\n    # Handle cases where centers are very close or identical\n    if abs(dr_f) < 1e-6 and abs(dc_f) < 1e-6:\n        return (0, 0)\n\n    if abs(dr_f) >= abs(dc_f):\n        # Move vertically\n        return (1 if dr_f > 0 else -1, 0)\n    else:\n        # Move horizontally\n        return (0, 1 if dc_f > 0 else -1)\n\ndef check_stop_condition(\n    potential_coords: List[Tuple[int, int]], \n    target_set: Set[Tuple[int, int]], \n    obstacle_set: Set[Tuple[int, int]], \n    grid_shape: Tuple[int, int]\n) -> bool:\n    \"\"\"Checks if the potential next move leads to a stop condition.\"\"\"\n    rows, cols = grid_shape\n    for r, c in potential_coords:\n        # 1. Check grid bounds\n        if not (0 <= r < rows and 0 <= c < cols):\n            return True  # Stop: Out of bounds\n        \n        # 2. Check collision with static obstacles\n        if (r, c) in obstacle_set:\n            return True # Stop: Collision with obstacle\n            \n        # 3. Check adjacency to target\n        for dr_adj, dc_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            adj_r, adj_c = r + dr_adj, c + dc_adj\n            if (adj_r, adj_c) in target_set:\n                return True # Stop: Adjacent to target\n                \n    return False # No stop condition met\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Moves a block of digits towards the '7' block until adjacent or blocked.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # --- 1. Identify Components ---\n    movable_digit, current_movable_coords, target_coords, static_obstacle_coords = identify_objects(grid)\n\n    # Handle cases with no movable object\n    if movable_digit is None or not current_movable_coords:\n        return output_grid.tolist()\n\n    # Convert lists to sets for efficient lookup\n    target_set = set(target_coords)\n    static_obstacle_set = set(static_obstacle_coords)\n\n    # --- 2. Determine Movement Direction ---\n    movable_center = calculate_center(current_movable_coords)\n    target_center = calculate_center(target_coords)\n    \n    # If no target 7s, stay put.\n    if not target_coords:\n         dr, dc = (0,0)\n    else:\n         dr, dc = determine_direction(movable_center, target_center)\n\n    # If direction is (0,0) (e.g., centers coincide or no target), no movement needed\n    if dr == 0 and dc == 0:\n         return output_grid.tolist()\n\n    # --- 3. Iterative Movement ---\n    while True:\n        # --- 3a. Calculate Potential Next Position ---\n        potential_next_coords = [(r + dr, c + dc) for r, c in current_movable_coords]\n\n        # --- 3b. Check Stopping Conditions for Potential Position ---\n        if check_stop_condition(potential_next_coords, target_set, static_obstacle_set, (rows, cols)):\n            break # Stop movement, current position is final\n\n        # --- 3c. Execute Move (if no stop condition) ---\n        # Clear old positions\n        for r, c in current_movable_coords:\n            output_grid[r, c] = 0\n        # Place in new positions\n        for nr, nc in potential_next_coords:\n            # Ensure we don't write out of bounds if check_stop_condition had a bug\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 output_grid[nr, nc] = movable_digit\n            else:\n                 # This case indicates an issue, maybe log or raise error\n                 # For now, just prevent writing out of bounds\n                 pass \n\n        # Update coordinates for the next iteration\n        current_movable_coords = potential_next_coords\n        \n        # Safety break: Prevent infinite loops in case of unexpected state\n        # This requires tracking previous states, let's omit for now and rely on stop conditions\n\n    # --- 4. Finalize ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11201,
    "candidates_token_count": 4558,
    "total_token_count": 15759,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.463625,
  "retries": 1
}