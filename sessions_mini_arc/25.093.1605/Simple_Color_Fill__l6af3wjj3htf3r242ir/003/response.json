{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms the input grid by identifying a unique 'source' cell (Y), a 'background' value (X), \nand an 'internal hole' region (H) of zeros. \n\nThe process involves:\n1. Identifying the source value Y (least frequent non-zero, adjacent to another non-zero value X) \n   and its location (r_y, c_y).\n2. Identifying the background value X (the non-zero value adjacent to Y).\n3. Finding the connected component of zeros (H) that meets two criteria:\n    a. All its non-zero orthogonal neighbors have the background value X.\n    b. No cell within the component touches the grid boundary.\n4. Filling this internal hole region H with the source value Y.\n5. Changing the value at the original source cell location (r_y, c_y) to the background value X.\n\"\"\"\n\ndef _get_value_counts(grid):\n    \"\"\"Counts occurrences of non-zero values in the grid.\"\"\"\n    counts = collections.Counter(val for val in grid.flat if val != 0)\n    return counts\n\ndef _find_source_and_background(grid):\n    \"\"\"\n    Finds the source value (Y), its location (r_y, c_y), and the background value (X).\n    Y is the least frequent non-zero value adjacent to another non-zero value X.\n    \"\"\"\n    counts = _get_value_counts(grid)\n    if not counts:\n        return None, None, None # No non-zero values\n\n    if len(counts) == 1:\n         # Only one non-zero value, cannot determine distinct source/background\n         # Based on task structure, this likely means no transformation is applicable.\n         return None, None, None\n\n    # Find least frequent non-zero value (potential source Y)\n    sorted_counts = counts.most_common()\n    source_y = sorted_counts[-1][0]\n    \n    # Find the location of this potential source value Y\n    locations_y = np.argwhere(grid == source_y)\n    if locations_y.size == 0:\n        # Should not happen if counts were > 0\n        return None, None, None \n        \n    # Assume unique location for Y based on problem constraints\n    source_r, source_c = tuple(locations_y[0])\n    source_location = (source_r, source_c)\n\n    # Find the adjacent background value X\n    rows, cols = grid.shape\n    background_x = None\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = source_r + dr, source_c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbor_val = grid[nr, nc]\n            if neighbor_val != 0 and neighbor_val != source_y:\n                # Found a non-zero neighbor different from Y. Assume this is X.\n                # The problem constraints imply Y is adjacent to only one other value type X.\n                background_x = neighbor_val\n                break # Found X, no need to check other neighbors\n\n    if background_x is None:\n        # The least frequent value wasn't adjacent to any *other* non-zero value.\n        # This scenario might not fit the problem pattern.\n        return None, None, None\n\n    return source_y, source_location, background_x\n\n\ndef _find_internal_hole_region(grid, background_value):\n    \"\"\"\n    Finds the connected region of zeros that is bordered only by the background value \n    (or other zeros) AND does not touch the grid boundary. Uses BFS.\n    Returns a list of (row, col) tuples for the hole cells, or [] if none found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited_zeros = set() # Keep track of zeros visited across different potential components\n    \n    for r_start in range(rows):\n        for c_start in range(cols):\n            if grid[r_start, c_start] == 0 and (r_start, c_start) not in visited_zeros:\n                # Start BFS for a new potential hole component\n                component_coords = []\n                q = collections.deque([(r_start, c_start)])\n                component_visited_bfs = set([(r_start, c_start)]) # Zeros visited in *this* BFS\n                \n                touches_boundary = False\n                invalid_neighbor_found = False\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.append((curr_r, curr_c))\n                    visited_zeros.add((curr_r, curr_c)) # Mark as globally visited\n\n                    # Check boundary condition\n                    if curr_r == 0 or curr_c == 0 or curr_r == rows - 1 or curr_c == cols - 1:\n                        touches_boundary = True\n\n                    # Check neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            neighbor_val = grid[nr, nc]\n                            neighbor_coord = (nr, nc)\n\n                            if neighbor_val == 0:\n                                if neighbor_coord not in component_visited_bfs:\n                                    component_visited_bfs.add(neighbor_coord)\n                                    q.append(neighbor_coord)\n                            elif neighbor_val != background_value:\n                                # Found a non-zero neighbor that isn't the background value\n                                invalid_neighbor_found = True\n                        # else: neighbor is out of bounds (implicitly handled)\n\n                # After BFS for this component is complete, check conditions\n                if not touches_boundary and not invalid_neighbor_found:\n                    # This component satisfies all conditions for the internal hole\n                    return component_coords\n\n    # If loop completes without finding a valid internal hole\n    return []\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on identifying background, source, and an internal hole region.\n    \n    1. Identifies source (Y), its location (r_y, c_y), and background (X).\n    2. Finds the internal hole region (H) - zeros bordered only by X and not touching the boundary.\n    3. Fills H with Y.\n    4. Changes the cell at (r_y, c_y) to X.\n    \"\"\"\n    # Convert list of lists to numpy array for easier processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # Step 1: Identify Source (Y), its location, and Background (X)\n    source_y, source_location, background_x = _find_source_and_background(input_grid)\n\n    if source_y is None or source_location is None or background_x is None:\n        # Could not identify the necessary components based on the rules.\n        # Return the original grid copy.\n        print(\"Warning: Could not identify source/background values/location per rules.\")\n        return output_grid.tolist() \n    \n    source_r, source_c = source_location\n\n    # Step 2: Identify Internal Hole Region (H)\n    hole_coordinates = _find_internal_hole_region(input_grid, background_x)\n\n    # Step 3: Fill Hole (if found)\n    if hole_coordinates:\n        for r_h, c_h in hole_coordinates:\n             # Check bounds just in case, though BFS should handle it\n             if 0 <= r_h < rows and 0 <= c_h < cols:\n                 output_grid[r_h, c_h] = source_y\n            \n    # Step 4: Update Source Location\n    # Check bounds for the source location as well\n    if 0 <= source_r < rows and 0 <= source_c < cols:\n        output_grid[source_r, source_c] = background_x\n            \n    # Step 5: Finalize - Convert back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15371,
    "candidates_token_count": 1930,
    "total_token_count": 17301,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.939411,
  "retries": 1
}