{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms the input grid based on identifying background, source, and hole regions.\n\nThe transformation identifies a 'background' value (X), a 'source' value (Y), \nand a 'hole' region (H) of zeros. The hole region is defined as a connected \ncomponent of zeros where all adjacent non-zero cells have the background value X.\nThe source value Y is typically a unique, non-zero value different from X, located \nat cell (r_y, c_y). The transformation fills the hole region H with the source \nvalue Y and changes the value at the original source cell location (r_y, c_y) \nto the background value X.\n\n1.  **Initialize:** Create a copy of the `InputGrid` to serve as the `OutputGrid`.\n2.  **Identify Background (X) and Source (Y) Values:** Determine the most frequent \n    non-zero value (X) and the least frequent non-zero value (Y).\n3.  **Identify Source Cell Location:** Find the coordinates (r_y, c_y) of the cell \n    containing the source value Y.\n4.  **Identify Hole Region (H):** Find the connected component of zero-valued cells (H) \n    such that every non-zero orthogonal neighbor of any cell in H has the value X.\n5.  **Fill Hole:** Update the `OutputGrid` by setting the value of all cells within \n    the identified Hole Region H to the source value Y.\n6.  **Update Source Location:** Set the value of the `OutputGrid` at the original \n    location of the source cell (r_y, c_y) to the background value X.\n7.  **Finalize:** Return the modified `OutputGrid`.\n\"\"\"\n\ndef _get_value_counts(grid):\n    \"\"\"Counts occurrences of non-zero values in the grid.\"\"\"\n    counts = collections.Counter(val for val in grid.flat if val != 0)\n    return counts\n\ndef _find_background_and_source_values(grid):\n    \"\"\"\n    Finds background (most frequent non-zero) and source (least frequent non-zero) values.\n    Assumes there are exactly two distinct non-zero values based on problem constraints.\n    \"\"\"\n    counts = _get_value_counts(grid)\n    if not counts:\n        return None, None # No non-zero values\n    if len(counts) == 1:\n        # Only one non-zero value, cannot determine distinct background and source\n        # Based on task structure, assume this case implies no change or is invalid input.\n        # Returning the single value as background, None as source.\n        background_value = list(counts.keys())[0]\n        return background_value, None\n\n    # Assume len(counts) >= 2. Find most and least frequent.\n    # Using most_common directly relies on insertion order for ties, which is fine here.\n    sorted_counts = counts.most_common()\n    background_value = sorted_counts[0][0]\n    source_value = sorted_counts[-1][0] # Least frequent\n\n    # Verify source is not same as background if counts were equal\n    if background_value == source_value and len(sorted_counts) > 1:\n        # This case shouldn't happen if frequencies truly differ.\n        # If frequencies are equal, need a tie-breaker rule not specified.\n        # The problem implies unique Y != X. Let's assume counts are distinct.\n         pass # Or potentially raise an error / log warning.\n\n    return background_value, source_value\n\ndef _find_cell_location(grid, value):\n    \"\"\"Finds the coordinates (r, c) of the first cell with the given value.\"\"\"\n    # np.argwhere returns an array of [row, col] pairs. Get the first one.\n    locations = np.argwhere(grid == value)\n    if locations.size > 0:\n        return tuple(locations[0])\n    return None # Value not found\n\ndef _find_hole_region(grid, background_value):\n    \"\"\"\n    Finds the connected region of zeros bordered only by the background value using BFS.\n    Returns a list of (row, col) tuples for the hole cells.\n    \"\"\"\n    rows, cols = grid.shape\n    visited_zeros = set() # Keep track of zeros visited across different potential components\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 0 and (r, c) not in visited_zeros:\n                # Found an unvisited zero, start BFS to find its connected component\n                component_coords = []\n                q = collections.deque([(r, c)])\n                component_visited_bfs = set([(r, c)]) # Zeros visited in *this* BFS run\n                is_target_hole_component = True # Assume true initially for this component\n\n                processed_in_bfs = set() # Track cells added to queue during this BFS\n\n                bfs_q = collections.deque([(r,c)])\n                processed_in_bfs.add((r,c))\n\n\n                while bfs_q:\n                    curr_r, curr_c = bfs_q.popleft()\n                    \n                    # Check if this zero is valid (part of the potential hole)\n                    # We need to check neighbors *before* adding to component_coords\n                    \n                    is_current_cell_valid = True\n                    for dr_check, dc_check in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr_check, nc_check = curr_r + dr_check, curr_c + dc_check\n                         if 0 <= nr_check < rows and 0 <= nc_check < cols:\n                              neighbor_val_check = grid[nr_check, nc_check]\n                              if neighbor_val_check != 0 and neighbor_val_check != background_value:\n                                   is_target_hole_component = False\n                                   is_current_cell_valid = False\n                                   break # This component touches a non-background value\n                         # else: out of bounds is fine\n                    \n                    if not is_current_cell_valid:\n                         # If the cell itself invalidates the component, mark component and continue BFS only to mark visited\n                         continue # Don't add invalid cell coords, but keep exploring its zero neighbors for visited marking\n\n                    # If current cell is valid so far, add it to potential component\n                    component_coords.append((curr_r, curr_c))\n\n                    # Explore valid neighbors for BFS\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            neighbor_val = grid[nr, nc]\n                            if neighbor_val == 0 and (nr, nc) not in processed_in_bfs:\n                                # Found an unvisited zero neighbor, add to queue\n                                processed_in_bfs.add((nr, nc))\n                                bfs_q.append((nr, nc))\n                            # Non-zero neighbors were already checked for validity calculation above\n\n                # After BFS for the component starting at (r,c) is complete:\n                # Mark all explored zeros in this component as globally visited\n                visited_zeros.update(processed_in_bfs)\n\n                # If the flag remained true throughout the component exploration, it's our hole\n                if is_target_hole_component and component_coords:\n                    # We found the hole region defined by the background value\n                    return component_coords \n\n    return [] # Return empty list if no such hole region is found\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the hole-filling transformation to the input grid.\n    \"\"\"\n    # Convert list of lists to numpy array for easier processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid)\n    \n    # Step 2: Identify Background (X) and Source (Y) Values\n    background_value, source_value = _find_background_and_source_values(input_grid)\n\n    if background_value is None or source_value is None:\n        # If values couldn't be determined (e.g., grid empty, only one non-zero type)\n        # return the original grid copy\n        print(\"Warning: Could not determine distinct background and source values.\")\n        return output_grid.tolist() \n\n    # Step 3: Identify Source Cell Location (r_y, c_y)\n    source_location = _find_cell_location(input_grid, source_value)\n    \n    if source_location is None:\n         # Should not happen if source_value was determined correctly\n        print(\"Warning: Source value found, but location not found.\")\n        return output_grid.tolist()\n    \n    source_r, source_c = source_location\n\n    # Step 4: Identify Hole Region (H) - zeros bordered only by X\n    hole_coordinates = _find_hole_region(input_grid, background_value)\n\n    # Step 5: Fill Hole\n    if hole_coordinates:\n        for r_h, c_h in hole_coordinates:\n            output_grid[r_h, c_h] = source_value\n            \n    # Step 6: Update Source Location\n    output_grid[source_r, source_c] = background_value\n            \n    # Step 7: Finalize - Convert back to list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1909,
    "candidates_token_count": 2214,
    "total_token_count": 4123,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 62.07071,
  "retries": 1
}