{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis program transforms an input grid based on the presence or absence of magenta (6) pixels. The output grid starts as a copy of the input.\n\n1.  **Check for Magenta:** Determine if any magenta pixels exist in the input grid.\n\n2.  **If Magenta is Absent:**\n    a.  Calculate a horizontal shift: `shift_col = floor(width / 2) - 1`. Vertical shift `shift_row` is 0.\n    b.  Identify all distinct, single-color, non-white objects fully contained within the left half of the grid (columns 0 to `floor(width / 2) - 1`), using 8-way connectivity.\n    c.  Copy each of these objects, applying the calculated shift `(shift_row, shift_col)` to each pixel's coordinates. Draw the copied objects onto the output grid, overwriting existing pixels.\n\n3.  **If Magenta is Present:**\n    a.  Find the coordinate `(start_r, start_c)` of the first pixel (scanning top-to-bottom, left-to-right) that is neither white (0) nor magenta (6). If none exists, return the initial copy.\n    b.  Perform a search (BFS) starting from `(start_r, start_c)` to find all reachable non-white pixels using 8-way connectivity.\n    c.  Define the \"Source Object\" as the set of all pixels found in step 3b that are *not* magenta. Store their original coordinates and colors.\n    d.  Identify all distinct magenta objects (contiguous blocks of color 6) using 8-way connectivity.\n    e.  For each distinct magenta object, find its top-left coordinate (minimum row, then minimum column).\n    f.  Collect all unique top-left coordinates of the magenta objects.\n    g.  Sort these coordinates first by row index, then by column index.\n    h.  If there are fewer than two sorted coordinates, return the initial copy. Otherwise, select the *second* coordinate pair in the sorted list as the shift vector `(shift_row, shift_col)`.\n    i.  Copy the \"Source Object\". For each pixel `(r, c)` with color `clr` in the Source Object, draw the color `clr` at the new coordinate `(r + shift_row, c + shift_col)` on the output grid, overwriting any existing pixel.\n\nThe output grid starts as a copy of the input grid, and the copied objects overwrite existing pixels at their new locations.\n\"\"\"\n\ndef find_single_color_objects(grid, target_color=None, connectivity=8):\n    \"\"\"\n    Finds all contiguous objects of a specific color or any non-background color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        target_color (int, optional): If specified, only find objects of this color.\n                                      Otherwise, find all non-zero colored objects.\n        connectivity (int): 4 or 8 for neighbor checking. Default is 8.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary:\n              {'coords': set((r, c), ...), 'color': int, 'size': int}\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    background_color = 0\n\n    if connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else: # connectivity 4\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) in visited:\n                continue\n\n            color = grid[r, c]\n\n            # Skip background\n            if color == background_color:\n                visited.add((r, c))\n                continue\n            # Skip if looking for a specific color and this isn't it\n            if target_color is not None and color != target_color:\n                continue\n\n            # Start BFS for a new object of the current color\n            q = deque([(r, c)])\n            current_object_coords = set()\n            visited.add((r, c))\n            obj_color = color # All pixels in this object must have this color\n\n            while q:\n                row, col = q.popleft()\n                current_object_coords.add((row, col))\n\n                # Check neighbors\n                for dr, dc in deltas:\n                    nr, nc = row + dr, col + dc\n\n                    # Check bounds and if neighbor is part of the same object (same color) and not visited\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       (nr, nc) not in visited and grid[nr, nc] == obj_color:\n                        visited.add((nr, nc))\n                        q.append((nr, nc))\n\n            if current_object_coords:\n                objects.append({\n                    'coords': current_object_coords,\n                    'color': obj_color,\n                    'size': len(current_object_coords)\n                })\n\n    return objects\n\n\ndef get_top_left(coords):\n    \"\"\"Calculates the top-left coordinate (min row, then min col) of a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords if r == min_r) # Min col among those with min row\n    # Correction: Find global min_r and global min_c independently is simpler/often intended.\n    # Let's stick to the strict definition: min row, then min col *among min rows*\n    # Re-correction: Based on many ARC tasks, global min_r and global min_c is usually expected. Let's use that.\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    return (min_r, min_c)\n\n\ndef find_connected_component(grid, start_node, connectivity=8):\n    \"\"\"\n    Finds all non-background pixels connected to start_node using BFS.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_node (tuple): The (row, col) to start the search from.\n        connectivity (int): 4 or 8 for neighbor checking. Default is 8.\n\n    Returns:\n        set: A set of tuples (r, c, color) for all pixels in the connected component.\n             Returns an empty set if start_node is background or out of bounds.\n    \"\"\"\n    rows, cols = grid.shape\n    r_start, c_start = start_node\n\n    if not (0 <= r_start < rows and 0 <= c_start < cols) or grid[r_start, c_start] == 0:\n        return set()\n\n    if connectivity == 8:\n        deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    else: # connectivity 4\n        deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    q = deque([start_node])\n    visited = {start_node}\n    component_pixels = set()\n    component_pixels.add((r_start, c_start, grid[r_start, c_start]))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in deltas:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds, if non-background, and not visited\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] != 0 and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                component_pixels.add((nr, nc, grid[nr, nc]))\n                q.append((nr, nc))\n\n    return component_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the presence/absence of magenta pixels.\n    Copies objects either from the left half (no magenta) or a specific\n    composite object determined by magenta marker positions.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = input_np.shape\n    magenta_color = 6\n    background_color = 0\n    connectivity = 8 # Use 8-way connectivity as specified\n\n    # Check for magenta pixels\n    magenta_present = np.any(input_np == magenta_color)\n\n    if not magenta_present:\n        # --- Case 1: No Magenta ---\n        shift_row = 0\n        # Calculate horizontal shift based on grid width\n        shift_col = cols // 2 - 1\n        # Ensure shift is not negative for very narrow grids\n        if shift_col < 0:\n             shift_col = 0\n\n        # Find all single-color non-white objects\n        all_objects = find_single_color_objects(input_np, connectivity=connectivity)\n\n        # Define the boundary for the left half\n        left_half_boundary = cols // 2\n\n        # Iterate through objects and copy those entirely in the left half\n        for obj in all_objects:\n            is_in_left_half = True\n            for r, c in obj['coords']:\n                if c >= left_half_boundary:\n                    is_in_left_half = False\n                    break\n\n            if is_in_left_half:\n                # Copy the object with the calculated shift\n                obj_color = obj['color']\n                for r, c in obj['coords']:\n                    nr, nc = r + shift_row, c + shift_col\n                    # Draw pixel if within output grid bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        output_grid[nr, nc] = obj_color\n\n    else:\n        # --- Case 2: Magenta Present ---\n        # Find the first non-background, non-magenta pixel\n        start_node = None\n        for r in range(rows):\n            for c in range(cols):\n                if input_np[r, c] != background_color and input_np[r, c] != magenta_color:\n                    start_node = (r, c)\n                    break\n            if start_node:\n                break\n\n        # If no such starting pixel, return the initial copy\n        if start_node is None:\n             return output_grid.tolist()\n\n        # Find the connected component starting from this node\n        connected_component = find_connected_component(input_np, start_node, connectivity=connectivity)\n\n        # Define the Source Object (non-magenta pixels from the component)\n        source_object_pixels = {(r, c, color) for r, c, color in connected_component if color != magenta_color}\n\n        if not source_object_pixels:\n             # If the component was only magenta or empty, nothing to copy\n             return output_grid.tolist()\n\n        # Find all distinct magenta objects\n        magenta_objects = find_single_color_objects(input_np, target_color=magenta_color, connectivity=connectivity)\n\n        # If fewer than 2 magenta objects, cannot determine shift, return initial copy\n        if len(magenta_objects) < 2:\n             return output_grid.tolist()\n\n        # Get top-left coordinates of magenta objects\n        magenta_top_lefts = []\n        for m_obj in magenta_objects:\n            tl = get_top_left(m_obj['coords'])\n            if tl:\n                magenta_top_lefts.append(tl)\n\n        # Ensure we have unique top-lefts in case objects overlap in top-left calc?\n        # The spec says \"distinct magenta objects\", so their coordinates should be distinct.\n        # If multiple objects share the same min_r, min_c, get_top_left will return the same point.\n        # Let's assume the examples imply distinct locations matter. Using unique set of TLs.\n        unique_magenta_top_lefts = sorted(list(set(magenta_top_lefts)))\n\n        # Check again if we have at least two unique positions\n        if len(unique_magenta_top_lefts) < 2:\n             return output_grid.tolist()\n\n        # Sort coordinates (row first, then column) - sorting the unique set handles this\n        # Get the shift vector from the *second* unique magenta object's top-left coordinate\n        shift_row, shift_col = unique_magenta_top_lefts[1] # Index 1 for the second item\n\n        # Copy the Source Object using the shift vector\n        for r, c, color in source_object_pixels:\n            nr, nc = r + shift_row, c + shift_col\n            # Draw pixel if within output grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = color\n\n    # Return the transformed grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11907,
    "candidates_token_count": 3092,
    "total_token_count": 14999,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.60017,
  "retries": null
}