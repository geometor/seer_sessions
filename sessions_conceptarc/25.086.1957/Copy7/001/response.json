{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentify two distinct non-background objects in the input grid.\nOne object (source) contains pixels of at least two different non-background colors.\nThe other object (target) contains pixels of only one non-background color.\nDetermine the less frequent non-background color within the source object; this is the 'pattern_color'.\nDetermine the single non-background color of the target object; this is the 'target_color'.\nFind the bounding boxes of both the source and target objects based on their constituent pixels.\nMap the locations of the 'pattern_color' pixels from within the source object's bounding box to the corresponding relative locations within the target object's bounding box.\nChange the color of the pixels in the output grid at these target locations to 'pattern_color', but only if the original color at that location in the input grid was the 'target_color'.\nAll other pixels remain unchanged from the input grid.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of non-ignored colors in the grid.\n    An object is a set of connected pixels (4-way adjacency).\n    \n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, where each dict represents an object\n              and contains 'pixels' (a set of (r, c) tuples) and potentially\n              other derived properties like 'colors_in_pixels' and 'bbox'.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != ignore_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels})\n                    \n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef analyze_object_colors(grid, obj):\n    \"\"\"\n    Analyzes the colors present within an object's pixels.\n    Adds 'colors_in_pixels' (Counter) and 'bbox' to the object dict.\n    \"\"\"\n    colors = Counter()\n    for r, c in obj['pixels']:\n        colors[grid[r, c]] += 1\n    obj['colors_in_pixels'] = colors\n    obj['bbox'] = get_bounding_box(obj['pixels'])\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern transfer transformation.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # 1. Find all distinct contiguous objects (ignoring background color 0)\n    objects = find_objects(input_grid, ignore_color=0)\n    \n    # 2. Analyze colors within each object's pixels and find bbox\n    for obj in objects:\n        analyze_object_colors(input_grid, obj)\n        \n    # 3. Identify source and target objects\n    source_object = None\n    target_object = None\n    \n    for obj in objects:\n        # Source has multiple non-background colors in its pixels\n        if len(obj['colors_in_pixels']) > 1:\n            source_object = obj\n        # Target has exactly one non-background color in its pixels\n        elif len(obj['colors_in_pixels']) == 1:\n            target_object = obj\n            \n    # Check if source and target were found (basic validation)\n    if source_object is None or target_object is None:\n        # If objects aren't clearly defined as source/target per rules, return original grid.\n        # This might happen if there are 0, 1, or >2 objects, or if color rules aren't met.\n        print(\"Warning: Could not definitively identify source and target objects based on color rules.\")\n        return output_grid\n\n    # 4. Determine pattern color (least frequent in source) and target color (single color in target)\n    pattern_color = min(source_object['colors_in_pixels'], key=source_object['colors_in_pixels'].get)\n    # Target color is the only key in its color counter\n    target_color = list(target_object['colors_in_pixels'].keys())[0] \n    \n    # 5. Get bounding boxes\n    src_r1, src_c1, src_r2, src_c2 = source_object['bbox']\n    tgt_r1, tgt_c1, tgt_r2, tgt_c2 = target_object['bbox']\n\n    # 6. Find relative coordinates of pattern pixels in source bbox\n    pattern_relative_coords = []\n    for r in range(src_r1, src_r2 + 1):\n        for c in range(src_c1, src_c2 + 1):\n             # Check if the pixel *within the bounding box* has the pattern color\n             # Important: check the input_grid value at (r,c), not just pixels belonging to the object\n             if input_grid[r, c] == pattern_color:\n                 rel_r = r - src_r1\n                 rel_c = c - src_c1\n                 pattern_relative_coords.append((rel_r, rel_c))\n\n    # 7. Apply pattern to target object in output grid\n    for rel_r, rel_c in pattern_relative_coords:\n        # Calculate corresponding target coordinates\n        tgt_r = tgt_r1 + rel_r\n        tgt_c = tgt_c1 + rel_c\n        \n        # Check if target coordinates are within grid bounds\n        if 0 <= tgt_r < rows and 0 <= tgt_c < cols:\n            # Check if the pixel at the target location in the *input* grid had the target_color\n            if input_grid[tgt_r, tgt_c] == target_color:\n                # Update the output grid\n                output_grid[tgt_r, tgt_c] = pattern_color\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3344,
    "candidates_token_count": 1721,
    "total_token_count": 5065,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.463474,
  "retries": null
}