{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies two distinct regions in the input grid based on color composition: a 'source' and a 'target'.\n1. Find all contiguous objects made of non-background (non-zero) pixels using 4-way adjacency.\n2. Analyze each object: determine the colors present and their counts, and calculate the object's bounding box.\n3. Identify the 'source' object: It must be the single object containing pixels of at least two different non-background colors. If zero or more than one such object exists, the transformation cannot be determined.\n4. Identify potential 'target' objects: These are all objects containing pixels of only one non-background color.\n5. Determine the 'pattern_color': This is the least frequent non-background color within the identified 'source' object.\n6. Select the final 'target' object: From the potential candidates, choose the one whose single color is *different* from the 'pattern_color'. If multiple candidates satisfy this, or none do, the transformation cannot be determined definitively (though this case might need refinement based on more examples). Assume only one valid target exists.\n7. Determine the 'target_color': This is the single color of the selected 'target' object.\n8. Map the pattern: Find the relative coordinates (row, col offsets from the top-left corner) of all pixels matching the 'pattern_color' *within the bounding box* of the 'source' object.\n9. Apply the pattern: For each relative coordinate derived in the previous step, calculate the corresponding absolute coordinate within the 'target' object's bounding box (by adding the offset to the target's top-left corner).\n10. Update the output grid: If the calculated target coordinate is within the grid bounds and the pixel at that location in the *input* grid has the 'target_color', change the color of the corresponding pixel in the *output* grid to the 'pattern_color'. Otherwise, leave the pixel unchanged.\n11. All other pixels in the output grid remain the same as the input grid.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of non-ignored colors in the grid.\n    An object is a set of connected pixels (4-way adjacency) of any non-ignored color.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background 0).\n\n    Returns:\n        list: A list of dictionaries, where each dict represents an object\n              and contains 'pixels' (a set of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if neighbor is not visited and not ignored color\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] != ignore_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'pixels': obj_pixels})\n                    \n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"\n    Calculates the bounding box for a set of pixels.\n\n    Args:\n        pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef analyze_object_properties(grid, obj):\n    \"\"\"\n    Analyzes the colors present within an object's pixels and finds its bounding box.\n    Adds 'colors_in_pixels' (Counter) and 'bbox' to the object dict.\n    \"\"\"\n    colors = Counter()\n    for r, c in obj['pixels']:\n        colors[grid[r, c]] += 1\n    obj['colors_in_pixels'] = colors\n    obj['bbox'] = get_bounding_box(obj['pixels'])\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern transfer transformation based on source/target object identification.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # 1. Find all distinct contiguous objects (ignoring background color 0)\n    objects = find_objects(input_grid, ignore_color=0)\n    \n    # 2. Analyze colors and bounding box for each object\n    for obj in objects:\n        analyze_object_properties(input_grid, obj)\n        \n    # 3. Identify source object (must be unique object with >1 color)\n    source_object = None\n    source_candidates = [obj for obj in objects if len(obj['colors_in_pixels']) > 1]\n    if len(source_candidates) == 1:\n        source_object = source_candidates[0]\n    else:\n        # If 0 or >1 multi-color objects found, cannot proceed with this logic\n        # print(f\"Warning: Found {len(source_candidates)} source candidates. Expected 1. Returning input.\")\n        return output_grid \n\n    # 4. Identify potential target objects (exactly 1 color)\n    target_candidates = [obj for obj in objects if len(obj['colors_in_pixels']) == 1]\n    \n    if not target_candidates:\n        # print(\"Warning: No target candidates found. Returning input.\")\n        return output_grid\n\n    # 5. Determine pattern color (least frequent non-background in source)\n    # Ensure colors_in_pixels is not empty (already guaranteed by source selection criteria)\n    pattern_color = min(source_object['colors_in_pixels'], key=source_object['colors_in_pixels'].get)\n\n    # 6. Select the actual target object (single color, different from pattern color)\n    final_target_object = None\n    valid_targets = []\n    for obj in target_candidates:\n        target_candidate_color = list(obj['colors_in_pixels'].keys())[0]\n        if target_candidate_color != pattern_color:\n            valid_targets.append(obj)\n            \n    if len(valid_targets) == 1:\n        final_target_object = valid_targets[0]\n    else:\n        # If 0 or >1 valid targets found based on color rule, cannot proceed\n        # print(f\"Warning: Found {len(valid_targets)} valid target candidates (color != pattern_color). Expected 1. Returning input.\")\n        return output_grid\n        \n    # 7. Determine target color\n    target_color = list(final_target_object['colors_in_pixels'].keys())[0] \n    \n    # 8. Get bounding boxes\n    src_r1, src_c1, src_r2, src_c2 = source_object['bbox']\n    tgt_r1, tgt_c1, tgt_r2, tgt_c2 = final_target_object['bbox']\n\n    # 9. Find relative coordinates of pattern pixels within the source bounding box\n    pattern_relative_coords = []\n    for r in range(src_r1, src_r2 + 1):\n        for c in range(src_c1, src_c2 + 1):\n             # Check the input_grid value at (r,c) within the source bbox\n             if 0 <= r < rows and 0 <= c < cols and input_grid[r, c] == pattern_color:\n                 rel_r = r - src_r1\n                 rel_c = c - src_c1\n                 pattern_relative_coords.append((rel_r, rel_c))\n\n    # 10. Apply pattern to target object in output grid\n    for rel_r, rel_c in pattern_relative_coords:\n        # Calculate corresponding target coordinates\n        tgt_r = tgt_r1 + rel_r\n        tgt_c = tgt_c1 + rel_c\n        \n        # 11. Update output grid if conditions met\n        # Check if target coordinates are within grid bounds\n        if 0 <= tgt_r < rows and 0 <= tgt_c < cols:\n            # Check if the pixel at the target location in the *input* grid had the target_color\n            if input_grid[tgt_r, tgt_c] == target_color:\n                # Update the output grid\n                output_grid[tgt_r, tgt_c] = pattern_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9810,
    "candidates_token_count": 2175,
    "total_token_count": 11985,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.22644,
  "retries": null
}