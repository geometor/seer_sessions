{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nHomogenizes the colors within the active segment (first to last non-white \npixel) of a single-row NumPy grid. It identifies the most frequent non-white \ncolor (dominant_color) within this segment. Then, it iterates through the segment \nin a copy of the grid, replacing any pixel that is not white (0) and not the \ndominant_color with the dominant_color. Pixels outside the segment (padding) \nand white pixels within the segment remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_active_segment(row):\n    \"\"\"\n    Finds the start and end indices (inclusive) of the segment containing \n    non-white pixels in a 1D NumPy array (row).\n\n    Args:\n        row (np.ndarray): A 1D NumPy array representing the pixel colors in the row.\n\n    Returns:\n        tuple: A tuple (start_index, end_index). Returns (None, None) if \n               no non-white pixels are found. Indices are inclusive.\n    \"\"\"\n    non_zero_indices = np.where(row != 0)[0] # Get indices of non-zero elements\n    \n    if len(non_zero_indices) == 0:\n        return None, None # No non-white pixels found\n        \n    start_index = non_zero_indices[0]\n    end_index = non_zero_indices[-1] # Inclusive end index\n    \n    return start_index, end_index\n\ndef find_dominant_color_in_segment(row, start_index, end_index):\n    \"\"\"\n    Determines the most frequent non-zero color within a specified segment \n    of a 1D NumPy array (row).\n\n    Args:\n        row (np.ndarray): The 1D NumPy array representing the full row.\n        start_index (int): The starting index of the segment (inclusive).\n        end_index (int): The ending index of the segment (inclusive).\n\n    Returns:\n        int or None: The most frequent non-zero color value within the segment, \n                     or None if the segment contains only zeros, is invalid, \n                     or if start/end indices are None.\n    \"\"\"\n    # Validate indices\n    if start_index is None or end_index is None or start_index > end_index:\n        return None \n\n    # Extract the segment using inclusive slicing for NumPy\n    # Need end_index + 1 because Python/NumPy slicing is exclusive at the end\n    segment = row[start_index : end_index + 1] \n    \n    # Filter out zeros (white) and count remaining colors\n    non_zero_segment = segment[segment != 0]\n\n    # If no non-zero colors were found after filtering\n    if len(non_zero_segment) == 0:\n        return None \n        \n    # Count frequencies\n    color_counts = Counter(non_zero_segment)\n        \n    # Find the most frequent color. most_common(1) returns a list [(color, count)]\n    dominant_color, _ = color_counts.most_common(1)[0]\n    return dominant_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the color normalization transformation to the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 1xN NumPy array representing the input row.\n\n    Returns:\n        np.ndarray: The transformed 1xN NumPy array.\n    \"\"\"\n    # Ensure input is a NumPy array and has at least one row\n    if not isinstance(input_grid, np.ndarray) or input_grid.ndim != 2 or input_grid.shape[0] == 0:\n        # Or handle potential 1D array input if needed based on testing environment\n        if isinstance(input_grid, np.ndarray) and input_grid.ndim == 1:\n             # Reshape 1D array to 2D (1xN)\n             input_grid = input_grid.reshape(1, -1)\n        else:\n             # Return empty array or raise error for unexpected input types/shapes\n             print(f\"Warning: Unexpected input type/shape: {type(input_grid)}, shape: {getattr(input_grid, 'shape', 'N/A')}\")\n             # Returning input shape might be safer if empty is wrong\n             return np.array([[]], dtype=int) if input_grid.ndim == 2 else np.array([], dtype=int)\n\n\n    # Handle empty row case specifically if shape is (1, 0)\n    if input_grid.shape[1] == 0:\n        return np.array([[]], dtype=int) # Return 1x0 array\n\n    # Select the first (and only) row\n    input_row = input_grid[0]\n\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    output_row = output_grid[0] # Get a reference to the row in the copy\n\n    # 1. Identify the active segment (indices of first to last non-white pixels)\n    start_index, end_index = find_active_segment(input_row)\n\n    # 2. If no non-white segment exists (row is all white or empty), return the original copy\n    if start_index is None:\n        return output_grid \n\n    # 3. Determine the dominant color within the identified active segment\n    dominant_color = find_dominant_color_in_segment(input_row, start_index, end_index)\n    \n    # 4. If a dominant color is found, normalize the segment in the output row\n    if dominant_color is not None:\n        # Iterate *only* through the indices corresponding to the active segment (inclusive)\n        for i in range(start_index, end_index + 1):\n            # Check if the current pixel in the segment is not white (0) \n            # AND is not the dominant color.\n            if output_row[i] != 0 and output_row[i] != dominant_color:\n                 # Replace this 'impurity' pixel with the dominant color\n                output_row[i] = dominant_color\n                # Pixels that are 0 or already the dominant color within the segment are unchanged.\n                \n    # 5. Return the modified output grid. Pixels outside the segment (padding) were never touched.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10867,
    "candidates_token_count": 1472,
    "total_token_count": 12339,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.702617,
  "retries": 1
}