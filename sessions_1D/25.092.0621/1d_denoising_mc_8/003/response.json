{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy # To ensure original input isn't modified if returned directly\n\n\"\"\"\nTransformation Rule:\n\n1. Determine the dimensions (height `H` and width `W`) of the input grid.\n2. Check if the grid represents a line: either `H=1` and `W>0` (row vector) or `W=1` and `H>0` (column vector).\n3. If it's a row vector (`H=1`), extract the first (only) row as the `linear_sequence`.\n4. If it's a column vector (`W=1`), extract the first (only) column as the `linear_sequence` (take the first element from each row).\n5. If the grid is not a row or column vector (e.g., empty, 1x1, or multi-dimensional), return the input grid unchanged.\n6. Find the index of the first non-white (non-zero) pixel (`start_index`) and the last non-white pixel (`end_index`) in the `linear_sequence`.\n7. If no non-white pixels are found (`start_index` is None), return the original input grid unchanged.\n8. Extract the leading white segment (pixels before `start_index`), the central segment (pixels from `start_index` to `end_index` inclusive), and the trailing white segment (pixels after `end_index`) from the `linear_sequence`.\n9. Count the frequency of each color within the `central_segment`.\n10. Identify the `dominant_color` (the color with the highest frequency).\n11. Create a `new_central_segment` of the same length as the original `central_segment`, filled entirely with the `dominant_color`.\n12. Construct the `output_sequence` by concatenating the `leading_white_segment`, the `new_central_segment`, and the `trailing_white_segment`.\n13. Construct the `output_grid` by placing the `output_sequence` back into the original format:\n    *   If the input was a row vector (1xN), the `output_grid` is `[output_sequence]`.\n    *   If the input was a column vector (Nx1), the `output_grid` is `[[pixel] for pixel in output_sequence]`.\n14. Return the `output_grid`.\n\"\"\"\n\ndef find_central_segment_indices(input_list):\n    \"\"\"\n    Finds the start and end indices of the first contiguous block of non-zero values.\n\n    Args:\n        input_list: A list of integers representing colors.\n\n    Returns:\n        A tuple (start_index, end_index).\n        Returns (None, None) if no non-zero elements are found.\n        start_index is the index of the first non-zero element.\n        end_index is the index of the last non-zero element.\n    \"\"\"\n    start_index = None\n    end_index = None\n    n = len(input_list)\n\n    # Find the first non-zero element\n    for i in range(n):\n        if input_list[i] != 0:\n            start_index = i\n            break\n\n    # If no non-zero element was found, return None, None\n    if start_index is None:\n        return None, None\n\n    # Find the last non-zero element by searching from the end\n    # Note: end_index should also be start_index if only one non-zero element exists\n    for i in range(n - 1, start_index - 1, -1):\n         if input_list[i] != 0:\n            end_index = i\n            break\n            \n    # This check should technically not be needed if start_index is not None,\n    # but added for robustness.\n    if end_index is None: \n        return None, None\n        \n    return start_index, end_index\n\ndef get_dominant_color(segment):\n    \"\"\"\n    Finds the most frequent non-zero color in a list segment.\n\n    Args:\n        segment: A list of integers representing colors.\n\n    Returns:\n        The integer value of the most frequent non-zero color.\n        Returns None if the segment is empty or contains only zeros.\n    \"\"\"\n    if not segment:\n        return None\n\n    # Filter out zeros, though the central segment shouldn't contain them by definition\n    non_zero_segment = [color for color in segment if color != 0]\n\n    if not non_zero_segment:\n        return None # Should not happen if segment comes from find_central_segment_indices\n\n    counts = collections.Counter(non_zero_segment)\n    # Find the color with the maximum count. If ties, most_common returns one arbitrarily.\n    dominant_color = counts.most_common(1)[0][0]\n    return dominant_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    \n    # Ensure input is not empty\n    if not input_grid or not input_grid[0]:\n        return copy.deepcopy(input_grid) # Return copy if empty\n\n    # 1. Determine dimensions\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # 2. Check if the grid represents a line (row or column vector)\n    is_row_vector = height == 1 and width > 0\n    is_col_vector = width == 1 and height > 0\n    \n    linear_sequence = []\n\n    # 3. Extract sequence if row vector\n    if is_row_vector:\n        linear_sequence = input_grid[0]\n    # 4. Extract sequence if column vector\n    elif is_col_vector:\n        linear_sequence = [input_grid[r][0] for r in range(height)]\n    # 5. If not a line, return original grid\n    else:\n        # Handles 1x1 grids and multi-dimensional grids\n        return copy.deepcopy(input_grid) \n\n    # 6. Find the boundaries of the central non-white segment\n    start_index, end_index = find_central_segment_indices(linear_sequence)\n\n    # 7. If no non-white pixels found, return original grid\n    if start_index is None:\n        return copy.deepcopy(input_grid)\n\n    # 8. Extract segments\n    leading_white_segment = linear_sequence[:start_index]\n    central_segment_input = linear_sequence[start_index : end_index + 1]\n    trailing_white_segment = linear_sequence[end_index + 1:]\n\n    # 9 & 10. Find the dominant color in the central segment\n    dominant_color = get_dominant_color(central_segment_input)\n\n    # Defensive check - should have a dominant color if start_index was found\n    if dominant_color is None:\n         print(\"Warning: Could not determine dominant color despite finding a central segment.\")\n         return copy.deepcopy(input_grid) \n\n    # 11. Create the new central segment filled with the dominant color\n    central_segment_output_len = len(central_segment_input)\n    new_central_segment = [dominant_color] * central_segment_output_len\n\n    # 12. Construct the output sequence\n    output_sequence = leading_white_segment + new_central_segment + trailing_white_segment\n\n    # 13. Reconstruct the output grid in the original format\n    output_grid = []\n    if is_row_vector:\n        output_grid = [output_sequence]\n    elif is_col_vector:\n        output_grid = [[pixel] for pixel in output_sequence]\n        \n    # 14. Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10880,
    "candidates_token_count": 1787,
    "total_token_count": 12667,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.452209,
  "retries": 1
}