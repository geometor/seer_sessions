{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify the contiguous segment of non-background (non-white/0) pixels in the input row.\nDetermine the most frequent color within this segment (the dominant color).\nReplace all non-background pixels within the segment that are not the dominant color with the dominant color.\nLeave background pixels unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_active_segment(row, background_color=0):\n    \"\"\"Finds the start and end indices of the contiguous non-background segment.\"\"\"\n    non_background_indices = np.where(row != background_color)[0]\n    if len(non_background_indices) == 0:\n        return None, None # No active segment\n    start_index = non_background_indices[0]\n    end_index = non_background_indices[-1]\n    return start_index, end_index\n\ndef find_dominant_color(segment):\n    \"\"\"Finds the most frequent color in a segment.\"\"\"\n    if len(segment) == 0:\n        return None # Should not happen if segment is valid\n    \n    counts = Counter(segment)\n    # Find the color with the maximum count. If ties, Counter returns one arbitrarily.\n    # In case of ties between background and non-background, prefer non-background.\n    # The prompt implies finding the dominant non-background color,\n    # but let's consider if the background itself could be dominant within the segment if mixed.\n    # Re-reading the prompt: \"dominant color\" refers to the most frequent *within the non-background segment*.\n    # So, we should technically filter out the background color before counting if it exists inside the segment.\n    # However, the examples suggest the segment *only* contains non-backgrounds once identified.\n    # Let's stick to the simplest interpretation: most frequent color *in the slice*.\n    \n    # Check if only one color exists (besides potential background infiltrators, though unlikely based on examples)\n    unique_colors = np.unique(segment)\n    if len(unique_colors) == 1:\n        return unique_colors[0]\n        \n    # Use Counter for frequency\n    counts = Counter(segment)\n    # Find the color with the highest frequency\n    dominant_color = counts.most_common(1)[0][0]\n    \n    # Refined approach based on prompt \"most frequent color within the non-background segment\":\n    # Filter out background color *if* present within the segment before counting.\n    # Although based on examples, the segment is purely non-background. Let's assume that holds.\n    \n    non_background_pixels = [p for p in segment if p != 0] # Filter background just in case\n    if not non_background_pixels:\n         return None # Segment was all background? Error condition.\n         \n    counts = Counter(non_background_pixels)\n    if not counts:\n        return None # Segment only contained background?\n        \n    # Find the color with the maximum count among non-background colors\n    dominant_color = counts.most_common(1)[0][0]\n    \n    return dominant_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Ensure input is a numpy array\n    input_grid = np.array(input_grid)\n    \n    # Create a copy to modify\n    output_grid = np.copy(input_grid)\n    \n    # Assuming the input is always a single row (1xN or just N)\n    # If it's 2D (1xN), extract the first row\n    if input_grid.ndim == 2 and input_grid.shape[0] == 1:\n        row = output_grid[0]\n    elif input_grid.ndim == 1:\n         row = output_grid\n    else:\n        # Handle potential multi-row grids if necessary, though examples are 1D\n        # For now, assume it won't happen based on examples or raise error\n        raise ValueError(\"Input grid has unexpected dimensions. Expected 1D or 1xN.\")\n\n    background_color = 0\n\n    # 1. Find the active segment\n    start_index, end_index = find_active_segment(row, background_color)\n\n    # If no active segment found (all background), return the original grid\n    if start_index is None:\n        return output_grid\n\n    # 2. Extract the pixels within the active segment\n    # Note: end_index is inclusive, so slice up to end_index + 1\n    active_segment_pixels = row[start_index : end_index + 1]\n\n    # 3. Find the dominant color in the active segment\n    # We only care about non-background colors for dominance\n    non_background_segment_pixels = [p for p in active_segment_pixels if p != background_color]\n    if not non_background_segment_pixels:\n         # This case should theoretically not happen if start/end indices were found\n         return output_grid # Or raise error\n         \n    dominant_color = find_dominant_color(non_background_segment_pixels) # Pass only non-backgrounds\n\n    if dominant_color is None:\n         # Should not happen with valid segment\n         return output_grid # Or raise error\n\n    # 4. Iterate through the active segment in the output row and replace minority colors\n    for i in range(start_index, end_index + 1):\n        # Only change non-background pixels\n        if row[i] != background_color:\n            # If the pixel is not the dominant color, change it\n            if row[i] != dominant_color:\n                row[i] = dominant_color\n                \n    # If the original input was 2D (1xN), ensure output is also 2D\n    if input_grid.ndim == 2 and input_grid.shape[0] == 1:\n         return output_grid # output_grid is already 2D as it's a copy\n    elif input_grid.ndim == 1:\n         return row # Return the modified 1D array\n\n    # Fallback, should have returned already\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2089,
    "candidates_token_count": 1411,
    "total_token_count": 3500,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.359205,
  "retries": 1
}