{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 1D grid (represented as a list of lists with one inner list) by identifying contiguous segments of non-background (non-zero) pixels. For each segment, it determines the most frequent color (majority color). It then constructs the output grid by replacing all pixels within each segment with that segment's majority color. Background (zero) pixels remain unchanged. The output format matches the input format (list of lists).\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_non_background_segments(grid_1d):\n    \"\"\"\n    Finds contiguous segments of non-zero pixels in a 1D numpy array.\n\n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A list of tuples, where each tuple contains (start_index, end_index) \n        for a non-background segment. end_index is exclusive.\n        Returns empty list if no non-background pixels are found.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_index = -1\n    # Iterate through the grid with index\n    for i, pixel in enumerate(grid_1d):\n        if pixel != 0 and not in_segment:\n            # Start of a new segment\n            in_segment = True\n            start_index = i\n        elif pixel == 0 and in_segment:\n            # End of the current segment (found a background pixel)\n            in_segment = False\n            segments.append((start_index, i)) \n            start_index = -1\n            \n    # Handle the case where a segment runs to the very end of the grid\n    if in_segment:\n        segments.append((start_index, len(grid_1d)))\n        \n    return segments\n\ndef get_majority_color(segment_pixels):\n    \"\"\"\n    Determines the most frequent color in a numpy array of pixels. \n    Handles empty segments and uses Counter's default tie-breaking.\n\n    Args:\n        segment_pixels: A numpy array of pixel values from a segment.\n\n    Returns:\n        The integer value of the most frequent color. Returns None if segment is empty.\n    \"\"\"\n    # Check if the segment is empty\n    if not segment_pixels.size > 0:\n        return None\n    \n    # Count occurrences of each color\n    color_counts = Counter(segment_pixels)\n    \n    # Check if Counter is empty (shouldn't happen if segment_pixels wasn't empty)\n    if not color_counts:\n        return None\n        \n    # Find the most common color. most_common(1) returns list: [(color, count)]\n    # In case of ties, most_common returns one of the tied elements arbitrarily.\n    majority_color, _ = color_counts.most_common(1)[0]\n    return majority_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid (expected to have one inner list).\n\n    Returns:\n        A list of lists representing the transformed grid, matching the input format.\n    \"\"\"\n    \n    # --- Input Handling and Initialization ---\n    # Validate input format - expect list of lists\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list):\n        raise ValueError(\"Input grid must be a non-empty list of lists.\")\n        \n    # Expecting a single row based on examples\n    if len(input_grid) > 1:\n         # For this specific problem, only handle single-row inputs.\n         # A more general solution might loop through rows or handle 2D differently.\n         print(\"Warning: Input grid has multiple rows, only processing the first row.\")\n         # Or raise ValueError(\"Input grid has multiple rows, expecting a single row for this task.\")\n\n    # Extract the first (and assumed only) row and convert to numpy array\n    grid_1d_original = np.array(input_grid[0], dtype=int)\n    \n    # Initialize the output grid as a copy of the original 1D data\n    output_grid_np = grid_1d_original.copy()\n\n    # --- Core Transformation Logic ---\n    # Step 1: Identify all non-background (non-zero) segments in the original grid\n    segments = find_non_background_segments(grid_1d_original)\n\n    # Step 2: Process each identified segment\n    for start_idx, end_idx in segments:\n        # Step 2a: Extract the pixels belonging to this segment from the *original* grid\n        segment_pixels = grid_1d_original[start_idx:end_idx]\n        \n        # Step 2b: Determine the majority color for this segment\n        majority_color = get_majority_color(segment_pixels)\n        \n        # Step 2c: If a majority color is found (i.e., segment was not empty)\n        if majority_color is not None:\n            # Step 2d: Replace all pixels in this segment's range *in the output grid*\n            # with the determined majority color.\n            output_grid_np[start_idx:end_idx] = majority_color\n            \n    # --- Output Formatting ---\n    # Convert the final numpy array back to the required list of lists format\n    output_grid_list_of_lists = [output_grid_np.tolist()]\n    \n    return output_grid_list_of_lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13473,
    "candidates_token_count": 1260,
    "total_token_count": 14733,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 13.932133,
  "retries": 1
}