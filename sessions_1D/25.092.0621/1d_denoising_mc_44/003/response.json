{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 1D input grid by identifying contiguous segments of non-background (non-zero) pixels. \nFor each segment, it determines the most frequent color (majority color). \nIt then constructs the output grid by replacing all pixels within each segment with that segment's majority color. \nBackground (zero) pixels remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_non_background_segments(grid_1d):\n    \"\"\"\n    Finds contiguous segments of non-zero pixels in a 1D numpy array.\n\n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A list of tuples, where each tuple contains (start_index, end_index) \n        for a non-background segment. end_index is exclusive.\n        Returns empty list if no non-background pixels are found.\n    \"\"\"\n    segments = []\n    in_segment = False\n    start_index = -1\n    # Iterate through the grid with index\n    for i, pixel in enumerate(grid_1d):\n        if pixel != 0 and not in_segment:\n            # Start of a new segment\n            in_segment = True\n            start_index = i\n        elif pixel == 0 and in_segment:\n            # End of the current segment (found a background pixel)\n            in_segment = False\n            segments.append((start_index, i)) \n            start_index = -1\n            \n    # Handle the case where a segment runs to the very end of the grid\n    if in_segment:\n        segments.append((start_index, len(grid_1d)))\n        \n    return segments\n\ndef get_majority_color(segment_pixels):\n    \"\"\"\n    Determines the most frequent color in a numpy array of pixels.\n\n    Args:\n        segment_pixels: A numpy array of pixel values from a segment.\n\n    Returns:\n        The integer value of the most frequent color. Returns None if segment is empty.\n    \"\"\"\n    # Check if the segment is empty\n    if not segment_pixels.size > 0:\n        return None\n    \n    # Count occurrences of each color\n    color_counts = Counter(segment_pixels)\n    \n    # Check if Counter is empty (shouldn't happen if segment_pixels wasn't empty, but good practice)\n    if not color_counts:\n        return None\n        \n    # Find the most common color. most_common(1) returns list: [(color, count)]\n    majority_color, _ = color_counts.most_common(1)[0]\n    return majority_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists or a list representing the input grid. \n                    Expected to represent a single row based on examples.\n\n    Returns:\n        A list of lists or a list (matching input format) representing the transformed grid.\n    \"\"\"\n    \n    # --- Input Handling ---\n    # Determine if input is list of lists (e.g., [[1, 2, 3]]) or flat list (e.g., [1, 2, 3])\n    is_list_of_lists = isinstance(input_grid, list) and len(input_grid) > 0 and isinstance(input_grid[0], list)\n    \n    # Convert input to a 1D numpy array for easier processing\n    if is_list_of_lists:\n        # Assuming it's a single row represented as a list containing one list\n        if len(input_grid) == 1:\n             grid_1d = np.array(input_grid[0], dtype=int)\n        else:\n             # Handle unexpected multi-row input, maybe raise error or process first row?\n             # For now, assume single row based on training examples\n             raise ValueError(\"Input grid has multiple rows, expecting a single row.\")\n    elif isinstance(input_grid, list):\n         # Input is already a flat list\n         grid_1d = np.array(input_grid, dtype=int)\n    else:\n         # Handle other unexpected types\n         raise TypeError(\"Input grid must be a list or list of lists.\")\n\n    # --- Core Transformation Logic ---\n    # Initialize output_grid as a copy of the input numpy array\n    output_grid_np = grid_1d.copy()\n\n    # Step 1: Identify all non-background (non-zero) segments\n    segments = find_non_background_segments(grid_1d)\n\n    # Step 2: Process each segment\n    for start_idx, end_idx in segments:\n        # Step 2a: Extract the pixels belonging to the current segment from the *original* grid\n        segment_pixels = grid_1d[start_idx:end_idx]\n        \n        # Step 2b: Determine the majority color for this segment\n        majority_color = get_majority_color(segment_pixels)\n        \n        # Step 2c: If a majority color is found (segment was not empty)\n        if majority_color is not None:\n            # Step 2d: Replace all pixels in this segment's range in the *output* grid\n            # with the majority color\n            output_grid_np[start_idx:end_idx] = majority_color\n            \n    # --- Output Formatting ---\n    # Convert the transformed numpy array back to the original input format\n    if is_list_of_lists:\n        # Return as list of lists\n        return [output_grid_np.tolist()]\n    else:\n        # Return as flat list\n        return output_grid_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6885,
    "candidates_token_count": 1299,
    "total_token_count": 8184,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.07764,
  "retries": 1
}