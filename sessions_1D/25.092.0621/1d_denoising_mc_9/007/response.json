{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nTransforms a single-row grid by identifying the contiguous segment of non-white \npixels (pixels with value > 0). It then determines the most frequent color \nwithin that segment (dominant color), handling ties by choosing the color that \nappears first in the segment among those with the highest frequency. Finally, it \nreplaces all pixels within that segment's original index range in the output grid \nwith the determined dominant color. Pixels outside this segment (typically \nwhite background pixels with value 0) remain unchanged.\n\"\"\"\n\ndef find_non_white_segment_1d(grid_row):\n    \"\"\"\n    Finds the start and end column indices of the contiguous non-white segment in a 1D row.\n\n    Args:\n        grid_row (np.array): A 1D numpy array representing a row of pixels.\n\n    Returns:\n        tuple: (start_index, end_index) if a segment is found, otherwise (None, None).\n    \"\"\"\n    # Find indices of all non-zero elements\n    non_white_indices = np.where(grid_row != 0)[0]\n    \n    # If no non-zero elements, return None\n    if len(non_white_indices) == 0:\n        return None, None \n\n    # Determine the start and end of the segment based on min and max indices\n    start_index = np.min(non_white_indices)\n    end_index = np.max(non_white_indices)\n\n    # Return indices as standard Python ints\n    return int(start_index), int(end_index) \n\ndef find_dominant_color_segment(segment):\n    \"\"\"\n    Finds the most frequent color in a given segment (list or array).\n    Handles ties by returning the first encountered color with the maximum frequency \n    in the original segment order.\n\n    Args:\n        segment (list or np.array): The pixels within the segment.\n\n    Returns:\n        int: The dominant color. Returns 0 if the segment is empty.\n    \"\"\"\n    # Ensure segment is a list for consistent processing\n    if not isinstance(segment, list):\n        segment = list(segment) \n\n    # Handle empty segment case\n    if not segment:\n        return 0 \n\n    # Count frequencies of each color\n    color_counts = Counter(segment)\n\n    # Find the maximum frequency count among all colors present\n    max_count = 0\n    if color_counts: # Check if counter is not empty\n      max_count = max(color_counts.values())\n    else: \n        return segment[0] if segment else 0 # Return first element or 0 if truly empty\n\n    # Iterate through the original segment to find the first color that has the max count\n    dominant_color = segment[0] # Default guess / handles segment with one element\n    for color in segment:\n        if color_counts[color] == max_count:\n            dominant_color = color\n            break # Stop as soon as the first dominant color is found\n\n    return dominant_color\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list): A list containing a single list of integers (the grid row).\n                           Example: [[0, 7, 7, 1, 7, 0]]\n\n    Returns:\n        list: A list containing the single transformed grid row.\n              Example: [[0, 7, 7, 7, 7, 0]]\n    \"\"\"\n    # --- Input Validation and Setup ---\n    # Ensure input is roughly the expected format (list of lists with at least one row)\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list):\n        # Return a deep copy for safety in case of unexpected input format\n        return copy.deepcopy(input_grid) \n\n    # Extract the first (and assumed only) row as a numpy array\n    try:\n        grid_row_np = np.array(input_grid[0], dtype=int) \n    except IndexError:\n         # Handle empty input grid row case e.g., [[]]\n         return copy.deepcopy(input_grid) \n\n    # --- Identify Segment ---\n    # Find the start and end indices of the non-white segment in the row\n    start_index, end_index = find_non_white_segment_1d(grid_row_np)\n\n    # If no segment found, return the input grid unchanged (but as a deep copy)\n    if start_index is None:\n        return copy.deepcopy(input_grid)\n\n    # --- Analyze Segment ---\n    # Extract the segment pixels from the original numpy row\n    # Segment includes pixels from start_index to end_index (inclusive)\n    segment_pixels = grid_row_np[start_index : end_index + 1]\n\n    # Find the dominant color in the extracted segment\n    dominant_color = find_dominant_color_segment(segment_pixels)\n\n    # --- Modify Output Grid ---\n    # Create a mutable copy of the original numpy row to modify\n    output_row_np = grid_row_np.copy()\n\n    # Replace colors in the copied numpy row within the segment boundaries\n    # using numpy slicing for efficiency\n    output_row_np[start_index : end_index + 1] = dominant_color\n         \n    # --- Format Output ---\n    # Convert the modified numpy row back to a list\n    output_row_list = output_row_np.tolist()\n\n    # Wrap the row list in another list to match the required output format [[...]]\n    output_grid = [output_row_list]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11641,
    "candidates_token_count": 1315,
    "total_token_count": 12956,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.146097,
  "retries": 1
}