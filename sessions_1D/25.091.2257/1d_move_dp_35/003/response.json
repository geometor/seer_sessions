{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms a 1D input grid by:\n1. Identifying a single 'anchor' pixel (magenta, color 6) which remains stationary.\n2. Identifying a contiguous horizontal block of a single color (neither white 0 nor magenta 6).\n3. Shifting this block horizontally to the right so that its rightmost pixel is positioned immediately to the left of the anchor pixel.\n4. Filling the original location of the shifted block with the background color (white, 0).\nThe output grid has the same dimensions as the input grid.\n\"\"\"\n\ndef find_pixel_index(grid: np.ndarray, color: int) -> Optional[int]:\n    \"\"\"\n    Finds the index of the first occurrence of a specific color pixel in a 1D grid.\n\n    Args:\n        grid: The 1D numpy array representing the grid.\n        color: The color value to search for.\n\n    Returns:\n        The index of the first pixel with the specified color, or None if not found.\n    \"\"\"\n    indices = np.where(grid == color)[0]\n    if len(indices) > 0:\n        return indices[0]\n    return None\n\ndef find_block(grid: np.ndarray, exclude_colors: List[int]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the first contiguous block of pixels in a 1D grid whose color is not in exclude_colors.\n\n    Args:\n        grid: The 1D numpy array representing the grid.\n        exclude_colors: A list of color values to ignore when searching for the block.\n\n    Returns:\n        A tuple (start_index, end_index_exclusive, length, color) of the block,\n        or None if no such block is found.\n    \"\"\"\n    block_color = -1\n    start_index = -1\n    for i, pixel_color in enumerate(grid):\n        is_excluded = pixel_color in exclude_colors\n        if not is_excluded:\n            # Found a potential block pixel\n            if start_index == -1:\n                # Start of a new block\n                start_index = i\n                block_color = pixel_color\n            elif pixel_color != block_color:\n                # Found a different non-excluded color, meaning the previous block ended.\n                # This scenario assumes only one movable block exists per grid as per examples.\n                end_index = i\n                length = end_index - start_index\n                return start_index, end_index, length, block_color\n        elif start_index != -1:\n            # Found an excluded color after a block started, meaning the block ended.\n            end_index = i\n            length = end_index - start_index\n            return start_index, end_index, length, block_color\n\n    # Check if a block was found and ran to the end of the grid\n    if start_index != -1:\n        end_index = len(grid)\n        length = end_index - start_index\n        return start_index, end_index, length, block_color\n\n    # No block found\n    return None\n\n\ndef transform(input_grid: List[int]) -> List[int]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list representing the 1D input grid.\n\n    Returns:\n        A list representing the transformed 1D output grid.\n    \"\"\"\n    # Convert input list to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    grid_length = len(grid_np)\n    background_color = 0\n    anchor_color = 6\n\n    # --- Initialize Output ---\n    # Create a new grid filled with the background color\n    output_grid_np = np.full(grid_length, background_color, dtype=int)\n\n    # --- Identify Anchor ---\n    # Locate the index of the magenta anchor pixel\n    anchor_index = find_pixel_index(grid_np, anchor_color)\n    if anchor_index is None:\n        # Handle error: anchor pixel not found (should not happen based on examples)\n        # Returning the input or an empty grid might be options depending on requirements.\n        print(f\"Error: Anchor pixel (color {anchor_color}) not found.\")\n        return input_grid # Return original grid as fallback\n\n    # --- Place Anchor ---\n    # Copy the anchor pixel to the output grid at its original position\n    output_grid_np[anchor_index] = anchor_color\n\n    # --- Identify Block ---\n    # Find the movable block (excluding background and anchor colors)\n    block_info = find_block(grid_np, [background_color, anchor_color])\n    if block_info is None:\n         # Handle error: movable block not found (should not happen based on examples)\n        print(f\"Error: Movable block not found (excluding colors {background_color}, {anchor_color}).\")\n        # If no block, the output is just the background + anchor\n        return output_grid_np.tolist()\n\n    block_start_in, block_end_in, block_length, block_color = block_info\n\n    # --- Calculate New Position ---\n    # Determine the target start index for the block in the output grid.\n    # The block ends just before the anchor pixel.\n    new_block_end_exclusive = anchor_index\n    new_block_start = new_block_end_exclusive - block_length\n\n    # --- Place Block ---\n    # Fill the calculated position in the output grid with the block's color.\n    # Ensure the calculated start index is valid.\n    if new_block_start >= 0:\n        output_grid_np[new_block_start:new_block_end_exclusive] = block_color\n    else:\n        # This case means the block would shift partially or fully off the left edge.\n        # Based on examples, this might not occur, but handle defensively.\n        # Place only the part of the block that fits on the grid.\n        actual_start = 0\n        visible_length = new_block_end_exclusive - actual_start\n        if visible_length > 0:\n             output_grid_np[actual_start:new_block_end_exclusive] = block_color\n        print(f\"Warning: Block (color {block_color}) shifted partially off-grid.\")\n\n\n    # --- Finalize ---\n    # Convert the numpy array back to a list for the final output\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7654,
    "candidates_token_count": 1514,
    "total_token_count": 9168,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.05832,
  "retries": 1
}