{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input 1xN NumPy array by identifying a specific adjacent pattern:\nthe first contiguous block of identical non-white pixels (BlockA), immediately\nfollowed by a contiguous block of white (0) pixels (BlockB), immediately followed\nby a maroon (9) pixel (Separator). If this pattern (BlockA -> BlockB -> Separator)\nis found, the positions of BlockA and BlockB are swapped, while the portion of\nthe sequence before BlockA (Prefix) and the portion including and after the\nSeparator (Suffix) remain in their relative positions. The output is returned as\na 1xN NumPy array. If the pattern is not found, the original input array is\nreturned unchanged.\n\"\"\"\n\nimport numpy as np\nfrom typing import Optional, Tuple\n\n# Define color constants\nWHITE = 0\nMAROON = 9\n\ndef find_first_non_white_block(sequence: np.ndarray) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the start index, end index, and color of the first contiguous block\n    of non-white pixels in a 1D NumPy array.\n\n    Args:\n        sequence: A 1D NumPy array representing the pixel sequence.\n\n    Returns:\n        A tuple (start_index, end_index, color) if found, otherwise None.\n    \"\"\"\n    n = sequence.shape[0]\n    for i in range(n):\n        if sequence[i] != WHITE:\n            start_index = i\n            color = sequence[i]\n            end_index = i\n            # Extend the block as long as the color matches\n            while end_index + 1 < n and sequence[end_index + 1] == color:\n                end_index += 1\n            return start_index, end_index, color\n    return None # No non-white block found\n\ndef find_following_white_block(sequence: np.ndarray, start_search_index: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the start and end index of a contiguous white block starting\n    immediately after start_search_index in a 1D NumPy array.\n\n    Args:\n        sequence: A 1D NumPy array representing the pixel sequence.\n        start_search_index: The index immediately after the preceding block.\n\n    Returns:\n        A tuple (start_index, end_index) if a white block is found immediately\n        following, otherwise None.\n    \"\"\"\n    n = sequence.shape[0]\n    if start_search_index >= n or sequence[start_search_index] != WHITE:\n        return None # No white block starts immediately after\n\n    start_index = start_search_index\n    end_index = start_index\n    # Extend the block as long as it's white\n    while end_index + 1 < n and sequence[end_index + 1] == WHITE:\n        end_index += 1\n    return start_index, end_index\n\ndef check_separator(sequence: np.ndarray, index: int) -> bool:\n    \"\"\"\n    Checks if the pixel at the given index in a 1D NumPy array is the\n    MAROON separator.\n\n    Args:\n        sequence: A 1D NumPy array representing the pixel sequence.\n        index: The index to check.\n\n    Returns:\n        True if the pixel at the index is MAROON, False otherwise.\n    \"\"\"\n    return index < sequence.shape[0] and sequence[index] == MAROON\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the block swapping transformation based on the identified pattern.\n\n    Args:\n        input_grid: A 1xN NumPy array representing the input grid.\n\n    Returns:\n        A 1xN NumPy array representing the transformed grid, or the original\n        input_grid if the pattern is not found or the input is invalid.\n    \"\"\"\n    # --- Input Validation ---\n    if not isinstance(input_grid, np.ndarray) or input_grid.ndim != 2 or input_grid.shape[0] != 1:\n        # Return input if it's not a valid 1xN NumPy array\n        print(f\"Invalid input format: shape={input_grid.shape}, type={type(input_grid)}\")\n        return input_grid\n\n    sequence = input_grid[0] # Extract the 1D sequence\n    n = sequence.shape[0]\n\n    # --- Find Pattern: BlockA -> BlockB -> Separator ---\n\n    # 1. Find BlockA (first non-white block)\n    block_a_info = find_first_non_white_block(sequence)\n    if block_a_info is None:\n        # BlockA not found, pattern fails\n        return input_grid\n\n    start_a, end_a, _ = block_a_info\n    block_a = sequence[start_a : end_a + 1]\n\n    # 2. Find BlockB (white block immediately after BlockA)\n    block_b_info = find_following_white_block(sequence, end_a + 1)\n    if block_b_info is None:\n        # BlockB not found immediately after BlockA, pattern fails\n        return input_grid\n\n    start_b, end_b = block_b_info\n    block_b = sequence[start_b : end_b + 1]\n\n    # 3. Check for Separator immediately after BlockB\n    separator_index = end_b + 1\n    if not check_separator(sequence, separator_index):\n        # Separator not found immediately after BlockB, pattern fails\n        return input_grid\n\n    # --- Pattern Found: Perform Transformation ---\n\n    # 4. Identify Prefix (before BlockA)\n    prefix = sequence[:start_a]\n\n    # 5. Identify Suffix (Separator and onwards)\n    suffix = sequence[separator_index:]\n\n    # 6. Reconstruct the sequence with swapped blocks\n    # Use np.concatenate for array joining\n    output_sequence = np.concatenate((prefix, block_b, block_a, suffix))\n\n    # 7. Reshape back to 1xN and return\n    # Ensure the output has the same shape as the input (1, N)\n    output_grid = output_sequence.reshape(1, -1)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6832,
    "candidates_token_count": 1451,
    "total_token_count": 8283,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.413838,
  "retries": 1
}