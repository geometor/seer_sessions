{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a contiguous horizontal block of a single color (not white 0 or azure 8) \nand a single azure (8) pixel in a 1D input grid.\nMoves the colored block horizontally to the right so that its rightmost pixel \nis immediately adjacent to the left of the azure pixel. \nThe background remains white (0), and the azure pixel's position is fixed.\nThe output grid has the same dimensions as the input grid.\n\"\"\"\n\n# Helper function to find the index of the first pixel of a given color in a 1D array\ndef find_pixel_index(grid_1d, color):\n    \"\"\"Finds the index of the first occurrence of a specific color.\"\"\"\n    indices = np.where(grid_1d == color)[0]\n    if len(indices) > 0:\n        return indices[0] # Return the index of the first occurrence\n    return -1 # Indicate not found\n\n# Helper function to find the contiguous block of the main color (non-0, non-8)\ndef find_colored_block(grid_1d):\n    \"\"\"\n    Finds the main colored block (non-0, non-8).\n    Returns its color, start index, and length.\n    Returns None if no such block is found.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_length = 0\n    in_block = False\n    background_color = 0\n    target_color = 8\n\n    for i, pixel in enumerate(grid_1d):\n        # Check if the pixel is part of the movable block\n        is_block_pixel = (pixel != background_color and pixel != target_color)\n\n        if is_block_pixel:\n            if not in_block:\n                # Found the start of the block\n                block_color = pixel\n                block_start = i\n                block_length = 1\n                in_block = True\n            elif pixel == block_color:\n                # Continue the block\n                block_length += 1\n            else:\n                # Found a different color - this shouldn't happen based on examples\n                # Assuming only one contiguous block exists\n                break \n        elif in_block:\n            # The pixel is background or target, and we were in a block, so the block ends here\n            break\n            \n    if block_start != -1:\n        return block_color, block_start, block_length\n    else:\n        # No block found\n        return None\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by moving the colored block next to the azure pixel.\n\n    Args:\n        input_grid: A numpy array representing the input grid. Assumed to be 1D\n                    or a 2D array with a single row based on examples.\n\n    Returns:\n        A numpy array representing the transformed grid.\n    \"\"\"\n    \n    # Handle potential 2D array with single row by flattening\n    original_shape = input_grid.shape\n    if input_grid.ndim > 1:\n        if input_grid.shape[0] == 1 or input_grid.shape[1] == 1:\n             grid_1d = input_grid.flatten()\n        else:\n             # If it's genuinely 2D and not a single row/column, this logic might not apply\n             # For now, return a copy as the transformation is defined for 1D sequence\n             print(f\"Warning: Input grid dimensions {original_shape} not handled. Returning copy.\")\n             return input_grid.copy()\n    else:\n        grid_1d = input_grid\n\n    # Define background and target colors\n    background_color = 0\n    target_color = 8\n\n    # Initialize the output grid with the background color\n    output_grid = np.full_like(grid_1d, background_color)\n\n    # Locate the target azure pixel (8)\n    azure_index = find_pixel_index(grid_1d, target_color)\n    if azure_index == -1:\n        # If no target pixel, maybe return the original grid or background grid\n        print(\"Warning: Azure pixel (8) not found. Returning background grid.\")\n        return output_grid.reshape(original_shape) # Reshape back before returning\n\n    # Place the target pixel in the output grid\n    output_grid[azure_index] = target_color\n\n    # Locate the colored block (non-background, non-target)\n    block_info = find_colored_block(grid_1d)\n    if block_info is None:\n        # If no block found, return the grid with only the target pixel placed\n        print(\"Warning: Colored block not found. Returning grid with only azure pixel.\")\n        return output_grid.reshape(original_shape) # Reshape back\n\n    block_color, _, block_length = block_info # Original start index is not needed for placement\n\n    # Calculate the new starting index for the block\n    # The block should end at the index immediately before the azure pixel (azure_index - 1)\n    # So, the block starts at (azure_index - 1) - (block_length - 1) = azure_index - block_length\n    new_block_start = azure_index - block_length\n\n    # Check for validity of the new start index\n    if new_block_start < 0:\n        print(f\"Warning: Calculated block start index {new_block_start} is out of bounds. Block not placed.\")\n        # Return grid with only azure pixel placed\n        return output_grid.reshape(original_shape) # Reshape back\n\n    # Place the colored block at its new position in the output grid\n    output_grid[new_block_start : new_block_start + block_length] = block_color\n\n    # Reshape the output to match the original input shape (e.g., if it was 1xN)\n    return output_grid.reshape(original_shape)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2299,
    "candidates_token_count": 1376,
    "total_token_count": 3675,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.818768,
  "retries": 1
}