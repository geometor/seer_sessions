{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport collections # Not strictly needed now, but good practice for potential future complex counting/grouping\n\n\"\"\"\nTransforms the input grid by moving the largest contiguous block of a\nsingle color (excluding white 0 and red 2) to immediately precede\nthe single red 2 pixel, filling the rest of the grid with white 0.\nThe red 2 pixel retains its original position.\n\"\"\"\n\n# Define constants for clarity based on the color map and problem description\nBACKGROUND_COLOR = 0\nANCHOR_COLOR = 2\n# Colors excluded when searching for the payload block\nEXCLUDED_COLORS = {BACKGROUND_COLOR, ANCHOR_COLOR}\n\ndef find_largest_payload_block(grid):\n    \"\"\"\n    Finds the largest contiguous block of a single color in the grid, \n    excluding specified background and anchor colors. If there's a tie\n    in length, the block encountered first is returned.\n\n    Args:\n        grid (list[int]): The input grid represented as a 1D list of color values.\n\n    Returns:\n        tuple(int, int) or tuple(None, 0): A tuple containing the color\n                                           and length of the largest valid\n                                           payload block found. Returns \n                                           (None, 0) if no such block exists.\n    \"\"\"\n    max_len = 0\n    max_color = None\n    current_len = 0\n    current_color = None\n\n    # Iterate through the grid to find contiguous blocks\n    for i, pixel in enumerate(grid):\n        # Check if the current pixel can be part of a payload block\n        is_payload_pixel = pixel not in EXCLUDED_COLORS\n\n        if is_payload_pixel:\n            # If it's a payload pixel\n            if pixel == current_color:\n                # Continue the existing block\n                current_len += 1\n            else:\n                # Different payload color, or start of the first block.\n                # First, check if the *previous* block was the largest found so far.\n                if current_color is not None and current_len > max_len:\n                     max_len = current_len\n                     max_color = current_color\n                \n                # Start tracking the new block\n                current_color = pixel\n                current_len = 1\n        else:\n            # Pixel is background or anchor, which ends any current payload block.\n            # Check if the just-ended block was the largest found so far.\n            if current_color is not None and current_len > max_len:\n                 max_len = current_len\n                 max_color = current_color\n            \n            # Reset tracking as this pixel breaks any payload sequence\n            current_color = None\n            current_len = 0\n\n    # After the loop, check if the last tracked block was the largest.\n    # This handles cases where the largest block extends to the end of the grid.\n    if current_color is not None and current_len > max_len:\n        max_len = current_len\n        max_color = current_color\n\n    return max_color, max_len\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list[int]): The input grid represented as a 1D list of color values.\n\n    Returns:\n        list[int]: The transformed grid.\n    \"\"\"\n\n    # Ensure input is mutable list and get its size\n    input_grid = list(input_grid)\n    grid_size = len(input_grid)\n\n    # --- Step 1: Initialize output grid ---\n    # Create a new grid of the same size, filled entirely with the background color.\n    output_grid = [BACKGROUND_COLOR] * grid_size\n\n    # --- Step 2: Locate the anchor pixel ---\n    # Find the index of the single red (2) pixel.\n    try:\n        anchor_index = input_grid.index(ANCHOR_COLOR)\n    except ValueError:\n        # According to the problem description and examples, the anchor should always exist.\n        # If not found, returning the original grid might be a fallback.\n        print(f\"Error: Anchor color {ANCHOR_COLOR} not found in input grid.\")\n        return input_grid # Return original grid or raise error as appropriate\n\n    # --- Step 3: Identify the payload block ---\n    # Find the color and length of the largest contiguous block of a single color\n    # (excluding background and anchor colors).\n    payload_color, payload_length = find_largest_payload_block(input_grid)\n\n    # --- Step 4: Construct the output grid (Place Payload) ---\n    # Proceed only if a valid payload block was found.\n    if payload_color is not None and payload_length > 0:\n        # Calculate the target start and end indices for placing the payload block.\n        # The payload block should end at the index immediately preceding the anchor pixel.\n        payload_end_index = anchor_index - 1\n        # The payload block starts 'payload_length' cells before its end.\n        payload_start_index = anchor_index - payload_length\n\n        # Check if the calculated start position is valid (within grid bounds).\n        # The examples suggest the payload will always fit before the anchor.\n        if payload_start_index >= 0:\n             # Place the payload block into the output grid.\n             for i in range(payload_start_index, payload_end_index + 1):\n                 output_grid[i] = payload_color\n        else:\n             # This case implies the payload block is too long to fit before the anchor.\n             # Based on problem constraints/examples, this might not occur.\n             # If it did, the behavior is undefined; we choose to not place the payload.\n             print(f\"Warning: Payload block (color {payload_color}, length {payload_length}) \"\n                   f\"does not fit entirely before anchor at index {anchor_index}. Payload not placed.\")\n\n    # --- Step 5: Place the anchor pixel ---\n    # Place the anchor (red 2) pixel into the output grid at its original position.\n    # This happens regardless of whether a payload was placed.\n    # Ensure the anchor index is valid before writing (it should be, based on find).\n    if 0 <= anchor_index < grid_size:\n        output_grid[anchor_index] = ANCHOR_COLOR\n\n    # --- Step 6: Return the result ---\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2272,
    "candidates_token_count": 1466,
    "total_token_count": 3738,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 70.401046,
  "retries": 1
}