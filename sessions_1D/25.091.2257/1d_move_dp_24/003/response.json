{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nShift a contiguous block of color horizontally rightward within a single-row grid \ntowards a stationary marker pixel (azure, 8). The magnitude of the shift is \ndetermined by the count of background pixels (white, 0) situated strictly \nbetween the block's right edge and the marker pixel in the input grid.\n\"\"\"\n\ndef find_marker_index(grid_row, marker_color=8):\n    \"\"\"Finds the column index of the first occurrence of the marker color in the row.\"\"\"\n    indices = np.where(grid_row == marker_color)[0]\n    if len(indices) > 0:\n        return indices[0]\n    return -1 # Marker not found\n\ndef find_main_block(grid_row, background_color=0, marker_color=8, marker_index=-1):\n    \"\"\"\n    Finds the contiguous block of non-background, non-marker color \n    located to the left of the marker_index.\n\n    Returns:\n        tuple: (block_color, start_index, end_index) or (-1, -1, -1) if not found.\n    \"\"\"\n    block_color = -1\n    start_index = -1\n    end_index = -1\n    in_block = False\n    \n    # Determine the search range (up to marker or end of grid if no marker)\n    search_limit = marker_index if marker_index != -1 else len(grid_row)\n\n    for i in range(search_limit):\n        pixel = grid_row[i]\n        is_main_color = (pixel != background_color and pixel != marker_color)\n\n        if is_main_color and not in_block:\n            # Start of a potential block\n            block_color = pixel\n            start_index = i\n            in_block = True\n        elif in_block and pixel != block_color:\n            # End of the block found before the search limit\n            end_index = i - 1\n            in_block = False\n            break # Found the block, stop searching\n\n    # If the loop finished while still in_block (block goes up to the search limit)\n    if in_block:\n        end_index = search_limit - 1\n\n    # If we found a valid block start but not an end (can happen if loop breaks immediately after start)\n    # Re-calculate end index explicitly\n    if start_index != -1 and end_index == -1:\n        current_idx = start_index\n        while current_idx < search_limit and grid_row[current_idx] == block_color:\n            current_idx += 1\n        end_index = current_idx -1\n        \n    # Ensure the block actually finished before the marker if a marker exists\n    if marker_index != -1 and end_index >= marker_index:\n         return -1, -1, -1 # Block overlaps or touches marker, invalid based on assumption\n\n    if start_index != -1 and end_index != -1:\n         return block_color, start_index, end_index\n    else:\n        return -1, -1, -1\n\n\ndef calculate_shift_distance(grid_row, block_end_index, marker_index, background_color=0):\n    \"\"\"Calculates the number of background pixels between the block end and marker.\"\"\"\n    count = 0\n    # Iterate strictly between block_end + 1 and marker_index\n    if block_end_index < marker_index -1 : # Only count if there's space between\n        for i in range(block_end_index + 1, marker_index):\n            if grid_row[i] == background_color:\n                count += 1\n    return count\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the shifting transformation to the input grid.\n\n    Args:\n        input_grid: A numpy array of shape (1, N) representing the input grid pixels.\n\n    Returns:\n        A numpy array of shape (1, N) representing the transformed output grid pixels.\n    \"\"\"\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    # Check for the expected 1xN shape\n    if input_grid.ndim != 2 or input_grid.shape[0] != 1:\n         # Handle error or return input if shape is unexpected\n         # For now, let's assume valid input based on examples\n         print(f\"Warning: Unexpected input grid shape {input_grid.shape}. Proceeding assuming row 0.\")\n         # return input_grid # Or raise ValueError(\"Input grid must have shape (1, N)\")\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    grid_row = output_grid[0] # Work with the first (only) row\n\n    background_color = 0\n    marker_color = 8\n\n    # 1. Find the position (column index) of the marker pixel (8).\n    marker_idx = find_marker_index(grid_row, marker_color)\n    if marker_idx == -1:\n        # If no marker, return the original grid as transformation is undefined\n        return output_grid \n\n    # 2. Find the main block's color, start index, and end index (must be before marker).\n    block_color, start_idx, end_idx = find_main_block(grid_row, background_color, marker_color, marker_idx)\n    if block_color == -1:\n         # If no valid block found before marker, return original grid\n         return output_grid\n\n    # 3. Count background pixels strictly between block end and marker.\n    shift_distance = calculate_shift_distance(grid_row, end_idx, marker_idx, background_color)\n\n    # 4. Perform the shift if distance > 0\n    if shift_distance > 0:\n        # Check if the shift is valid (doesn't overwrite marker or go out of bounds)\n        # The new end position will be end_idx + shift_distance\n        if end_idx + shift_distance >= marker_idx:\n             # This case shouldn't happen if assumptions hold, but good practice to check\n             print(\"Warning: Calculated shift would overwrite or pass the marker. No shift performed.\")\n             return output_grid\n\n        # Iterate shift_distance times to update the grid row\n        # Note: Direct assignment works on the view 'grid_row' which modifies 'output_grid'\n        for i in range(shift_distance):\n            # Set the leftmost pixel of the original block location to background\n            grid_row[start_idx + i] = background_color\n            # Set the pixel just after the original block end location to block color\n            # Note: end_idx + 1 is the first position *after* the original block\n            grid_row[end_idx + 1 + i] = block_color\n\n    # 5. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7642,
    "candidates_token_count": 1621,
    "total_token_count": 9263,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.345614,
  "retries": 1
}