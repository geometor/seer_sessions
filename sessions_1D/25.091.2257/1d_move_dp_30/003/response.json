{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 1xN input grid based on the following rules:\n1. Identifies a single contiguous block of a primary color (non-white 0, non-gray 5) and a single gray (5) pixel within the single row.\n2. Determines the number of white (0) pixels separating the right edge of the primary color block from the gray pixel.\n3. Creates an output grid of the same dimensions, initially filled with white (0).\n4. Places the gray (5) pixel in the output grid at its original position.\n5. Shifts the primary color block to the right by the calculated number of separating white pixels, placing it in the output grid immediately adjacent to the left of the gray pixel.\n\"\"\"\n\nimport numpy as np\n\ndef find_pixel_index_in_row(row_1d, color):\n    \"\"\"Finds the index of the first occurrence of a specific color in a 1D numpy array.\"\"\"\n    indices = np.where(row_1d == color)[0]\n    if len(indices) > 0:\n        return indices[0]\n    return -1 # Not found\n\ndef find_color_block_in_row(row_1d):\n    \"\"\"\n    Finds the contiguous block of non-white (0), non-gray (5) color in a 1D numpy array.\n    Returns the block's color, start index, and end index.\n    Returns (None, -1, -1) if no such block is found.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_end = -1\n    in_block = False\n    for i, pixel in enumerate(row_1d):\n        # Check if the pixel is the start of a potential block\n        is_primary_color = pixel != 0 and pixel != 5\n        if is_primary_color and not in_block:\n            block_color = pixel\n            block_start = i\n            block_end = i # Initialize end index\n            in_block = True\n        # Check if we are continuing the block\n        elif in_block and pixel == block_color:\n            block_end = i # Update end index\n        # Check if we just exited the block\n        elif in_block and pixel != block_color:\n            break # Block ended\n\n    if block_start != -1:\n        return block_color, block_start, block_end\n    else:\n        return None, -1, -1\n\ndef count_white_separation(row_1d, block_end_idx, gray_idx):\n    \"\"\"Counts white (0) pixels between the block end and the gray pixel.\"\"\"\n    separation_count = 0\n    # Ensure there's space between block and gray, and indices are valid\n    if block_end_idx != -1 and gray_idx != -1 and block_end_idx < gray_idx - 1:\n       # Iterate through the pixels strictly between the block end and gray pixel\n       for i in range(block_end_idx + 1, gray_idx):\n           if row_1d[i] == 0:\n               separation_count += 1\n    return separation_count\n\ndef transform(input_grid):\n    \"\"\"\n    Shifts a color block rightwards within the single row of the grid\n    to be adjacent to a stationary gray pixel.\n    \"\"\"\n    # --- Input Processing ---\n    # Ensure input is a list of lists and extract the first row\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list):\n        # Handle invalid input format if necessary, though ARC examples are consistent\n        raise ValueError(\"Input grid must be a list containing at least one list (row).\")\n    input_row_list = input_grid[0]\n    input_row_np = np.array(input_row_list, dtype=int)\n    grid_width = len(input_row_np)\n\n    # --- Analysis ---\n    # Find the gray pixel's index\n    gray_idx = find_pixel_index_in_row(input_row_np, 5)\n    if gray_idx == -1:\n        # Handle error: Gray pixel not found (shouldn't happen per examples)\n        # Return input or default grid maybe? For now, raise error or return copy.\n        print(\"Warning: Gray pixel (5) not found. Returning input grid.\")\n        return input_grid # Or potentially a grid of zeros\n\n    # Find the color block details\n    block_color, block_start, block_end = find_color_block_in_row(input_row_np)\n    if block_color is None:\n        # Handle error: Color block not found (shouldn't happen per examples)\n        # Create output with only the gray pixel\n        print(\"Warning: Color block not found. Creating output with only gray pixel.\")\n        output_row_np = np.zeros(grid_width, dtype=int)\n        output_row_np[gray_idx] = 5\n        return [output_row_np.tolist()] # Return as 2D grid\n\n    # Calculate the number of white pixels separating the block and gray pixel\n    separation_count = count_white_separation(input_row_np, block_end, gray_idx)\n\n    # --- Output Grid Construction ---\n    # Initialize output grid (row) with white (0)\n    output_row_np = np.zeros(grid_width, dtype=int)\n\n    # Place the gray pixel in the output\n    output_row_np[gray_idx] = 5\n\n    # Calculate the new position for the block\n    new_block_start = block_start + separation_count\n    block_length = block_end - block_start + 1\n    new_block_end = new_block_start + block_length - 1 # For verification/slicing\n\n    # Place the color block in the output at its new position\n    # Check bounds and potential overlap (though logic should prevent overlap with gray)\n    if new_block_end < gray_idx and new_block_start >= 0:\n        output_row_np[new_block_start : new_block_start + block_length] = block_color\n    else:\n        # This case indicates an issue with the logic or unexpected input\n        print(f\"Warning: Calculated new block position [{new_block_start}, {new_block_end}] conflicts with gray pixel at {gray_idx} or grid bounds.\")\n        # Fallback: Place block based on original logic anyway, might overwrite gray or be partial\n        start = max(0, new_block_start)\n        end = min(grid_width, new_block_start + block_length)\n        # Avoid overwriting gray pixel if possible, prioritize gray's position\n        if gray_idx >= start and gray_idx < end:\n           # Write before gray\n           if gray_idx > start:\n               output_row_np[start : gray_idx] = block_color\n           # Write after gray (less likely scenario based on task)\n           if gray_idx + 1 < end:\n               output_row_np[gray_idx + 1 : end] = block_color\n        else:\n            output_row_np[start : end] = block_color\n\n\n    # --- Final Output ---\n    # Convert the numpy row back to a list and wrap it in another list for 2D output\n    output_grid = [output_row_np.tolist()]\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9696,
    "candidates_token_count": 1718,
    "total_token_count": 11414,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.526013,
  "retries": 1
}