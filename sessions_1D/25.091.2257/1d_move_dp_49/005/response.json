{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a contiguous horizontal line of a single color (not white 0 or azure 8) \nand a single azure pixel (8) in a 1D input grid. Creates a new grid where the \ncolored line is moved horizontally so that its rightmost pixel is immediately \nadjacent to the left of the azure pixel's original position. The background is \nwhite (0), and the azure pixel's position, line color, and line length are \npreserved in the output.\n\"\"\"\n\nimport numpy as np\n\ndef _find_anchor(grid_np):\n    \"\"\"\n    Finds the index of the anchor pixel (color 8).\n\n    Args:\n        grid_np: Numpy array representing the 1D grid.\n\n    Returns:\n        The integer index of the anchor pixel.\n\n    Raises:\n        ValueError: If exactly one anchor pixel (8) is not found.\n    \"\"\"\n    anchor_indices = np.where(grid_np == 8)[0]\n    if len(anchor_indices) == 1:\n        return anchor_indices[0]\n    else:\n        # Raise error if the assumption of exactly one anchor is violated\n        raise ValueError(f\"Expected exactly one anchor pixel (8), found {len(anchor_indices)}\")\n\ndef _find_colored_line(grid_np):\n    \"\"\"\n    Finds the color and length of the contiguous colored line (not 0 or 8).\n    Assumes only one such line exists per grid based on examples.\n\n    Args:\n        grid_np: Numpy array representing the 1D grid.\n\n    Returns:\n        A tuple (line_color, line_length).\n\n    Raises:\n        ValueError: If no colored line segment (non-0, non-8) is found.\n    \"\"\"\n    line_color = -1\n    line_length = 0\n    in_line = False\n\n    for i, pixel in enumerate(grid_np):\n        # Check if pixel is part of the colored line\n        if pixel != 0 and pixel != 8:\n            if not in_line:\n                # Start of the line segment\n                line_color = pixel\n                line_length = 1\n                in_line = True\n            else:\n                # Continuing the line segment (ensure color matches)\n                if pixel == line_color:\n                    line_length += 1\n                else:\n                    # Found a different color - stop, assuming only one contiguous line segment\n                    break \n        elif in_line:\n            # We were in a line, and hit a 0 or 8, so the line ends here\n            break\n\n    if not in_line:\n        # Raise error if no line was found\n        raise ValueError(\"Could not find a colored line (non-0, non-8) in the input grid.\")\n\n    return line_color, line_length\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by repositioning the colored line next to the anchor pixel.\n\n    Args:\n        input_grid: A list of integers representing the 1D input grid.\n\n    Returns:\n        A list of integers representing the transformed 1D output grid.\n        Returns the original input_grid if assumptions about input structure (one anchor, one line) fail.\n    \"\"\"\n    try:\n        # Convert input list to numpy array for efficient processing\n        grid_np = np.array(input_grid, dtype=int)\n        grid_size = len(grid_np)\n\n        # Step 1: Identify the anchor pixel's index\n        anchor_index = _find_anchor(grid_np)\n\n        # Step 2: Identify the colored line's properties (color and length)\n        line_color, line_length = _find_colored_line(grid_np)\n\n        # Step 3: Create a new output grid initialized with the background color (white 0)\n        output_grid_np = np.zeros(grid_size, dtype=int)\n\n        # Step 4: Place the anchor pixel (8) in the output grid at its original position\n        # Basic check anchor_index is within bounds, although _find_anchor ensures it exists\n        if 0 <= anchor_index < grid_size:\n             output_grid_np[anchor_index] = 8\n        else:\n             # This case should not be reachable if _find_anchor succeeded\n             raise IndexError(f\"Anchor index {anchor_index} is out of bounds for grid size {grid_size}.\")\n\n        # Step 5: Calculate the new start and end indices for the colored line\n        # The line should end at the index immediately before the anchor\n        new_line_end_index = anchor_index  # End index for slicing is exclusive\n        new_line_start_index = anchor_index - line_length\n\n        # Step 6: Place the colored line in the output grid at its new position\n        # Check if the calculated placement is valid within the grid boundaries\n        if new_line_start_index >= 0 and new_line_end_index <= grid_size:\n            output_grid_np[new_line_start_index:new_line_end_index] = line_color\n        else:\n            # The calculated position is out of bounds. This might indicate an\n            # impossible transformation based on line length and anchor position.\n            # Based on examples, this shouldn't happen. Raise error or handle as needed.\n            # For now, raise an error to indicate the problem clearly.\n            raise ValueError(f\"Calculated line position [{new_line_start_index}:{new_line_end_index}] is out of bounds for grid size {grid_size}.\")\n\n        # Step 7: Convert the numpy array back to a list for the final output\n        output_grid = output_grid_np.tolist()\n\n    except (ValueError, IndexError) as e:\n        # If any assumption fails (no anchor, no line, invalid placement)\n        # print an error and return the original input grid as a fallback.\n        print(f\"Error processing grid: {e}. Returning original input.\")\n        output_grid = input_grid # Return original input on error\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10272,
    "candidates_token_count": 1391,
    "total_token_count": 11663,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.889292,
  "retries": 1
}