{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nMove a contiguous colored block within a single-row grid rightwards until its \nright edge is immediately adjacent to the left edge of a fixed orange target \npixel in the same row.\n\nThe input is a 2D grid with exactly one row.\n1. Extract the single row from the input grid.\n2. Identify the background color (0), the fixed target pixel (7), and the \n   movable colored block (contiguous sequence of non-0, non-7 pixels) within the row.\n3. Determine the column index of the target pixel and the color, start index, \n   and length of the movable block.\n4. Calculate the destination start column index for the movable block, which is the \n   target pixel's index minus the block's length.\n5. Construct the output row:\n   a. Initialize a new row with the background color.\n   b. Place the movable block at the calculated destination start index.\n   c. Place the target pixel at its original index.\n   d. Copy any pixels from the input row that were originally to the right of \n      the target pixel.\n6. Format the output row as a 2D grid (1xN) and return it.\n\"\"\"\n\nimport numpy as np\n\ndef find_target_pixel(row):\n    \"\"\"Finds the column index of the target pixel (7) in a given row.\"\"\"\n    for idx, pixel in enumerate(row):\n        if pixel == 7:\n            return idx\n    # This should not be reached if the assumptions hold true\n    raise ValueError(\"Target pixel (7) not found in the row.\") \n\ndef find_movable_block(row):\n    \"\"\"\n    Finds the start index, length, and color of the movable block in a row.\n    The block consists of contiguous pixels that are not background (0) \n    and not the target (7).\n    \"\"\"\n    block_start = -1\n    block_color = -1\n    block_length = 0\n    in_block = False\n    \n    for idx, pixel in enumerate(row):\n        # Check if the pixel belongs to the movable block\n        if pixel != 0 and pixel != 7:\n            if not in_block:\n                # Start of a new block\n                block_start = idx\n                block_color = pixel\n                in_block = True\n            block_length += 1\n        elif in_block: \n            # End of the block found (encountered 0 or 7, or end of row)\n            break # Stop searching once the block is found and passed\n             \n    if block_start == -1:\n         # This should not be reached if the assumptions hold true\n        raise ValueError(\"Movable block not found in the row.\")\n\n    return block_start, block_length, block_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving the colored block next to the target pixel.\n\n    Args:\n        input_grid (numpy.ndarray): A 2D NumPy array representing the input grid (shape 1xN).\n\n    Returns:\n        numpy.ndarray: A 2D NumPy array representing the transformed output grid (shape 1xN).\n    \"\"\"\n    # --- Input Validation and Extraction ---\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid) # Convert if input is list of lists\n        \n    if input_grid.shape[0] != 1:\n        raise ValueError(f\"Input grid must have exactly one row, but got shape {input_grid.shape}\")\n        \n    input_row = input_grid[0] # Extract the single row\n    row_length = len(input_row)\n\n    # --- Identify Objects ---\n    try:\n        target_index = find_target_pixel(input_row)\n        block_start, block_length, block_color = find_movable_block(input_row)\n    except ValueError as e:\n        # Handle cases where assumptions might be violated in unexpected inputs\n        print(f\"Error during object identification: {e}\")\n        # Return the original grid or handle error appropriately\n        return input_grid \n\n    # --- Calculate Destination ---\n    # The block should end at target_index - 1\n    # So it should start at (target_index - 1) - (block_length - 1) = target_index - block_length\n    destination_start_index = target_index - block_length\n    \n    # --- Construct Output Row ---\n    # Initialize output row with background color (0)\n    output_row = [0] * row_length\n\n    # Place the Movable Block at its new position\n    # Ensure indices are within bounds (though assumptions imply they should be)\n    start = max(0, destination_start_index)\n    end = min(row_length, destination_start_index + block_length)\n    for i in range(start, end):\n        output_row[i] = block_color\n\n    # Place the Target Pixel at its original position\n    if 0 <= target_index < row_length: # Boundary check\n        output_row[target_index] = 7\n\n    # Copy pixels from the input that were originally to the right of the Target Pixel\n    # Start copying from the position right after the target pixel\n    copy_start_index = target_index + 1\n    if copy_start_index < row_length:\n        for i in range(copy_start_index, row_length):\n             output_row[i] = input_row[i]\n\n    # --- Format Output ---\n    # Convert the output row list back to a 2D numpy array (1xN)\n    output_grid = np.array([output_row])\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6568,
    "candidates_token_count": 1312,
    "total_token_count": 7880,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.738027,
  "retries": 1
}