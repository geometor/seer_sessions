{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1xN grid by moving a contiguous block of a single color (not white or green) \nso that its right end is immediately adjacent to the left of a single green pixel. \nThe green pixel's position remains unchanged. The background is white. The input and output\nare expected to be 2D numpy arrays of shape (1, N).\n\"\"\"\n\ndef find_pixel_index(row, color):\n  \"\"\"Finds the index of the first occurrence of a specific color in the row.\"\"\"\n  indices = np.where(row == color)[0]\n  if len(indices) > 0:\n    return indices[0]\n  return -1 # Should not happen based on task description\n\ndef find_block_properties(row, exclude_colors):\n  \"\"\"\n  Finds the first contiguous block of pixels whose color is not in exclude_colors.\n  Returns the color and length of the block. Assumes exactly one such block exists.\n  \"\"\"\n  block_color = -1\n  block_length = 0\n  in_block = False\n\n  for i, pixel in enumerate(row):\n    if pixel not in exclude_colors:\n      if not in_block:\n        # Start of a new block\n        in_block = True\n        block_color = pixel\n        block_length = 1\n      elif pixel == block_color:\n        # Continuing the current block\n        block_length += 1\n      else:\n        # Found a different non-excluded color - assumes only one block type exists per row\n        # as per the examples, so we can break once we hit a different color or excluded color.\n        break \n    elif in_block:\n      # End of the block (encountered an excluded color or end of row)\n      break \n      \n  if block_color != -1:\n      return block_color, block_length\n  else:\n      # Should not happen if a block always exists as per examples\n      return None, 0 \n\ndef transform(input_grid):\n    \"\"\"\n    Moves a colored block to be adjacent to a fixed green pixel in a 1xN grid.\n\n    Args:\n        input_grid: A 2D numpy array of shape (1, N) representing the input grid.\n\n    Returns:\n        A 2D numpy array of shape (1, N) representing the transformed grid.\n    \"\"\"\n    # Ensure input is a 2D numpy array\n    if not isinstance(input_grid, np.ndarray) or input_grid.ndim != 2 or input_grid.shape[0] != 1:\n         # Convert if necessary, assuming list of lists [[...]] or similar\n         input_grid_np = np.array(input_grid)\n         if input_grid_np.ndim == 1: # Handle case where input might be 1D list/array\n             input_grid_np = input_grid_np.reshape(1, -1)\n         elif input_grid_np.ndim != 2 or input_grid_np.shape[0] != 1:\n              raise ValueError(\"Input grid must be convertible to a 2D array with shape (1, N)\")\n         input_grid = input_grid_np\n         \n    # 1. Extract the row for processing\n    input_row = input_grid[0]\n    grid_size = len(input_row)\n\n    # 2. Initialize output row with background color (white, 0)\n    output_row = np.zeros(grid_size, dtype=int)\n\n    # 3. Find the index of the anchor pixel (green, 3)\n    anchor_index = find_pixel_index(input_row, 3)\n    if anchor_index == -1:\n        # Handle error or edge case: green pixel not found. \n        # Based on examples, it should always be present. Return empty grid? Or initial?\n        # For now, returning the initialized empty grid wrapped in 2D shape.\n        return output_row.reshape(1, -1) \n\n    # 4. Find the properties (color, length) of the main block (non-white, non-green)\n    exclude_colors = {0, 3} \n    block_color, block_length = find_block_properties(input_row, exclude_colors)\n\n    # If no block is found (e.g., only green and white pixels), just place the green pixel\n    if block_color is None:\n        if 0 <= anchor_index < grid_size:\n            output_row[anchor_index] = 3\n        return output_row.reshape(1, -1)\n\n    # 5. Calculate the new position for the main block\n    # The right end of the block should be at anchor_index - 1\n    target_end_index = anchor_index - 1\n    # The start index is calculated from the end index and length\n    target_start_index = target_end_index - block_length + 1\n\n    # 6. Place the main block in the output row\n    # Check bounds to prevent errors if calculations lead outside the grid\n    # (though based on examples this shouldn't happen if logic is correct)\n    actual_start = max(0, target_start_index)\n    actual_end = min(grid_size - 1, target_end_index)\n    \n    if actual_start <= actual_end: # Check if the block placement is valid\n        # Adjust length if clipping occurred due to boundary check (unlikely given problem)\n        # place_length = actual_end - actual_start + 1 \n        # Place the block segment\n        output_row[actual_start : actual_end + 1] = block_color\n        \n        # Note: The above placement assumes the *intended* start/end indices are used\n        # for calculation, even if they slightly exceed bounds. A safer slice using\n        # calculated target indices:\n        if 0 <= target_start_index < grid_size and 0 <= target_end_index < grid_size:\n             output_row[target_start_index : target_end_index + 1] = block_color\n        # If the calculated indices are out of bounds, the block might not be placed correctly or at all,\n        # depending on how edge cases should be handled. Sticking to direct calculation placement.\n\n\n    # 7. Place the anchor pixel (green, 3) in the output row at its original position\n    # This might overwrite the last pixel of the block if block_length=1 and start=end=anchor_index-1\n    # which is the intended behavior based on adjacency requirement.\n    if 0 <= anchor_index < grid_size:\n        output_row[anchor_index] = 3\n\n    # 8. Format the output as a 1xN 2D array\n    output_grid = output_row.reshape(1, -1)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7527,
    "candidates_token_count": 1585,
    "total_token_count": 9112,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.298437,
  "retries": 1
}