{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nIdentify a contiguous horizontal block of non-white (0), non-maroon (9) pixels (the 'main block') and a single maroon (9) pixel (the 'marker') in the input grid (which is a single row).\nCreate an output grid of the same size, initially filled with white (0).\nShift the main block horizontally to the right so that its rightmost pixel is positioned immediately to the left of the marker pixel's original position.\nPlace the marker pixel in the output grid at its original position.\nThe color and length of the main block are preserved.\n\"\"\"\n\ndef find_contiguous_block(row):\n    \"\"\"\n    Finds the first contiguous block of non-background (0) and non-marker (9) color.\n\n    Args:\n        row (list or np.array): The input row.\n\n    Returns:\n        tuple: (color, start_index, end_index, length) or None if not found.\n    \"\"\"\n    start_index = -1\n    color = -1\n    for i, pixel in enumerate(row):\n        if pixel != 0 and pixel != 9:\n            if start_index == -1:\n                start_index = i\n                color = pixel\n            elif pixel != color: # End of block if color changes\n                return color, start_index, i - 1, (i - 1) - start_index + 1\n        elif start_index != -1: # End of block if 0 or 9 encountered\n             return color, start_index, i - 1, (i - 1) - start_index + 1\n    # If block runs to the end of the row\n    if start_index != -1:\n        return color, start_index, len(row) - 1, (len(row) - 1) - start_index + 1\n    return None # Block not found\n\ndef find_pixel(row, target_color):\n    \"\"\"\n    Finds the index of the first occurrence of a specific color.\n\n    Args:\n        row (list or np.array): The input row.\n        target_color (int): The color to find.\n\n    Returns:\n        int: The index of the pixel, or -1 if not found.\n    \"\"\"\n    for i, pixel in enumerate(row):\n        if pixel == target_color:\n            return i\n    return -1\n\ndef transform(input_grid):\n    \"\"\"\n    Shifts a colored block to the left of a marker pixel.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid (expected 1xN).\n\n    Returns:\n        list of lists: A 2D list representing the transformed grid.\n    \"\"\"\n    # Ensure input is treated as a single row (list or 1D numpy array)\n    if isinstance(input_grid, list) and len(input_grid) == 1:\n        input_row = np.array(input_grid[0])\n    elif isinstance(input_grid, np.ndarray) and input_grid.shape[0] == 1:\n         input_row = input_grid[0]\n    else:\n        # Handle potential malformed input or adapt if multi-row inputs become possible\n        # For now, assume it's a flat list if not 1xN\n         input_row = np.array(input_grid)\n         if input_row.ndim > 1:\n              raise ValueError(\"Input grid must be effectively 1-dimensional for this task\")\n\n\n    # Get grid dimensions\n    height = 1 # Task specific\n    width = len(input_row)\n\n    # Initialize output grid with background color (white = 0)\n    output_row = np.zeros(width, dtype=int)\n\n    # 1. Identify the main block\n    block_info = find_contiguous_block(input_row)\n    if not block_info:\n        # No block found, maybe return input or empty grid? Return copy for safety.\n        return [output_row.tolist()] # Return as list of lists\n    block_color, block_start, block_end, block_length = block_info\n\n    # 2. Identify the marker pixel (maroon = 9)\n    marker_index = find_pixel(input_row, 9)\n    if marker_index == -1:\n        # No marker found, behavior undefined. Return copy for safety.\n         return [output_row.tolist()] # Return as list of lists\n\n    # 3. Calculate target position for the block\n    # Target end index is one position to the left of the marker\n    target_end_index = marker_index - 1\n    # Target start index is calculated based on the target end and block length\n    target_start_index = target_end_index - block_length + 1\n\n    # Check if target indices are valid\n    if target_start_index < 0 or target_end_index >= width:\n         # Handle cases where the shift would go out of bounds (though not seen in examples)\n         print(f\"Warning: Calculated block position [{target_start_index}, {target_end_index}] might be out of bounds [0, {width-1}]. Clamping or error handling might be needed.\")\n         # For now, proceed - numpy slicing handles some boundary issues, but logic might be flawed.\n         # A more robust solution might clip indices or return an error state.\n\n    # 4. Place the shifted block into the output grid\n    # Ensure indices are within bounds before slicing/assignment\n    start = max(0, target_start_index)\n    end = min(width, target_end_index + 1) # Numpy slice end index is exclusive\n    actual_length_to_place = end - start\n\n    if actual_length_to_place > 0 and block_length == actual_length_to_place: # Check if the full block fits\n        output_row[start:end] = block_color\n    # else: Handle partial placement or error if it doesn't fit? Based on examples, it always fits.\n\n\n    # 5. Place the marker pixel into the output grid at its original position\n    if 0 <= marker_index < width:\n        output_row[marker_index] = 9\n\n    # Return the result as a list of lists\n    return [output_row.tolist()]\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2354,
    "candidates_token_count": 1455,
    "total_token_count": 3809,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.315321,
  "retries": 1
}