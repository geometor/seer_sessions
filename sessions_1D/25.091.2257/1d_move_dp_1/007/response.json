{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nShift a contiguous block of a non-white (0), non-azure (8) color within a 1D list (row) \nrightward until its rightmost edge is immediately adjacent to the left of the single \nazure (8) pixel. The space previously occupied by the block is filled with white (0). \nPixels at indices greater than the azure pixel's index remain unchanged.\n\"\"\"\n\ndef find_movable_block(row: np.ndarray) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the contiguous block of non-white (0), non-azure (8) color in a 1D row.\n\n    Args:\n        row: The 1D input row as a numpy array.\n\n    Returns:\n        A tuple containing (color, start_index, end_index) of the block,\n        or None if no such block is found.\n    \"\"\"\n    start_index = -1\n    block_color = -1\n    for i, pixel in enumerate(row):\n        # Look for a pixel that starts or continues the block\n        if pixel != 0 and pixel != 8:\n            if start_index == -1:  # Start of a new block\n                start_index = i\n                block_color = pixel\n            # Task examples imply block color is consistent, so we don't strictly need\n            # to check pixel == block_color here, just that it's not 0 or 8.\n            # If we encounter a different non-0/8 color, it implies end of block based on examples.\n            elif pixel != block_color: \n                 return block_color, start_index, i - 1\n        # If we were tracking a block and hit background (0) or target (8), the block ends\n        elif start_index != -1: \n            return block_color, start_index, i - 1\n            \n    # Handle case where block goes uninterrupted to the end of the grid\n    if start_index != -1:\n        return block_color, start_index, len(row) - 1\n        \n    return None # No block found\n\n\ndef find_target_pixel(row: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Finds the index of the single azure (8) pixel in a 1D row.\n\n    Args:\n        row: The 1D input row as a numpy array.\n\n    Returns:\n        The index of the azure pixel, or None if not found or multiple found. \n        (Examples imply exactly one target).\n    \"\"\"\n    indices = np.where(row == 8)[0]\n    if len(indices) == 1:\n        return indices[0]\n    # Handle cases where 0 or >1 targets are found, although examples suggest exactly 1.\n    # Returning None signifies an unexpected state based on examples.\n    return None \n\n\ndef transform(input_list: List[int]) -> List[int]:\n    \"\"\"\n    Applies the block shifting transformation to the input list.\n\n    Args:\n        input_list: A list of integers representing the 1D input row.\n\n    Returns:\n        A list of integers representing the transformed 1D output row.\n    \"\"\"\n    # --- Input Validation and Setup ---\n    if not isinstance(input_list, list) or not input_list:\n         # Return input or raise error if input is invalid format\n         # Based on expected ARC format, returning input might be safer default\n         return input_list \n         # raise ValueError(\"Input must be a non-empty list.\") \n\n    input_row = np.array(input_list)\n    row_len = len(input_row)\n\n    # Initialize output row with background color (white = 0)\n    output_row = np.zeros(row_len, dtype=int)\n\n    # --- Find Objects ---\n    # Find the movable block details (color, start, end)\n    block_info = find_movable_block(input_row)\n    if not block_info:\n        # If no block found, transformation cannot proceed as defined.\n        # Return original list as per observed behavior in similar ARC tasks.\n        return input_list \n\n    block_color, block_start, block_end = block_info\n    block_length = block_end - block_start + 1\n\n    # Find the target azure pixel's index\n    target_index = find_target_pixel(input_row)\n    if target_index is None:\n        # If no target pixel, transformation cannot proceed as defined.\n        # Return original list.\n        return input_list \n\n    # --- Calculate New Position ---\n    # Determine the target end position for the block (adjacent to target)\n    new_block_end = target_index - 1\n    # Determine the target start position based on end position and block length\n    new_block_start = new_block_end - block_length + 1\n\n    # --- Construct Output List ---\n    # Check if the calculated position is valid within the list bounds\n    if new_block_start < 0:\n        # This case implies the block is too long to fit left of the target.\n        # Examples don't cover this, returning original seems safest.\n        return input_list \n        # Alternatively, one could place a truncated block if rules allowed.\n        # print(f\"Warning: Calculated block start index {new_block_start} is out of bounds.\")\n\n    # Place the block in the output row at the calculated new position\n    output_row[new_block_start : new_block_end + 1] = block_color\n\n    # Place the target pixel (8) in the output row at its original index\n    # Bounds check target_index, though find_target_pixel should ensure it's valid\n    if 0 <= target_index < row_len:\n        output_row[target_index] = 8\n\n    # Copy any pixels from the input that were originally to the right of the target pixel\n    if target_index + 1 < row_len:\n        # Get the segment of the input row after the target pixel\n        pixels_to_copy = input_row[target_index + 1:]\n        # Determine the corresponding slice in the output row\n        output_slice_start = target_index + 1\n        output_slice_end = output_slice_start + len(pixels_to_copy)\n        # Place the copied pixels into the output row\n        output_row[output_slice_start:output_slice_end] = pixels_to_copy\n\n    # Convert the final numpy array back to a list\n    return output_row.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11311,
    "candidates_token_count": 1526,
    "total_token_count": 12837,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.758595,
  "retries": 1
}