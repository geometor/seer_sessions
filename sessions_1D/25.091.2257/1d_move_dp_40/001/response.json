{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport sys\n\n# Add the directory containing py_utils to the Python path\n# Note: Replace '/path/to/arc-prize-strategy/lib' with the actual path if needed\nsys.path.append('/path/to/arc-prize-strategy/lib')\n# Or if the structure is Notebooks/ -> lib/ then use:\n# sys.path.append('../lib')\ntry:\n    # Import utility functions if available, otherwise define placeholders\n    # This is useful if you have common ARC helper functions\n    # from py_utils import get_objects, find_objects, find_objects_by_color\n    pass # No specific py_utils needed for this task yet\nexcept ImportError:\n    print(\"Warning: py_utils not found. Proceeding without them.\")\n    # Define placeholder functions or handle the absence as needed\n    pass\n\n\"\"\"\nTransformation Rule:\nIdentify four contiguous segments in the input row:\n1. `initial_segment`: Any pixels from the start up to the first non-white pixel (can be empty).\n2. `movable_block`: The first contiguous block of non-white pixels.\n3. `white_gap`: The contiguous block of white (0) pixels immediately following the `movable_block`.\n4. `final_segment`: All pixels following the `white_gap` until the end of the row.\nConstruct the output row by concatenating these segments in the order: `initial_segment`, `white_gap`, `movable_block`, `final_segment`.\n\"\"\"\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Swaps the first contiguous non-white block with the immediately\n    following contiguous white block in a 1D input grid.\n\n    Args:\n        input_grid: A numpy array of shape (1, N) representing the input row.\n\n    Returns:\n        A numpy array of shape (1, M) representing the transformed row.\n        M might be the same as N, assuming no pixels are added/removed.\n    \"\"\"\n    # Ensure the input is a 1D array (or treat the first row if 2D)\n    if input_grid.ndim == 2 and input_grid.shape[0] == 1:\n        input_list = input_grid[0].tolist()\n    elif input_grid.ndim == 1:\n        input_list = input_grid.tolist()\n    else:\n        raise ValueError(\"Input grid must be 1D or have shape (1, N)\")\n\n    n = len(input_list)\n    \n    # --- Find Segment Boundaries ---\n    \n    movable_start = -1\n    movable_end = -1\n    gap_start = -1\n    gap_end = -1\n\n    # 1. Find the start of the movable_block (first non-white pixel)\n    for i in range(n):\n        if input_list[i] != 0:\n            movable_start = i\n            break\n    \n    # If no non-white pixel found (e.g., all white input), return original\n    if movable_start == -1:\n        print(\"Warning: No non-white block found.\")\n        return input_grid \n\n    # 2. Find the end of the movable_block (first white pixel *at or after* movable_start)\n    # This also marks the potential start of the white_gap\n    for i in range(movable_start, n):\n        if input_list[i] == 0:\n            movable_end = i\n            gap_start = i # White gap starts where the movable block ends\n            break\n    else: \n        # Non-white block extends to the end of the list\n        movable_end = n\n        # This implies no white_gap exists immediately after, violating the observed pattern.\n        print(\"Warning: Movable block extends to the end. No white gap found immediately after.\")\n        # Based on examples, this case shouldn't occur for a valid transformation.\n        # Return original or raise error depending on stricter requirements.\n        return input_grid \n\n    # 3. Find the end of the white_gap (first non-white pixel *at or after* gap_start)\n    for i in range(gap_start, n):\n        if input_list[i] != 0:\n            gap_end = i\n            break\n    else: \n        # White gap extends to the end of the list\n        gap_end = n\n\n    # --- Validate Segment Presence ---\n    # Check if a valid movable block was found (length > 0)\n    if movable_start == movable_end : # This shouldn't happen if movable_start != -1\n         print(f\"Warning: Zero-length movable block found? Start={movable_start}, End={movable_end}\")\n         return input_grid\n\n    # Check if a valid white gap was found (length > 0)\n    if gap_start == gap_end:\n        # This means the pixel sequence was ...non-white, non-white... with no white in between\n        print(f\"Warning: No white gap found immediately after movable block. Movable ends at {movable_end-1}, Gap starts at {gap_start}, Gap ends at {gap_end}.\")\n        # Based on examples, this shouldn't occur for a valid transformation.\n        return input_grid\n\n    # --- Extract Segments ---\n    # Segment 1: initial_segment (pixels before movable_block)\n    initial_segment = input_list[:movable_start]\n    \n    # Segment 2: movable_block (the non-white block)\n    movable_block = input_list[movable_start:movable_end]\n    \n    # Segment 3: white_gap (the white block immediately after)\n    white_gap = input_list[gap_start:gap_end]\n    \n    # Segment 4: final_segment (pixels after white_gap)\n    final_segment = input_list[gap_end:]\n\n    # --- Reconstruct Output ---\n    # Concatenate in the new order: initial + gap + movable + final\n    output_list = initial_segment + white_gap + movable_block + final_segment\n\n    # Convert back to numpy array with the shape (1, M)\n    # M should be equal to N as we only reordered elements\n    output_grid = np.array([output_list], dtype=input_grid.dtype)\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2357,
    "candidates_token_count": 1476,
    "total_token_count": 3833,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.341114,
  "retries": 1
}