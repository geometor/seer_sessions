{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Locate the single maroon (9) pixel at position (R, C).\n2. Determine the most frequent color in the entire input grid, excluding white (0) and maroon (9). This is the 'fill_color'.\n3. In the row R containing the maroon pixel, identify the contiguous block of white (0) pixels located immediately to the left of the maroon pixel (ending at column C-1).\n4. Change the color of all pixels within this contiguous white block to the 'fill_color'.\n5. Return the modified grid. If the marker is not found, return the original grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nimport logging # Optional: can be removed if not debugging\n\n# Configure logging - useful for debugging during development, can be commented out\n# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\n# --- Helper Functions ---\n\ndef _find_pixel_location(grid, color_value):\n    \"\"\"\n    Finds the (row, col) coordinates of the first occurrence of a specified color value.\n\n    Args:\n        grid (np.array): The input grid (2D NumPy array).\n        color_value (int): The color value to search for.\n\n    Returns:\n        tuple: A tuple (row, col) if the color is found, otherwise None.\n    \"\"\"\n    locations = np.where(grid == color_value)\n    if locations[0].size > 0:\n        row_index = locations[0][0]\n        col_index = locations[1][0]\n        # logging.debug(f\"Found color {color_value} at ({row_index}, {col_index})\")\n        return row_index, col_index\n    # logging.debug(f\"Color {color_value} not found in grid.\")\n    return None\n\ndef _determine_fill_color(grid, exclude_colors=(0, 9)):\n    \"\"\"\n    Determines the most frequent color in the grid, excluding specified colors.\n\n    Args:\n        grid (np.array): The input grid (2D NumPy array).\n        exclude_colors (tuple): Color values to exclude from frequency counting.\n\n    Returns:\n        int: The most frequent color value after exclusions. Returns 0 as a fallback\n             if no other candidate colors exist.\n    \"\"\"\n    flat_grid = grid.flatten()\n    color_counts = Counter(flat_grid)\n    # logging.debug(f\"Initial color counts: {color_counts}\")\n\n    for color in exclude_colors:\n        if color in color_counts:\n            del color_counts[color]\n    # logging.debug(f\"Counts after excluding {exclude_colors}: {color_counts}\")\n\n    if not color_counts:\n        # logging.warning(\"No candidate fill colors found after exclusions. Defaulting to 0.\")\n        return 0 # Fallback if only excluded colors are present\n\n    fill_color = color_counts.most_common(1)[0][0]\n    # logging.debug(f\"Determined fill color: {fill_color}\")\n    return fill_color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # logging.info(f\"Input grid shape: {grid.shape}\")\n\n    # Initialize output_grid as a copy of the input grid\n    output_grid = grid.copy()\n\n    # --- Workflow Steps ---\n\n    # 1. Identify the Marker: Locate the maroon (9) pixel.\n    marker_location = _find_pixel_location(grid, 9)\n\n    # If the marker pixel (9) is not found, return the original grid unchanged.\n    if marker_location is None:\n        # logging.warning(\"Maroon (9) marker pixel not found. Returning original grid.\")\n        return output_grid.tolist()\n\n    marker_row, marker_col = marker_location\n    # logging.info(f\"Maroon (9) marker found at: Row={marker_row}, Col={marker_col}\")\n\n    # 2. Determine the Fill Color: Find the most frequent color excluding white (0) and maroon (9).\n    fill_color = _determine_fill_color(grid, exclude_colors=(0, 9))\n    # logging.info(f\"Determined fill color: {fill_color}\")\n\n    # 3. & 4. Modify the Grid Contiguously:\n    # Iterate leftwards from the column immediately left of the marker (C-1).\n    # Change contiguous white (0) pixels to the fill_color until a non-white pixel\n    # or the start of the row is encountered.\n    # logging.info(f\"Applying fill color {fill_color} contiguously leftwards from ({marker_row}, {marker_col-1})\")\n    for col in range(marker_col - 1, -1, -1): # Iterate from C-1 down to 0\n        # Check if the current pixel in the output grid is white (0)\n        if output_grid[marker_row, col] == 0:\n            # If it's white, change its color to the determined fill_color\n            output_grid[marker_row, col] = fill_color\n            # logging.debug(f\"Changed pixel at ({marker_row}, {col}) from 0 to {fill_color}\")\n        else:\n            # If a non-white pixel is encountered, stop the contiguous fill process.\n            # logging.debug(f\"Encountered non-white pixel at ({marker_row}, {col}). Stopping fill.\")\n            break # Exit the loop\n\n    # 5. Output: Return the modified grid.\n    # Convert the NumPy array back to a list of lists format.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9343,
    "candidates_token_count": 1362,
    "total_token_count": 10705,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.979219,
  "retries": 1
}