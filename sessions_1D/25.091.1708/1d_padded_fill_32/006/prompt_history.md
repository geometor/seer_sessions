
## train_1

**input:**
```
0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0
```


**output:**
```
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0
```


## train_2

**input:**
```
0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 5 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 5 5 5 5 5 5 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0
```


**output:**
```
0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0
```

*   **Perception:**
    *   The input and output grids are single rows of pixels.
    *   Each input grid contains a background color (white, 0) and multiple instances of a single non-white foreground color (e.g., azure/8 in train\_1 and train\_3, gray/5 in train\_2).
    *   The output grid is generated by identifying the first and last occurrences of the foreground color in the input row.
    *   All pixels between the first and last foreground pixel (inclusive) in the output row are set to that foreground color.
    *   Pixels outside this range (before the first foreground pixel and after the last foreground pixel) remain the background color (white).
    *   The dimensions of the output grid are identical to the input grid.

*   **Facts:**
    
```yaml
    task_type: transformation
    grid_properties:
      - single_row: true
      - constant_dimensions: true # Output dimensions match input dimensions
    objects:
      - type: background_pixel
        color: white (0)
      - type: foreground_pixel
        color: non-white (varies per example, e.g., azure/8, gray/5)
        distribution: sparse, multiple occurrences
    relationships:
      - spatial: identifies the horizontal extent of foreground pixels
      - positional: finds the first and last occurrence of the foreground color
    actions:
      - identify_foreground_color: Find the single non-white color present in the input row.
      - find_boundaries: Locate the minimum and maximum column index containing the foreground color.
      - fill_range: Change the color of all pixels between the minimum and maximum indices (inclusive) to the foreground color in the output row.
      - preserve_background: Pixels outside the identified range retain the background color (white).
    ```


*   **Natural Language Program:**
    1.  Initialize the output grid as a copy of the input grid.
    2.  Iterate through each row of the input grid (in this case, there is only one row).
    3.  Identify the non-white foreground color present in the current row. If no non-white color exists, the output row remains unchanged (all white).
    4.  Find the column index of the leftmost occurrence (first instance) of this foreground color in the row.
    5.  Find the column index of the rightmost occurrence (last instance) of this foreground color in the row.
    6.  For the corresponding row in the output grid, change the color of all pixels from the leftmost index to the rightmost index (inclusive) to the identified foreground color.
```python
import numpy as np

"""
For each row in the input grid:
1. Identify the single non-white foreground color present in the row.
2. Find the column index of the leftmost occurrence (first instance) of this foreground color.
3. Find the column index of the rightmost occurrence (last instance) of this foreground color.
4. If a foreground color exists in the row, change the color of all pixels in the output grid's corresponding row, from the leftmost index to the rightmost index (inclusive), to the identified foreground color.
5. If no foreground color exists (the row is all white), the output row remains unchanged (all white).
Pixels outside the identified range (before the first foreground pixel and after the last foreground pixel) retain their original color (white background).
The dimensions of the output grid are identical to the input grid.
"""

def transform(input_grid):
    """
    Transforms the input grid by filling the horizontal span between the first and last
    occurrence of the foreground color in each row.

    Args:
        input_grid (list of list of int): The input grid represented as a 2D list.

    Returns:
        list of list of int: The transformed grid.
    """
    # Convert input to a numpy array for efficient processing
    input_np = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input
    output_np = input_np.copy()
    
    # Get the number of rows and columns
    rows, cols = input_np.shape
    
    # Define the background color (white)
    background_color = 0
    
    # Iterate through each row of the grid
    for r in range(rows):
        # Get the current row
        row = input_np[r, :]
        
        # Find the indices of all non-background pixels in the current row
        foreground_indices = np.where(row != background_color)[0]
        
        # Check if there are any foreground pixels in the row
        if foreground_indices.size > 0:
            # Identify the foreground color (assuming only one foreground color per row based on examples)
            # We can take the color of the first foreground pixel found
            foreground_color = row[foreground_indices[0]]
            
            # Find the minimum (leftmost) column index of the foreground color
            min_col = np.min(foreground_indices)
            # Find the maximum (rightmost) column index of the foreground color
            max_col = np.max(foreground_indices)
            
            # Fill the pixels in the output grid's row between min_col and max_col (inclusive)
            # with the foreground color
            output_np[r, min_col : max_col + 1] = foreground_color
            
        # If foreground_indices is empty, the row contains only the background color,
        # and the output row (being a copy) is already correct. No action needed.

    # Convert the numpy array back to a list of lists before returning
    return output_np.tolist()

```
```python
import numpy as np

"""
For each row in the input grid:
1. Identify the single non-white foreground color present in the row. If no non-white color exists, the output row remains unchanged (all white).
2. Find the column index of the leftmost occurrence (first instance) of this foreground color.
3. Find the column index of the rightmost occurrence (last instance) of this foreground color.
4. Change the color of all pixels in the output grid's corresponding row, from the leftmost index to the rightmost index (inclusive), to the identified foreground color.
5. Pixels outside this identified range retain their original color (which is the background color, white/0, in the examples).
The dimensions of the output grid are identical to the input grid.
"""

def transform(input_grid):
    """
    Transforms the input grid by filling the horizontal span between the first and last
    occurrence of the foreground color in each row independently.

    Args:
        input_grid (list of list of int): The input grid represented as a 2D list.

    Returns:
        list of list of int: The transformed grid.
    """
    # Convert input to a numpy array for efficient processing
    input_np = np.array(input_grid, dtype=int)
    # Initialize the output grid as a copy of the input
    # This handles rows with only background color automatically
    output_np = input_np.copy()

    # Get the number of rows
    rows = input_np.shape[0]

    # Define the background color (white)
    background_color = 0

    # Iterate through each row of the grid
    for r in range(rows):
        # Get the current row
        row = input_np[r, :]

        # Find the column indices of all non-background pixels in the current row
        # np.where returns a tuple of arrays, we need the first element for 1D arrays
        foreground_indices = np.where(row != background_color)[0]

        # Check if there are any foreground pixels in the row
        if foreground_indices.size > 0:
            # Identify the foreground color
            # Assumes only one foreground color per row based on examples.
            # Get the color of the first foreground pixel found.
            foreground_color = row[foreground_indices[0]]

            # Find the minimum (leftmost) column index of the foreground color
            min_col = np.min(foreground_indices)
            # Find the maximum (rightmost) column index of the foreground color
            max_col = np.max(foreground_indices)

            # Fill the pixels in the output grid's row between min_col and max_col (inclusive)
            # with the determined foreground color
            output_np[r, min_col : max_col + 1] = foreground_color
        # else: If foreground_indices is empty, the row contains only the background color.
        # Since output_np is a copy of input_np, this row is already correct. No action needed.

    # Convert the numpy array back to a list of lists before returning
    return output_np.tolist()
```
```python
import numpy as np

"""
Transforms the input grid by processing each row independently. 
For each row:
1. Identifies the non-background color (any color other than white/0).
2. Finds the leftmost (minimum column index) and rightmost (maximum column index) occurrences of this non-background color within that row.
3. If a non-background color exists in the row, it fills the segment between the leftmost and rightmost occurrences (inclusive) in the output grid's corresponding row with that non-background color.
4. Rows containing only the background color (white/0) remain unchanged.
The output grid has the same dimensions as the input grid.
"""

def transform(input_grid):
    """
    Fills the horizontal span between the first and last non-background pixel 
    in each row independently.

    Args:
        input_grid (list of list of int): The input grid represented as a 2D list.

    Returns:
        list of list of int: The transformed grid.
    """
    # Convert input list of lists to a NumPy array for efficient processing
    input_np = np.array(input_grid, dtype=int)
    
    # Create a copy of the input array to modify for the output.
    # This handles rows with only background color correctly, as they won't be modified.
    output_np = input_np.copy()
    
    # Get the number of rows in the grid
    rows = input_np.shape[0]
    
    # Define the background color explicitly (although 0 is standard)
    background_color = 0
    
    # Iterate through each row index
    for r in range(rows):
        # Get the current row from the input grid
        row = input_np[r, :]
        
        # Find the column indices of all pixels that are NOT the background color
        # np.where returns a tuple of arrays; for a 1D array, we need the first element
        foreground_indices = np.where(row != background_color)[0]
        
        # Check if any non-background pixels were found in this row
        if foreground_indices.size > 0:
            # Determine the non-background color present in this row.
            # Based on examples, assume only one non-background color per row.
            # We can get the color from the first foreground pixel found.
            foreground_color = row[foreground_indices[0]]
            
            # Find the minimum column index (leftmost occurrence)
            min_col = np.min(foreground_indices)
            
            # Find the maximum column index (rightmost occurrence)
            max_col = np.max(foreground_indices)
            
            # In the output grid's corresponding row, fill the pixels
            # from min_col to max_col (inclusive) with the foreground color.
            # Note: Python slicing is exclusive of the end index, so use max_col + 1.
            output_np[r, min_col : max_col + 1] = foreground_color
            
        # else: If foreground_indices is empty, the row contains only background pixels.
        # Since output_np started as a copy, this row is already correct and needs no changes.

    # Convert the modified NumPy array back to a list of lists for the return value
    return output_np.tolist()

```
