
## train_1

**input:**
```
0 2 0 0 2 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 2 0 0 2 0 0 0 0 0
```


**output:**
```
0 2 2 2 2 0 0 0 0 0 0 2 2 2 2 0 0 0 0 0 0 2 2 2 2 0 0 0 0 0
```


## train_2

**input:**
```
4 0 4 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0 4 0 4 0 0 0 0 0 0 0
```


**output:**
```
4 4 4 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0 4 4 4 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 7 0 7 0 0 0 0 0 0 0 7 0 7 0 0 0 0 0 0 0 7 0 7 0
```


**output:**
```
0 0 0 0 0 0 7 7 7 0 0 0 0 0 0 0 7 7 7 0 0 0 0 0 0 0 7 7 7 0
```

*   **Perception:**
    *   The input and output are grids of pixels with the same dimensions.
    *   Each example involves a transformation that operates independently on each row of the input grid.
    *   Each row in the input contains exactly two pixels of the same non-white color, separated by one or more white (0) pixels. All other pixels in the row are white.
    *   The transformation identifies the pair of identical non-white pixels in each row.
    *   The output is generated by changing the color of the white pixels located horizontally *between* the identified pair of non-white pixels to match the color of the pair.
    *   The original non-white pixels and any white pixels outside the span of the pair remain unchanged.

*   **Facts:**
    
```yaml
    task_type: grid_transformation
    scope: row_based
    input_output_relation:
      grid_dimensions: preserved
    elements:
      - type: background_pixel
        color: white (0)
      - type: marker_pixel
        color: non-white (1-9)
        properties:
          - exists_as_a_pair_per_row
          - pair_members_have_identical_color
          - pair_members_are_horizontally_separated_by_background_pixels
    transformation:
      action: fill_segment
      target: background_pixels
      condition: located_horizontally_between_a_pair_of_marker_pixels_in_the_same_row
      fill_color: color_of_the_marker_pixel_pair_in_that_row
    invariants:
      - position_and_color_of_marker_pixels
      - position_and_color_of_background_pixels_outside_the_marker_pair_span
      - grid_dimensions
      - colors_present (no new colors introduced other than filling)
    ```


*   **Natural Language Program:**
    1.  Iterate through each row of the input grid independently.
    2.  For the current row, identify the non-white color present (let this be `C`).
    3.  Find the column index of the leftmost pixel with color `C` (let this be `col_start`).
    4.  Find the column index of the rightmost pixel with color `C` (let this be `col_end`).
    5.  Iterate through the columns from `col_start + 1` up to `col_end - 1`.
    6.  For each pixel within this column range in the current row, change its color to `C`.
    7.  Keep all other pixels in the row (including the original pixels at `col_start` and `col_end`) unchanged.
    8.  Construct the output grid row by row based on these modifications.
```python
import numpy as np

"""
Iterate through each row of the input grid. For each row, find the pair of identical non-white pixels. Fill the white pixels located horizontally between this pair with the same non-white color. Leave all other pixels unchanged.
"""

def find_marker_pixels(row):
    """
    Finds the non-white color and the column indices of its occurrences in a row.
    Assumes exactly one non-white color and exactly two occurrences per row based on the task description.
    """
    marker_color = 0
    marker_indices = []
    for col_idx, pixel_value in enumerate(row):
        if pixel_value != 0:
            if marker_color == 0: # First non-white pixel found
                marker_color = pixel_value
            # Add index if it matches the marker color (handles cases where the first non-zero isn't the marker)
            if pixel_value == marker_color:
                 marker_indices.append(col_idx)

    # Check assumptions (optional but good practice)
    if marker_color == 0 or len(marker_indices) != 2:
         # Handle unexpected row format if necessary, or rely on problem constraints
         # For this specific task based on examples, we can assume valid input.
         pass 

    # Ensure indices are sorted (although find should return them in order)
    marker_indices.sort() 
    
    return marker_color, marker_indices


def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    For each row, it finds the pair of non-white pixels and fills the space
    between them with the same color.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Create a copy to modify, preserving the original input
    output_grid = np.copy(input_np)
    
    # Get grid dimensions
    height, width = input_np.shape

    # Iterate through each row
    for r in range(height):
        # Find the marker color and the column indices for this row
        marker_color, marker_indices = find_marker_pixels(input_np[r])

        # If a valid marker pair is found in the row
        if marker_color != 0 and len(marker_indices) == 2:
            col_start = marker_indices[0]
            col_end = marker_indices[1]

            # Iterate through the columns between the start and end markers
            # Note: range(col_start + 1, col_end) correctly excludes the markers themselves
            for c in range(col_start + 1, col_end):
                # Change the pixel color in the output grid to the marker color
                output_grid[r, c] = marker_color
                
    # Convert back to list of lists if necessary, or return numpy array
    # ARC standard is typically list of lists
    return output_grid.tolist()

```
```python
import numpy as np

"""
Iterate through each row of the input grid independently. 
For the current row, identify the non-white color present (C). There will be exactly two pixels with this color.
Find the column index of the leftmost pixel with color C (col_start) and the rightmost pixel with color C (col_end).
Iterate through the columns strictly between col_start and col_end (i.e., from col_start + 1 up to, but not including, col_end).
For each column index c in this range, set the pixel at (current_row, c) in the output grid to color C.
Leave all other pixels unchanged.
"""

def find_marker_indices_and_color(row):
    """
    Finds the column indices and color of the non-white marker pixels in a row.
    Assumes exactly two identical non-white markers per row.
    Returns (None, None) if the assumption is not met.
    """
    indices = np.where(row != 0)[0] # Find indices of all non-zero elements
    
    if len(indices) == 2:
        # Check if the two non-zero elements have the same color
        color1 = row[indices[0]]
        color2 = row[indices[1]]
        if color1 == color2:
            # Return the color and the sorted indices
            return color1, sorted(indices)
            
    # If not exactly two markers or they have different colors (unexpected based on examples)
    return None, None

def transform(input_grid):
    """
    Applies the transformation rule to the input grid.
    For each row, it finds the pair of identical non-white pixels and fills 
    the space strictly between them with the same color.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    # Create a copy to modify, preserving the original input
    output_grid = np.copy(input_np)
    
    # Get grid dimensions
    height, width = input_np.shape

    # Iterate through each row
    for r in range(height):
        # Get the current row
        row = input_np[r]
        
        # Find the marker color and the column indices for this row
        marker_color, marker_indices = find_marker_indices_and_color(row)

        # If a valid marker pair is found in the row
        if marker_color is not None and marker_indices is not None:
            col_start = marker_indices[0]
            col_end = marker_indices[1]

            # Iterate through the columns strictly between the start and end markers
            # range(col_start + 1, col_end) correctly excludes the markers themselves
            for c in range(col_start + 1, col_end):
                # Check if the pixel is currently background (white) before changing
                # Although the examples only show white pixels between markers, 
                # this check makes the logic slightly more robust if that wasn't always the case.
                # Based on the description, only background pixels between are targeted.
                if output_grid[r, c] == 0: 
                    # Change the pixel color in the output grid to the marker color
                    output_grid[r, c] = marker_color
                
    # Convert back to list of lists for the expected ARC format
    return output_grid.tolist()
```
