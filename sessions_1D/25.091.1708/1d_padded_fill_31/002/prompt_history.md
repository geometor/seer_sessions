
## train_1

**input:**
```
0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0
```


**output:**
```
0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0
```


## train_3

**input:**
```
0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0
```


**output:**
```
0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0
```

*   **Perception:**
    *   The input and output are both single rows (1D grids).
    *   Each input row contains mostly white pixels (0) and a few pixels of a single specific color (magenta, green, or yellow in the examples).
    *   The output row appears to be generated by filling the space *between* the first and last occurrence of the non-white color with that same color.
    *   The pixels outside the range defined by the first and last non-white pixel remain white.
    *   The original non-white pixels keep their positions and color.

*   **Facts:**
    
```yaml
    task_type: array_transformation
    grid_dimensionality: 1D (single row)
    input_composition:
      - background_color: white (0)
      - foreground_pixels:
          count: multiple
          color: single non-white color (varies per example: 6, 3, 4)
          distribution: sparse
    output_composition:
      - background_color: white (0) (outside the filled range)
      - foreground_pixels:
          color: same as input foreground color
          distribution: contiguous block spanning from the first to the last input foreground pixel
    transformation:
      action: fill_segment
      target: white pixels (0)
      range: strictly between the first and last occurrence of the non-white color
      fill_color: the non-white color present in the input
    invariance:
      - grid dimensions
      - position and color of original non-white pixels
      - color of white pixels outside the identified range
    ```


*   **Natural Language Program:**
    1.  Identify the single non-white color (let's call it `fill_color`) present in the input row.
    2.  Find the index of the first (leftmost) pixel with `fill_color`. Store this as `start_index`.
    3.  Find the index of the last (rightmost) pixel with `fill_color`. Store this as `end_index`.
    4.  Initialize the output row as a copy of the input row.
    5.  Iterate through the indices `i` from `start_index + 1` up to `end_index - 1`.
    6.  For each index `i`, set the color of the pixel at position `i` in the output row to `fill_color`.
    7.  Return the modified output row.
```python
import numpy as np

def find_non_white_color(grid):
  """Finds the first non-white color (value != 0) in the grid."""
  for pixel in grid:
    if pixel != 0:
      return pixel
  return None # Should not happen based on task description

def find_color_indices(grid, color):
  """Finds all indices of a given color in the grid."""
  return np.where(grid == color)[0]

def transform(input_grid):
  """
  Transforms the input grid by filling the segment between the first and 
  last occurrence of the non-white color with that same color.

  Args:
    input_grid: A 1D numpy array representing the input row.

  Returns:
    A 1D numpy array representing the transformed output row.
  """
  # Ensure input is a NumPy array
  input_grid_np = np.array(input_grid)

  # 1. Identify the single non-white color (fill_color)
  fill_color = find_non_white_color(input_grid_np)
  if fill_color is None:
      # Handle case with no non-white color (return input as is)
      return input_grid_np.copy() 

  # 2. Find the indices of all occurrences of the fill_color
  indices = find_color_indices(input_grid_np, fill_color)
  
  # Handle case with zero or one occurrence (no filling needed)
  if len(indices) < 2:
    return input_grid_np.copy()

  # 3. Get the first (start_index) and last (end_index) index
  start_index = indices[0]
  end_index = indices[-1]

  # 4. Initialize the output grid as a copy of the input grid
  output_grid = input_grid_np.copy()

  # 5 & 6. Iterate through the indices strictly between start_index and end_index 
  #        and set the color to fill_color.
  #        Using numpy slicing for efficiency: output_grid[start+1:end]
  if start_index + 1 < end_index: # Check if there's actually space between
      output_grid[start_index + 1 : end_index] = fill_color
  
  # 7. Return the modified output grid
  return output_grid
```
