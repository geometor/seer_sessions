{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 2D input grid (typically 1xN or Nx1) representing a 1D sequence.\nThe transformation involves:\n1. Identifying a single maroon pixel (9) acting as a stationary separator.\n2. Identifying a contiguous block of a single color (neither white 0 nor maroon 9).\n3. Calculating the distance (number of cells) between the separator and the nearest edge of the colored block in the flattened grid representation.\n4. Creating an output grid of the same shape as the input, initially filled with white (0).\n5. Placing the maroon separator (9) at its original position in the output grid (based on flattened index).\n6. Placing the colored block on the opposite side of the separator in the output grid, maintaining the calculated distance from the separator to the block's new nearest edge.\n7. The logic operates on a flattened 1D view, and the result is reshaped back to the original 2D shape.\n\"\"\"\n\ndef find_pixel_index(grid_1d, color):\n    \"\"\"\n    Finds the index of the first occurrence of a given color in a 1D numpy array.\n    Returns the index or -1 if not found.\n    \"\"\"\n    indices = np.where(grid_1d == color)[0]\n    if len(indices) > 0:\n        # Use .item() to ensure it's a standard Python int\n        return indices[0].item() \n    return -1 # Color not found\n\ndef find_colored_block(grid_1d):\n    \"\"\"\n    Finds the contiguous block of non-white (0), non-maroon (9) color in a 1D numpy array.\n    Returns: tuple (block_color, block_start_index, block_length) or None if not found.\n    Converts numpy types to standard python types.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_length = 0\n    in_block = False\n\n    for i, pixel in enumerate(grid_1d):\n        # Check if the pixel is part of the colored block\n        is_block_pixel = (pixel != 0 and pixel != 9)\n        \n        if is_block_pixel and not in_block: # Start of a potential block\n            block_color = pixel\n            block_start = i\n            block_length = 1\n            in_block = True\n        elif is_block_pixel and in_block: # Continuing the block\n            if pixel == block_color: # Check if it's the same color\n                block_length += 1\n            else: \n                # Found a different non-background/separator color - assumes only one block based on examples\n                # This means the previous block has ended.\n                break \n        elif not is_block_pixel and in_block: # End of the block (hit 0 or 9)\n             break # Found the complete block, stop searching\n\n    if block_start != -1:\n        # Convert numpy types if necessary before returning\n        block_color_py = block_color.item() if isinstance(block_color, np.generic) else block_color\n        # block_start and block_length are already standard python ints\n        return block_color_py, block_start, block_length\n    else:\n        return None # Block not found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n\n    Returns:\n        list of lists: The transformed 2D grid.\n    \"\"\"\n    # Convert input to numpy array and store original shape\n    input_array = np.array(input_grid, dtype=int)\n    original_shape = input_array.shape\n    \n    # Flatten the grid for 1D processing\n    input_flat = input_array.flatten()\n    grid_size = len(input_flat)\n\n    # Create a new 1D array (output sequence) filled with the background color (white, 0).\n    output_flat = np.zeros(grid_size, dtype=int)\n\n    # Find the index (`separator_index`) of the single maroon pixel (9).\n    separator_index = find_pixel_index(input_flat, 9)\n    if separator_index == -1:\n        print(\"Warning: Maroon separator (9) not found. Returning empty grid.\")\n        # Return an empty grid of original shape, or handle as per ARC rules.\n        return np.zeros(original_shape, dtype=int).tolist() \n\n    # Place the maroon pixel (9) into the output sequence at `separator_index`.\n    output_flat[separator_index] = 9\n\n    # Identify the contiguous block of pixels (not 0 or 9). \n    # Record its color (`block_color`), start index (`block_start_index`), and length (`block_length`).\n    block_info = find_colored_block(input_flat)\n    if block_info is None:\n        print(\"Warning: Colored block not found. Returning grid with only separator.\")\n        # Reshape the array with just the separator and return\n        return output_flat.reshape(original_shape).tolist()\n        \n    block_color, block_start_index, block_length = block_info\n    block_end_index = block_start_index + block_length - 1\n\n    # Determine if the block is to the left or right of the separator.\n    # Check block_end_index first for left side\n    block_on_left = block_end_index < separator_index \n\n    # Calculate the distance between the separator and the block's nearest edge.\n    distance = -1 # Initialize distance\n    if block_on_left:\n        # Block is left, nearest edge is block_end_index\n        distance = separator_index - block_end_index\n    else: # Block must be on the right (start index > separator index)\n        # Block is right, nearest edge is block_start_index\n        distance = block_start_index - separator_index\n        \n    # Ensure distance is at least 1 (based on examples, they are never adjacent)\n    # This also covers the case where the block wasn't properly identified relative to separator\n    if distance <= 0:\n         print(f\"Warning: Calculated distance is {distance}. Assuming minimum distance of 1.\")\n         distance = 1\n\n    # Calculate the starting index (`new_block_start_index`) for the block in the output array.\n    new_block_start_index = -1 # Initialize\n    if block_on_left:\n        # Move block from left to right: new start is separator + distance\n        new_block_start_index = separator_index + distance\n    else: # Block was on the right\n        # Move block from right to left: new end is separator - distance\n        new_block_end_index = separator_index - distance\n        new_block_start_index = new_block_end_index - block_length + 1\n\n    # Place the identified block into the output array.\n    # Calculate the index range for slicing (exclusive end)\n    new_block_actual_end_index = new_block_start_index + block_length\n    # Check bounds before placing\n    if new_block_start_index >= 0 and new_block_actual_end_index <= grid_size:\n        output_flat[new_block_start_index:new_block_actual_end_index] = block_color\n    else:\n        # Handle error: Block doesn't fit (shouldn't happen based on task constraints/examples)\n        print(f\"Error: Calculated new block position ({new_block_start_index} to {new_block_actual_end_index-1}) is out of bounds for grid size {grid_size}. Block not placed.\")\n        # Output array currently contains only the separator.\n        \n    # Reshape the 1D output sequence back into the original 2D shape.\n    output_grid_reshaped = output_flat.reshape(original_shape)\n\n    # Return the reshaped grid as a list of lists.\n    return output_grid_reshaped.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13722,
    "candidates_token_count": 1887,
    "total_token_count": 15609,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.968717,
  "retries": 1
}