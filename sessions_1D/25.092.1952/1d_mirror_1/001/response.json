{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n# COLOR_MAP = {\n#     0: (238, 238, 238),  # white\n#     1: (30, 147, 255),  # blue\n#     2: (220, 50, 40),  # red\n#     3: (79, 204, 48),  # green\n#     4: (230, 200, 0),  # yellow\n#     5: (85, 85, 85),  # gray\n#     6: (229, 58, 163),  # magenta\n#     7: (230, 120, 20),  # orange\n#     8: (135, 216, 241),  # azure\n#     9: (146, 18, 49),  # maroon\n# }\n\ndef find_movable_block(grid_list):\n    \"\"\"\n    Finds the first contiguous block of a single color that is not white (0)\n    or maroon (9).\n\n    Args:\n        grid_list: A list of integers representing the grid row.\n\n    Returns:\n        A tuple (block_color, block_start_index, block_length) if found,\n        otherwise raises ValueError.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_length = 0\n    n = len(grid_list)\n    i = 0\n    while i < n:\n        pixel_color = grid_list[i]\n        if pixel_color != 0 and pixel_color != 9:\n            # Found the start of a potential block\n            block_color = pixel_color\n            block_start = i\n            j = i\n            # Find the end of the block\n            while j < n and grid_list[j] == block_color:\n                j += 1\n            block_length = j - i\n            # Return the first block found\n            return block_color, block_start, block_length\n        i += 1\n    # If loop completes without finding a block\n    raise ValueError(\"Movable block not found in input.\")\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves a contiguous block of a single color (not white 0 or maroon 9)\n    from one side of the stationary maroon (9) pivot pixel to the other side,\n    ensuring exactly one white (0) pixel separates the block and the pivot\n    in the output. Assumes the input is a 1D list or represents a 1xN grid.\n    \"\"\"\n\n    # Ensure input is treated as a 1D list\n    if isinstance(input_grid, np.ndarray):\n        # Handle numpy array input, expecting 1D or 1xN / Nx1\n        if input_grid.ndim == 1:\n            input_list = input_grid.tolist()\n        elif input_grid.ndim == 2 and (input_grid.shape[0] == 1 or input_grid.shape[1] == 1):\n             input_list = input_grid.flatten().tolist()\n        else:\n            raise ValueError(\"Input grid must be 1D or effectively 1D (1xN or Nx1)\")\n    elif isinstance(input_grid, list):\n        # Basic check if it's a list of lists (potentially 2D)\n        if input_grid and isinstance(input_grid[0], list):\n             if len(input_grid) == 1: # Treat as 1xN\n                 input_list = input_grid[0]\n             elif all(len(row) == 1 for row in input_grid): # Treat as Nx1\n                 input_list = [row[0] for row in input_grid]\n             else:\n                 raise ValueError(\"Input grid must be 1D or effectively 1D (1xN or Nx1)\")\n        else: # Assume it's already a 1D list\n            input_list = input_grid\n    else:\n        raise TypeError(\"Input must be a list or a numpy array.\")\n\n\n    n = len(input_list)\n    if n == 0:\n        return [] # Handle empty input\n\n    # Initialize output grid (list) with background color (white 0)\n    output_list = [0] * n\n\n    # --- Workflow ---\n\n    # 1. Locate the pivot pixel (maroon 9)\n    try:\n        pivot_index = input_list.index(9)\n    except ValueError:\n        raise ValueError(\"Pivot pixel (9) not found in input.\")\n\n    # 2. Place the pivot pixel in the output list\n    output_list[pivot_index] = 9\n\n    # 3. Identify the movable block (color, start index, length) using helper\n    block_color, block_start_index, block_length = find_movable_block(input_list)\n\n    # 4. Determine if the block is currently left or right of the pivot\n    is_left_of_pivot = block_start_index < pivot_index\n\n    # 5. Calculate the new starting index for the block in the output list\n    if is_left_of_pivot:\n        # Block was left, move it to the right of the pivot\n        # The new layout should be: ... Pivot | White(0) | Block_Start ...\n        new_start_index = pivot_index + 2\n    else:\n        # Block was right, move it to the left of the pivot\n        # The new layout should be: ... Block_End | White(0) | Pivot ...\n        # The start index needs to be calculated from the pivot position backwards\n        # Indices occupied by block: new_start_index to new_start_index + block_length - 1\n        # Index before pivot: pivot_index - 1 (should be white)\n        # Index of last block element: pivot_index - 2\n        # Index of first block element: (pivot_index - 2) - (block_length - 1) = pivot_index - block_length - 1\n        new_start_index = pivot_index - block_length - 1\n\n    # 6. Check if the calculated new position is valid (within bounds)\n    if new_start_index < 0 or (new_start_index + block_length) > n:\n         # This might indicate an input where the move isn't possible with the required spacing\n         raise ValueError(f\"Calculated new block position ({new_start_index} to {new_start_index + block_length -1}) is out of bounds for length {n}.\")\n\n    # 7. Place the block in the output list at the new calculated position\n    for k in range(block_length):\n        current_output_index = new_start_index + k\n        # Sanity check: Ensure we are not overwriting the pivot pixel.\n        # This should only happen if block_length is too large or spacing is wrong.\n        if current_output_index == pivot_index:\n             raise ValueError(\"Block placement calculation conflicts with pivot position.\")\n        # Ensure we are only writing over background (0) pixels\n        if output_list[current_output_index] != 0:\n             raise ValueError(f\"Attempting to overwrite non-background pixel at index {current_output_index} during block placement.\")\n\n        output_list[current_output_index] = block_color\n\n    # Return the transformed list\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2476,
    "candidates_token_count": 1744,
    "total_token_count": 4220,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 41.54912,
  "retries": 1
}