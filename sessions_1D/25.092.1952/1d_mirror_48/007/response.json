{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional\n\n\"\"\"\nTransformation Rule:\nIdentifies a unique pivot element (color 9) and a single contiguous horizontal segment of another color (non-0, non-9) within the same row of a 2D numpy grid.\nThe segment is then moved horizontally to the opposite side of the pivot element within that row, while maintaining the exact same number of background pixels (color 0) horizontally separating the segment and the pivot column as existed in the input grid.\nThe pivot's position remains fixed. The segment's color and length (width) remain unchanged. All other positions in the output grid are filled with the background color (0). The output grid has the same dimensions as the input grid.\n\"\"\"\n\ndef find_pivot(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Locates the coordinates (row, column) of the pivot element (9).\n\n    Args:\n        grid: The 2D input numpy array.\n\n    Returns:\n        A tuple (row, column) of the pivot, or None if not found or multiple pivots exist.\n    \"\"\"\n    pivot_coords = np.argwhere(grid == 9)\n    if len(pivot_coords) == 1:\n        # Return standard Python ints for coordinates\n        return int(pivot_coords[0, 0]), int(pivot_coords[0, 1])\n    elif len(pivot_coords) == 0:\n        print(\"Warning: Pivot element (9) not found.\")\n        return None\n    else:\n        print(f\"Warning: Expected 1 pivot (9), found {len(pivot_coords)}. Coordinates: {pivot_coords}\")\n        return None # Ambiguous which pivot to use\n\ndef find_horizontal_segment_in_row(grid: np.ndarray, row_index: int, pivot_col: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the single contiguous horizontal segment of non-0, non-9 color in the specified row.\n\n    Args:\n        grid: The 2D input numpy array.\n        row_index: The row index to search within.\n        pivot_col: The column index of the pivot (to ignore).\n\n    Returns:\n        A tuple containing (segment_color, start_col, end_col, length),\n        or None if no single valid segment is found in that row.\n    \"\"\"\n    row_data = grid[row_index, :]\n    segment_color = -1\n    start_col = -1\n    current_length = 0\n    found_segment = None # Store potential segment info here\n\n    for col_index, color in enumerate(row_data):\n        # Skip background and the pivot itself\n        if color == 0 or col_index == pivot_col:\n            if start_col != -1:\n                # End of a potential segment\n                if found_segment is not None:\n                     # Found a second segment after already finding one - error\n                     print(f\"Warning: Found multiple segments in row {row_index}. Previous: {found_segment}, current ends at col {col_index-1}.\")\n                     return None # Violates single segment assumption\n                found_segment = (segment_color, start_col, col_index - 1, current_length)\n                # Reset for searching next potential segment (though we expect only one)\n                start_col = -1\n                current_length = 0\n            continue # Move to next column\n\n        # Found a non-background, non-pivot color\n        current_color = int(color)\n\n        if start_col == -1:\n            # Start of a new potential segment\n            segment_color = current_color\n            start_col = col_index\n            current_length = 1\n        elif current_color == segment_color:\n            # Continuation of the current segment\n            current_length += 1\n        else:\n            # Found a different color, ending the previous segment\n            if found_segment is not None:\n                 print(f\"Warning: Found multiple segments or colors in row {row_index}.\")\n                 return None # Violates assumption\n            found_segment = (segment_color, start_col, col_index - 1, current_length)\n            # Start tracking the new color segment immediately\n            segment_color = current_color\n            start_col = col_index\n            current_length = 1\n\n    # Check if a segment was ongoing when the row ended\n    if start_col != -1:\n        if found_segment is not None:\n             print(f\"Warning: Found multiple segments in row {row_index} (one ending at grid edge).\")\n             return None\n        found_segment = (segment_color, start_col, grid.shape[1] - 1, current_length)\n\n    if found_segment is None:\n        print(f\"Warning: No valid segment found in row {row_index}.\")\n\n    return found_segment\n\n\ndef calculate_horizontal_distance(grid: np.ndarray, row_index: int, start_col: int, end_col: int, pivot_col: int) -> int:\n    \"\"\"\n    Calculates the number of background (0) pixels horizontally between the segment and the pivot.\n\n    Args:\n        grid: The 2D input numpy array.\n        row_index: The row index where segment and pivot reside.\n        start_col: The starting column index of the segment.\n        end_col: The ending column index of the segment.\n        pivot_col: The column index of the pivot element.\n\n    Returns:\n        The count of background (0) pixels strictly between the segment and pivot column.\n    \"\"\"\n    distance = 0\n    row_data = grid[row_index, :]\n\n    if end_col < pivot_col: # Segment is to the left\n        # Count zeros between segment end (exclusive) and pivot col (exclusive)\n        sub_array = row_data[end_col + 1 : pivot_col]\n        distance = np.sum(sub_array == 0)\n    elif start_col > pivot_col: # Segment is to the right\n        # Count zeros between pivot col (exclusive) and segment start (exclusive)\n        sub_array = row_data[pivot_col + 1 : start_col]\n        distance = np.sum(sub_array == 0)\n    # Else: segment is adjacent, distance is 0, handled correctly by slicing\n\n    return int(distance) # Ensure standard int return\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule: moves a colored horizontal segment to the\n    opposite side of a pivot (color 9) within the same row, preserving the\n    horizontal count of background (0) pixels between them.\n    \"\"\"\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    # Basic validation for 2D grid\n    if input_grid.ndim != 2:\n        print(\"Error: Input grid must be 2-dimensional.\")\n        # Return input or empty? Returning input shape filled with 0s.\n        return np.zeros_like(input_grid)\n\n    rows, cols = input_grid.shape\n    # Initialize output grid with background color (0)\n    output_grid = np.zeros((rows, cols), dtype=input_grid.dtype)\n\n    # 1. Find the pivot element (color 9)\n    pivot_coords = find_pivot(input_grid)\n    if pivot_coords is None:\n        # Error message printed in helper, return empty grid\n        return output_grid\n\n    pivot_row, pivot_col = pivot_coords\n\n    # 2. Place the pivot in the output grid at its fixed position\n    output_grid[pivot_row, pivot_col] = 9\n\n    # 3. Find the contiguous horizontal segment in the pivot's row\n    segment_info = find_horizontal_segment_in_row(input_grid, pivot_row, pivot_col)\n    if segment_info is None:\n        # Warning printed in helper, return grid with only pivot placed\n        return output_grid\n\n    segment_color, segment_start_col, segment_end_col, segment_length = segment_info\n\n    # 4. Calculate the horizontal distance (number of 0s) between segment and pivot\n    distance = calculate_horizontal_distance(input_grid, pivot_row, segment_start_col, segment_end_col, pivot_col)\n\n    # 5. Determine the new starting column for the segment on the opposite side\n    new_segment_start_col = -1\n    if segment_end_col < pivot_col: # Segment was to the left, move to the right\n        new_segment_start_col = pivot_col + distance + 1\n    elif segment_start_col > pivot_col: # Segment was to the right, move to the left\n        new_segment_start_col = pivot_col - distance - segment_length\n    else:\n        # Should not happen if segment/pivot validation is correct and they don't overlap/touch\n        print(\"Error: Segment appears adjacent to or overlapping pivot, cannot determine move direction.\")\n        return output_grid # Return grid with just pivot\n\n    # 6. Place the segment in the output grid at the new position\n    # Check if the calculated new position is valid and within bounds\n    new_segment_end_col = new_segment_start_col + segment_length\n    if 0 <= new_segment_start_col < cols and new_segment_end_col <= cols:\n        output_grid[pivot_row, new_segment_start_col : new_segment_end_col] = segment_color\n    else:\n        print(f\"Warning: Calculated new segment position col:[{new_segment_start_col}:{new_segment_end_col}] in row {pivot_row} is out of bounds for grid cols {cols}.\")\n        # Fallback: Return grid with only the pivot placed if segment doesn't fit\n        output_grid_fallback = np.zeros_like(input_grid)\n        output_grid_fallback[pivot_row, pivot_col] = 9\n        return output_grid_fallback\n\n    # 7. Return the completed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14055,
    "candidates_token_count": 2366,
    "total_token_count": 16421,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.362431,
  "retries": 1
}