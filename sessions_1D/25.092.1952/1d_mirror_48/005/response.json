{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional\n\n\"\"\"\nTransformation Rule:\nIdentifies a unique pivot element (color 9) and a single contiguous segment of another color (non-0, non-9) within a 1D numpy array.\nThe segment is then moved to the opposite side of the pivot element, while maintaining the exact same number of background pixels (color 0) between the segment and the pivot as existed in the input array.\nThe pivot's position remains fixed. The segment's color and length remain unchanged. All other positions in the output array are filled with the background color (0).\n\"\"\"\n\ndef find_pivot(grid: np.ndarray) -> Optional[int]:\n    \"\"\"\n    Locates the index of the pivot element (9).\n\n    Args:\n        grid: The 1D input numpy array.\n\n    Returns:\n        The index of the pivot element (9), or None if not found or if multiple pivots exist.\n    \"\"\"\n    pivot_indices = np.where(grid == 9)[0]\n    if len(pivot_indices) == 1:\n        return int(pivot_indices[0])\n    # Handle cases where pivot is not found or multiple pivots exist (violates task constraint)\n    print(f\"Warning: Expected 1 pivot (9), found {len(pivot_indices)}. Indices: {pivot_indices}\")\n    return None\n\ndef find_segment(grid: np.ndarray, pivot_index: Optional[int]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the single contiguous segment of non-0, non-9 color.\n\n    Args:\n        grid: The 1D input numpy array.\n        pivot_index: The index of the pivot element, or None.\n\n    Returns:\n        A tuple containing (segment_color, segment_start_index, segment_length),\n        or None if no single valid segment is found.\n    \"\"\"\n    segment_color = -1\n    segment_start = -1\n    segment_length = 0\n    found_segment = False\n\n    for i, color in enumerate(grid):\n        # Skip background and the pivot itself\n        if color == 0 or (pivot_index is not None and i == pivot_index):\n            # If we were tracking a segment, it ends here\n            if segment_start != -1:\n                found_segment = True\n                break\n            continue # Continue searching\n\n        # Found a non-background, non-pivot color\n        current_color = int(color) # Ensure standard int\n\n        if segment_start == -1:\n            # Start of a potential segment\n            segment_color = current_color\n            segment_start = i\n            segment_length = 1\n        elif current_color == segment_color:\n            # Continuation of the current segment\n            segment_length += 1\n        else:\n            # Found a different color - implies multiple segments or noise\n            # Based on examples, we assume only one segment. If we already started one, break.\n             if segment_start != -1:\n                 found_segment = True\n                 break\n             # If we hadn't started one yet, this is the first potential segment cell\n             segment_color = current_color\n             segment_start = i\n             segment_length = 1\n\n\n    # Check if a segment was identified (either by loop break or reaching the end)\n    if segment_start != -1:\n         # If loop finished without break, mark found_segment as true if segment exists\n         if not found_segment:\n              found_segment = True\n\n    # Final check for validity\n    if found_segment and segment_length > 0:\n         # Check if another segment starts after the one found - this would violate assumption\n         if pivot_index is not None:\n             search_start = segment_start + segment_length\n             for j in range(search_start, len(grid)):\n                  if grid[j] != 0 and j != pivot_index:\n                      print(f\"Warning: Found multiple segments. First: color={segment_color} start={segment_start} len={segment_length}. Second starts at index {j}.\")\n                      # Depending on strictness, could return None here. Sticking with first found.\n                      break \n         return segment_color, segment_start, segment_length\n    else:\n        print(\"Warning: No valid segment found.\")\n        return None\n\ndef calculate_distance(grid: np.ndarray, segment_start: int, segment_length: int, pivot_index: int) -> int:\n    \"\"\"\n    Calculates the number of background (0) pixels between the segment and the pivot.\n\n    Args:\n        grid: The 1D input numpy array.\n        segment_start: The starting index of the segment.\n        segment_length: The length of the segment.\n        pivot_index: The index of the pivot element.\n\n    Returns:\n        The count of background (0) pixels strictly between the segment and pivot.\n    \"\"\"\n    segment_end = segment_start + segment_length - 1\n    distance = 0\n\n    if segment_end < pivot_index: # Segment is to the left\n        # Count zeros between segment end (exclusive) and pivot index (exclusive)\n        sub_array = grid[segment_end + 1 : pivot_index]\n        distance = np.sum(sub_array == 0)\n    elif segment_start > pivot_index: # Segment is to the right\n        # Count zeros between pivot index (exclusive) and segment start (exclusive)\n        sub_array = grid[pivot_index + 1 : segment_start]\n        distance = np.sum(sub_array == 0)\n    # Else: segment is adjacent, distance is 0, handled correctly by slicing returning empty array\n\n    return int(distance) # Ensure standard int return\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule: moves a colored segment to the opposite\n    side of a pivot (color 9), preserving the count of background (0) pixels\n    between them.\n    \"\"\"\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    # Check if input is 1D\n    if input_grid.ndim != 1:\n        raise ValueError(\"Input grid must be 1-dimensional\")\n\n    n = len(input_grid)\n    # Initialize output grid with background color (0)\n    output_grid = np.zeros(n, dtype=input_grid.dtype)\n\n    # 1. Find the pivot element (color 9)\n    pivot_index = find_pivot(input_grid)\n    if pivot_index is None:\n        print(\"Error: Pivot element (9) not found or invalid.\")\n        # Return an empty grid or raise error? Returning empty for now.\n        return np.zeros_like(input_grid)\n\n    # 2. Place the pivot in the output grid at its fixed position\n    output_grid[pivot_index] = 9\n\n    # 3. Find the contiguous segment (color != 0 and != 9)\n    segment_info = find_segment(input_grid, pivot_index)\n    if segment_info is None:\n        print(\"Warning: No valid segment found. Returning grid with only pivot.\")\n        # Return grid with only the pivot placed if no segment exists\n        return output_grid\n\n    segment_color, segment_start, segment_length = segment_info\n    segment_end = segment_start + segment_length - 1 # Calculate segment end index\n\n    # 4. Calculate the distance (number of 0s) between the segment and pivot\n    distance = calculate_distance(input_grid, segment_start, segment_length, pivot_index)\n\n    # 5. Determine the new starting position for the segment on the opposite side\n    new_segment_start = -1\n    if segment_end < pivot_index: # Segment was to the left, move to the right\n        new_segment_start = pivot_index + distance + 1\n    elif segment_start > pivot_index: # Segment was to the right, move to the left\n        new_segment_start = pivot_index - distance - segment_length\n    else:\n        # Should not happen if segment/pivot validation is correct and they don't overlap/touch\n        print(\"Error: Segment appears adjacent to or overlapping pivot, cannot determine move.\")\n        return output_grid # Return grid with just pivot\n\n    # 6. Place the segment in the output grid at the new position\n    # Check if the calculated new position is valid and within bounds\n    new_segment_end = new_segment_start + segment_length\n    if 0 <= new_segment_start < n and new_segment_end <= n:\n        output_grid[new_segment_start : new_segment_end] = segment_color\n    else:\n        print(f\"Warning: Calculated new segment position [{new_segment_start}:{new_segment_end}] is out of bounds for grid size {n}.\")\n        # Fallback: Return grid with only the pivot placed if segment doesn't fit\n        output_grid_fallback = np.zeros_like(input_grid)\n        output_grid_fallback[pivot_index] = 9\n        return output_grid_fallback\n\n    # 7. Return the completed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10128,
    "candidates_token_count": 2143,
    "total_token_count": 12271,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.582608,
  "retries": 1
}