{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid (represented as a single row) into a 2-row output grid.\nIt finds an anchor pixel (maroon, 9) and a horizontal payload line (any other \nnon-white color) in the input row. \nThe transformation places both the anchor and the payload into the second row \n(index 1) of the output grid. The anchor maintains its original column index.\nThe payload line's horizontal starting position in the output is determined by \na relative distance rule: the distance from the anchor's column to the payload's\n*end* column in the input dictates the distance from the anchor's column to the \npayload's *start* column in the output. The first row (index 0) of the output \ngrid is filled with the background color (white, 0).\n\"\"\"\n\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef find_anchor_in_row(row_data, anchor_color=9):\n    \"\"\"\n    Finds the column index of the first occurrence of the anchor pixel \n    in a given 1D array (row).\n    Returns the column index or None if not found.\n    \"\"\"\n    for c_idx, pixel in enumerate(row_data):\n        if pixel == anchor_color:\n            return c_idx\n    return None \n\ndef find_payload_in_row(row_data, background_color=0, anchor_color=9):\n    \"\"\"\n    Finds the first contiguous horizontal line of non-background, non-anchor \n    color in a given 1D array (row).\n    Returns its color, starting column index, and length, or (None, None, None) \n    if not found.\n    \"\"\"\n    width = len(row_data)\n    for c_idx in range(width):\n        pixel = row_data[c_idx]\n        # Check if the pixel is a potential start of the payload\n        if pixel != background_color and pixel != anchor_color:\n            # Ensure it's the actual start (not preceded by the same color)\n            if c_idx == 0 or row_data[c_idx-1] != pixel:\n                payload_color = pixel\n                payload_col_start_in = c_idx\n                payload_length = 0\n                # Measure the length of the contiguous line\n                for k in range(c_idx, width):\n                    if row_data[k] == payload_color:\n                        payload_length += 1\n                    else:\n                        break # End of line\n                return payload_color, payload_col_start_in, payload_length\n    # Return None if no payload line is found\n    return None, None, None \n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # --- Input Validation and Setup ---\n    # Check input format: must be a list containing at least one list (the row)\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list) or not input_grid[0]:\n        # Handle invalid or empty input: return an empty 2x0 grid structure\n        # Or potentially raise an error, depending on desired robustness.\n        # Returning empty list aligns with structure if width were 0.\n        print(\"Warning: Invalid or empty input grid. Returning empty structure.\")\n        return [[], []] \n        \n    # Extract the first row as the primary data source\n    input_row_data = input_grid[0]\n    input_width = len(input_row_data)\n    \n    # Define output grid dimensions\n    output_height = 2 \n    output_width = input_width\n    \n    # Initialize the output grid with background color (0)\n    output_np = np.zeros((output_height, output_width), dtype=int)\n\n    # --- Find Objects in Input Row ---\n    # Find the anchor's column index\n    c_anchor = find_anchor_in_row(input_row_data, anchor_color=9)\n    \n    # Find the payload's details\n    payload_color, c_payload_start_in, l_payload = find_payload_in_row(input_row_data)\n\n    # --- Handle Missing Objects ---\n    # If anchor or payload is missing, return the initialized (mostly white) grid\n    # Potentially place anchor if it *was* found but payload was not.\n    if c_anchor is None or payload_color is None:\n        print(f\"Warning: Anchor {'found' if c_anchor is not None else 'NOT FOUND'}, Payload {'found' if payload_color is not None else 'NOT FOUND'}. Returning default grid.\")\n        # If anchor was found, place it in the output grid's second row\n        if c_anchor is not None:\n             # Basic bounds check (should be safe by width construction)\n             if 0 <= c_anchor < output_width:\n                  output_np[1, c_anchor] = 9 # Place in row index 1\n        return output_np.tolist() # Return the grid (white or with anchor)\n\n    # --- Calculate Output Positions ---\n    # Calculate the end column of the payload in the input row\n    c_payload_end_in = c_payload_start_in + l_payload - 1\n\n    # Calculate the relative distance for positioning\n    dist = c_anchor - c_payload_end_in\n    \n    # Calculate the starting column for the payload in the output row\n    c_payload_start_out = c_anchor + dist\n    \n    # Define the target row index for both anchor and payload in the output\n    r_output = 1 \n\n    # --- Populate Output Grid (Row 1) ---\n    # Place the anchor pixel in the output grid's second row\n    # Bounds check (mostly for safety, should be valid)\n    if 0 <= c_anchor < output_width:\n        output_np[r_output, c_anchor] = 9\n    \n    # Draw the payload line in the output grid's second row\n    for i in range(l_payload):\n        current_col = c_payload_start_out + i\n        # Check if the current drawing column is within the grid bounds\n        if 0 <= current_col < output_width:\n            # Place the payload pixel\n            output_np[r_output, current_col] = payload_color\n            \n    # --- Return Result ---\n    # Convert the NumPy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12380,
    "candidates_token_count": 1512,
    "total_token_count": 13892,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.874675,
  "retries": 1
}