{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid (represented as a single flat list, conceptually 1xN) \ninto a 2xN output grid. It identifies a maroon (9) anchor pixel and a \ncontiguous horizontal payload line (any other non-white color) in the input. \nThe anchor and the payload are then placed into the second row (index 1) of \nthe output grid. The anchor retains its original column index. The payload \nline's starting column in the output is determined by a relative distance rule: \nthe distance from the anchor's column to the payload's end column in the input \ndictates the distance from the anchor's column to the payload's start column \nin the output (output_start = anchor + (anchor - input_end)). The first row \n(index 0) of the output grid remains white (0).\n\"\"\"\n\nimport numpy as np\n\n# --- Helper Functions ---\n\ndef find_anchor_in_row(row_data, anchor_color=9):\n    \"\"\"\n    Finds the column index of the first occurrence of the anchor pixel \n    in a given 1D list or array (row).\n    Returns the column index or None if not found.\n    \"\"\"\n    for c_idx, pixel in enumerate(row_data):\n        if pixel == anchor_color:\n            return c_idx\n    return None \n\ndef find_payload_in_row(row_data, background_color=0, anchor_color=9):\n    \"\"\"\n    Finds the first contiguous horizontal line of non-background, non-anchor \n    color in a given 1D list or array (row).\n    Returns its color, starting column index, and length, or (None, None, None) \n    if not found.\n    \"\"\"\n    width = len(row_data)\n    for c_idx in range(width):\n        pixel = row_data[c_idx]\n        # Check if the pixel is a potential start of the payload\n        if pixel != background_color and pixel != anchor_color:\n            # Ensure it's the actual start (not preceded by the same color)\n            if c_idx == 0 or row_data[c_idx-1] != pixel:\n                payload_color = pixel\n                payload_col_start_in = c_idx\n                payload_length = 0\n                # Measure the length of the contiguous line\n                for k in range(c_idx, width):\n                    if row_data[k] == payload_color:\n                        payload_length += 1\n                    else:\n                        break # End of line\n                return payload_color, payload_col_start_in, payload_length\n    # Return None if no payload line is found\n    return None, None, None \n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # --- Input Validation and Setup ---\n    # The input is expected to be a single flat list representing the 1xN grid.\n    if not isinstance(input_grid, list) or not input_grid:\n        print(\"Warning: Invalid or empty input grid (expected a non-empty list). Returning empty structure.\")\n        # Return structure matching expected output format for zero width\n        return [[], []] \n        \n    input_row_data = input_grid # Treat the input list directly as the row data\n    input_width = len(input_row_data)\n    \n    # Define output grid dimensions based on input width\n    output_height = 2 \n    output_width = input_width\n    \n    # Initialize the 2xN output grid with background color (0 - white)\n    output_np = np.zeros((output_height, output_width), dtype=int)\n\n    # --- Find Objects in Input Row ---\n    # Find the anchor's column index in the input data\n    c_anchor = find_anchor_in_row(input_row_data, anchor_color=9)\n    \n    # Find the payload's details (color, start column, length) in the input data\n    payload_color, c_payload_start_in, l_payload = find_payload_in_row(input_row_data)\n\n    # --- Handle Missing Objects ---\n    # If either the anchor or the payload is missing, return the default grid \n    # (all white, potentially with the anchor placed if found).\n    if c_anchor is None or payload_color is None:\n        print(f\"Warning: Anchor {'found' if c_anchor is not None else 'NOT FOUND'}, Payload {'found' if payload_color is not None else 'NOT FOUND'}. Returning default grid.\")\n        # If only the anchor was found, place it in the output grid's second row\n        if c_anchor is not None:\n             # Basic bounds check \n             if 0 <= c_anchor < output_width:\n                  output_np[1, c_anchor] = 9 # Place anchor in row index 1\n        return output_np.tolist() # Return the initialized or partially filled grid\n\n    # --- Calculate Output Positions ---\n    # Calculate the end column of the payload in the input row\n    c_payload_end_in = c_payload_start_in + l_payload - 1\n\n    # Calculate the relative distance: anchor column - payload end column\n    dist = c_anchor - c_payload_end_in\n    \n    # Calculate the starting column for the payload in the output row using the rule\n    c_payload_start_out = c_anchor + dist\n    \n    # Define the target row index for placing both anchor and payload in the output\n    r_output = 1 \n\n    # --- Populate Output Grid (Row 1) ---\n    # Place the anchor pixel in the output grid's second row (index 1)\n    # Bounds check (should be valid based on width calculation)\n    if 0 <= c_anchor < output_width:\n        output_np[r_output, c_anchor] = 9\n    \n    # Draw the payload line in the output grid's second row (index 1)\n    for i in range(l_payload):\n        current_col = c_payload_start_out + i\n        # Check if the current drawing column is within the grid's width bounds\n        if 0 <= current_col < output_width:\n            # Place the payload pixel at the calculated position\n            output_np[r_output, current_col] = payload_color\n            \n    # --- Return Result ---\n    # Convert the final NumPy array back to a list of lists format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13634,
    "candidates_token_count": 1518,
    "total_token_count": 15152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.525207,
  "retries": 1
}