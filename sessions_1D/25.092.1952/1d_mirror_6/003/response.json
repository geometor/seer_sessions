{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_anchor_in_row(row_data, anchor_color=9):\n    \"\"\"\n    Finds the column index of the first occurrence of the anchor pixel \n    in a given 1D array (row).\n    Returns the column index or None if not found.\n    \"\"\"\n    # Iterate through the row data with index\n    for c_idx, pixel in enumerate(row_data):\n        # Check if the pixel matches the anchor color\n        if pixel == anchor_color:\n            # Return the column index if found\n            return c_idx\n    # Return None if the loop completes without finding the anchor\n    return None \n\ndef find_payload_in_row(row_data, background_color=0, anchor_color=9):\n    \"\"\"\n    Finds the first contiguous horizontal line of non-background, non-anchor \n    color in a given 1D array (row).\n    Returns its color, starting column index, and length, or (None, None, None) \n    if not found.\n    \"\"\"\n    width = len(row_data)\n    # Iterate through the row data to find the start of the payload\n    for c_idx in range(width):\n        pixel = row_data[c_idx]\n        # Check if the pixel is a potential payload color\n        if pixel != background_color and pixel != anchor_color:\n            # Check if this is the actual start of the line \n            # (i.e., it's the first pixel or the previous pixel is different)\n            if c_idx == 0 or row_data[c_idx-1] != pixel:\n                payload_color = pixel\n                payload_col_start_in = c_idx\n                payload_length = 0\n                # Measure the length of the contiguous line of this color\n                for k in range(c_idx, width):\n                    if row_data[k] == payload_color:\n                        payload_length += 1\n                    else:\n                        # Stop counting when the color changes or end of row\n                        break \n                # Return the found payload details\n                return payload_color, payload_col_start_in, payload_length\n    # Return None if no payload line is found in the row\n    return None, None, None \n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms an input grid based on finding an anchor pixel (maroon, 9) and a \n    horizontal payload line (any other non-white color) in the first row. \n    The payload line is moved to a new row (assumed to be row 1 in a 2-row \n    output grid) and its horizontal position is adjusted relative to the anchor.\n\n    The transformation rule identified from examples is:\n    The horizontal distance from the anchor's column to the END column of the \n    payload line in the input determines the horizontal distance from the \n    anchor's column to the START column of the payload line in the output.\n\n    Assumptions derived from the provided examples:\n    1. The anchor pixel (9) and the payload line exist and are located in the \n       first row/list element of the input_grid data structure.\n    2. The required output grid always has a height of 2.\n    3. The output grid has the same width as the input row where objects were found.\n    4. The anchor's final position in the output grid is in row index 1, at the \n       same column index it occupied in the input row.\n    5. The entire payload line moves to row index 1 in the output grid.\n    \"\"\"\n    \n    # --- Input Validation and Analysis ---\n    # Check if input_grid is a list, is not empty, and its first element is also a list\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list):\n        print(\"Warning: Invalid input grid format. Expecting List[List[int]].\")\n        # Return an empty structure that matches the expected output format (2 rows)\n        return [[], []] \n        \n    # Attempt to convert the first row to a NumPy array for easier processing\n    try:\n        # Assume relevant objects are only in the first row/list element\n        input_row_data = np.array(input_grid[0], dtype=int)\n    except (ValueError, TypeError):\n         print(\"Warning: Could not convert first input row to numpy array.\")\n         return [[], []] \n\n    input_width = len(input_row_data)\n    # Handle case where the first row is empty\n    if input_width == 0:\n         print(\"Warning: Input row is empty.\")\n         return [[], []] # Return empty 2-row grid\n\n    # --- Define Output Structure ---\n    # Define expected output dimensions based on consistent example pattern\n    output_height = 2 \n    output_width = input_width\n    # Define the assumed output row index for both anchor & payload based on examples\n    r_output = 1 \n\n    # --- Find Input Objects ---\n    # Find the column index ('c_anchor') of the anchor pixel in the input row\n    c_anchor = find_anchor_in_row(input_row_data, anchor_color=9)\n    \n    # Find payload details ('payload_color', 'c_payload_start_in', 'l_payload') in the input row\n    payload_color, c_payload_start_in, l_payload = find_payload_in_row(input_row_data)\n\n    # --- Handle Missing Objects ---\n    # Check if either the anchor or the payload was not found\n    if c_anchor is None or payload_color is None:\n        # If essential components are missing, create a default output grid.\n        print(f\"Warning: Anchor {'found' if c_anchor is not None else 'NOT FOUND'}, Payload {'found' if payload_color is not None else 'NOT FOUND'}. Returning default grid.\")\n        # Create a 2xWidth grid filled with the background color (0).\n        output_grid = np.zeros((output_height, output_width), dtype=int)\n        # If the anchor *was* found, place it in its assumed output position.\n        if c_anchor is not None:\n            # Check bounds before placing anchor (should be safe given width calculation)\n            if 0 <= r_output < output_height and 0 <= c_anchor < output_width:\n                 output_grid[r_output, c_anchor] = 9 \n        # Return the default grid (empty or with only anchor)\n        return output_grid.tolist()\n\n    # --- Transformation Calculation ---\n    # Calculate the column index of the last pixel of the payload line in the input row\n    c_payload_end_in = c_payload_start_in + l_payload - 1\n\n    # Calculate the key horizontal distance: from anchor column to payload end column\n    dist = c_anchor - c_payload_end_in\n    \n    # Calculate the starting column for the payload line in the output grid\n    # The rule is: output_start_column = anchor_column + distance\n    c_payload_start_out = c_anchor + dist\n    \n    # --- Populate Output Grid ---\n    # Initialize the final output grid with the background color (0)\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # Place the anchor pixel in its assumed output position (row 'r_output', same column 'c_anchor')\n    # Include basic bounds check for robustness, although should be valid by construction\n    if 0 <= r_output < output_height and 0 <= c_anchor < output_width:\n        output_grid[r_output, c_anchor] = 9\n    \n    # Draw the payload line at its new position in the output grid\n    # The row is 'r_output', starting column is 'c_payload_start_out'\n    for i in range(l_payload):\n        current_col = c_payload_start_out + i\n        # Check if the current column index is within the grid's width bounds\n        if 0 <= current_col < output_width:\n            # Place the payload pixel in the calculated position (row 'r_output')\n            # This will overwrite the background '0'\n            output_grid[r_output, current_col] = payload_color\n            \n    # Convert the final NumPy array grid back to a list of lists for the return value\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12540,
    "candidates_token_count": 1943,
    "total_token_count": 14483,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 60.928394,
  "retries": 1
}