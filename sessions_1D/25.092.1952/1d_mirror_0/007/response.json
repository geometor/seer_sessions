{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1D grid (represented as a list containing one list) by rearranging\ntwo key elements: a contiguous block of a single color (not white 0, not maroon 9)\nand a single maroon pixel (9), separated by a gap of white pixels.\n\nThe transformation rule is:\n1. Identify the contiguous colored block (color C, length L, end index E_block)\n   and the single maroon pixel (index M) in the input row.\n2. Calculate the gap size (G) between them in the input: G = M - E_block - 1.\n3. Create an output row of the same size, initialized to white (0).\n4. Place the maroon pixel (9) in the output row at its original index (M).\n5. Calculate the starting index for the colored block in the output:\n   Output_S_block = M + G + 1.\n6. Place the colored block (color C, length L) into the output row, starting at\n   index Output_S_block and ending at Output_S_block + L - 1.\n7. Return the output row enclosed in a list.\n\"\"\"\n\ndef find_colored_block(row):\n    \"\"\"\n    Finds the first contiguous block of non-white (0), non-maroon (9) color\n    in a single row.\n\n    Args:\n        row: A numpy array representing the row.\n\n    Returns:\n        A dictionary containing 'color', 'start', 'end', and 'length' of the block,\n        or None if no such block is found.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_end = -1\n    in_block = False\n    row_len = len(row)\n\n    for i, pixel in enumerate(row):\n        # Check for non-background, non-marker color\n        if pixel != 0 and pixel != 9:\n            if not in_block:\n                # Start of a new potential block\n                block_start = i\n                block_color = pixel\n                in_block = True\n            # Check if the block continues or ends\n            # Block ends if we reach the end of the row or the next pixel is different\n            if i + 1 == row_len or row[i+1] != block_color:\n                block_end = i\n                break # Found the end of the block\n        elif in_block:\n            # If we were in a block and encounter 0 or 9, the block just ended at the previous index\n            block_end = i - 1\n            break\n\n    if block_start != -1 and block_end != -1:\n        block_length = block_end - block_start + 1\n        # Ensure length is positive\n        if block_length > 0:\n            return {'color': block_color, 'start': block_start, 'end': block_end, 'length': block_length}\n        else:\n             # This might happen if block starts and immediately ends due to 0 or 9\n             print(f\"Warning: Detected block with non-positive length at start {block_start}, end {block_end}. Investigate.\")\n             return None\n    else:\n        # This case should not happen based on the task's example structure\n        return None\n\ndef find_marker_pixel(row, marker_color=9):\n    \"\"\"\n    Finds the index of the first pixel with the marker_color in a single row.\n\n    Args:\n        row: A numpy array representing the row.\n        marker_color: The color value to search for (default is 9).\n\n    Returns:\n        The index of the marker pixel, or -1 if not found.\n    \"\"\"\n    indices = np.where(row == marker_color)[0]\n    if len(indices) > 0:\n        return indices[0] # Return the first occurrence\n    # This case should not happen based on the task's example structure\n    return -1\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the rearrangement transformation to the input grid.\n\n    Args:\n        input_grid: A list containing a single list of integers\n                    representing the 1D input grid.\n\n    Returns:\n        A list containing a single list of integers\n        representing the transformed 1D output grid.\n    \"\"\"\n    # --- Input Validation and Preparation ---\n    # Expecting input like [[...row data...]]\n    if not isinstance(input_grid, list) or len(input_grid) == 0 or not isinstance(input_grid[0], list):\n        print(\"Warning: Unexpected input grid format. Returning input.\")\n        return input_grid # Return input as is if format is wrong\n\n    input_row = np.array(input_grid[0])\n    grid_length = len(input_row)\n\n    # --- Initialize Output Grid ---\n    # Create a new output grid of the same size, filled with background color 0\n    output_row = np.zeros_like(input_row)\n\n    # --- Identify Elements ---\n    # Find the contiguous block of non-white, non-maroon pixels\n    block_info = find_colored_block(input_row)\n    if not block_info:\n        print(\"Error: Colored block not found.\")\n        # Return an empty grid in the expected list-of-lists format\n        return [output_row.tolist()]\n\n    # Find the single maroon marker pixel\n    marker_index = find_marker_pixel(input_row)\n    if marker_index == -1:\n        print(\"Error: Marker pixel not found.\")\n        return [output_row.tolist()]\n\n    # --- Calculate Geometry ---\n    # Calculate the size of the gap (number of 0s) between block end and marker start\n    # G = M - E_block - 1\n    gap_size = marker_index - block_info['end'] - 1\n    if gap_size < 0:\n        # This implies overlap or adjacency, which contradicts example patterns\n        print(\"Warning: Gap size is negative or zero, input structure might be unexpected.\")\n        # Proceed assuming minimum possible gap if needed, or adjust based on task rules\n        gap_size = max(0, gap_size) # Treat unexpected overlap as zero gap for calculation\n\n    # --- Construct Output Grid ---\n    # 1. Place the marker pixel (color 9) at its original index M\n    # Bounds check (should be intrinsically ok as M comes from input)\n    if 0 <= marker_index < grid_length:\n        output_row[marker_index] = 9\n    else:\n        # This case should be logically impossible if marker_index was found correctly\n        print(f\"Error: Marker index {marker_index} out of bounds.\")\n        return [np.zeros_like(input_row).tolist()] # Return empty grid\n\n    # 2. Calculate the starting index for the colored block in the output grid\n    # Output_S_block = M + G + 1\n    block_output_start = marker_index + gap_size + 1\n\n    # 3. Calculate the ending index (exclusive) for the colored block\n    block_output_end_exclusive = block_output_start + block_info['length']\n\n    # 4. Place the colored block (color C, length L) into the output grid\n    # Perform bounds check to prevent errors if rearranged block exceeds grid limits\n    if block_output_start >= grid_length:\n        # Block starts outside the grid, nothing to place\n         print(f\"Warning: Calculated block start {block_output_start} is outside grid bounds {grid_length}.\")\n    elif block_output_end_exclusive > grid_length:\n        # Block partially fits, place the part that does\n        print(f\"Warning: Calculated block end {block_output_end_exclusive} exceeds grid bounds {grid_length}. Truncating.\")\n        output_row[block_output_start : grid_length] = block_info['color']\n    else:\n        # Block fits entirely\n        output_row[block_output_start : block_output_end_exclusive] = block_info['color']\n\n\n    # --- Format and Return Output ---\n    # Return the transformed row in the expected list-of-lists format\n    return [output_row.tolist()]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12133,
    "candidates_token_count": 1892,
    "total_token_count": 14025,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.807155,
  "retries": 1
}