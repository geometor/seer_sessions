{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 2D grid by repositioning a contiguous colored block relative to a\nfixed pivot pixel (maroon, 9) based on a flattened 1D representation.\n\nThe transformation involves these steps:\n1. Flatten the input 2D grid into a 1D sequence.\n2. Identify the index of the single pivot pixel (maroon, 9) in the 1D sequence.\n3. Identify the contiguous block of pixels that are neither white (0) nor maroon (9). Record its color, start/end indices, and length in the 1D sequence.\n4. Determine if the block is before or after the pivot in the 1D sequence.\n5. Calculate the gap size (number of white pixels) strictly between the block and the pivot in the 1D sequence.\n6. Create a new 1D sequence of the same size, filled with the background color (white, 0).\n7. Place the pivot pixel at its original index in the new sequence.\n8. Calculate the new starting index for the block in the new sequence by placing it on the opposite side of the pivot, separated by the same gap size.\n9. Place the colored block into the new sequence at its calculated position.\n10. Reshape the resulting 1D sequence back into the original 2D grid dimensions.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n# Define constants for colors\nBACKGROUND_COLOR = 0\nPIVOT_COLOR = 9\n\ndef find_pivot(grid_list: List[int], pivot_color: int) -> Optional[int]:\n    \"\"\"Finds the index of the first occurrence of the pivot color in a 1D list.\"\"\"\n    for i, pixel in enumerate(grid_list):\n        if pixel == pivot_color:\n            return i\n    return None # Pivot not found\n\ndef find_colored_block(grid_list: List[int], background_color: int, pivot_color: int) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the first contiguous block of non-background, non-pivot color in a 1D list.\n    Returns (start_index, end_index, color) or None if not found.\n    Ignores the pivot's position during search, focusing only on the block itself.\n    \"\"\"\n    block_start = -1\n    block_color = -1\n    n = len(grid_list)\n    for i, pixel in enumerate(grid_list):\n        # Check if the current pixel is background or pivot\n        is_bg_or_pivot = (pixel == background_color or pixel == pivot_color)\n\n        if block_start == -1: # We are looking for the start of a block\n            if not is_bg_or_pivot:\n                block_start = i\n                block_color = pixel\n        else: # We are inside a potential block, looking for its end\n            # Block ends if pixel is background, pivot, or a different color\n            is_different_color = (pixel != block_color)\n            if is_bg_or_pivot or is_different_color:\n                # The block ended at the previous index\n                return block_start, i - 1, block_color\n\n    # If the loop finished and we were tracking a block, it means the block goes to the end\n    if block_start != -1:\n        return block_start, n - 1, block_color\n\n    return None # Block not found\n\ndef calculate_gap(grid_list: List[int], block_start: int, block_end: int, pivot_index: int, background_color: int) -> int:\n    \"\"\"Calculates the number of background pixels strictly between the block and the pivot in a 1D list.\"\"\"\n    gap = 0\n    if block_end < pivot_index: # Block is before pivot\n        # Count background pixels from block_end + 1 up to pivot_index\n        start = block_end + 1\n        end = pivot_index\n        for i in range(start, end):\n             # Ensure index is valid before accessing grid_list[i]\n             if 0 <= i < len(grid_list) and grid_list[i] == background_color:\n                 gap += 1\n    elif block_start > pivot_index: # Block is after pivot\n        # Count background pixels from pivot_index + 1 up to block_start\n        start = pivot_index + 1\n        end = block_start\n        for i in range(start, end):\n             # Ensure index is valid before accessing grid_list[i]\n             if 0 <= i < len(grid_list) and grid_list[i] == background_color:\n                 gap += 1\n    # If block is adjacent, start >= end, range is empty, gap remains 0.\n    return gap\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Store original shape for final reshaping\n    original_shape = input_grid.shape\n    rows, cols = original_shape\n\n    # 1. Flatten the input 2D grid into a 1D list\n    input_list = input_grid.flatten().tolist()\n    grid_size = len(input_list)\n\n    # 2. Find the pivot pixel index\n    pivot_index = find_pivot(input_list, PIVOT_COLOR)\n    if pivot_index is None:\n        print(\"Error: Pivot pixel (9) not found.\")\n        # Return original grid or raise error based on expected behavior\n        return input_grid\n\n    # 3. Find the colored block\n    block_info = find_colored_block(input_list, BACKGROUND_COLOR, PIVOT_COLOR)\n    if block_info is None:\n        print(\"Error: Colored block (non-0, non-9) not found.\")\n        # Return original grid or raise error\n        return input_grid\n    block_start, block_end, block_color = block_info\n    block_length = block_end - block_start + 1\n\n    # 4. Determine block position relative to pivot\n    block_was_before_pivot = block_end < pivot_index\n\n    # 5. Calculate the gap size between block and pivot\n    gap_size = calculate_gap(input_list, block_start, block_end, pivot_index, BACKGROUND_COLOR)\n\n    # 6. Create the output list, initialized with background color\n    output_list = [BACKGROUND_COLOR] * grid_size\n\n    # 7. Place the pivot pixel in the output list\n    output_list[pivot_index] = PIVOT_COLOR\n\n    # 8. Calculate the new starting position for the block\n    if block_was_before_pivot:\n        # Block was before, move it after the pivot\n        new_block_start = pivot_index + 1 + gap_size\n    else:\n        # Block was after, move it before the pivot\n        new_block_start = pivot_index - gap_size - block_length\n\n    # Calculate the new end position\n    new_block_end = new_block_start + block_length - 1\n\n    # 9. Place the block in the output list, checking bounds\n    # Ensure indices are within the list bounds before writing\n    actual_start = max(0, new_block_start)\n    actual_end = min(grid_size - 1, new_block_end)\n    \n    # Determine which part of the block (if any) fits\n    block_offset_start = max(0, -new_block_start) # How many pixels from block start are cut off from the left\n    length_to_write = (actual_end - actual_start + 1) \n    \n    if length_to_write > 0:\n         for i in range(length_to_write):\n            # Check if the target index is within bounds (redundant due to actual_start/end, but safe)\n            if 0 <= actual_start + i < grid_size:\n                output_list[actual_start + i] = block_color\n    elif new_block_start >= 0 and new_block_start < grid_size: # Handle 0-length fitting blocks? Usually means issue.\n        pass # block doesn't fit\n    \n    if new_block_start < 0 or new_block_end >= grid_size:\n        print(f\"Warning: Calculated block position [{new_block_start}-{new_block_end}] was out of bounds for grid size {grid_size}. Block placement truncated.\")\n\n\n    # 10. Reshape the output list back into the original 2D grid dimensions\n    output_grid = np.array(output_list).reshape(original_shape)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9697,
    "candidates_token_count": 2016,
    "total_token_count": 11713,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.780067,
  "retries": 1
}