{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nMoves a contiguous colored block within a 1D array across a separator pixel \n(maroon, 9), maintaining the relative distance (number of background pixels) \nbetween the block and the separator.\n\nThe transformation operates on a single 1D array (list of integers).\nThe block moves from its original side of the separator to the opposite side.\nThe separator's position remains unchanged.\nThe block's color and length remain unchanged.\nThe block's original position in the array is effectively replaced by the \nbackground color (white, 0) when the output array is initialized.\nThe relative distance (number of background pixels between block and separator) \nis preserved in the new position on the opposite side.\nThe block overwrites background pixels at its destination in the output array.\n\"\"\"\n\ndef find_separator_index(row: np.ndarray) -> int:\n    \"\"\"Finds the index of the separator pixel (9) in a 1D row.\"\"\"\n    # Find indices where the value is 9\n    separator_indices = np.where(row == 9)[0]\n    # Validate that exactly one separator exists\n    if len(separator_indices) != 1:\n        raise ValueError(f\"Expected exactly one separator pixel (9), found {len(separator_indices)}.\")\n    # Return the index of the single separator\n    return separator_indices[0]\n\ndef find_colored_block(row: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Finds the contiguous colored block (not 0 or 9) in a 1D row.\n\n    Returns:\n        A tuple containing (start_index, end_index, color).\n    Raises:\n        ValueError: If no block, multiple blocks, or inconsistent block found.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_end = -1\n    in_block = False\n    found_block = False\n\n    # Iterate through the row with index\n    for i, pixel in enumerate(row):\n        # Skip separator and background pixels\n        if pixel == 9 or pixel == 0:\n            if in_block:  # Just exited a block\n                block_end = i - 1\n                in_block = False\n                # Since we expect only one block, we can stop searching\n                break\n            continue # Continue if not in a block and pixel is 0 or 9\n\n        # Found a non-background, non-separator pixel\n        current_pixel_color = pixel\n        if not in_block:\n            # Start of a new block\n            if found_block:\n                 raise ValueError(\"Found more than one colored block.\") # Error if block already found previously\n            block_color = current_pixel_color\n            block_start = i\n            in_block = True\n            found_block = True\n        elif current_pixel_color != block_color:\n             # Error if inside a block but color changes\n             raise ValueError(f\"Found inconsistent color within a block. Expected {block_color}, got {current_pixel_color}.\")\n\n    # Handle case where block is at the very end of the row\n    if in_block:\n        block_end = len(row) - 1\n\n    # Validate that a complete block was found\n    if not found_block or block_start == -1 or block_end == -1:\n        raise ValueError(\"Could not find a valid colored block.\")\n\n    return block_start, block_end, block_color\n\n\ndef transform(input_grid: List[int]) -> List[int]:\n    \"\"\"\n    Applies the block-moving transformation to the input 1D grid.\n\n    Args:\n        input_grid: A list representing the 1D input grid.\n\n    Returns:\n        A list representing the 1D transformed grid.\n    \"\"\"\n    # Convert input list to numpy array for efficient operations\n    input_row = np.array(input_grid)\n    grid_size = len(input_row)\n\n    # Initialize output_row with background color (0)\n    # This effectively handles clearing the original block's position\n    output_row = np.zeros_like(input_row)\n\n    # --- Transformation Steps ---\n\n    # 1. Find the index of the separator (9)\n    separator_index = find_separator_index(input_row)\n\n    # 2. Place the separator in the output row at the same index\n    output_row[separator_index] = 9\n\n    # 3. Find the colored block (color C, start, end indices)\n    block_start, block_end, block_color = find_colored_block(input_row)\n    block_length = block_end - block_start + 1\n\n    # 4. Determine if the block is to the left or right of the separator\n    #    and calculate the distance (number of background cells between them)\n    distance = 0\n    is_left = block_end < separator_index\n    if is_left:\n        # Block is to the left. Distance = space between block_end and separator_index\n        distance = separator_index - 1 - block_end\n    else:\n        # Block is to the right. Distance = space between separator_index and block_start\n        distance = block_start - (separator_index + 1)\n\n    # Ensure distance is non-negative (it should be based on logic)\n    distance = max(0, distance)\n\n    # 5. Calculate the new start and end indices for the block on the opposite side\n    new_block_start = -1\n    new_block_end = -1\n\n    if is_left:\n        # Block was left, move to right, maintaining distance\n        new_block_start = separator_index + 1 + distance\n        new_block_end = new_block_start + block_length - 1\n    else:\n        # Block was right, move to left, maintaining distance\n        new_block_end = separator_index - 1 - distance\n        new_block_start = new_block_end - block_length + 1\n\n    # 6. Validate the calculated new position is within the grid bounds\n    if new_block_start < 0 or new_block_end >= grid_size:\n        raise ValueError(f\"Calculated new block position [{new_block_start}, {new_block_end}] is out of bounds for grid size {grid_size}.\")\n    if new_block_start > new_block_end:\n         raise ValueError(f\"Calculated invalid block range: start {new_block_start} > end {new_block_end}\")\n\n    # 7. Place the block (using its color) into the calculated new position in the output row\n    output_row[new_block_start : new_block_end + 1] = block_color\n\n    # Convert the resulting numpy array back to a list for the return value\n    output_grid = output_row.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10680,
    "candidates_token_count": 1596,
    "total_token_count": 12276,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.644041,
  "retries": 1
}