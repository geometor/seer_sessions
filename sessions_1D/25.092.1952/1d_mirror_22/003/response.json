{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nMoves a contiguous colored block within a single-row grid across a separator \npixel (maroon, 9), maintaining the relative distance (number of background \npixels) between the block and the separator.\n\nThe transformation operates solely on the first (and only) row of the grid.\nThe block moves from its original side of the separator to the opposite side.\nThe separator's position remains unchanged.\nThe block's color and length remain unchanged.\nThe block's original position in the row is filled with the background color (white, 0).\nThe relative distance is preserved in the new position on the opposite side.\nThe block overwrites background pixels at its destination.\n\"\"\"\n\ndef find_separator_index(row: np.ndarray) -> int:\n    \"\"\"Finds the index of the separator pixel (9) in a 1D row.\"\"\"\n    separator_indices = np.where(row == 9)[0]\n    if len(separator_indices) != 1:\n        raise ValueError(f\"Expected exactly one separator pixel (9), found {len(separator_indices)}.\")\n    return separator_indices[0]\n\ndef find_colored_block(row: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Finds the contiguous colored block (not 0 or 9) in a 1D row.\n\n    Returns:\n        A tuple containing (start_index, end_index, color).\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_end = -1\n    in_block = False\n\n    for i, pixel in enumerate(row):\n        # Skip separator and background\n        if pixel == 9 or pixel == 0:\n            if in_block: # End of a block\n                block_end = i - 1\n                in_block = False\n                # Since we expect only one block, we can return here\n                return block_start, block_end, block_color\n            continue\n\n        # Found a non-background, non-separator pixel\n        if not in_block:\n            # Start of a new block\n            if block_color != -1:\n                 raise ValueError(\"Found more than one colored block.\")\n            block_color = pixel\n            block_start = i\n            in_block = True\n        elif pixel != block_color:\n             raise ValueError(f\"Found inconsistent color within a block. Expected {block_color}, got {pixel}.\")\n\n    # Handle case where block is at the very end of the row\n    if in_block:\n        block_end = len(row) - 1\n        return block_start, block_end, block_color\n    \n    # If we reach here, no block was found or completed properly\n    if block_start != -1 and block_end == -1 and in_block: #Handles block at end\n         block_end = len(row) -1\n         return block_start, block_end, block_color\n\n\n    raise ValueError(\"Could not find a valid colored block.\")\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the block-moving transformation to the input grid.\n\n    Args:\n        input_grid: A 2D list representing the input grid (expected to have 1 row).\n\n    Returns:\n        A 2D list representing the transformed grid.\n    \"\"\"\n    # Ensure input is a list of lists and has at least one row\n    if not isinstance(input_grid, list) or not input_grid or not isinstance(input_grid[0], list):\n         raise ValueError(\"Input grid must be a non-empty list of lists.\")\n    if len(input_grid) > 1:\n        # This implementation currently assumes a single row based on examples.\n        # Adapt if multi-row inputs become relevant for this specific rule.\n        print(\"Warning: Input grid has more than one row. Processing only the first row.\")\n        # raise ValueError(\"This transformation currently only supports single-row grids.\")\n\n\n    # Extract the first row and convert to numpy array for easier manipulation\n    input_row_list = input_grid[0]\n    input_row = np.array(input_row_list)\n    grid_size = len(input_row)\n\n    # Initialize output_row with background color (0)\n    output_row = np.zeros_like(input_row)\n\n    # --- Transformation Steps ---\n\n    # 1. Find the separator index in the input row\n    separator_index = find_separator_index(input_row)\n\n    # 2. Place the separator in the output row\n    output_row[separator_index] = 9\n\n    # 3. Find the colored block in the input row\n    block_start, block_end, block_color = find_colored_block(input_row)\n    block_length = block_end - block_start + 1\n\n    # 4. Determine if the block is left/right and calculate distance to separator\n    distance = 0\n    is_left = block_end < separator_index\n    if is_left:\n        # Block is to the left of the separator\n        # Distance is number of cells between block_end and separator_index\n        distance = separator_index - 1 - block_end\n    else:\n        # Block is to the right of the separator\n        # Distance is number of cells between separator_index and block_start\n        distance = block_start - (separator_index + 1)\n\n    # Ensure distance calculation didn't result in negative (e.g., adjacent)\n    distance = max(0, distance) # Should always be >= 0 based on definition\n\n    # 5. Calculate the new position for the block on the opposite side\n    new_block_start = -1\n    new_block_end = -1\n\n    if is_left:\n        # Block was left, move to right, maintaining distance\n        new_block_start = separator_index + 1 + distance\n        new_block_end = new_block_start + block_length - 1\n    else:\n        # Block was right, move to left, maintaining distance\n        new_block_end = separator_index - 1 - distance\n        new_block_start = new_block_end - block_length + 1\n\n    # 6. Check if the calculated new position is valid within the grid bounds\n    if new_block_start < 0 or new_block_end >= grid_size:\n        raise ValueError(f\"Calculated new block position [{new_block_start}, {new_block_end}] is out of bounds for grid size {grid_size}.\")\n    if new_block_start > new_block_end:\n         raise ValueError(f\"Calculated invalid block range: start {new_block_start} > end {new_block_end}\")\n\n\n    # 7. Place the block with its color into the calculated position in the output row\n    output_row[new_block_start : new_block_end + 1] = block_color\n\n    # --- Final Output Formatting ---\n\n    # Convert the numpy output row back to a list\n    output_row_list = output_row.tolist()\n\n    # Wrap the output row in a list to match the 2D output format\n    output_grid = [output_row_list]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7726,
    "candidates_token_count": 1681,
    "total_token_count": 9407,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.673651,
  "retries": 1
}