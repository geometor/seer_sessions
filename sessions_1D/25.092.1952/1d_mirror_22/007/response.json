{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nMoves a contiguous colored block within a single-row grid across a separator pixel \n(maroon, 9), maintaining the relative distance (number of background pixels) \nbetween the block and the separator.\n\nThe transformation operates on a 2D grid assumed to have exactly one row (1xN shape).\nThe block moves from its original side of the separator to the opposite side within that row.\nThe separator's position remains unchanged.\nThe block's color and length remain unchanged.\nThe block's original position in the row is effectively replaced by the background \ncolor (white, 0) when the output row is initialized.\nThe relative distance (number of background pixels between the block's nearest edge \nand the separator) is preserved in the new position on the opposite side.\nThe block overwrites background pixels at its destination in the output row.\n\"\"\"\n\ndef find_separator_index(row: np.ndarray) -> int:\n    \"\"\"\n    Finds the index of the separator pixel (9) in a 1D numpy array representing a row.\n\n    Args:\n        row: The 1D numpy array representing the grid row.\n\n    Returns:\n        The index of the separator pixel (9).\n\n    Raises:\n        ValueError: If exactly one separator pixel is not found.\n    \"\"\"\n    separator_indices = np.where(row == 9)[0]\n    if len(separator_indices) != 1:\n        raise ValueError(f\"Expected exactly one separator pixel (9), found {len(separator_indices)}.\")\n    return separator_indices[0]\n\ndef find_colored_block(row: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Finds the single contiguous colored block (not 0 or 9) in a 1D numpy array row.\n\n    Args:\n        row: The 1D numpy array representing the grid row.\n\n    Returns:\n        A tuple containing (start_index, end_index, color).\n\n    Raises:\n        ValueError: If no block, multiple blocks, or an inconsistent block is found.\n    \"\"\"\n    block_color = -1\n    block_start = -1\n    block_end = -1\n    in_block = False\n    found_block = False\n\n    for i, pixel in enumerate(row):\n        # Skip separator (9) and background (0) pixels\n        if pixel == 9 or pixel == 0:\n            if in_block:  # Just finished scanning a block\n                block_end = i - 1\n                in_block = False\n                # Found the single expected block, stop searching\n                break \n            continue # Continue searching if not currently in a block\n\n        # Found a non-background, non-separator pixel\n        current_pixel_color = pixel\n        if not in_block:\n            # Start of a new block\n            if found_block:\n                 # Error: Found a second block when only one is expected\n                 raise ValueError(\"Found more than one colored block.\")\n            block_color = current_pixel_color\n            block_start = i\n            in_block = True\n            found_block = True\n        elif current_pixel_color != block_color:\n             # Error: Pixel color within the block changed unexpectedly\n             raise ValueError(f\"Found inconsistent color within a block. Expected {block_color}, got {current_pixel_color}.\")\n\n    # Handle case where the block extends to the very end of the row\n    if in_block:\n        block_end = len(row) - 1\n\n    # Final validation: Ensure a complete block was successfully identified\n    if not found_block or block_start == -1 or block_end == -1:\n        raise ValueError(\"Could not find a valid colored block.\")\n\n    return block_start, block_end, block_color\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the block-moving transformation to the input grid.\n\n    Args:\n        input_grid: A 2D list representing the input grid (expected to have 1 row).\n\n    Returns:\n        A 2D list representing the transformed grid (also 1 row).\n    \"\"\"\n    # Validate input grid structure\n    if not isinstance(input_grid, list) or len(input_grid) != 1 or not isinstance(input_grid[0], list):\n         raise ValueError(\"Input grid must be a list containing exactly one list (row).\")\n\n    # Extract the single row and convert to numpy array\n    input_row_list = input_grid[0]\n    input_row = np.array(input_row_list)\n    grid_size = len(input_row)\n\n    # Initialize output_row with background color (0)\n    output_row = np.zeros_like(input_row)\n\n    # --- Transformation Workflow ---\n\n    # 1. Find the index of the separator pixel (9)\n    separator_index = find_separator_index(input_row)\n\n    # 2. Place the separator in the output row at the same index\n    output_row[separator_index] = 9\n\n    # 3. Find the colored block (details: color, start, end indices)\n    block_start, block_end, block_color = find_colored_block(input_row)\n    block_length = block_end - block_start + 1\n\n    # 4. Determine if the block is left/right of the separator and calculate the distance\n    distance = 0\n    is_left = block_end < separator_index\n    if is_left:\n        # Block is to the left. Distance = number of cells between block_end and separator_index\n        distance = separator_index - 1 - block_end\n    else:\n        # Block is to the right. Distance = number of cells between separator_index and block_start\n        distance = block_start - (separator_index + 1)\n\n    # Ensure distance is non-negative (it should be, but safety check)\n    distance = max(0, distance)\n\n    # 5. Calculate the new start and end indices for the block on the opposite side\n    new_block_start = -1\n    new_block_end = -1\n\n    if is_left:\n        # Block was left, moving to the right side\n        new_block_start = separator_index + 1 + distance\n        new_block_end = new_block_start + block_length - 1\n    else:\n        # Block was right, moving to the left side\n        # Calculate new end first, then derive start\n        new_block_end = separator_index - 1 - distance\n        new_block_start = new_block_end - block_length + 1\n\n    # 6. Validate the calculated new position is within the grid bounds\n    if new_block_start < 0 or new_block_end >= grid_size:\n        raise ValueError(f\"Calculated new block position [{new_block_start}, {new_block_end}] is out of bounds for grid size {grid_size}.\")\n    if new_block_start > new_block_end: # Should not happen if logic is correct\n         raise ValueError(f\"Calculated invalid block range: start {new_block_start} > end {new_block_end}\")\n\n    # 7. Place the block (using its color) into the calculated new position in the output row\n    # Numpy slicing handles assigning the color to the correct range\n    output_row[new_block_start : new_block_end + 1] = block_color\n\n    # --- Final Output Formatting ---\n\n    # Convert the resulting numpy array back to a list\n    output_row_list = output_row.tolist()\n\n    # Wrap the output row in a list to match the required 2D List[List[int]] format\n    output_grid = [output_row_list]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10865,
    "candidates_token_count": 1809,
    "total_token_count": 12674,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.640054,
  "retries": 1
}