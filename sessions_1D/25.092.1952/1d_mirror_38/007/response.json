{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 1xN input grid by relocating a contiguous colored block.\nThe transformation identifies a single pivot pixel (maroon 9) and a single\ncontiguous block of another color (not white 0 or maroon 9) that precedes the pivot.\nThe block is effectively 'cut' from its original position (which is then filled\nwith background color 0) and 'pasted' into the grid at a new location.\nThe new starting position of the block is determined by the original position\nof the pivot and the length of the gap (sequence of pixels between the block\nand the pivot in the input). Specifically, the block starts at index:\noriginal_pivot_index + 1 + gap_length. The pivot pixel itself remains in its\noriginal position.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Dict, Any, Union\n\ndef find_pivot_index(row: List[int], pivot_color: int = 9) -> int:\n    \"\"\"Finds the index of the first occurrence of the pivot color.\"\"\"\n    for i, pixel in enumerate(row):\n        if pixel == pivot_color:\n            # Check if there's another pivot later\n            if pivot_color in row[i+1:]:\n                 raise ValueError(\"More than one pivot pixel found.\")\n            return i\n    raise ValueError(f\"Pivot color {pivot_color} not found.\")\n\ndef find_colored_block(row: List[int], background_color: int = 0, pivot_color: int = 9) -> Tuple[List[int], int, int]:\n    \"\"\"\n    Finds the first contiguous block of non-background, non-pivot color.\n\n    Returns:\n        Tuple[List[int], int, int]: (block_data, block_start_index, block_end_index)\n    Raises:\n        ValueError: If no block is found, or multiple/non-contiguous blocks are detected.\n    \"\"\"\n    block_data = []\n    block_start = -1\n    block_end = -1\n    in_block = False\n    block_color = -1\n    found_block = False # Flag to detect multiple blocks\n\n    for i, pixel in enumerate(row):\n        is_block_pixel = (pixel != background_color and pixel != pivot_color)\n\n        if is_block_pixel:\n            if not in_block: # Start of a new block\n                if found_block:\n                    # Found the start of a second block - error\n                     raise ValueError(\"Multiple distinct colored blocks found.\")\n                block_start = i\n                block_color = pixel\n                in_block = True\n                block_data.append(pixel)\n                block_end = i\n            elif in_block and pixel == block_color: # Continue the current block\n                block_data.append(pixel)\n                block_end = i\n            elif in_block and pixel != block_color: # Different color adjacent to block\n                 raise ValueError(\"Non-contiguous block or adjacent blocks of different colors found.\")\n        elif in_block: # End of the current block (hit background or pivot)\n            in_block = False\n            found_block = True # Mark that we have successfully found one block\n\n    if not found_block:\n        raise ValueError(\"Colored block not found.\")\n\n    return block_data, block_start, block_end\n\n\ndef transform(input_grid: Union[np.ndarray, List[List[int]]]) -> Union[np.ndarray, List[List[int]]]:\n    \"\"\"\n    Applies the block relocation transformation to the input grid.\n\n    Args:\n        input_grid: A 1xN grid, represented as a numpy array or list of lists.\n\n    Returns:\n        The transformed 1xN grid in the same format as the input.\n    \"\"\"\n    # --- Input Handling ---\n    is_numpy = isinstance(input_grid, np.ndarray)\n    if is_numpy:\n        if input_grid.ndim == 1:\n             input_list = [input_grid.tolist()]\n        elif input_grid.ndim == 2:\n             if input_grid.shape[0] != 1:\n                 raise ValueError(\"Input grid must have exactly one row.\")\n             input_list = input_grid.tolist()\n        else:\n            raise ValueError(\"Input grid must be 1D or 2D.\")\n    elif isinstance(input_grid, list):\n         if not input_grid or not isinstance(input_grid[0], list):\n             # Try handling flat list input\n             if all(isinstance(x, int) for x in input_grid):\n                 input_list = [input_grid]\n                 is_numpy = False # Treat as list of lists conceptually\n             else:\n                 raise TypeError(\"Input must be a list of lists or a flat list of integers.\")\n         elif len(input_grid) != 1:\n             raise ValueError(\"Input grid must contain exactly one row.\")\n         else:\n            input_list = input_grid\n    else:\n         raise TypeError(\"Input must be a numpy array or list of lists.\")\n\n    input_row = input_list[0]\n    n_cols = len(input_row)\n    if n_cols == 0: # Handle empty row\n        return np.array([[]]) if is_numpy else [[]]\n\n    background_color = 0\n    pivot_color = 9\n\n    try:\n        # 1. Find Pivot\n        pivot_index = find_pivot_index(input_row, pivot_color)\n\n        # 2. Find Colored Block\n        block_data, block_start, block_end = find_colored_block(input_row, background_color, pivot_color)\n\n        # Validate block is before pivot\n        if block_end >= pivot_index:\n            raise ValueError(\"Colored block must precede the pivot pixel.\")\n\n        # 3. Calculate Gap Length\n        gap_length = pivot_index - block_end - 1\n        if gap_length < 0:\n             # This implies block and pivot are adjacent, gap_length = -1, needs adjustment\n             # Let's re-evaluate: pivot_index - (block_end + 1) gives number of elements between\n             gap_length = max(0, pivot_index - (block_end + 1))\n\n\n        # 4. Initialize Output Row as a copy\n        output_row = list(input_row) # Use list() to ensure it's mutable\n\n        # 5. Erase original block location in output row\n        block_len = len(block_data)\n        for i in range(block_start, block_end + 1):\n            output_row[i] = background_color\n\n        # 6. Calculate Target Start Index for the block\n        target_block_start = pivot_index + 1 + gap_length\n\n        # Check if target position is valid\n        if target_block_start + block_len > n_cols:\n            raise ValueError(\"Calculated target position for block exceeds grid boundaries.\")\n\n        # 7. Place block data at the target location\n        for i in range(block_len):\n            output_row[target_block_start + i] = block_data[i]\n\n    except ValueError as e:\n        # Handle errors like missing pivot/block or invalid configuration\n        print(f\"Warning: Input configuration error: {e}. Returning original grid.\")\n        # Returning the original grid might be required by ARC evaluation\n        return input_grid\n\n\n    # --- Output Formatting ---\n    if is_numpy:\n        # Use the original dtype if possible\n        dtype = input_grid.dtype if hasattr(input_grid, 'dtype') else None\n        output_grid = np.array([output_row], dtype=dtype)\n    else:\n         # Check original input format (list of lists vs flat list)\n         if isinstance(input_grid, list) and isinstance(input_grid[0], list):\n             output_grid = [output_row]\n         else: # Assumed flat list originally\n             output_grid = output_row\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16652,
    "candidates_token_count": 1829,
    "total_token_count": 18481,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.156523,
  "retries": 1
}