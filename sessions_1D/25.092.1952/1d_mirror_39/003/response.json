{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Create the output grid with the same dimensions as the input grid, initializing all pixels to white (0).\n2. Find the coordinates (`maroon_row`, `maroon_col`) of the single maroon (9) pixel in the input grid.\n3. Place a maroon (9) pixel at the same coordinates (`maroon_row`, `maroon_col`) in the output grid.\n4. Identify the color (`shape_color`) of the contiguous shape that is not white (0) or maroon (9).\n5. Collect the set of all coordinates `(r, c)` in the input grid that have the `shape_color`. These form the \"movable shape\".\n6. If no movable shape is found, return the output grid containing only the maroon pixel.\n7. Determine the minimum row index (`shape_top_row`) among all coordinates belonging to the movable shape.\n8. For each coordinate `(r, c)` belonging to the movable shape in the input grid:\n    a. Calculate the pixel's vertical offset from the top of its shape: `relative_r = r - shape_top_row`.\n    b. Calculate the pixel's target row in the output grid: `new_r = (maroon_row + 1) + relative_r`.\n    c. Set the pixel at coordinate (`new_r`, `c`) in the output grid to the `shape_color`.\n9. Return the completed output grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set\n\ndef find_pixel(grid: np.ndarray, color: int) -> Optional[Tuple[int, int]]:\n    \"\"\"Finds the coordinates (row, col) of the first pixel with the specified color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if len(rows) > 0:\n        # ARC guarantees only one maroon pixel per grid in this task's examples\n        return int(rows[0]), int(cols[0])\n    return None\n\ndef find_colored_shape(grid: np.ndarray) -> Optional[Tuple[Set[Tuple[int, int]], int]]:\n    \"\"\"\n    Finds the set of coordinates and the color of the single \n    non-white (0), non-maroon (9) contiguous shape.\n    Returns None if no such shape exists.\n    \"\"\"\n    shape_pixels: Set[Tuple[int, int]] = set()\n    shape_color = -1 \n    height, width = grid.shape\n\n    # First pass to find the color of the shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0 and color != 9:\n                shape_color = color\n                break # Found the color, stop searching\n        if shape_color != -1:\n            break\n            \n    if shape_color == -1:\n        return None # No shape found\n\n    # Second pass to collect all pixels of that color\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == shape_color:\n                shape_pixels.add((r, c))\n\n    if not shape_pixels:\n         # This case should theoretically not happen if shape_color was found,\n         # but added for robustness.\n        return None\n\n    return shape_pixels, shape_color\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Create the output grid with the same dimensions, filled with white (0).\n    output_grid = np.zeros_like(input_np)\n\n    # 2. Find the coordinates of the single maroon (9) pixel.\n    maroon_pos = find_pixel(input_np, 9)\n    if maroon_pos is None:\n        # If no maroon pixel, the transformation is undefined by the examples.\n        # Returning the empty grid is a possible handling.\n        print(\"Warning: Maroon pixel (9) not found in input.\")\n        return output_grid.tolist() \n    maroon_row, maroon_col = maroon_pos\n\n    # 3. Place the maroon pixel in the output grid.\n    output_grid[maroon_row, maroon_col] = 9\n\n    # 4. & 5. Identify the colored shape's pixels and color.\n    shape_info = find_colored_shape(input_np)\n    \n    # 6. If no movable shape is found, return the grid with only the maroon pixel.\n    if shape_info is None:\n        return output_grid.tolist() \n        \n    shape_pixels, shape_color = shape_info\n\n    # 7. Determine the top-most row of the shape.\n    # Check if shape_pixels is empty (should be handled by shape_info check, but safe)\n    if not shape_pixels:\n         return output_grid.tolist()\n    shape_top_row = min(r for r, c in shape_pixels)\n\n    # 8. Calculate new positions and place the shape in the output grid.\n    for r, c in shape_pixels:\n        # a. Calculate relative row within the shape.\n        relative_r = r - shape_top_row\n        # b. Calculate the new row in the output grid.\n        new_r = (maroon_row + 1) + relative_r\n        \n        # c. Set the pixel in the output grid, checking bounds.\n        if 0 <= new_r < height and 0 <= c < width:\n            output_grid[new_r, c] = shape_color\n        else:\n            # Handle cases where the moved shape goes out of bounds.\n            # Based on examples, this shouldn't happen, but log if it does.\n            print(f\"Warning: Pixel ({r},{c}) maps to out-of-bounds ({new_r},{c})\")\n            pass \n\n    # 9. Return the resulting grid as a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11328,
    "candidates_token_count": 1433,
    "total_token_count": 12761,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.402032,
  "retries": 1
}