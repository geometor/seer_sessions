{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Initialize the output grid with the same dimensions as the input grid, filling it entirely with white pixels (0).\n2. Find the coordinates (`marker_row`, `marker_col`) of the single maroon pixel (9) in the input grid.\n3. Place a maroon pixel (9) at the same coordinates (`marker_row`, `marker_col`) in the output grid.\n4. Identify the unique color (`shape_color`) present in the input grid that is neither white (0) nor maroon (9).\n5. Collect the set of all coordinates `(r, c)` in the input grid where the pixel value is equal to `shape_color`. These coordinates constitute the \"movable shape\".\n6. If no movable shape pixels are found (i.e., the set of coordinates is empty), return the output grid containing only the maroon pixel.\n7. Determine the minimum row index (`shape_top_row`) among all coordinates collected in step 5.\n8. For each coordinate `(r, c)` belonging to the movable shape (from the set collected in step 5):\n    a. Calculate the pixel's vertical offset relative to the top of its shape: `relative_r = r - shape_top_row`.\n    b. Calculate the pixel's target row in the output grid: `new_r = (marker_row + 1) + relative_r`.\n    c. Set the pixel at coordinate (`new_r`, `c`) in the output grid to `shape_color`. Ensure this target coordinate is within the grid boundaries before setting the pixel.\n9. Return the completed output grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional, Set\n\ndef find_pixel(grid: np.ndarray, color: int) -> Optional[Tuple[int, int]]:\n    \"\"\"Finds the coordinates (row, col) of the first pixel with the specified color.\"\"\"\n    rows, cols = np.where(grid == color)\n    if len(rows) > 0:\n        # Assuming only one marker pixel per grid based on examples\n        return int(rows[0]), int(cols[0])\n    return None\n\ndef find_colored_shape(grid: np.ndarray) -> Optional[Tuple[Set[Tuple[int, int]], int]]:\n    \"\"\"\n    Finds the set of coordinates and the color of the single \n    non-white (0), non-maroon (9) contiguous shape.\n    Returns None if no such shape exists.\n    \"\"\"\n    shape_pixels: Set[Tuple[int, int]] = set()\n    shape_color = -1 \n    height, width = grid.shape\n\n    # Find the unique shape color first\n    possible_colors = set(np.unique(grid)) - {0, 9}\n    if not possible_colors:\n        return None # No shape color found\n    if len(possible_colors) > 1:\n        # Unexpected state based on examples, maybe handle error or pick one?\n        # For now, assume only one shape color exists.\n        print(f\"Warning: Multiple potential shape colors found: {possible_colors}. Choosing one.\")\n        # We'll just pick one, e.g., the smallest one numerically\n        shape_color = min(possible_colors)\n    else:\n        shape_color = possible_colors.pop()\n            \n    # Collect all pixels of that color\n    rows, cols = np.where(grid == shape_color)\n    for r, c in zip(rows, cols):\n         shape_pixels.add((int(r), int(c)))\n\n    if not shape_pixels:\n        return None # Should not happen if color was found, but check anyway\n\n    return shape_pixels, shape_color\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Initialize the output grid with white pixels (0).\n    output_grid = np.zeros_like(input_np)\n\n    # 2. Find the coordinates of the single maroon (9) pixel (marker).\n    marker_pos = find_pixel(input_np, 9)\n    if marker_pos is None:\n        # If no marker pixel, the transformation is undefined. Return empty grid.\n        print(\"Warning: Marker pixel (9) not found in input.\")\n        return output_grid.tolist() \n    marker_row, marker_col = marker_pos\n\n    # 3. Place the marker pixel in the output grid.\n    output_grid[marker_row, marker_col] = 9\n\n    # 4. & 5. Identify the colored shape's pixels and color.\n    shape_info = find_colored_shape(input_np)\n    \n    # 6. If no movable shape is found, return the grid with only the marker pixel.\n    if shape_info is None:\n        return output_grid.tolist() \n        \n    shape_pixels, shape_color = shape_info\n\n    # 7. Determine the top-most row of the shape.\n    if not shape_pixels: # Defensive check\n         return output_grid.tolist()\n    shape_top_row = min(r for r, c in shape_pixels)\n\n    # 8. Calculate new positions and place the shape in the output grid.\n    for r, c in shape_pixels:\n        # a. Calculate relative row within the shape.\n        relative_r = r - shape_top_row\n        # b. Calculate the new row in the output grid.\n        new_r = (marker_row + 1) + relative_r\n        \n        # c. Set the pixel in the output grid, checking bounds.\n        if 0 <= new_r < height and 0 <= c < width:\n            output_grid[new_r, c] = shape_color\n        else:\n            # Handle cases where the moved shape goes out of bounds.\n            # Based on examples, this shouldn't happen, so we can just ignore or log.\n            # print(f\"Debug: Pixel ({r},{c}) maps to out-of-bounds ({new_r},{c})\")\n            pass \n\n    # 9. Return the resulting grid as a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9533,
    "candidates_token_count": 1481,
    "total_token_count": 11014,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.548575,
  "retries": 1
}