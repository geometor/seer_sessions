{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nIdentifies three key components in a 1D input array: a single pivot pixel (maroon, 9), a contiguous block of a single color other than white (0) or maroon (9) (the 'colored object'), and a contiguous block of white (0) pixels separating the pivot and the colored object (the 'separator'). The transformation rearranges these components while preserving the original position of the pivot pixel. In the output array, the pivot pixel retains its original index. The separator block is placed immediately to the right of the pivot pixel, and the colored object block is placed immediately to the right of the separator block. All other positions in the output array are filled with white (0) pixels, maintaining the original total length of the array.\n\"\"\"\n\ndef find_pivot(grid: np.ndarray) -> int:\n    \"\"\"Finds the index of the pivot pixel (9).\"\"\"\n    pivot_indices = np.where(grid == 9)[0]\n    if len(pivot_indices) == 1:\n        return pivot_indices[0]\n    else:\n        raise ValueError(\"Input grid must contain exactly one pivot pixel (9).\")\n\ndef find_colored_object(grid: np.ndarray) -> Tuple[List[int], int, int]:\n    \"\"\"Finds the contiguous block of non-0, non-9 color.\"\"\"\n    obj_indices = np.where((grid != 0) & (grid != 9))[0]\n    if len(obj_indices) == 0:\n        raise ValueError(\"Input grid must contain a colored object (non-0, non-9).\")\n\n    start_index = obj_indices[0]\n    end_index = obj_indices[-1] # Inclusive end index for the object block\n\n    # Verify contiguity\n    if not np.all(np.diff(obj_indices) == 1):\n         raise ValueError(\"Colored object is not contiguous.\")\n         \n    # Verify single color\n    obj_color = grid[start_index]\n    if not np.all(grid[start_index:end_index+1] == obj_color):\n        raise ValueError(\"Colored object block contains multiple colors.\")\n\n    colored_object = grid[start_index : end_index + 1].tolist()\n    return colored_object, start_index, end_index\n\ndef find_separator(grid: np.ndarray, pivot_idx: int, obj_start_idx: int, obj_end_idx: int) -> List[int]:\n    \"\"\"Finds the separator block (0s) between the pivot and the object.\"\"\"\n    if pivot_idx < obj_start_idx:\n        # Pivot is to the left of the object\n        separator_slice = grid[pivot_idx + 1 : obj_start_idx]\n        separator_start = pivot_idx + 1\n        separator_end = obj_start_idx -1 # inclusive\n    elif pivot_idx > obj_end_idx:\n        # Pivot is to the right of the object\n        separator_slice = grid[obj_end_idx + 1 : pivot_idx]\n        separator_start = obj_end_idx + 1\n        separator_end = pivot_idx -1 # inclusive\n    else:\n        raise ValueError(\"Pivot index is within the object bounds.\")\n\n    # Verify separator contains only zeros\n    if not np.all(separator_slice == 0):\n        raise ValueError(f\"Separator between pivot ({pivot_idx}) and object ({obj_start_idx}-{obj_end_idx}) contains non-zero values.\")\n\n    return separator_slice.tolist()\n\n\ndef transform(input_grid: List[int]) -> List[int]:\n    \"\"\"\n    Rearranges elements in a 1D array based on a pivot color (9).\n    The pivot retains its original position, followed by the separator, \n    then the colored object. Remaining positions are filled with 0s.\n    \"\"\"\n    # Convert input list to numpy array for easier manipulation\n    input_array = np.array(input_grid)\n    n = len(input_array)\n\n    # --- Identify components ---\n    # 1. Find the pivot (9)\n    pivot_idx = find_pivot(input_array)\n    pivot_value = 9\n\n    # 2. Find the colored object (non-0, non-9 block)\n    colored_object, obj_start_idx, obj_end_idx = find_colored_object(input_array)\n\n    # 3. Find the separator (0s between pivot and object)\n    separator = find_separator(input_array, pivot_idx, obj_start_idx, obj_end_idx)\n\n    # --- Construct the output array ---\n    # Initialize output grid with zeros (white)\n    output_array = np.zeros(n, dtype=int)\n\n    # Place the pivot at its original index\n    output_array[pivot_idx] = pivot_value\n\n    # Place the separator immediately after the pivot\n    separator_start_out = pivot_idx + 1\n    separator_end_out = separator_start_out + len(separator)\n    if separator_end_out <= n: # Check bounds\n        output_array[separator_start_out:separator_end_out] = separator\n    else:\n        # Handle cases where separator might wrap or go out of bounds (though unlikely based on examples)\n        print(\"Warning: Separator placement extends beyond array bounds.\") \n        place_len = n - separator_start_out\n        if place_len > 0:\n            output_array[separator_start_out:] = separator[:place_len]\n\n\n    # Place the colored object immediately after the separator\n    object_start_out = separator_end_out\n    object_end_out = object_start_out + len(colored_object)\n    if object_end_out <= n: # Check bounds\n        output_array[object_start_out:object_end_out] = colored_object\n    else:\n        # Handle cases where object might wrap or go out of bounds\n        print(\"Warning: Object placement extends beyond array bounds.\")\n        place_len = n - object_start_out\n        if place_len > 0:\n             output_array[object_start_out:] = colored_object[:place_len]\n\n\n    # The rest of the array remains 0 (initialized state)\n\n    # Convert numpy array back to list for the required output format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2470,
    "candidates_token_count": 1478,
    "total_token_count": 3948,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.201417,
  "retries": 1
}