{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\ndef find_marker(grid):\n    \"\"\"\n    Finds the index of the first occurrence of the marker color (maroon, 9).\n\n    Args:\n        grid (np.array): The 1D input grid.\n\n    Returns:\n        int: The index of the marker, or None if not found.\n    \"\"\"\n    marker_indices = np.where(grid == 9)[0]\n    if len(marker_indices) > 0:\n        return marker_indices[0]\n    else:\n        return None # Marker not found\n\ndef find_colored_line(grid):\n    \"\"\"\n    Finds the first contiguous block of non-white (0) and non-maroon (9) pixels.\n\n    Args:\n        grid (np.array): The 1D input grid.\n\n    Returns:\n        tuple: (line_color, line_length, line_start_index, line_end_index)\n               or None if no such line is found.\n    \"\"\"\n    line_color = -1\n    line_length = 0\n    line_start_index = -1\n    line_end_index = -1\n    in_line = False\n\n    for i, pixel in enumerate(grid):\n        # A pixel is part of the line if it's not white (0) and not maroon (9)\n        is_line_pixel = pixel != 0 and pixel != 9\n        \n        if is_line_pixel and not in_line:\n            # Start of a potential line\n            in_line = True\n            line_color = pixel\n            line_start_index = i\n            line_length = 1\n        elif is_line_pixel and in_line:\n            # Continuing the line\n            if pixel == line_color: # Ensure it's the same color\n                line_length += 1\n            else: \n                # Found a different color - this indicates the end of the first line\n                line_end_index = i - 1\n                # We only care about the first contiguous line based on examples\n                break \n        elif not is_line_pixel and in_line:\n            # End of the line (transitioned to white or maroon)\n            line_end_index = i - 1\n            in_line = False\n            # Found the line, stop searching\n            break\n            \n    # Handle case where the line goes to the very end of the grid\n    if in_line:\n        line_end_index = len(grid) - 1\n\n    if line_start_index != -1:\n        return line_color, line_length, line_start_index, line_end_index\n    else:\n        return None # Line not found\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the following rules:\n    1. Identify the single maroon pixel (9) marker.\n    2. Identify the contiguous sequence of non-white, non-maroon pixels (the colored line).\n    3. Calculate the gap (number of white pixels) between the end of the line and the marker.\n    4. Find the index of the first white pixel immediately after the marker.\n    5. Calculate the new starting position for the line: first white index after marker + gap size.\n    6. Create the output grid by copying the input.\n    7. Erase the original line by setting its pixels to white (0).\n    8. Draw the line (same color and length) at the new calculated position.\n    \"\"\"\n    # Ensure input is a numpy array for efficient operations\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = grid_np.copy()\n    \n    # 1. Identify the marker\n    marker_index = find_marker(grid_np)\n    if marker_index is None:\n        print(\"Error: Marker (9) not found.\")\n        return input_grid # Return original if marker is missing\n\n    # 2. Identify the colored line\n    line_info = find_colored_line(grid_np)\n    if line_info is None:\n        print(\"Error: Colored line not found.\")\n        return input_grid # Return original if line is missing\n    line_color, line_length, line_start_index, line_end_index = line_info\n\n    # 3. Calculate the gap length before the marker\n    # Gap is the number of white pixels between line_end_index and marker_index\n    # If the line is right before the marker, the difference is 1, gap is 0.\n    gap_before_length = marker_index - (line_end_index + 1)\n    # Ensure gap is not negative (shouldn't happen with valid inputs)\n    gap_before_length = max(0, gap_before_length) \n\n    # 4. Find the index of the first white pixel after the marker\n    # Based on examples, the pixel immediately after the marker is always white (0)\n    # and is where the new positioning calculation starts.\n    first_white_after_marker_index = marker_index + 1\n    \n    # Basic check if marker is at the very end\n    if first_white_after_marker_index >= len(grid_np):\n         print(\"Warning: Marker is at the end, cannot place line after it based on logic.\")\n         # Or maybe the logic implies wrapping or stopping? Let's proceed but be aware.\n         # Based on train cases, there's always space after marker.\n         # If logic requires placing part of the line, calculation below handles it.\n         pass # Allow calculation to proceed, might result in out-of-bounds below\n\n    # 5. Calculate the new starting index for the colored line\n    new_line_start_index = first_white_after_marker_index + gap_before_length\n\n    # 6. Output grid is already a copy\n\n    # 7. Erase the original colored line by filling with white (0)\n    output_grid[line_start_index : line_end_index + 1] = 0\n\n    # 8. Place the colored line at the new position\n    new_line_end_index = new_line_start_index + line_length\n    # Ensure the placement does not exceed grid bounds\n    # Only place the part of the line that fits within the grid\n    actual_end_index = min(new_line_end_index, len(output_grid))\n    actual_length = actual_end_index - new_line_start_index\n    \n    if actual_length > 0:\n        output_grid[new_line_start_index : actual_end_index] = line_color\n    \n    # If actual_length < line_length, the line was truncated. This doesn't happen in examples.\n\n    # 9. Return the modified grid as a list\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2375,
    "candidates_token_count": 1577,
    "total_token_count": 3952,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 42.285715,
  "retries": 1
}