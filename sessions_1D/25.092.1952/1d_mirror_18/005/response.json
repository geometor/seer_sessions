{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\nIdentify a single maroon (9) pixel which acts as a pivot within a single-row grid (1xN).\nIdentify a contiguous block of a single color (not white 0 or maroon 9) within that same row.\nMove this colored block from one side of the pivot to the other along the row, maintaining the same number of white (0) pixels (the gap) between the block and the pivot. The original column positions occupied by the block become white (0) in the output grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import Optional, Tuple\n\n# Define colors for clarity\nWHITE = 0\nMAROON = 9\n\n# --- Helper Functions ---\n\ndef find_pivot(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the row and column index of the maroon (9) pivot pixel.\n    Assumes exactly one pivot exists.\n    Returns: (row, col) or None if not found.\n    \"\"\"\n    # Find indices where the value is MAROON\n    pivot_loc = np.where(grid == MAROON)\n    if len(pivot_loc[0]) > 0:\n        # Return the row and column of the first (and assumed only) occurrence\n        return pivot_loc[0][0], pivot_loc[1][0]\n    return None # Pivot not found\n\ndef find_colored_block(grid: np.ndarray, pivot_row: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the contiguous block of color in the specified row (pivot_row)\n    that is not white (0) or maroon (9).\n    Assumes only one such block exists in the relevant row.\n    Returns: (color, start_col, end_col, length) or None if not found.\n    \"\"\"\n    row_data = grid[pivot_row, :]\n    grid_len = len(row_data)\n    start_col = -1\n    block_color = -1\n\n    for col in range(grid_len):\n        pixel = row_data[col]\n        # Look for the start of a block (not white, not maroon)\n        if pixel != WHITE and pixel != MAROON:\n            start_col = col\n            block_color = pixel\n            # Find the end of the contiguous block of the same color\n            end_col = start_col\n            while end_col + 1 < grid_len and row_data[end_col + 1] == block_color:\n                end_col += 1\n            # Calculate block length\n            block_length = end_col - start_col + 1\n            # Return block details - assumes only one block needs to be found in the row\n            return block_color, start_col, end_col, block_length\n    return None # No suitable block found in this row\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to move the colored block across the pivot\n    in a single-row (1xN) NumPy array.\n    \"\"\"\n    # Get grid dimensions\n    rows, cols = input_grid.shape\n    if rows != 1:\n        # This specific solution assumes a 1xN grid based on examples.\n        # Handle other cases if necessary, e.g., return input or raise error.\n        print(f\"Warning: Input grid has {rows} rows, expected 1. Returning copy.\")\n        return np.copy(input_grid)\n\n    # Initialize output grid with background color (white)\n    output_grid = np.full_like(input_grid, WHITE)\n\n    # Find the pivot\n    pivot_info = find_pivot(input_grid)\n    if pivot_info is None:\n        print(\"Warning: Pivot (9) not found. Returning white grid.\")\n        return output_grid # Or return copy of input: np.copy(input_grid)\n\n    pivot_row, pivot_col = pivot_info\n\n    # Place the pivot in the output grid\n    output_grid[pivot_row, pivot_col] = MAROON\n\n    # Find the colored block in the pivot's row\n    block_info = find_colored_block(input_grid, pivot_row)\n    if block_info is None:\n        print(\"Warning: Colored block not found. Returning grid with only pivot.\")\n        return output_grid # Grid already has pivot placed\n\n    block_color, block_start_col, block_end_col, block_length = block_info\n\n    # Calculate the gap and new position based on relative location to pivot\n    new_start_col = -1\n    new_end_col = -1\n\n    if block_end_col < pivot_col:\n        # Block is before pivot\n        gap = pivot_col - block_end_col - 1\n        # Calculate new position (after pivot)\n        new_start_col = pivot_col + 1 + gap\n        new_end_col = new_start_col + block_length - 1\n    elif block_start_col > pivot_col:\n        # Block is after pivot (handle this case for robustness)\n        gap = block_start_col - pivot_col - 1\n        # Calculate new position (before pivot)\n        new_end_col = pivot_col - 1 - gap\n        new_start_col = new_end_col - block_length + 1\n    else:\n        # Block is adjacent to or overlapping pivot - undefined case based on examples\n        print(\"Warning: Block is adjacent to or overlapping pivot. Cannot determine movement.\")\n        return output_grid # Return grid with only pivot\n\n    # Place the colored block in its new position in the output grid, checking bounds\n    if 0 <= new_start_col < cols and 0 <= new_end_col < cols:\n        output_grid[pivot_row, new_start_col : new_end_col + 1] = block_color\n    else:\n        # Handle error case: New position is out of bounds\n        print(f\"Warning: Calculated new block position ({new_start_col}-{new_end_col}) is out of bounds for grid width {cols}. Block not placed.\")\n        # Output grid will contain only the pivot in this case\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8808,
    "candidates_token_count": 1447,
    "total_token_count": 10255,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.945529,
  "retries": 1
}