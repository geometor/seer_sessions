{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nTransforms a 1D input grid by reflecting a colored block across a maroon anchor pixel.\n\n1.  Receives the input grid (expected as `List[List[int]]`). Extracts the first row for processing and converts it into a NumPy array.\n2.  Initializes an output NumPy array of the same width, filled with white (0).\n3.  Finds the index (`anchor_index`) of the single maroon (9) pixel in the input row. If not found, returns the input grid.\n4.  Places the maroon (9) pixel at `anchor_index` in the output array.\n5.  Finds the single contiguous block of non-white, non-maroon pixels in the input row. Identifies its color (`block_color`), start index (`block_start_index`), end index (`block_end_index`), and length (`block_length`). If not found, returns the input grid.\n6.  Calculates the distance (`d`) between the end of the input block and the anchor pixel: `d = anchor_index - block_end_index`. Assumes the block is always before the anchor.\n7.  Calculates the new starting index (`new_block_start_index`) for the colored block in the output array: `new_block_start_index = anchor_index + d`.\n8.  Calculates the new ending index (`new_block_end_index`).\n9.  Checks if the new block position is within bounds.\n10. If within bounds, fills the corresponding pixels in the output array with the `block_color`.\n11. Converts the final output NumPy array back into the `List[List[int]]` format and returns it.\n\"\"\"\n\n\ndef _find_anchor(row: np.ndarray) -> Optional[int]:\n    \"\"\"Finds the index of the single maroon (9) pixel.\"\"\"\n    anchor_indices = np.where(row == 9)[0]\n    # Expect exactly one anchor\n    if len(anchor_indices) == 1:\n        # Use .item() to convert numpy int to standard python int\n        return anchor_indices[0].item()\n    return None # Return None if zero or more than one anchor found\n\ndef _find_colored_block(row: np.ndarray) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the single contiguous block of a color that is not white (0) or maroon (9).\n    Returns: Tuple (block_color, block_start_index, block_end_index, block_length) or None if no single valid block found.\n    \"\"\"\n    block_color = -1\n    block_start_index = -1\n    block_end_index = -1\n    width = len(row)\n    found_block = False\n\n    for i, pixel in enumerate(row):\n        # Look for the start of a potential block\n        if pixel != 0 and pixel != 9:\n            # Found a non-white, non-maroon pixel\n            if not found_block:\n                # This is the start of the first potential block\n                block_color = pixel.item() # Store color\n                block_start_index = i\n                block_end_index = i # Assume length 1 initially\n                found_block = True\n            elif pixel == block_color:\n                 # Continue the current block\n                 block_end_index = i\n            else:\n                 # Found a different color - indicates more than one block or noise\n                 return None # Problem statement implies only one block\n        elif found_block:\n            # We were in a block, but now hit 0 or 9, so the block ends here.\n            break # Exit loop once the block ends\n\n    # Check if a valid block was found\n    if found_block:\n        block_length = block_end_index - block_start_index + 1\n        # Verify only one block: Scan the rest of the array for other colored pixels\n        for i in range(block_end_index + 1, width):\n             if row[i] != 0 and row[i] != 9:\n                 return None # Found another colored pixel after the block ended\n        return block_color, block_start_index, block_end_index, block_length\n    else:\n        # No block start was ever found\n        return None\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the reflection transformation to the input grid.\n    \"\"\"\n    # --- Input Validation and Conversion ---\n    # Check if input_grid is a list and contains at least one row (list)\n    if not isinstance(input_grid, list) or len(input_grid) == 0 or not isinstance(input_grid[0], list):\n         # Invalid format, return input or appropriate error indication\n         # Returning input is often preferred in ARC if rules don't match\n         return input_grid\n    if len(input_grid[0]) == 0: # Handle empty row case\n        return input_grid\n\n    # Convert the first row to a NumPy array for efficient processing\n    try:\n        input_row = np.array(input_grid[0], dtype=int)\n    except ValueError:\n         # Handle case where row contains non-integer elements if necessary\n         return input_grid # Return input if conversion fails\n         \n    width = len(input_row)\n\n    # --- Find Key Elements ---\n    # Find the maroon anchor pixel's index\n    anchor_index = _find_anchor(input_row)\n    # Find the properties of the colored block\n    block_info = _find_colored_block(input_row)\n\n    # --- Pre-computation Checks ---\n    # If anchor or block is missing or invalid (e.g., multiple blocks),\n    # the specific transformation rule cannot be applied. Return input grid.\n    if anchor_index is None or block_info is None:\n        return input_grid\n\n    # Unpack block information (already standard Python types from helpers)\n    block_color, block_start_index, block_end_index, block_length = block_info\n\n    # --- Initialize Output Grid ---\n    # Create a new row filled with the background color (white, 0)\n    output_row = np.zeros_like(input_row) # Creates numpy array of same shape/type\n\n    # --- Apply Transformation Logic ---\n    # Place the anchor pixel in the output grid at its original position\n    # Ensure anchor_index is within bounds (should be if found correctly)\n    if 0 <= anchor_index < width:\n        output_row[anchor_index] = 9\n    else:\n         # This case should ideally not happen if _find_anchor works\n         return input_grid # Safety return\n\n    # Calculate the distance offset: how far the block end is from the anchor\n    # Assumes block is always before anchor, as seen in examples\n    distance = anchor_index - block_end_index\n\n    # Calculate the new starting index for the block after reflection\n    new_block_start_index = anchor_index + distance\n\n    # Calculate the new ending index for the block\n    new_block_end_index = new_block_start_index + block_length - 1\n\n    # --- Populate Output Grid with Transformed Block ---\n    # Check if the calculated new block position is valid (within grid bounds)\n    # Important: Slicing end index is exclusive, so use new_block_end_index + 1\n    if 0 <= new_block_start_index < width and 0 <= new_block_end_index < width:\n        # Fill the segment in the output grid with the block's color\n        output_row[new_block_start_index : new_block_end_index + 1] = block_color\n    # Else: If the block goes out of bounds, it's simply not drawn there.\n    # The output_row already has 0s in those positions.\n\n    # --- Format Output ---\n    # Convert the resulting NumPy row back to the required List[List[int]] format\n    # Need [[val1, val2, ...]]\n    output_grid = [output_row.tolist()]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11962,
    "candidates_token_count": 1875,
    "total_token_count": 13837,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.060872,
  "retries": 1
}