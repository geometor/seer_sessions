{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np # Although not strictly needed for list ops, good practice for potential future array needs\n\ndef find_maroon_pixel(row):\n    \"\"\"Finds the index of the single Maroon (9) pixel.\"\"\"\n    try:\n        return row.index(9)\n    except ValueError:\n        return -1 # Indicate not found\n\ndef find_colored_block(row):\n    \"\"\"\n    Finds the contiguous block of non-White(0), non-Maroon(9) color.\n    Returns: tuple (sequence, start_index, end_index_exclusive) or (None, -1, -1) if not found.\n    \"\"\"\n    sequence = []\n    start_index = -1\n    end_index = -1\n    block_color = -1\n    in_block = False\n\n    for i, pixel in enumerate(row):\n        if not in_block:\n            if pixel != 0 and pixel != 9:\n                # Start of a new block\n                in_block = True\n                start_index = i\n                block_color = pixel\n                sequence.append(pixel)\n        else: # Already in a block\n            if pixel == block_color:\n                # Continue the block\n                sequence.append(pixel)\n            else:\n                # End of the block (different color, 0, or 9 found)\n                end_index = i\n                break # Block found and ended\n\n    # If the block runs to the very end of the row\n    if in_block and end_index == -1:\n        end_index = len(row)\n\n    if not in_block: # Block never started\n        return None, -1, -1\n    else:\n        return sequence, start_index, end_index\n\ndef find_separator(row, block_end_index, maroon_index):\n    \"\"\"\n    Finds the sequence of White(0) pixels between the colored block and the maroon pixel.\n    Assumes block appears before maroon pixel based on examples.\n    Returns: list (separator sequence)\n    \"\"\"\n    if block_end_index != -1 and maroon_index != -1 and block_end_index <= maroon_index:\n        # Extract the slice between the end of the block and the start of the maroon pixel\n        separator = row[block_end_index:maroon_index]\n        # Verify it's all zeros (optional, based on strictness)\n        # if not all(p == 0 for p in separator):\n        #     print(\"Warning: Non-zero elements found in expected separator region.\")\n        return separator\n    elif maroon_index != -1 and block_end_index != -1 and maroon_index < block_end_index:\n        # Handle case where maroon pixel is before the block (if needed)\n        # separator = row[maroon_index + 1 : block_end_index] # Assuming block_end_index is start index here\n        # This case is not seen in examples, so stick to observed pattern for now.\n        print(\"Warning: Maroon pixel found before colored block, separator logic might need adjustment.\")\n        return []\n    else:\n        # One or both components not found or adjacent\n        return []\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the following rule:\n    1. Identifies a single Maroon (9) pixel, a contiguous block of another color (non-0, non-9),\n       and a sequence of White (0) pixels separating them in the input.\n    2. Constructs the output grid by placing the Maroon pixel at its original index,\n       followed immediately by the separator sequence, followed immediately by the colored block sequence.\n    3. All other positions are filled with White (0).\n    \"\"\"\n    # Input grid is expected as [[row_elements...]]\n    if not input_grid or not isinstance(input_grid[0], list):\n        print(\"Error: Invalid input grid format.\")\n        return [] # Return empty list for invalid input\n\n    input_row = input_grid[0]\n    width = len(input_row)\n\n    # Initialize output grid with background color (0)\n    output_row = [0] * width\n\n    # --- Identify Components ---\n    maroon_index = find_maroon_pixel(input_row)\n    if maroon_index == -1:\n        print(\"Error: Maroon pixel (9) not found.\")\n        return [output_row] # Return default grid if essential component missing\n\n    colored_block_sequence, block_start_index, block_end_index = find_colored_block(input_row)\n    if colored_block_sequence is None:\n        print(\"Error: Colored block not found.\")\n        return [output_row] # Return default grid if essential component missing\n\n    # Find separator based on the relative positions found\n    separator_sequence = find_separator(input_row, block_end_index, maroon_index)\n    # Note: find_separator currently assumes block is before maroon pixel.\n\n    # --- Construct Output Grid ---\n\n    # Place Maroon pixel (anchor point)\n    # Boundary check already implicitly done by find_maroon_pixel finding a valid index\n    output_row[maroon_index] = 9\n\n    # Place Separator sequence after Maroon pixel\n    current_index = maroon_index + 1\n    sep_len = len(separator_sequence)\n    if current_index < width: # Check if there's space to start placing separator\n        # Calculate how many separator pixels actually fit\n        fit_len = min(sep_len, width - current_index)\n        output_row[current_index : current_index + fit_len] = separator_sequence[:fit_len]\n        current_index += fit_len # Update index to position after placed separator\n\n    # Place Colored Block sequence after Separator sequence\n    block_len = len(colored_block_sequence)\n    if current_index < width: # Check if there's space to start placing block\n        # Calculate how many block pixels actually fit\n        fit_len = min(block_len, width - current_index)\n        output_row[current_index : current_index + fit_len] = colored_block_sequence[:fit_len]\n        # No need to update current_index further as this is the last element placed\n\n    # Return the output row wrapped in a list\n    return [output_row]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9209,
    "candidates_token_count": 1447,
    "total_token_count": 10656,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.56117,
  "retries": 1
}