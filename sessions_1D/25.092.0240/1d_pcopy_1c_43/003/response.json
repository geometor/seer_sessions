{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1D input grid based on a pattern replacement rule.\n\n1.  Identify the \"pattern\": Find the first contiguous horizontal sequence of \n    identical non-white pixels (color C) with a length (L) greater than 1, \n    scanning from left to right.\n2.  If no such pattern exists, return the input grid unchanged.\n3.  Identify \"target\" pixels: Locate all single pixels in the *input* grid \n    that have the same color (C) as the pattern. A pixel at index 'i' is \n    considered single if it's not adjacent (horizontally) to another pixel \n    of the same color C (i.e., pixel i-1 (if exists) != C and \n    pixel i+1 (if exists) != C).\n4.  Replace targets in the output grid: For each target pixel found at index 'i' \n    in the input grid, determine the replacement start position `start_pos = max(0, i - 1)`. \n    Replace the segment of the *output* grid from `start_pos` up to \n    `min(width, start_pos + L)` with the pattern color (C).\n5.  Return the modified grid, preserving the original shape (1D or single-row 2D).\n\"\"\"\n\ndef find_pattern_sequence(grid_1d):\n    \"\"\"\n    Finds the first sequence longer than 1 pixel in a 1D grid.\n    \n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A tuple (color, length) of the first pattern sequence found, \n        or (None, None) if no sequence longer than 1 exists.\n    \"\"\"\n    n = len(grid_1d)\n    i = 0\n    while i < n:\n        color = grid_1d[i]\n        # Skip background color\n        if color == 0: \n            i += 1\n            continue\n        \n        # Found a non-white pixel, track sequence start\n        start_index = i\n        j = i + 1\n        # Find the end of the sequence of this color\n        while j < n and grid_1d[j] == color:\n            j += 1\n        \n        length = j - start_index\n        \n        # Check if this sequence is the pattern (length > 1)\n        if length > 1:\n            return color, length # Found the pattern\n            \n        # Move the main index past the sequence just checked\n        i = j \n        \n    # No pattern sequence found\n    return None, None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern replacement transformation to the input grid.\n    \"\"\"\n    # Convert input to numpy array and ensure it's effectively 1D\n    input_np = np.array(input_grid, dtype=int)\n    original_shape = input_np.shape \n    \n    # Handle 1D or single-row 2D arrays\n    if input_np.ndim == 1:\n        grid_1d = input_np\n    elif input_np.ndim == 2 and input_np.shape[0] == 1:\n        grid_1d = input_np.flatten()\n    else:\n        # If input is not 1D or single-row 2D, return it unchanged\n        # as the logic is defined for 1D sequences.\n        # print(f\"Warning: Input grid shape {original_shape} is not 1D or single-row 2D. Returning input unchanged.\")\n        return input_grid\n\n    width = len(grid_1d)\n    \n    # Initialize output_grid as a copy of the 1D input\n    output_grid_1d = grid_1d.copy()\n\n    # Step 1: Find the pattern sequence (color C, length L)\n    pattern_color, pattern_length = find_pattern_sequence(grid_1d)\n\n    # Step 2: If no pattern found, return the original input (reshaped)\n    if pattern_color is None:\n        return output_grid_1d.reshape(original_shape)\n\n    # Step 3 & 4: Find single target pixels in the *input* grid \n    #             and perform replacement in the *output* grid\n    i = 0\n    while i < width:\n        # Check if current pixel in the input grid matches pattern color\n        if grid_1d[i] == pattern_color:\n            # Check if it's a single pixel sequence in the input grid\n            is_single = True\n            # Check left neighbor (if exists)\n            if i > 0 and grid_1d[i-1] == pattern_color:\n                is_single = False\n            # Check right neighbor (if exists)\n            if i < width - 1 and grid_1d[i+1] == pattern_color:\n                is_single = False\n            \n            # If it's a single target pixel\n            if is_single:\n                # Calculate the start position for replacement in the output grid\n                start_index = max(0, i - 1)\n                # Calculate the end index (exclusive) for replacement, capped by grid width\n                end_index = min(width, start_index + pattern_length)\n                # Replace the segment in the output grid\n                output_grid_1d[start_index:end_index] = pattern_color\n                # Move to the next pixel in the input grid\n                i += 1 \n            else:\n                # It's part of a longer sequence in the input, just move to the next pixel\n                i += 1\n        else:\n            # Not the pattern color, move to the next pixel in the input grid\n            i += 1\n\n    # Step 5: Reshape the output to match the original input shape and return\n    return output_grid_1d.reshape(original_shape)\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9120,
    "candidates_token_count": 1375,
    "total_token_count": 10495,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.920326,
  "retries": 1
}