{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1D input grid based on a pattern replacement rule.\n\n1.  Identify the \"pattern\": Find the first contiguous horizontal sequence of \n    identical non-white pixels (color C) with a length (L) greater than 1, \n    scanning from left to right.\n2.  If no such pattern exists, return the input grid unchanged.\n3.  Identify \"target\" pixels: Locate all single pixels in the input grid \n    that have the same color (C) as the pattern. A pixel is considered single \n    if it's not adjacent (horizontally) to another pixel of the same color.\n4.  Replace targets: For each target pixel found at index 'i', replace the \n    segment of the grid from index 'i' up to 'i + L - 1' (or the end of the \n    grid, whichever comes first) with the pattern color (C). This replacement \n    happens on a copy of the input grid.\n5.  Return the modified grid.\n\"\"\"\n\ndef find_pattern_sequence(grid_1d):\n    \"\"\"\n    Finds the first sequence longer than 1 pixel.\n    Returns its color and length, or (None, None) if not found.\n    \"\"\"\n    n = len(grid_1d)\n    i = 0\n    while i < n:\n        color = grid_1d[i]\n        if color == 0:  # Skip white background\n            i += 1\n            continue\n        \n        # Found a non-white pixel, start counting sequence length\n        start_index = i\n        j = i + 1\n        while j < n and grid_1d[j] == color:\n            j += 1\n        \n        length = j - start_index\n        \n        if length > 1:\n            return color, length # Found the pattern\n            \n        i = j # Move to the pixel after the sequence\n        \n    return None, None # No sequence longer than 1 found\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern replacement transformation to the input grid.\n    \"\"\"\n    # Ensure input is treated as a 1D numpy array\n    input_np = np.array(input_grid, dtype=int)\n    # Store original shape if it was 2D (like [[...]])\n    original_shape = input_np.shape \n    if input_np.ndim > 1:\n        if input_np.shape[0] == 1: # Check if it's a single row 2D array\n             grid_1d = input_np.flatten()\n        else:\n             # This function expects a 1D array or single row 2D array\n             # For multi-row inputs, the logic is undefined by the examples.\n             # Returning input unchanged for now. Consider raising an error?\n             # print(f\"Warning: Input grid has multiple rows ({original_shape}), expected 1 row. Returning input unchanged.\")\n             return input_grid # Or raise ValueError(\"Input must be 1D or a single row.\")\n    else:\n        grid_1d = input_np\n\n    width = len(grid_1d)\n    \n    # Initialize output_grid as a copy of the 1D input\n    output_grid_1d = grid_1d.copy()\n\n    # 1. Find the pattern sequence (color C, length L)\n    pattern_color, pattern_length = find_pattern_sequence(grid_1d)\n\n    # 2. If no pattern found, return the original input\n    if pattern_color is None:\n        # Return in the original shape\n        return output_grid_1d.reshape(original_shape)\n\n    # 3. & 4. Find single target pixels and replace them in the output grid\n    i = 0\n    while i < width:\n        # Check if current pixel is a potential target (matches pattern color)\n        if grid_1d[i] == pattern_color:\n            # Check if it's a single pixel sequence\n            is_single = True\n            # Check left neighbor (if exists)\n            if i > 0 and grid_1d[i-1] == pattern_color:\n                is_single = False\n            # Check right neighbor (if exists)\n            if i < width - 1 and grid_1d[i+1] == pattern_color:\n                is_single = False\n            \n            # 5. If it's a single target pixel, perform replacement\n            if is_single:\n                # Determine the end index for replacement, capped by grid width\n                end_index = min(i + pattern_length, width)\n                # Replace the segment in the output grid\n                output_grid_1d[i:end_index] = pattern_color\n                # Important: Advance 'i' past the newly placed pattern to avoid re-evaluating replaced pixels\n                # or creating overlapping patterns immediately. Although the logic checks original grid, \n                # skipping prevents redundant checks if we were modifying in place or checking output.\n                # However, since we check the *original* grid_1d for targets, we just need to advance i by 1.\n                # If we placed a pattern of length L, the next potential *start* of a single pixel\n                # cannot be within the replaced section based on the original grid.\n                # Let's just advance by 1.\n                i += 1 \n            else:\n                # It's part of a longer sequence, just move to the next pixel\n                i += 1\n        else:\n            # Not the pattern color, move to the next pixel\n            i += 1\n\n    # Reshape the output to match the original input shape before returning\n    return output_grid_1d.reshape(original_shape)\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2351,
    "candidates_token_count": 1322,
    "total_token_count": 3673,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.176058,
  "retries": 1
}