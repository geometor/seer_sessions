{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\n\n\"\"\"\nProcesses the input grid row by row. For each row:\n1. Identifies all contiguous horizontal blocks (objects) of non-white pixels.\n2. Determines the largest object in the row based on width, designating it as the 'pattern' for that row. If there's a tie for the largest size, the one appearing earliest (leftmost start index) is chosen.\n3. Finds all single-pixel objects (width=1) within the same row that share the same color as the row's pattern.\n4. Creates a copy of the row to store modifications.\n5. Replaces each identified single-pixel object in the copied row with a copy of the pattern, ensuring the pattern is centered over the original pixel's position.\n6. Handles boundary conditions: if placing the pattern causes it to extend beyond the row's edges, the pattern is clipped accordingly so only the overlapping part is written.\n7. The original pattern object location remains unchanged in the input but can be overwritten in the output if a target replacement overlaps its position.\n8. Returns a new grid composed of these potentially modified rows, having the same dimensions as the input grid. If a row has no non-white objects, or no single-pixel targets matching the pattern color, it remains unchanged in the output.\n\"\"\"\n\ndef find_objects_1d(grid_1d):\n    \"\"\"\n    Finds contiguous blocks of non-white pixels in a 1D NumPy array (a row).\n\n    Args:\n        grid_1d: A 1D NumPy array representing a row of the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys: 'color', 'size' (width), 'start' (column index), 'end' (column index). \n        Returns an empty list if the input row is empty or contains only \n        background pixels (color 0).\n    \"\"\"\n    if grid_1d is None or grid_1d.size == 0:\n        return []\n\n    objects = []\n    in_object = False\n    current_object = {}\n    for i, pixel in enumerate(grid_1d):\n        # Ensure pixel is a standard Python int for comparisons\n        pixel_val = pixel.item() \n        \n        if pixel_val != 0 and not in_object: # Start of a new non-white object\n            in_object = True\n            current_object = {'color': pixel_val, 'size': 1, 'start': i, 'end': i}\n        elif pixel_val != 0 and in_object: # Continuing an object\n            if pixel_val == current_object['color']: # Same color, extend object\n                current_object['size'] += 1\n                current_object['end'] = i\n            else: # Different non-white color, end previous object, start new one\n                objects.append(current_object)\n                current_object = {'color': pixel_val, 'size': 1, 'start': i, 'end': i}\n                in_object = True # Still in an object (the new one)\n        elif pixel_val == 0 and in_object: # End of an object (hit white pixel)\n            in_object = False\n            objects.append(current_object)\n            current_object = {}\n        # If pixel is 0 and not in_object, do nothing\n\n    # If the row ends while inside an object, add the last object\n    if in_object:\n        objects.append(current_object)\n        \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the row-wise pattern replacement transformation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # --- Input Validation and Initialization ---\n    if not isinstance(input_grid, list) or not input_grid:\n        return [] # Handle empty input list\n    if not all(isinstance(row, list) for row in input_grid):\n         # Handle cases where input is not list of lists (e.g., list of ints)\n         return input_grid # Return input unmodified as a safe default\n\n    try:\n        # Convert input to NumPy array for efficient processing\n        input_np = np.array(input_grid, dtype=int)\n    except ValueError:\n        # Handle potential error if rows have different lengths (ragged array)\n        # Returning original might be safest without more specs\n        return input_grid \n        \n    output_np = input_np.copy() # Create a copy to modify for the output\n    \n    # Handle empty grid (e.g., [[]])\n    if input_np.size == 0:\n       # If input was [[]], numpy might make shape (1,0). \n       # Return [[]] to match potential expectation.\n       if len(input_grid) == 1 and len(input_grid[0]) == 0:\n           return [[]]\n       # Otherwise return empty list for input like []\n       return []\n       \n    height, width = input_np.shape\n    \n    # Handle grid with width 0 (e.g. [[], []])\n    if width == 0:\n        return [[] for _ in range(height)] # Return list of empty lists\n\n\n    # --- Process Each Row Independently ---\n    for r in range(height):\n        # Extract the current row from the original input\n        # This ensures subsequent pattern searches use the unmodified row\n        row_np_original = input_np[r, :] \n        \n        # --- Find Objects in the Current Row ---\n        objects = find_objects_1d(row_np_original)\n\n        # If no non-white objects exist in this row, skip to the next row\n        # The output row already contains the original row data from the initial copy\n        if not objects:\n            continue\n\n        # --- Identify Pattern and Targets for the Row ---\n        # Find the object(s) with the maximum size\n        max_size = 0\n        for obj in objects:\n            if obj['size'] > max_size:\n                max_size = obj['size']\n        \n        # Filter to get all objects with max_size\n        largest_objects = [obj for obj in objects if obj['size'] == max_size]\n\n        # If multiple largest objects exist, choose the one with the smallest 'start' index\n        # (This handles ties consistently)\n        if not largest_objects: # Should not happen if objects is not empty\n             continue \n        pattern_object_info = min(largest_objects, key=lambda obj: obj['start'])\n\n        pattern_color = pattern_object_info['color']\n        pattern_size = pattern_object_info['size']\n        pattern_start = pattern_object_info['start']\n        pattern_end = pattern_object_info['end']\n\n        # Extract the actual pixel sequence of the pattern from the original row\n        # Check bounds just in case, though find_objects should be correct\n        if 0 <= pattern_start <= pattern_end < width:\n             pattern_sequence = row_np_original[pattern_start : pattern_end + 1]\n        else:\n             # Should not happen with correct find_objects_1d\n             continue # Skip row if pattern indices are invalid\n\n        # Identify target objects: single pixels (size 1) with the same color as the pattern\n        target_objects_indices = [\n            obj['start'] for obj in objects\n            if obj['size'] == 1 and obj['color'] == pattern_color\n        ]\n        \n        # If no targets found, no changes needed for this row\n        if not target_objects_indices:\n            continue\n\n        # --- Perform Replacements in the Output Row ---\n        # Operate on the corresponding row in the output_np array\n        row_to_modify = output_np[r, :]\n        \n        for target_index in target_objects_indices:\n            # Calculate the ideal start column for placing the pattern, centered on target_index\n            # math.floor is used for centering consistency, especially with even pattern sizes\n            start_col = target_index - math.floor(pattern_size / 2)\n            \n            # Calculate the ideal end column (exclusive)\n            end_col = start_col + pattern_size\n\n            # --- Boundary Condition Handling (Clipping) ---\n            # Determine the actual slice of the output row to modify (destination)\n            dest_start = max(0, start_col)\n            dest_end = min(width, end_col)\n\n            # Determine the corresponding slice of the pattern sequence to use (source)\n            # src_start is how many pixels to skip from the beginning of pattern_sequence\n            src_start = max(0, -start_col) \n            # src_end is the index in pattern_sequence corresponding to dest_end\n            # It's calculated based on how much the pattern hangs off the right edge\n            src_end = pattern_size - max(0, end_col - width)\n            \n            # Ensure the calculated slices are valid and represent a non-empty segment\n            if dest_start < dest_end and src_start < src_end:\n                # Get the actual segment of the pattern to place\n                pattern_segment = pattern_sequence[src_start:src_end]\n                \n                # Check if the lengths match (they should if logic is correct)\n                if len(pattern_segment) == (dest_end - dest_start):\n                     # Place the potentially clipped part of the pattern sequence\n                     # into the corresponding row of the output grid\n                     row_to_modify[dest_start:dest_end] = pattern_segment\n                # else: Optional: add error handling/logging if lengths mismatch\n\n\n    # --- Format Output ---\n    # Convert the final NumPy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12137,
    "candidates_token_count": 2258,
    "total_token_count": 14395,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.718371,
  "retries": 1
}