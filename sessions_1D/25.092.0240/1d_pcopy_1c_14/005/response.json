{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nProcesses the input grid row by row. For each row:\n1. Identifies all contiguous blocks (objects) of non-white pixels.\n2. Determines the largest object in the row, designating it as the 'pattern' for that row.\n3. Finds all single-pixel objects within the same row that share the same color as the row's pattern.\n4. Creates a copy of the row.\n5. Replaces each identified single-pixel object in the copied row with a copy of the pattern, ensuring the pattern is centered over the original pixel's position.\n6. Handles boundary conditions: if placing the pattern causes it to extend beyond the row's edges, the pattern is clipped accordingly.\n7. The original pattern object location remains unchanged unless it is overwritten by a replacement centered on a different target pixel.\n8. Returns a new grid composed of these potentially modified rows, having the same dimensions as the input grid.\n\"\"\"\n\nimport numpy as np\nimport math\n\ndef find_objects_1d(grid_1d):\n    \"\"\"\n    Finds contiguous blocks of non-white pixels in a 1D NumPy array (a row).\n\n    Args:\n        grid_1d: A 1D NumPy array representing a row of the grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys: 'color', 'size', 'start', 'end'. Returns an empty list\n        if the input is empty or contains only background pixels (color 0).\n    \"\"\"\n    if grid_1d is None or grid_1d.size == 0:\n        return []\n\n    objects = []\n    in_object = False\n    current_object = {}\n    for i, pixel in enumerate(grid_1d):\n        pixel_val = pixel.item() # Extract scalar value for comparison\n        \n        if pixel_val != 0 and not in_object: # Start of a new non-white object\n            in_object = True\n            current_object = {'color': pixel_val, 'size': 1, 'start': i, 'end': i}\n        elif pixel_val != 0 and in_object: # Continuing an object\n            if pixel_val == current_object['color']: # Same color, extend object\n                current_object['size'] += 1\n                current_object['end'] = i\n            else: # Different non-white color, end previous object, start new one\n                objects.append(current_object)\n                current_object = {'color': pixel_val, 'size': 1, 'start': i, 'end': i}\n                # No need to set in_object=True, it already is.\n        elif pixel_val == 0 and in_object: # End of an object (hit white pixel)\n            in_object = False\n            objects.append(current_object)\n            current_object = {}\n        # If pixel is 0 and not in_object, do nothing\n\n    # If the grid ends while inside an object, add the last object\n    if in_object:\n        objects.append(current_object)\n        \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the row-wise pattern replacement transformation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # --- Input Validation and Initialization ---\n    if not isinstance(input_grid, list) or not input_grid:\n        return [] \n    if not all(isinstance(row, list) for row in input_grid):\n         # Handle cases where input is not list of lists\n         # Return input unmodified as a safe default, though error might be better\n         return input_grid \n\n    input_np = np.array(input_grid, dtype=int)\n    output_np = input_np.copy() # Create a copy to modify\n    height, width = input_np.shape\n\n    # --- Process Each Row Independently ---\n    for r in range(height):\n        row_np = input_np[r, :] # Get the current row from the original input\n        \n        # Handle empty rows within the grid\n        if row_np.size == 0:\n            continue \n\n        # --- Find Objects in the Current Row ---\n        objects = find_objects_1d(row_np)\n\n        # If no non-white objects exist in this row, skip to the next row\n        if not objects:\n            continue\n\n        # --- Identify Pattern and Targets for the Row ---\n        # Use max with a default value in case objects is empty (safety check)\n        pattern_object_info = max(objects, key=lambda obj: obj['size'], default=None)\n        \n        # This check is redundant due to the 'if not objects' check above, but safe\n        if pattern_object_info is None:\n            continue # Should not happen if objects list is not empty\n\n        pattern_color = pattern_object_info['color']\n        pattern_size = pattern_object_info['size']\n        pattern_start = pattern_object_info['start']\n        pattern_end = pattern_object_info['end']\n\n        # Extract the actual pixel sequence of the pattern from the original row\n        # Ensure indices are within bounds (should be guaranteed by find_objects_1d)\n        if pattern_start >= 0 and pattern_end < width:\n             pattern_sequence = row_np[pattern_start : pattern_end + 1]\n        else:\n             # Handle potential error case if find_objects_1d returned invalid indices\n             continue # Skip this row if pattern indices are bad\n\n\n        # Identify target objects: single pixels (size 1) with the same color as the pattern\n        target_objects_indices = [\n            obj['start'] for obj in objects\n            if obj['size'] == 1 and obj['color'] == pattern_color\n        ]\n\n        # --- Perform Replacements in the Output Row ---\n        # Note: Replacements are done on output_np[r, :]\n        for target_index in target_objects_indices:\n            # Calculate the ideal start index for placing the pattern so it's centered\n            start_index = target_index - math.floor(pattern_size / 2)\n            # Calculate the ideal end index (exclusive) for slicing\n            end_index = start_index + pattern_size\n\n            # --- Boundary Condition Handling (Clipping) ---\n            # Determine the actual slice of the output row to modify (destination)\n            dest_start = max(0, start_index)\n            dest_end = min(width, end_index)\n\n            # Determine the corresponding slice of the pattern sequence to use (source)\n            src_start = max(0, -start_index) \n            src_end = pattern_size - max(0, end_index - width)\n            \n            # Ensure the calculated slices are valid before attempting replacement\n            if dest_start < dest_end and src_start < src_end and src_end <= pattern_sequence.size:\n                 # Ensure the source slice doesn't exceed the pattern sequence length\n                effective_src_end = min(src_end, src_start + (dest_end - dest_start))\n\n                if src_start < effective_src_end:\n                    # Place the appropriate (potentially clipped) part of the pattern sequence\n                    # into the corresponding row of the output grid\n                    output_np[r, dest_start:dest_end] = pattern_sequence[src_start:effective_src_end]\n\n    # --- Format Output ---\n    # Convert the final NumPy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8849,
    "candidates_token_count": 1748,
    "total_token_count": 10597,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.447178,
  "retries": 1
}