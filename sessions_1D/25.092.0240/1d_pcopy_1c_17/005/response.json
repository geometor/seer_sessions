{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\ndef find_first_contiguous_segment(grid):\n    \"\"\"\n    Finds the first contiguous horizontal segment of a single non-white color\n    encountered when scanning the grid top-to-bottom, left-to-right.\n\n    Args:\n        grid (np.ndarray): The input grid (2D NumPy array).\n\n    Returns:\n        tuple: (color, row_index, min_col, max_col) if found, otherwise None.\n               color is the integer color value.\n               row_index is the row where the segment starts.\n               min_col is the starting column index of the segment.\n               max_col is the ending column index of the segment.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color_c = grid[r, c]\n            if color_c != 0:  # Found the first non-white pixel\n                # Find the end of the contiguous segment of this color in this row\n                min_c = c\n                max_c = c\n                # Look ahead to find the end of the segment with the *same* color\n                while max_c + 1 < cols and grid[r, max_c + 1] == color_c:\n                    max_c += 1\n                # Found the first segment, return its properties\n                return int(color_c), r, int(min_c), int(max_c)\n    return None # No non-white pixels found\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on a reference line and trigger pixels below it.\n    1. Identifies the topmost contiguous horizontal segment of a single non-white\n       color (the \"reference line\").\n    2. Records its color (C), row (R), and column range [min_col, max_col].\n    3. Iterates through rows below the reference line (r > R).\n    4. If any pixel in an input row r (below R) has the color C, it triggers filling.\n    5. In the output grid, the segment from min_col to max_col in the triggered row r\n       is filled entirely with color C.\n    6. Pixels not part of the reference line or the filled segments remain unchanged.\n    \"\"\"\n\n    # --- Initialization and Grid Setup ---\n    input_array = np.array(input_grid_list, dtype=int)\n\n    # Determine grid shape. Assume 4x8 for length 32, fail otherwise for now.\n    # More robust ARC solutions might dynamically determine shape.\n    if len(input_grid_list) == 32:\n        shape = (4, 8)\n    else:\n        # Handle potential other shapes or raise an error if shape is ambiguous/unexpected\n        # For this specific problem, based on examples, 4x8 seems implied.\n        # A more general solution would need shape inference.\n        # Let's try inferring rectangular shapes:\n        rows = int(np.sqrt(len(input_grid_list)))\n        if rows * rows == len(input_grid_list): # perfect square\n            shape = (rows, rows)\n        else: # try common factors, this part is heuristic for ARC\n             factors = [(i, len(input_grid_list)//i) for i in range(1, int(len(input_grid_list)**0.5) + 1) if len(input_grid_list) % i == 0]\n             # Prefer squarish shapes or shapes seen in ARC?\n             # This is complex. Hardcoding 4x8 based on the example data length.\n             if len(input_grid_list) != 32:\n                 raise ValueError(\"Input list length is not 32, cannot assume 4x8 shape.\")\n             shape = (4,8) # Defaulting back to the observed size\n\n\n    try:\n        input_grid = input_array.reshape(shape)\n    except ValueError as e:\n        print(f\"Error reshaping input list of length {len(input_grid_list)}: {e}\")\n        # Decide how to handle error: return input? raise?\n        return input_grid_list # Return original if reshape fails\n\n    # Initialize output grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- Find Reference Line ---\n    reference_info = find_first_contiguous_segment(input_grid)\n\n    # If no reference line is found (e.g., all white grid), return the original grid\n    if reference_info is None:\n        return output_grid.tolist() # Convert back to list of lists\n\n    color_c, row_r, min_col, max_col = reference_info\n\n    # --- Scan Rows Below Reference and Apply Transformation ---\n    # Iterate through each row 'r' strictly below the reference line's row 'row_r'\n    for r in range(row_r + 1, rows):\n        # Check if any pixel in the *input* grid's current row 'r' has the reference color 'color_c'\n        trigger_found = False\n        # Use numpy's any() for efficient checking across the row\n        if np.any(input_grid[r] == color_c):\n            trigger_found = True\n\n        # If a trigger pixel was found in input row 'r'\n        if trigger_found:\n            # Fill the corresponding segment in the *output* grid's row 'r'\n            # The segment spans the same columns as the reference line [min_col, max_col]\n            # Ensure slice indices are within grid bounds, although they should be if reference line was valid.\n            fill_start_col = max(0, min_col)\n            fill_end_col = min(cols, max_col + 1) # Slicing is exclusive at the end\n\n            # Modify the output grid segment with the reference color\n            output_grid[r, fill_start_col:fill_end_col] = color_c\n\n    # --- Return Result ---\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18312,
    "candidates_token_count": 1422,
    "total_token_count": 19734,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.759781,
  "retries": 1
}