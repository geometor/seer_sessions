{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on a reference line and trigger pixels below it.\n1. Assumes the input is a 2D grid (list of lists).\n2. Creates a deep copy of the input grid for the output.\n3. Identifies the topmost contiguous horizontal segment of a single non-white\n   color (the \"reference line\") by scanning top-down, left-right.\n4. Records its color (C), row (R), and column range [min_col, max_col].\n5. If no reference line is found, returns the original grid copy.\n6. Iterates through rows below the reference line (r > R) in the input grid.\n7. If any pixel in an input row r (below R) has the color C, it triggers filling.\n8. In the output grid, the segment from min_col to max_col in the triggered row r\n   is filled entirely with color C.\n9. Pixels not part of the reference line or the filled segments remain unchanged.\n10. Returns the modified output grid as a list of lists.\n\"\"\"\n\nimport numpy as np\nimport copy\n\ndef find_first_contiguous_segment(grid):\n    \"\"\"\n    Finds the first contiguous horizontal segment of a single non-white color\n    encountered when scanning the grid top-to-bottom, left-to-right.\n\n    Args:\n        grid (np.ndarray): The input grid (2D NumPy array).\n\n    Returns:\n        tuple: (color, row_index, min_col, max_col) if found, otherwise None.\n               color is the integer color value.\n               row_index is the row where the segment starts.\n               min_col is the starting column index of the segment.\n               max_col is the ending column index of the segment.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color_c = grid[r, c]\n            if color_c != 0:  # Found the first non-white pixel\n                # Find the end of the contiguous segment of this color in this row\n                min_c = c\n                max_c = c\n                # Look ahead to find the end of the segment with the *same* color\n                while max_c + 1 < cols and grid[r, max_c + 1] == color_c:\n                    max_c += 1\n                # Found the first segment, return its properties\n                # Ensure types are standard Python ints\n                return int(color_c), int(r), int(min_c), int(max_c)\n    return None # No non-white pixels found\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid_list (list): A list of lists representing the input grid.\n\n    Returns:\n        list: A list of lists representing the transformed output grid.\n    \"\"\"\n    # --- Initialization and Grid Setup ---\n    # Convert input list of lists to a NumPy array for efficient processing\n    try:\n        input_grid = np.array(input_grid_list, dtype=int)\n    except ValueError:\n        # Handle potentially inconsistent row lengths if necessary, although ARC spec implies rectangular\n        print(\"Warning: Input grid might not be rectangular.\")\n        # Attempt to proceed if possible, or return input/raise error\n        return copy.deepcopy(input_grid_list) # Return copy if conversion fails\n\n    # Create a deep copy for the output grid to modify\n    output_grid = copy.deepcopy(input_grid)\n    rows, cols = input_grid.shape\n\n    # --- Find Reference Line ---\n    # Use the helper function to find the reference segment properties\n    reference_info = find_first_contiguous_segment(input_grid)\n\n    # If no reference line is found (e.g., all white grid), return the initial copy\n    if reference_info is None:\n        # Convert back to list of lists before returning\n        return output_grid.tolist()\n\n    # Unpack the reference line properties\n    color_c, row_r, min_col, max_col = reference_info\n\n    # --- Scan Rows Below Reference and Apply Transformation ---\n    # Iterate through each row 'r' strictly below the reference line's row 'row_r'\n    for r in range(row_r + 1, rows):\n        # Check if any pixel in the *input* grid's current row 'r' has the reference color 'color_c'\n        # Use numpy's any() for efficient checking across the row\n        trigger_found = np.any(input_grid[r] == color_c)\n\n        # If a trigger pixel was found in input row 'r'\n        if trigger_found:\n            # Fill the corresponding segment in the *output* grid's row 'r'\n            # The segment spans the same columns as the reference line [min_col, max_col]\n            # Ensure slice indices are within grid bounds, although they should be valid\n            # if the reference line was correctly found within bounds.\n            fill_start_col = max(0, min_col)\n            fill_end_col = min(cols, max_col + 1) # Slicing is exclusive at the end\n\n            # Modify the output grid segment with the reference color\n            output_grid[r, fill_start_col:fill_end_col] = color_c\n\n    # --- Return Result ---\n    # Convert the final numpy array back to a list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14144,
    "candidates_token_count": 1264,
    "total_token_count": 15408,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.225582,
  "retries": 1
}