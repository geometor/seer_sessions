{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms an 11x3 grid based on the following rules:\n1. Identify the primary non-white color (foreground_color) in the input grid.\n2. Find the index (header_row_index) of the first row (scanning top-to-bottom)\n   that contains more than one pixel of the foreground_color.\n   If no such row exists, the output is identical to the input.\n3. Initialize the output grid as a copy of the input grid.\n4. Iterate through the rows below the header_row_index (i.e., from\n   header_row_index + 1 to the last row).\n5. For each row in this range, if it contains exactly one pixel of the\n   foreground_color, change all three pixels in that row of the output grid\n   to the foreground_color.\n6. Rows at or above header_row_index, and rows below it that do not contain\n   exactly one foreground_color pixel, remain unchanged.\n7. Return the modified grid, flattened into a list.\n\"\"\"\n\ndef _get_foreground_color(grid):\n    \"\"\"\n    Finds the most frequent non-background (non-zero) color in the grid.\n\n    Args:\n        grid: A numpy array representing the grid.\n\n    Returns:\n        The integer value of the foreground color, or None if only background\n        color (0) is present.\n    \"\"\"\n    # Flatten the grid and filter out the background color (0)\n    non_background_pixels = grid.flatten()[grid.flatten() != 0]\n    \n    if non_background_pixels.size == 0:\n        return None # No foreground color found\n\n    # Count occurrences of each non-background color\n    counts = collections.Counter(non_background_pixels)\n    \n    # Return the most common non-background color\n    # Assumes there's a dominant foreground color as seen in examples\n    return counts.most_common(1)[0][0]\n\ndef _find_header_row_index(grid, foreground_color):\n    \"\"\"\n    Finds the index of the first row containing more than one\n    instance of the foreground_color.\n\n    Args:\n        grid: A numpy array representing the grid.\n        foreground_color: The integer value of the foreground color.\n\n    Returns:\n        The index of the header row, or -1 if no such row is found.\n    \"\"\"\n    height, _ = grid.shape\n    for r_idx in range(height):\n        row = grid[r_idx]\n        # Count how many pixels in the current row match the foreground color\n        count = np.count_nonzero(row == foreground_color)\n        if count > 1:\n            return r_idx # Found the first row with more than one foreground pixel\n    return -1 # Indicate no header row found\n\ndef transform(input_grid_flat):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid_flat: A flattened list representing the input grid.\n\n    Returns:\n        A flattened list representing the transformed output grid.\n    \"\"\"\n    # --- Grid Setup ---\n    # Determine grid dimensions (assuming 11x3 based on examples)\n    # ARC tasks have fixed dimensions per task, so this is usually safe.\n    height = 11\n    width = 3\n    \n    # Basic check for expected input size\n    if len(input_grid_flat) != height * width:\n        # Handle unexpected input size (e.g., raise error or try to infer)\n        # For now, we'll assume it's correct for 11x3 or fail on reshape\n        pass \n\n    # Reshape the flattened input list into a 2D numpy array\n    try:\n        input_grid = np.array(input_grid_flat).reshape((height, width))\n    except ValueError:\n        # Handle error if reshaping fails (e.g. wrong number of elements)\n        print(f\"Error: Input list length {len(input_grid_flat)} is not compatible with grid size {height}x{width}\")\n        return input_grid_flat # Or raise an exception\n\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # --- Identify Key Elements ---\n    # Find the primary non-white color\n    foreground_color = _get_foreground_color(input_grid)\n\n    # If no foreground color exists (e.g., all-white grid), return the input as is\n    if foreground_color is None:\n        return output_grid.flatten().tolist()\n\n    # Find the row index of the 'header' row\n    header_row_index = _find_header_row_index(input_grid, foreground_color)\n\n    # If no header row is found (no row has >1 foreground pixel), return the input as is\n    if header_row_index == -1:\n        return output_grid.flatten().tolist()\n\n    # --- Apply Transformation Logic ---\n    # Iterate through rows *below* the header row index\n    for r_idx in range(header_row_index + 1, height):\n        # Get the current row from the original input grid for analysis\n        row = input_grid[r_idx]\n        \n        # Count the number of foreground pixels in this input row\n        foreground_count = np.count_nonzero(row == foreground_color)\n\n        # Check the condition: is there exactly one foreground pixel in this row?\n        if foreground_count == 1:\n            # If yes, modify the corresponding row in the *output* grid\n            # Fill the entire row with the foreground color\n            output_grid[r_idx, :] = foreground_color\n        # else: If the count is not 1, the row in output_grid remains unchanged\n        #       (as it was initially copied from input_grid).\n\n    # --- Return Result ---\n    # Flatten the modified output grid back into a list\n    return output_grid.flatten().tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6723,
    "candidates_token_count": 1376,
    "total_token_count": 8099,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 55.496507,
  "retries": 1
}