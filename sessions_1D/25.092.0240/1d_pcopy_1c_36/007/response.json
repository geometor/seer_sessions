{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms an 11x3 grid based on the following rules:\n1. Identify the primary non-white color (foreground_color, C) in the input grid.\n2. Find the index (header_row_index, R) of the first row (scanning top-to-bottom)\n   that contains more than one pixel of the foreground_color.\n   If no such row exists, or if no foreground color exists, the output is identical\n   to the input.\n3. Initialize the output grid as a copy of the input grid.\n4. Iterate through the rows below the header_row_index (i.e., from R + 1 to the\n   last row).\n5. For each row 'i' in this range:\n   a. If the corresponding row in the *input* grid contains exactly one pixel\n      of the foreground_color C at column index 'j':\n      i. If j = 0 (left column), set output row 'i' to [C, C, 0].\n      ii. If j = 1 (middle column), set output row 'i' to [C, C, C].\n      iii. If j = 2 (right column), set output row 'i' to [0, C, C].\n   b. Otherwise (if the input row 'i' has 0, 2, or 3 foreground pixels),\n      the output row 'i' remains unchanged from the initial copy.\n6. Rows at or above header_row_index R also remain unchanged.\n7. Return the modified grid, flattened into a list.\n\"\"\"\n\ndef _get_foreground_color(grid):\n    \"\"\"\n    Finds the most frequent non-background (non-zero) color in the grid.\n\n    Args:\n        grid: A numpy array representing the grid.\n\n    Returns:\n        The integer value of the foreground color, or None if only background\n        color (0) is present.\n    \"\"\"\n    # Flatten the grid and filter out the background color (0)\n    non_background_pixels = grid.flatten()[grid.flatten() != 0]\n\n    if non_background_pixels.size == 0:\n        return None # No foreground color found\n\n    # Count occurrences of each non-background color\n    counts = collections.Counter(non_background_pixels)\n\n    # Return the most common non-background color\n    # Assumes there's a dominant foreground color as seen in examples\n    return counts.most_common(1)[0][0]\n\ndef _find_header_row_index(grid, foreground_color):\n    \"\"\"\n    Finds the index of the first row containing more than one\n    instance of the foreground_color.\n\n    Args:\n        grid: A numpy array representing the grid.\n        foreground_color: The integer value of the foreground color.\n\n    Returns:\n        The index of the header row, or -1 if no such row is found.\n    \"\"\"\n    height, _ = grid.shape\n    for r_idx in range(height):\n        row = grid[r_idx]\n        # Count how many pixels in the current row match the foreground color\n        count = np.count_nonzero(row == foreground_color)\n        if count > 1:\n            return r_idx # Found the first row with more than one foreground pixel\n    return -1 # Indicate no header row found\n\ndef _find_single_pixel_column(row, foreground_color):\n    \"\"\"\n    Finds the column index of the single foreground pixel in a row.\n    Assumes the row is known to contain exactly one foreground pixel.\n\n    Args:\n        row: A numpy array representing a single row of the grid.\n        foreground_color: The integer value of the foreground color.\n\n    Returns:\n        The column index (0, 1, or 2) where the foreground pixel is located,\n        or -1 if it's not found (should not happen if precondition is met).\n    \"\"\"\n    indices = np.where(row == foreground_color)[0]\n    if len(indices) == 1:\n        return indices[0]\n    return -1 # Should not be reached if called correctly\n\ndef transform(input_grid_flat):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid_flat: A flattened list representing the input grid.\n\n    Returns:\n        A flattened list representing the transformed output grid.\n    \"\"\"\n    # --- Grid Setup ---\n    # Define grid dimensions (fixed for this task)\n    height = 11\n    width = 3\n\n    # Validate input size and reshape\n    if len(input_grid_flat) != height * width:\n        # In a real scenario, might raise an error or try to infer dimensions\n        print(f\"Warning: Input list length {len(input_grid_flat)} does not match expected {height}x{width}. Attempting reshape.\")\n    try:\n        input_grid = np.array(input_grid_flat).reshape((height, width))\n    except ValueError:\n        print(f\"Error: Cannot reshape input list of length {len(input_grid_flat)} to {height}x{width}.\")\n        return input_grid_flat # Return original input on error\n\n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # --- Identify Key Elements ---\n    # Find the primary non-white color\n    foreground_color = _get_foreground_color(input_grid)\n\n    # If no foreground color exists, return the input as is\n    if foreground_color is None:\n        return output_grid.flatten().tolist()\n\n    # Find the row index of the 'header' row (first row with >1 foreground pixel)\n    header_row_index = _find_header_row_index(input_grid, foreground_color)\n\n    # If no header row is found, the grid remains unchanged.\n    if header_row_index == -1:\n        return output_grid.flatten().tolist()\n\n    # --- Apply Transformation Logic ---\n    # Iterate through rows *below* the header row index\n    for r_idx in range(header_row_index + 1, height):\n        # Get the current row from the *original input* grid for analysis\n        input_row = input_grid[r_idx]\n\n        # Count the number of foreground pixels in this input row\n        foreground_count = np.count_nonzero(input_row == foreground_color)\n\n        # Check the condition: is there exactly one foreground pixel in this input row?\n        if foreground_count == 1:\n            # Find the column of the single foreground pixel\n            col_idx = _find_single_pixel_column(input_row, foreground_color)\n\n            # Apply the transformation based on the column index\n            if col_idx == 0: # Pixel in left column\n                output_grid[r_idx, :] = [foreground_color, foreground_color, 0]\n            elif col_idx == 1: # Pixel in middle column\n                output_grid[r_idx, :] = [foreground_color, foreground_color, foreground_color]\n            elif col_idx == 2: # Pixel in right column\n                output_grid[r_idx, :] = [0, foreground_color, foreground_color]\n            # else: col_idx is -1 (error condition, row remains unchanged)\n\n        # else: If the count is not 1, the row in output_grid remains unchanged\n        #       (as it was initially copied from input_grid).\n\n    # --- Return Result ---\n    # Flatten the modified output grid back into a list\n    return output_grid.flatten().tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10070,
    "candidates_token_count": 1750,
    "total_token_count": 11820,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.554463,
  "retries": 1
}