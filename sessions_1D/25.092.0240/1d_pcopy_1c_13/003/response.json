{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport copy\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify the first contiguous horizontal sequence (block) of 2 or more identical non-white (not 0) pixels in the input row. This is the \"pattern\". Note its sequence of values, its color, and its length.\n2.  If no such pattern is found, the output is identical to the input.\n3.  Identify all \"target\" pixels in the input row. A target pixel is a single non-white pixel that:\n    a. Has the same color as the identified pattern.\n    b. Is \"isolated\", meaning the pixel immediately to its left is white (0) or it's the first pixel in the row, AND the pixel immediately to its right is white (0) or it's the last pixel in the row.\n4.  Create a copy of the input row to serve as the output row.\n5.  For each identified target pixel at index `i`:\n    a. Calculate the starting index for replacement in the output row: `start_index = i - floor(pattern_length / 2)`.\n    b. Overwrite the segment of the output row starting at `start_index` with the `pattern` sequence. Ensure writing stays within the row boundaries (0 to length-1). If the pattern extends beyond the boundaries, only the parts within the boundaries are written.\n6.  Return the modified output row, wrapped in a list to represent the grid format.\n\"\"\"\n\ndef find_first_pattern(grid_row):\n    \"\"\"\n    Finds the first contiguous sequence of 2 or more identical non-white pixels.\n\n    Args:\n        grid_row: A list of integers representing the input row.\n\n    Returns:\n        A tuple (pattern, pattern_color, pattern_length) where:\n        - pattern: A list of integers representing the pattern sequence.\n        - pattern_color: The integer color value of the pattern.\n        - pattern_length: The length of the pattern sequence.\n        Returns (None, -1, 0) if no such pattern is found.\n    \"\"\"\n    n = len(grid_row)\n    i = 0\n    while i < n:\n        current_color = grid_row[i]\n        # Look for start of a potential pattern (non-white)\n        if current_color != 0:\n            start_index = i\n            j = i + 1\n            # Find the end of the contiguous block of the same color\n            while j < n and grid_row[j] == current_color:\n                j += 1\n            \n            length = j - start_index\n            # Check if the block meets the pattern criteria (length >= 2)\n            if length >= 2:\n                pattern = grid_row[start_index:j]\n                return pattern, current_color, length\n            else:\n                # Block was too short, continue searching from the end of this block\n                i = j \n        else:\n            # Current pixel is white, move to the next\n            i += 1\n            \n    # No pattern found after checking the whole row\n    return None, -1, 0\n\ndef find_isolated_targets(grid_row, pattern_color):\n    \"\"\"\n    Finds indices of isolated single pixels matching the pattern_color.\n    Isolated means surrounded by white (0) or grid boundaries.\n\n    Args:\n        grid_row: A list of integers representing the input row.\n        pattern_color: The integer color value to match.\n\n    Returns:\n        A list of integer indices where isolated target pixels are found.\n    \"\"\"\n    n = len(grid_row)\n    target_indices = []\n    if pattern_color == -1: # No pattern means no targets\n        return []\n        \n    for i in range(n):\n        # Check if the current pixel matches the pattern color\n        if grid_row[i] == pattern_color:\n            # Check left neighbor (is it white or boundary?)\n            left_is_isolated = (i == 0) or (grid_row[i-1] == 0)\n            # Check right neighbor (is it white or boundary?)\n            right_is_isolated = (i == n-1) or (grid_row[i+1] == 0)\n            \n            # If isolated on both sides, it's a target\n            if left_is_isolated and right_is_isolated:\n                 target_indices.append(i)\n                 \n    return target_indices\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the pattern replacement transformation to the input grid.\n\n    Args:\n        input_grid: A list containing a single list of integers (the input row).\n                    Example: [[0, 0, 7, 7, 7, 0, ...]]\n\n    Returns:\n        A list containing a single list of integers (the transformed row).\n        Returns a copy of the input_grid if no pattern is found.\n    \"\"\"\n    # Ensure input is in the expected format and handle potential NumPy conversion\n    if not isinstance(input_grid, list) or len(input_grid) == 0 or not isinstance(input_grid[0], list):\n         # Or raise an error, or return input depending on desired robustness\n         return copy.deepcopy(input_grid) \n         \n    input_row = list(input_grid[0]) # Convert to list to avoid NumPy issues\n    output_row = list(input_row)    # Create a mutable copy for the output\n    n = len(input_row)\n\n    # 1. Find the pattern\n    pattern, pattern_color, pattern_length = find_first_pattern(input_row)\n\n    # 2. If no pattern found, return the original grid (as a copy)\n    if pattern is None:\n        # Return the structure expected [[row]]\n        return [output_row] \n\n    # 3. Find isolated targets matching the pattern color\n    target_indices = find_isolated_targets(input_row, pattern_color)\n    \n    # 4. Replace targets in the output grid copy\n    # Calculate the offset from the target index to the start of the pattern replacement\n    start_offset = math.floor(pattern_length / 2)\n\n    for i in target_indices:\n        # Calculate where the pattern should start writing in the output row\n        start_replace_index = i - start_offset\n        \n        # Iterate through the pattern and write it into the output row\n        for k in range(pattern_length):\n            current_write_index = start_replace_index + k\n            # Check if the write index is within the bounds of the output row\n            if 0 <= current_write_index < n:\n                output_row[current_write_index] = pattern[k]\n\n    # 5. Return the modified row wrapped in a list\n    return [output_row]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6965,
    "candidates_token_count": 1563,
    "total_token_count": 8528,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.894062,
  "retries": 1
}