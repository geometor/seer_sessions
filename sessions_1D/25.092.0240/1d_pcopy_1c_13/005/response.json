{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport copy\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  Identify the first contiguous horizontal sequence (block) of 2 or more identical non-white (not 0) pixels in the input row. This is the \"pattern\". Note its sequence of values, its color, and its length.\n2.  If no such pattern is found, the output is identical to the input.\n3.  Identify all \"target\" pixels in the input row. A target pixel is a single non-white pixel that:\n    a. Has the same color as the identified pattern.\n    b. Is \"isolated\", meaning the pixel immediately to its left is white (0) or it's the first pixel in the row, AND the pixel immediately to its right is white (0) or it's the last pixel in the row.\n4.  Create a copy of the input row to serve as the output row.\n5.  For each identified target pixel at index `i`:\n    a. Calculate the starting index for replacement in the output row: `start_index = i - floor(pattern_length / 2)`.\n    b. Overwrite the segment of the output row starting at `start_index` with the `pattern` sequence. Ensure writing stays within the row boundaries (0 to length-1). If the pattern extends beyond the boundaries, only the parts within the boundaries are written.\n6.  Return the modified output row, wrapped in a list to represent the grid format.\n\"\"\"\n\ndef find_first_pattern(grid_row):\n    \"\"\"\n    Finds the first contiguous sequence of 2 or more identical non-white pixels.\n\n    Args:\n        grid_row: A list of integers representing the input row.\n\n    Returns:\n        A tuple (pattern, pattern_color, pattern_length) where:\n        - pattern: A list of integers representing the pattern sequence.\n        - pattern_color: The integer color value of the pattern.\n        - pattern_length: The length of the pattern sequence.\n        Returns (None, -1, 0) if no such pattern is found.\n    \"\"\"\n    n = len(grid_row)\n    i = 0\n    while i < n:\n        current_color = grid_row[i]\n        # Look for start of a potential pattern (non-white)\n        if current_color != 0:\n            start_index = i\n            j = i + 1\n            # Find the end of the contiguous block of the same color\n            while j < n and grid_row[j] == current_color:\n                j += 1\n            \n            length = j - start_index\n            # Check if the block meets the pattern criteria (length >= 2)\n            if length >= 2:\n                pattern = grid_row[start_index:j]\n                return pattern, current_color, length\n            else:\n                # Block was too short, continue searching from the end of this block\n                i = j \n        else:\n            # Current pixel is white, move to the next\n            i += 1\n            \n    # No pattern found after checking the whole row\n    return None, -1, 0\n\ndef find_isolated_targets(grid_row, pattern_color):\n    \"\"\"\n    Finds indices of isolated single pixels matching the pattern_color.\n    Isolated means surrounded by white (0) or grid boundaries.\n\n    Args:\n        grid_row: A list of integers representing the input row.\n        pattern_color: The integer color value to match.\n\n    Returns:\n        A list of integer indices where isolated target pixels are found.\n    \"\"\"\n    n = len(grid_row)\n    target_indices = []\n    # Cannot find targets if there's no valid pattern color\n    if pattern_color <= 0: \n        return []\n        \n    for i in range(n):\n        # Check if the current pixel matches the pattern color\n        if grid_row[i] == pattern_color:\n            # Check left neighbor (is it white or boundary?)\n            left_is_isolated = (i == 0) or (grid_row[i-1] == 0)\n            # Check right neighbor (is it white or boundary?)\n            right_is_isolated = (i == n-1) or (grid_row[i+1] == 0)\n            \n            # If isolated on both sides, it's a target\n            if left_is_isolated and right_is_isolated:\n                 target_indices.append(i)\n                 \n    return target_indices\n\n\ndef transform(input_grid):\n    # Ensure input is in the expected format [[row]]\n    if not isinstance(input_grid, list) or len(input_grid) == 0 or not isinstance(input_grid[0], list):\n         # Return input unchanged if format is wrong\n         return copy.deepcopy(input_grid) \n         \n    # Extract the single row (convert to list for safety)\n    input_row = list(input_grid[0])\n    \n    # Create a mutable copy for the output\n    output_row = list(input_row)    \n    n = len(input_row)\n\n    # Step 1 & 2: Find the first pattern (sequence of 2+ identical non-white pixels)\n    pattern, pattern_color, pattern_length = find_first_pattern(input_row)\n\n    # Step 3: If no pattern is found, return the original grid (copy)\n    if pattern is None:\n        return [output_row] # Return in the expected [[row]] format\n\n    # Step 4: Find isolated target pixels matching the pattern color\n    target_indices = find_isolated_targets(input_row, pattern_color)\n    \n    # Step 5: If no targets found, return the grid copy\n    if not target_indices:\n         return [output_row]\n\n    # Step 6: Replace targets in the output grid copy\n    # Calculate the offset from the target index to the start of the pattern replacement\n    start_offset = math.floor(pattern_length / 2)\n\n    for i in target_indices:\n        # Calculate where the pattern should start writing in the output row\n        start_replace_index = i - start_offset\n        \n        # Iterate through the pattern and write it into the output row\n        for k in range(pattern_length):\n            current_write_index = start_replace_index + k\n            # Check if the write index is within the bounds of the output row\n            if 0 <= current_write_index < n:\n                output_row[current_write_index] = pattern[k]\n\n    # Step 7: Return the modified row wrapped in a list\n    return [output_row]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9254,
    "candidates_token_count": 1525,
    "total_token_count": 10779,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.762661,
  "retries": 1
}