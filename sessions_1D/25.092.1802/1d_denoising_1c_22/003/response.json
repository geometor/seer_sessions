{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Optional, Tuple, Union\n\n\"\"\"\nIdentify the single longest contiguous horizontal segment of the non-background \ncolor within the flattened representation of the input grid. The output grid \nhas the same dimensions as the input, but contains only this longest segment, \nplaced according to its position in the flattened sequence, with all other cells \nset to the background color (0).\n\"\"\"\n\ndef find_contiguous_blocks(arr: np.ndarray, color: int) -> List[Dict[str, int]]:\n    \"\"\"\n    Finds all contiguous blocks of a specified color in a 1D array.\n\n    Args:\n        arr: The 1D numpy array to search within.\n        color: The color value to search for.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block \n        and contains 'start', 'end', and 'length' keys.\n    \"\"\"\n    blocks = []\n    start_index = -1\n    n = len(arr)\n    for i, pixel in enumerate(arr):\n        if pixel == color and start_index == -1:\n            # Start of a new block\n            start_index = i\n        elif pixel != color and start_index != -1:\n            # End of the current block\n            end_index = i - 1\n            length = end_index - start_index + 1\n            blocks.append({\"start\": start_index, \"end\": end_index, \"length\": length})\n            start_index = -1 # Reset for the next block\n\n    # Check if the array ends with a block\n    if start_index != -1:\n        end_index = n - 1\n        length = end_index - start_index + 1\n        blocks.append({\"start\": start_index, \"end\": end_index, \"length\": length})\n\n    return blocks\n\ndef find_largest_block(blocks: List[Dict[str, int]]) -> Optional[Dict[str, int]]:\n    \"\"\"\n    Finds the block with the maximum length from a list of blocks.\n    If there's a tie, returns the first one encountered.\n\n    Args:\n        blocks: A list of block dictionaries.\n\n    Returns:\n        The dictionary representing the largest block, or None if the list is empty.\n    \"\"\"\n    if not blocks:\n        return None\n    \n    largest = blocks[0]\n    # Start checking from the second block\n    for block in blocks[1:]:\n        # Only update if the current block is strictly larger\n        # This implicitly handles ties by keeping the first largest found\n        if block[\"length\"] > largest[\"length\"]:\n            largest = block\n            \n    return largest\n\ndef get_colors(arr: np.ndarray) -> Tuple[int, Optional[int]]:\n    \"\"\"\n    Identifies the background (0) and primary (non-zero) colors in a 1D array.\n    Assumes only one non-zero color exists.\n\n    Args:\n        arr: The 1D numpy array.\n\n    Returns:\n        A tuple containing the background color (always 0) and the primary color \n        (or None if only background color is present).\n    \"\"\"\n    background_color = 0\n    primary_color = None\n    unique_colors = np.unique(arr)\n    for color in unique_colors:\n        if color != background_color:\n            primary_color = int(color) # Ensure it's a standard python int\n            break # Assume only one non-background color\n    return background_color, primary_color\n\n\ndef transform(input_grid: Union[List[List[int]], np.ndarray]) -> Union[List[List[int]], np.ndarray]:\n    \"\"\"\n    Transforms the input grid by isolating the longest contiguous segment \n    of the primary color found in the flattened version of the grid.\n\n    Args:\n        input_grid: A 2D list or numpy array representing the input grid.\n\n    Returns:\n        A 2D numpy array representing the transformed grid.\n    \"\"\"\n    # Ensure input is a numpy array\n    input_array = np.array(input_grid, dtype=int)\n    \n    # 1. Record the original dimensions\n    original_shape = input_array.shape\n    \n    # 2. Flatten the 2D input grid into a 1D array\n    flat_array = input_array.flatten()\n    flat_size = flat_array.size\n\n    # 4. Identify the background and primary colors\n    background_color, primary_color = get_colors(flat_array)\n\n    # Handle case where input is all background color\n    if primary_color is None:\n        # 3. Initialize output with background color and return if no primary color\n        return np.full(original_shape, background_color, dtype=int)\n\n    # 5. Find all contiguous segments of the primary color in the flattened array\n    blocks = find_contiguous_blocks(flat_array, primary_color)\n\n    # 6. Find the longest segment (block)\n    largest_block = find_largest_block(blocks)\n\n    # 3. Initialize a 1D output array with the background color\n    output_flat = np.full(flat_size, background_color, dtype=int)\n\n    # 7. If a largest segment was found, place it in the 1D output array\n    if largest_block:\n        start = largest_block[\"start\"]\n        end = largest_block[\"end\"]\n        output_flat[start : end + 1] = primary_color\n\n    # 8. Reshape the 1D output array back into the original dimensions\n    output_grid = output_flat.reshape(original_shape)\n\n    # 9. Return the resulting 2D output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7218,
    "candidates_token_count": 1321,
    "total_token_count": 8539,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.801319,
  "retries": 1
}