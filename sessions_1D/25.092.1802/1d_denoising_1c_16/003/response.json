{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentify the largest contiguous block of solid, non-white rows in the input grid. \nA solid row consists entirely of a single color that is not white (0).\nA block is a vertically contiguous sequence of solid rows that all share the same non-white color.\nThe largest block is defined as the one with the greatest height (number of rows). If there is a tie in height, \nthe block appearing earliest in the grid (lowest starting row index) is chosen.\nPreserve only this largest block in the output grid, setting all other pixels to white (0).\nIf no solid rows or blocks are found, the output grid is entirely white.\n\"\"\"\n\n# Define type aliases for clarity\nGrid = List[List[int]]\nSolidRowInfo = Tuple[int, int]  # (row_index, color)\nBlockInfo = Tuple[int, int, int, int] # (start_row, end_row, color, height)\n\ndef _find_solid_rows(input_array: np.ndarray) -> List[SolidRowInfo]:\n    \"\"\"\n    Identifies rows composed of a single non-white color.\n\n    Args:\n        input_array: The input grid as a NumPy array.\n\n    Returns:\n        A list of tuples, where each tuple contains the row index and the color \n        of a solid non-white row. Returns an empty list if none are found.\n    \"\"\"\n    solid_rows: List[SolidRowInfo] = []\n    height, _ = input_array.shape\n    for r in range(height):\n        row = input_array[r, :]\n        unique_colors = np.unique(row)\n        # Check if the row has exactly one unique color and it's not white (0)\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            solid_rows.append((r, int(unique_colors[0]))) # Store row index and color\n    return solid_rows\n\ndef _group_solid_rows_into_blocks(solid_rows: List[SolidRowInfo]) -> List[BlockInfo]:\n    \"\"\"\n    Groups adjacent solid rows of the same color into blocks.\n\n    Args:\n        solid_rows: A list of tuples (row_index, color) representing solid rows,\n                    assumed to be sorted by row_index implicitly by find_solid_rows.\n\n    Returns:\n        A list of tuples, where each tuple represents a block:\n        (start_row, end_row, color, height). Returns an empty list if no blocks\n        can be formed.\n    \"\"\"\n    if not solid_rows:\n        return []\n\n    blocks: List[BlockInfo] = []\n    current_block_start_index = 0\n    while current_block_start_index < len(solid_rows):\n        start_row, color = solid_rows[current_block_start_index]\n        current_height = 1\n        \n        # Look ahead to find contiguous rows of the same color\n        next_row_in_block_idx = current_block_start_index + 1\n        while (next_row_in_block_idx < len(solid_rows) and\n               solid_rows[next_row_in_block_idx][0] == start_row + current_height and # Check vertical contiguity\n               solid_rows[next_row_in_block_idx][1] == color): # Check for the same color\n            current_height += 1\n            next_row_in_block_idx += 1\n            \n        end_row = start_row + current_height - 1\n        blocks.append((start_row, end_row, color, current_height))\n        \n        # Move to the start of the next potential block\n        # next_row_in_block_idx now points to the first row *not* in the current block\n        current_block_start_index = next_row_in_block_idx\n        \n    return blocks\n\ndef _find_largest_block(blocks: List[BlockInfo]) -> Optional[BlockInfo]:\n    \"\"\"\n    Selects the largest block based on height from a list of blocks.\n    Ties are broken by choosing the block that appears first (lowest start_row).\n\n    Args:\n        blocks: A list of block information tuples (start_row, end_row, color, height).\n\n    Returns:\n        The tuple representing the largest block, or None if the input list is empty.\n    \"\"\"\n    if not blocks:\n        return None\n        \n    # Find the block with the maximum height.\n    # max() with a key naturally handles ties by returning the first element \n    # encountered that matches the maximum key value. Since blocks are generated\n    # in top-to-bottom order, this correctly selects the highest block in case of ties.\n    largest_block = max(blocks, key=lambda item: item[3]) # item[3] is height\n    \n    return largest_block\n\ndef transform(input_grid: Grid) -> Grid:\n    \"\"\"\n    Transforms the input grid by finding the largest contiguous block of solid, \n    non-white rows and preserving only that block, making everything else white.\n\n    Args:\n        input_grid: The input grid as a list of lists of integers.\n\n    Returns:\n        The transformed grid as a list of lists of integers.\n    \"\"\"\n    # Convert input to NumPy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    \n    # Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_array)\n\n    # Step 1: Find all solid, non-white rows\n    solid_rows = _find_solid_rows(input_array)\n\n    # If no solid rows, return the all-white grid\n    if not solid_rows:\n        return output_grid.tolist()\n\n    # Step 2: Group solid rows into contiguous blocks of the same color\n    blocks = _group_solid_rows_into_blocks(solid_rows)\n\n    # If no blocks could be formed, return the all-white grid\n    if not blocks:\n         return output_grid.tolist()\n\n    # Step 3: Select the largest block (by height)\n    largest_block = _find_largest_block(blocks)\n\n    # Step 4: If a largest block was found, copy it to the output grid\n    if largest_block:\n        start_r, end_r, _, _ = largest_block\n        # Copy the slice corresponding to the largest block from input to output\n        output_grid[start_r : end_r + 1, :] = input_array[start_r : end_r + 1, :]\n\n    # Convert the final NumPy array back to a list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8592,
    "candidates_token_count": 1578,
    "total_token_count": 10170,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.865734,
  "retries": 1
}