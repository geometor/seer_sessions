{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\n\"\"\"\nIdentify the largest contiguous vertical block of solid, identically colored, non-white rows in the input grid. \nA solid row consists entirely of a single color that is not white (0).\nA block is a vertically contiguous sequence of solid rows that all share the same non-white color.\nThe largest block is defined as the one with the greatest height (number of rows). If there is a tie in height, \nthe block appearing earliest in the grid (lowest starting row index) is chosen.\nPreserve only this largest block in the output grid, setting all other pixels to white (0).\nIf no solid rows or blocks are found, the output grid is entirely white.\n\"\"\"\n\n# Define type aliases for clarity\nGrid = List[List[int]]\nSolidRowInfo = Tuple[int, int]  # (row_index, color)\nBlockInfo = Tuple[int, int, int, int] # (start_row, end_row, color, height)\n\ndef _find_solid_rows(input_array: np.ndarray) -> List[SolidRowInfo]:\n    \"\"\"\n    Identifies rows composed of a single non-white color.\n    \"\"\"\n    solid_rows: List[SolidRowInfo] = []\n    height, _ = input_array.shape\n    for r in range(height):\n        row = input_array[r, :]\n        unique_colors = np.unique(row)\n        # Check if the row has exactly one unique color and it's not white (0)\n        if len(unique_colors) == 1 and unique_colors[0] != 0:\n            solid_rows.append((r, int(unique_colors[0]))) # Store row index and color\n    return solid_rows\n\ndef _group_solid_rows_into_blocks(solid_rows: List[SolidRowInfo]) -> List[BlockInfo]:\n    \"\"\"\n    Groups adjacent solid rows of the same color into blocks.\n    \"\"\"\n    if not solid_rows:\n        return []\n\n    blocks: List[BlockInfo] = []\n    current_block_start_index = 0\n    while current_block_start_index < len(solid_rows):\n        start_row, color = solid_rows[current_block_start_index]\n        current_height = 1\n        \n        # Look ahead to find contiguous rows of the same color\n        next_row_in_block_idx = current_block_start_index + 1\n        while (next_row_in_block_idx < len(solid_rows) and\n               solid_rows[next_row_in_block_idx][0] == start_row + current_height and # Check vertical contiguity\n               solid_rows[next_row_in_block_idx][1] == color): # Check for the same color\n            current_height += 1\n            next_row_in_block_idx += 1\n            \n        end_row = start_row + current_height - 1\n        blocks.append((start_row, end_row, color, current_height))\n        \n        # Move to the start of the next potential block\n        current_block_start_index = next_row_in_block_idx\n        \n    return blocks\n\ndef _find_largest_block(blocks: List[BlockInfo]) -> Optional[BlockInfo]:\n    \"\"\"\n    Selects the largest block based on height, breaking ties by start row index.\n    \"\"\"\n    if not blocks:\n        return None\n        \n    # Find the block with the maximum height.\n    # max() with a key naturally handles ties by returning the first element \n    # encountered that matches the maximum key value. Since blocks are generated\n    # in top-to-bottom order, this correctly selects the block with the lowest \n    # start_row index in case of ties in height.\n    largest_block = max(blocks, key=lambda item: item[3]) # item[3] is height\n    \n    return largest_block\n\ndef transform(input_grid: Grid) -> Grid:\n    \"\"\"\n    Transforms the input grid based on the described rules.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing.\n    # Includes basic validation for 2D structure.\n    try:\n        input_array = np.array(input_grid, dtype=int)\n        if input_array.ndim != 2:\n             # Handle non-2D input, returning an empty grid or similar default\n             if isinstance(input_grid, list) and all(isinstance(row, list) for row in input_grid):\n                 h = len(input_grid)\n                 w = len(input_grid[0]) if h > 0 and isinstance(input_grid[0], list) else 0\n                 return np.zeros((h, w), dtype=int).tolist()\n             else: # Unclear structure, return empty list\n                 return []\n        # Handle case of empty input grid (0 rows or 0 columns)\n        if input_array.size == 0:\n            return [] # Return empty list for empty grid\n    except (ValueError, TypeError): # Catches issues like jagged lists or non-numeric data\n        # Return empty list or handle error appropriately\n        return []\n        \n    height, width = input_array.shape\n    \n    # Initialize an output grid of the same dimensions, filled with white (0).\n    output_grid = np.zeros_like(input_array)\n\n    # Step 1: Find all rows that consist of a single non-white color.\n    solid_rows = _find_solid_rows(input_array)\n\n    # If no solid rows are found, return the all-white output grid.\n    if not solid_rows:\n        return output_grid.tolist()\n\n    # Step 2: Group these solid rows into contiguous vertical blocks of the same color.\n    blocks = _group_solid_rows_into_blocks(solid_rows)\n\n    # If no blocks could be formed, return the all-white output grid.\n    if not blocks:\n         return output_grid.tolist()\n\n    # Step 3: Identify the largest block based on height (number of rows), with tie-breaking.\n    largest_block = _find_largest_block(blocks)\n\n    # Step 4: If a largest block was successfully identified, copy it from the\n    # input array to the corresponding location in the otherwise white output grid.\n    if largest_block:\n        start_r, end_r, _, _ = largest_block\n        # Copy the slice corresponding to the largest block from input to output\n        output_grid[start_r : end_r + 1, :] = input_array[start_r : end_r + 1, :]\n\n    # Convert the final NumPy array back to a standard list of lists format and return.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11187,
    "candidates_token_count": 1571,
    "total_token_count": 12758,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.426999,
  "retries": 1
}