{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify the longest contiguous horizontal sequence (block) of non-white pixels within the input row. Construct an output row of the same dimensions where only the pixels corresponding to this longest block retain their original color and position, and all other pixels are set to white (0). If multiple blocks share the maximum length, the first (leftmost) one encountered is selected.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Dict, Union, Optional\n\ndef find_non_white_blocks(row: np.ndarray) -> List[Dict[str, int]]:\n    \"\"\"\n    Finds all contiguous blocks of non-white pixels in a 1D numpy array row.\n\n    Args:\n        row: A 1D numpy array representing a row of pixels.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        and contains 'start', 'end', and 'length' keys.\n        'end' is the index of the last pixel *in* the block. Returns empty list if no blocks found.\n    \"\"\"\n    blocks = []\n    current_block_start = -1\n    row_len = len(row)\n    \n    for i, pixel in enumerate(row):\n        is_non_white = (pixel != 0) # Comparison works directly on numpy elements\n\n        if is_non_white:\n            # Start of a new block or continuation of an existing one\n            if current_block_start == -1:\n                current_block_start = i\n        elif current_block_start != -1:\n            # End of the current block (encountered a white pixel or end of row)\n            block_length = i - current_block_start\n            blocks.append({\n                'start': current_block_start,\n                'end': i - 1, # End index is inclusive\n                'length': block_length\n            })\n            current_block_start = -1 # Reset for the next block\n\n    # Check if the row ends with a non-white block\n    if current_block_start != -1:\n        block_length = row_len - current_block_start\n        blocks.append({\n            'start': current_block_start,\n            'end': row_len - 1, # End index is inclusive\n            'length': block_length\n        })\n\n    return blocks\n\ndef transform(input_grid: Union[List[List[int]], np.ndarray]) -> Union[List[List[int]], np.ndarray]:\n    \"\"\"\n    Transforms the input grid according to the specified rule.\n\n    Args:\n        input_grid: A 2D list or numpy array representing the input grid. \n                      Expected to contain a single row based on examples.\n\n    Returns:\n        A 2D list or numpy array representing the transformed grid.\n    \"\"\"\n    # Convert input to numpy array for consistent handling\n    input_np = np.array(input_grid, dtype=int)\n\n    # Handle empty input or unexpected dimensions\n    if input_np.size == 0:\n        return input_np.tolist() # Return empty structure matching input type if possible\n    if input_np.ndim != 2 or input_np.shape[0] != 1:\n        # Based on examples, we expect a single row (shape 1xN)\n        # If not, return input unchanged or raise error, depending on desired strictness.\n        # For now, return input as it might be a future variation.\n         # print(f\"Warning: Expected input shape (1, N), got {input_np.shape}. Returning original.\")\n         # return input_grid # Return original format\n         # Let's assume the task implies 1D and proceed, erroring if structure is wrong\n         if input_np.ndim == 1: # If input was just [a,b,c], reshape it\n             input_np = input_np.reshape(1, -1)\n         else: # If more than 1 row, it's unexpected based on training\n              raise ValueError(f\"Input grid must have exactly one row. Shape: {input_np.shape}\")\n\n\n    input_row = input_np[0] # Extract the single row\n    height, width = input_np.shape\n\n    # 1. Initialize output grid with white pixels (0)\n    output_row = np.zeros(width, dtype=int)\n\n    # 2. Scan and Identify blocks in the input row\n    blocks = find_non_white_blocks(input_row)\n\n    # If no non-white blocks found, the output is already correct (all zeros)\n    if not blocks:\n        # Return the all-white row, wrapped in a list/array structure\n        return output_row.reshape(height, width).tolist() if isinstance(input_grid, list) else output_row.reshape(height, width)\n\n\n    # 3. Find Maximum Length\n    max_length = 0\n    for block in blocks:\n        if block['length'] > max_length:\n            max_length = block['length']\n            \n    # 4. Select the Longest Block (first one if tied)\n    longest_block = None\n    for block in blocks:\n        if block['length'] == max_length:\n            longest_block = block\n            break # Stop searching once the first longest block is found\n\n    # 5. Copy Block to output row\n    if longest_block: # Should always be true if blocks were found\n        start = longest_block['start']\n        end = longest_block['end'] # Inclusive index\n        # Copy the segment from input_row to output_row\n        output_row[start : end + 1] = input_row[start : end + 1]\n\n    # 6. Finalize and return\n    # Reshape the 1D output_row back into the 2D structure (1xN)\n    output_grid_np = output_row.reshape(height, width)\n\n    # Return in the same format as the input (list of lists or numpy array)\n    return output_grid_np.tolist() if isinstance(input_grid, list) else output_grid_np\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8124,
    "candidates_token_count": 1389,
    "total_token_count": 9513,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.405763,
  "retries": 1
}