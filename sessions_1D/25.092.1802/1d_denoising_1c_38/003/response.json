{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a single-row input grid by identifying the longest contiguous block \nof the foreground color (the single non-zero color present). The output grid \nis the same length as the input, containing only this longest block in its \noriginal position. All other pixels in the output are set to the background \ncolor (white, 0). If no foreground color exists in the input, the output \nis entirely the background color.\n\"\"\"\n\nimport numpy as np # Import numpy as the input might be a numpy array\n\n# ================================================\n# Helper Functions\n# ================================================\n\ndef _get_row_list(input_grid):\n    \"\"\"\n    Extracts the first row from the input grid and returns it as a list.\n    Handles potential numpy array input and basic validation.\n\n    Args:\n        input_grid: The input grid (potentially list of lists or numpy array).\n\n    Returns:\n        list: The first row as a list of integers.\n        None: If the input format is invalid or empty.\n    \"\"\"\n    if input_grid is None:\n        return None\n        \n    # Handle numpy array input\n    if isinstance(input_grid, np.ndarray):\n        if input_grid.ndim == 2 and input_grid.shape[0] >= 1:\n             # Convert the first row to a list\n            return input_grid[0].tolist()\n        else:\n            # Invalid numpy array shape\n            return None \n            \n    # Handle list of lists input\n    if isinstance(input_grid, list) and len(input_grid) >= 1 and isinstance(input_grid[0], list):\n         # Return the first row (which is already a list)\n        return input_grid[0]\n        \n    # Invalid list format\n    return None\n\ndef _find_foreground_color(row):\n    \"\"\"\n    Finds the first non-zero color in the row list.\n    Assumes 0 is the background color.\n\n    Args:\n        row (list): A list of integers representing a row of pixels.\n\n    Returns:\n        int or None: The first non-zero color found, or None if only \n                     background color (0) exists or row is empty/None.\n    \"\"\"\n    if not row: # Check if row is empty or None\n        return None\n        \n    for pixel in row:\n        # Check if the pixel value is non-zero\n        if pixel != 0:\n            return pixel # Return the first non-zero color found\n            \n    # If loop completes without finding a non-zero color\n    return None \n\ndef _find_longest_block(row, foreground_color):\n    \"\"\"\n    Finds the start index and length of the longest contiguous block \n    of the specified foreground_color in the row list.\n\n    Args:\n        row (list): A list of integers representing a row of pixels.\n        foreground_color (int): The color value to search for blocks of.\n                                Can be None if no foreground color exists.\n\n    Returns:\n        tuple (int, int): A tuple containing:\n            - The start index of the longest block found (-1 if no block found).\n            - The length of the longest block found (0 if no block found).\n    \"\"\"\n    # Handle cases where row is empty/None or no foreground color is specified\n    if not row or foreground_color is None:\n        return -1, 0 \n\n    n = len(row)\n    max_len = 0\n    longest_block_start = -1 # Start index of the longest block found so far\n    current_start = -1      # Start index of the current block being tracked\n    current_len = 0         # Length of the current block being tracked\n\n    for i in range(n):\n        # Check if the current pixel matches the foreground color\n        if row[i] == foreground_color:\n            # If this is the start of a new block\n            if current_len == 0:  \n                current_start = i # Record the start index\n            # Increment the length of the current block\n            current_len += 1\n        else:  \n            # Pixel does not match foreground color: current block (if any) ends\n            \n            # Check if the block just ended was the longest found so far\n            if current_len > 0:  # Only check if we were actually tracking a block\n                if current_len > max_len:\n                    max_len = current_len\n                    longest_block_start = current_start\n            \n            # Reset current block tracking since the block ended\n            current_len = 0  \n            current_start = -1 # Reset start index too\n\n    # After the loop, check if the sequence ending at the last pixel was a block \n    # and potentially the longest one (handles blocks ending at the row's end)\n    if current_len > max_len:\n        max_len = current_len\n        longest_block_start = current_start\n\n    # Return the start index and length of the overall longest block\n    return longest_block_start, max_len\n\n\n# ================================================\n# Main Transformation Function\n# ================================================\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A grid represented possibly as a list of lists or numpy array, \n                    expected to contain a single row.\n\n    Returns:\n        list of lists: A new grid containing the transformed single row `[[...]]`.\n                       Returns an empty list `[]` if the input is invalid.\n    \"\"\"\n    \n    # --- 1. Process Input & Validate ---\n    # Extract the first row as a list, handling potential format issues\n    input_row = _get_row_list(input_grid)\n    \n    # If input is invalid or empty, return an empty list\n    if input_row is None:\n        # Or consider raising an error, depending on desired behavior for invalid input\n        return [] \n        \n    n = len(input_row) # Get the length of the row\n\n    # --- 2. Identify Foreground Color ---\n    # Find the non-zero color used in the input row\n    foreground_color = _find_foreground_color(input_row)\n\n    # --- 3. Handle All-Background Case ---\n    # If no foreground color was found (row is all background or empty)\n    if foreground_color is None:\n        # Return a new grid of the same size filled with background color (0)\n        # Wrapped in a list to maintain the grid structure [[...]]\n        return [[0] * n] \n\n    # --- 4. Find the Longest Block ---\n    # Locate the starting position and length of the longest continuous block \n    # of the identified foreground color.\n    start_index, length = _find_longest_block(input_row, foreground_color)\n\n    # --- 5. Create Output Row ---\n    # Initialize a new output row list of the same length as the input,\n    # filled entirely with the background color (0).\n    output_row = [0] * n\n\n    # --- 6. Copy Target Block ---\n    # If a longest block was actually found (i.e., start_index is valid and length > 0)\n    if start_index != -1 and length > 0:\n        # Iterate through the indices belonging to the longest block\n        for i in range(length):\n            # Calculate the index in the output row\n            output_index = start_index + i\n            # Copy the foreground color into the output row at this index\n            # Basic bounds check (shouldn't be needed due to find_longest_block logic, but safe)\n            if 0 <= output_index < n: \n                output_row[output_index] = foreground_color\n\n    # --- 7. Format and Return Output ---\n    # Return the transformed row, wrapped in a list to match the required grid format [[...]]\n    return [output_row]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8949,
    "candidates_token_count": 1813,
    "total_token_count": 10762,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.522798,
  "retries": 1
}