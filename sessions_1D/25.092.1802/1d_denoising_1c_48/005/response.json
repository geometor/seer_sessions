{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the single foreground color (C) in the input grid.\nFind all distinct connected objects composed of this foreground color C, using cardinal (4-way) adjacency.\nDetermine the row index ('max_row_idx') that contains the highest count of color C. If multiple rows share the highest count, select the topmost row (smallest index).\nIdentify the specific object(s) that have at least one pixel located within 'max_row_idx'.\nCreate an output grid of the same dimensions as the input, filled entirely with the background color (0).\nCopy only the pixels belonging to the identified target object(s) from the input grid to the corresponding positions in the output grid.\n\"\"\"\n\ndef find_foreground_color(grid):\n    \"\"\"\n    Finds the first non-zero (non-background) color encountered in the grid.\n    Assumes there is at most one non-background color per grid based on examples.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        int: The foreground color value, or 0 if only background is present.\n    \"\"\"\n    for pixel in grid.flat:\n        if pixel != 0:\n            return pixel\n    return 0 # Return background color (0) if no foreground color is found\n\ndef find_max_row(grid, foreground_color):\n    \"\"\"\n    Finds the index of the row containing the maximum number of foreground_color pixels.\n    Ties are broken by choosing the lowest row index (topmost).\n\n    Args:\n        grid (np.array): The input grid.\n        foreground_color (int): The color to count.\n\n    Returns:\n        int: The index of the row with the maximum count, or -1 if the color is not found.\n    \"\"\"\n    max_count = -1\n    max_row_idx = -1\n    height = grid.shape[0]\n\n    if foreground_color == 0: # Cannot find max row for background color meaningfully in this context\n        return -1\n\n    for r in range(height):\n        current_count = np.count_nonzero(grid[r, :] == foreground_color)\n        if current_count > max_count:\n            max_count = current_count\n            max_row_idx = r\n            \n    # If max_count is still 0 after checking all rows, the color wasn't present\n    if max_count == 0:\n      return -1\n      \n    return max_row_idx\n\ndef find_connected_components(grid, foreground_color):\n    \"\"\"\n    Finds all connected components (objects) of a given foreground color using BFS.\n    Connectivity is 4-directional (cardinal).\n\n    Args:\n        grid (np.array): The input grid.\n        foreground_color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of pixels in a connected component.\n                   Returns an empty list if foreground_color is 0 or not found.\n    \"\"\"\n    if foreground_color == 0:\n        return []\n        \n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == foreground_color and not visited[r, c]:\n                # Start BFS for a new object\n                current_object_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds and if it's a valid, unvisited pixel of the object\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == foreground_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append(current_object_coords)\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on selecting the object(s) connected\n    to the row with the most foreground pixels.\n    \"\"\"\n    # Convert input to numpy array\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle empty input grid case\n    if input_array.size == 0:\n        return []\n        \n    height, width = input_array.shape\n\n    # Initialize output grid with background color (0)\n    output_array = np.zeros_like(input_array)\n\n    # Find the foreground color\n    foreground_color = find_foreground_color(input_array)\n\n    # If no foreground color, return the background grid\n    if foreground_color == 0:\n        return output_array.tolist()\n\n    # Find the row with the maximum count of the foreground color\n    max_row_idx = find_max_row(input_array, foreground_color)\n\n    # If the foreground color wasn't actually found (e.g., max count was 0), return background\n    if max_row_idx == -1:\n         return output_array.tolist()\n\n    # Find all connected components (objects) of the foreground color\n    all_objects = find_connected_components(input_array, foreground_color)\n\n    # Identify target objects: those intersecting the max_row_idx\n    target_objects_pixels = set()\n    for obj_coords in all_objects:\n        # Check if any pixel in this object lies on the max_row_idx\n        intersects_max_row = any(r == max_row_idx for r, c in obj_coords)\n        if intersects_max_row:\n            # Add all pixels of this object to the set of pixels to keep\n            target_objects_pixels.update(obj_coords)\n\n    # Populate the output grid with the pixels from the target objects\n    for r, c in target_objects_pixels:\n        # Ensure coordinates are valid just in case (should be by construction)\n        if 0 <= r < height and 0 <= c < width:\n             output_array[r, c] = foreground_color\n\n    # Convert back to list of lists and return\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13605,
    "candidates_token_count": 1540,
    "total_token_count": 15145,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.060886,
  "retries": 1
}