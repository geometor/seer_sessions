{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by identifying the single foreground color (C), finding the topmost row ('max_row_idx') with the maximum count of C, locating all connected components (objects) of color C using 4-way adjacency, selecting the object(s) that intersect 'max_row_idx', and copying only the pixels belonging to these selected object(s) to an otherwise background-filled output grid of the same dimensions.\n\"\"\"\n\ndef find_foreground_color(grid):\n    \"\"\"\n    Finds the first non-zero (non-background) color encountered in the grid.\n    Assumes there is at most one non-background color per grid based on examples.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        int: The foreground color value, or 0 if only background is present.\n    \"\"\"\n    # Iterate through all pixels in the grid\n    for pixel in grid.flat:\n        # If a non-background pixel is found, return its color\n        if pixel != 0:\n            return pixel\n    # If no non-background pixel is found, return the background color\n    return 0\n\ndef find_max_row(grid, foreground_color):\n    \"\"\"\n    Finds the index of the row containing the maximum number of foreground_color pixels.\n    Ties are broken by choosing the lowest row index (topmost).\n\n    Args:\n        grid (np.array): The input grid.\n        foreground_color (int): The color to count.\n\n    Returns:\n        int: The index of the row with the maximum count, or -1 if the color is not found or has zero count.\n    \"\"\"\n    max_count = -1\n    max_row_idx = -1\n    height = grid.shape[0]\n\n    # Cannot meaningfully find max row for background color in this context\n    if foreground_color == 0:\n        return -1\n\n    # Iterate through each row\n    for r in range(height):\n        # Count occurrences of the foreground color in the current row\n        current_count = np.count_nonzero(grid[r, :] == foreground_color)\n        # If current count is strictly greater than max_count, update max_count and max_row_idx\n        # This automatically handles the tie-breaking (choosing the first max row found)\n        if current_count > max_count:\n            max_count = current_count\n            max_row_idx = r\n\n    # If max_count is still 0 after checking all rows, the color wasn't present with a count > 0\n    if max_count <= 0:\n      return -1\n\n    return max_row_idx\n\ndef find_connected_components(grid, foreground_color):\n    \"\"\"\n    Finds all connected components (objects) of a given foreground color using BFS.\n    Connectivity is 4-directional (cardinal: up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        foreground_color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of pixels in a connected component.\n                   Returns an empty list if foreground_color is 0 or not found.\n    \"\"\"\n    # Cannot find components of the background color meaningfully here\n    if foreground_color == 0:\n        return []\n\n    height, width = grid.shape\n    # Keep track of visited pixels to avoid redundant processing\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = [] # List to store the sets of coordinates for each object found\n\n    # Iterate through every pixel in the grid\n    for r in range(height):\n        for c in range(width):\n            # If we find a pixel of the target color that hasn't been visited yet\n            if grid[r, c] == foreground_color and not visited[r, c]:\n                # Start a Breadth-First Search (BFS) to find the connected component (object)\n                current_object_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True # Mark the starting pixel as visited\n\n                while q:\n                    row, col = q.popleft() # Get the next pixel from the queue\n                    current_object_coords.add((row, col)) # Add it to the current object\n\n                    # Check its 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Right, Left, Down, Up\n                        nr, nc = row + dr, col + dc\n\n                        # Check if the neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if the neighbor has the target color and hasn't been visited\n                            if grid[nr, nc] == foreground_color and not visited[nr, nc]:\n                                visited[nr, nc] = True # Mark neighbor as visited\n                                q.append((nr, nc)) # Add neighbor to the queue\n\n                # Once the queue is empty, the full object has been found\n                objects.append(current_object_coords)\n\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle empty input grid case\n    if input_array.size == 0:\n        return []\n\n    height, width = input_array.shape\n\n    # Initialize output grid with the same dimensions, filled with background color (0)\n    output_array = np.zeros_like(input_array)\n\n    # Step 1: Find the unique foreground color\n    foreground_color = find_foreground_color(input_array)\n\n    # If no foreground color exists, return the all-background grid\n    if foreground_color == 0:\n        return output_array.tolist()\n\n    # Step 2: Find the topmost row with the maximum count of the foreground color\n    max_row_idx = find_max_row(input_array, foreground_color)\n\n    # If no row contains the foreground color (e.g., max_count was 0), return background grid\n    if max_row_idx == -1:\n         return output_array.tolist()\n\n    # Step 3: Find all connected components (objects) of the foreground color\n    all_objects = find_connected_components(input_array, foreground_color)\n\n    # Step 4: Identify target objects - those intersecting the max_row_idx\n    target_pixels = set() # Use a set to store all pixels of the target object(s)\n    for obj_coords in all_objects:\n        # Check if any pixel in this object lies on the max_row_idx\n        intersects_max_row = any(r == max_row_idx for r, c in obj_coords)\n        if intersects_max_row:\n            # If it intersects, add all pixels of this object to the target set\n            target_pixels.update(obj_coords)\n\n    # Step 5: Populate the output grid with the pixels from the target objects\n    for r, c in target_pixels:\n        # Check bounds just in case (should be guaranteed by find_connected_components)\n        if 0 <= r < height and 0 <= c < width:\n             output_array[r, c] = foreground_color # Set the pixel in the output grid\n\n    # Convert the resulting NumPy array back to a list of lists and return\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12351,
    "candidates_token_count": 1758,
    "total_token_count": 14109,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.12445,
  "retries": 1
}