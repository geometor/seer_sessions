{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import Counter\nimport numpy as np # Import numpy to handle potential numpy array inputs\n\n\"\"\"\nTransforms a 1xN input grid by identifying the first contiguous segment of non-zero pixels. \nWithin this segment, there must be exactly two distinct non-zero colors: one appearing \nonce ('singleton') and the other appearing multiple times contiguously ('block'). \nThe transformation swaps the relative positions of the singleton pixel and the block \nof pixels within the segment, leaving the surrounding zero pixels (background) unchanged.\nIf the input structure does not match this pattern (e.g., no non-zero segment, wrong number \nof colors, block not contiguous), the original grid is returned.\n\"\"\"\n\ndef find_active_segment_indices(row):\n    \"\"\"\n    Finds the start and end indices (inclusive) of the first contiguous non-zero segment in a list.\n\n    Args:\n        row (list): A list of pixel values.\n\n    Returns:\n        tuple: A tuple (start_index, end_index). Returns (-1, -1) if no non-zero segment is found.\n    \"\"\"\n    start_index = -1\n    end_index = -1\n    in_segment = False\n    for i, pixel in enumerate(row):\n        # Use explicit comparison to handle potential numpy numeric types\n        if pixel != 0: \n            if not in_segment:\n                start_index = i\n                in_segment = True\n            end_index = i \n        elif in_segment: \n            # We found the end of the first contiguous segment\n            break \n    \n    if not in_segment: # No non-zero elements found at all\n        return -1, -1\n        \n    return start_index, end_index\n\ndef analyze_segment(segment):\n    \"\"\"\n    Analyzes a segment of pixels to find the singleton and block colors/lengths. \n    Verifies the expected structure (two distinct non-zero colors, one singleton, one contiguous block).\n\n    Args:\n        segment (list): The list of pixel values from the active segment.\n\n    Returns:\n        tuple: (singleton_color, block_color, block_length). \n               Returns (-1, -1, 0) if the expected structure is not found.\n    \"\"\"\n    if not segment:\n        return -1, -1, 0\n\n    # Ensure we only count non-zero pixels within the provided segment\n    non_zero_pixels = [p for p in segment if p != 0]\n    if not non_zero_pixels:\n         return -1, -1, 0\n         \n    counts = Counter(non_zero_pixels)\n\n    singleton_color = -1\n    block_color = -1\n    block_length = 0\n\n    # Expect exactly two distinct non-zero colors\n    if len(counts) != 2: \n         return -1, -1, 0\n\n    # Identify singleton and block based on counts\n    for color, count in counts.items():\n        # Convert color to int just in case it's a numpy numeric type\n        color_int = int(color) \n        if count == 1:\n            singleton_color = color_int\n        elif count > 1:\n            block_color = color_int\n            block_length = count\n\n    # Final check if both were identified correctly\n    if singleton_color == -1 or block_color == -1:\n        return -1, -1, 0\n\n    # Verify the block is contiguous\n    try:\n        # Find first occurrence index\n        first_block_idx = -1\n        for idx, p in enumerate(segment):\n            if p == block_color:\n                first_block_idx = idx\n                break\n        \n        if first_block_idx == -1: # Should not happen if counter found it\n             return -1, -1, 0\n\n        # Check if the slice starting from first_block_idx of length block_length are all block_color\n        is_contiguous = True\n        if first_block_idx + block_length > len(segment): # Block would extend beyond segment\n            is_contiguous = False\n        else:\n            for i in range(block_length):\n                if segment[first_block_idx + i] != block_color:\n                    is_contiguous = False\n                    break\n        \n        # Also check that no other block_color pixels exist outside this contiguous range\n        other_block_pixels = False\n        for i in range(len(segment)):\n            if i >= first_block_idx and i < first_block_idx + block_length:\n                continue # Skip the contiguous block itself\n            if segment[i] == block_color:\n                other_block_pixels = True\n                break\n\n        if not is_contiguous or other_block_pixels:\n             return -1, -1, 0\n             \n    except Exception: # Catch potential errors during check\n        return -1, -1, 0\n        \n    return singleton_color, block_color, block_length\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping a singleton and block within the active segment.\n    Handles both list of lists and numpy array inputs.\n    \"\"\"\n    # --- 1. Input Handling and Initialization ---\n    # Check for basic validity and get the row\n    if input_grid is None: return [] # Handle None input\n    \n    input_row_orig = None\n    if isinstance(input_grid, np.ndarray):\n        if input_grid.ndim == 2 and input_grid.shape[0] == 1:\n            input_row_orig = input_grid[0]\n        elif input_grid.ndim == 1: # Allow 1D numpy array as input row directly\n            input_row_orig = input_grid\n        else:\n             return [] # Invalid numpy array shape\n    elif isinstance(input_grid, list):\n        if len(input_grid) == 1 and isinstance(input_grid[0], list):\n             input_row_orig = input_grid[0]\n        elif all(isinstance(item, (int, np.integer)) for item in input_grid): # Check if it's a flat list (like a direct row)\n             input_row_orig = input_grid # Allow flat list input\n        else:\n            return [] # Invalid list structure\n    else:\n        return [] # Invalid input type\n\n    # Ensure working with standard Python list of ints\n    try:\n        input_row = [int(p) for p in input_row_orig]\n    except (ValueError, TypeError):\n        return copy.deepcopy(input_grid) # Return original if conversion fails\n\n    # Create a mutable copy for the output\n    output_row = list(input_row) \n\n    # --- 2. Identify Active Segment ---\n    start_index, end_index = find_active_segment_indices(input_row)\n\n    # If no non-zero segment found, return the original grid formatted correctly\n    if start_index == -1:\n        # Ensure output is list of lists\n        if isinstance(input_grid, np.ndarray) and input_grid.ndim == 1:\n            return [input_row] # Wrap 1D array input row\n        elif isinstance(input_grid, list) and not isinstance(input_grid[0], list):\n             return [input_row] # Wrap flat list input row\n        else:\n             return copy.deepcopy(input_grid) \n\n\n    # --- 3. Extract Active Segment ---\n    segment = input_row[start_index : end_index + 1]\n\n    # --- 4. Analyze Segment: Find Singleton and Block ---\n    singleton_color, block_color, block_length = analyze_segment(segment)\n\n    # If analysis failed (unexpected format), return original grid formatted correctly\n    if singleton_color == -1 or block_color == -1:\n         # print(f\"Warning: Segment analysis failed for segment {segment}. Returning original grid.\")\n        if isinstance(input_grid, np.ndarray) and input_grid.ndim == 1:\n            return [input_row] \n        elif isinstance(input_grid, list) and not isinstance(input_grid[0], list):\n             return [input_row]\n        else:\n            return copy.deepcopy(input_grid)\n\n    # --- 5. Determine Original Order ---\n    starts_with_singleton = (segment[0] == singleton_color)\n    \n    # Verify segment starts with either the singleton or the block\n    if not starts_with_singleton and segment[0] != block_color:\n        # This implies an unexpected structure not caught by analyze_segment\n        # print(f\"Warning: Segment {segment} doesn't start with identified singleton ({singleton_color}) or block ({block_color}). Returning original.\")\n        if isinstance(input_grid, np.ndarray) and input_grid.ndim == 1:\n            return [input_row] \n        elif isinstance(input_grid, list) and not isinstance(input_grid[0], list):\n             return [input_row]\n        else:\n             return copy.deepcopy(input_grid)\n        \n    # --- 6. Construct New Swapped Segment ---\n    new_segment = []\n    if starts_with_singleton:\n        # Original: Singleton then Block -> New: Block then Singleton\n        new_segment.extend([block_color] * block_length)\n        new_segment.append(singleton_color)\n    else: # Starts with block\n        # Original: Block then Singleton -> New: Singleton then Block\n        new_segment.append(singleton_color)\n        new_segment.extend([block_color] * block_length)\n        \n    # Sanity check: ensure the new segment has the same length as the old one\n    if len(new_segment) != len(segment):\n        # print(f\"Error: New segment length ({len(new_segment)}) does not match original ({len(segment)}).\")\n        # Return original on internal error\n        if isinstance(input_grid, np.ndarray) and input_grid.ndim == 1:\n            return [input_row]\n        elif isinstance(input_grid, list) and not isinstance(input_grid[0], list):\n             return [input_row]\n        else:\n             return copy.deepcopy(input_grid)\n\n    # --- 7. Reconstruct Output List ---\n    # Replace the original segment slice in the output row copy with the new segment\n    output_row[start_index : end_index + 1] = new_segment\n    \n    # --- 8. Format Output ---\n    # Wrap the final output row back into a 1xN grid (list of lists)\n    output_grid = [output_row]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11603,
    "candidates_token_count": 2469,
    "total_token_count": 14072,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.481318,
  "retries": 1
}