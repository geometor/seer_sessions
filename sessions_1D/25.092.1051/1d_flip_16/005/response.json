{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import Counter\n\n\"\"\"\nTransforms a 1xN input grid by identifying a contiguous segment of non-zero pixels. \nWithin this segment, there must be exactly two distinct non-zero colors: one \nappearing once ('singleton') and the other appearing multiple times contiguously \n('block'). The transformation swaps the relative positions of the singleton pixel \nand the block of pixels within the segment, leaving the surrounding zero pixels \n(background) unchanged.\n\"\"\"\n\ndef find_active_segment_indices(row):\n    \"\"\"\n    Finds the start and end indices (inclusive) of the first contiguous non-zero segment in a list.\n\n    Args:\n        row (list): A list of pixel values.\n\n    Returns:\n        tuple: A tuple (start_index, end_index). Returns (-1, -1) if no non-zero segment is found.\n    \"\"\"\n    start_index = -1\n    end_index = -1\n    in_segment = False\n    for i, pixel in enumerate(row):\n        if pixel != 0:\n            if not in_segment:\n                start_index = i\n                in_segment = True\n            end_index = i \n        elif in_segment: \n            # We found the end of the first contiguous segment\n            break \n            # Note: If multiple segments are possible, this only finds the first.\n            # Based on examples, only one segment seems relevant.\n            \n    # If loop finished while in_segment, end_index is already correct.\n    # If loop finished before finding non-zero, start_index is -1.\n    \n    # Handle edge case where the segment goes to the end of the list: end_index is already correctly set.\n\n    if not in_segment: # No non-zero elements found at all\n        return -1, -1\n        \n    return start_index, end_index\n\ndef analyze_segment(segment):\n    \"\"\"\n    Analyzes a segment of non-zero pixels to find the singleton and block colors/lengths.\n\n    Args:\n        segment (list): The list of pixel values from the active segment. \n                        Should ideally contain only non-zero values from that segment.\n\n    Returns:\n        tuple: (singleton_color, block_color, block_length). \n               Returns (-1, -1, 0) if the expected structure (one singleton, one block color) is not found.\n    \"\"\"\n    if not segment:\n        return -1, -1, 0\n\n    # Ensure we only count non-zero pixels within the provided segment\n    non_zero_pixels = [p for p in segment if p != 0]\n    if not non_zero_pixels:\n         # This case means the segment passed in was all zeros, shouldn't happen\n         # if find_active_segment_indices worked correctly.\n         return -1, -1, 0\n         \n    counts = Counter(non_zero_pixels)\n\n    singleton_color = -1\n    block_color = -1\n    block_length = 0\n\n    # Expect exactly two distinct non-zero colors based on problem description\n    if len(counts) != 2: \n         # print(f\"Warning: Expected 2 distinct non-zero colors in segment {segment}, found {len(counts)}\")\n         return -1, -1, 0\n\n    # Identify singleton and block based on counts\n    for color, count in counts.items():\n        if count == 1:\n            singleton_color = color\n        elif count > 1:\n            block_color = color\n            block_length = count\n        # else: Should not happen if len(counts) == 2 and one has count 1\n\n    # Final check if both were identified correctly\n    if singleton_color == -1 or block_color == -1:\n        # print(f\"Warning: Could not definitively identify singleton/block in segment {segment}\")\n        return -1, -1, 0\n\n    # Verify contiguous block (optional but good practice)\n    # Find first and last occurrence of block_color\n    try:\n        first_block_idx = segment.index(block_color)\n        last_block_idx = len(segment) - 1 - segment[::-1].index(block_color)\n        # Check if all elements between first and last are the block color\n        is_contiguous = all(p == block_color for p in segment[first_block_idx : last_block_idx + 1])\n        # Check if the count matches the span\n        if not is_contiguous or (last_block_idx - first_block_idx + 1) != block_length:\n             # print(f\"Warning: Block color {block_color} is not contiguous or length mismatch in segment {segment}\")\n             return -1, -1, 0\n    except ValueError: # Should not happen if block_color was found by Counter\n        # print(f\"Error: Block color {block_color} not found in segment {segment} during contiguity check.\")\n        return -1, -1, 0\n        \n\n    return singleton_color, block_color, block_length\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping a singleton and block within the active segment.\n    \"\"\"\n    # --- 1. Input Handling and Initialization ---\n    # Expecting a 1xN grid (list containing one list)\n    if not input_grid or not isinstance(input_grid, list) or len(input_grid) != 1 or \\\n       not input_grid[0] or not isinstance(input_grid[0], list):\n        # Return empty list for invalid format based on ARC structure\n        return [] \n        \n    input_row = input_grid[0]\n    # Create a mutable copy for the output\n    output_row = list(input_row) \n\n    # --- 2. Identify Active Segment ---\n    start_index, end_index = find_active_segment_indices(input_row)\n\n    # If no non-zero segment found, return the original grid (as a deep copy)\n    if start_index == -1:\n        return copy.deepcopy(input_grid) \n\n    # --- 3. Extract Active Segment ---\n    # Indices from find_active_segment_indices are inclusive\n    segment = input_row[start_index : end_index + 1]\n\n    # --- 4. Analyze Segment: Find Singleton and Block ---\n    singleton_color, block_color, block_length = analyze_segment(segment)\n\n    # If analysis failed (unexpected format), return original grid\n    if singleton_color == -1 or block_color == -1:\n         # print(f\"Warning: Segment analysis failed for segment {segment}. Returning original grid.\")\n         return copy.deepcopy(input_grid)\n\n    # --- 5. Determine Original Order ---\n    # Check if the segment starts with the singleton or the block\n    starts_with_singleton = (segment[0] == singleton_color)\n    \n    # Verify segment starts with either the singleton or the block\n    if not starts_with_singleton and segment[0] != block_color:\n        # This implies the segment has an unexpected structure, e.g., internal zeros\n        # or more than two components, which analyze_segment should ideally catch.\n        # print(f\"Warning: Segment {segment} doesn't start with identified singleton ({singleton_color}) or block ({block_color}). Returning original.\")\n        return copy.deepcopy(input_grid)\n        \n    # --- 6. Construct New Swapped Segment ---\n    new_segment = []\n    if starts_with_singleton:\n        # Original: Singleton then Block -> New: Block then Singleton\n        new_segment.extend([block_color] * block_length)\n        new_segment.append(singleton_color)\n    else: # Starts with block\n        # Original: Block then Singleton -> New: Singleton then Block\n        new_segment.append(singleton_color)\n        new_segment.extend([block_color] * block_length)\n        \n    # Sanity check: ensure the new segment has the same length as the old one\n    if len(new_segment) != len(segment):\n        # print(f\"Error: New segment length ({len(new_segment)}) does not match original ({len(segment)}). Segment: {segment}, New: {new_segment}\")\n        # This indicates a potential logic error in analysis or reconstruction.\n        return copy.deepcopy(input_grid) # Return original on error\n\n    # --- 7. Reconstruct Output List ---\n    # Replace the original segment slice in the output row copy with the new segment\n    output_row[start_index : end_index + 1] = new_segment\n    \n    # --- 8. Format Output ---\n    # Wrap the final output row back into a 1xN grid (list of lists)\n    output_grid = [output_row]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10419,
    "candidates_token_count": 2035,
    "total_token_count": 12454,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.015559,
  "retries": 1
}