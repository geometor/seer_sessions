{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict, Any\n\n\"\"\"\nTransforms a 1D grid by finding a specific pattern and rearranging its components.\nThe pattern consists of a single 'mover' pixel (color 1-9) immediately adjacent\nto a contiguous 'block' of two or more pixels (all having the same color 1-9,\ndifferent from the mover's color). The transformation swaps the relative position\nof the mover pixel and the block within the grid segment defined by the pattern.\nAll other pixels in the grid, including background pixels (color 0), remain unchanged.\n\"\"\"\n\ndef find_non_background_pattern(grid_1d: np.ndarray) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Finds the first occurrence of a non-background mover pixel adjacent\n    to a non-background block (>=2 pixels) of a different, uniform color.\n\n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A dictionary containing pattern details (mover_color, block_sequence,\n        start_index, end_index, mover_is_left) if found, otherwise None.\n    \"\"\"\n    n = len(grid_1d)\n    if n < 3: # Need at least 3 elements for mover + block(len>=2)\n        return None\n\n    # Iterate through potential boundaries between pattern elements\n    for i in range(n - 1):\n        c1 = grid_1d[i]\n        c2 = grid_1d[i+1]\n\n        # Potential boundary must involve two different non-zero colors\n        if c1 != 0 and c2 != 0 and c1 != c2:\n\n            # CASE 1: c1 is potential Mover (at i), c2 starts potential Block (at i+1)\n            # Check if c1 is single (not preceded by same color)\n            is_c1_single = (i == 0 or grid_1d[i-1] != c1)\n            # Check if c2 starts a block of length >= 2\n            is_c2_block_start = (i + 2 < n and grid_1d[i+2] == c2)\n\n            if is_c1_single and is_c2_block_start:\n                # Find the end of the block starting at i+1\n                block_color = c2\n                k = i + 1 # Start of block\n                while k + 1 < n and grid_1d[k+1] == block_color:\n                    k += 1\n                # End of block is k\n                # Verify block is properly terminated (or hits grid end)\n                is_block_terminated = (k + 1 == n or grid_1d[k+1] != block_color)\n\n                if is_block_terminated:\n                    mover_color = c1\n                    block_sequence = list(grid_1d[i+1 : k+1])\n                    start_index = i\n                    end_index = k\n                    return {\n                        \"mover_color\": mover_color,\n                        \"block_sequence\": block_sequence,\n                        \"start_index\": start_index,\n                        \"end_index\": end_index,\n                        \"mover_is_left\": True\n                    }\n\n            # CASE 2: c1 ends potential Block (at i), c2 is potential Mover (at i+1)\n            # Check if c2 is single (not followed by same color)\n            is_c2_single = (i + 1 == n - 1 or grid_1d[i+2] != c2)\n            # Check if c1 ends a block of length >= 2\n            is_c1_block_end = (i > 0 and grid_1d[i-1] == c1)\n\n            if is_c2_single and is_c1_block_end:\n                 # Find the start of the block ending at i\n                 block_color = c1\n                 j = i # End of block\n                 while j - 1 >= 0 and grid_1d[j-1] == block_color:\n                     j -= 1\n                 # Start of block is j\n                 # Verify block is properly terminated (or hits grid start)\n                 is_block_terminated = (j == 0 or grid_1d[j-1] != block_color)\n\n                 if is_block_terminated:\n                     mover_color = c2\n                     block_sequence = list(grid_1d[j : i+1])\n                     start_index = j\n                     end_index = i + 1 # Pattern includes the mover c2\n                     return {\n                         \"mover_color\": mover_color,\n                         \"block_sequence\": block_sequence,\n                         \"start_index\": start_index,\n                         \"end_index\": end_index,\n                         \"mover_is_left\": False\n                    }\n\n    return None # No valid pattern found\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n                    Expected to be 1D or 2D with a single row.\n\n    Returns:\n        A numpy array representing the transformed grid.\n    \"\"\"\n    # --- Input Handling ---\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid, dtype=int)\n\n    # Handle potential 2D shape (1, N) -> convert to 1D for processing\n    original_ndim = input_grid.ndim\n    if original_ndim == 2:\n        if input_grid.shape[0] == 1:\n            grid_1d = input_grid[0]\n        elif input_grid.shape[1] == 1: # Handle (N, 1) case if needed, though examples are rows\n             grid_1d = input_grid.flatten()\n             original_ndim = 1 # Treat as 1D for output reshaping consistency\n        else:\n             raise ValueError(f\"Input grid must be 1D or 2D with one dimension = 1. Got shape: {input_grid.shape}\")\n    elif original_ndim == 1:\n        grid_1d = input_grid\n    else:\n        raise ValueError(f\"Input grid must be 1D or 2D. Got shape: {input_grid.shape}\")\n\n    # --- Initialization ---\n    # Initialize output grid as a copy of the 1D working grid\n    output_grid_1d = grid_1d.copy()\n\n    # --- Pattern Finding ---\n    # Find the specific mover-block pattern, ignoring background pixels in the core components\n    pattern_info = find_non_background_pattern(grid_1d)\n\n    # --- Transformation Application ---\n    # If the pattern is found, apply the swap transformation\n    if pattern_info:\n        # Extract pattern details\n        mover_color = pattern_info[\"mover_color\"]\n        block_sequence = pattern_info[\"block_sequence\"]\n        start = pattern_info[\"start_index\"]\n        end = pattern_info[\"end_index\"]\n        mover_is_left = pattern_info[\"mover_is_left\"]\n\n        # Construct the new sequence by swapping the mover and block\n        if mover_is_left:\n            # New sequence: block + mover\n            new_sequence = block_sequence + [mover_color]\n        else:\n            # New sequence: mover + block\n            new_sequence = [mover_color] + block_sequence\n\n        # Replace the original pattern segment in the output grid with the new sequence\n        # Ensure length matches (should always be true if find_pattern is correct)\n        if len(new_sequence) == (end - start + 1):\n             output_grid_1d[start : end + 1] = new_sequence\n        else:\n             # This case indicates a potential flaw in find_non_background_pattern logic\n             print(f\"Warning: Length mismatch during replacement. Indices [{start}:{end+1}], Expected len {end-start+1}, New len {len(new_sequence)}. Pattern: {pattern_info}\")\n             # Return unmodified copy in case of unexpected error to avoid crashing\n             pass # Output grid remains the initial copy\n\n    # --- Output Formatting ---\n    # Reshape back to the original input format (1D or 2D) if necessary\n    if original_ndim == 2 and input_grid.shape[0] == 1:\n        return output_grid_1d.reshape(1, -1)\n    else: # Handles original 1D or (N, 1) cases converted earlier\n        return output_grid_1d\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10980,
    "candidates_token_count": 2015,
    "total_token_count": 12995,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.955453,
  "retries": 1
}