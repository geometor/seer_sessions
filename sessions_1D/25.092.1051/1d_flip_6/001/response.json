{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict, Any\n\n\"\"\"\nIdentifies a pattern where a single 'mover' pixel is adjacent to a\ncontiguous block (>= 2 pixels) of a different color in a 1D grid.\nThe transformation swaps the relative position of the mover pixel and\nthe block. If the mover is initially to the left of the block, it moves\nto the right, and vice-versa. The rest of the grid remains unchanged.\n\"\"\"\n\ndef find_pattern(grid_1d: np.ndarray) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Finds the first occurrence of a mover pixel adjacent to a block (>=2 pixels)\n    of a different, uniform color.\n\n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A dictionary containing pattern details (mover_color, block_sequence,\n        start_index, end_index, mover_is_left) if found, otherwise None.\n    \"\"\"\n    n = len(grid_1d)\n    if n < 3: # Need at least 3 elements for mover + block(len>=2)\n        return None\n\n    # Iterate through potential boundaries between elements\n    for i in range(n - 1):\n        left_val = grid_1d[i]\n        right_val = grid_1d[i+1]\n\n        # Potential boundary found if colors are different\n        if left_val != right_val:\n\n            # Check Case 1: Mover (left_val at i) + Block (starting at i+1)\n            # The block must have length >= 2\n            if i + 2 < n and grid_1d[i+1] == grid_1d[i+2]:\n                block_color = grid_1d[i+1]\n                # Find the end of the block\n                k = i + 1\n                while k + 1 < n and grid_1d[k+1] == block_color:\n                    k += 1\n                # Block length is k - (i+1) + 1 = k - i\n                block_len = k - i\n                # No need to check block_len >= 2 again due to initial check\n\n                mover_color = left_val\n                start_index = i\n                end_index = k\n                block_sequence = list(grid_1d[i+1 : k+1])\n                return {\n                    \"mover_color\": mover_color,\n                    \"block_sequence\": block_sequence,\n                    \"start_index\": start_index,\n                    \"end_index\": end_index,\n                    \"mover_is_left\": True\n                }\n\n            # Check Case 2: Block (ending at i) + Mover (right_val at i+1)\n            # The block must have length >= 2\n            if i > 0 and grid_1d[i] == grid_1d[i-1]:\n                 block_color = grid_1d[i]\n                 # Find the start of the block\n                 j = i\n                 while j - 1 >= 0 and grid_1d[j-1] == block_color:\n                     j -= 1\n                 # Block length is i - j + 1\n                 block_len = i - j + 1\n                 # Need to confirm block length >= 2\n                 if block_len >= 2:\n                     mover_color = right_val # The element at i+1 is the mover\n                     start_index = j\n                     end_index = i + 1 # Pattern includes the mover at i+1\n                     block_sequence = list(grid_1d[j : i+1])\n                     return {\n                         \"mover_color\": mover_color,\n                         \"block_sequence\": block_sequence,\n                         \"start_index\": start_index,\n                         \"end_index\": end_index,\n                         \"mover_is_left\": False\n                    }\n    return None # No pattern found\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n                    Expected to be 1D or 2D with a single row.\n\n    Returns:\n        A numpy array representing the transformed grid.\n    \"\"\"\n    # Ensure input is a numpy array and handle potential 2D shape (1, N)\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    original_ndim = input_grid.ndim\n    if original_ndim == 2 and input_grid.shape[0] == 1:\n        grid_1d = input_grid[0]\n    elif original_ndim == 1:\n        grid_1d = input_grid\n    else:\n         raise ValueError(f\"Input grid must be 1D or a 2D array with a single row. Got shape: {input_grid.shape}\")\n\n    # Initialize output grid as a copy\n    output_grid_1d = grid_1d.copy()\n\n    # Find the mover and block pattern\n    pattern_info = find_pattern(grid_1d)\n\n    # If a pattern is found, apply the transformation\n    if pattern_info:\n        mover_color = pattern_info[\"mover_color\"]\n        block_sequence = pattern_info[\"block_sequence\"]\n        start = pattern_info[\"start_index\"]\n        end = pattern_info[\"end_index\"]\n        mover_is_left = pattern_info[\"mover_is_left\"]\n\n        # Construct the new sequence by swapping mover and block\n        if mover_is_left:\n            # New sequence: block + mover\n            new_sequence = block_sequence + [mover_color]\n        else:\n            # New sequence: mover + block\n            new_sequence = [mover_color] + block_sequence\n\n        # Verify lengths before replacement (should always match if find_pattern is correct)\n        expected_len = end - start + 1\n        if len(new_sequence) == expected_len:\n            # Replace the original pattern segment with the new sequence in the output grid\n            output_grid_1d[start : end + 1] = new_sequence\n        else:\n            # Log an error if lengths mismatch - indicates a logic flaw\n            print(f\"Error: Length mismatch during replacement. Original length: {expected_len}, New length: {len(new_sequence)}\")\n            # Return the unmodified grid copy in case of error\n            if original_ndim == 2:\n                return output_grid_1d.reshape(1, -1)\n            else:\n                return output_grid_1d\n\n\n    # Reshape back to original format if necessary (e.g., 2D with 1 row)\n    if original_ndim == 2:\n        return output_grid_1d.reshape(1, -1)\n    else:\n        return output_grid_1d\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2578,
    "candidates_token_count": 1614,
    "total_token_count": 4192,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 51.726375,
  "retries": 1
}