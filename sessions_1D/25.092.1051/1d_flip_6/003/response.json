{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict, Any\n\n\"\"\"\nTransforms a 1D grid by identifying a unique pattern consisting of a single 'mover' pixel adjacent to a contiguous block (length >= 2) of pixels of a different, uniform color. The transformation swaps the relative position of the mover pixel and the block within the grid segment defined by the pattern. Pixels outside this segment remain unchanged.\n\"\"\"\n\n\ndef find_pattern(grid_1d: np.ndarray) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Finds the first occurrence of a mover pixel adjacent to a block (>=2 pixels)\n    of a different, uniform color.\n\n    Args:\n        grid_1d: A 1D numpy array representing the grid row.\n\n    Returns:\n        A dictionary containing pattern details (mover_color, block_sequence,\n        start_index, end_index, mover_is_left) if found, otherwise None.\n    \"\"\"\n    n = len(grid_1d)\n    if n < 3: # Need at least 3 elements for mover + block(len>=2)\n        return None\n\n    # Iterate through potential start positions of the pattern\n    for i in range(n - 1):\n        # Case 1: Potential Mover at grid_1d[i], Potential Block starts at grid_1d[i+1]\n        mover_cand_color = grid_1d[i]\n        block_cand_start_color = grid_1d[i+1]\n\n        # Check if colors are different and if a block of length >= 2 starts at i+1\n        if mover_cand_color != block_cand_start_color and i + 2 < n and grid_1d[i+1] == grid_1d[i+2]:\n            # Verify mover candidate is truly single (check left boundary or neighbor)\n            if i == 0 or grid_1d[i-1] != mover_cand_color:\n                block_color = block_cand_start_color\n                # Find the end of the block\n                k = i + 1\n                while k + 1 < n and grid_1d[k+1] == block_color:\n                    k += 1\n                # Check if the element after the block is different (ensures block ends here)\n                # or if we are at the end of the grid\n                if k + 1 == n or grid_1d[k+1] != block_color:\n                    block_sequence = list(grid_1d[i+1 : k+1])\n                    start_index = i\n                    end_index = k\n                    return {\n                        \"mover_color\": mover_cand_color,\n                        \"block_sequence\": block_sequence,\n                        \"start_index\": start_index,\n                        \"end_index\": end_index,\n                        \"mover_is_left\": True\n                    }\n\n        # Case 2: Potential Block ends at grid_1d[i], Potential Mover at grid_1d[i+1]\n        mover_cand_color = grid_1d[i+1]\n        block_cand_end_color = grid_1d[i]\n\n        # Check if colors are different and if a block of length >= 2 ends at i\n        if mover_cand_color != block_cand_end_color and i > 0 and grid_1d[i] == grid_1d[i-1]:\n            # Verify mover candidate is truly single (check right boundary or neighbor)\n            if i + 1 == n - 1 or grid_1d[i+2] != mover_cand_color:\n                block_color = block_cand_end_color\n                # Find the start of the block\n                j = i\n                while j - 1 >= 0 and grid_1d[j-1] == block_color:\n                    j -= 1\n                # Check if the element before the block is different (ensures block starts here)\n                # or if we are at the start of the grid\n                if j == 0 or grid_1d[j-1] != block_color:\n                    block_sequence = list(grid_1d[j : i+1])\n                    start_index = j\n                    end_index = i + 1\n                    return {\n                        \"mover_color\": mover_cand_color,\n                        \"block_sequence\": block_sequence,\n                        \"start_index\": start_index,\n                        \"end_index\": end_index,\n                        \"mover_is_left\": False\n                    }\n\n    return None # No valid pattern found\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n                    Expected to be 1D or 2D with a single row.\n\n    Returns:\n        A numpy array representing the transformed grid.\n    \"\"\"\n    # Ensure input is a numpy array and handle potential 2D shape (1, N)\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    original_ndim = input_grid.ndim\n    if original_ndim == 2 and input_grid.shape[0] == 1:\n        grid_1d = input_grid[0]\n    elif original_ndim == 1:\n        grid_1d = input_grid\n    else:\n        raise ValueError(f\"Input grid must be 1D or a 2D array with a single row. Got shape: {input_grid.shape}\")\n\n    # Initialize output grid as a copy of the input\n    output_grid_1d = grid_1d.copy()\n\n    # Find the specific mover-block pattern\n    pattern_info = find_pattern(grid_1d)\n\n    # If the pattern is found, apply the transformation\n    if pattern_info:\n        # Extract pattern details\n        mover_color = pattern_info[\"mover_color\"]\n        block_sequence = pattern_info[\"block_sequence\"]\n        start = pattern_info[\"start_index\"]\n        end = pattern_info[\"end_index\"]\n        mover_is_left = pattern_info[\"mover_is_left\"]\n\n        # Construct the new sequence by swapping the mover and block\n        if mover_is_left:\n            # New sequence: block + mover\n            new_sequence = block_sequence + [mover_color]\n        else:\n            # New sequence: mover + block\n            new_sequence = [mover_color] + block_sequence\n\n        # Verify lengths before replacement (as a safeguard)\n        expected_len = end - start + 1\n        if len(new_sequence) == expected_len:\n            # Replace the original pattern segment in the output grid\n            output_grid_1d[start : end + 1] = new_sequence\n        else:\n            # This case should ideally not happen if find_pattern is correct\n            print(f\"Warning: Length mismatch during replacement. Original: {expected_len}, New: {len(new_sequence)}. Pattern: {pattern_info}\")\n            # Return unmodified copy in case of unexpected error\n            if original_ndim == 2:\n                return output_grid_1d.reshape(1, -1)\n            else:\n                return output_grid_1d\n\n    # If no pattern was found, output_grid_1d remains an unchanged copy\n\n    # Reshape back to the original input format (1D or 2D)\n    if original_ndim == 2:\n        return output_grid_1d.reshape(1, -1)\n    else:\n        return output_grid_1d\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10556,
    "candidates_token_count": 1768,
    "total_token_count": 12324,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.64309,
  "retries": 1
}