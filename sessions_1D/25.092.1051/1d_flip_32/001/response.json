{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Dict, Any, Optional\n\n\"\"\"\nThis module transforms a 1D grid of pixels by finding a specific pattern\nand swapping the positions of its components.\n\nThe pattern consists of:\n1. A single 'marker' pixel (the first non-background pixel encountered).\n2. A contiguous sequence of identical pixels ('color sequence') that \n   immediately follows the marker pixel and has a different color than it.\n\nThe transformation involves:\n1. Moving the entire 'color sequence' to start at the original position \n   of the 'marker' pixel.\n2. Moving the 'marker' pixel to the position immediately following the \n   end of the moved 'color sequence'.\nBackground pixels (color 0) remain unchanged.\n\"\"\"\n\ndef find_pattern(grid: List[int]) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Scans the grid to find the marker pixel and the adjacent color sequence.\n\n    Args:\n        grid: A 1D list representing the input grid pixels.\n\n    Returns:\n        A dictionary containing information about the found pattern \n        (marker index, marker color, sequence start index, sequence end index, \n        sequence color), or None if the pattern is not found or invalid.\n    \"\"\"\n    marker_index = -1\n    marker_color = -1\n    seq_start_index = -1\n    seq_color = -1\n    seq_end_index = -1\n    grid_len = len(grid)\n\n    # Find the first non-background pixel (marker)\n    for i, pixel in enumerate(grid):\n        if pixel != 0:\n            marker_index = i\n            marker_color = pixel\n            break\n\n    # Check if a marker was found and if there's space for a sequence after it\n    if marker_index == -1 or marker_index >= grid_len - 1:\n        return None # No marker found or no space for sequence\n\n    # Find the start of the sequence (must be non-background and different color)\n    seq_start_index = marker_index + 1\n    if grid[seq_start_index] == 0 or grid[seq_start_index] == marker_color:\n        return None # Invalid sequence start\n    seq_color = grid[seq_start_index]\n    seq_end_index = seq_start_index # Sequence is at least one pixel long\n\n    # Find the end of the contiguous sequence of the same color\n    for i in range(seq_start_index + 1, grid_len):\n        if grid[i] == seq_color:\n            seq_end_index = i\n        else:\n            break # Sequence ends\n\n    return {\n        \"marker_index\": marker_index,\n        \"marker_color\": marker_color,\n        \"seq_start_index\": seq_start_index,\n        \"seq_end_index\": seq_end_index,\n        \"seq_color\": seq_color\n    }\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by swapping the marker pixel and the adjacent color sequence.\n\n    Args:\n        input_grid: A numpy array representing the input grid. \n                      Expected to be 1D or 2D with a single row.\n\n    Returns:\n        A numpy array representing the transformed grid, maintaining the original shape.\n    \"\"\"\n    # Ensure input is a NumPy array and handle potential multi-row inputs\n    # For this task, we expect 1xN or N shape. Flatten to 1D list for processing.\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n        \n    original_shape = input_grid.shape\n    # Flatten the grid to a 1D list for easier processing\n    input_list = input_grid.flatten().tolist()\n    \n    # Initialize output_list as a copy of the input_list\n    output_list = list(input_list)\n\n    # Locate the marker and the sequence\n    pattern_info = find_pattern(input_list)\n\n    # If the specific pattern isn't found, return the original grid unchanged\n    if pattern_info is None:\n        # print(\"Warning: Required pattern not found. Returning original grid.\")\n        return input_grid # Return original numpy array\n\n    # Extract pattern details\n    marker_index = pattern_info[\"marker_index\"]\n    marker_color = pattern_info[\"marker_color\"]\n    seq_start_index = pattern_info[\"seq_start_index\"]\n    seq_end_index = pattern_info[\"seq_end_index\"]\n    seq_color = pattern_info[\"seq_color\"]\n\n    # Calculate the length of the color sequence\n    seq_length = seq_end_index - seq_start_index + 1\n\n    # Perform the swap in the output list\n    # 1. Place the color sequence starting at the original marker position\n    for i in range(seq_length):\n        # Check bounds just in case, although pattern finding should ensure validity\n        if marker_index + i < len(output_list):\n            output_list[marker_index + i] = seq_color\n\n    # 2. Place the marker pixel immediately after the newly placed sequence\n    new_marker_position = marker_index + seq_length\n    if new_marker_position < len(output_list):\n         output_list[new_marker_position] = marker_color\n    # Note: This logic assumes the swap doesn't overwrite essential parts before they are used.\n    # Since we work on a copy `output_list` based on `input_list`, this is safe.\n\n    # Convert the result list back to a numpy array with the original shape\n    output_grid = np.array(output_list).reshape(original_shape)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2317,
    "candidates_token_count": 1337,
    "total_token_count": 3654,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.906041,
  "retries": 1
}