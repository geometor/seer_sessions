{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransforms the input grid by identifying a contiguous non-white segment \nin the first row, finding a single 'singleton' pixel and a contiguous 'block' \nof another color within that segment, and then swapping their relative positions. \nBackground pixels (color 0) remain unchanged.\n\nThe transformation logic assumes the input is a 1xN grid (or processes only \nthe first row) and the non-white segment contains exactly one singleton pixel \nand one block of pixels of another color, positioned adjacently at the ends \nof the segment.\n\"\"\"\n\ndef find_non_white_segment_info(row):\n    \"\"\"\n    Finds the start, end indices and extracts the contiguous non-white segment \n    from a 1D row (list or numpy array). Also checks for contiguity.\n    \n    Args:\n        row (np.array or list): A 1D array/list of integers representing a row.\n\n    Returns:\n        tuple: (start_index, end_index, segment_array) or (None, None, None) if \n               no non-white segment is found or it's not contiguous.\n    \"\"\"\n    # Find indices of non-white pixels\n    non_white_indices = np.where(np.array(row) != 0)[0]\n    \n    if non_white_indices.size == 0:\n        # No non-white pixels found\n        return None, None, None\n        \n    start = non_white_indices.min()\n    end = non_white_indices.max()\n    \n    # Check for contiguity: the number of non-white pixels should match the span\n    if (end - start + 1) != non_white_indices.size:\n         # The non-white pixels are not in a single contiguous block\n        return None, None, None\n\n    # Extract the segment as a numpy array\n    segment = np.array(row)[start : end + 1]\n    return start, end, segment\n\ndef analyze_segment_and_swap(segment):\n    \"\"\"\n    Analyzes a non-white segment to find singleton and block, then constructs\n    the swapped segment.\n\n    Args:\n        segment (np.array): The numpy array of non-white pixels forming the segment.\n\n    Returns:\n        np.array: The segment with singleton and block positions swapped, \n                  or None if the segment doesn't fit the expected pattern.\n    \"\"\"\n    if segment.size < 2: # Need at least one singleton and one block pixel\n        return None\n\n    # Count occurrences of each color in the segment\n    unique_colors, counts = np.unique(segment, return_counts=True)\n    \n    # Expecting exactly two distinct non-white colors\n    if unique_colors.size != 2: \n        return None\n\n    singleton_color = None\n    block_color = None\n    block_length = 0\n    \n    # Identify singleton (count=1) and block (count>1) colors\n    for color, count in zip(unique_colors, counts):\n        if count == 1:\n            singleton_color = color\n        elif count > 1:\n            block_color = color\n            block_length = count\n        # Note: We already checked unique_colors.size == 2, so other counts aren't possible\n\n    # Check if we successfully identified both\n    if singleton_color is None or block_color is None:\n        return None # Should not happen if unique_colors.size == 2\n\n    # Find the position index of the singleton within the segment\n    # np.where returns a tuple of arrays, we need the first element of the first array\n    singleton_index_in_segment = np.where(segment == singleton_color)[0]\n    \n    # Check if singleton was found and there's only one\n    if singleton_index_in_segment.size != 1:\n         return None # Should not happen if counts were correct\n\n    singleton_index_in_segment = singleton_index_in_segment[0]\n    segment_length = segment.size\n\n    # Construct the new segment with swapped positions\n    new_segment_list = []\n    \n    # Check if singleton is at the beginning of the segment\n    if singleton_index_in_segment == 0:\n        # Place block first, then singleton\n        new_segment_list.extend([block_color] * block_length)\n        new_segment_list.append(singleton_color)\n    # Check if singleton is at the end of the segment\n    elif singleton_index_in_segment == segment_length - 1:\n        # Place singleton first, then block\n        new_segment_list.append(singleton_color)\n        new_segment_list.extend([block_color] * block_length)\n    else:\n        # Singleton is in the middle - not expected by examples\n        return None\n\n    # Safety check: ensure the new segment has the correct length\n    if len(new_segment_list) != segment_length:\n        return None # Logic error\n\n    return np.array(new_segment_list)\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the singleton-block swap transformation to the input grid.\n    Handles NumPy array input and returns a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n\n    # Handle empty or non-2D input\n    if input_np.ndim != 2 or input_np.shape[0] == 0 or input_np.shape[1] == 0:\n        # Return input as list of lists if it's invalid/empty\n        return input_grid \n\n    # Work primarily on the first row as per examples\n    input_row = input_np[0]\n    # Create a mutable copy for the output\n    output_row = input_row.copy() \n\n    # 1. Identify the contiguous segment of non-white pixels\n    start, end, segment = find_non_white_segment_info(input_row)\n\n    # If no valid segment found, return the original grid unchanged\n    if start is None:\n        # Convert back to list of lists format\n        return input_np.tolist()\n\n    # 2. Analyze the segment and create the swapped version\n    new_segment = analyze_segment_and_swap(segment)\n    \n    # If segment analysis or swap fails (doesn't match pattern), return original\n    if new_segment is None:\n        return input_np.tolist()\n\n    # 3. Place the newly constructed segment back into the output row\n    output_row[start : end + 1] = new_segment\n\n    # 4. Construct the final output grid (currently assuming 1 row input)\n    # If input had more rows, they should be preserved.\n    output_np = input_np.copy() # Start with a copy of the original grid\n    output_np[0] = output_row   # Update the first row\n\n    # 5. Return the modified grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6823,
    "candidates_token_count": 1632,
    "total_token_count": 8455,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.671089,
  "retries": 1
}