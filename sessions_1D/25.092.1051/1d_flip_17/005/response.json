{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\nIdentify a specific pattern in the 1D input grid: a single non-white pixel (Color A) that is immediately followed by a contiguous block of one or more pixels of a different non-white color (Color B). The single pixel (Color A) must be preceded by white (0) or be at the very beginning of the grid (index 0).\n\nIf this pattern is found, perform a positional swap:\n1. The contiguous block (Color B) moves one position to the left, starting at the original index of the single pixel (Color A).\n2. The single pixel (Color A) moves to the position immediately following the end position of where the block *was originally*. This effectively places it at the index corresponding to `original_index_of_A + length_of_block_B`.\n\nAll other pixels (background white pixels, and any pixels not part of the identified pattern) remain unchanged. If the specific pattern is not found anywhere in the grid, the output grid is an identical copy of the input grid. Only the first occurrence of the pattern found scanning left-to-right is transformed.\n\"\"\"\n\nimport copy\nimport numpy as np # numpy is commonly used for grid manipulations in ARC tasks\n\ndef find_pattern_indices(grid):\n    \"\"\"\n    Scans the grid to find the first occurrence of the pattern: \n    a single pixel (A) followed immediately by a block (B).\n    'Single' means preceded by 0 or at index 0. A and B must be non-zero and different.\n\n    Args:\n        grid: A list of integers representing the 1D grid row.\n\n    Returns:\n        A tuple (single_pixel_index, block_start_index, block_end_index) \n        if the pattern is found, otherwise None.\n    \"\"\"\n    n = len(grid)\n    # Iterate through possible start positions of block B (index i)\n    # This means pixel A would be at i-1\n    for i in range(1, n): \n        color_a = grid[i-1] # Potential single pixel A\n        color_b = grid[i]   # Potential start of block B\n\n        # Check primary conditions: A and B are non-white (non-zero) and different\n        if color_a != 0 and color_b != 0 and color_a != color_b:\n            \n            # Check if grid[i-1] (Color A) meets the 'single pixel' condition:\n            # It's either at the very start (i-1 == 0) or preceded by white (0)\n            is_single_pixel_a = (i == 1 or grid[i-2] == 0)\n            \n            # If all conditions for the pattern start are met\n            if is_single_pixel_a:\n                single_pixel_index = i - 1\n                block_start_index = i\n                \n                # Find the end of the contiguous block of Color B\n                block_end_index = block_start_index\n                # Keep extending the end index as long as we are within bounds \n                # and the next pixel has the same color B\n                while block_end_index + 1 < n and grid[block_end_index + 1] == color_b:\n                    block_end_index += 1\n                    \n                # Pattern found, return the relevant indices. We only need the first match.\n                return single_pixel_index, block_start_index, block_end_index\n                \n    # If the loop completes without finding the pattern\n    return None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described swap transformation to the input grid row.\n    \"\"\"\n    # Initialize output_grid as a deep copy to avoid modifying the input directly\n    # and to handle the case where no pattern is found.\n    output_grid = copy.deepcopy(input_grid)\n    \n    # Use the helper function to find the indices of the pattern (if it exists)\n    pattern_indices = find_pattern_indices(input_grid)\n\n    # Proceed with transformation only if the pattern was found\n    if pattern_indices:\n        # Unpack the indices returned by the helper function\n        single_pixel_index, block_start_index, block_end_index = pattern_indices\n        \n        # Extract the actual colors involved in the pattern from the input grid\n        color_a = input_grid[single_pixel_index]\n        color_b = input_grid[block_start_index]\n        \n        # Calculate the length of the block B based on its start and end indices\n        block_length = block_end_index - block_start_index + 1\n\n        # --- Perform the swap in the output grid ---\n        \n        # 1. Place the block B starting at the single pixel's original index (single_pixel_index)\n        # Iterate 'block_length' times to place each pixel of block B\n        for k in range(block_length):\n            # Calculate the target index in the output grid for the k-th pixel of block B\n            target_index = single_pixel_index + k\n            # Assign color B to this target index in the output grid\n            output_grid[target_index] = color_b\n            \n        # 2. Place the single pixel A immediately after the block's new position.\n        # The block B now occupies indices from single_pixel_index to single_pixel_index + block_length - 1.\n        # Therefore, pixel A goes into the next index in the output grid.\n        output_grid[single_pixel_index + block_length] = color_a\n\n        # Note: Since we started with a deep copy, all pixels outside the modified range \n        # (single_pixel_index to single_pixel_index + block_length) automatically \n        # retain their original values from the input_grid.\n\n    # Return the modified output grid (or the original copy if pattern wasn't found)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8614,
    "candidates_token_count": 1354,
    "total_token_count": 9968,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.19754,
  "retries": 1
}