{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms a 1D input grid by locating a single contiguous segment of non-white pixels. \nThis segment must contain exactly two distinct non-white colors: one 'head' color appearing once \nat either end, and one 'body' color appearing multiple times. The transformation moves the \n'head' pixel to the opposite end of the segment, keeping the body pixels, segment length, \nand overall segment position within the grid unchanged.\n\"\"\"\n\ndef find_non_white_segment(grid_row):\n    \"\"\"\n    Finds the start index, end index, and the subarray of the first contiguous \n    non-white segment in a 1D numpy array.\n\n    Args:\n        grid_row (np.ndarray): The 1D input grid row.\n\n    Returns:\n        tuple: (start_index, end_index, segment_array) or (None, None, None) if no \n               segment found or segment is not contiguous.\n    \"\"\"\n    non_white_indices = np.where(grid_row != 0)[0]\n    if len(non_white_indices) == 0:\n        return None, None, None\n    \n    start_index = non_white_indices[0]\n    end_index = non_white_indices[-1]\n    \n    # Check for contiguity: difference between consecutive indices should always be 1\n    if len(non_white_indices) > 1 and not np.all(np.diff(non_white_indices) == 1):\n         # If there are multiple non-white pixels but they aren't contiguous\n         return None, None, None \n\n    segment = grid_row[start_index : end_index + 1]\n    return start_index, end_index, segment\n\ndef analyze_segment(segment):\n    \"\"\"\n    Analyzes a segment to identify head and body colors and the head's position.\n    Checks if the segment matches the expected pattern: two colors, one unique (head) \n    at an end, one repeated (body).\n\n    Args:\n        segment (np.ndarray): The segment subarray.\n\n    Returns:\n        tuple: (head_color, body_color, head_index_in_segment) or \n               (None, None, None) if the pattern is not matched.\n    \"\"\"\n    if segment is None or len(segment) < 2:\n        return None, None, None # Segment needs at least a head and a body pixel\n\n    counts = Counter(segment)\n    \n    # Check for exactly two distinct colors\n    if len(counts) != 2:\n        return None, None, None\n\n    head_color = None\n    body_color = None\n    \n    # Identify head (count 1) and body (count > 1) colors\n    for color, count in counts.items():\n        if count == 1:\n            head_color = color\n        elif count > 1:\n            body_color = color\n        else: # Should not happen if len(counts) == 2 and len(segment) >= 2\n             return None, None, None\n\n    # Ensure both head and body were found\n    if head_color is None or body_color is None:\n        return None, None, None\n\n    # Find the index of the head pixel within the segment\n    try:\n        head_index_in_segment = np.where(segment == head_color)[0][0] \n    except IndexError: # Should not happen if head_color was identified\n        return None, None, None\n\n    # Validate head is at one of the ends\n    if head_index_in_segment != 0 and head_index_in_segment != len(segment) - 1:\n        # Head is not at either end, pattern violation\n        return None, None, None \n\n    return head_color, body_color, head_index_in_segment\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the head-reversal transformation to the input grid.\n\n    Args:\n        input_grid (list): A 1D list representing the input row.\n\n    Returns:\n        list: The transformed 1D list, or the original list if the\n              pattern wasn't found or matched.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_row = np.array(input_grid)\n    \n    # Initialize output grid as a copy of the input\n    output_grid = input_row.copy()\n\n    # 1. Identify the contiguous segment of non-white pixels\n    start_index, end_index, segment = find_non_white_segment(input_row)\n\n    # If no valid segment found, return the original grid\n    if segment is None:\n        return output_grid.tolist()\n\n    # 2. Analyze the segment for the head/body pattern\n    analysis_result = analyze_segment(segment)\n\n    # If pattern not matched within the segment, return original\n    if analysis_result is None:\n        return output_grid.tolist()\n        \n    head_color, body_color, head_index_in_segment = analysis_result\n\n    # 3. Get segment length\n    segment_len = len(segment)\n\n    # 4. Construct the transformed segment\n    # Create a new array filled with the body color\n    transformed_segment = np.full(segment_len, body_color, dtype=segment.dtype) \n\n    # Determine the new position for the head and place it\n    if head_index_in_segment == 0:\n        # Head was at the start, move it to the end\n        transformed_segment[-1] = head_color\n    else: # head_index_in_segment == segment_len - 1\n        # Head was at the end, move it to the start\n        transformed_segment[0] = head_color\n        \n    # 5. Place the transformed segment back into the output grid\n    output_grid[start_index : end_index + 1] = transformed_segment\n\n    # Return the result as a list\n    return output_grid.tolist() \n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6620,
    "candidates_token_count": 1397,
    "total_token_count": 8017,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.699046,
  "retries": 1
}