{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 1D input grid by locating a single contiguous segment of non-white pixels. \nThis segment must contain exactly two distinct non-white colors: one 'head' color appearing once \nat either end, and one 'body' color appearing multiple times. The transformation moves the \n'head' pixel to the opposite end of the segment, keeping the body pixels, segment length, \nand overall segment position within the grid unchanged. If the input does not contain \na segment matching these criteria, the original input grid is returned.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_non_white_segment(grid_row):\n    \"\"\"\n    Finds the start index, end index, and the subarray of the first contiguous \n    non-white segment in a 1D numpy array.\n\n    Args:\n        grid_row (np.ndarray): The 1D input grid row.\n\n    Returns:\n        tuple: (start_index, end_index, segment_array) or (None, None, None) if no \n               segment found or segment is not contiguous.\n    \"\"\"\n    # Find indices of all non-white (non-zero) pixels\n    non_white_indices = np.where(grid_row != 0)[0]\n    \n    # If no non-white pixels found, return None\n    if len(non_white_indices) == 0:\n        return None, None, None\n    \n    # Determine the potential start and end of the segment\n    start_index = non_white_indices[0]\n    end_index = non_white_indices[-1]\n    \n    # Check for contiguity: the number of non-white pixels must equal the span + 1\n    # A simpler way is checking if differences between consecutive indices are all 1.\n    if len(non_white_indices) > 1:\n         if not np.all(np.diff(non_white_indices) == 1):\n             # If there are multiple non-white pixels but they aren't contiguous\n             return None, None, None \n    # A single non-white pixel is always contiguous.\n    # Ensure the slice length matches the number of non_white pixels found\n    elif len(non_white_indices) != (end_index - start_index + 1):\n         return None, None, None\n\n    # Extract the segment\n    segment = grid_row[start_index : end_index + 1]\n    return start_index, end_index, segment\n\ndef analyze_segment(segment):\n    \"\"\"\n    Analyzes a segment to identify head and body colors and the head's position.\n    Checks if the segment matches the expected pattern: exactly two colors, \n    one unique color ('head') located at one end, and one repeated color ('body').\n\n    Args:\n        segment (np.ndarray): The segment subarray.\n\n    Returns:\n        tuple: (head_color, body_color, head_index_in_segment) or \n               (None, None, None) if the pattern is not matched.\n    \"\"\"\n    # Segment must have at least two pixels (one head, one body)\n    if segment is None or len(segment) < 2:\n        return None, None, None \n\n    # Count colors in the segment\n    counts = Counter(segment)\n    \n    # Check for exactly two distinct colors\n    if len(counts) != 2:\n        return None, None, None\n\n    head_color = None\n    body_color = None\n    head_count = 0\n    body_count = 0\n    \n    # Identify head (count 1) and body (count > 1) colors\n    for color, count in counts.items():\n        if count == 1:\n            head_color = color\n            head_count = count\n        elif count > 1:\n            body_color = color\n            body_count = count\n        # Any other count invalidates the pattern (e.g., count=0 or invalid color)\n\n    # Ensure both head and body pattern parts were found (exactly 1 head, 1+ body)\n    if head_color is None or body_color is None or head_count != 1 or body_count < 1:\n        return None, None, None\n\n    # Find the index of the head pixel within the segment\n    try:\n        # np.where returns a tuple of arrays, we need the first element of the first array\n        head_indices = np.where(segment == head_color)[0]\n        # There should be exactly one index since head_count is 1\n        if len(head_indices) != 1:\n             return None, None, None # Should not happen based on count logic, but good check\n        head_index_in_segment = head_indices[0]\n    except IndexError: \n        # Should not happen if head_color was identified from the segment\n        return None, None, None\n\n    # Validate head is at one of the ends (index 0 or index len-1)\n    if head_index_in_segment != 0 and head_index_in_segment != len(segment) - 1:\n        # Head is not at either end, pattern violation\n        return None, None, None \n\n    return head_color, body_color, head_index_in_segment\n\ndef transform(input_grid):\n    # Convert input list to a numpy array for efficient processing\n    input_row = np.array(input_grid)\n    \n    # Initialize the output grid as a copy of the input\n    # We will modify this copy only if the transformation pattern is matched\n    output_grid = input_row.copy()\n\n    # Step 1: Find the contiguous non-white segment\n    start_index, end_index, segment = find_non_white_segment(input_row)\n\n    # Step 2: If no valid segment found, return the original grid (as a list)\n    if segment is None:\n        return output_grid.tolist()\n\n    # Step 3: Analyze the segment for the head/body pattern\n    analysis_result = analyze_segment(segment)\n\n    # Step 4: If pattern not matched within the segment, return the original grid (as a list)\n    if analysis_result is None:\n        return output_grid.tolist()\n        \n    # Extract analysis results\n    head_color, body_color, head_index_in_segment = analysis_result\n\n    # Step 5: Construct the transformed segment\n    segment_len = len(segment)\n    # Create a new array filled with the body color, preserving data type\n    transformed_segment = np.full(segment_len, body_color, dtype=segment.dtype) \n\n    # Determine the new position for the head and place it\n    if head_index_in_segment == 0:\n        # Head was at the start (index 0), move it to the end (index len-1)\n        transformed_segment[-1] = head_color\n    else: # head_index_in_segment == segment_len - 1\n        # Head was at the end (index len-1), move it to the start (index 0)\n        transformed_segment[0] = head_color\n        \n    # Step 6: Place the transformed segment back into the output grid\n    # Note: Slicing end index is exclusive, so end_index + 1 is correct\n    output_grid[start_index : end_index + 1] = transformed_segment\n\n    # Step 7: Return the modified output grid as a list\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12613,
    "candidates_token_count": 1730,
    "total_token_count": 14343,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.425909,
  "retries": 1
}