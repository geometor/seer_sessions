{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransformation Rule:\nIdentify the contiguous horizontal segment of non-white (non-zero) pixels in the input row. \nWithin this segment, find the single pixel whose color is unique compared to the others. \nMove this unique pixel to the opposite end of the segment, shifting the other pixels \n(which all share the same repeated color) accordingly. Keep the surrounding white (zero) \npixels and the colors within the segment unchanged. Return the modified grid.\n\"\"\"\n\ndef find_segment_indices(row):\n    \"\"\"\n    Finds the start and end indices of the first contiguous non-zero segment in a 1D array.\n\n    Args:\n        row: A 1D numpy array or list representing a row of pixels.\n\n    Returns:\n        A tuple (start_index, end_index). Returns (-1, -1) if no segment is found.\n    \"\"\"\n    start_index = -1\n    end_index = -1\n    in_segment = False\n    for i, pixel in enumerate(row):\n        if pixel != 0:\n            if not in_segment:\n                start_index = i\n                in_segment = True\n            end_index = i\n        elif in_segment:\n            # Found the end of the segment\n            break \n            # Optimization: if we assume only one segment exists per row based on examples\n            # we can break here. If multiple segments could exist and we only care about the\n            # first one, this break is correct. If we need to process potentially multiple\n            # segments, the logic would need extension. Based on examples, only one segment exists.\n            \n    # Handle case where segment goes to the end of the row\n    if in_segment and end_index == -1:\n         end_index = len(row) -1\n         \n    # Recalculate end_index if start was found but loop finished within segment\n    if start_index != -1 and end_index < start_index:\n         for i in range(start_index, len(row)):\n             if row[i] != 0:\n                 end_index = i\n             else:\n                 break # Stop at the first zero after start\n\n    # Final check if only start was found but no non-zero followed\n    if start_index != -1 and end_index < start_index :\n         return -1, -1 # No valid segment found\n\n    return start_index, end_index\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves a unique colored pixel within a contiguous non-zero segment \n    to the opposite end of that segment in a 1-row grid.\n\n    Args:\n        input_grid: A numpy array, expected to be 2D with shape (1, N).\n\n    Returns:\n        A numpy array with the transformed row, same shape as input.\n    \"\"\"\n    # Validate input shape - expect 2D array with 1 row\n    if not isinstance(input_grid, np.ndarray) or input_grid.ndim != 2 or input_grid.shape[0] != 1:\n        # Or handle other potential valid inputs if needed\n        # For now, assume strict adherence to the observed pattern\n        return input_grid \n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    input_row = output_grid[0] # Work directly on the row of the output grid copy\n\n    # 1. Find the start and end indices of the non-white segment\n    start, end = find_segment_indices(input_row)\n\n    # 2. If no segment is found or segment is too small, return the original grid\n    if start == -1 or (end - start + 1) < 2:\n        return output_grid\n\n    # 3. Extract the segment\n    segment = input_row[start:end+1]\n    segment_len = len(segment)\n\n    # 4. Analyze segment colors\n    color_counts = collections.Counter(segment)\n    \n    # 5. Check for the specific pattern: exactly two colors, one unique\n    unique_color = -1\n    repeated_color = -1\n    if len(color_counts) == 2:\n        for color, count in color_counts.items():\n            if count == 1:\n                unique_color = color\n            else:\n                repeated_color = color # Assumes the other color count > 1\n    \n    # 6. If the pattern doesn't match, return original\n    if unique_color == -1 or repeated_color == -1 or color_counts[repeated_color] != segment_len - 1:\n       return output_grid\n\n    # 7. Determine current position of the unique pixel\n    is_unique_at_start = (segment[0] == unique_color)\n    is_unique_at_end = (segment[-1] == unique_color)\n\n    # 8. If unique pixel is not at either end, return original (shouldn't happen based on examples)\n    if not is_unique_at_start and not is_unique_at_end:\n        return output_grid\n        \n    # 9. Construct the new segment\n    new_segment = np.zeros(segment_len, dtype=input_row.dtype)\n    num_repeated = segment_len - 1\n\n    if is_unique_at_start:\n        # Move unique pixel to the end\n        new_segment[0:num_repeated] = repeated_color\n        new_segment[num_repeated] = unique_color\n    elif is_unique_at_end:\n        # Move unique pixel to the start\n        new_segment[0] = unique_color\n        new_segment[1:segment_len] = repeated_color\n        \n    # 10. Replace the original segment with the new segment in the output row\n    output_grid[0, start:end+1] = new_segment\n\n    # 11. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10268,
    "candidates_token_count": 1379,
    "total_token_count": 11647,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.578373,
  "retries": 1
}