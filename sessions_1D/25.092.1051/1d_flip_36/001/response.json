{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies a contiguous block of non-zero colored pixels within a 1D input array (represented as a single row grid). \nThis block contains exactly two distinct non-zero colors: one appearing as a single pixel and the other as a contiguous sub-block. \nThe transformation swaps the positions of the single pixel and the contiguous sub-block within this identified region, leaving the surrounding zero (white) pixels unchanged.\n\"\"\"\n\ndef find_active_region(row):\n    \"\"\"Finds the start and end indices and content of the non-zero region.\"\"\"\n    non_zero_indices = [i for i, x in enumerate(row) if x != 0]\n    if not non_zero_indices:\n        return None, None, None  # No active region found\n    \n    start_index = min(non_zero_indices)\n    end_index = max(non_zero_indices)\n    \n    # Check for contiguity (optional but good practice)\n    if len(non_zero_indices) != (end_index - start_index + 1):\n        # This indicates gaps of zeros within the supposed active region,\n        # which contradicts the problem description's examples.\n        # Handle as an error or unexpected case if necessary.\n        # For now, we'll proceed assuming contiguity based on examples.\n        pass \n        \n    active_segment = row[start_index : end_index + 1]\n    return start_index, end_index, active_segment\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping a single pixel and a block of pixels \n    within the contiguous non-zero region of the single row.\n    \n    Args:\n        input_grid (list of lists): A grid representing the input state. \n                                     Expected to have a single row for this task.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Ensure input is treated as a NumPy array for easier slicing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Assuming the relevant data is always in the first (and only) row\n    if input_array.shape[0] != 1:\n        # Handle unexpected input dimensions if necessary\n        # For this specific task based on examples, we expect 1 row.\n        # Returning input as is or raising error might be options.\n        print(\"Warning: Expected input grid with a single row.\")\n        # Attempt to process the first row anyway\n        # return input_grid # Or raise ValueError(\"Input must be a 1xN grid\")\n        \n    row = list(input_array[0]) # Work with the first row as a list\n\n    # 1. Identify the Active Region\n    start_index, end_index, active_segment = find_active_region(row)\n\n    # If no active region, return the original grid\n    if active_segment is None:\n        return input_grid \n\n    # 2. Identify Objects within the Active Region\n    color_counts = Counter(c for c in active_segment if c != 0)\n    \n    # Validate the composition (exactly two non-zero colors)\n    if len(color_counts) != 2:\n        print(f\"Warning: Active region {active_segment} does not contain exactly two non-zero colors.\")\n        return input_grid # Return original if structure is unexpected\n\n    single_pixel_color = None\n    block_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            single_pixel_color = color\n        else:\n            block_color = color\n            block_count = count # Store the expected count for the block\n\n    # Validate identification (one single, one block)\n    if single_pixel_color is None or block_color is None:\n         print(f\"Warning: Active region {active_segment} does not contain one single pixel and one block.\")\n         return input_grid # Return original\n\n    # 3. Determine Order & 4. Perform Swap\n    # Find the index of the single pixel within the active segment\n    try:\n        single_pixel_index_in_segment = active_segment.index(single_pixel_color)\n    except ValueError:\n         # Should not happen if previous checks passed, but good practice\n         print(f\"Error: Could not find single pixel color {single_pixel_color} in segment {active_segment}.\")\n         return input_grid\n\n    swapped_active_segment = []\n    # Create the block first\n    block = [block_color] * block_count\n    \n    # Check if the single pixel was at the beginning or end\n    if single_pixel_index_in_segment == 0:\n        # Single pixel was first, put block first in output\n        swapped_active_segment.extend(block)\n        swapped_active_segment.append(single_pixel_color)\n    elif single_pixel_index_in_segment == len(active_segment) - 1:\n         # Single pixel was last, put it first in output\n        swapped_active_segment.append(single_pixel_color)\n        swapped_active_segment.extend(block)\n    else:\n        # This case (single pixel in the middle) is not covered by examples\n        # or the description of a single pixel and a *contiguous* block.\n        print(f\"Warning: Single pixel {single_pixel_color} found in the middle of the active segment {active_segment}. Unexpected.\")\n        return input_grid\n\n    # 5. Construct Output Array\n    output_row = list(row) # Create a mutable copy\n    output_row[start_index : end_index + 1] = swapped_active_segment\n    \n    # Convert back to the required grid format (list of lists)\n    output_grid = [output_row]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1958,
    "candidates_token_count": 1351,
    "total_token_count": 3309,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.204606,
  "retries": 1
}