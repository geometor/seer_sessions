{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms a 1D input grid by finding a single contiguous block of non-zero pixels.\nThis block is expected to contain exactly two colors: one 'marker' color appearing once,\nand one 'body' color appearing multiple times.\nIf the marker pixel is found at the start (leftmost position) of the block,\nit is moved to the end (rightmost position) of the block. The body pixels shift\nleftwards to fill the gap.\nThe background (zero) pixels and the overall position of the block remain unchanged.\nIf the block structure is invalid or the marker is not at the start, the original grid is returned.\n\"\"\"\n\ndef find_colored_block_indices(grid_1d):\n    \"\"\"\n    Finds the start and end indices of the first contiguous block of non-zero pixels.\n\n    Args:\n        grid_1d (np.array): A 1D numpy array representing the input grid row.\n\n    Returns:\n        tuple: A tuple containing the start and end index (inclusive) of the block.\n               Returns (-1, -1) if no non-zero block is found.\n    \"\"\"\n    non_zero_indices = np.where(grid_1d != 0)[0]\n    if len(non_zero_indices) == 0:\n        return -1, -1  # No block found\n\n    start_index = non_zero_indices[0]\n    # Find the actual end index by checking for breaks in contiguity from the start\n    end_index = start_index\n    while end_index + 1 < len(grid_1d) and grid_1d[end_index + 1] != 0:\n        end_index += 1\n        \n    return start_index, end_index\n\ndef analyze_block(block):\n    \"\"\"\n    Analyzes a block of pixels to find the marker and body colors and check structure.\n\n    Args:\n        block (np.array): The 1D numpy array representing the colored block.\n\n    Returns:\n        tuple: (marker_color, body_color, is_valid_structure)\n               marker_color: The color appearing once (-1 if none/multiple).\n               body_color: The color appearing multiple times (-1 if none/multiple).\n               is_valid_structure: True if exactly one marker and one body color found, False otherwise.\n    \"\"\"\n    if len(block) <= 1:\n        return -1, -1, False # Block too small to have distinct marker/body\n\n    color_counts = Counter(block)\n    marker_color = -1\n    body_color = -1\n    marker_found = False\n    body_found = False\n    valid_structure = True\n\n    # Check if there are exactly two distinct non-zero colors\n    non_zero_colors = [c for c in color_counts if c != 0]\n    if len(non_zero_colors) != 2:\n        return -1, -1, False\n\n    for color, count in color_counts.items():\n        if color == 0: continue # Ignore background color if somehow included\n\n        if count == 1:\n            if marker_found: # Found more than one color with count 1\n                valid_structure = False\n                break\n            marker_color = color\n            marker_found = True\n        elif count > 1:\n            if body_found: # Found more than one color with count > 1\n                valid_structure = False\n                break\n            body_color = color\n            body_found = True\n        # else: count is 0 or unexpected, handled by initial checks\n\n    # Final structure check: need exactly one marker AND one body color\n    if not (marker_found and body_found):\n        valid_structure = False\n\n    if not valid_structure:\n        return -1, -1, False\n\n    return marker_color, body_color, True\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid list.\n\n    Args:\n        input_grid_list (list): A list of integers representing the 1D input grid.\n\n    Returns:\n        list: The transformed grid as a list of integers.\n    \"\"\"\n    # Convert list to numpy array for easier manipulation\n    input_grid = np.array(input_grid_list, dtype=int)\n    \n    # Initialize output_grid as a copy of the input, returned if transformation doesn't apply\n    output_grid = np.copy(input_grid)\n\n    # 1. Locate the Object: Find the contiguous non-white block\n    start_index, end_index = find_colored_block_indices(input_grid)\n\n    # If no block is found, return the original grid\n    if start_index == -1:\n        return output_grid.tolist() # Return as list\n\n    # 2. Extract and Analyze the Object\n    colored_block = input_grid[start_index : end_index + 1]\n    block_len = len(colored_block)\n\n    marker_color, body_color, is_valid_structure = analyze_block(colored_block)\n\n    # If block structure is invalid, return the original grid\n    if not is_valid_structure:\n        return output_grid.tolist()\n\n    # 3. Check the Condition: Marker must be at the start (index 0) of the block\n    if colored_block[0] != marker_color:\n        # Condition not met, return the original grid\n        return output_grid.tolist()\n\n    # 4. Perform Transformation\n    # Create a new block filled with the body color\n    new_block = np.full(block_len, body_color, dtype=int)\n    # Place the marker color at the end\n    new_block[-1] = marker_color\n\n    # Place the reconstructed block back into the output grid\n    output_grid[start_index : end_index + 1] = new_block\n\n    # 5. Final Output: Return the modified grid as a list\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13310,
    "candidates_token_count": 1387,
    "total_token_count": 14697,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.282388,
  "retries": 1
}