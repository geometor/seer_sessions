{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\nIdentify a 'singleton' pixel (unique non-white color) and a 'block' of contiguous pixels (another non-white color) which are adjacent to each other, forming a combined contiguous 'span'. Rotate the sequence of pixels within this span by one position. If the singleton was originally at the left end of the span, rotate right (last element becomes first). If the singleton was at the right end, rotate left (first element becomes last). Place the rotated sequence back into the same span location in the output grid. Background pixels remain unchanged.\n\"\"\"\n\ndef find_span_and_singleton_pos(row):\n    \"\"\"\n    Identifies the combined span of the singleton and block, and the singleton's position.\n\n    Args:\n        row (np.array): The 1D input row.\n\n    Returns:\n        tuple: (span_start, span_end, singleton_pos) or (None, None, None) if pattern not found.\n               singleton_pos is 'left' or 'right'.\n    \"\"\"\n    non_white_indices = np.where(row != 0)[0]\n    if len(non_white_indices) < 2: # Need at least one singleton and one block pixel\n        return None, None, None\n\n    non_white_colors = row[non_white_indices]\n    color_counts = Counter(non_white_colors)\n\n    singleton_color = None\n    block_color = None\n    singleton_index = -1\n\n    # Identify singleton and block colors\n    for color, count in color_counts.items():\n        if count == 1:\n            if singleton_color is not None: return None, None, None # More than one singleton type\n            singleton_color = color\n        else: # count > 1 implies block color (assuming only 2 non-white colors)\n             if block_color is not None: return None, None, None # More than one block type\n             block_color = color\n\n    if singleton_color is None or block_color is None:\n        return None, None, None # Pattern needs one singleton and one block\n\n    # Find the index of the singleton\n    try:\n        # Find the index within the non_white_indices array first\n        s_idx_in_non_white = np.where(non_white_colors == singleton_color)[0][0]\n        singleton_index = non_white_indices[s_idx_in_non_white]\n    except IndexError:\n        return None, None, None # Should not happen if color_counts was correct\n\n    # Determine span boundaries (min and max of all non-white indices)\n    span_start = np.min(non_white_indices)\n    span_end = np.max(non_white_indices)\n\n    # Verify combined span contiguity\n    expected_len = span_end - span_start + 1\n    if len(non_white_indices) != expected_len:\n        # Implies gaps or non-contiguity of the combined object\n        return None, None, None\n\n    # Determine singleton position within the span\n    if singleton_index == span_start:\n        singleton_pos = 'left'\n    elif singleton_index == span_end:\n        singleton_pos = 'right'\n    else:\n        # Singleton is not at either end, which contradicts the observed pattern\n        return None, None, None\n\n    return span_start, span_end, singleton_pos\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the span rotation transformation to the input grid.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n                                     Expected to be effectively 1D (1 row).\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # --- Input Validation and Initialization ---\n    if not isinstance(input_grid, list) or not input_grid:\n        return [] # Handle empty input\n    if len(input_grid) != 1:\n         # This specific task seems focused on 1-row grids based on examples.\n         # If multi-row grids were possible, logic would need adjustment.\n         # For now, assume valid input is 1xN. Return original if not.\n         print(\"Warning: Input grid has more than one row. Returning original.\")\n         return input_grid\n    if not isinstance(input_grid[0], list):\n         return [] # Handle malformed input\n\n    input_row = np.array(input_grid[0])\n    output_row = input_row.copy() # Create a copy to modify\n\n    # --- Find the Span and Singleton Position ---\n    span_start, span_end, singleton_pos = find_span_and_singleton_pos(output_row)\n\n    # If the expected pattern (singleton + adjacent block) isn't found, return original\n    if span_start is None:\n        # print(\"Pattern (singleton adjacent to block) not found. Returning original.\")\n        return input_grid\n\n    # --- Extract and Rotate the Span ---\n    # Extract the sequence of pixels within the identified span\n    span_sequence = output_row[span_start : span_end + 1]\n\n    # Perform rotation based on the singleton's original position\n    rotated_sequence = np.zeros_like(span_sequence)\n    if singleton_pos == 'left':\n        # Rotate right: last element moves to the first position\n        rotated_sequence = np.roll(span_sequence, 1)\n    elif singleton_pos == 'right':\n        # Rotate left: first element moves to the last position\n        rotated_sequence = np.roll(span_sequence, -1)\n    else:\n         # Should not happen due to checks in find_span_and_singleton_pos\n         print(\"Error: Invalid singleton position detected.\")\n         return input_grid # Return original on error\n\n    # --- Update Output Grid ---\n    # Place the rotated sequence back into the output row at the original span location\n    output_row[span_start : span_end + 1] = rotated_sequence\n\n    # --- Format and Return Output ---\n    # Convert the modified numpy row back to a list and wrap in a list\n    output_grid = [output_row.tolist()]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8720,
    "candidates_token_count": 1432,
    "total_token_count": 10152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.478479,
  "retries": 1
}