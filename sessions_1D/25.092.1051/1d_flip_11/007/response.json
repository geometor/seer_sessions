{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\nIdentify a contiguous horizontal span of non-white pixels (colors other than 0) \nin the input row. This span must satisfy several conditions:\n1. It must be truly contiguous (no background pixels within).\n2. It must consist of exactly two distinct non-white colors.\n3. One of these colors (the 'singleton') must appear exactly once within the span.\n4. The other color (the 'block') must appear one or more times within the span.\n5. The singleton pixel must be located at either the leftmost or the rightmost \n   position of this contiguous span.\n\nIf all these conditions are met, the transformation involves performing a \ncircular shift (numpy.roll) on the sequence of pixels *within the identified span*.\n- If the singleton pixel was originally at the left end of the span, the sequence \n  is shifted LEFT by one position (np.roll(sequence, -1)).\n- If the singleton pixel was originally at the right end of the span, the sequence \n  is shifted RIGHT by one position (np.roll(sequence, 1)).\n\nThe resulting shifted sequence replaces the original sequence within the span's \nlocation in the output grid. All pixels outside this span (background pixels) \nremain unchanged. If the input does not match the described pattern, the original \ninput grid is returned.\n\"\"\"\n\ndef _find_span_and_singleton_pos(row):\n    \"\"\"\n    Identifies the contiguous non-white span, its boundaries, and the singleton's position.\n\n    Args:\n        row (np.array): The 1D input row.\n\n    Returns:\n        tuple: (span_start, span_end, singleton_pos) or (None, None, None) if pattern not found.\n               singleton_pos is 'left' or 'right'. Returns None if conditions (contiguity, \n               exactly one singleton at an end, exactly two colors) are not met.\n    \"\"\"\n    # Find indices of all non-white pixels (colors != 0)\n    non_white_indices = np.where(row != 0)[0]\n\n    # Check if there are at least two non-white pixels needed for a singleton and a block\n    if len(non_white_indices) < 2:\n        # print(\"Debug: Less than 2 non-white pixels.\")\n        return None, None, None\n\n    # Determine the potential start and end of the contiguous span\n    span_start = np.min(non_white_indices)\n    span_end = np.max(non_white_indices)\n\n    # Verify that the identified span is truly contiguous (no background pixels within)\n    # The number of non-white pixels must equal the length of the span\n    expected_len = span_end - span_start + 1\n    if len(non_white_indices) != expected_len:\n        # print(f\"Debug: Non-contiguity detected. Span {span_start}-{span_end}, Expected len {expected_len}, Actual non-white count {len(non_white_indices)}\")\n        # Implies gaps (background pixels) within the span\n        return None, None, None\n\n    # Extract the sequence of pixels within the span\n    span_sequence = row[span_start : span_end + 1]\n\n    # Count the occurrences of each color within the span\n    color_counts = Counter(span_sequence)\n\n    # Verify exactly two distinct non-white colors exist in the span\n    if len(color_counts) != 2:\n        # print(f\"Debug: Expected 2 distinct colors in span, found {len(color_counts)}: {color_counts}\")\n        return None, None, None\n        \n    # Identify the singleton color (the one with count 1)\n    singleton_color = None\n    block_color = None\n    singleton_count_check = 0\n    block_color_check = None # Store the color identified as block\n\n    for color, count in color_counts.items():\n        if count == 1:\n            singleton_count_check += 1\n            singleton_color = color # Assign the color with count 1\n        elif count > 1:\n            block_color_check = color # Assign potential block color\n        # else count == 0? Should not happen with Counter on span_sequence\n\n    # Verify exactly one singleton color and infer block color\n    if singleton_count_check != 1:\n        # print(f\"Debug: Expected exactly 1 singleton color, found check count {singleton_count_check}\")\n        return None, None, None\n    \n    # The block color must be the other color present\n    block_color = block_color_check # Assign confirmed block color\n    if block_color is None:\n         # This case implies the counts were {color_A: 1, color_B: 1}, handled by len(color_counts) != 2?\n         # Let's double check. If span is [7, 6], counts are {7:1, 6:1}. len=2. singleton_count_check=2 -> returns None. Correct.\n         # If span is [7, 7], counts is {7:2}. len=1 -> returns None. Correct.\n         # If span is [7, 6, 6], counts {7:1, 6:2}. len=2. s_count=1, b_color=6. block_color gets 6. Correct.\n         # If span is [7, 7, 6], counts {7:2, 6:1}. len=2. s_count=1, s_color=6, b_color=7. block_color gets 7. Correct.\n         # If block_color is None here, it means no color had count > 1, which was covered by the s_count!=1 check if len==2.\n         # print(f\"Debug: Could not definitively identify block color.\") # Should be unreachable\n         return None, None, None\n\n\n    # Determine singleton position ('left' or 'right') based on its index in the original row\n    singleton_pos = None\n    if row[span_start] == singleton_color:\n        singleton_pos = 'left'\n    elif row[span_end] == singleton_color:\n        singleton_pos = 'right'\n    else:\n         # Singleton is not at either end of the span, pattern mismatch\n         # print(f\"Debug: Singleton color {singleton_color} not found at ends ({span_start}, {span_end}) of span.\")\n         return None, None, None\n\n    # If all checks passed, return the span boundaries and singleton position\n    # print(f\"Debug: Found pattern: Span {span_start}-{span_end}, Singleton Pos: {singleton_pos}\")\n    return span_start, span_end, singleton_pos\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the span rotation transformation to the input grid.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n                                     Expected to be effectively 1D (1 row).\n\n    Returns:\n        list of lists: The transformed grid, or the original grid if the\n                       specific pattern is not found.\n    \"\"\"\n    # --- Input Validation and Initialization ---\n    if not isinstance(input_grid, list) or not input_grid:\n        # print(\"Warning: Input grid is not a list or is empty.\")\n        return input_grid # Return original for invalid input format\n\n    if len(input_grid) < 1:\n         # print(\"Warning: Input grid has no rows.\")\n         return input_grid # Return original\n\n    if len(input_grid) > 1:\n        # print(\"Warning: Input grid has more than one row. This function expects a single row. Returning original.\")\n        return input_grid # This task seems constrained to 1 row based on examples\n\n    if not isinstance(input_grid[0], list):\n         # print(\"Warning: First element of input grid is not a list.\")\n         return input_grid # Return original for malformed input\n\n    # Convert the first (and only) row to a NumPy array for efficient processing\n    input_row = np.array(input_grid[0])\n    # Create a copy of the input row to modify for the output\n    output_row = input_row.copy()\n\n    # --- Find the Span and Singleton Position ---\n    # Call the helper function to identify the relevant pattern components\n    span_start, span_end, singleton_pos = _find_span_and_singleton_pos(output_row) # Use output_row for analysis is fine as it's a copy\n\n    # If the expected pattern (contiguous span, 2 colors, singleton at end) isn't found,\n    # the helper returns None. In this case, return the original grid unchanged.\n    if span_start is None:\n        # print(\"Pattern not found. Returning original grid.\") # Optional debug message\n        return input_grid\n\n    # --- Extract and Rotate the Span ---\n    # Extract the sequence of pixels within the identified span from the *output* row (which we will modify)\n    span_sequence = output_row[span_start : span_end + 1]\n\n    # Perform circular shift (roll) based on the singleton's original position\n    rotated_sequence = None\n    if singleton_pos == 'left':\n        # If singleton was on the left, roll the sequence LEFT by 1\n        # Example: [S, B, B] -> [B, B, S] (roll amount = -1)\n        # print(f\"Debug: Rolling left (amount -1) on sequence: {span_sequence.tolist()}\")\n        rotated_sequence = np.roll(span_sequence, -1)\n    elif singleton_pos == 'right':\n        # If singleton was on the right, roll the sequence RIGHT by 1\n        # Example: [B, B, S] -> [S, B, B] (roll amount = 1)\n        # print(f\"Debug: Rolling right (amount 1) on sequence: {span_sequence.tolist()}\")\n        rotated_sequence = np.roll(span_sequence, 1)\n    # No else needed as singleton_pos is guaranteed 'left' or 'right' if span_start is not None\n\n    # --- Update Output Grid ---\n    # Place the rotated sequence back into the output row at the original span location\n    if rotated_sequence is not None:\n         # print(f\"Debug: Placing rotated sequence {rotated_sequence.tolist()} into slice {span_start}:{span_end + 1}\")\n         output_row[span_start : span_end + 1] = rotated_sequence\n    else:\n         # Should not happen if logic above is correct\n         # print(\"Error: Rotation failed unexpectedly.\")\n         return input_grid # Return original if rotation somehow failed\n\n    # --- Format and Return Output ---\n    # Convert the modified numpy row back to a list\n    output_list = output_row.tolist()\n    # Wrap the list in another list to match the required output format [[]]\n    output_grid = [output_list]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11447,
    "candidates_token_count": 2542,
    "total_token_count": 13989,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.551923,
  "retries": 1
}