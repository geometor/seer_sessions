{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\nIdentify a contiguous horizontal span of non-white pixels in the input row. \nThis span must consist of exactly two colors: one 'singleton' color appearing once, \nand one 'block' color appearing one or more times. The singleton pixel must be \nlocated at either the leftmost or rightmost position within this span. \nThe transformation involves performing a circular shift (roll) on the sequence of pixels \nwithin the span. If the singleton was originally at the left end, roll the sequence \nleft by one position. If the singleton was originally at the right end, roll the \nsequence right by one position. Place the rolled sequence back into the same span \nlocation in the output grid. Background pixels (color 0) remain unchanged.\n\"\"\"\n\ndef find_span_and_singleton_pos(row):\n    \"\"\"\n    Identifies the contiguous non-white span, its boundaries, and the singleton's position.\n\n    Args:\n        row (np.array): The 1D input row.\n\n    Returns:\n        tuple: (span_start, span_end, singleton_pos) or (None, None, None) if pattern not found.\n               singleton_pos is 'left' or 'right'. Returns None if conditions (contiguity, \n               exactly one singleton at an end, exactly two colors) are not met.\n    \"\"\"\n    # Find indices of all non-white pixels (colors != 0)\n    non_white_indices = np.where(row != 0)[0]\n\n    # Check if there are at least two non-white pixels needed for a singleton and a block\n    if len(non_white_indices) < 2:\n        return None, None, None\n\n    # Determine the potential start and end of the contiguous span\n    span_start = np.min(non_white_indices)\n    span_end = np.max(non_white_indices)\n\n    # Verify that the identified span is truly contiguous (no background pixels within)\n    # The number of non-white pixels must equal the length of the span\n    expected_len = span_end - span_start + 1\n    if len(non_white_indices) != expected_len:\n        # Implies gaps (background pixels) within the span\n        return None, None, None\n\n    # Extract the sequence of pixels within the span\n    span_sequence = row[span_start : span_end + 1]\n\n    # Count the occurrences of each color within the span\n    color_counts = Counter(span_sequence)\n\n    # Verify exactly two distinct non-white colors exist in the span\n    if len(color_counts) != 2:\n        return None, None, None\n        \n    # Identify the singleton color (the one with count 1)\n    singleton_color = None\n    block_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            if singleton_color is not None: # Found more than one color with count 1\n                 return None, None, None\n            singleton_color = color\n        else: # Must be the block color (count > 1)\n             if block_color is not None: # Found more than one color with count > 1\n                 return None, None, None\n             block_color = color\n\n    # Check if we successfully identified one singleton and one block color\n    if singleton_color is None or block_color is None:\n        return None, None, None\n\n    # Find the index of the singleton *within the original row*\n    # We know its color, find where it is located between span_start and span_end\n    singleton_index_in_row = -1\n    if row[span_start] == singleton_color:\n        singleton_index_in_row = span_start\n    elif row[span_end] == singleton_color:\n        singleton_index_in_row = span_end\n    else:\n         # Singleton is not at either end of the span, pattern mismatch\n         return None, None, None\n\n    # Determine singleton position ('left' or 'right') based on its index in the row\n    if singleton_index_in_row == span_start:\n        singleton_pos = 'left'\n    elif singleton_index_in_row == span_end:\n        singleton_pos = 'right'\n    else:\n        # This case should technically be caught above, but double-check\n        return None, None, None\n\n    # If all checks passed, return the span boundaries and singleton position\n    return span_start, span_end, singleton_pos\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the span rotation transformation to the input grid.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n                                     Expected to be effectively 1D (1 row).\n\n    Returns:\n        list of lists: The transformed grid, or the original grid if the\n                       specific pattern is not found.\n    \"\"\"\n    # --- Input Validation and Initialization ---\n    # Check if input is a list and not empty\n    if not isinstance(input_grid, list) or not input_grid:\n        print(\"Warning: Input grid is not a list or is empty.\")\n        return input_grid # Return original for invalid input format\n\n    # Check if it contains at least one row\n    if len(input_grid) < 1:\n         print(\"Warning: Input grid has no rows.\")\n         return input_grid # Return original\n\n    # This task specifically targets 1-row grids based on examples.\n    # Handle multi-row inputs by returning original or raising error if needed.\n    if len(input_grid) > 1:\n        print(\"Warning: Input grid has more than one row. This function expects a single row. Returning original.\")\n        return input_grid\n\n    # Check if the first row is a list\n    if not isinstance(input_grid[0], list):\n         print(\"Warning: First element of input grid is not a list.\")\n         return input_grid # Return original for malformed input\n\n    # Convert the first (and only) row to a NumPy array for efficient processing\n    input_row = np.array(input_grid[0])\n    # Create a copy of the input row to modify for the output\n    output_row = input_row.copy()\n\n    # --- Find the Span and Singleton Position ---\n    # Call the helper function to identify the relevant pattern components\n    span_start, span_end, singleton_pos = find_span_and_singleton_pos(output_row)\n\n    # If the expected pattern (contiguous span, 2 colors, singleton at end) isn't found,\n    # the helper returns None. In this case, return the original grid unchanged.\n    if span_start is None:\n        # print(\"Pattern not found. Returning original grid.\") # Optional debug message\n        return input_grid\n\n    # --- Extract and Rotate the Span ---\n    # Extract the sequence of pixels within the identified span\n    span_sequence = output_row[span_start : span_end + 1]\n\n    # Perform circular shift (roll) based on the singleton's original position\n    rotated_sequence = None\n    if singleton_pos == 'left':\n        # If singleton was on the left, roll the sequence LEFT by 1\n        # Example: [S, B, B] -> [B, B, S]\n        rotated_sequence = np.roll(span_sequence, -1)\n    elif singleton_pos == 'right':\n        # If singleton was on the right, roll the sequence RIGHT by 1\n        # Example: [B, B, S] -> [S, B, B]\n        rotated_sequence = np.roll(span_sequence, 1)\n    # else: # This case is prevented by checks in find_span_and_singleton_pos\n        # print(\"Error: Invalid singleton position detected after check.\")\n        # return input_grid # Return original on internal error\n\n\n    # --- Update Output Grid ---\n    # Place the rotated sequence back into the output row at the original span location\n    if rotated_sequence is not None:\n         output_row[span_start : span_end + 1] = rotated_sequence\n    else:\n         # Should not happen if singleton_pos is 'left' or 'right'\n         print(\"Error: Rotation failed.\")\n         return input_grid # Return original if rotation calculation failed\n\n    # --- Format and Return Output ---\n    # Convert the modified numpy row back to a list\n    output_list = output_row.tolist()\n    # Wrap the list in another list to match the required output format [[]]\n    output_grid = [output_list]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8960,
    "candidates_token_count": 1981,
    "total_token_count": 10941,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.84613,
  "retries": 1
}