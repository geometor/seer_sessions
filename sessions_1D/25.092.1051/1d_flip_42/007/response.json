{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 1xN grid by finding a specific pattern: a single non-white 'marker' pixel adjacent to a contiguous block of a different non-white color. This pattern must be bounded by white (0) pixels or grid edges. The transformation swaps the marker and the block: the block shifts one position left to occupy the marker's original position, and the marker moves to the position immediately following the block's original end position.\n\"\"\"\n\ndef find_marker_and_block_1d(grid_1d):\n    \"\"\"\n    Scans a 1D numpy array to find the unique marker pixel and the adjacent block,\n    checking boundary conditions.\n\n    Args:\n        grid_1d (np.array): The 1D input grid row.\n\n    Returns:\n        tuple: (marker_color, marker_index, block_color, block_end_index)\n               Returns (None, -1, None, -1) if the specific pattern is not found.\n    \"\"\"\n    n = len(grid_1d)\n    # Iterate through potential marker positions (up to second to last element)\n    for i in range(n - 1):\n        # Condition 1 & 2: Current pixel is non-white (marker), next is non-white and DIFFERENT color (start of block)\n        if grid_1d[i] != 0 and grid_1d[i+1] != 0 and grid_1d[i] != grid_1d[i+1]:\n            \n            # Condition 3: Marker is at the start OR preceded by white\n            is_left_boundary_ok = (i == 0) or (grid_1d[i-1] == 0)\n            \n            if is_left_boundary_ok:\n                # Potential pattern found, identify components\n                marker_color = grid_1d[i]\n                marker_index = i\n                block_color = grid_1d[i+1]\n                block_start_index = i + 1\n                block_end_index = block_start_index # Initialize block end index\n\n                # Find the actual end of the contiguous block of 'block_color'\n                for j in range(block_start_index + 1, n):\n                    if grid_1d[j] == block_color:\n                        block_end_index = j\n                    else:\n                        break # Block sequence ended\n\n                # Condition 4: Block is at the end OR followed by white\n                # Ensure check doesn't go out of bounds if block ends at the last pixel\n                is_right_boundary_ok = (block_end_index == n - 1) or \\\n                                       (block_end_index + 1 < n and grid_1d[block_end_index + 1] == 0)\n\n                if is_right_boundary_ok:\n                    # All conditions met, found the unique pattern\n                    return marker_color, marker_index, block_color, block_end_index\n\n    # If loop finishes without returning, the specific pattern was not found\n    return None, -1, None, -1\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping the marker pixel and the adjacent block.\n\n    Args:\n        input_grid (list or np.ndarray): A list of lists or numpy array representing the 1xN input grid.\n\n    Returns:\n        list or np.ndarray: The transformed grid in the same format as the input.\n    \"\"\"\n    # Convert input to NumPy array for processing, ensure integer type\n    if isinstance(input_grid, list):\n        input_array = np.array(input_grid, dtype=int)\n    elif isinstance(input_grid, np.ndarray):\n        input_array = input_grid.astype(int) \n    else:\n        raise TypeError(\"Input grid must be a list of lists or a NumPy array.\")\n\n    # Ensure the input is treated as 2D (e.g., 1xN)\n    if input_array.ndim == 1:\n         # Reshape 1D array like [0, 3, 1, 1, 0] to 2D [[0, 3, 1, 1, 0]]\n         input_array = input_array.reshape(1, -1)\n         \n    # Verify shape is 1xN (or handle MxN if needed, though examples are 1xN)\n    if input_array.shape[0] != 1:\n         # For this specific task based on examples, we expect 1xN.\n         # If other shapes were possible, logic would need adjustment.\n         print(f\"Warning: Expected input shape 1xN, but got {input_array.shape}. Processing first row only.\")\n         # Decide how to handle: proceed with row 0, return original, or raise error.\n         # Proceeding with row 0 based on task structure.\n\n    # Extract the first (and only relevant) row for processing\n    grid_1d = input_array[0]\n\n    # Find the marker and block details using the helper function\n    marker_color, marker_index, block_color, block_end_index = find_marker_and_block_1d(grid_1d)\n\n    # If the specific marker/block pattern wasn't found, return the original grid\n    if marker_index == -1:\n        # Return in the original format\n        if isinstance(input_grid, list):\n            return input_grid\n        else:\n            # Return original numpy array (potentially reshaped if input was 1D)\n            return input_array \n\n    # Create a copy of the input array to modify for the output\n    output_array = np.copy(input_array)\n\n    # Calculate block properties\n    block_start_index = marker_index + 1\n    block_length = block_end_index - block_start_index + 1\n    \n    # Calculate the new index for the marker (position after original block end)\n    new_marker_index = block_end_index + 1\n\n    # Perform the swap transformation on the output array:\n    # 1. Copy the block pixels to the marker's original starting position\n    output_array[0, marker_index : marker_index + block_length] = block_color\n    \n    # 2. Place the marker pixel at the position after the block's original end position\n    # Check bounds before placing the marker, although find_marker_and_block should ensure validity\n    if new_marker_index < output_array.shape[1]:\n        output_array[0, new_marker_index] = marker_color\n    else:\n        # This path indicates an issue, either in pattern finding or unexpected input structure.\n        print(f\"Warning: Calculated new marker position {new_marker_index} is out of bounds for grid width {output_array.shape[1]}. Returning original grid.\")\n        if isinstance(input_grid, list):\n            return input_grid\n        else:\n            return input_array\n\n    # Return the result in the same format as the input\n    if isinstance(input_grid, list):\n        # If original input was list of lists or 1D list reshaped internally\n        return output_array.tolist()\n    else:\n        # If original input was numpy array\n        return output_array\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9732,
    "candidates_token_count": 1677,
    "total_token_count": 11409,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.550503,
  "retries": 1
}