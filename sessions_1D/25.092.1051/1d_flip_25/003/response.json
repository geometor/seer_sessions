{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\nSwap the position of a unique singleton pixel with the last pixel (in reading order) \nof an adjacent block within a 2D grid. The input is expected as a 2D structure \n(e.g., numpy array), and the output should be a flattened 1D list.\n\n1. Receive the input grid as a 2D structure.\n2. Determine the dimensions (height, width) of the input grid.\n3. Identify the \"singleton\" pixel: Find the pixel whose color value (ignoring the \n   background color 0) appears only once in the entire grid. Record its color \n   and location (row, column).\n4. Identify the \"block color\": Examine the neighbors (including diagonals, 8-connectivity) \n   of the singleton pixel. Find the color of the first neighbor encountered that is \n   neither the background color (0) nor the singleton's color. This is the color \n   of the adjacent block.\n5. Determine the \"last block pixel\" location: Scan the grid row by row, from top \n   to bottom, and within each row, column by column, from left to right. Record \n   the location (row, column) of the *last* pixel found that matches the identified \n   block color.\n6. Perform the swap: Create a copy of the input grid to serve as the output grid. \n   In the output grid, set the color of the pixel at the singleton's original location \n   to the block color. Set the color of the pixel at the last block pixel's location \n   to the singleton's color.\n7. Flatten the modified 2D output grid into a 1D list for the final output.\n\"\"\"\n\nimport numpy as np\n\ndef _find_singleton(grid):\n    \"\"\"Finds the color and location of the pixel appearing exactly once (excluding background 0).\"\"\"\n    # Flatten grid excluding background 0 to count non-background colors\n    non_background_pixels = grid[grid != 0]\n    if non_background_pixels.size == 0:\n        raise ValueError(\"Grid contains only background color 0.\")\n        \n    colors, counts = np.unique(non_background_pixels, return_counts=True)\n    \n    # Find colors that appear exactly once\n    singleton_color_candidates = colors[counts == 1]\n    \n    if len(singleton_color_candidates) == 0:\n        raise ValueError(\"Could not find any unique non-background color (singleton).\")\n    if len(singleton_color_candidates) > 1:\n         # This could happen if there are multiple distinct single pixels. \n         # The prompt examples only show one. Assume the first found is the target.\n         # Or, raise an error if the definition implies strictly one possible singleton.\n         # Let's stick to the assumption based on examples: there's exactly one.\n         raise ValueError(\"Found multiple unique non-background colors. Ambiguous singleton.\")\n         \n    singleton_color = singleton_color_candidates[0]\n    \n    # Find the location of this unique color\n    locations = np.argwhere(grid == singleton_color)\n    \n    # Should be exactly one location based on the count check\n    if len(locations) != 1:\n         # This is an internal consistency check, should not happen if count logic is right.\n        raise ValueError(f\"Internal error: Found {len(locations)} locations for singleton color {singleton_color}.\")\n        \n    singleton_loc = tuple(locations[0]) # (row, col)\n    return singleton_color, singleton_loc\n\ndef _find_adjacent_block_color(grid, singleton_loc):\n    \"\"\"Finds the color of the block adjacent (8-connectivity) to the singleton.\"\"\"\n    rows, cols = grid.shape\n    sr, sc = singleton_loc\n    singleton_color = grid[sr, sc]\n    \n    # Check 8 neighbors\n    for r_offset in [-1, 0, 1]:\n        for c_offset in [-1, 0, 1]:\n            # Skip the singleton's own location\n            if r_offset == 0 and c_offset == 0:\n                continue \n            \n            nr, nc = sr + r_offset, sc + c_offset\n            \n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_color = grid[nr, nc]\n                # Check if the neighbor is not background and not the singleton itself\n                if neighbor_color != 0 and neighbor_color != singleton_color:\n                    # Found the color of the adjacent block\n                    return neighbor_color \n                    \n    # If no adjacent block color found after checking all neighbors\n    raise ValueError(\"Could not find an adjacent block color (non-background, non-singleton) for the singleton.\")\n\n\ndef _find_last_block_pixel_loc(grid, block_color):\n    \"\"\"Finds the location (row, col) of the last pixel with the block color in reading order.\"\"\"\n    rows, cols = grid.shape\n    last_loc = None\n    # Iterate row by row, then column by column\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == block_color:\n                # Update last_loc every time we find the block color\n                last_loc = (r, c) \n    \n    # If we never found the block color\n    if last_loc is None:\n         raise ValueError(f\"Could not find any pixels with the block color {block_color}.\")\n         \n    return last_loc\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by swapping a unique singleton pixel with the \n    last pixel (reading order) of an adjacent block.\n    Args:\n        input_grid (numpy.ndarray): A 2D numpy array representing the input grid.\n    Returns:\n        list: A flattened 1D list representing the transformed grid.\n    \"\"\"\n    # Ensure input is a numpy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n        \n    if input_grid.ndim != 2:\n         raise ValueError(f\"Input grid must be 2-dimensional, but got {input_grid.ndim} dimensions.\")\n\n    # Create the output grid as a copy to modify\n    output_grid = np.copy(input_grid)\n\n    # --- Identify Key Elements ---\n    # Step 3: Find the singleton pixel's color and location\n    singleton_color, singleton_loc = _find_singleton(input_grid)\n    \n    # Step 4: Find the color of the adjacent block\n    block_color = _find_adjacent_block_color(input_grid, singleton_loc)\n    \n    # Step 5: Find the location of the last pixel belonging to the block (in reading order)\n    last_block_loc = _find_last_block_pixel_loc(input_grid, block_color)\n\n    # --- Perform the Transformation ---\n    # Step 6: Swap the colors at the singleton location and the last block pixel location\n    # Set the original singleton location to the block's color\n    output_grid[singleton_loc] = block_color \n    # Set the last block pixel's location to the singleton's color\n    output_grid[last_block_loc] = singleton_color\n\n    # --- Output Formatting ---\n    # Step 7: Flatten the grid back to a 1D list\n    output_grid_flat = output_grid.flatten().tolist()\n    \n    return output_grid_flat\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7180,
    "candidates_token_count": 1743,
    "total_token_count": 8923,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.530647,
  "retries": 1
}