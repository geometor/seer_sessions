{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms a grid by analyzing connected components of green (3) pixels.\n\n1. Find all distinct connected components (objects) of green (3) pixels.\n2. For each green object:\n   a. Check if it forms a solid rectangle (pixel count equals bounding box area).\n   b. If it's a solid rectangle, change all its pixels to blue (1) in the output.\n   c. If it's not a solid rectangle:\n      i. Find all maximal horizontal segments of green pixels within the object.\n      ii. For each segment:\n         - If its length is 2 or 4, change its pixels to blue (1) in the output.\n         - Otherwise, change its pixels to gray (5) in the output.\n3. Keep all other pixels (background white 0) unchanged.\n\"\"\"\n\ndef find_connected_components(grid, color):\n    \"\"\"\n    Finds connected components of a specific color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the components to find.\n\n    Returns:\n        list: A list of lists, where each inner list contains the\n              coordinates (row, col) of the pixels belonging to one component.\n              Returns an empty list if no components are found.\n    \"\"\"\n    binary_grid = (grid == color).astype(int)\n    labeled_grid, num_features = label(binary_grid)\n\n    if num_features == 0:\n        return []\n\n    components = []\n    # find_objects returns slices, need to convert to coordinates\n    slices = find_objects(labeled_grid)\n    for i in range(num_features):\n        coords = []\n        component_slice = slices[i]\n        # Extract the subgrid corresponding to the labeled component\n        subgrid = labeled_grid[component_slice]\n        # Find coordinates within the subgrid where the label matches\n        relative_coords = np.argwhere(subgrid == (i + 1))\n        # Convert relative coordinates to absolute coordinates in the original grid\n        for r, c in relative_coords:\n            coords.append((component_slice[0].start + r, component_slice[1].start + c))\n        if coords: # Ensure component is not empty (shouldn't happen with find_objects but good practice)\n             components.append(coords)\n             \n    return components\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box of a set of coordinates.\"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return min_r, min_c, max_r, max_c\n\ndef is_solid_rectangle(coords, bounding_box):\n    \"\"\"Checks if a component fills its bounding box.\"\"\"\n    if not coords or bounding_box is None:\n        return False\n    min_r, min_c, max_r, max_c = bounding_box\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return len(coords) == height * width\n\ndef find_horizontal_segments(coords):\n    \"\"\"Finds maximal horizontal segments within a set of coordinates.\"\"\"\n    if not coords:\n        return []\n\n    segments = []\n    # Group coordinates by row\n    coords_by_row = {}\n    for r, c in coords:\n        if r not in coords_by_row:\n            coords_by_row[r] = []\n        coords_by_row[r].append(c)\n\n    # Find segments in each row\n    for r, cols in coords_by_row.items():\n        if not cols:\n            continue\n        cols.sort()\n        current_segment = [(r, cols[0])]\n        for i in range(1, len(cols)):\n            # Check if the current column is adjacent to the previous one\n            if cols[i] == cols[i-1] + 1:\n                current_segment.append((r, cols[i]))\n            else:\n                # End of the current segment, start a new one\n                segments.append(current_segment)\n                current_segment = [(r, cols[i])]\n        # Add the last segment\n        segments.append(current_segment)\n\n    return segments\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    target_color = 3 # green\n    rect_color = 1 # blue\n    seg_2_4_color = 1 # blue\n    other_seg_color = 5 # gray\n\n    # Find all green connected components\n    green_components = find_connected_components(input_grid, target_color)\n\n    # Process each component\n    for component_coords in green_components:\n        if not component_coords:\n            continue\n\n        # Calculate bounding box\n        bbox = get_bounding_box(component_coords)\n\n        # Check if it's a solid rectangle (Rule 1)\n        if is_solid_rectangle(component_coords, bbox):\n            for r, c in component_coords:\n                output_grid[r, c] = rect_color\n        else:\n            # Not a solid rectangle, process horizontal segments (Rule 2)\n            horizontal_segments = find_horizontal_segments(component_coords)\n            for segment in horizontal_segments:\n                segment_len = len(segment)\n                # Determine the color based on segment length\n                color_to_set = seg_2_4_color if segment_len == 2 or segment_len == 4 else other_seg_color\n                # Apply the color to the pixels in the segment\n                for r, c in segment:\n                    output_grid[r, c] = color_to_set\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2464,
    "candidates_token_count": 1438,
    "total_token_count": 3902,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.040735,
  "retries": 1
}