{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nfrom typing import Set, Tuple\n\n\"\"\"\nRecolor distinct red(2) objects based on scanning order.\nThe object containing the first red pixel encountered during a top-to-bottom, \nleft-to-right scan is recolored to maroon(9). All other distinct red objects \nare recolored to orange(7). White(0) pixels remain unchanged. \nContiguity for objects is defined by 8-way adjacency (including diagonals).\n\"\"\"\n\ndef _find_object_bfs(grid: np.ndarray, start_r: int, start_c: int, visited: np.ndarray) -> Set[Tuple[int, int]]:\n    \"\"\"\n    Finds all connected pixels of the same color as the starting pixel\n    using Breadth-First Search (BFS) with 8-way adjacency. Marks visited\n    pixels in the `visited` array.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        start_r (int): The starting row index.\n        start_c (int): The starting column index.\n        visited (np.ndarray): A boolean grid of the same shape as grid,\n                              marking visited pixels. Modified in place.\n\n    Returns:\n        set: A set of tuples (row, col) representing the coordinates of\n             all pixels belonging to the connected object. Returns an empty\n             set if the starting pixel is invalid or already visited.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Basic validation and check if already visited\n    if not (0 <= start_r < height and 0 <= start_c < width) or visited[start_r, start_c]:\n       return set() \n\n    target_color = grid[start_r, start_c]\n    object_coords = set()\n    \n    # Define 8 directions for adjacency (including diagonals)\n    directions = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),          (0, 1),\n        (1, -1), (1, 0), (1, 1)\n    ]\n\n    # Use a deque for BFS queue\n    queue = deque([(start_r, start_c)])\n\n    # Mark the starting pixel as visited and add to the object\n    visited[start_r, start_c] = True\n    object_coords.add((start_r, start_c))\n\n    while queue:\n        r, c = queue.popleft()\n\n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check boundaries\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if neighbor is the target color and not visited\n                if grid[nr, nc] == target_color and not visited[nr, nc]:\n                    visited[nr, nc] = True # Mark as visited\n                    object_coords.add((nr, nc)) # Add to current object\n                    queue.append((nr, nc)) # Add to queue for exploration\n\n    return object_coords\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by recoloring red(2) objects based on scan order.\n    The first encountered red object (top-to-bottom, left-to-right) is colored \n    maroon(9), others are colored orange(7). White(0) pixels are unchanged.\n\n    Args:\n        input_grid (np.ndarray): The 2D input grid containing integers 0-9.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input to preserve non-red pixels\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Keep track of visited pixels to avoid processing parts of the same object multiple times\n    visited = np.zeros((height, width), dtype=bool)\n\n    # Store coordinates of the first object and others separately\n    first_object_coords = set()\n    other_objects_coords = set()\n    first_object_found = False\n\n    # Iterate through the grid, top-to-bottom, left-to-right\n    for r in range(height):\n        for c in range(width):\n            # If we find a red pixel (color 2) that hasn't been visited yet\n            if input_grid[r, c] == 2 and not visited[r, c]:\n                \n                # Find all connected red pixels belonging to this object using BFS\n                # The BFS also marks the found pixels as visited.\n                current_object_coords = _find_object_bfs(input_grid, r, c, visited)\n\n                # If this is the very first red object we've identified in the scan\n                if not first_object_found:\n                    # Store its coordinates and set the flag\n                    first_object_coords = current_object_coords\n                    first_object_found = True\n                # Otherwise, this is a subsequent red object\n                else:\n                    # Add its coordinates to the set of 'other' objects\n                    other_objects_coords.update(current_object_coords)\n                \n                # Note: _find_object_bfs modifies 'visited' in place.\n\n    # After scanning the entire grid and identifying all objects:\n    # Recolor the pixels based on which object set they belong to.\n    \n    # Color the first object maroon (9)\n    for r_obj, c_obj in first_object_coords:\n        if 0 <= r_obj < height and 0 <= c_obj < width: # Bounds check for safety\n            output_grid[r_obj, c_obj] = 9\n\n    # Color all other objects orange (7)\n    for r_obj, c_obj in other_objects_coords:\n         if 0 <= r_obj < height and 0 <= c_obj < width: # Bounds check for safety\n            output_grid[r_obj, c_obj] = 7\n\n    # White (0) pixels (and any other colors) were preserved by the initial copy\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8188,
    "candidates_token_count": 1412,
    "total_token_count": 9600,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.137218,
  "retries": 1
}