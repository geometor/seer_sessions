{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies contiguous blocks of orange (7) pixels in the input 1D array (row).\nDetermines a 'target length' based on the distribution of the lengths of these orange blocks.\nThe rule for determining the target length is:\n1. If exactly one block length occurs uniquely (only once among all orange blocks), that length is the target length.\n2. Otherwise (if zero unique lengths or multiple unique lengths exist), the target length is the median length of all orange blocks. When calculating the median for an even number of blocks, the larger of the two middle lengths (upper median) after sorting is used.\n\nTransforms the input grid by replacing orange blocks:\n- If an orange block's length equals the calculated target length, its pixels are replaced with maroon (9).\n- Otherwise (if its length does not equal the target length), its pixels are replaced with magenta (6).\nWhite (0) pixels remain unchanged.\n\"\"\"\n\nfrom collections import Counter\nimport numpy as np # Import numpy for handling potential numpy array inputs\n\n# Helper Functions\n\ndef find_blocks_by_color(grid, color):\n    \"\"\"\n    Finds contiguous blocks of a specific color in a 1D grid.\n\n    Args:\n        grid (list or np.ndarray): The input 1D array.\n        color (int): The color value to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a block\n              and contains {'start': start_index, 'end': end_index, 'length': length}.\n              Returns an empty list if no blocks are found.\n    \"\"\"\n    # Ensure grid is a standard list\n    if isinstance(grid, np.ndarray):\n        # Handle 0-dimensional arrays which can occur if input is like [[5]]\n        if grid.ndim == 0:\n             grid_list = [grid.item()]\n        # Handle 2D arrays like [[...]] representing a single row\n        elif grid.ndim == 2 and grid.shape[0] == 1:\n             grid_list = grid[0].tolist()\n        # Handle 1D arrays\n        elif grid.ndim == 1:\n             grid_list = grid.tolist()\n        else:\n             # Handle unexpected dimensions if necessary, or raise error\n             # For now, assume it's convertible or error out naturally\n             grid_list = grid.tolist()\n    elif isinstance(grid, list) and len(grid) > 0 and isinstance(grid[0], list):\n         # Handle list of lists like [[...]]\n         if len(grid) == 1:\n             grid_list = grid[0]\n         else:\n             # Unexpected format: list of multiple lists for a 1D task\n             # For robustness, maybe only process the first list or raise error\n             # Assuming we take the first row if this structure appears\n             grid_list = grid[0] # Or raise ValueError(\"Expected 1D grid\")\n    else:\n        grid_list = list(grid) # Assume it's already a 1D list or convertible\n\n\n    blocks = []\n    in_block = False\n    start_index = -1\n    for i, pixel in enumerate(grid_list):\n        if pixel == color and not in_block:\n            # Start of a new block\n            in_block = True\n            start_index = i\n        elif pixel != color and in_block:\n            # End of the current block\n            in_block = False\n            end_index = i - 1\n            length = end_index - start_index + 1\n            blocks.append({'start': start_index, 'end': end_index, 'length': length})\n            start_index = -1 # Reset start_index\n        # Handle block ending at the very end of the grid\n    if in_block: # If the loop finished while still in a block\n         end_index = len(grid_list) - 1\n         length = end_index - start_index + 1\n         blocks.append({'start': start_index, 'end': end_index, 'length': length})\n    return blocks\n\ndef calculate_target_length(lengths):\n    \"\"\"\n    Calculates the target length based on uniqueness or median rule.\n\n    Args:\n        lengths (list): A list of block lengths.\n\n    Returns:\n        int: The target length. Returns None if the list is empty.\n    \"\"\"\n    if not lengths:\n        return None # No blocks found\n\n    # Calculate frequency of each length\n    length_counts = Counter(lengths)\n\n    # Find lengths that appear exactly once (unique lengths)\n    unique_lengths = [length for length, count in length_counts.items() if count == 1]\n\n    # Determine target length based on uniqueness\n    if len(unique_lengths) == 1:\n        target_length = unique_lengths[0]\n    else:\n        # Calculate median length (upper median rule for even count)\n        sorted_lengths = sorted(lengths)\n        n = len(sorted_lengths)\n        mid_index = n // 2\n        if n % 2 == 1:\n            # Odd number of blocks, median is the middle element\n            target_length = sorted_lengths[mid_index]\n        else:\n            # Even number of blocks, median is the larger of the two middle elements\n            # Note: Python uses 0-based indexing, so middle elements are at mid_index-1 and mid_index\n            # target_length = sorted_lengths[mid_index] # This is the element at the higher index\n            # Ensure mid_index is valid even for n=0 (handled by initial check) or n=1 (handled by odd case)\n            # For n=2, mid_index is 1, accessing sorted_lengths[1] is correct\n            target_length = sorted_lengths[mid_index]\n\n\n    return target_length\n\n\n# Main Transformation Function\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list or np.ndarray): The input 1D grid.\n\n    Returns:\n        list: The transformed 1D grid as a standard Python list.\n    \"\"\"\n\n    # Ensure input is a standard 1D list for processing\n    # (find_blocks_by_color handles numpy conversion and list-of-list check)\n    # We'll work with the list version returned by find_blocks_by_color indirectly\n    # Or, convert explicitly here if preferred for clarity before calling helpers.\n    if isinstance(input_grid, np.ndarray):\n         if input_grid.ndim == 0:\n             work_grid = [input_grid.item()]\n         elif input_grid.ndim == 2 and input_grid.shape[0] == 1:\n             work_grid = input_grid[0].tolist()\n         elif input_grid.ndim == 1:\n             work_grid = input_grid.tolist()\n         else:\n             # Default fallback or raise error\n             work_grid = input_grid.tolist() # May fail for > 2 dims\n    elif isinstance(input_grid, list) and len(input_grid) > 0 and isinstance(input_grid[0], list):\n         if len(input_grid) == 1:\n             work_grid = input_grid[0]\n         else:\n              # Taking first row as default for unexpected multi-row list input\n              work_grid = input_grid[0]\n    else:\n         work_grid = list(input_grid) # Ensure it's a mutable list\n\n    # Initialize output_grid as a copy of the working input grid\n    output_grid = list(work_grid) # Use work_grid which is guaranteed to be a list\n\n    # Find all contiguous blocks of orange (7) pixels\n    orange_blocks = find_blocks_by_color(work_grid, 7)\n\n    # If no orange blocks are found, return the original grid (as a list)\n    if not orange_blocks:\n        return output_grid\n\n    # Extract the lengths of the found blocks\n    block_lengths = [block['length'] for block in orange_blocks]\n\n    # Calculate the target length based on the rules (uniqueness or median)\n    target_length = calculate_target_length(block_lengths)\n\n    # Iterate through the identified orange blocks and modify the output grid\n    for block in orange_blocks:\n        start = block['start']\n        end = block['end']\n        length = block['length']\n\n        # Determine the replacement color based on whether the block's length matches the target length\n        replacement_color = 9 if length == target_length else 6 # 9: maroon, 6: magenta\n\n        # Apply the color change to the corresponding slice in the output grid\n        for i in range(start, end + 1):\n            # Check bounds just in case, though logic should prevent out-of-bounds\n            if 0 <= i < len(output_grid):\n                 output_grid[i] = replacement_color\n            else:\n                 # This case should ideally not happen if find_blocks_by_color is correct\n                 print(f\"Warning: Index {i} out of bounds for output_grid of length {len(output_grid)}\")\n\n\n    # Return the transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7239,
    "candidates_token_count": 2114,
    "total_token_count": 9353,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.850661,
  "retries": 1
}