{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input NumPy grid by:\n1. Flattening the grid into a 1D sequence.\n2. Identifying all contiguous horizontal segments of blue (1) pixels.\n3. Finding the segment with the maximum length. If multiple segments share the maximum length, the one starting at the earliest index (first encountered) is chosen.\n4. Changing the color of all pixels within this longest segment from blue (1) to red (2).\n5. Reshaping the modified sequence back to the original grid dimensions.\nAll other pixels retain their original color. If no blue segments are found, the original grid is returned.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\ndef find_segments(sequence: np.ndarray, target_color: int) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Finds all contiguous segments of a specific color in a 1D numpy array.\n\n    Args:\n        sequence: The 1D input numpy array of integers (pixels).\n        target_color: The color value to find segments of.\n\n    Returns:\n        A list of tuples, where each tuple represents a segment:\n        (start_index, end_index, length). Returns an empty list if no\n        segments of the target_color are found.\n    \"\"\"\n    segments = []\n    start_index = -1\n    current_length = 0\n    \n    # Add a sentinel value at the end that's different from the target color\n    # This simplifies handling segments that end at the array's boundary\n    # Use a value not in 0-9 range, e.g., -1, to avoid conflicts\n    sentinel = target_color + 1 if target_color < 9 else -1 \n    sequence_with_sentinel = np.append(sequence, sentinel)\n\n    for i, pixel in enumerate(sequence_with_sentinel):\n        if pixel == target_color:\n            # Start of a new segment or continuation of an existing one\n            if start_index == -1:\n                start_index = i\n            current_length += 1\n        else:\n            # End of a segment (if one was active)\n            if start_index != -1:\n                # End index is i-1 because the current pixel 'i' is the first non-target pixel\n                end_index = i - 1 \n                segments.append((start_index, end_index, current_length))\n                # Reset tracking\n                start_index = -1\n                current_length = 0\n                \n    return segments\n\ndef find_longest_segment(segments: List[Tuple[int, int, int]]) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the longest segment from a list of segments.\n    If there are ties for the longest length, returns the one that appears\n    first in the list (which corresponds to the earliest start index).\n\n    Args:\n        segments: A list of segments, each represented as (start_index, end_index, length).\n\n    Returns:\n        The longest segment tuple, or None if the input list is empty.\n    \"\"\"\n    if not segments:\n        return None\n\n    max_length = 0\n    longest_segment = None\n\n    for segment in segments:\n        length = segment[2]\n        if length > max_length:\n            max_length = length\n            longest_segment = segment\n            \n    return longest_segment\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A NumPy array representing the input grid.\n\n    Returns:\n        A NumPy array representing the transformed output grid.\n    \"\"\"\n    # Store original shape\n    original_shape = input_grid.shape\n    \n    # Flatten the input grid to a 1D array for easier segment processing\n    flat_grid = input_grid.flatten()\n    \n    # Define target and replacement colors\n    target_color = 1  # blue\n    replacement_color = 2  # red\n    \n    # Find all segments of the target color\n    blue_segments = find_segments(flat_grid, target_color)\n    \n    # If no blue segments are found, return the original grid (reshaped if it was flattened)\n    if not blue_segments:\n        # No need to copy or reshape if no changes were made and it was already 1D\n        if len(original_shape) == 1: \n            return input_grid \n        else:\n            # Reshape is necessary only if it wasn't 1D originally\n            return input_grid.reshape(original_shape)\n\n    # Find the longest blue segment (first one in case of ties)\n    longest_blue_segment = find_longest_segment(blue_segments)\n\n    # Create a copy of the flattened grid to modify\n    output_flat_grid = flat_grid.copy()\n\n    # If a longest segment was identified, modify the output grid\n    if longest_blue_segment:\n        start_idx, end_idx, _ = longest_blue_segment\n        \n        # Change the color within the longest segment range\n        # Use slicing for efficient modification of the numpy array\n        output_flat_grid[start_idx : end_idx + 1] = replacement_color\n            \n    # Reshape the modified flat grid back to the original shape\n    output_grid = output_flat_grid.reshape(original_shape)\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6989,
    "candidates_token_count": 1253,
    "total_token_count": 8242,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.054368,
  "retries": 1
}