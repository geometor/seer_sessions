{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nTransformation Rule:\n1. Identify the single blue pixel (1) in the input row. Note its position (blue_index).\n2. Identify the contiguous horizontal block of non-white (0), non-blue (1) pixels located immediately to the left of a gap of white pixels preceding the blue pixel.\n3. Determine the start (block_start_index) and end (block_end_index) indices and the color (block_color) of this colored block.\n4. Calculate the length of the block (block_length).\n5. Create the output row, initially identical to the input row.\n6. Clear the original position of the colored block in the output row by setting the corresponding pixels to white (0).\n7. Determine the new starting position for the block so that its rightmost pixel is adjacent to the blue pixel (new_block_start_index = blue_index - block_length).\n8. Draw the colored block in its new position in the output row using its original color (block_color).\n9. All other pixels, including the blue pixel and background white pixels not involved in the shift, remain unchanged.\n\"\"\"\n\ndef find_blue_pixel(row):\n    \"\"\"Finds the index of the first blue pixel (1) in a 1D array.\"\"\"\n    blue_indices = np.where(row == 1)[0]\n    if len(blue_indices) > 0:\n        return blue_indices[0]\n    return -1 # Not found\n\ndef find_colored_block_left_of_blue(row, blue_index):\n    \"\"\"\n    Finds the contiguous block of non-white, non-blue color to the left of the blue pixel,\n    separated by zero or more white pixels.\n    Returns (start_index, end_index, color) or (-1, -1, -1) if not found.\n    \"\"\"\n    if blue_index <= 0:\n        return -1, -1, -1 # No space to the left\n\n    # Scan backwards from the position left of the blue pixel\n    i = blue_index - 1\n    while i >= 0 and row[i] == 0: # Skip the gap (if any)\n        i -= 1\n\n    if i < 0 or row[i] == 1: # Reached the start or found blue (invalid block)\n        return -1, -1, -1\n\n    block_end_index = i\n    block_color = row[block_end_index]\n\n    if block_color == 0: # Must be a non-white block\n         return -1, -1, -1\n\n    block_start_index = block_end_index\n    while block_start_index > 0 and row[block_start_index - 1] == block_color:\n        block_start_index -= 1\n\n    return block_start_index, block_end_index, block_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Shifts a colored block horizontally so its right edge is adjacent \n    to the left side of a stationary blue marker pixel.\n    Assumes input is a 1xN numpy array based on examples.\n    \"\"\"\n    # Ensure input is a numpy array\n    input_array = np.array(input_grid, dtype=int)\n\n    # Handle cases where input might not be 1xN as expected by examples\n    if input_array.ndim != 1 or input_array.shape[0] == 0:\n         # For true 2D grids, we'd need to iterate rows or find the target row.\n         # Based on examples, we assume it's always a single row (or treated as such).\n         # If input is 2D like [[...]], get the first row.\n         if input_array.ndim == 2 and input_array.shape[0] == 1:\n             row = input_array[0]\n             is_2d = True\n         else:\n              # Cannot process this shape based on observed pattern\n              print(f\"Warning: Unexpected input shape {input_array.shape}. Returning copy.\")\n              return input_array.copy()\n    else:\n        row = input_array\n        is_2d = False # Input was already 1D\n\n    # Make a copy to modify\n    output_row = row.copy()\n    n = len(row)\n\n    # 1. Find the blue pixel\n    blue_index = find_blue_pixel(row)\n    if blue_index == -1:\n        print(\"Warning: Blue pixel (1) not found.\")\n        # Return original if blue marker is missing\n        return input_array.copy() \n\n    # 2. Find the colored block to the left\n    block_start_index, block_end_index, block_color = find_colored_block_left_of_blue(row, blue_index)\n\n    if block_start_index == -1:\n        print(\"Warning: Could not find valid colored block left of blue pixel.\")\n        # Return original if no block is found\n        return input_array.copy() \n\n    # 3. Calculate block length\n    block_length = block_end_index - block_start_index + 1\n\n    # 4. Clear the original block position in the output row\n    output_row[block_start_index : block_end_index + 1] = 0\n\n    # 5. Calculate the new starting position for the block\n    # New end index should be blue_index - 1\n    new_block_start_index = blue_index - block_length\n    new_block_end_index = blue_index - 1 # Inclusive end index for slicing is blue_index\n\n    # Ensure the new position is valid\n    if new_block_start_index < 0:\n         print(f\"Warning: Calculated new block start index {new_block_start_index} is out of bounds.\")\n         return input_array.copy() # Cannot place block, return original\n\n    # 6. Draw the block in the new position\n    output_row[new_block_start_index : new_block_end_index + 1] = block_color\n\n    # If original input was 2D (1xN), reshape output back\n    if is_2d:\n        return output_row.reshape(1, -1)\n    else:\n        return output_row\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2139,
    "candidates_token_count": 1460,
    "total_token_count": 3599,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.971349,
  "retries": 1
}