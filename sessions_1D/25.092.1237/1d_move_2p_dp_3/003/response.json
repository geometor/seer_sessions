{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a specific row in a 2D input grid containing a characteristic pattern: a contiguous sequence of a single non-white(0), non-green(3) color (the 'object sequence'), followed by one or more white(0) pixels (the 'gap'), followed by a single green(3) pixel (the 'barrier').\nTransforms this target row by swapping the positions of the 'object sequence' and the 'gap'. The object sequence moves immediately to the left of the barrier, and the gap moves to the position originally occupied by the start of the object sequence relative to the prefix.\nAll other rows in the grid remain unchanged. If no row matches the pattern, the original grid is returned.\n\"\"\"\n\nimport numpy as np\nfrom typing import Tuple, Optional\n\ndef find_object_sequence_1d(row: np.ndarray) -> Optional[Tuple[int, int, int]]:\n    \"\"\"\n    Finds the start index, end index, and color of the first contiguous sequence\n    of identical pixels in a 1D array (row) that are not white (0) or green (3).\n\n    Args:\n        row: A 1D numpy array representing a row of the grid.\n\n    Returns:\n        A tuple (start_index, end_index, color) if found, otherwise None.\n    \"\"\"\n    start_index = -1\n    current_color = -1\n    for i, pixel in enumerate(row):\n        if pixel != 0 and pixel != 3: # Potential object pixel\n            if start_index == -1: # Start of a new potential sequence\n                start_index = i\n                current_color = pixel\n            elif pixel != current_color: # End of sequence due to different non-0/3 color\n                # Found a complete sequence before this different color started\n                return start_index, i - 1, current_color\n        elif start_index != -1: # Sequence ends because we hit 0 or 3\n            # Found the end of the sequence\n            return start_index, i - 1, current_color\n            \n    # Check if the sequence runs to the end of the row\n    if start_index != -1:\n        return start_index, len(row) - 1, current_color\n        \n    return None # No suitable object sequence found\n\ndef find_barrier_1d(row: np.ndarray, search_start_index: int = 0) -> Optional[int]:\n    \"\"\"\n    Finds the index of the first green (3) pixel in a 1D array (row),\n    starting the search from a given index.\n\n    Args:\n        row: A 1D numpy array representing a row of the grid.\n        search_start_index: The index from which to start searching for the barrier.\n\n    Returns:\n        The index of the green pixel if found, otherwise None.\n    \"\"\"\n    try:\n        # Find all occurrences of '3' in the specified slice\n        relative_indices = np.where(row[search_start_index:] == 3)[0]\n        if len(relative_indices) > 0:\n            # Return the absolute index in the original row\n            return search_start_index + relative_indices[0]\n        else:\n            return None\n    except IndexError: # Should not happen with numpy where but good practice\n         return None\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the object/gap swap transformation to the target row within the input grid.\n\n    Args:\n        input_grid: A 2D numpy array representing the input grid.\n\n    Returns:\n        A 2D numpy array representing the transformed grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    target_row_found = False\n\n    # Iterate through each row to find the target row\n    for r in range(rows):\n        current_row = input_grid[r, :]\n\n        # 1. Find the object sequence in the current row\n        object_info = find_object_sequence_1d(current_row)\n        if not object_info:\n            continue # No object sequence in this row\n\n        obj_start, obj_end, obj_color = object_info\n\n        # 2. Find the barrier (green pixel) after the object sequence\n        barrier_index = find_barrier_1d(current_row, search_start_index=obj_end + 1)\n        if barrier_index is None:\n            continue # No barrier found after the object in this row\n\n        # 3. Define and validate the gap\n        gap_start_index = obj_end + 1\n        gap_end_index = barrier_index # gap is up to, but not including, the barrier\n\n        # Ensure gap exists (barrier is not immediately adjacent to object)\n        if gap_start_index >= gap_end_index:\n             continue # No gap found between object and barrier\n\n        gap_seq = current_row[gap_start_index:gap_end_index]\n\n        # Check if the gap contains only white (0) pixels\n        if not np.all(gap_seq == 0):\n            continue # Gap contains non-white pixels, this is not the target row\n\n        # If we reach here, we've found the target row and confirmed the pattern\n        target_row_found = True\n\n        # 4. Extract segments from the target row\n        prefix = current_row[:obj_start]\n        object_seq = current_row[obj_start : obj_end + 1]\n        # gap_seq is already extracted\n        barrier_pixel = np.array([current_row[barrier_index]]) # Keep as array for concatenation\n        suffix = current_row[barrier_index + 1 :]\n\n        # 5. Construct the modified row by rearranging segments\n        # Order: prefix, gap, object, barrier, suffix\n        modified_row = np.concatenate((prefix, gap_seq, object_seq, barrier_pixel, suffix))\n\n        # 6. Update the output grid with the modified row\n        output_grid[r, :] = modified_row\n\n        # Assume only one target row per grid based on examples\n        break \n\n    # Return the modified grid (or the original copy if no target row was found)\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7995,
    "candidates_token_count": 1451,
    "total_token_count": 9446,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.864017,
  "retries": 1
}