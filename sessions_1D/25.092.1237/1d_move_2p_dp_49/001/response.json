{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nShift a horizontal colored line to be adjacent to a fixed gray pixel.\n\n1. Identify the position of the single gray pixel (5), the 'anchor'.\n2. Identify the contiguous horizontal line of a single color (not white 0, not gray 5). Record its color, start index, and end index.\n3. Calculate the target end index for the line, which is the index immediately to the left of the anchor pixel (anchor_index - 1).\n4. Calculate the new start index for the line based on its length and the target end index.\n5. Create an output grid of the same size as the input, filled with the background color (white 0).\n6. Place the anchor pixel (gray 5) at its original position in the output grid.\n7. Place the identified colored line at its new calculated position (new start index to target end index) in the output grid using its original color.\n\"\"\"\n\ndef find_pixel(grid_row, target_color):\n    \"\"\"Finds the index of the first occurrence of target_color in a 1D list.\"\"\"\n    try:\n        return grid_row.index(target_color)\n    except ValueError:\n        return -1 # Not found\n\ndef find_colored_line(grid_row, background_color=0, anchor_color=5):\n    \"\"\"\n    Finds the start index, end index, and color of the first contiguous\n    horizontal line whose color is not background_color or anchor_color.\n    Assumes only one such line exists.\n    \"\"\"\n    line_color = -1\n    start_index = -1\n    end_index = -1\n    in_line = False\n\n    for i, pixel_color in enumerate(grid_row):\n        is_line_pixel = (pixel_color != background_color and pixel_color != anchor_color)\n\n        if is_line_pixel and not in_line:\n            # Start of a new line\n            in_line = True\n            start_index = i\n            line_color = pixel_color\n        elif is_line_pixel and in_line:\n            # Continuation of the current line\n            if pixel_color != line_color:\n                 # This case shouldn't happen based on task description,\n                 # but handles finding the *first* valid line if multiple colors were present.\n                 # We assume the line is monochromatic.\n                 pass\n            end_index = i # Keep updating end index while in the line\n        elif not is_line_pixel and in_line:\n            # End of the line found\n            end_index = i - 1 # The previous pixel was the end\n            break # Found the first complete line\n\n    # If the line extends to the end of the grid\n    if in_line and end_index < start_index:\n         end_index = len(grid_row) - 1\n\n    # Check if a line was actually found\n    if start_index != -1 and line_color != -1:\n        # If the line was just one pixel long\n        if end_index < start_index:\n             end_index = start_index\n        return start_index, end_index, line_color\n    else:\n        return -1, -1, -1 # Line not found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Shifts a colored horizontal line in a 1D grid so its right end is\n    adjacent to a fixed gray pixel.\n\n    Args:\n        input_grid (list): A 1D list representing the input grid row.\n\n    Returns:\n        list: A 1D list representing the transformed output grid row.\n    \"\"\"\n    # Assuming the input grid is effectively 1D (a single list)\n    input_row = input_grid[0] # Get the single row\n    grid_width = len(input_row)\n    background_color = 0\n    anchor_color = 5\n\n    # Initialize output_grid with background color\n    output_row = [background_color] * grid_width\n\n    # 1. Find the anchor pixel\n    anchor_index = find_pixel(input_row, anchor_color)\n    if anchor_index == -1:\n        # Handle error: Anchor pixel not found (shouldn't happen based on examples)\n        return [input_row] # Or raise an error\n\n    # Place anchor pixel in output\n    output_row[anchor_index] = anchor_color\n\n    # 2. Find the colored line\n    line_start, line_end, line_color = find_colored_line(input_row, background_color, anchor_color)\n    if line_start == -1:\n        # Handle error: Colored line not found (shouldn't happen based on examples)\n         # Return grid with only anchor placed\n        return [output_row]\n\n    # 3. Calculate target end index\n    target_end_index = anchor_index - 1\n\n    # 4. Calculate line length and new start index\n    line_length = line_end - line_start + 1\n    new_start_index = target_end_index - line_length + 1\n\n    # 5. Check bounds (ensure the new line fits within the grid)\n    if new_start_index < 0 or target_end_index >= grid_width:\n        # Handle error: Shifted line goes out of bounds (shouldn't happen based on examples)\n        print(f\"Warning: Calculated line position [{new_start_index}, {target_end_index}] might be out of bounds [0, {grid_width-1}].\")\n        # Depending on exact requirements, might return original, raise error, or clip.\n        # For now, let's proceed, Python slicing handles some out-of-bounds gracefully for write.\n\n    # 6. Place the colored line in the output grid at the new position\n    for i in range(line_length):\n        current_index = new_start_index + i\n        # Add extra bounds check before writing\n        if 0 <= current_index < grid_width:\n            # Ensure we don't overwrite the anchor if calculations are somehow off\n            if current_index != anchor_index:\n                 output_row[current_index] = line_color\n            else:\n                 print(f\"Warning: Calculated line position overlaps anchor at index {anchor_index}.\")\n        else:\n            print(f\"Warning: Attempted to write line pixel outside grid bounds at index {current_index}.\")\n\n\n    # Return the transformed row wrapped in a list to match the expected grid format (list of lists)\n    return [output_row]\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2337,
    "candidates_token_count": 1502,
    "total_token_count": 3839,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.444864,
  "retries": 1
}