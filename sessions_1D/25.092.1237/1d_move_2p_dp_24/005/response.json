{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional\n\n\"\"\"\nTransformation Rule:\n1. Locate the unique target pixel (green=3) in the 1D input NumPy array.\n2. Scan leftwards from the target pixel to identify a contiguous block of background pixels (white=0). This is the 'gap'. Determine its start index, end index, and size. If no gap exists immediately to the left of the target, the transformation is not applied.\n3. Identify the contiguous block of a single non-background, non-target color located immediately to the left of the gap's start index. This is the 'movable block'. Determine its start and end indices.\n4. If both a gap (size > 0) and a movable block are found in the expected adjacent configuration:\n   a. Extract four segments:\n      i. Pixels before the movable block.\n      ii. The pixels of the movable block.\n      iii. The pixels of the gap.\n      iv. Pixels from the target pixel to the end of the array.\n   b. Reconstruct the array by concatenating the segments in the order: (pixels before block) + (gap pixels) + (movable block pixels) + (pixels from target onwards).\n5. If no gap is found (size == 0) or the expected block/gap structure is not present, return the original input array unchanged.\n\"\"\"\n\ndef find_target_pixel(grid: np.ndarray, target_color: int) -> Optional[int]:\n    \"\"\"Finds the index of the first occurrence of the target color.\"\"\"\n    indices = np.where(grid == target_color)[0]\n    if len(indices) > 0:\n        return indices[0]\n    return None\n\ndef find_gap(grid: np.ndarray, target_index: int, background_color: int) -> Tuple[Optional[int], Optional[int], int]:\n    \"\"\"\n    Finds the contiguous block of background pixels immediately left of the target index.\n    Returns (gap_start_index, gap_end_index, gap_size).\n    Returns (None, None, 0) if no gap is found immediately left.\n    \"\"\"\n    gap_end_index = target_index - 1\n    gap_start_index = None\n    gap_size = 0\n\n    if gap_end_index < 0: # Target is at the beginning\n        return None, None, 0\n\n    current_index = gap_end_index\n    while current_index >= 0 and grid[current_index] == background_color:\n        gap_start_index = current_index\n        gap_size += 1\n        current_index -= 1\n\n    if gap_size > 0:\n        return gap_start_index, gap_end_index, gap_size\n    else:\n        # No background pixel found immediately left of target\n        return None, None, 0\n\ndef find_movable_block(grid: np.ndarray, gap_start_index: Optional[int], background_color: int, target_color: int) -> Tuple[Optional[int], Optional[int]]:\n    \"\"\"\n    Finds the contiguous block of non-background, non-target color immediately left of the gap's start index.\n    Returns (block_start_index, block_end_index).\n    Returns (None, None) if no block is found or gap_start_index is None/0.\n    \"\"\"\n    if gap_start_index is None or gap_start_index == 0:\n        # Gap doesn't exist or is at the very beginning, no space for a block before it\n        return None, None\n\n    block_end_index = gap_start_index - 1\n    block_color = grid[block_end_index]\n\n    # Check if the potential block color is valid\n    if block_color == background_color or block_color == target_color:\n        return None, None # Found background or target color where block should be\n\n    # Scan left from the block end to find the start of the block\n    block_start_index = block_end_index\n    current_index = block_end_index - 1\n    while current_index >= 0 and grid[current_index] == block_color:\n        block_start_index = current_index\n        current_index -= 1\n\n    return block_start_index, block_end_index\n\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to swap a colored block and a background gap\n    located immediately to the left of a target pixel (3).\n    \"\"\"\n    # Configuration\n    target_color = 3\n    background_color = 0\n\n    # Ensure input is a NumPy array\n    if not isinstance(input_grid, np.ndarray):\n        input_grid = np.array(input_grid)\n\n    # Make a copy to avoid modifying the original input if no transformation occurs\n    output_grid = input_grid.copy()\n\n    # 1. Find the target pixel\n    target_index = find_target_pixel(output_grid, target_color)\n    if target_index is None:\n        # print(f\"Debug: Target color {target_color} not found.\")\n        return output_grid # Return copy of original input\n\n    # 2. Find the gap immediately left of the target\n    gap_start_index, gap_end_index, gap_size = find_gap(output_grid, target_index, background_color)\n\n    # 3. If no gap exists, return the original grid unchanged\n    if gap_size == 0:\n        # print(f\"Debug: No gap found left of target at index {target_index}.\")\n        return output_grid # Return copy of original input\n\n    # 4. Find the movable block immediately left of the gap\n    block_start_index, block_end_index = find_movable_block(output_grid, gap_start_index, background_color, target_color)\n\n    # 5. If no valid block is found before the gap, return the original grid unchanged\n    if block_start_index is None:\n        # print(f\"Debug: No valid movable block found left of gap starting at index {gap_start_index}.\")\n        return output_grid # Return copy of original input\n\n    # 6. Extract the segments for rearrangement\n    pixels_before_block = output_grid[:block_start_index]\n    movable_block_pixels = output_grid[block_start_index : block_end_index + 1]\n    gap_pixels = output_grid[gap_start_index : gap_end_index + 1]\n    # Include the target pixel and everything after it\n    pixels_after_inclusive = output_grid[target_index:]\n\n    # 7. Construct the output grid by concatenating segments in the new order\n    # Order: (Pixels before block) + (Gap pixels) + (Movable block pixels) + (Pixels from target onwards)\n    transformed_grid = np.concatenate((\n        pixels_before_block,\n        gap_pixels,\n        movable_block_pixels,\n        pixels_after_inclusive\n    ))\n\n    return transformed_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10060,
    "candidates_token_count": 1639,
    "total_token_count": 11699,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.72728,
  "retries": 1
}