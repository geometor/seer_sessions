{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\nGiven a 1xN grid (represented as a 2D NumPy array), identify the single red pixel (2). \nIdentify the contiguous block of non-white (0), non-red (2) pixels located immediately to the left of two white (0) separator pixels, which are themselves immediately to the left of the red pixel. \nSwap the positions of this colored block segment and the two white separator pixels segment within the row. \nAll other pixels (leading background, red pixel, trailing background) remain in their relative positions.\nThe output grid has the same shape as the input grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import Tuple, Optional\n\n# --- Helper Functions ---\n\ndef find_single_pixel_coords(grid_row: np.ndarray, color: int) -> Optional[int]:\n    \"\"\"Finds the column index of the single pixel with the specified color in a 1D array (row).\"\"\"\n    indices = np.where(grid_row == color)[0]\n    if len(indices) == 1:\n        return indices[0]\n    # Return None if not found or multiple found, indicating an unexpected state\n    elif len(indices) == 0:\n        print(f\"Warning: Pixel with color {color} not found.\")\n        return None\n    else:\n        print(f\"Warning: Multiple pixels with color {color} found.\")\n        return None # Or potentially indices[0] if we assume the first one matters\n\ndef find_colored_block_indices_in_row(grid_row: np.ndarray, search_end_col: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the start and end column indices of a contiguous block of non-white, non-red pixels\n    ending immediately before search_end_col in a 1D NumPy array (row).\n    Returns (start_col, end_col) or None if not found or invalid structure.\n    \"\"\"\n    if search_end_col <= 0:\n        # Cannot have a block ending before column 0\n        return None\n\n    block_end_col = search_end_col - 1\n    if block_end_col < 0:\n         # Should not happen if search_end_col > 0, but safe check\n         return None\n\n    block_color = grid_row[block_end_col]\n\n    # Check if the color is valid for a 'colored block' (not white, not red)\n    if block_color == 0 or block_color == 2:\n         # The pixel immediately left of the separators is not a colored block start\n         return None\n\n    block_start_col = block_end_col\n    # Iterate leftwards to find where the block starts\n    while block_start_col > 0 and grid_row[block_start_col - 1] == block_color:\n        block_start_col -= 1\n\n    # Optional: Check if the pixel before the block start is white or if it's the beginning of the array\n    # if block_start_col > 0 and grid_row[block_start_col - 1] != 0:\n    #     print(f\"Warning: Pixel before block start (col {block_start_col - 1}) is not white (0).\")\n        # pass # Relaxing this constraint as per previous analysis\n\n    return block_start_col, block_end_col\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the transformation rule to the input 2D NumPy array.\n    \"\"\"\n    # Ensure input is a 2D NumPy array\n    if not isinstance(input_grid, np.ndarray) or input_grid.ndim != 2:\n         raise ValueError(\"Input grid must be a 2-dimensional NumPy array.\")\n\n    # Assume transformation operates on the first row if multiple rows exist,\n    # or the only row if shape is (1, N).\n    if input_grid.shape[0] == 0 or input_grid.shape[1] == 0:\n         print(\"Warning: Input grid is empty.\")\n         return input_grid # Return empty grid\n\n    # Work on a copy to avoid modifying the original input array\n    output_grid = np.copy(input_grid)\n    grid_row = output_grid[0] # Operate on the first row\n\n    # 1. Find the column index of the red pixel (marker)\n    red_col = find_single_pixel_coords(grid_row, 2)\n    if red_col is None:\n        print(\"Error: Red pixel (2) marker not found or ambiguous. Returning original grid.\")\n        return input_grid # Cannot proceed without the marker\n\n    # 2. Verify the two white separator pixels exist immediately to the left\n    if red_col < 2:\n        print(f\"Error: Red pixel at column {red_col} is too close to the start for separators. Returning original grid.\")\n        return input_grid\n    if not (grid_row[red_col - 1] == 0 and grid_row[red_col - 2] == 0):\n        print(f\"Error: Expected white separator pixels (0, 0) at columns {red_col - 2}, {red_col - 1}. Returning original grid.\")\n        return input_grid # Structure mismatch\n\n    white_sep_start_col = red_col - 2\n\n    # 3. Find the indices (start_col, end_col) of the colored block immediately left of separators\n    block_indices = find_colored_block_indices_in_row(grid_row, white_sep_start_col)\n    if block_indices is None:\n        print(f\"Error: Could not find valid colored block ending at column {white_sep_start_col - 1}. Returning original grid.\")\n        return input_grid # Structure mismatch\n\n    block_start_col, block_end_col = block_indices\n\n    # 4. Extract the segments of the row using NumPy slicing\n    leading_segment = grid_row[:block_start_col]\n    colored_block_segment = grid_row[block_start_col : block_end_col + 1]\n    white_separator_segment = grid_row[white_sep_start_col : red_col] # Cols white_sep_start_col, white_sep_start_col + 1\n    red_pixel_segment = grid_row[red_col : red_col + 1] # Just the red pixel at red_col\n    trailing_segment = grid_row[red_col + 1 :]\n\n    # 5. Construct the new row by concatenating segments in the swapped order\n    new_row = np.concatenate([\n        leading_segment,\n        white_separator_segment, # Separators move left\n        colored_block_segment,   # Block moves right\n        red_pixel_segment,       # Red pixel stays\n        trailing_segment         # Trailing part stays\n    ])\n\n    # 6. Place the modified row back into the output grid\n    output_grid[0] = new_row\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12340,
    "candidates_token_count": 1635,
    "total_token_count": 13975,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.416875,
  "retries": 1
}