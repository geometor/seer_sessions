{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nExpand isolated single non-white pixels into 3-pixel horizontal blocks, \nkeeping the first encountered 3-pixel block unchanged.\n\nThe transformation applies to grids that are effectively single rows.\nIt identifies the first sequence of three identical non-white pixels ('anchor block')\nand leaves it untouched. Then, it finds any other single non-white pixels ('target pixels')\nthat are surrounded horizontally by white pixels (or grid boundaries). Each target pixel\nis expanded into a horizontal block of three pixels of its own color, centered at the \noriginal target pixel's location.\n\"\"\"\n\ndef find_first_anchor_block(grid_row):\n    \"\"\"\n    Finds the start index and color of the first horizontal block of \n    exactly 3 identical non-white pixels.\n    \n    Args:\n        grid_row (np.array): A 1D numpy array representing the grid row.\n\n    Returns:\n        tuple: (start_index, color) or (None, None) if not found.\n    \"\"\"\n    width = len(grid_row)\n    for i in range(width - 2):\n        # Check for 3 consecutive pixels\n        pixel1 = grid_row[i]\n        pixel2 = grid_row[i+1]\n        pixel3 = grid_row[i+2]\n        \n        # Check if they are identical and non-white (color > 0)\n        if pixel1 > 0 and pixel1 == pixel2 and pixel1 == pixel3:\n            # Check if it's exactly 3 pixels long (boundary conditions)\n            is_exactly_3 = True\n            # Check left boundary\n            if i > 0 and grid_row[i-1] == pixel1:\n                is_exactly_3 = False\n            # Check right boundary\n            if i + 3 < width and grid_row[i+3] == pixel1:\n                 is_exactly_3 = False # It's longer than 3\n\n            # Based on problem description, we only need the *first* 3-block\n            # The examples don't explicitly show blocks longer than 3 that start the same way.\n            # Assuming the first 3-block found is *the* anchor block.\n            # Let's refine based on the first example: 999 is the anchor, 1 is the target.\n            # Example 3: 999 is anchor, first 8 is target, second 8 is target.\n            # The definition seems to be just \"first group of 3 identical non-white\".\n            \n            # Re-evaluating: The definition is simpler. Find the *first* group of 3 identical non-white pixels.\n            # No need to check if it's *exactly* 3 for identification, just for the condition itself.\n            return i, pixel1\n            \n    return None, None\n\n\ndef is_isolated_pixel(grid_row, index):\n    \"\"\"\n    Checks if a pixel at a given index is horizontally isolated by white pixels (0) or boundaries.\n    Assumes the pixel itself is non-white.\n    \n    Args:\n        grid_row (np.array): A 1D numpy array representing the grid row.\n        index (int): The index of the pixel to check.\n\n    Returns:\n        bool: True if the pixel is isolated, False otherwise.\n    \"\"\"\n    width = len(grid_row)\n    \n    # Check left neighbor\n    left_is_white_or_boundary = (index == 0) or (grid_row[index - 1] == 0)\n    \n    # Check right neighbor\n    right_is_white_or_boundary = (index == width - 1) or (grid_row[index + 1] == 0)\n    \n    return left_is_white_or_boundary and right_is_white_or_boundary\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rules:\n    - Find the first 3-pixel horizontal block of identical non-white color (anchor).\n    - Keep the anchor block unchanged.\n    - Expand all other isolated single non-white pixels into 3-pixel blocks of their color.\n    \n    Args:\n        input_grid (np.array): A 2D numpy array, expected to be 1xN.\n\n    Returns:\n        np.array: The transformed 2D numpy array.\n    \"\"\"\n    # Ensure input is treated as a single row for simplicity based on examples\n    # Assuming input is always 1xN or Nx1. We'll work with the first row or column if needed.\n    # For the given examples, they are presented as 1xN.\n    if input_grid.shape[0] != 1:\n        # This case isn't explicitly covered by examples, but good practice.\n        # If it's Nx1, transpose it? Or handle as a column?\n        # Let's assume 1xN based on examples. If not, this might fail or need adjustment.\n        # For now, we'll proceed assuming grid[0] is the relevant row.\n        pass # Raise error or adapt if necessary for more general cases.\n        \n    grid_row = input_grid[0]\n    width = len(grid_row)\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    output_row = output_grid[0] # Work directly on the output row\n\n    # Find the anchor block\n    anchor_start_index, anchor_color = find_first_anchor_block(grid_row)\n    anchor_indices = set()\n    if anchor_start_index is not None:\n        anchor_indices = {anchor_start_index, anchor_start_index + 1, anchor_start_index + 2}\n\n    # Iterate through the input grid row to find and expand target pixels\n    for i in range(width):\n        # Check if current pixel is part of the anchor block\n        if i in anchor_indices:\n            continue\n\n        # Get the color of the current pixel\n        pixel_color = grid_row[i]\n\n        # Check if it's a non-white pixel\n        if pixel_color > 0:\n            # Check if it's an isolated pixel\n            if is_isolated_pixel(grid_row, i):\n                # This is a target pixel, expand it in the output grid\n                \n                # Expand left (if possible)\n                if i > 0:\n                    output_row[i - 1] = pixel_color\n                \n                # Expand center (overwrite original position)\n                output_row[i] = pixel_color\n                \n                # Expand right (if possible)\n                if i < width - 1:\n                    output_row[i + 1] = pixel_color\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2755,
    "candidates_token_count": 1568,
    "total_token_count": 4323,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.560978,
  "retries": 1
}