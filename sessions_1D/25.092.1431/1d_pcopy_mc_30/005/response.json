{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nTransforms a 4x8 grid based on the following rules:\n\n1. Initialize an output grid as a copy of the input grid.\n2. Identify \"source\" pixels in the input grid. A pixel at (r, c) is a source if:\n    a. It is not white (color value > 0).\n    b. Its horizontal neighbors (left and right, with column wrap-around) have colors different from the source pixel's color.\n3. For each identified source pixel at input position (r, c) with color C:\n    a. Calculate the target coordinates for a 3-pixel horizontal line:\n        i. Center pixel coordinates: (r, c).\n        ii. Left pixel coordinates: \n            - Column: (c - 1 + 8) % 8 (column wrap-around).\n            - Row: (r - 1 + 4) % 4 if the source column c is 0 (left edge), otherwise r.\n        iii. Right pixel coordinates:\n            - Column: (c + 1 + 8) % 8 (column wrap-around).\n            - Row: (r + 1 + 4) % 4 if the source column c is 7 (right edge), otherwise r.\n    b. Update the *output* grid by setting the color of the pixels at the calculated left, center, and right target coordinates to C.\n4. Return the final modified output grid. Existing 3-pixel horizontal lines from the input are preserved unless overwritten by an expansion.\n\"\"\"\n\ndef is_source_pixel(grid: np.ndarray, r: int, c: int) -> bool:\n    \"\"\"\n    Checks if a pixel at (r, c) in the input grid is a source for expansion.\n    A pixel is a source if it's non-white and its horizontal neighbors\n    (with column wrap-around) are not the same color as the pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    color = grid[r, c]\n\n    # Must be non-white\n    if color == 0:\n        return False\n\n    # Check horizontal neighbors using modulo for column wrap-around\n    left_c = (c - 1 + cols) % cols\n    right_c = (c + 1 + cols) % cols\n    left_neighbor_color = grid[r, left_c]\n    right_neighbor_color = grid[r, right_c]\n\n    # A pixel is a source if its color differs from both its left and right horizontal neighbors\n    return left_neighbor_color != color and right_neighbor_color != color\n\ndef calculate_target_coords(r: int, c: int, rows: int, cols: int) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Calculates the target coordinates (left, center, right) for expansion,\n    applying specific row and column wrap-around rules based on the source pixel's position.\n\n    Args:\n        r: Row index of the source pixel.\n        c: Column index of the source pixel.\n        rows: Total number of rows in the grid.\n        cols: Total number of columns in the grid.\n\n    Returns:\n        A tuple containing three coordinate tuples: ((left_r, left_c), (center_r, center_c), (right_r, right_c)).\n    \"\"\"\n    # Calculate column indices with standard horizontal wrap-around\n    left_c_target = (c - 1 + cols) % cols\n    center_c_target = c\n    right_c_target = (c + 1 + cols) % cols\n\n    # Calculate row indices, starting with the source row\n    left_r_target = r\n    center_r_target = r\n    right_r_target = r\n\n    # Apply special row wrap adjustment for edge columns\n    if c == 0: # Source is in the first column (left edge)\n        # The pixel wrapping to the last column uses the row above (with row wrap)\n        left_r_target = (r - 1 + rows) % rows\n    if c == cols - 1: # Source is in the last column (right edge)\n        # The pixel wrapping to the first column uses the row below (with row wrap)\n        right_r_target = (r + 1 + rows) % rows\n\n    return ((left_r_target, left_c_target),\n            (center_r_target, center_c_target),\n            (right_r_target, right_c_target))\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the expansion transformation to the input grid.\n\n    Args:\n        input_grid: A 2D list of integers representing the input grid.\n\n    Returns:\n        A 2D list of integers representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # Initialize output grid as a copy of the input grid\n    output_np = input_np.copy()\n\n    # Iterate through each cell of the *input* grid to find source pixels\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the current cell in the input grid is a source for expansion\n            if is_source_pixel(input_np, r, c):\n                # Get the color of the source pixel\n                color = input_np[r, c]\n\n                # Calculate the target coordinates for the 3-pixel horizontal line\n                (left_coord, center_coord, right_coord) = calculate_target_coords(r, c, rows, cols)\n\n                # Update the *output* grid with the expanded line using the source color\n                output_np[left_coord] = color\n                # Center coordinate update overwrites the original source pixel location in the output\n                output_np[center_coord] = color\n                output_np[right_coord] = color\n\n    # Convert the final numpy array back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9216,
    "candidates_token_count": 1420,
    "total_token_count": 10636,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.173257,
  "retries": 1
}