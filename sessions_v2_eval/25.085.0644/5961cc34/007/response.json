{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport math\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on blue/green shapes and a yellow marker.\n\n1. Initialize the output grid with the same dimensions as the input, filled with azure (8).\n2. Identify all distinct contiguous shapes composed of blue (1) or green (3) pixels using 8-way connectivity. Store the set of pixel coordinates for each shape. Let N be the number of shapes found.\n3. Locate the single yellow (4) marker pixel at position (mr, mc).\n4. Apply rules based on the number of shapes (N):\n    * If N > 1:\n        * Fill the exact pixel locations of every blue/green shape with red (2).\n        * Fill the entire column mc (the marker's column) with red (2), overwriting previous fills.\n    * If N == 1:\n        * Let the single shape be S.\n        * Calculate the minimum Manhattan distance (min_dist) from the marker's position (mr, mc) to any pixel belonging to shape S.\n        * If min_dist <= 2:\n            * Calculate the centroid (average row, average column) of the pixels in S. Determine the centroid's column index cc (floor of the average column value).\n            * Fill the exact pixel locations of shape S with red (2).\n            * Fill the entire column cc (the centroid's column index) with red (2), overwriting previous fills.\n        * If min_dist > 2:\n            * Fill the entire column mc (the marker's column index) with red (2).\n    * If N == 0:\n        * (Assumption based on examples and lack of N=0 case) Fill the marker's column mc with red (2). If no marker, return the background grid.\n5. Return the final output grid.\n\"\"\"\n\ndef find_shapes(input_grid_np, shape_colors):\n    \"\"\"\n    Identifies contiguous shapes of specified colors using 8-way connectivity\n    and returns their pixel coordinates.\n\n    Args:\n        input_grid_np (np.array): The input grid.\n        shape_colors (list): List of colors that constitute shapes.\n\n    Returns:\n        tuple: (list_of_shapes, num_shapes)\n            list_of_shapes: A list where each element is a dict:\n                            {'pixels': set((r, c), ...)}\n            num_shapes: The total number of distinct shapes found.\n    \"\"\"\n    rows, cols = input_grid_np.shape\n    shape_mask = np.isin(input_grid_np, shape_colors)\n    visited = np.zeros_like(shape_mask, dtype=bool)\n    current_label = 0\n    shapes = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if shape_mask[r, c] and not visited[r, c]:\n                current_label += 1\n                component_pixels = set()\n                q = deque([(r, c)]) # Use deque for efficient BFS\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               shape_mask[nr, nc] and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                \n                shapes.append({'pixels': component_pixels})\n\n    return shapes, current_label\n\ndef calculate_min_manhattan_dist_to_pixels(marker_pos, shapes):\n    \"\"\"\n    Calculates the minimum Manhattan distance from the marker position\n    to any pixel belonging to any of the shapes.\n\n    Args:\n        marker_pos (tuple): (row, col) of the marker.\n        shapes (list): List of shape dictionaries, each with a 'pixels' set.\n\n    Returns:\n        float: Minimum Manhattan distance, or infinity if no shapes/pixels.\n    \"\"\"\n    if not shapes:\n        return float('inf')\n\n    mr, mc = marker_pos\n    min_dist = float('inf')\n\n    for shape in shapes:\n        if not shape['pixels']:\n            continue\n        for r, c in shape['pixels']:\n            dist = abs(mr - r) + abs(mc - c)\n            min_dist = min(min_dist, dist)\n\n    return min_dist\n\ndef calculate_centroid_column(pixels):\n    \"\"\"\n    Calculates the floor of the average column index for a set of pixels.\n\n    Args:\n        pixels (set): Set of (row, col) tuples.\n\n    Returns:\n        int: The floor of the average column index, or -1 if no pixels.\n    \"\"\"\n    if not pixels:\n        return -1\n    \n    # Ensure float division\n    avg_c = sum(c for r, c in pixels) / float(len(pixels)) \n    return math.floor(avg_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on shapes, marker, and distance.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    background_color = 8 # azure\n    fill_color = 2 # red\n    shape_colors = [1, 3] # blue, green\n    marker_color = 4 # yellow\n\n    # 1. Initialize output_grid with background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 2. Identify shapes and their properties\n    shapes, num_shapes = find_shapes(input_grid_np, shape_colors)\n\n    # 3. Locate the marker\n    marker_coords = np.argwhere(input_grid_np == marker_color)\n    \n    # Handle case where marker might be missing (though unlikely based on examples)\n    if marker_coords.size == 0:\n        # If no marker, return background grid as per implicit rules\n        return output_grid.tolist() \n\n    marker_pos = tuple(marker_coords[0]) # (mr, mc)\n    mr, mc = marker_pos\n\n    # 4/5. Apply rules based on number of shapes (N)\n    if num_shapes == 0:\n        # Fill marker column if no shapes exist\n        output_grid[:, mc] = fill_color\n\n    elif num_shapes == 1:\n        # Case: N == 1\n        single_shape = shapes[0]\n        min_dist = calculate_min_manhattan_dist_to_pixels(marker_pos, shapes)\n        \n        if min_dist <= 2:\n            # Marker \"close\": Fill shape pixels + centroid column\n            cc = calculate_centroid_column(single_shape['pixels'])\n            if cc != -1: # Ensure centroid column is valid\n                # Fill shape pixels\n                for r, c in single_shape['pixels']:\n                    output_grid[r, c] = fill_color\n                # Fill centroid column (overwriting shape pixels in that column)\n                output_grid[:, cc] = fill_color \n            else:\n                 # Should not happen if num_shapes == 1 and pixels exist\n                 print(\"Warning: Could not calculate centroid column for single shape.\")\n                 # Fallback? Maybe fill marker column? Let's fill marker column as a guess.\n                 output_grid[:, mc] = fill_color \n        \n        else: # min_dist > 2\n            # Marker \"distant\": Fill only marker column\n            output_grid[:, mc] = fill_color\n\n    else: # num_shapes > 1\n        # Case: N > 1: Fill all shape pixels + marker column\n        for shape in shapes:\n            for r, c in shape['pixels']:\n                output_grid[r, c] = fill_color\n        # Fill marker column (overwriting shape pixels in that column)\n        output_grid[:, mc] = fill_color \n        \n    # 6. Return the modified output grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14297,
    "candidates_token_count": 1938,
    "total_token_count": 16235,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.211731
}