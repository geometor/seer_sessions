
## train_1

**input:**
```
3 4 3 4 8 9 9 9 9 9 9 8 4 4 4 4
4 3 4 3 8 9 9 9 9 9 9 8 4 4 3 4
3 3 3 4 8 8 8 9 9 9 9 8 3 3 4 4
3 4 3 3 8 9 8 9 9 9 9 8 8 8 8 8
8 8 8 8 8 9 8 9 9 9 9 9 8 9 9 9
9 8 9 9 9 9 8 9 9 9 9 9 8 9 9 9
9 8 9 9 9 8 8 8 8 8 8 8 8 9 9 9
9 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9
9 9 9 9 9 8 8 8 8 8 8 8 8 8 8 9
9 9 9 9 9 9 8 9 9 9 9 9 9 9 8 9
9 9 9 9 9 9 8 9 9 9 9 9 9 9 8 9
9 9 9 9 9 9 8 9 9 9 9 9 9 9 8 9
9 9 9 9 9 9 8 9 9 9 9 9 9 9 8 9
9 9 9 9 9 8 8 8 8 9 9 9 9 8 8 8
9 9 9 9 9 8 4 4 8 9 9 9 9 8 3 4
9 9 9 9 9 8 4 3 8 9 9 9 9 8 4 4
```


**output:**
```
3 4 3 4 3 9 9 9 9 9 9 4 4 4 4 4
4 3 4 3 3 9 9 9 9 9 9 4 4 4 3 4
3 3 3 4 3 3 3 9 9 9 9 4 3 3 4 4
3 4 3 3 3 9 3 9 9 9 9 4 4 4 4 4
3 3 3 3 3 9 3 9 9 9 9 9 4 9 9 9
9 3 9 9 9 9 3 9 9 9 9 9 4 9 9 9
9 3 9 9 9 8 8 8 4 4 4 4 4 9 9 9
9 3 3 3 3 8 4 8 9 9 9 9 9 9 9 9
9 9 9 9 9 8 8 8 4 4 4 4 4 4 4 9
9 9 9 9 9 9 4 9 9 9 9 9 9 9 4 9
9 9 9 9 9 9 4 9 9 9 9 9 9 9 4 9
9 9 9 9 9 9 4 9 9 9 9 9 9 9 4 9
9 9 9 9 9 9 4 9 9 9 9 9 9 9 4 9
9 9 9 9 9 4 4 4 4 9 9 9 9 4 4 4
9 9 9 9 9 4 4 4 4 9 9 9 9 4 3 4
9 9 9 9 9 4 4 3 4 9 9 9 9 4 4 4
```


## train_2

**input:**
```
0 0 0 0 0 0 0 5 2 2
0 0 0 0 5 5 5 5 2 1
0 0 0 0 5 0 0 5 5 5
0 0 0 5 5 5 0 0 0 0
0 5 5 5 5 5 5 5 5 0
0 5 0 5 5 5 0 0 5 0
0 5 0 0 0 0 0 0 5 0
5 5 5 5 0 0 0 5 5 5
2 1 1 5 0 0 0 5 2 2
1 2 1 5 0 0 0 5 1 2
```


**output:**
```
0 0 0 0 0 0 0 2 2 2
0 0 0 0 2 2 2 2 2 1
0 0 0 0 2 0 0 2 2 2
0 0 0 5 5 5 0 0 0 0
0 1 1 5 2 5 2 2 2 0
0 1 0 5 5 5 0 0 2 0
0 1 0 0 0 0 0 0 2 0
1 1 1 1 0 0 0 2 2 2
2 1 1 1 0 0 0 2 2 2
1 2 1 1 0 0 0 2 1 2
```


## train_3

**input:**
```
6 6 6 6 6 7 8 8 8 8 7 5 6 5 7 8 8 8 8 8
6 6 5 6 6 7 8 8 8 8 7 6 5 5 7 8 8 8 8 8
5 6 6 6 6 7 7 7 8 8 7 7 7 7 7 8 8 8 8 8
6 6 6 6 6 7 8 7 8 8 8 7 8 8 8 8 8 8 8 8
6 6 6 6 6 7 8 7 7 8 8 7 8 8 8 8 8 8 8 8
7 7 7 7 7 7 8 8 7 8 7 7 8 8 8 8 8 7 7 7
8 8 8 7 8 8 8 8 7 8 7 8 8 8 8 8 8 7 5 6
8 8 8 7 8 8 8 8 7 8 7 8 8 7 7 7 7 7 5 5
8 8 8 7 7 7 7 7 7 7 7 7 7 7 8 8 8 7 5 6
8 8 8 8 8 8 8 8 7 7 7 8 8 8 8 8 8 7 6 5
8 8 8 7 7 7 7 7 7 7 7 8 8 8 8 8 8 7 7 7
8 8 8 7 8 8 8 8 7 8 7 8 8 8 8 8 8 8 8 8
8 8 8 7 8 8 8 8 7 8 7 8 8 8 8 8 8 8 8 8
7 7 7 7 7 7 7 8 7 8 7 8 8 8 8 8 8 8 8 8
6 5 6 6 6 6 7 7 7 8 7 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 7 8 8 8 7 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 7 8 8 8 7 8 8 8 8 8 8 8 8 8
6 6 6 6 6 5 7 8 8 7 7 7 7 7 7 7 8 8 8 8
6 5 6 6 5 6 7 8 8 7 6 5 5 6 5 7 8 8 8 8
6 6 6 6 6 6 7 8 8 7 6 5 5 6 5 7 8 8 8 8
```


**output:**
```
6 6 6 6 6 6 8 8 8 8 5 5 6 5 5 8 8 8 8 8
6 6 5 6 6 6 8 8 8 8 5 6 5 5 5 8 8 8 8 8
5 6 6 6 6 6 6 6 8 8 5 5 5 5 5 8 8 8 8 8
6 6 6 6 6 6 8 6 8 8 8 5 8 8 8 8 8 8 8 8
6 6 6 6 6 6 8 6 6 8 8 5 8 8 8 8 8 8 8 8
6 6 6 6 6 6 8 8 6 8 5 5 8 8 8 8 8 5 5 5
8 8 8 6 8 8 8 8 6 8 5 8 8 8 8 8 8 5 5 6
8 8 8 6 8 8 8 8 6 8 5 8 8 5 5 5 5 5 5 5
8 8 8 6 6 6 6 6 7 7 7 5 5 5 8 8 8 5 5 6
8 8 8 8 8 8 8 8 7 6 7 8 8 8 8 8 8 5 6 5
8 8 8 6 6 6 6 6 7 7 7 8 8 8 8 8 8 5 5 5
8 8 8 6 8 8 8 8 6 8 5 8 8 8 8 8 8 8 8 8
8 8 8 6 8 8 8 8 6 8 5 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 8 6 8 5 8 8 8 8 8 8 8 8 8
6 5 6 6 6 6 6 6 6 8 5 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 8 8 8 5 8 8 8 8 8 8 8 8 8
6 6 6 6 6 6 6 8 8 8 5 8 8 8 8 8 8 8 8 8
6 6 6 6 6 5 6 8 8 5 5 5 5 5 5 5 8 8 8 8
6 5 6 6 5 6 6 8 8 5 6 5 5 6 5 5 8 8 8 8
6 6 6 6 6 6 6 8 8 5 6 5 5 6 5 5 8 8 8 8
```

    *   ex1: Target=8 (72), A=3 (15), B=4 (21). Target is not the most frequent (9 is 148). A and B are less frequent.
    *   ex2: Target=5 (38), A=1 (6), B=2 (8). Target is not most frequent (0 is 48). A and B are least frequent.
    *   ex3: Target=7 (109), A=6 (64), B=5 (21). Target is not most frequent (8 is 206). A and B are less frequent.

    Is there a relationship between the *values*?
    *   ex1: T=8, A=3, B=4. No obvious arithmetic relationship.
    *   ex2: T=5, A=1, B=2. No obvious arithmetic relationship.
    *   ex3: T=7, A=6, B=5. A = T-1, B = T-2? Let's check others.
        *   ex1: T=8. T-1=7 (orange), T-2=6 (magenta). Not A=3, B=4.
        *   ex2: T=5. T-1=4 (yellow), T-2=3 (green). Not A=1, B=2.
    This arithmetic relationship only works for ex3.

    Maybe it's about the set of colors present?
    *   ex1: {3, 4, 8, 9}.
    *   ex2: {0, 1, 2, 5}.
    *   ex3: {5, 6, 7, 8}.
    In each case, the target T, color A, and color B are among the non-background colors (assuming 0 and 9 are background/noise).
    *   ex1: T=8, A=3, B=4 from {3, 4, 8}.
    *   ex2: T=5, A=1, B=2 from {1, 2, 5}.
    *   ex3: T=7, A=6, B=5 from {5, 6, 7, 8}.

    How to pick T, A, B from the set of significant colors {C1, C2, ..., Cn}?
    *   ex1: {3, 4, 8}. T=8, A=3, B=4. 8 is highest value. 3 and 4 are the others. B=4 > A=3.
    *   ex2: {1, 2, 5}. T=5, A=1, B=2. 5 is highest value. 1 and 2 are the others. B=2 > A=1.
    *   ex3: {5, 6, 7, 8}. Significant colors {5, 6, 7}. Color 8 is most frequent but doesn't participate? Let's re-examine ex3. Orange(7) changes. Magenta(6) and Gray(5) are the sources. Azure(8) is untouched. Why? Maybe 8 is like 9 in ex1 and 0 in ex2 - a passive color.
        *   ex1: Passive={9}. Active={3, 4, 8}. T=max(Active)=8. A=min(Active-T)=3. B=max(Active-T)=4. B > A.
        *   ex2: Passive={0}. Active={1, 2, 5}. T=max(Active)=5. A=min(Active-T)=1. B=max(Active-T)=2. B > A.
        *   ex3: Passive={8}. Active={5, 6, 7}. T=max(Active)=7. A=min(Active-T)=5. B=max(Active-T)=6. B > A.
        *   BUT, in ex3, the source colors were A=6 (magenta) and B=5 (gray). And the tie-break favored B=5. So the rule was `if dist_A < dist_B, change to A; else change to B`. This means the tie favors the color with the *lower* index (5 vs 6).
        *   Let's recheck ex2 tie-break. Pixel (1,4) had equal distance (5) to blue(1) and red(2). Output was red(2). Here, tie favors the color with the *higher* index (2 vs 1).
        *   This contradicts.

    Let's revisit the tie-breaking rule.
    *   ex2: T=5, A=1, B=2. Pixel (1,4) tie. Output is B=2. Tie -> B.
    *   ex3: T=7, A=6, B=5. Pixel (5,10) tie. Output is B=5. Tie -> B.

    Okay, the tie-breaking rule consistently favors Color B.

    Now, how are A and B determined?
    *   ex1: Active={3, 4, 8}. T=8. A=3, B=4.
    *   ex2: Active={1, 2, 5}. T=5. A=1, B=2.
    *   ex3: Active={5, 6, 7}. T=7. A=5, B=6. (Wait, I had A=6, B=5 before based on the test).

    Let's re-re-examine ex3.
    *   Target T=7 (orange).
    *   Sources are magenta(6) and gray(5). Let's call them S1=6, S2=5.
    *   Rule: For pixel=T, find min_dist(S1) and min_dist(S2).
    *   If min_dist(S1) < min_dist(S2), change to S1=6.
    *   If min_dist(S2) < min_dist(S1), change to S2=5.
    *   If min_dist(S1) == min_dist(S2), change to ???.
    *   Pixel (5,10)=7. min_dist(6)=6. min_dist(5)=5. Output is 5. Matches min_dist(S2) < min_dist(S1). No tie needed here. I miscalculated distances before.
        *   Recalc (5,10)=7:
            *   Nearest 6: (0,0)...(0,4) dists: 5+10=15 ... 5+6=11. (1,0)...(1,4) dists: 4+10=14 ... 4+6=10. (2,0)...(2,4) dists: 3+10=13 ... 3+6=9. (3,0)...(3,4) dists: 2+10=12 ... 2+6=8. (4,0)...(4,4) dists: 1+10=11 ... 1+6=7. (19,13) dist 14+3=17. Min dist to 6 is 7.
            *   Nearest 5: (1,11) dist 4+1=5. (2,12) dist 3+2=5. (6,18) dist 1+8=9. Min dist to 5 is 5.
        *   Indeed, min_dist(5) = 5 < min_dist(6) = 7. Output is 5. Correct.

    *   Let's find a real tie in ex3. Maybe (2, 5)=7?
        *   Nearest 6: (0,0)...(0,4) dists: 2+5=7...2+1=3. Min dist=3.
        *   Nearest 5: (1,11) dist 1+6=7. (2,12) dist 0+7=7. Min dist=7.
        *   Here min_dist(6) < min_dist(5). Output should be 6. Output at (2,5) is 6. Correct.

    *   Maybe (5, 6)=7?
        *   Nearest 6: (0,0)...(0,4) dists: 5+6=11...5+2=7. (1,0)...(1,4) dists: 4+6=10...4+2=6. (2,0)...(2,4) dists: 3+6=9...3+2=5. (3,0)...(3,4) dists: 2+6=8...2+2=4. (4,0)...(4,4) dists: 1+6=7...1+2=3. (5,0)...(5,4) dists: 0+6=6...0+2=2. Min dist=2 (from (5,4)).
        *   Nearest 5: (1,11) dist 4+5=9. (2,12) dist 3+6=9. Min dist=9.
        *   min_dist(6) < min_dist(5). Output should be 6. Output at (5,6) is 6. Correct.

    *   It seems I can't easily find a tie in ex3. Let's trust ex2's tie-break for now: tie favors the higher color index.
    *   Revisit ex2, pixel (1,4)=5. min_dist(1)=5, min_dist(2)=5. Tie. Output is 2. Favors higher index.

    Now, how to identify T, S1, S2 (Target, Source1, Source2)?
    *   ex1: Active={3, 4, 8}. T=8. S1=3, S2=4.
    *   ex2: Active={1, 2, 5}. T=5. S1=1, S2=2.
    *   ex3: Active={5, 6, 7}. T=7. S1=5, S2=6. (If we follow the pattern: T=max, S1=min, S2=middle).

    Let's redefine A and B consistently. Let A be the source with the lower index, and B be the source with the higher index.
    *   ex1: Active={3, 4, 8}. T=8. A=3, B=4. Tie favors B. Rule: If dist_A < dist_B -> A, If dist_B < dist_A -> B, If dist_A == dist_B -> B. Simpler: If dist_A <= dist_B -> B, else -> A? NO. If dist_B <= dist_A -> B, else -> A. YES.
    *   ex2: Active={1, 2, 5}. T=5. A=1, B=2. Tie favors B. Rule: If dist_B <= dist_A -> B, else -> A. YES.
    *   ex3: Active={5, 6, 7}. T=7. A=5, B=6. Does tie favor B=6? We couldn't find a tie. Let's assume it follows the pattern. Rule: If dist_B <= dist_A -> B, else -> A.

    Hypothesis Refined:
    1.  Identify "passive" colors (most frequent? Or specific like 0, 9, 8 in ex3?). Identify "active" colors (the rest).
    2.  From the "active" colors, find the one with the maximum value. This is the Target color T.
    3.  The remaining active colors are the Source colors. Let A be the source color with the minimum value, and B be the source color with the maximum value (among sources).
    4.  Create a copy of the input grid.
    5.  Iterate through each pixel (r, c) of the input grid.
    6.  If input[r, c] == T:
        *   Calculate `dist_A` = minimum Manhattan distance from (r, c) to any pixel with color A in the input grid.
        *   Calculate `dist_B` = minimum Manhattan distance from (r, c) to any pixel with color B in the input grid.
        *   If `dist_B <= dist_A`: Set output[r, c] = B.
        *   Else (`dist_A < dist_B`): Set output[r, c] = A.
    7.  If input[r, c] != T: Set output[r, c] = input[r, c].
    8.  Return the output grid.

    Identifying Passive/Active:
    *   ex1: Colors {3, 4, 8, 9}. Counts {3:15, 4:21, 8:72, 9:148}. Active={3, 4, 8}, Passive={9}. Passive is most frequent. T=max(Active)=8. A=min(Active-T)=3. B=max(Active-T)=4.
    *   ex2: Colors {0, 1, 2, 5}. Counts {0:48, 1:6, 2:8, 5:38}. Active={1, 2, 5}, Passive={0}. Passive is most frequent. T=max(Active)=5. A=min(Active-T)=1. B=max(Active-T)=2.
    *   ex3: Colors {5, 6, 7, 8}. Counts {5:21, 6:64, 7:109, 8:206}. Active={5, 6, 7}, Passive={8}. Passive is most frequent. T=max(Active)=7. A=min(Active-T)=5. B=max(Active-T)=6.

    This seems consistent. The passive color is the single most frequent color in the grid. The active colors are the rest. The target color T is the maximum value among active colors. The source colors A and B are the remaining active colors, with A < B. The transformation rule depends on the minimum distance to A and B, with B taking precedence in case of ties.

    Let's double check the logic and calculations for a few points.
    *   train_1, pixel (3, 6) = 8 (T). A=3, B=4. dist_A=3 (from (3,3)). dist_B=4 (from (2,3)). dist_A < dist_B. Rule says change to A=3. Output has 3. Correct.
    *   train_1, pixel (0, 11) = 8 (T). A=3, B=4. dist_A=9 (from (3,3)). dist_B=2 (from (0,13) or (1,12)). dist_B < dist_A. Rule says change to B=4. Output has 4. Correct.
    *   train_2, pixel (1, 4) = 5 (T). A=1, B=2. dist_A=5 (from (1,9)). dist_B=5 (from (0,8)). dist_B <= dist_A. Rule says change to B=2. Output has 2. Correct.
    *   train_3, pixel (0, 5) = 7 (T). A=5, B=6. dist_A=7 (from (1,11)). dist_B=4 (from (0,1)). dist_B < dist_A. Rule says change to B=6. Output has 6. Correct.
    *   train_3, pixel (0, 10) = 7 (T). A=5, B=6. dist_A=2 (from (1,11)). dist_B=6 (from (0,4) or (1,5)). dist_A < dist_B. Rule says change to A=5. Output has 5. Correct.

    The logic seems solid across all examples.

    **Final Plan:**
    1.  Perception: Note the grid size, colors involved. Observe that one specific color changes based on proximity to two other specific colors. Other colors remain unchanged.
    2.  Facts: Document the colors, the concept of Manhattan distance, the identification of Target/Source colors based on frequency and value, and the comparison logic including tie-breaking.
    3.  NL Program: Describe the steps: find counts, identify passive (most frequent) color, identify active colors, determine T (max active), A (min source), B (max source), iterate through grid, calculate distances for T pixels, apply the transformation rule (change to B if dist_B <= dist_A, else change to A).*   **Perception**:
    *   The task involves transforming input grids based on the proximity of certain pixels to others.
    *   Each example uses a distinct set of colors, but a similar pattern emerges across them.
    *   In each example, there appears to be one "target" color whose pixels might change.
    *   There also appear to be two "source" colors that influence the change of the target color pixels.
    *   One color in each grid seems "passive" or acts as a background/noise, remaining unchanged and not influencing others. This passive color is consistently the most frequent color in the input grid.
    *   The transformation rule involves calculating the Manhattan distance from each target pixel to the nearest pixel of each source color.
    *   The target pixel's color changes to one of the source colors based on which source is closer. A specific tie-breaking rule seems to apply when distances are equal.
    *   Pixels that are not of the target color remain unchanged.

*   **Facts**:
    
```yaml
    task_type: pixel_transformation
    transformation_scope: local_neighbor_influence
    elements:
      - element: grid
        properties:
          - shape: variable (e.g., 16x16, 10x10, 20x20)
          - colors: multiple (integers 0-9)
      - element: pixel
        properties:
          - color: integer 0-9
          - position: (row, column)
      - element: color_group
        properties:
          - type: passive (most frequent color in the input grid)
          - type: active (all other colors present in the input grid)
          - type: target (T) (the active color with the highest numerical value)
          - type: source_A (the active color, excluding T, with the lowest numerical value)
          - type: source_B (the active color, excluding T, with the highest numerical value)
    relationships:
      - type: spatial_proximity
        measure: Manhattan distance
        between: target_pixel
        and: source_A_pixels, source_B_pixels
    actions:
      - action: identify_colors
        inputs: input_grid
        outputs: passive_color, active_colors {T, A, B}
        logic: Count color frequencies. Most frequent is passive. Others are active. T=max(active), A=min(active-{T}), B=max(active-{T}).
      - action: calculate_min_distance
        inputs: target_pixel_position, source_color_pixels_positions
        outputs: minimum_manhattan_distance
      - action: transform_pixel
        inputs: target_pixel, min_dist_A, min_dist_B
        outputs: new_pixel_color
        condition: Applies only to pixels with the target color T.
        rule: If min_dist_B <= min_dist_A, new_color = B. Else, new_color = A.
      - action: copy_pixel
        inputs: input_pixel
        outputs: output_pixel
        condition: Applies to pixels whose color is not the target color T.
        rule: output_pixel_color = input_pixel_color.
    ```


*   **Natural Language Program**:
    1.  Analyze the input grid to identify all unique colors present and count their frequencies.
    2.  Determine the "passive" color: the color with the highest frequency.
    3.  Identify the "active" colors: all colors present in the grid except the passive color.
    4.  From the set of active colors, identify the "target" color (T): the active color with the highest numerical value.
    5.  Identify the two "source" colors from the remaining active colors: Let Source A be the one with the lower numerical value and Source B be the one with the higher numerical value.
    6.  Create a list of coordinates for all pixels having color Source A and another list for all pixels having color Source B.
    7.  Initialize an output grid as a copy of the input grid.
    8.  Iterate through each pixel at position (row, column) in the input grid.
    9.  If the color of the current input pixel `input[row, column]` is the target color T:
        a.  Calculate `min_dist_A`: the minimum Manhattan distance from (row, column) to any pixel coordinate in the list for Source A. If no Source A pixels exist, treat the distance as infinite.
        b.  Calculate `min_dist_B`: the minimum Manhattan distance from (row, column) to any pixel coordinate in the list for Source B. If no Source B pixels exist, treat the distance as infinite.
        c.  Compare the distances: If `min_dist_B` is less than or equal to `min_dist_A`, set the corresponding pixel in the output grid `output[row, column]` to color Source B.
        d.  Otherwise (if `min_dist_A` is strictly less than `min_dist_B`), set the corresponding pixel in the output grid `output[row, column]` to color Source A.
    10. If the color of the current input pixel is *not* the target color T, its value in the output grid remains unchanged (as initially copied).
    11. After iterating through all pixels, return the final output grid.
