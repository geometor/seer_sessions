{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy\n\n\"\"\"\nApplies a cyclical color transformation to three specific non-background colors, \nleaving other colors unchanged. The three colors are selected based on their \nobject count (fewest first), total area (smallest first), and color value \n(highest first for ties). The cycle maps the first selected color (C1) to the \nthird (C3), the second (C2) to the first (C1), and the third (C3) to the second (C2).\n\n1. Determine the background color (most frequent).\n2. Find all non-background colors, count their distinct objects (4-neighbor), \n   and calculate their total area.\n3. Sort these colors by object count (asc), then area (asc), then color value (desc).\n4. If fewer than three such colors exist, return the original grid.\n5. Select the first three colors from the sorted list: C1, C2, C3.\n6. Create a transformation mapping: C1 -> C3, C2 -> C1, C3 -> C2.\n7. Apply this mapping to all pixels in the grid. Pixels not matching C1, C2, \n   or C3 remain unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a specific color in the grid using 4-neighbor adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects, where each object is represented by a set\n              of (row, col) tuples. Returns an empty list if the color\n              is not found or forms no objects.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                current_object = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    current_object.add((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if current_object:\n                    objects.append(current_object)\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the cyclical color transformation based on object count, area, and color value.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle empty grid case\n    if input_array.size == 0:\n        return []\n        \n    rows, cols = input_array.shape\n\n    # 1. Determine the background color\n    flat_array = input_array.flatten()\n    color_counts = Counter(flat_array)\n    \n    # Handle case with only one color\n    if len(color_counts) <= 1:\n        return input_grid # Return original grid\n        \n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Identify non-background colors and their properties\n    color_properties = []\n    for color, count in color_counts.items():\n        if color != background_color:\n            # 3. Count objects and get total area\n            objects = find_objects(input_array, color)\n            num_objects = len(objects)\n            total_area = count # Total pixels of this color\n            if num_objects > 0: # Only consider colors actually forming objects\n                 # 4. Create list of properties\n                 color_properties.append({'color': color, 'obj_count': num_objects, 'area': total_area})\n\n    # 4 & 6. Check if at least three non-background colors exist\n    if len(color_properties) < 3:\n        return input_grid # Return original grid unchanged\n\n    # 5. Sort the list of colors\n    # Primary key: object count (ascending)\n    # Secondary key: total area (ascending)\n    # Tertiary key: color value (descending)\n    color_properties.sort(key=lambda x: (x['obj_count'], x['area'], -x['color']))\n\n    # 7. Select the first three colors\n    color1_props = color_properties[0]\n    color2_props = color_properties[1]\n    color3_props = color_properties[2]\n\n    c1 = color1_props['color']\n    c2 = color2_props['color']\n    c3 = color3_props['color']\n\n    # 8. Create the transformation mapping\n    transformation_map = {\n        c1: c3,\n        c2: c1,\n        c3: c2\n    }\n\n    # 9. Create output grid and apply transformation\n    output_array = np.copy(input_array)\n    for r in range(rows):\n        for c in range(cols):\n            original_color = input_array[r, c]\n            if original_color in transformation_map:\n                output_array[r, c] = transformation_map[original_color]\n            # else: color remains unchanged (already handled by copy)\n\n    # 10. Return the modified grid as list of lists\n    return output_array.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15379,
    "candidates_token_count": 1366,
    "total_token_count": 16745,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 12.895439
}