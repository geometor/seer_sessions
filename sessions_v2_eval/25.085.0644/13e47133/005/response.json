{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nTransformation Rule:\n1.  **Identify Grid Structure:**\n    *   Determine the background color (the most frequent color, excluding Red=2).\n    *   Identify the Red (color 2) divider lines: find the index `v` of the first complete vertical Red column and the index `h` of the first row where the horizontal Red line segment begins at column `v`. This defines the intersection point `(h, v)`.\n2.  **Identify Initiators:** Locate all pixels in the input grid whose color is neither the background color nor Red. Record their positions (row, col) and colors.\n3.  **Perform Quadrant-Based Filling:**\n    *   Create an output grid as a copy of the input grid.\n    *   Define the four quadrants based on `h` and `v`: Top-Left (TL: `rows < h, cols < v`), Top-Right (TR: `rows < h, cols > v`), Bottom-Left (BL: `rows >= h, cols < v`), Bottom-Right (BR: `rows >= h, cols > v`).\n    *   For each quadrant independently:\n        *   Find all initiators located *within* that specific quadrant.\n        *   For every pixel `(r, c)` *within* that quadrant that has the background color in the input grid:\n            *   Calculate the Manhattan distance from `(r, c)` to every initiator *within the same quadrant*.\n            *   Find the minimum distance.\n            *   Identify all initiators within the quadrant at that minimum distance.\n            *   Apply tie-breaking: select the initiator among the closest ones that has the lowest color index. If colors are tied, select the one with the lowest row index; if rows are tied, select the one with the lowest column index.\n            *   Set the color of the pixel `(r, c)` in the *output grid* to the color of the selected initiator.\n4.  **Conditional BL Quadrant Reflection:**\n    *   Check the *input grid's* BL quadrant (rows `h` to end, columns `0` to `v-1`) to see if it contains any initiator pixels.\n    *   **If** the input BL quadrant contains **no** initiator pixels:\n        *   Define the TL region in the *output grid* (rows `0` to `h-1`, columns `0` to `v-1`) and the BL region in the *output grid* (rows `h` to end, columns `0` to `v-1`). Let their heights be `h_tl = h` and `h_bl = rows - h`.\n        *   Determine the height `h_copy = min(h_tl, h_bl)`.\n        *   If `h_copy > 0` and `v > 0` (i.e., TL region is not empty):\n            *   Extract the bottom `h_copy` rows from the TL region of the output grid (`output_grid[h_tl - h_copy : h_tl, 0:v]`).\n            *   Flip this extracted sub-grid vertically.\n            *   Place the flipped sub-grid into the top `h_copy` rows of the BL region in the output grid (rows `h` to `h + h_copy - 1`).\n            *   **If** the BL region is taller than the TL region (`h_bl > h_tl`):\n                *   Take the row that was just placed at the top of the BL region (row `h` in the output grid).\n                *   Fill all remaining rows in the BL region (from `h + h_copy` to the end) by repeating this row.\n5.  **Return Output:** The modified output grid is the result.\n\"\"\"\n\ndef find_background_color(grid, divider_color):\n    \"\"\"Finds the most frequent color excluding the divider color.\"\"\"\n    pixels = grid[grid != divider_color]\n    if pixels.size == 0:\n        # Default to 0 if only divider color exists or grid is empty\n        return 0\n    count = Counter(pixels)\n    # Handle case where all non-divider pixels are unique - return lowest index?\n    # Based on examples, seems there's always a dominant background.\n    if not count:\n         # If only divider color existed, pixels was empty. If grid only had one\n         # other color, count will have one entry. If grid was empty, pixels was empty.\n         # This case *shouldn't* be hit if there are non-divider pixels.\n         # Fallback, though unlikely needed for this task based on examples.\n         unique_colors = np.unique(grid[grid != divider_color])\n         return unique_colors[0] if unique_colors.size > 0 else 0\n\n    background_color = count.most_common(1)[0][0]\n    return background_color\n\ndef find_dividing_intersection(grid, divider_color):\n    \"\"\"\n    Finds the intersection point (h, v) defined by the vertical divider\n    and the start of the horizontal divider segment.\n    'v' is the index of the first full vertical divider column.\n    'h' is the index of the first row where grid[h, v] and grid[h, v+1] are divider_color.\n    Returns (h, v) or (None, None) if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    v_idx = None\n    h_idx = None\n\n    # Find vertical divider index 'v' (first full column of divider_color)\n    for c in range(cols):\n        if np.all(grid[:, c] == divider_color):\n            v_idx = c\n            break\n\n    if v_idx is None:\n        return None, None # No full vertical divider found\n\n    # Check if v_idx+1 is within bounds for horizontal check\n    if v_idx + 1 >= cols:\n        # Vertical divider is at the right edge, no horizontal segment possible starting from it\n        # Need to check if *any* horizontal segment exists. Let's search row by row.\n        for r in range(rows):\n            if np.any(grid[r, :] == divider_color) and grid[r, v_idx] == divider_color:\n                 # Found a row with a divider segment that includes the vertical line\n                 # Let's refine 'h' to be the *first* such row where grid[h,v-1] is also divider? No.\n                 # Let's stick to the original definition: where horizontal segment *starts* at v\n                 # If v+1 is out of bounds, this definition fails.\n                 # Let's redefine h slightly: the first row index containing the horizontal divider segment.\n                 is_horizontal_segment = False\n                 for c_check in range(cols -1):\n                     if grid[r, c_check] == divider_color and grid[r, c_check+1] == divider_color:\n                         is_horizontal_segment = True\n                         break\n                 if is_horizontal_segment and grid[r, v_idx] == divider_color:\n                     h_idx = r\n                     break\n        # If no horizontal segment found connected to v_idx, h_idx remains None.\n        # But the original definition was grid[h,v]==2 AND grid[h,v+1]==2.\n        # So if v+1 is out of bounds, h cannot be found by that definition.\n        # Let's revert to the stricter interpretation based on the successful examples.\n        return None, v_idx # Cannot find 'h' if v is at the right edge based on original definition.\n\n    # Find horizontal start row 'h' using the original definition\n    for r in range(rows):\n        # Check if the cell at (r, v_idx) and the one to its right are the divider color\n        if grid[r, v_idx] == divider_color and grid[r, v_idx + 1] == divider_color:\n            h_idx = r\n            break\n\n    # h_idx might still be None if no horizontal segment starts *at* v_idx\n    # If h_idx is None but v_idx was found, return v_idx but None for h\n    return h_idx, v_idx\n\ndef find_initiators(grid, background_color, divider_color):\n    \"\"\"Finds coordinates and colors of initiator pixels.\"\"\"\n    initiators = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = grid[r, c]\n            if pixel_color != background_color and pixel_color != divider_color:\n                initiators.append({'row': r, 'col': c, 'color': pixel_color})\n    return initiators\n\ndef manhattan_distance(r1, c1, r2, c2):\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(r1 - r2) + abs(c1 - c2)\n\ndef fill_quadrant_voronoi(grid, output_grid, bounds, all_initiators, bg_color):\n    \"\"\"Fills a quadrant based on closest initiator using Manhattan distance.\"\"\"\n    r_start, r_end, c_start, c_end = bounds\n    rows, cols = grid.shape\n\n    # Filter initiators to only those within this quadrant's bounds\n    quadrant_initiators = [\n        init for init in all_initiators\n        if r_start <= init['row'] < r_end and c_start <= init['col'] < c_end\n    ]\n\n    if not quadrant_initiators:\n        return # No initiators in this quadrant, nothing to fill\n\n    # Iterate through each cell in the quadrant\n    for r in range(r_start, r_end):\n        for c in range(c_start, c_end):\n            # Only fill background cells\n            if grid[r, c] == bg_color:\n                min_dist = math.inf\n                closest_initiators_at_min_dist = []\n\n                # Find distance to each initiator in this quadrant\n                for init in quadrant_initiators:\n                    dist = manhattan_distance(r, c, init['row'], init['col'])\n\n                    if dist < min_dist:\n                        min_dist = dist\n                        closest_initiators_at_min_dist = [init]\n                    elif dist == min_dist:\n                        closest_initiators_at_min_dist.append(init)\n\n                # Apply tie-breaking if necessary\n                if len(closest_initiators_at_min_dist) > 1:\n                    # Sort by color index, then row, then col\n                    closest_initiators_at_min_dist.sort(key=lambda i: (i['color'], i['row'], i['col']))\n                    winning_initiator = closest_initiators_at_min_dist[0]\n                elif len(closest_initiators_at_min_dist) == 1:\n                    winning_initiator = closest_initiators_at_min_dist[0]\n                else:\n                    # Should not happen if grid[r,c] is bg_color and quadrant_initiators is not empty\n                    continue\n\n                # Update the output grid\n                output_grid[r, c] = winning_initiator['color']\n\n\ndef check_initiators_in_region(grid, r_start, r_end, c_start, c_end, background_color, divider_color):\n    \"\"\"Checks if any initiator pixels exist within the specified region [r_start:r_end, c_start:c_end].\"\"\"\n    # Ensure bounds are valid before slicing/iterating\n    rows, cols = grid.shape\n    r_end = min(r_end, rows)\n    c_end = min(c_end, cols)\n    r_start = max(r_start, 0)\n    c_start = max(c_start, 0)\n\n    if r_start >= r_end or c_start >= c_end:\n        return False # Region is empty\n\n    region = grid[r_start:r_end, c_start:c_end]\n\n    # Check if any pixel in the region is neither background nor divider\n    for r in range(region.shape[0]):\n        for c in range(region.shape[1]):\n            if region[r, c] != background_color and region[r, c] != divider_color:\n                return True # Found an initiator\n    return False # No initiators found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies Voronoi-like fill within quadrants based on Manhattan distance\n    and conditionally reflects/repeats the top-left quadrant to the bottom-left.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n    divider_color = 2 # Red\n\n    # --- Step 1: Identify Grid Structure ---\n    background_color = find_background_color(input_np, divider_color)\n    h_intersect, v_intersect = find_dividing_intersection(input_np, divider_color)\n\n    # Handle cases where intersection wasn't properly found\n    if h_intersect is None or v_intersect is None:\n         # Task constraints likely guarantee intersection, but good practice to handle\n         print(f\"Warning: Could not find valid intersection point (h={h_intersect}, v={v_intersect}). Returning copy of input.\")\n         return output_np.tolist()\n\n    # --- Step 2: Identify Initiators ---\n    initiators = find_initiators(input_np, background_color, divider_color)\n\n    # --- Step 3: Perform Quadrant-Based Filling ---\n    # Define quadrant bounds (exclusive for end row/col)\n    tl_bounds = (0, h_intersect, 0, v_intersect)\n    tr_bounds = (0, h_intersect, v_intersect + 1, cols)\n    bl_bounds = (h_intersect, rows, 0, v_intersect) # Starts from row h\n    br_bounds = (h_intersect, rows, v_intersect + 1, cols) # Starts from row h\n\n    # Fill each quadrant\n    fill_quadrant_voronoi(input_np, output_np, tl_bounds, initiators, background_color)\n    fill_quadrant_voronoi(input_np, output_np, tr_bounds, initiators, background_color)\n    fill_quadrant_voronoi(input_np, output_np, bl_bounds, initiators, background_color)\n    fill_quadrant_voronoi(input_np, output_np, br_bounds, initiators, background_color)\n\n    # --- Step 4: Conditional BL Quadrant Reflection ---\n    # Define Bottom-Left quadrant bounds for input grid check (inclusive start, exclusive end)\n    bl_check_r_start, bl_check_r_end = h_intersect, rows\n    bl_check_c_start, bl_check_c_end = 0, v_intersect\n\n    # Check the INPUT grid's bottom-left region for initiators\n    bottom_left_has_initiators = check_initiators_in_region(\n        input_np, bl_check_r_start, bl_check_r_end, bl_check_c_start, bl_check_c_end, background_color, divider_color\n    )\n\n    if not bottom_left_has_initiators:\n        # Define TL and BL regions in the output grid\n        h_tl = h_intersect\n        w_tl = v_intersect\n        h_bl = rows - h_intersect\n        w_bl = v_intersect # Widths must match\n\n        # Proceed only if TL region exists\n        if h_tl > 0 and w_tl > 0:\n            h_copy = min(h_tl, h_bl)\n\n            # Extract the bottom h_copy rows from the filled TL quadrant\n            sub_tl = output_np[h_tl - h_copy : h_tl, 0:w_tl]\n\n            # Flip vertically\n            flipped_sub_tl = np.flipud(sub_tl)\n\n            # Paste into the top h_copy rows of the BL quadrant\n            output_np[h_intersect : h_intersect + h_copy, 0:w_bl] = flipped_sub_tl\n\n            # If BL is taller than TL, repeat the top row of the pasted section\n            if h_bl > h_tl:\n                # Ensure there are rows left to fill\n                if h_intersect + h_copy < rows:\n                    # Get the row that was just pasted at the top of BL (index h_intersect)\n                    repeat_row = output_np[h_intersect, 0:w_bl]\n                    # Fill remaining rows\n                    for r_extra in range(h_intersect + h_copy, rows):\n                        output_np[r_extra, 0:w_bl] = repeat_row\n                # else: # h_bl > h_tl but h_intersect + h_copy == rows; should not happen if h_copy = h_tl < h_bl\n                #    pass # No more rows to fill, just pasted up to the end\n\n\n    # --- Step 5: Return Result ---\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14481,
    "candidates_token_count": 4005,
    "total_token_count": 18486,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.780632
}