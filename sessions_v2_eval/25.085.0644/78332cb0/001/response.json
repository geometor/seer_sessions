{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport itertools\n\ndef find_separators(grid_np):\n    \"\"\"\n    Find indices of full rows and columns consisting entirely of magenta (6).\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing two lists:\n        - sep_rows: Indices of rows that are full separators.\n        - sep_cols: Indices of columns that are full separators.\n    \"\"\"\n    sep_color = 6\n    h, w = grid_np.shape\n    sep_rows = [r for r in range(h) if np.all(grid_np[r, :] == sep_color)]\n    sep_cols = [c for c in range(w) if np.all(grid_np[:, c] == sep_color)]\n    return sep_rows, sep_cols\n\ndef extract_blocks(grid_np, sep_rows, sep_cols):\n    \"\"\"\n    Extracts the rectangular subgrids (blocks) located between the separators.\n    Blocks are returned along with their original row/column index within the \n    conceptual grid formed by the separators.\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n        sep_rows: A list of indices for horizontal separator rows.\n        sep_cols: A list of indices for vertical separator columns.\n\n    Returns:\n        A list of dictionaries, where each dictionary contains:\n        - 'data': The numpy array of the extracted block.\n        - 'row': The original row index of the block in the grid-of-blocks.\n        - 'col': The original column index of the block in the grid-of-blocks.\n    \"\"\"\n    h, w = grid_np.shape\n    blocks_info = []\n    \n    # Define the boundaries for slicing, including edges of the grid\n    row_coords = [-1] + sorted(sep_rows) + [h]\n    col_coords = [-1] + sorted(sep_cols) + [w]\n\n    # Iterate through the segments defined by row separators\n    for r_idx, (r_start, r_end) in enumerate(zip(row_coords[:-1], row_coords[1:])):\n        # Iterate through the segments defined by column separators\n        for c_idx, (c_start, c_end) in enumerate(zip(col_coords[:-1], col_coords[1:])):\n            # Calculate the actual block coordinates (start+1 to exclude separator)\n            block_r_start = r_start + 1\n            block_r_end = r_end\n            block_c_start = c_start + 1\n            block_c_end = c_end\n\n            # Check if the calculated coordinates define a valid block area\n            if block_r_start < block_r_end and block_c_start < block_c_end:\n                block = grid_np[block_r_start:block_r_end, block_c_start:block_c_end]\n                # Store the block data and its original position (grid-of-blocks index)\n                blocks_info.append({'data': block, 'row': r_idx, 'col': c_idx})\n                \n    return blocks_info\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies separator lines (rows or columns of magenta 6) in the input grid.\n    Extracts the blocks defined by these separators.\n    Reassembles the blocks into a new grid based on the separator configuration:\n    - Input Horizontal separators only -> Output Horizontal assembly, blocks ordered bottom-to-top.\n    - Input Vertical separators only -> Output Vertical assembly, blocks ordered left-to-right.\n    - Input Both separator types -> Output Vertical assembly, blocks ordered TL, BR, TR, BL.\n    Separators (single row/column of magenta 6) are inserted between blocks in the output, \n    with orientation opposite to the input separators defining the output assembly direction\n    (e.g., horizontal assembly uses vertical separators).\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    h, w = input_np.shape\n    sep_color = 6\n\n    # 1. & 2. Identify separator rows and columns.\n    sep_rows, sep_cols = find_separators(input_np)\n\n    # 3. Determine the type of segmentation based on found separators.\n    has_horizontal = bool(sep_rows)\n    has_vertical = bool(sep_cols)\n\n    segmentation_type = \"none\"\n    if has_horizontal and has_vertical:\n        segmentation_type = \"both\"\n    elif has_horizontal:\n        segmentation_type = \"horizontal\"\n    elif has_vertical:\n        segmentation_type = \"vertical\"\n    else:\n        # If no separators are found, return the input grid unchanged.\n        return input_grid \n\n    # 4. Extract the blocks based on the separators.\n    blocks_info = extract_blocks(input_np, sep_rows, sep_cols)\n    \n    # If no blocks could be extracted (e.g., grid only contains separators), return input.\n    if not blocks_info: \n        return input_grid \n\n    # Assume all blocks have the same dimensions, get from the first block.\n    sample_block = blocks_info[0]['data']\n    block_h, block_w = sample_block.shape\n\n    # 5. & 6. Determine the output orientation and the order of blocks.\n    ordered_blocks = []\n    output_orientation = \"vertical\" # Default, changed if only horizontal seps found\n\n    if segmentation_type == \"horizontal\":\n        output_orientation = \"horizontal\"\n        # Order blocks by their original row index, descending (bottom-up).\n        ordered_blocks = [b['data'] for b in sorted(blocks_info, key=lambda x: x['row'], reverse=True)]\n    elif segmentation_type == \"vertical\":\n        output_orientation = \"vertical\"\n        # Order blocks by their original column index, ascending (left-to-right).\n        ordered_blocks = [b['data'] for b in sorted(blocks_info, key=lambda x: x['col'])]\n    elif segmentation_type == \"both\":\n        output_orientation = \"vertical\"\n        # Special order for 'both' case: Top-Left, Bottom-Right, Top-Right, Bottom-Left.\n        # Create a dictionary mapping (row, col) index to block data for easy lookup.\n        block_dict = {(b['row'], b['col']): b['data'] for b in blocks_info}\n        # Define the specific order of indices. Assumes a 2x2 grid structure.\n        order_indices = [(0, 0), (1, 1), (0, 1), (1, 0)] # TL, BR, TR, BL\n        for r, c in order_indices:\n             # Only add the block if it exists for the given index.\n             if (r, c) in block_dict: \n                 ordered_blocks.append(block_dict[(r,c)])\n             # Note: This implicitly handles grids that might not be perfectly 2x2 \n             # by only including the blocks that exist in the specified order.\n\n    # If ordering resulted in no blocks (e.g., missing blocks in 'both' case), return input.\n    if not ordered_blocks: \n        return input_grid\n\n    # 7. Construct the output grid by assembling blocks and separators.\n    num_blocks = len(ordered_blocks)\n    \n    if output_orientation == \"vertical\":\n        # Stack blocks vertically, insert horizontal separators between them.\n        # Separator is a single row with the width of a block.\n        separator = np.full((1, block_w), sep_color, dtype=int)\n        output_components = []\n        for i, block in enumerate(ordered_blocks):\n            output_components.append(block)\n            # Add a separator after each block except the last one.\n            if i < num_blocks - 1:\n                output_components.append(separator)\n        # Combine all components vertically.\n        output_grid = np.vstack(output_components)\n        \n    elif output_orientation == \"horizontal\":\n        # Arrange blocks horizontally, insert vertical separators between them.\n        # Separator is a single column with the height of a block.\n        separator = np.full((block_h, 1), sep_color, dtype=int)\n        output_components = []\n        for i, block in enumerate(ordered_blocks):\n            output_components.append(block)\n            # Add a separator after each block except the last one.\n            if i < num_blocks - 1:\n                output_components.append(separator)\n        # Combine all components horizontally.\n        output_grid = np.hstack(output_components)\n    else:\n         # Fallback: Should not be reached due to earlier logic.\n         return input_grid\n\n    # Convert the final numpy array back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3546,
    "candidates_token_count": 2078,
    "total_token_count": 5624,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 47.953546
}