{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the following rules:\n\n1.  **Initialize:** Start with the input grid. Create a working copy.\n2.  **Yellow Connection:**\n    *   Identify all Yellow (4) pixels in the current working grid.\n    *   For each row, find pairs of Yellow pixels.\n    *   If the horizontal path strictly between a pair of Yellow pixels on the same row consists only of White (0) pixels, fill that path with Yellow (4) in the working grid.\n    *   Repeat this connection process on the updated working grid until no more connections can be made in a full pass. Store this grid state.\n3.  **Source Identification and Mapping:**\n    *   Refer back to the *original* input grid. Identify all non-White (0) and non-Yellow (4) pixels. These are the \"expansion sources\".\n    *   Determine if any of these identified expansion sources are Magenta (6) (`has_magenta_source`).\n    *   Determine if the *original* input grid contains *any* Orange (7) pixels (not necessarily sources) (`has_orange_anywhere`).\n    *   Create a mapping for how source colors will expand:\n        *   If a source is Azure (8) AND `has_magenta_source` is true, it expands as Blue (1).\n        *   If a source is Magenta (6) AND `has_orange_anywhere` is true, it expands as Orange (7).\n        *   All other sources expand using their own original color.\n4.  **Simultaneous Expansion (BFS):**\n    *   Start a simultaneous Breadth-First Search (BFS) from all identified expansion sources on the grid resulting from the Yellow Connection phase (Step 2).\n    *   The BFS expands one step (Manhattan distance) at a time into adjacent cells.\n    *   **Expansion Condition:** A source can only expand into a cell if that cell was White (0) in the *original* input grid AND is currently White (0) in the working grid (i.e., hasn't been filled by Yellow connections or previous expansion steps). This check implicitly handles obstacles defined by originally non-white cells and connected yellow cells.\n    *   **Obstacles:** Expansion is blocked by grid boundaries and any cell that is not eligible based on the Expansion Condition.\n    *   **Conflict Resolution:** If multiple *different* sources attempt to expand into the same valid White cell in the *same step* of the BFS, that cell remains White (0) and becomes an obstacle, preventing any source from expanding into or through it in subsequent steps.\n    *   **Coloring:** When a source successfully expands into a cell, the cell is filled with the color determined by the color mapping defined in Step 3, based on the *original* color of the source that reached it.\n5.  **Output:** The final grid is the state of the working grid after the expansion process is complete. It contains the original non-White pixels, the added Yellow connections, and the colored expansions, with contested areas remaining White.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # 1. Initialize: Create a working copy\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Yellow Connection Phase\n    made_connection = True\n    while made_connection:\n        made_connection = False\n        for r in range(rows):\n            # Find yellow pixel indices in the current row of the working grid\n            yellow_indices = [c for c in range(cols) if output_grid[r, c] == 4]\n            if len(yellow_indices) >= 2:\n                for i in range(len(yellow_indices) - 1):\n                    c1 = yellow_indices[i]\n                    c2 = yellow_indices[i+1]\n                    # Check if path between c1 and c2 (exclusive) is all white (0) in the working grid\n                    can_connect = True\n                    if c2 > c1 + 1: # Only check if there are cells between them\n                        for k in range(c1 + 1, c2):\n                            # Check the current state of the output_grid\n                            if output_grid[r, k] != 0:\n                                can_connect = False\n                                break\n                        if can_connect:\n                            # Fill the path with yellow (4) in the working grid\n                            for k in range(c1 + 1, c2):\n                                # Ensure we only fill if it's currently white (already checked, but safe)\n                                if output_grid[r, k] == 0:\n                                     output_grid[r, k] = 4\n                                     made_connection = True # Signal that a change occurred to repeat the process\n\n    # Store the grid state after yellow connections\n    grid_with_yellow_connections = np.copy(output_grid)\n\n    # 3. Source Identification and Mapping\n    sources = []\n    has_magenta_source = False\n    has_orange_anywhere = False\n    source_coords_colors = {} # Store original color at source coord: {(r, c): color}\n\n    for r in range(rows):\n        for c in range(cols):\n            color = input_grid[r, c] # Check ORIGINAL grid\n            if color != 0:\n                if color == 7:\n                    has_orange_anywhere = True # Check if orange exists anywhere in original\n                if color != 4: # Non-white, non-yellow are potential sources\n                    sources.append(((r, c), color))\n                    source_coords_colors[(r, c)] = color\n                    if color == 6:\n                        has_magenta_source = True # Check if any source is magenta\n\n    # Create the expansion color map based on original source colors\n    expansion_color_map = {}\n    for _, color in sources:\n        if color not in expansion_color_map: # Avoid redundant mapping\n            if color == 8 and has_magenta_source:\n                expansion_color_map[color] = 1 # Azure -> Blue\n            elif color == 6 and has_orange_anywhere:\n                expansion_color_map[color] = 7 # Magenta -> Orange\n            else:\n                expansion_color_map[color] = color # Other sources expand as themselves\n\n    # 4. Simultaneous Expansion Phase (BFS)\n    # distance: Stores the step count when a cell is reached. -1 means unreached.\n    # owner: Stores the coordinate tuple (sr, sc) of the source that reached the cell.\n    #        None means unreached/unowned. \"CONTESTED\" means multiple sources reached simultaneously.\n    distance = np.full((rows, cols), -1, dtype=int)\n    owner = np.full((rows, cols), None, dtype=object)\n    queue = deque()\n\n    # Initialize BFS queue and state grids with sources\n    for (r, c), color in sources:\n         # Check if source still exists in the grid after yellow connection (it should, unless yellow overwrote it)\n         # We base ownership on the original source location\n         if grid_with_yellow_connections[r, c] == input_grid[r,c]: # Ensure source wasn't paved over by yellow\n            distance[r, c] = 0\n            owner[r, c] = (r, c) # Owner is the coord tuple\n            queue.append(((r, c), 0)) # ((row, col), dist)\n\n    # Main BFS loop processing level by level\n    current_dist = 0\n    while queue:\n        # Dictionary to track cells reached in this specific step for conflict detection\n        # Format: {(nr, nc): originating_owner_coord}\n        newly_reached_this_step = {}\n\n        # Process all nodes at the current distance level\n        level_size = len(queue)\n        if level_size == 0: break\n\n        # Peek distance of the first element to confirm the current level\n        if queue:\n             _, peek_dist = queue[0]\n             current_dist = peek_dist\n\n        # Process all elements belonging to the current distance level\n        processed_count_in_level = 0\n        while queue and queue[0][1] == current_dist:\n             (r, c), dist = queue.popleft()\n             processed_count_in_level += 1\n\n             # Get the owner coord tuple of the current cell expanding\n             current_owner_coord = owner[r, c]\n\n             # If the current cell became contested earlier (shouldn't happen if processing level by level correctly, but safe check)\n             # or if it's not owned by a source tuple (e.g., None initially)\n             if not isinstance(current_owner_coord, tuple):\n                 continue\n\n             # Explore neighbors (Manhattan distance)\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r + dr, c + dc\n\n                 # Check bounds\n                 if 0 <= nr < rows and 0 <= nc < cols:\n                     # *** Expansion Condition ***\n                     # 1. Must be originally white in the input grid\n                     # 2. Must be currently unoccupied/uncontested in the BFS state (owner is None)\n                     #    This implicitly checks that it wasn't filled by yellow connections earlier,\n                     #    as those cells would retain their yellow color in grid_with_yellow_connections\n                     #    and thus wouldn't be owner=None here if we were checking that grid.\n                     #    We only care about expanding into originally white cells.\n                     if input_grid[nr, nc] == 0:\n                        existing_owner = owner[nr, nc]\n\n                        if existing_owner is None: # Unreached before this step\n                            if (nr, nc) not in newly_reached_this_step:\n                                # First time reached in this step by any source\n                                newly_reached_this_step[(nr, nc)] = current_owner_coord\n                                # Don't update distance/owner/queue yet, wait until end of step processing\n\n                            elif newly_reached_this_step[(nr, nc)] != current_owner_coord:\n                                # Reached by a *different* source in the *same* step -> CONTESTED\n                                newly_reached_this_step[(nr, nc)] = \"CONTESTED\"\n\n                        # If existing_owner is not None (already reached in a *previous* step),\n                        # or if it was already marked CONTESTED, we do nothing.\n                        # If it was reached *earlier* in *this* step by the *same* owner,\n                        # newly_reached_this_step[(nr, nc)] == current_owner_coord, so we also do nothing extra here.\n\n\n        # End of step processing: Update owner/distance grids and queue based on newly_reached_this_step\n        for (nr, nc), assigned_owner in newly_reached_this_step.items():\n            if assigned_owner != \"CONTESTED\":\n                 # Successfully claimed by one owner in this step\n                 distance[nr, nc] = current_dist + 1\n                 owner[nr, nc] = assigned_owner # Store the tuple coord of the owner source\n                 queue.append(((nr, nc), current_dist + 1)) # Add to queue for next level\n            else:\n                 # Mark as contested permanently in the owner grid\n                 owner[nr, nc] = \"CONTESTED\"\n                 # Do not update distance (remains -1 or its previous value if reached before becoming contested?)\n                 # Let's set distance to indicate it was processed but contested, e.g., -2? Or just rely on owner == \"CONTESTED\".\n                 # Relying on owner is cleaner.\n                 # Crucially, do *not* add contested cells to the queue for further expansion.\n\n\n    # 5. Final Output Construction\n    # Start with the grid after yellow connections\n    final_output_grid = grid_with_yellow_connections # Contains original non-whites and yellow connections\n    # Now fill in the expanded areas based on the BFS results\n    for r in range(rows):\n        for c in range(cols):\n            cell_owner = owner[r, c]\n            # Fill if:\n            # 1. Originally white (otherwise it keeps its original color or yellow connection color)\n            # 2. Owned by a non-contested source (owner is a tuple)\n            if input_grid[r, c] == 0 and isinstance(cell_owner, tuple):\n                sr, sc = cell_owner\n                # Get the original color of the source that owns this cell\n                original_source_color = source_coords_colors[(sr, sc)]\n                # Determine the fill color using the expansion map\n                fill_color = expansion_color_map.get(original_source_color, original_source_color) # Use map, fallback to original\n                final_output_grid[r, c] = fill_color\n            # If originally white and owner is \"CONTESTED\" or None, it remains white (0)\n            # as initialized in grid_with_yellow_connections (if it wasn't yellow-connected).\n\n    return final_output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8159,
    "candidates_token_count": 3017,
    "total_token_count": 11176,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.731225
}