
## train_1

**input:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 6 4 4 4 6 5 2 4 4 4 2 5 4 4 3 4 4 5 4 4 4 4 4 5
5 4 4 4 6 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 4 4 4 4 5
5 4 4 6 4 4 5 4 4 2 4 4 5 3 3 3 3 3 5 4 4 4 4 4 5
5 4 6 4 4 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 4 4 4 4 5
5 6 4 4 4 4 5 2 4 4 4 2 5 4 4 3 4 4 5 4 4 4 4 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


**output:**
```
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
5 6 4 4 4 6 5 2 4 4 4 2 5 4 4 3 4 4 5 2 4 4 4 2 5
5 4 4 4 6 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 2 4 2 4 5
5 4 4 6 4 4 5 4 4 2 4 4 5 3 3 3 3 3 5 4 4 2 3 3 5
5 4 6 4 4 4 5 4 2 4 2 4 5 4 4 3 4 4 5 4 2 3 4 4 5
5 6 4 4 4 4 5 2 4 4 4 2 5 4 4 3 4 4 5 2 4 3 4 4 5
5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
```


## train_2

**input:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 8 8 8 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 8 8 8 8 1
1 4 8 4 8 8 1 8 8 2 8 8 1 3 3 3 3 3 1 8 8 8 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 8 8 8 8 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 8 8 8 8 8 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


**output:**
```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 2 8 3 8 8 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 2 3 8 8 1
1 4 8 4 8 8 1 8 8 2 8 8 1 3 3 3 3 3 1 8 8 2 3 3 1
1 8 8 4 8 8 1 8 2 8 2 8 1 8 8 3 8 8 1 8 2 3 8 8 1
1 8 8 4 8 8 1 2 8 8 8 2 1 8 8 3 8 8 1 2 8 3 8 8 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```


## train_3

**input:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 7 9 9 9 9 6 9 9 9 4 4 6 9 1 9 1 9 6 9 9 9 9 9 6
6 9 7 9 9 9 6 9 9 9 4 4 6 1 9 1 9 1 6 9 9 9 9 9 6
6 9 9 7 9 9 6 9 9 9 9 9 6 9 1 9 1 9 6 9 9 9 9 9 6
6 9 9 9 7 9 6 4 4 9 9 9 6 1 9 1 9 1 6 9 9 9 9 9 6
6 7 9 9 9 7 6 4 4 9 9 9 6 9 1 9 1 9 6 9 9 9 9 9 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


**output:**
```
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
6 7 9 9 9 9 6 9 9 9 4 4 6 9 1 9 1 9 6 9 1 9 1 9 6
6 9 7 9 9 9 6 9 9 9 4 4 6 1 9 1 9 1 6 9 9 1 9 1 6
6 9 9 7 9 9 6 9 9 9 9 9 6 9 1 9 1 9 6 9 9 9 1 9 6
6 9 9 9 7 9 6 4 4 9 9 9 6 1 9 1 9 1 6 4 4 9 9 1 6
6 7 9 9 9 7 6 4 4 9 9 9 6 9 1 9 1 9 6 4 4 9 9 9 6
6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
```


## train_4

**input:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 1 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 0 0 0 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 0 0 0 4
4 1 1 1 1 1 4 0 0 2 0 0 4 3 3 3 3 3 4 0 0 0 0 0 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 0 0 0 4
4 0 0 0 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 0 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```


**output:**
```
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
4 0 0 1 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 2 0 0 0 2 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 2 0 2 0 4
4 1 1 1 1 1 4 0 0 2 0 0 4 3 3 3 3 3 4 3 3 2 3 3 4
4 0 0 0 0 0 4 0 2 0 2 0 4 0 0 3 0 0 4 0 0 3 0 0 4
4 0 0 0 0 0 4 2 0 0 0 2 4 0 0 3 0 0 4 0 0 3 0 0 4
4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
```

Okay, let's break down this task.

**Perception**

1.  **Grid Structure:** The input and output grids are always the same size (7x25 in the examples). They feature a consistent single-color border (color varies between tasks) that remains unchanged.
2.  **Internal Zones:** Inside the border, the grid is divided into four distinct rectangular zones of equal size (5 columns wide), separated by single columns of the border color. Let's label them Zone 1 (cols 1-5), Zone 2 (cols 7-11), Zone 3 (cols 13-17), and Zone 4 (cols 19-23), using 0-based indexing for columns.
3.  **Zone Content:** Each zone typically contains a background color (which might be the same across multiple zones or unique) and a foreground pattern composed of one or more other colors.
4.  **Transformation Focus:** The transformation exclusively affects Zone 4. Zones 1, 2, 3, and the borders remain identical between input and output.
5.  **Core Logic - Copying:** The primary action seems to be copying a pattern from one of the earlier zones (Zone 2 or Zone 3) into Zone 4, overwriting the original content of Zone 4 but preserving Zone 4's original background color.
6.  **Source Selection Logic:** The choice of whether to copy from Zone 2 or Zone 3 depends on the content of Zone 3:
    *   If Zone 3 contains non-background pixels that are *not* green (color 3), then Zone 3 is the source pattern (e.g., `train_3`).
    *   Otherwise (if Zone 3's non-background pixels are *only* green, or if it has no non-background pixels), Zone 2 is the *primary* source pattern (e.g., `train_1`, `train_2`, `train_4`).
7.  **Modification Logic:** In cases where Zone 2 is the primary source, Zone 3 might act as a modifier *if* its non-background content consists solely of green (color 3) pixels forming a single horizontal line spanning the zone's width.
    *   If Zone 3 acts as a modifier, after copying Zone 2's pattern to Zone 4, the green pattern from Zone 3 is overlaid onto Zone 4, replacing any pixels at corresponding locations (e.g., `train_2`, `train_4`).
    *   If Zone 2 is the source but Zone 3 does not meet the criteria to be a modifier (e.g., its green pixels aren't a horizontal line, like in `train_1`), then only Zone 2's pattern is copied, and Zone 3 has no effect on the output.

**Facts**


```yaml
constants:
  zone_width: 5
  zone_separator_width: 1
  num_zones: 4
  zone_columns:
    zone1: [1, 2, 3, 4, 5]
    zone2: [7, 8, 9, 10, 11]
    zone3: [13, 14, 15, 16, 17]
    zone4: [19, 20, 21, 22, 23]
  modifier_color: 3 # green

grid_properties:
  - border_color: The color forming the grid's outer border and separating the zones. It's the most frequent color overall.
  - zones: Four rectangular areas within the border.
  - zone_background_colors: The most frequent color within each zone, excluding the border color.

transformation:
  target_zone: Zone 4
  source_zone_determination:
    - check: Examine non-background, non-border pixels within Zone 3.
    - rule_1: If any such pixel exists and its color is NOT green (3), then Source Zone = Zone 3, Modifier Zone = None.
    - rule_2: If all such pixels (if any) ARE green (3) AND they form a single continuous horizontal line spanning the zone width, then Source Zone = Zone 2, Modifier Zone = Zone 3.
    - rule_3: Otherwise (e.g., only green non-bg pixels but not a horizontal line, or no non-bg pixels), then Source Zone = Zone 2, Modifier Zone = None.
  actions:
    - step_1_copy: Copy the pattern from the Source Zone to the Target Zone (Zone 4).
        - Iterate through each pixel (r, c_src) in the Source Zone.
        - Let `color_src` be the color at (r, c_src).
        - Let `bg_src` be the background color of the Source Zone.
        - If `color_src` is not `bg_src` and not the `border_color`:
            - Calculate the corresponding column `c_tgt` in the Target Zone (c_src + 12 if source=Z2, c_src + 6 if source=Z3).
            - Change the pixel at (r, c_tgt) in the output grid to `color_src`.
    - step_2_modify (only if Modifier Zone = Zone 3): Overlay the pattern from the Modifier Zone (Zone 3) onto the Target Zone (Zone 4).
        - Iterate through each pixel (r, c_mod) in the Modifier Zone (Zone 3).
        - Let `color_mod` be the color at (r, c_mod).
        - Let `bg_mod` be the background color of the Modifier Zone.
        - If `color_mod` is not `bg_mod` and not the `border_color`:
            - Calculate the corresponding column `c_tgt` in the Target Zone (c_mod + 6).
            - Change the pixel at (r, c_tgt) in the output grid to `color_mod`. (This overwrites the result from step_1_copy if applicable).
```


**Natural Language Program**

1.  Initialize the output grid as a copy of the input grid.
2.  Identify the border color (the most frequent color in the grid).
3.  Define the column ranges for Zone 1 ([1-5]), Zone 2 ([7-11]), Zone 3 ([13-17]), and Zone 4 ([19-23]).
4.  Determine the background color for Zone 2 and Zone 3 (the most frequent color within each zone's columns, excluding the border color).
5.  Analyze Zone 3:
    a.  Find all pixels within Zone 3's columns (13-17) whose color is neither the border color nor the Zone 3 background color. Let this set be `Z3_pattern_pixels`.
    b.  Check if any pixel in `Z3_pattern_pixels` has a color other than green (3).
    c.  **If yes (non-green pattern found in Z3):**
        i.  Set Source Zone = Zone 3.
        ii. Set Modifier Zone = None.
    d.  **If no (all pattern pixels in Z3 are green, or Z3 has no pattern pixels):**
        i.  Check if `Z3_pattern_pixels` forms a single continuous horizontal line spanning exactly 5 columns wide (columns 13 through 17) on a single row.
        ii. **If yes (green horizontal line found):**
            1.  Set Source Zone = Zone 2.
            2.  Set Modifier Zone = Zone 3.
        iii. **If no (green pattern isn't a horizontal line, or no pattern):**
            1.  Set Source Zone = Zone 2.
            2.  Set Modifier Zone = None.
6.  Perform the copy operation:
    a.  Iterate through each row `r` from 1 to height-2.
    b.  Iterate through each column `c_src` within the Source Zone's column range.
    c.  Get the color `color_src` at `(r, c_src)`.
    d.  Get the background color `bg_src` of the Source Zone.
    e.  If `color_src` is not `bg_src` and not the border color:
        i.  Calculate the target column `c_tgt`: If Source Zone is Zone 2, `c_tgt = c_src + 12`. If Source Zone is Zone 3, `c_tgt = c_src + 6`.
        ii. Set the pixel color at `(r, c_tgt)` in the output grid to `color_src`.
7.  Perform the modification operation (only if Modifier Zone is Zone 3):
    a.  Iterate through each row `r` from 1 to height-2.
    b.  Iterate through each column `c_mod` in Zone 3's range (13-17).
    c.  Get the color `color_mod` at `(r, c_mod)`.
    d.  Get the background color `bg_mod` of Zone 3.
    e.  If `color_mod` is not `bg_mod` and not the border color (it must be green=3):
        i.  Calculate the target column `c_tgt = c_mod + 6`.
        ii. Set the pixel color at `(r, c_tgt)` in the output grid to `color_mod`.
8.  Return the modified output grid.
