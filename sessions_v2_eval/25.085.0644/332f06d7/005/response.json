{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1. Identify the background color (typically green, 3).\n2. Locate the single, contiguous red object (color 2, 'Agent').\n3. Locate all distinct, contiguous white objects (color 0, 'Targets'). Count the total number of white objects.\n4. Identify all blue pixels (color 1, 'Path').\n5. Perform a Breadth-First Search (BFS) starting from blue pixels adjacent (including diagonally) to the red object. The search moves through adjacent blue pixels.\n6. Identify the 'reachable' white object: This is the first white object encountered during the BFS (i.e., a blue pixel in the path is adjacent to a pixel belonging to a white object). If no white object is reachable, proceed without changing any white objects.\n7. Create the output grid, initially as a copy of the input grid.\n8. Transformation Rules:\n   a. If a white object was reachable via the BFS path:\n      i. Change all pixels of the reachable white object to blue (color 1).\n      ii. If the total number of white objects found in step 3 was exactly one, change all pixels of the original red object to white (color 0).\n      iii. If the total number of white objects found in step 3 was greater than one, leave the original red object unchanged (keep it red, color 2).\n   b. If no white object was reachable via the BFS path, make no changes to the grid (return the copy).\n   c. All other pixels (background, other path pixels, unreachable white objects) remain unchanged from the input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color using 8-way connectivity (including diagonals).\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color (int): The color of the objects to find.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples\n                   representing the coordinates of a distinct object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited pixel of the target color\n            if grid[r, c] == color and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor is same color and unvisited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == color and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                obj_coords.add((nr, nc))\n                # Add the found object's coordinates to the list of objects\n                objects.append(obj_coords)\n    return objects\n\ndef get_neighbors(coord, grid_shape, include_diagonal=True):\n    \"\"\"\n    Gets valid neighbor coordinates for a given coordinate within the grid boundaries.\n\n    Args:\n        coord (tuple): The (row, col) coordinate.\n        grid_shape (tuple): The (rows, cols) shape of the grid.\n        include_diagonal (bool): Whether to include diagonal neighbors.\n\n    Returns:\n        list[tuple]: A list of valid neighbor (row, col) coordinates.\n    \"\"\"\n    r, c = coord\n    rows, cols = grid_shape\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip the center pixel itself\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonal neighbors if not included\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if the neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds a red agent, identifies white targets,\n    determines reachability via a blue path, and modifies the agent and the first\n    reachable target based on the total count of targets.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, ensuring the original input is unchanged\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Define colors used in the transformation logic\n    agent_color = 2             # Red\n    path_color = 1              # Blue\n    target_color = 0            # White\n    result_color_target = 1     # Blue (color to change reachable white object to)\n    result_color_agent_single = 0 # White (color to change red agent to if only 1 white obj)\n    # background_color = 3      # Green (not explicitly needed for modification rule)\n\n    # --- Step 2: Locate the red agent object ---\n    red_objects = find_objects(grid, agent_color)\n    # If no red agent is found, return the original grid unchanged\n    if not red_objects:\n        return input_grid # Return original list[list]\n    # Assumption based on examples: there is only one red object\n    red_object_coords = red_objects[0]\n\n    # --- Step 3: Locate all white target objects and count them ---\n    white_objects = find_objects(grid, target_color)\n    num_white_objects = len(white_objects)\n    # If no white targets are found, return the original grid unchanged\n    if num_white_objects == 0:\n        return input_grid # Return original list[list]\n\n    # Create a lookup map for quick identification of which white object a coordinate belongs to\n    white_coord_to_object_index = {}\n    for idx, obj in enumerate(white_objects):\n        for coord in obj:\n            white_coord_to_object_index[coord] = idx\n\n    # --- Step 4: Identify all blue path pixels ---\n    blue_path_coords = set(zip(*np.where(grid == path_color)))\n\n    # --- Step 5 & 6: Find Reachable White Object via BFS starting from agent's adjacent path ---\n\n    # Initialize BFS structures\n    queue = deque()\n    visited_path = set() # Keep track of visited blue path pixels during BFS\n    start_nodes = set()  # Collect unique blue pixels adjacent to the red object\n\n    # Find blue pixels adjacent (including diagonally) to any part of the red object\n    for r_coord in red_object_coords:\n        for neighbor in get_neighbors(r_coord, grid.shape, include_diagonal=True):\n            # Check if the neighbor is a blue path pixel\n            if neighbor in blue_path_coords:\n                start_nodes.add(neighbor)\n\n    # Add starting blue nodes to the queue and mark as visited\n    for node in start_nodes:\n         if node not in visited_path:\n             queue.append(node)\n             visited_path.add(node)\n\n    reachable_white_object_index = -1 # Index of the first reachable white object found\n    reachable_white_object_coords = None # Coordinates of that object\n\n    # Perform BFS through the blue path\n    while queue:\n        current_coord = queue.popleft() # Get the next blue pixel from the path\n\n        # Check if the current blue pixel is adjacent (including diagonally) to any white pixel\n        found_target = False\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            if neighbor in white_coord_to_object_index:\n                # A connection to a white object is found\n                target_object_index = white_coord_to_object_index[neighbor]\n                # Record the first reachable white object encountered\n                reachable_white_object_index = target_object_index\n                reachable_white_object_coords = white_objects[target_object_index]\n                found_target = True\n                break # Stop checking neighbors for this blue pixel\n\n        if found_target:\n            break # Exit BFS entirely, as we only care about the first reachable object\n\n        # If no target found yet, expand the BFS to adjacent unvisited blue path pixels\n        for neighbor in get_neighbors(current_coord, grid.shape, include_diagonal=True):\n            # Check if the neighbor is part of the blue path and hasn't been visited in this BFS\n            if neighbor in blue_path_coords and neighbor not in visited_path:\n                visited_path.add(neighbor)\n                queue.append(neighbor)\n\n    # --- Step 8: Modify the Output Grid based on BFS findings ---\n\n    # Check if the BFS successfully found a reachable white object\n    if reachable_white_object_coords is not None:\n        # Rule 8.a.i: Change all pixels of the reachable white object to blue\n        for r, c in reachable_white_object_coords:\n            output_grid[r, c] = result_color_target\n\n        # Rules 8.a.ii & 8.a.iii: Determine the transformation of the red object based on the *total* count of white objects\n        if num_white_objects == 1:\n            # If exactly one white object existed in the input grid, change the red object to white\n            for r, c in red_object_coords:\n                output_grid[r, c] = result_color_agent_single\n        elif num_white_objects > 1:\n            # If more than one white object existed, the red object remains unchanged (red)\n            # No action needed as output_grid started as a copy with the red object intact\n            pass\n        # Note: The case num_white_objects == 0 was handled earlier by returning the input grid\n\n    # Rule 8.b: If no white object was reachable (reachable_white_object_coords is None),\n    # no changes are made beyond the initial copy, so the grid remains as is.\n\n    # Rule 8.c: All other pixels remain unchanged implicitly because we started with a copy.\n\n    # Convert the final NumPy array back to a standard list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7727,
    "candidates_token_count": 2513,
    "total_token_count": 10240,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 62.816216
}