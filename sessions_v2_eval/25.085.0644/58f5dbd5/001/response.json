{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the background color (assumed to be the color of the corners).\nFinds all rectangular blocks composed of a single, non-background color (solid blocks).\nSelects only those solid blocks that are completely enclosed by a one-pixel thick border of the background color.\nConstructs an output grid containing only these selected blocks and their background borders, preserving their relative positions.\nThe output grid dimensions are adjusted to tightly fit the selected content.\n\"\"\"\n\ndef get_background_color(grid):\n    \"\"\"\n    Determines the background color, assuming it's the color of the top-left corner.\n    \"\"\"\n    return grid[0][0]\n\ndef find_solid_blocks(grid_np, bg_color):\n    \"\"\"\n    Finds all contiguous blocks of a single non-background color.\n\n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n        bg_color (int): The background color.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a solid block:\n              (color, min_row, max_row, min_col, max_col)\n    \"\"\"\n    height, width = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    blocks = []\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c] and grid_np[r, c] != bg_color:\n                color = grid_np[r, c]\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                q = deque([(r, c)])\n                visited[r, c] = True\n                is_solid = True\n                block_pixels = set([(r,c)])\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < height and 0 <= nc < width:\n                            if not visited[nr, nc]:\n                                if grid_np[nr, nc] == color:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                                    block_pixels.add((nr, nc))\n                                elif grid_np[nr, nc] != bg_color:\n                                    # Found a different non-background color adjacent, not solid?\n                                    # Revisit: This BFS finds contiguous areas, need to check rectangular shape later.\n                                    pass\n                        \n                # Check if the found contiguous area forms a solid rectangle\n                is_rectangle = True\n                if (max_r - min_r + 1) * (max_c - min_c + 1) != len(block_pixels):\n                    is_rectangle = False\n                else:\n                    for br in range(min_r, max_r + 1):\n                        for bc in range(min_c, max_c + 1):\n                            if grid_np[br, bc] != color:\n                                is_rectangle = False\n                                break\n                        if not is_rectangle:\n                            break\n\n                if is_rectangle:\n                    blocks.append((color, min_r, max_r, min_c, max_c))\n                    # Mark the whole rectangle as visited to avoid redundant checks\n                    visited[min_r:max_r+1, min_c:max_c+1] = True\n\n\n    return blocks\n\n\ndef is_background_bordered(grid_np, bg_color, min_r, max_r, min_c, max_c):\n    \"\"\"\n    Checks if a block is surrounded by a 1-pixel border of the background color.\n\n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n        bg_color (int): The background color.\n        min_r, max_r, min_c, max_c (int): Bounding box of the solid block.\n\n    Returns:\n        bool: True if the block is properly bordered, False otherwise.\n    \"\"\"\n    height, width = grid_np.shape\n    \n    # Define the border coordinates\n    border_min_r = max(0, min_r - 1)\n    border_max_r = min(height - 1, max_r + 1)\n    border_min_c = max(0, min_c - 1)\n    border_max_c = min(width - 1, max_c + 1)\n\n    for r in range(border_min_r, border_max_r + 1):\n        for c in range(border_min_c, border_max_c + 1):\n            # Skip pixels inside the block itself\n            if min_r <= r <= max_r and min_c <= c <= max_c:\n                continue\n            \n            # Check if the border pixel is the background color\n            if grid_np[r, c] != bg_color:\n                return False\n                \n    # Ensure the block is not touching the actual grid edge if border check passed\n    # This means the border derived above must actually *be* a border\n    if min_r == 0 or max_r == height - 1 or min_c == 0 or max_c == width - 1:\n         # Check if the border check passed *because* it was at the edge\n         # If min_r is 0, border_min_r is 0. We need to ensure the check didn't falsely pass.\n         # Re-think: The loop condition correctly handles edges. If a border pixel is checked\n         # and it's on the grid boundary, it still must be bg_color. The logic seems correct.\n         pass\n\n\n    return True\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters the input grid to keep only solid blocks surrounded by a background border.\n    \n    1. Identify the background color.\n    2. Find all solid rectangular blocks of non-background colors.\n    3. Check each block for a complete 1-pixel background border.\n    4. Determine the bounding box of the selected blocks including their borders.\n    5. Construct the output grid containing only these bordered blocks.\n    \"\"\"\n    \n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # 1. Identify background color\n    bg_color = get_background_color(input_grid_np)\n    \n    # 2. Find solid blocks\n    solid_blocks = find_solid_blocks(input_grid_np, bg_color)\n\n    # 3. Filter blocks that are background-bordered\n    selected_regions = [] # Stores (border_min_r, border_max_r, border_min_c, border_max_c)\n    for color, min_r, max_r, min_c, max_c in solid_blocks:\n        if is_background_bordered(input_grid_np, bg_color, min_r, max_r, min_c, max_c):\n            # Calculate border coordinates, ensuring they stay within grid bounds\n            b_min_r = max(0, min_r - 1)\n            b_max_r = min(height - 1, max_r + 1)\n            b_min_c = max(0, min_c - 1)\n            b_max_c = min(width - 1, max_c + 1)\n            selected_regions.append((b_min_r, b_max_r, b_min_c, b_max_c))\n\n    # Handle case where no blocks are selected\n    if not selected_regions:\n        # Returning a 1x1 background pixel grid as a default\n        # Adjust if requirements differ (e.g., empty grid, error)\n        return [[bg_color]]\n\n    # 4. Determine overall bounding box for the output\n    min_overall_r = min(r[0] for r in selected_regions)\n    max_overall_r = max(r[1] for r in selected_regions)\n    min_overall_c = min(r[2] for r in selected_regions)\n    max_overall_c = max(r[3] for r in selected_regions)\n\n    # 5. Construct the output grid\n    output_height = max_overall_r - min_overall_r + 1\n    output_width = max_overall_c - min_overall_c + 1\n    \n    # Initialize output grid with background color\n    output_grid_np = np.full((output_height, output_width), bg_color, dtype=int)\n\n    # Copy selected regions (including borders) from input to output\n    for r1, r2, c1, c2 in selected_regions:\n        # Calculate target coordinates in the output grid\n        target_r1 = r1 - min_overall_r\n        target_r2 = r2 - min_overall_r\n        target_c1 = c1 - min_overall_c\n        target_c2 = c2 - min_overall_c\n        \n        # Extract the region from the input grid\n        region_to_copy = input_grid_np[r1 : r2 + 1, c1 : c2 + 1]\n        \n        # Place it into the output grid\n        output_grid_np[target_r1 : target_r2 + 1, target_c1 : target_c2 + 1] = region_to_copy\n\n    # Convert numpy array back to list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5239,
    "candidates_token_count": 2334,
    "total_token_count": 7573,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.901627
}