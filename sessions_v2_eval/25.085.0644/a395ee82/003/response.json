{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify Background: Determine the background color by finding the most frequent color in the input grid.\n2. Find Objects: Identify all distinct connected objects (contiguous pixels of the same color) that are *not* the background color. Record their color, size (pixel count), pixel coordinates, and bounding boxes.\n3. Identify Pattern Object: Find the object with the largest size. This is the 'pattern object'. Store its color and its shape (the coordinates of its pixels relative to its bounding box's top-left corner). Calculate the relative center of the pattern object's *bounding box* (`center_row = bbox_height // 2`, `center_col = bbox_width // 2`).\n4. Identify Marker Colors: Find the minimum size among all non-background objects. Identify all distinct colors associated with objects of this minimum size. These are the 'marker colors'.\n5. Find Marker Locations: Locate all pixels in the *original input grid* that have any of the identified 'marker colors'. These are the 'marker locations'.\n6. Initialize Output: Create the output grid by making an exact copy of the input grid.\n7. Stamp Pattern Copies: For each 'marker location' `(marker_row, marker_col)` found in step 5:\n    a. Calculate the target top-left coordinate `(target_top_left_row, target_top_left_col)` on the output grid where the pattern copy should start. This is determined by aligning the pattern's relative bounding box center (calculated in step 3) with the marker location: `target_top_left_row = marker_row - center_row`, `target_top_left_col = marker_col - center_col`.\n    b. Iterate through each relative pixel coordinate `(rel_row, rel_col)` defining the pattern's shape (from step 3).\n    c. Calculate the destination coordinate `(dest_row, dest_col)` on the output grid: `dest_row = target_top_left_row + rel_row`, `dest_col = target_top_left_col + rel_col`.\n    d. Check if the destination coordinate `(dest_row, dest_col)` is within the bounds of the output grid.\n    e. If it is within bounds, set the color of the pixel at `(dest_row, dest_col)` in the output grid to the pattern object's color. This overwrites any existing color at that location.\n8. Final Output: The modified grid after stamping all pattern copies is the final output.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\ndef find_connected_objects(grid, background_color):\n    \"\"\"\n    Finds all connected objects in the grid, excluding the background color.\n    Returns a dictionary where keys are object IDs (1-based) and\n    values are dictionaries containing 'color', 'coords', 'size', 'bbox'.\n    'coords' are absolute coordinates in the grid.\n    'bbox' is a tuple of slice objects representing the bounding box.\n    \"\"\"\n    objects = {}\n    current_label = 0\n    unique_colors = np.unique(grid)\n\n    for color in unique_colors:\n        if color == background_color:\n            continue\n\n        # Create a binary mask for the current color\n        mask = (grid == color)\n        # Label connected components for this color\n        # Use 8-connectivity (diagonal connections allowed) which is standard for ARC\n        structure = np.array([[1,1,1],[1,1,1],[1,1,1]])\n        labeled_array, num_features = label(mask, structure=structure)\n\n        if num_features > 0:\n            # Find the locations (slices) of each labeled object\n            locations = find_objects(labeled_array)\n            for i in range(num_features):\n                obj_label = i + 1\n                obj_slice = locations[i]\n                # Extract coordinates within the bounding box slice\n                coords_in_slice = np.argwhere(labeled_array[obj_slice] == obj_label)\n                # Convert to absolute grid coordinates\n                abs_coords = coords_in_slice + np.array([obj_slice[0].start, obj_slice[1].start])\n\n                current_label += 1\n                objects[current_label] = {\n                    'color': color,\n                    'coords': abs_coords,\n                    'size': len(abs_coords),\n                    'bbox': obj_slice\n                }\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # 1. Identify Background Color\n    color_counts = Counter(input_grid_np.flatten())\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Find Non-Background Objects\n    all_objects = find_connected_objects(input_grid_np, background_color)\n\n    # Edge Case: No non-background objects\n    if not all_objects:\n        return input_grid # Return original grid as list of lists\n\n    # 3. Identify Pattern Object (Largest)\n    pattern_obj_id = max(all_objects, key=lambda k: all_objects[k]['size'])\n    pattern_obj = all_objects[pattern_obj_id]\n    pattern_color = pattern_obj['color']\n    pattern_bbox = pattern_obj['bbox']\n    pattern_coords_absolute = pattern_obj['coords']\n\n    # Calculate pattern shape relative to its bounding box top-left\n    pattern_bbox_top_left = np.array([pattern_bbox[0].start, pattern_bbox[1].start])\n    pattern_coords_relative = pattern_coords_absolute - pattern_bbox_top_left\n\n    # Calculate relative center of the pattern's bounding box\n    bbox_height = pattern_bbox[0].stop - pattern_bbox[0].start\n    bbox_width = pattern_bbox[1].stop - pattern_bbox[1].start\n    center_dr = bbox_height // 2\n    center_dc = bbox_width // 2\n\n    # 4. Identify Marker Color(s) (Color(s) of Smallest Object(s))\n    min_size = min(obj['size'] for obj in all_objects.values())\n    marker_colors = set(obj['color'] for obj in all_objects.values() if obj['size'] == min_size)\n\n    # 5. Find Marker Locations\n    marker_locations = []\n    for r in range(height):\n        for c in range(width):\n            if input_grid_np[r, c] in marker_colors:\n                marker_locations.append((r, c))\n    # Convert to numpy array for easier coordinate math if needed, though list iteration works fine\n    # marker_locations = np.argwhere(np.isin(input_grid_np, list(marker_colors)))\n\n    # 6. Initialize Output Grid (as a copy of the input)\n    output_grid = np.copy(input_grid_np)\n\n    # 7. Stamp Pattern Copies onto the Output Grid\n    for marker_r, marker_c in marker_locations:\n        # a. Calculate target top-left for placing the pattern copy\n        target_top_left_r = marker_r - center_dr\n        target_top_left_c = marker_c - center_dc\n\n        # b. Iterate through pattern's relative coordinates\n        for rel_r, rel_c in pattern_coords_relative:\n            # c. Calculate destination coordinate\n            dest_r = target_top_left_r + rel_r\n            dest_c = target_top_left_c + rel_c\n\n            # d. Check bounds\n            if 0 <= dest_r < height and 0 <= dest_c < width:\n                # e. Set pixel color (overwrite)\n                output_grid[dest_r, dest_c] = pattern_color\n\n    # 8. Final Output (convert back to list of lists)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5170,
    "candidates_token_count": 1877,
    "total_token_count": 7047,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.210099
}