{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms an input grid by filling columns based on marker locations and blue boundaries.\n\n1.  **Initialize:** Create the output grid as a copy of the input grid.\n2.  **Identify Markers:**\n    a.  Locate the single, unique Yellow (4) pixel at `(Ry, Cy)`.\n    b.  Locate all Red (2) pixels.\n    c.  Find the Red pixel `(Rr, Cr)` closest to the Yellow pixel using L1 distance. Tie-breaking: minimum row index, then minimum column index.\n3.  **Determine Boundaries and Fill Columns:**\n    a.  Define a boundary function: For a given column, find the minimum row index of any Blue (1) pixel. If no Blue pixel exists, the boundary is the grid height.\n    b.  **If `Cr == Cy` (Same Column):**\n        i.  The target column `C` is `Cr`.\n        ii. Calculate the boundary row `B` for column `C`.\n        iii. Fill `output_grid` column `C` from row 0 up to `B-1` with alternating Red (2, even rows) and Yellow (4, odd rows).\n        iv. Override: For rows `r` from 0 to `B-1`, if `input_grid[r, C]` was Green (3), set `output_grid[r, C]` to Yellow (4).\n    c.  **If `Cr != Cy` (Different Columns):**\n        i.  Calculate Red boundary `Br` for column `Cr`. Fill `output_grid` column `Cr` from row 0 to `Br-1` with Red (2).\n        ii. Calculate Yellow boundary `By` for column `Cy`. Fill `output_grid` column `Cy` from row 0 to `By-1` with Yellow (4).\n4.  **Finalize:** Return the modified `output_grid`. Pixels not explicitly modified retain their original input values.\n\"\"\"\n\ndef find_color_coords(grid, color):\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    # np.argwhere returns [row, col] pairs, scan order is row-major\n    coords = np.argwhere(grid == color)\n    return [tuple(coord) for coord in coords]\n\ndef find_upper_blue_boundary(grid, target_col):\n    \"\"\"\n    Finds the minimum row index of a Blue (1) pixel in the target column.\n    This row acts as the exclusive upper bound for modifications (fill up to boundary - 1).\n    Returns grid height if no Blue pixel is found in the column.\n    \"\"\"\n    height, width = grid.shape\n    blue_rows_in_col = [r for r, c in find_color_coords(grid, 1) if c == target_col]\n\n    if not blue_rows_in_col:\n        # If no blue pixel, the modification applies to the whole column [0, height-1].\n        # The boundary is effectively the bottom, so return height.\n        return height\n    else:\n        # Return the row index of the highest (minimum row index) blue pixel.\n        return min(blue_rows_in_col)\n\ndef find_closest_red(red_coords, yellow_coord):\n    \"\"\"\n    Finds the red coordinate closest to the yellow coordinate using L1 distance.\n    Tie-breaking: minimum row index, then minimum column index.\n    Returns the closest (r, c) tuple or None if no red_coords provided.\n    \"\"\"\n    if not red_coords:\n        return None\n\n    r_y, c_y = yellow_coord\n    min_dist = float('inf')\n    closest_r_coord = None\n\n    for r_coord_cand in red_coords:\n        r_r_cand, c_r_cand = r_coord_cand\n        dist = abs(r_r_cand - r_y) + abs(c_r_cand - c_y)\n\n        if dist < min_dist:\n            min_dist = dist\n            closest_r_coord = r_coord_cand\n        elif dist == min_dist:\n            # Tie-breaking\n            # Check if candidate row is smaller\n            if r_r_cand < closest_r_coord[0]:\n                 closest_r_coord = r_coord_cand\n            # If rows are equal, check if candidate column is smaller\n            elif r_r_cand == closest_r_coord[0] and c_r_cand < closest_r_coord[1]:\n                 closest_r_coord = r_coord_cand\n\n    return closest_r_coord\n\n\ndef transform(input_grid):\n    # 1. Initialize output_grid\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 2. Identify Markers\n    yellow_coords = find_color_coords(input_grid, 4)\n    red_coords = find_color_coords(input_grid, 2)\n\n    # Ensure exactly one yellow marker exists\n    if len(yellow_coords) != 1:\n        # If assumption is violated, return original grid\n        # (or raise an error depending on desired behavior)\n        return output_grid\n    \n    unique_yellow_coord = yellow_coords[0]\n    r_y, c_y = unique_yellow_coord\n\n    # Find the closest red marker\n    selected_red_coord = find_closest_red(red_coords, unique_yellow_coord)\n\n    # Ensure a red marker was found (red_coords might be empty)\n    if selected_red_coord is None:\n         # No red marker found, return original grid\n        return output_grid\n\n    r_r, c_r = selected_red_coord\n\n    # 3. Determine Boundaries and Fill Columns\n    if c_r == c_y:\n        # Case: Same Column\n        target_col = c_r\n        # Find boundary row (exclusive upper limit)\n        boundary_row = find_upper_blue_boundary(input_grid, target_col)\n\n        # Fill with alternating pattern up to the boundary\n        for r in range(boundary_row):\n            color = 2 if r % 2 == 0 else 4 # Red for even rows, Yellow for odd\n            output_grid[r, target_col] = color\n\n        # Apply Green override\n        for r in range(boundary_row):\n            if input_grid[r, target_col] == 3: # Check original input grid\n                output_grid[r, target_col] = 4 # Override with Yellow\n\n    else:\n        # Case: Different Columns\n        # Process Red column\n        boundary_row_r = find_upper_blue_boundary(input_grid, c_r)\n        for r in range(boundary_row_r):\n            output_grid[r, c_r] = 2 # Fill with Red\n\n        # Process Yellow column\n        boundary_row_y = find_upper_blue_boundary(input_grid, c_y)\n        for r in range(boundary_row_y):\n            output_grid[r, c_y] = 4 # Fill with Yellow\n\n    # 4. Finalize\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12165,
    "candidates_token_count": 1669,
    "total_token_count": 13834,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.312218
}