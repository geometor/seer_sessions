
## train_1

**input:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


## train_2

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 0 0 0 8 0 0
0 0 9 0 0 2 7 0 2 8 0 0
0 6 5 5 0 1 7 0 2 3 3 0
0 6 0 5 0 1 7 0 2 0 3 0
0 6 0 5 0 1 7 7 7 7 3 0
```


## train_3

**input:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 9 4 4 4 7 0 2 3 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 0 9 0 0 0 7 0 2 0 3 0
0 6 5 5 0 1 7 7 7 7 4 0
0 6 0 5 0 1 0 0 0 0 4 0
0 6 0 5 0 1 0 0 0 0 4 0
```


**output:**
```
6 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 0 0 0 0 8 0 0
0 0 0 0 0 2 5 5 5 8 0 0
0 0 0 0 0 2 0 0 0 8 0 0
0 0 0 0 0 2 7 0 2 3 3 0
0 0 0 0 0 2 7 0 2 0 3 0
0 0 9 4 4 4 7 0 2 0 3 0
0 0 9 5 0 1 7 7 7 7 4 0
0 0 9 5 0 1 0 0 0 0 4 0
0 0 5 5 0 1 0 0 0 0 4 0
```


## train_4

**input:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 6 0 0 3 0 5 0 7 7 0
0 0 2 2 2 2 2 2 2 2 7 0
```


## train_5

**input:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 0 0 5 0 0 0 1 0 0 0
0 0 6 3 3 3 0 5 5 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 0 6 0 0 3 0 5 0 7 0 0
0 4 2 2 2 2 2 2 2 2 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
0 4 0 0 0 0 0 0 0 0 7 0
```


**output:**
```
7 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 0 0 0 0 0 0 0
0 0 0 0 5 1 1 1 1 0 0 0
0 4 6 3 3 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 1 0 0 0
0 4 6 0 0 3 0 5 5 0 0 0
0 4 2 2 2 2 2 2 2 2 0 0
```

Okay, let's break down this task.

**Perception of Task Elements**

1.  **Indicator Pixel:** The pixel at coordinates (0, 0) in the input grid seems to act as a control or indicator. Its color determines the subsequent transformation.
2.  **Objects:** The rest of the input grid contains multiple distinct objects, typically appearing as hollow shapes ('L' shapes, 'U' shapes) composed of one or two colors. These objects are separated by white (0) pixels.
3.  **Transformation:** The transformation involves two main actions based on the indicator color:
    *   **Object Removal:** One or more objects are completely removed (replaced by white) from the grid. The object(s) removed appear to be those containing the same color as the indicator pixel.
    *   **Object Shifting:** The remaining objects (those *not* containing the indicator color) are shifted vertically downwards by a specific amount.
4.  **Shift Amount:** The number of rows the remaining objects are shifted downwards appears to depend solely on the color of the indicator pixel at (0, 0).
    *   Maroon (9) at (0, 0): No shift (0 rows).
    *   Magenta (6) at (0, 0): Shift down by 2 rows.
    *   Any other color observed (Yellow (4), Orange (7)) at (0, 0): Shift down by 3 rows.
5.  **Special Case (Maroon):** If the indicator pixel is Maroon (9), no changes occur; the output is identical to the input.

**YAML Fact Document**


```yaml
task_description: |
  Transform the input grid based on the color of the pixel at (0,0).
  This color determines which object(s) to remove and how many rows to shift the remaining objects downwards.

definitions:
  - &indicator_pixel
    name: indicator_pixel
    location: (0, 0)
    property: color (C)
  - &objects
    name: objects
    description: Contiguous blocks of non-white pixels in the grid, excluding the indicator_pixel.
    properties:
      - colors: The set of colors present within the object.
      - pixels: The list of coordinates belonging to the object.

rules:
  - name: Determine Shift Amount (S)
    based_on: *indicator_pixel
    logic: |
      If C is Maroon (9), then S = 0.
      If C is Magenta (6), then S = 2.
      Otherwise (e.g., Yellow (4), Orange (7)), S = 3.

  - name: Identify Objects for Removal
    based_on: [*indicator_pixel, *objects]
    logic: |
      An object is marked for removal if its 'colors' property contains the color C of the indicator_pixel.

  - name: Identify Objects for Shifting
    based_on: [*indicator_pixel, *objects]
    logic: |
      An object is marked for shifting if its 'colors' property does NOT contain the color C of the indicator_pixel.

transformation:
  - name: Apply Transformation
    condition: S > 0
    steps:
      - Create a new empty grid (filled with white (0)) of the same dimensions as the input.
      - Copy the indicator_pixel from the input to the new grid at (0,0).
      - For each object marked for shifting:
        - For each pixel (r, c) with color 'col' in the object:
          - Calculate the new row: r_new = r + S.
          - If r_new is within the grid height:
            - Set the pixel (r_new, c) in the new grid to 'col'.
      - The new grid is the output.
  - name: Apply Transformation (No Change)
    condition: S == 0
    steps:
      - The output grid is identical to the input grid.

```


**Natural Language Program**

1.  Examine the color `C` of the pixel at the top-left corner (row 0, column 0) of the input grid.
2.  Determine the downward shift amount `S` based on color `C`: if `C` is 9 (Maroon), `S` is 0; if `C` is 6 (Magenta), `S` is 2; otherwise, `S` is 3.
3.  If `S` is 0, the output grid is identical to the input grid. Stop.
4.  If `S` is greater than 0, perform the following:
    a.  Create a new output grid of the same size as the input, initially filled with white (0).
    b.  Copy the pixel `C` from the input's (0, 0) position to the output's (0, 0) position.
    c.  Identify all distinct connected objects composed of non-white pixels in the input grid (ignoring the pixel at (0,0)).
    d.  For each identified object:
        i.  Check if any pixel within the object has the color `C`.
        ii. If the object does *not* contain any pixel with color `C`, then for every pixel `(r, c)` belonging to this object with color `col`:
            - Calculate the new row `r_new = r + S`.
            - If `r_new` is less than the grid height, set the pixel at `(r_new, c)` in the output grid to `col`.
    e.  The resulting output grid is the final result.
