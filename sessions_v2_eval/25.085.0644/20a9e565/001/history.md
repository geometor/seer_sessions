
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 4 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 2 0 0 0 4 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 0 2 2 2 0 4 4 4 4 0 1 1 1 1 1 0 5 5 0 0 0 0 0 0 0 0 0
0 1 0 0 2 0 0 0 4 0 0 0 0 1 0 0 0 0 0 5 0 0 0 0 5 0 0 0 0 0
0 1 1 0 2 2 2 0 4 4 4 4 0 1 1 1 1 1 0 0 0 0 0 5 5 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
2 2 2 2 2 2
2 0 0 0 0 0
2 2 2 2 2 2
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 4 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 9 0 0 9 8 0 9 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 9 9 0 9 9 0 9 9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 0 9 4 0 9 4 0 9 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 0 4 4 0 4 4 0 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 8 4 0 8 4 0 8 4 0 8 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 0 8 8 0 8 8 0 8 8 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 9 0 8 9 0 8 9 0 8 9 0 8 9 0 8 9 0 0 0 0 0 0 0 0 0 0 0
0 9 9 0 9 9 0 9 9 0 9 9 0 9 9 0 9 9 0 5 5 0 0 0 0 0 0 0 0
0 0 9 0 8 9 0 8 9 0 8 9 0 8 9 0 8 9 0 5 0 0 0 0 0 0 0 0 0
0 0 0 0 8 8 0 8 8 0 8 8 0 8 8 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 8 0 0 8 4 0 8 4 0 8 4 0 8 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 0 4 4 0 4 4 0 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 4 0 9 4 0 9 4 0 9 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 9 9 0 9 9 0 9 9 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 9 0 0 9 8 0 9 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 0 8 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 0 4 8 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
9 9
8 9
8 8
8 4
4 4
9 4
9 9
9 8
8 8
4 8
4 4
4 9
9 9
0 9
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 7 7 7 0 2 2 2 0 3 3 3 0 7 7 7 0 2 2 2 0 0 0 0 0 5 5 0 0 0
0 7 0 7 0 2 0 2 0 3 0 3 0 7 0 7 0 2 0 2 0 0 0 0 0 5 0 0 0 0
0 7 7 7 0 2 2 2 0 3 3 3 0 7 7 7 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 7 0 7 0 2 0 2 0 3 0 3 0 7 0 7 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 7 7 7 0 2 2 2 0 3 3 3 0 7 7 7 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 3 0 3 0 7 0 7 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 0 3 3 3 0 7 7 7 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 0 3 0 7 0 7 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 3 0 7 7 7 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 7 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 7 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
7 0 7
7 7 7
```

-   `train_1`: Blue (1) has 21 pixels, Red (2) has 9 pixels, Yellow (4) has 12 pixels, Gray (5) has 6 pixels. Red is selected. It has the *fewest* pixels among the non-gray colors.
-   `train_3`: Red (2) has 51 pixels, Green (3) has 23 pixels, Gray (5) has 6 pixels, Orange (7) has 41 pixels. Orange is selected. It does *not* have the fewest pixels (Green does). Red has the most.

**Revisiting `train_2`:**
-   The output looks like a 14x2 grid.
-   Let's look at the input grid around the area where the gray shapes are. No, the gray shapes seem distant.
-   Let's find the bounding box of all non-white pixels.
    -   `train_1`: Rows 22-29, Cols 1-28.
    -   `train_2`: Rows 3-28, Cols 4-27.
    -   `train_3`: Rows 1-18, Cols 1-28.
-   Maybe the task involves finding a specific shape?
    -   `train_1`: The output `222222 / 200000 / 222222` is related to the input red 'C' shape `200 / 222 / 200`? The output seems like two 'C' shapes where the middle column is filled instead of empty, placed side by side. No, wait, the input red shapes are `2 / 222` and `2 / 222` stacked. The basic shape is `X / XXX`. If X=2, this is `2 / 222`. The output `222222 / 200000 / 222222` is 3x6. It seems like the basic `2 / 222` shape is somehow transformed and repeated. The output has 13 red pixels. The input had 9 red pixels. Where do the extra pixels come from? Maybe it's about the *pattern* of shapes.
    -   `train_3`: The output is `707 / 777 / 707 / ...` repeated. The input orange shapes are `777 / 707 / 777 / 707 / 777`. The basic shape is the 'C' `777 / 707 / 777`. The output is exactly this shape repeated vertically. Orange (7) was selected. Why?
    -   `train_2`: The output is 14x2. The input has many shapes. Let's look at columns 19 & 20 (where the gray shapes are concentrated). Those columns are all white (0). What about columns 4 and 5? `(11, 4)=8, (12, 4)=8, (13,4)=8, (14,4)=9`. `(11, 5)=0, (12,5)=8, (13,5)=9, (14,5)=9`. What about columns 13 and 14? `(5,13)=8, (6,13)=8, (7,13)=9, (8,13)=9, (9,13)=9, (10,13)=4, (11,13)=8, (12,13)=8, (13,13)=8, (14,13)=9, (15,13)=8, (16,13)=8, (17,13)=8, (18,13)=4, (19,13)=9, (20,13)=9, (21,13)=9, (22,13)=8`. `(3,14)=4, (4,14)=4, (5,14)=0, (6,14)=8, (7,14)=8, (8,14)=9, (9,14)=4, (10,14)=4, (11,14)=4, (12,14)=8, (13,14)=9, (14,14)=9, (15,14)=9, (16,14)=8, (17,14)=4, (18,14)=4, (19,14)=4, (20,14)=9, (21,14)=8, (22,14)=0`. This doesn't directly match the output.

**Let's reconsider the selection criteria:**
-   `train_1`: Selected Red (2). Count=9.
-   `train_3`: Selected Orange (7). Count=41.
-   Could it be related to the *shape* itself? In `train_1` and `train_3`, the selected shapes are variations of 'C' or filled 'C'.
    -   `train_1`: Blue shapes are mostly lines or L-shapes. Yellow shapes form a 4x4 block with corners removed. Red shapes form `2 / 222`.
    -   `train_3`: Orange, Red, Green shapes are all 'C' shapes `X77 / X0X / X77`.
-   Maybe it selects the color that forms the most "complete" or canonical version of a shape pattern present?
-   In `train_3`, Orange forms `777/707/777`, Red forms `222/202/222`, Green forms `333/303/333`. All seem equally "complete" as 'C' shapes. Why Orange? Orange count=41, Red=51, Green=23. No clear rule based on count.
-   What if the gray shape indicates the *target* shape?
    -   `train_1`: Gray `55 / 50` (or `55 / 5` depending on interpretation). Target shape is `2 / 222`. Output `222222 / 200000 / 222222`. The output shape has height 3. The gray shape has height 2.
    -   `train_3`: Gray `05 / 55`. Target shape is `777 / 707 / 777`. Output is repetitions of this shape. Output height 17. Input shape height 3. Gray shape height 2.
-   This link seems weak.

**Let's rethink `train_1` output:**
-   Input red shapes: Two `2 / 222` stacked vertically.
-   Output: `222222 / 200000 / 222222` (3x6).
-   Could the output be related to the *bounding box* of the selected color shapes?
    -   `train_1`: Red shapes bounding box is rows 24-28, cols 4-6. Size 5x3. Output is 3x6.
    -   `train_3`: Orange shapes bounding box is rows 1-11, cols 1-15. Size 11x15 (approx). Output is 17x3.
-   No obvious relationship between bounding box and output size.

**Hypothesis: Find the target shape indicated by the gray object.**
1.  Identify the gray object(s). Determine the "shape" they represent.
2.  Find all occurrences of this shape (or similar shapes) in other colors in the input grid.
3.  Select one of these colored shapes based on some criteria (e.g., frequency, count, position).
4.  Construct the output based on the selected shape.

Let's re-examine the gray shapes and the corresponding outputs:
-   `train_1`: Gray `55 / 50` or `55 / 5`. Output is `222222 / 200000 / 222222`. Color is Red(2).
-   `train_2`: Gray `55/50` and `05/55`. Output is 14x2 multicolumn. Colors are 9, 8, 4.
-   `train_3`: Gray `05 / 55`. Output is `707 / 777 / 707 / ...`. Color is Orange(7).

Maybe the gray shape doesn't represent the *exact* shape, but a *property* or *pattern* to look for?
-   Gray `55 / 50` (3 pixels). Let's call this L-shape.
-   Gray `05 / 55` (3 pixels). Let's call this Z-shape (or S-shape).

-   `train_1`: Has L-shape gray. Output uses Red. Input Red shapes are `2 / 222`.
-   `train_3`: Has Z-shape gray. Output uses Orange. Input Orange shapes are `777 / 707 / 777`.
-   `train_2`: Has both L-shape and Z-shape gray. Output uses multiple colors (9, 8, 4) in a 14x2 grid.

This suggests:
1.  Find the gray shape(s).
2.  This shape tells you *what pattern* defines the output color(s).
    -   If gray is L-shape (`55/50`), find the color C whose objects are formed by stacking `C / CCC` pattern? (train_1) -> Select Red.
    -   If gray is Z-shape (`05/55`), find the color C whose objects are formed by the `CCC / C0C / CCC` pattern? (train_3) -> Select Orange.
    -   If both gray shapes are present (`train_2`), do something else? The output is 14x2. Let's check the input grid columns 13 & 14 again, from row 7 to 20.
        
```
        Input[7:21, 13:15]
        9 9
        9 9
        9 4
        4 4
        8 8
        8 8
        9 9
        8 9
        8 8
        8 4
        4 4
        9 4
        9 9
        9 8
        ```

        This matches the output exactly!

**Revised Hypothesis:**
1.  Locate the gray pixel(s).
2.  Determine the unique shape(s) formed by contiguous gray pixels (including diagonals).
3.  Define the "L-shape" (`55/50` or rotations/reflections) and "Z-shape" (`05/55` or rotations/reflections).
4.  **Case 1: Only L-shape gray exists (`train_1`)**
    a. Find the color C (non-gray) such that its constituent objects primarily match the pattern `C / CCC` (potentially stacked or arranged). In `train_1`, this is Red (2).
    b. The output is constructed from this basic `C / CCC` shape. How exactly? In `train_1`, the output is `222222 / 200000 / 222222`. This looks like two 'C' shapes (`222/202/222`) placed side-by-side. The 'C' shape is derived from the `C / CCC` pattern by reflecting and joining? Or is it `C C C / C 0 C / C C C`? This seems more standard. Let's assume the base shape is `C C C / C 0 C / C C C`.
    c. Take the identified color C (Red). Construct the 3x3 'C' shape: `CCC/C0C/CCC`.
    d. Tile this shape horizontally twice to get the 3x6 output.
5.  **Case 2: Only Z-shape gray exists (`train_3`)**
    a. Find the color C (non-gray) such that its constituent objects primarily match the pattern `CCC / C0C / CCC`. In `train_3`, this is Orange (7). (Also Red and Green fit, why Orange? Maybe the *most frequent* pattern instance? Orange=41, Red=51, Green=23. No. Tallest stack? Orange stack height ~11. Red stack height ~5. Green stack height ~5. Maybe the tallest stack.) Let's assume for now it's Orange.
    b. The output is constructed from this basic `CCC / C0C / CCC` shape.
    c. Take the identified color C (Orange). Construct the 3x3 'C' shape: `777/707/777`.
    d. Repeat this shape vertically. How many times? The output is 17 rows. Input orange stack is 11 rows tall. 17 doesn't seem directly related to input properties. Maybe the height is determined by the *location* of the gray shape? In `train_3`, the gray shape is near row 17. That seems plausible. Repeat the 3x3 pattern vertically until the height matches the row index of the top-most gray pixel (or bottom-most?). Gray pixels are at (16, 27), (17, 26), (17, 27). Let's say the target height is max row index + 1 = 17+1=18? No, output height is 17. Target height = max row index = 17. Yes.
6.  **Case 3: Both L-shape and Z-shape gray exist (`train_2`)**
    a. Find the column index `col` of the *leftmost* gray pixel belonging to the L-shape. (In `train_2`, L-shape gray is at (14,19), (14,20), (15,19). Leftmost col = 19).
    b. Find the column index `col'` of the *leftmost* gray pixel belonging to the Z-shape. (In `train_2`, Z-shape gray is at (26,20), (27,19), (27,20). Leftmost col = 19).
    c. The target columns for the output are `col'-2` and `col'-1`. (Here 19-2=17, 19-1=18). This doesn't match the `train_2` output which seems to come from cols 13, 14.
    d. Let's reconsider: Maybe it's related to the *number* of gray shapes or their properties.
    e. Alternative for `train_2`: Find the vertical symmetry axis of the *entire* pattern of non-white input pixels. Extract the two columns immediately to the left of this axis?
        - Find bounding box of non-white pixels. Cols 4 to 27. Width = 27-4+1 = 24. Center column = 4 + (24/2) - 1 = 4 + 12 - 1 = 15. Column 15 is the right-center, column 14 is the left-center. The axis is between 14 and 15.
        - The two columns immediately left of the axis are 13 and 14.
        - Extract the content of columns 13 and 14 within the vertical bounding box of the non-white pixels (rows 3 to 28). This gives a 26x2 grid.
        - The output is 14x2. Where does the vertical cropping come from? Maybe the bounding box of the *gray* pixels? Gray pixels are rows 14-15 and 26-27. No.
        - Maybe the bounding box of the *central* pattern? The complex multi-colored part is roughly rows 7 to 22. That's 16 rows. Close to 14. Let's try extracting rows 7 to 20 (14 rows) from columns 13 and 14. This matches the output exactly.

**Refined Hypothesis:**
1.  Identify all contiguous gray objects. Classify them as L-shape (`55/50` type) or Z-shape (`05/55` type).
2.  **If only L-shape gray exists:**
    a. Find the color C whose objects fit the `C/CCC` pattern.
    b. Construct the 3x3 'C' shape (`CCC/C0C/CCC`) using color C.
    c. Tile this shape horizontally twice to form the output.
3.  **If only Z-shape gray exists:**
    a. Find the color C whose objects fit the `CCC/C0C/CCC` pattern. If multiple colors fit, choose the one whose pattern forms the tallest vertical stack in the input.
    b. Construct the 3x3 'C' shape (`CCC/C0C/CCC`) using color C.
    c. Determine the maximum row index `max_r` among all gray pixels.
    d. Repeat the 3x3 'C' shape vertically, creating an output grid of height `max_r` and width 3. Trim or repeat rows of the pattern as needed to match the height `max_r`. (In train_3, max_r = 17. The pattern `777/707/777` has height 3. 17 rows means 5 full repeats (15 rows) plus the first 2 rows of the pattern).
4.  **If both L-shape and Z-shape gray exist:**
    a. Find the bounding box of all non-white, non-gray pixels. Let the min/max rows be `r_min, r_max` and min/max cols be `c_min, c_max`.
    b. Calculate the center column index: `c_center = c_min + floor((c_max - c_min) / 2)`.
    c. The target columns are `c_center - 1` and `c_center`.
    d. Identify the core repeating vertical pattern within these two columns. Find the topmost row `r_pattern_start` and bottommost row `r_pattern_end` where this core pattern seems to exist (heuristically, maybe where the pattern isn't just white space). In `train_2`, this seems to be rows 7 to 20.
    e. Extract the subgrid from the input using rows `r_pattern_start` to `r_pattern_end` and columns `c_center - 1` and `c_center`. This is the output.

**Double Check:**
-   `train_1`: Only L-shape gray. Pattern `C/CCC` is Red(2). Base shape `222/202/222`. Tile twice horizontally -> `222222 / 202202 / 222222`. This does NOT match the output `222222 / 200000 / 222222`. The middle row is different.
    -   Maybe the output depends on the *input* shapes? Input has `2/222`. Output is 3x6. Is it `(2/222)` combined with its horizontal reflection `(222/2)`? No.
    -   What if the output pattern is derived from the gray shape? `55/50`. If 5->2 and 0->0, we get `22/20`. How does this become 3x6?
    -   What if the rule for L-shape gray is different? Find the color C with pattern `C/CCC`. Take this shape `S = C/CCC`. Output is `S` reflected horizontally + `S`? `(2/222)` reflected is `(222/2)`. Concatenated: `(2 222 / 222 2)`. No.
    -   Look at the output `222222 / 200000 / 222222`. It's a 3x6 rectangle filled with Red, with the middle row center 4 pixels cleared to white.
    -   Maybe L-shape gray means: Find the color C with `C/CCC` pattern. Create a rectangle filled with C. The dimensions are related to the gray shape? Gray `55/50` is 2x2. Output 3x6? No. Related to the `C/CCC` shape? It's 2 rows high, 3 wide. Output 3x6? No.
    -   Let's reconsider `train_1`. Input color counts: Blue 21, Red 9, Yellow 12. Red has fewest pixels. Maybe the rule is: Identify the non-gray color with the *fewest* pixels. Let this be C. Construct a 3x6 grid. Fill the border with C. Fill the interior `(row=1, col=1..4)` with white(0).
        - Test on `train_3`: Counts: Red 51, Green 23, Orange 41. Green has fewest. Output should use Green. But output uses Orange. Hypothesis fails.

**Backtrack: Focus on `train_3` again.**
-   Input: Orange, Red, Green C-shapes `XXX/X0X/XXX`. Gray Z-shape `05/55`.
-   Output: Orange `707/777/...` repeated vertically for 17 rows.
-   Why Orange? Tallest stack? Orange stack is rows 1-11. Red stack is rows 1-5. Green stack is rows 1-9. Orange is tallest.
-   Why 17 rows? Max row index of gray pixels is 17.
-   Hypothesis for `train_3`: Find the color C forming `CCC/C0C/CCC` shapes. Select the C whose shapes form the tallest vertical stack. Let the max row index of gray pixels be `max_r`. Construct the output by repeating the `CCC/C0C/CCC` pattern of the selected color vertically to a height of `max_r`.

**Apply this logic to `train_1`:**
-   Gray shape is L-shape `55/50`.
-   Find color C forming `CCC/C0C/CCC` shapes. None exist.
-   Find color C forming `C/CCC` shapes. Red(2). Red shapes are `2/222`.
-   Are there other patterns? Blue: `1/11/1/11`, also `1`. Yellow: `4/4/4444/4004/4444`.
-   Assume the L-shape gray refers to the `C/CCC` pattern. Select Red.
-   Max row index of gray pixels: `max_r = 28`.
-   Repeat the `C/CCC` pattern (`2/222`) vertically to height 28? No, output is 3x6.

**Consider the gray shapes as keys:**
-   Key `05/55` (Z-shape):
    1. Find color C forming `CCC/C0C/CCC` pattern.
    2. Select C with the tallest stack.
    3. Find max gray row `max_r`.
    4. Output is the `CCC/C0C/CCC` pattern repeated vertically to height `max_r`. (Works for train_3)
-   Key `55/50` (L-shape):
    1. Find color C forming `C/CCC` pattern. (Red in train_1)
    2. Select C? (Only Red fits).
    3. Find max gray row `max_r = 28`.
    4. Output is `CCC C C C / C 0 0 0 0 C / CCC C C C`? (Using C=Red). -> `222222 / 200000 / 222222`. Yes! This matches `train_1` output.
-   Key: Both L and Z shapes:
    1. Find center columns `c_center-1`, `c_center` based on non-gray bounding box.
    2. Find vertical extent `r_pattern_start`, `r_pattern_end` of core pattern in these columns.
    3. Extract `input[r_pattern_start:r_pattern_end+1, c_center-1:c_center+1]`. (Works for train_2)

**Final Hypothesis:**
1.  Identify contiguous gray shapes. Classify as L-type (`55/50` structure) or Z-type (`05/55` structure).
2.  Count the number of unique L-type shapes (`count_L`) and Z-type shapes (`count_Z`).
3.  **If `count_L > 0` and `count_Z == 0`:**
    a. Find the color `C` (non-gray, non-white) whose objects exclusively form patterns like `C / CCC` (potentially stacked). If multiple such colors exist, this rule needs refinement (e.g., smallest count, largest stack?). Assume only one exists for now (Red in train_1).
    b. Construct a 3x6 grid.
    c. Fill the border of the grid with color `C`.
    d. Fill the interior `(row=1, col=1..4)` with white (0).
    e. This 3x6 grid is the output.
4.  **If `count_L == 0` and `count_Z > 0`:**
    a. Find the color `C` (non-gray, non-white) whose objects exclusively form patterns like `CCC / C0C / CCC` (potentially stacked).
    b. If multiple such colors exist, select the one whose stacked pattern has the greatest height. (Orange in train_3).
    c. Determine the maximum row index `max_r` across all gray pixels in the input.
    d. Construct the base 3x3 pattern `P = CCC / C0C / CCC` using color `C`.
    e. Create the output grid by vertically repeating the rows of `P` until the grid height is `max_r`. (Specifically, output row `i` is `P[i % 3]`).
5.  **If `count_L > 0` and `count_Z > 0`:**
    a. Find the bounding box `(r_min, c_min, r_max, c_max)` of all non-white, non-gray pixels.
    b. Calculate the center column index just left of the vertical midline: `c_left_center = c_min + floor((c_max - c_min) / 2)`.
    c. Define the target columns `tc1 = c_left_center - 1`, `tc2 = c_left_center`.
    d. Determine the vertical range `(r_start, r_end)` containing the 'core pattern' within these columns (heuristically, e.g., rows 7-20 in train_2, perhaps defined by finding the min/max row index containing non-white pixels *within columns tc1 and tc2*).
    e. Extract the subgrid `input[r_start : r_end+1, tc1 : tc2+1]`. This is the output.

This hypothesis covers all three examples. Need to be precise about finding L/Z shapes and the "core pattern" range in case 3.

L-shape: 3 gray pixels where one is adjacent (not diagonal) to the other two, and those two are adjacent to each other (e.g., `(r,c), (r, c+1), (r+1, c)`).
Z-shape: 3 gray pixels where one is adjacent to the second, and the second is adjacent to the third, forming a non-straight line (e.g., `(r, c+1), (r+1, c), (r+1, c+1)`).

Need to handle rotations/reflections if necessary, but the examples might use canonical forms. Let's assume the base forms `55/50` and `05/55` are sufficient for now.**Perception**

1.  **Input Grid Structure:** The input grids are large (30x30) and sparsely populated with various colored objects against a white background.
2.  **Object Types:**
    *   Small gray (color 5) objects, typically composed of 2 or 3 pixels, appear in consistent patterns ("L-shape" like `55/50` or "Z-shape" like `05/55`). These seem to act as indicators or keys.
    *   Larger objects/patterns made of other colors (blue, red, green, yellow, orange, azure, maroon). These often exhibit repeating structures or specific shapes like 'C' patterns (`CCC/C0C/CCC`) or simpler blocks (`C/CCC`).
3.  **Output Grid Structure:** The output grids vary significantly in size and content based on the example.
    *   `train_1`: Small (3x6), single color (red), specific pattern (filled border, hollow center).
    *   `train_2`: Medium (14x2), multi-colored, appears to be a direct vertical slice from the input.
    *   `train_3`: Medium (17x3), single color (orange), repeating 'C' pattern vertically.
4.  **Transformation Logic:** The transformation seems conditional based on the type(s) of gray shapes present in the input.
    *   The gray shapes dictate which rule to apply.
    *   Rule 1 (L-shape gray): Identifies a specific color based on a simple pattern (`C/CCC`), then constructs a fixed 3x6 output pattern using that color.
    *   Rule 2 (Z-shape gray): Identifies a specific color based on a 'C' pattern (`CCC/C0C/CCC`), prioritizing the tallest stack, then repeats that 'C' pattern vertically to a height determined by the gray shape's position.
    *   Rule 3 (Both L & Z shapes gray): Extracts a specific two-column vertical slice from the input grid, based on the center of the main colored patterns.

**Facts**


```yaml
task_type: conditional_transformation
input_features:
  - grid_size: [30, 30]
  - background_color: 0 (white)
  - objects:
      - type: indicator
        color: 5 (gray)
        shape_types:
          - L-shape: 3 pixels, e.g., [[5, 5], [5, 0]] or rotations/reflections
          - Z-shape: 3 pixels, e.g., [[0, 5], [5, 5]] or rotations/reflections
        role: Determine the transformation rule case. May also determine output dimensions (e.g., height in Z-shape case).
      - type: pattern_source
        colors: [1, 2, 3, 4, 7, 8, 9] (non-gray, non-white)
        shapes:
          - C-pattern: 3x3, e.g., [[C, C, C], [C, 0, C], [C, C, C]]
          - Block-pattern: 2x3, e.g., [[C], [C, C, C]]
        arrangement: Often stacked vertically or grouped.
        role: Provide the color and/or base pattern for the output grid, selected based on criteria determined by the indicator shapes.
output_features:
  - grid_size: variable
  - content: Derived from selected input pattern_source objects/colors.
  - structure: Depends on the transformation rule case triggered by gray indicators.
    - Case L: Fixed 3x6 pattern with border of selected color C, hollow center.
    - Case Z: Vertical repetition of the 3x3 C-pattern of selected color C, height determined by gray position.
    - Case L+Z: Direct extraction of a 2-column slice from the input grid's central pattern.
relationships:
  - Gray shape type(s) determine the transformation case (L-only, Z-only, Both).
  - In L-only case, the gray shape implicitly selects the color C based on the `C/CCC` pattern, and the output is a fixed 3x6 shape using C.
  - In Z-only case, the gray shape implicitly selects the color C based on the `CCC/C0C/CCC` pattern (tallest stack), and the maximum row index of gray pixels determines the output height.
  - In Both case, the location of non-gray patterns determines the columns to extract, and the vertical extent of the pattern in those columns determines the rows to extract.
```


**Natural Language Program**

1.  **Analyze Gray Shapes:** Scan the input grid to find all contiguous groups of gray (5) pixels. Classify each group as either "L-shape" (three pixels like `[[5, 5], [5, 0]]`) or "Z-shape" (three pixels like `[[0, 5], [5, 5]]`), considering rotations and reflections. Determine if only L-shapes exist, only Z-shapes exist, or both types exist.
2.  **Conditional Execution:**
    *   **If only L-shapes exist:**
        a. Identify the non-gray, non-white color `C` whose objects in the input form a `C / CCC` pattern (a single pixel above a 1x3 row). Assume only one such color exists.
        b. Create a 3x6 output grid. Fill the border pixels (top/bottom rows and left/right columns) with color `C`. Fill the remaining inner pixels `(row=1, col=1..4)` with white (0).
    *   **If only Z-shapes exist:**
        a. Identify all non-gray, non-white colors `C` whose objects form a `CCC / C0C / CCC` pattern (a 3x3 'C' shape).
        b. Among these colors, select the one (`selected_C`) whose `CCC / C0C / CCC` patterns form the tallest connected vertical stack in the input grid.
        c. Find the maximum row index `max_r` among all gray pixels in the input.
        d. Create an output grid with `max_r` rows and 3 columns.
        e. Define the 3x3 pattern `P = [[selected_C, selected_C, selected_C], [selected_C, 0, selected_C], [selected_C, selected_C, selected_C]]`.
        f. Fill the output grid such that `output[i, j] = P[i % 3, j]`.
    *   **If both L-shapes and Z-shapes exist:**
        a. Find the minimal bounding box `(r_min, c_min, r_max, c_max)` enclosing all non-white, non-gray pixels.
        b. Calculate the column index just left of the vertical midline: `c_left_center = c_min + floor((c_max - c_min) / 2)`.
        c. Define the target columns: `tc1 = c_left_center - 1`, `tc2 = c_left_center`.
        d. Find the minimum row index `r_start` and maximum row index `r_end` such that there is at least one non-white pixel in either column `tc1` or
