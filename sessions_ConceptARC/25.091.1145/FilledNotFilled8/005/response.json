{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Set, List, Optional\n\n\"\"\"\nTransforms an input grid based on a diamond shape derived from its non-background pixels.\n\nThe transformation identifies the single non-background color (ShapeColor) and the set of pixels with this color (InputShapePixels).\nIt calculates the minimum and maximum values for u = row + col and v = row - col based on InputShapePixels.\nUsing these bounds (min_u, max_u, min_v, max_v), it generates a theoretical set of pixels (TheoreticalDiamondPixels) within the grid that satisfy min_u <= r+c <= max_u, min_v <= r-c <= max_v, and where r+c and r-c have the same parity.\n\nIf InputShapePixels is identical to TheoreticalDiamondPixels, the input is considered a 'perfect' filled diamond. The output grid will contain only the perimeter pixels of this diamond, colored with ShapeColor. A perimeter pixel is one within the diamond that has at least one 8-directionally adjacent neighbor outside the diamond or outside the grid bounds.\n\nIf InputShapePixels is not identical to TheoreticalDiamondPixels (e.g., the input pixels are scattered or form an incomplete diamond), the output grid will be the completely filled TheoreticalDiamondPixels, colored with ShapeColor.\n\nThe background color is assumed to be 0.\n\"\"\"\n\ndef _find_shape_pixels(grid: np.ndarray) -> Tuple[Optional[int], Set[Tuple[int, int]]]:\n    \"\"\"Finds the non-background color and coordinates of shape pixels.\"\"\"\n    # Find coordinates where the grid is not equal to the background color (0)\n    non_background_indices = np.where(grid != 0)\n    \n    # If no non-background pixels are found, return None for color and an empty set\n    if len(non_background_indices[0]) == 0:\n        return None, set()\n\n    # Extract the coordinates as a set of (row, col) tuples\n    pixel_coords = set(zip(non_background_indices[0], non_background_indices[1]))\n    \n    # Get the color of the first non-background pixel found (assuming only one color)\n    shape_color = int(grid[non_background_indices[0][0], non_background_indices[1][0]])\n    \n    return shape_color, pixel_coords\n\ndef _calculate_uv_bounds(pixels: Set[Tuple[int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"Calculates the min/max bounds for u=r+c and v=r-c.\"\"\"\n    if not pixels:\n        return None # No pixels, no bounds\n    # Calculate u = r+c for all pixels\n    u_coords = [r + c for r, c in pixels]\n    # Calculate v = r-c for all pixels\n    v_coords = [r - c for r, c in pixels]\n    # Return the min/max of u and v\n    return min(u_coords), max(u_coords), min(v_coords), max(v_coords)\n\ndef _generate_diamond_pixels_uv(uv_bounds: Tuple[int, int, int, int], grid_shape: Tuple[int, int]) -> Set[Tuple[int, int]]:\n    \"\"\"Generates pixels within the diamond defined by u,v bounds and parity check.\"\"\"\n    min_u, max_u, min_v, max_v = uv_bounds\n    rows, cols = grid_shape\n    diamond_pixels = set()\n    \n    # Iterate through all grid pixels\n    for r in range(rows):\n        for c in range(cols):\n            u = r + c\n            v = r - c\n            # Check if the pixel's u,v fall within the calculated bounds\n            if min_u <= u <= max_u and min_v <= v <= max_v:\n                 # Check the parity constraint: (r+c) and (r-c) must have same parity.\n                 # This is equivalent to checking if u and v have the same parity.\n                 if (u % 2) == (v % 2): \n                     diamond_pixels.add((r, c))\n                     \n    return diamond_pixels\n\ndef _is_perimeter(r: int, c: int, grid_shape: Tuple[int, int], diamond_pixels: Set[Tuple[int, int]]) -> bool:\n    \"\"\"Checks if a pixel (r, c) within the diamond is adjacent (8-way) to a non-diamond pixel or grid edge.\"\"\"\n    rows, cols = grid_shape\n    # Iterate through all 8 neighbors\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is outside the grid boundaries\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                return True # Pixel is adjacent to the grid edge\n\n            # Check if the neighbor is NOT part of the diamond pixel set\n            if (nr, nc) not in diamond_pixels:\n                return True # Pixel is adjacent to a background/non-diamond pixel\n\n    # If none of the neighbors were outside the diamond or grid, it's an interior pixel\n    return False\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the diamond fill/hollow transformation based on u,v bounds.\n    \"\"\"\n    # Convert input to NumPy array\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize the output grid with background color 0\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the shape color and input pixel coordinates\n    shape_color, input_shape_pixels = _find_shape_pixels(input_np)\n\n    # If no shape pixels are found, return the original grid\n    if shape_color is None:\n        return input_grid\n\n    # 2. Calculate the u,v bounds from the input pixels\n    uv_bounds = _calculate_uv_bounds(input_shape_pixels)\n    if uv_bounds is None: # Should not happen if shape_color is not None\n         return input_grid \n\n    # 3. Generate the set of pixels for the theoretical diamond based on u,v bounds\n    theoretical_diamond_pixels = _generate_diamond_pixels_uv(uv_bounds, (rows, cols))\n\n    # 4. Compare the actual input pixels with the theoretical diamond pixels\n    is_perfect_diamond_input = (input_shape_pixels == theoretical_diamond_pixels)\n\n    # 5. Determine the output based on the comparison\n    if not is_perfect_diamond_input:\n        # Mode 1: Input was scattered or incomplete. Fill the theoretical diamond.\n        for r, c in theoretical_diamond_pixels:\n             # Check bounds just in case, though _generate ensures this\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_np[r, c] = shape_color\n    else:\n        # Mode 2: Input was a perfect filled diamond. Hollow it (keep only perimeter).\n        for r, c in theoretical_diamond_pixels:\n             # Check if the current pixel is on the perimeter\n             if _is_perimeter(r, c, (rows, cols), theoretical_diamond_pixels):\n                 # Check bounds just in case\n                 if 0 <= r < rows and 0 <= c < cols:\n                     output_np[r, c] = shape_color\n\n    # Convert the final NumPy array back to a list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19846,
    "candidates_token_count": 1786,
    "total_token_count": 21632,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.448465,
  "retries": 1
}