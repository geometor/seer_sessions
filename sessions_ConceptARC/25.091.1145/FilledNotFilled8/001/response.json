{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Set, List\n\n\"\"\"\nThis code solves ARC task a8c383ab.\nThe transformation identifies the non-background color pixels in the input.\nIt calculates the minimal bounding diamond (using Manhattan distance) that encloses all these pixels.\nIt then determines if the input pixels perfectly match all pixels within this theoretical diamond.\nIf the input pixels DO NOT match the theoretical filled diamond (e.g., they are scattered points), the output is the complete, filled diamond using the identified color.\nIf the input pixels DO match the theoretical filled diamond, the output is the perimeter of that diamond, keeping only the pixels that are adjacent (8-way) to a background pixel or the grid edge.\n\"\"\"\n\ndef _find_shape_pixels(grid: np.ndarray) -> Tuple[int, Set[Tuple[int, int]]]:\n    \"\"\"Finds the non-background color and coordinates of shape pixels.\"\"\"\n    non_background_pixels = np.where(grid != 0)\n    if len(non_background_pixels[0]) == 0:\n        return 0, set()  # No shape found, return background color and empty set\n\n    # Assume only one non-background color\n    shape_color = int(grid[non_background_pixels[0][0], non_background_pixels[1][0]])\n    \n    pixel_coords = set(zip(non_background_pixels[0], non_background_pixels[1]))\n    return shape_color, pixel_coords\n\ndef _manhattan_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:\n    \"\"\"Calculates Manhattan distance between two points.\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef _calculate_diamond_params(pixels: Set[Tuple[int, int]]) -> Tuple[Tuple[float, float], int]:\n    \"\"\"Calculates the center and radius of the minimal bounding diamond.\"\"\"\n    if not pixels:\n        return (0, 0), -1 # Indicate no pixels\n\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Calculate center based on the bounding box midpoints\n    center_r = (min_r + max_r) / 2.0\n    center_c = (min_c + max_c) / 2.0\n    center = (center_r, center_c)\n    \n    # Find the maximum Manhattan distance from the *integer* pixel coordinates\n    # closest to the calculated center to any pixel in the set.\n    # Test the four potential integer centers around the float center.\n    potential_centers = [\n        (int(np.floor(center_r)), int(np.floor(center_c))),\n        (int(np.floor(center_r)), int(np.ceil(center_c))),\n        (int(np.ceil(center_r)), int(np.floor(center_c))),\n        (int(np.ceil(center_r)), int(np.ceil(center_c))),\n    ]\n\n    best_center = None\n    min_max_dist = float('inf')\n\n    # Refined approach: Find the tightest diamond.\n    # The center must be the average of the extrema in row+col and row-col coordinates.\n    # Let u = r + c, v = r - c\n    u_coords = [r + c for r, c in pixels]\n    v_coords = [r - c for r, c in pixels]\n    min_u, max_u = min(u_coords), max(u_coords)\n    min_v, max_v = min(v_coords), max(v_coords)\n    \n    # Center calculation from u,v extrema:\n    # center_r + center_c = (min_u + max_u) / 2\n    # center_r - center_c = (min_v + max_v) / 2\n    # Adding: 2 * center_r = (min_u + max_u + min_v + max_v) / 2\n    # Subtracting: 2 * center_c = (min_u + max_u - min_v - max_v) / 2\n    center_r = (min_u + max_u + min_v + max_v) / 4.0\n    center_c = (min_u + max_u - min_v - max_v) / 4.0\n    center = (center_r, center_c)\n    \n    # The radius k is related to the span of u and v\n    # k = max(|r - center_r| + |c - center_c|)\n    # This can also be expressed as:\n    radius = (max(max_u - min_u, max_v - min_v)) / 2.0\n\n    # Find the max distance from the *closest integer coordinate* center\n    # Need to handle float centers and radii carefully. Check integer grid points.\n    int_center_r = round(center_r)\n    int_center_c = round(center_c)\n    int_center = (int_center_r, int_center_c)\n    \n    max_dist = 0\n    for pixel in pixels:\n         dist = _manhattan_distance(pixel, int_center)\n         max_dist = max(max_dist, dist)\n\n    # It's possible the true center is slightly offset, affecting radius.\n    # A more robust radius calculation is needed if center is float.\n    # Let's stick to the max distance from the rounded integer center for now.\n    radius_k = max_dist \n\n    return int_center, radius_k\n\n\ndef _generate_diamond_pixels(center: Tuple[int, int], radius: int, grid_shape: Tuple[int, int]) -> Set[Tuple[int, int]]:\n    \"\"\"Generates all pixel coordinates within the diamond defined by center and radius.\"\"\"\n    diamond_pixels = set()\n    center_r, center_c = center\n    rows, cols = grid_shape\n    \n    # Iterate through a bounding box around the diamond\n    min_r_bound = max(0, center_r - radius)\n    max_r_bound = min(rows, center_r + radius + 1)\n    min_c_bound = max(0, center_c - radius)\n    max_c_bound = min(cols, center_c + radius + 1)\n\n    for r in range(min_r_bound, max_r_bound):\n        for c in range(min_c_bound, max_c_bound):\n            if _manhattan_distance((r, c), center) <= radius:\n                diamond_pixels.add((r, c))\n    return diamond_pixels\n\ndef _is_perimeter(r: int, c: int, grid_shape: Tuple[int, int], diamond_pixels: Set[Tuple[int, int]]) -> bool:\n    \"\"\"Checks if a pixel (r, c) within the diamond is adjacent to a non-diamond pixel.\"\"\"\n    rows, cols = grid_shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n            \n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is outside grid bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                return True # Adjacent to edge\n            \n            # Check if neighbor is not part of the diamond\n            if (nr, nc) not in diamond_pixels:\n                return True # Adjacent to background or other shape\n                \n    return False # All neighbors are within the diamond\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the diamond fill/hollow logic.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_np = np.zeros_like(input_np) # Initialize with background color 0\n\n    # 1. Identify Shape Pixels\n    shape_color, input_shape_pixels = _find_shape_pixels(input_np)\n\n    if not input_shape_pixels:\n        return input_grid # Return original if no shape found\n\n    # 2. Determine Bounding Diamond Parameters\n    center, radius = _calculate_diamond_params(input_shape_pixels)\n    \n    # Check if valid parameters were found\n    if radius < 0:\n         return input_grid # Should not happen if pixels were found, but safety check\n\n    # 3. Generate Theoretical Diamond Pixels\n    theoretical_diamond_pixels = _generate_diamond_pixels(center, radius, (rows, cols))\n\n    # 4. Compare Input Pixels with Theoretical Diamond\n    is_filled_diamond_input = (input_shape_pixels == theoretical_diamond_pixels)\n\n    # 5. Apply Transformation based on comparison\n    if not is_filled_diamond_input:\n        # Mode 1: Fill the diamond (Input was scattered/incomplete)\n        for r, c in theoretical_diamond_pixels:\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_np[r, c] = shape_color\n    else:\n        # Mode 2: Hollow the diamond (Input was already a filled diamond)\n        for r, c in theoretical_diamond_pixels:\n             # Keep pixel if it's on the perimeter\n             if _is_perimeter(r, c, (rows, cols), theoretical_diamond_pixels):\n                 if 0 <= r < rows and 0 <= c < cols: # Redundant check, but safe\n                     output_np[r, c] = shape_color\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3591,
    "candidates_token_count": 2327,
    "total_token_count": 5918,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 118.05857,
  "retries": 2
}