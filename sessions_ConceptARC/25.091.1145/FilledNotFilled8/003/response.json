{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Set, List, Optional\nimport math\n\n\"\"\"\nThis code solves ARC task a8c383ab.\nThe transformation identifies the non-background color pixels in the input grid.\nIt determines the parameters (center and radius) of a diamond shape based on the bounding box of these input pixels.\nIt then generates all pixels that would belong to a perfect diamond with these parameters.\nIf the set of input pixels is identical to the set of pixels in the generated theoretical diamond, the output is the perimeter (hollow diamond) of this shape.\nOtherwise (if the input pixels are scattered or form an incomplete diamond), the output is the completely filled theoretical diamond.\nThe background color is assumed to be 0. Only one non-background color is expected per input grid.\n\"\"\"\n\ndef _find_shape_pixels(grid: np.ndarray) -> Tuple[Optional[int], Set[Tuple[int, int]]]:\n    \"\"\"Finds the non-background color and coordinates of shape pixels.\"\"\"\n    # Find coordinates where the grid is not equal to the background color (0)\n    non_background_indices = np.where(grid != 0)\n    \n    # If no non-background pixels are found, return None for color and an empty set\n    if len(non_background_indices[0]) == 0:\n        return None, set()\n\n    # Extract the coordinates as a set of (row, col) tuples\n    pixel_coords = set(zip(non_background_indices[0], non_background_indices[1]))\n    \n    # Get the color of the first non-background pixel found (assuming only one color)\n    shape_color = int(grid[non_background_indices[0][0], non_background_indices[1][0]])\n    \n    return shape_color, pixel_coords\n\ndef _calculate_diamond_params_from_bbox(pixels: Set[Tuple[int, int]]) -> Tuple[Tuple[int, int], int]:\n    \"\"\"\n    Calculates the center and radius of a diamond based on the bounding box of the pixels.\n    Returns ((center_r, center_c), radius).\n    \"\"\"\n    if not pixels:\n        # Should not happen if called after checking for pixels, but defensive check\n        return (0, 0), -1 \n\n    # Extract row and column coordinates\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n\n    # Find the min/max row and column to define the bounding box\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Calculate the center coordinates by averaging the min/max and rounding\n    # Using integer division // for robustness if sum is odd\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    center = (center_r, center_c)\n\n    # Calculate the radius based on the larger dimension of the bounding box\n    # This defines the 'size' of the diamond related to the bbox extent\n    # Using integer division // 2\n    radius = max(max_r - min_r, max_c - min_c) // 2\n    \n    # Alternative center calculation: check if averaging produces .5\n    # center_r_float = (min_r + max_r) / 2.0\n    # center_c_float = (min_c + max_c) / 2.0\n    # center_r = int(round(center_r_float)) # Round to nearest int\n    # center_c = int(round(center_c_float)) # Round to nearest int\n    # We use the integer division approach first as it seemed to work for examples.\n\n    return center, radius\n\ndef _generate_diamond_pixels(center: Tuple[int, int], radius: int, grid_shape: Tuple[int, int]) -> Set[Tuple[int, int]]:\n    \"\"\"Generates all pixel coordinates within the diamond defined by center and radius.\"\"\"\n    diamond_pixels = set()\n    center_r, center_c = center\n    rows, cols = grid_shape\n    \n    # Iterate through potential pixels within the grid boundaries\n    # No need to calculate tight bounds, just check distance for all grid cells\n    # (Optimization possible by iterating only within bounding box of diamond)\n    min_r_bound = max(0, center_r - radius)\n    max_r_bound = min(rows, center_r + radius + 1)\n    min_c_bound = max(0, center_c - radius)\n    max_c_bound = min(cols, center_c + radius + 1)\n\n    for r in range(min_r_bound, max_r_bound):\n        for c in range(min_c_bound, max_c_bound):\n            # Calculate Manhattan distance from the pixel to the center\n            distance = abs(r - center_r) + abs(c - center_c)\n            # If the distance is within the radius, add it to the set\n            if distance <= radius:\n                diamond_pixels.add((r, c))\n                \n    return diamond_pixels\n\ndef _is_perimeter(r: int, c: int, grid_shape: Tuple[int, int], diamond_pixels: Set[Tuple[int, int]]) -> bool:\n    \"\"\"Checks if a pixel (r, c) within the diamond is adjacent (8-way) to a non-diamond pixel or grid edge.\"\"\"\n    rows, cols = grid_shape\n    # Iterate through all 8 neighbors and self (checking self is redundant but harmless)\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor is outside the grid boundaries\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                return True # Pixel is adjacent to the grid edge\n\n            # Check if the neighbor is NOT part of the diamond pixel set\n            if (nr, nc) not in diamond_pixels:\n                return True # Pixel is adjacent to a background/non-diamond pixel\n\n    # If none of the neighbors were outside the diamond or grid, it's an interior pixel\n    return False\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on detecting a diamond shape.\n    If the input perfectly matches a filled diamond derived from its bounding box,\n    the output is the hollow perimeter of that diamond.\n    Otherwise, the output is the filled diamond derived from the bounding box.\n    \"\"\"\n    # Convert the input list of lists to a NumPy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize the output grid with the background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # 1. Find the shape's color and the coordinates of its pixels\n    shape_color, input_shape_pixels = _find_shape_pixels(input_np)\n\n    # If no shape pixels are found, return the original grid\n    if shape_color is None:\n        return input_grid\n\n    # 2. Calculate the diamond parameters (center, radius) based on the bounding box\n    center, radius = _calculate_diamond_params_from_bbox(input_shape_pixels)\n\n    # If radius calculation failed (e.g., no pixels), return original grid\n    if radius < 0:\n         return input_grid \n\n    # 3. Generate the set of pixels for a theoretical perfect diamond with these parameters\n    theoretical_diamond_pixels = _generate_diamond_pixels(center, radius, (rows, cols))\n\n    # 4. Compare the actual input pixels with the theoretical diamond pixels\n    is_perfect_diamond_input = (input_shape_pixels == theoretical_diamond_pixels)\n\n    # 5. Determine the output based on whether the input was a perfect diamond\n    if not is_perfect_diamond_input:\n        # Mode 1: Input was scattered or incomplete. Output is the filled theoretical diamond.\n        for r, c in theoretical_diamond_pixels:\n             # Ensure coordinates are within grid bounds (should be, but safety check)\n             if 0 <= r < rows and 0 <= c < cols:\n                 output_np[r, c] = shape_color\n    else:\n        # Mode 2: Input was a perfect filled diamond. Output is the perimeter.\n        for r, c in theoretical_diamond_pixels:\n             # Check if the current pixel is on the perimeter\n             if _is_perimeter(r, c, (rows, cols), theoretical_diamond_pixels):\n                 # Ensure coordinates are within grid bounds\n                 if 0 <= r < rows and 0 <= c < cols:\n                     output_np[r, c] = shape_color\n\n    # Convert the final NumPy array back to a list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14155,
    "candidates_token_count": 2108,
    "total_token_count": 16263,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 122.18728,
  "retries": 2
}