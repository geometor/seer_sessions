
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 3 4 0 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```

*   **Perception:** The task involves modifying pixels within a region defined by a green (color 3) boundary. The modification depends on the presence of yellow (color 4) pixels within this boundary in the input and the coordinates of white (color 0) pixels inside. Specifically, if yellow pixels are present inside the boundary, certain white pixels within that boundary are changed to yellow based on a checkerboard pattern determined by coordinate parity. If no yellow pixels are initially inside the boundary, no changes are made.

*   **Facts:**
    
```yaml
    elements:
      - object: boundary
        color: 3 # green
        description: A contiguous shape made of green pixels that encloses a region. Can be complete or incomplete (touching grid edge).
      - object: interior_region
        description: The set of pixels enclosed by the green boundary. These pixels are not green and cannot reach the grid edge without crossing a green pixel.
      - object: interior_pixel
        description: A pixel located within the interior_region.
        properties:
          - color: Can be white (0), yellow (4), or potentially other colors (though only 0 and 4 appear internally in examples).
          - coordinates: (row, column) index pair.
          - parity_sum: The sum of the row and column index (row + column).

    actions:
      - name: identify_boundary
        input: input_grid
        output: set of coordinates for green (3) pixels forming the boundary.
      - name: identify_interior_region
        input: input_grid, boundary_coordinates
        output: set of coordinates for pixels inside the boundary.
        method: Find non-green pixels not reachable from the grid edge without crossing green pixels.
      - name: check_interior_yellow_presence
        input: input_grid, interior_region_coordinates
        output: boolean (true if at least one yellow (4) pixel exists in the interior region, false otherwise).
      - name: apply_transformation
        input: input_grid, interior_region_coordinates, interior_yellow_present (boolean)
        output: output_grid
        condition: Only applies if interior_yellow_present is true.
        rule: For each pixel (r, c) in interior_region_coordinates:
                If input_grid[r, c] is white (0) AND (r + c) is even:
                  output_grid[r, c] = yellow (4)
                Else:
                  output_grid[r, c] = input_grid[r, c]
      - name: no_transformation
        input: input_grid
        output: output_grid
        condition: Applies if interior_yellow_present is false.
        rule: output_grid = input_grid

    relationships:
      - The green boundary defines the interior_region.
      - The transformation rule depends on the initial presence of yellow pixels within the interior_region.
      - The transformation targets specific white pixels within the interior_region based on their coordinate parity sum.
    ```


*   **Natural Language Program:**
    1.  Identify all green (3) pixels in the input grid. These form a boundary.
    2.  Determine the set of all non-green pixels that are enclosed by this boundary (i.e., cannot reach the edge of the grid without crossing a green pixel). This is the "interior region".
    3.  Scan the interior region in the input grid to see if it contains any yellow (4) pixels.
    4.  **If** the interior region contains at least one yellow (4) pixel in the input grid:
        a.  Create the output grid by copying the input grid.
        b.  Iterate through each pixel (with coordinates row `r`, column `c`) within the interior region.
        c.  If the pixel's color in the input grid is white (0) AND the sum of its coordinates (`r + c`) is an even number, change the color of the corresponding pixel in the output grid to yellow (4).
        d.  Leave all other pixels in the output grid (including boundary pixels, pixels outside the boundary, yellow interior pixels, and white interior pixels where `r + c` is odd) unchanged from their input colors.
    5.  **Else (if** the interior region contains no yellow (4) pixels in the input grid):
        a.  The output grid is an identical copy of the input grid.
