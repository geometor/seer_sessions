
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 2 2 1 0 0 0 0
0 0 0 0 0 1 2 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 1 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 2 1 0 0
0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 2 2 1 0 0 0 0
0 0 0 0 0 1 2 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 0 0 0 0 1
1 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 1 2 2 2 2 2 2 2 2 1 1 0
0 0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 1 2 2 2 2 2 2 1 1 0 0
0 0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 1 1 1 1 1 1 1 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 2 2 2 2 2 2 2 2 2 2 2 1
1 2 2 2 2 2 2 2 2 2 2 2 2 1
1 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 1 2 2 2 2 2 2 2 2 1 1 0
0 0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 1 2 2 2 2 2 2 1 1 0 0
0 0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 1 1 1 1 1 1 1 0 0 0
```

*   **Perception:**
    The task involves identifying regions enclosed by blue pixels (1) and filling any white pixels (0) within those enclosed regions with red pixels (2). The blue pixels act as a boundary or fence. If the boundary is complete, any white space inside gets filled. If the boundary is incomplete or there's no enclosed white space, the grid remains unchanged. The red pixels (2) already present within the boundary are not affected, nor are pixels outside the boundary.

*   **YAML Facts:**
    
```yaml
    task_type: fill_enclosed_region
    elements:
      - object: background
        color: 0 # white
        role: fillable_space/exterior
      - object: border
        color: 1 # blue
        role: boundary
      - object: interior_fill
        color: 2 # red
        role: existing_fill/fill_color
    actions:
      - identify_boundary: Find the structure formed by blue (1) pixels.
      - identify_regions: Determine areas enclosed by the blue boundary.
      - flood_fill: Fill white (0) pixels within the identified enclosed regions.
    transformation_rule:
      - If a white (0) pixel is fully enclosed by a boundary of blue (1) pixels (possibly including existing red (2) pixels as part of the inside), change its color to red (2).
      - Enclosed means there is no path from the white pixel to the edge of the grid consisting solely of white pixels.
    relationships:
      - containment: Blue pixels define regions that contain red and potentially white pixels.
      - adjacency: The filling process depends on the adjacency of white pixels to the boundary and other interior pixels.
    unchanged_elements:
      - Blue (1) pixels.
      - Red (2) pixels already present in the input.
      - White (0) pixels not enclosed by the blue boundary.
    ```


*   **Natural Language Program:**
    1.  Identify all white (0) pixels that are connected to the border of the grid through a path of only white (0) pixels. Mark these as "exterior" white pixels. Use a flood fill or similar connectivity algorithm starting from all white pixels on the grid's edges (top, bottom, left, right).
    2.  Identify all remaining white (0) pixels that were not marked as "exterior". These are the "interior" or "enclosed" white pixels.
    3.  Change the color of all identified "interior" white (0) pixels to red (2).
    4.  Leave all other pixels (blue, existing red, and "exterior" white) unchanged.
    5.  Output the modified grid.
```python
"""
Identify all white (0) pixels that are connected to the border of the grid through a path of only white (0) pixels (exterior white pixels). 
Change the color of all remaining white (0) pixels (interior or enclosed white pixels) to red (2). 
Leave all other pixels (blue (1), existing red (2), and exterior white (0)) unchanged.
"""

import numpy as np
from collections import deque

def transform(input_grid):
    """
    Fills enclosed white regions within a blue boundary with red.

    Args:
        input_grid (list of lists): The input grid represented as a list of lists.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to a numpy array for efficient manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)  # Work on a copy
    height, width = grid.shape

    # Keep track of visited white pixels connected to the border
    visited = np.zeros_like(grid, dtype=bool)
    
    # Queue for Breadth-First Search (BFS)
    q = deque()

    # 1. Seed the flood fill: Add all white border pixels to the queue and mark as visited.
    for r in range(height):
        for c in [0, width - 1]: # Left and right columns
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
                
    for c in range(width):
        for r in [0, height - 1]: # Top and bottom rows
             # Avoid adding corners twice if they were already added by column check
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True

    # 2. Perform flood fill (BFS) to find all 'exterior' white pixels
    while q:
        r, c = q.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < height and 0 <= nc < width:
                # Check if neighbor is white (0) and not visited
                if grid[nr, nc] == 0 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    q.append((nr, nc))

    # 3. Fill 'interior' white pixels: Iterate through the grid.
    # If a pixel is white (0) and was NOT visited by the flood fill (meaning it's not connected to the border),
    # change its color to red (2) in the output grid.
    for r in range(height):
        for c in range(width):
            if grid[r, c] == 0 and not visited[r, c]:
                output_grid[r, c] = 2

    # Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
```python
"""
Identify all non-white (non-0) pixels. Determine the minimum bounding box 
containing these pixels. Iterate through all pixels within this bounding box. 
If a pixel inside the bounding box is white (0), change its color to red (2). 
Leave all other pixels unchanged.
"""

import numpy as np

def transform(input_grid):
    """
    Fills white pixels within the bounding box of non-white pixels with red.

    Args:
        input_grid (list of lists): The input grid represented as a list of lists.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to a numpy array for efficient manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = np.copy(grid)  # Work on a copy
    height, width = grid.shape

    # 1. Find coordinates of all non-white (structure) pixels
    structure_pixels_coords = np.argwhere(grid != 0)

    # 2. Handle edge case: If there are no structure pixels, return the original grid
    if structure_pixels_coords.size == 0:
        return input_grid # Return original list of lists format

    # 3. Calculate the bounding box
    min_row = structure_pixels_coords[:, 0].min()
    max_row = structure_pixels_coords[:, 0].max()
    min_col = structure_pixels_coords[:, 1].min()
    max_col = structure_pixels_coords[:, 1].max()

    # 4. Iterate through each pixel within the bounding box
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            # 5. Check if the pixel in the *original* grid is white (0)
            if grid[r, c] == 0:
                # 6. If it's white and inside the box, change it to red (2) in the output grid
                output_grid[r, c] = 2

    # 7. Convert back to list of lists for the expected output format
    return output_grid.tolist()
```
