
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 1 2 2 2 2 1 0 0 0 0
0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 1 0 0 0 0 0 0 0 1 0 0
0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 2 2 1 0 0 0 0
0 0 0 0 0 1 2 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 1 2 2 2 2 2 2 2 1 0 0
0 0 1 2 2 2 2 2 2 2 1 0 0
0 0 0 1 2 2 2 2 2 1 0 0 0
0 0 0 0 1 2 2 2 1 0 0 0 0
0 0 0 0 0 1 2 1 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 2 2 2 2 1 0 0 0
1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 0 0 0 0 1
1 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 1 2 2 2 2 2 2 2 2 1 1 0
0 0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 1 2 2 2 2 2 2 1 1 0 0
0 0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 1 1 1 1 1 1 1 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 2 2 2 2 2 2 2 2 2 2 2 2 1
1 2 2 2 2 2 2 2 2 2 2 2 2 1
1 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 2 2 2 2 2 2 2 2 2 2 1 0
0 1 1 2 2 2 2 2 2 2 2 1 1 0
0 0 1 2 2 2 2 2 2 2 2 1 0 0
0 0 1 1 2 2 2 2 2 2 1 1 0 0
0 0 0 1 2 2 2 2 2 2 1 0 0 0
0 0 0 1 1 1 1 1 1 1 1 0 0 0
```

*   **Perception:**
    The task involves identifying regions enclosed by blue pixels (1) and filling any white pixels (0) within those enclosed regions with red pixels (2). The blue pixels act as a boundary or fence. If the boundary is complete, any white space inside gets filled. If the boundary is incomplete or there's no enclosed white space, the grid remains unchanged. The red pixels (2) already present within the boundary are not affected, nor are pixels outside the boundary.

*   **YAML Facts:**
    
```yaml
    task_type: fill_enclosed_region
    elements:
      - object: background
        color: 0 # white
        role: fillable_space/exterior
      - object: border
        color: 1 # blue
        role: boundary
      - object: interior_fill
        color: 2 # red
        role: existing_fill/fill_color
    actions:
      - identify_boundary: Find the structure formed by blue (1) pixels.
      - identify_regions: Determine areas enclosed by the blue boundary.
      - flood_fill: Fill white (0) pixels within the identified enclosed regions.
    transformation_rule:
      - If a white (0) pixel is fully enclosed by a boundary of blue (1) pixels (possibly including existing red (2) pixels as part of the inside), change its color to red (2).
      - Enclosed means there is no path from the white pixel to the edge of the grid consisting solely of white pixels.
    relationships:
      - containment: Blue pixels define regions that contain red and potentially white pixels.
      - adjacency: The filling process depends on the adjacency of white pixels to the boundary and other interior pixels.
    unchanged_elements:
      - Blue (1) pixels.
      - Red (2) pixels already present in the input.
      - White (0) pixels not enclosed by the blue boundary.
    ```


*   **Natural Language Program:**
    1.  Identify all white (0) pixels that are connected to the border of the grid through a path of only white (0) pixels. Mark these as "exterior" white pixels. Use a flood fill or similar connectivity algorithm starting from all white pixels on the grid's edges (top, bottom, left, right).
    2.  Identify all remaining white (0) pixels that were not marked as "exterior". These are the "interior" or "enclosed" white pixels.
    3.  Change the color of all identified "interior" white (0) pixels to red (2).
    4.  Leave all other pixels (blue, existing red, and "exterior" white) unchanged.
    5.  Output the modified grid.
