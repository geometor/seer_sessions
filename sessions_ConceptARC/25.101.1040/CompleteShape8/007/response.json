{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the color and spatial arrangement of its pixels.\n\n1. Create a new output grid with the same dimensions as the input grid, filled entirely with the white background color (0).\n2. Identify all unique non-white (0) and non-gray (5) colors present in the input grid.\n3. For each unique non-gray color identified:\n    a. Find the set of coordinates `C` of all pixels in the input grid that have this color.\n    b. If `C` is empty, continue to the next color.\n    c. Calculate the minimum bounding box `B` enclosing all coordinates in `C`. Let `(min_r, min_c)` be the top-left corner and `(max_r, max_c)` be the bottom-right corner. Determine the height `H = max_r - min_r + 1` and width `W = max_c - min_c + 1`.\n    d. Check for Pattern 1 (2x2 Diagonal): If `H` is 2, `W` is 2, `C` contains exactly 2 pixels, and those pixels are `(min_r, min_c)` and `(max_r, max_c)`:\n        i. Add pixels to the output grid at the following six coordinates (relative to `min_r, min_c`), using the current color: `(min_r+0, min_c+0)`, `(min_r+1, min_c+1)`, `(min_r+0, min_c+2)`, `(min_r+2, min_c+0)`, `(min_r+2, min_c+1)`, `(min_r+2, min_c+2)`. Ensure coordinates are within grid bounds.\n    e. Check for Pattern 2 (3x3 Anti-Diagonal): Else if `H` is 3, `W` is 3, `C` contains exactly 2 pixels, and those pixels are `(min_r, max_c)` and `(max_r, min_c)`:\n        i. Add pixels to the output grid at the following six coordinates, using the current color: `(min_r, min_c)`, `(min_r, max_c)`, `(min_r+1, min_c+1)`, `(max_r, min_c)`, `(max_r, min_c+1)`, `(max_r, max_c)`. Ensure coordinates are within grid bounds.\n    f. Check for Pattern 3 (General 3x3): Else if `H` is 3 and `W` is 3:\n        i. Fill the entire 3x3 rectangular area defined by the bounding box `B` (from `min_r` to `max_r` and `min_c` to `max_c`) in the output grid with the current color.\n    g. Fallback (Other): Otherwise (if none of the above specific patterns or conditions match):\n        i. For each original pixel coordinate in `C`, set the corresponding pixel in the output grid to the current color.\n4. Return the completed output grid. Gray pixels (5) from the input are implicitly ignored.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\ndef get_bounding_box(coords: np.ndarray) -> Tuple[int, int, int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box and its dimensions for a set of coordinates.\n\n    Args:\n        coords: A NumPy array of shape (N, 2) containing (row, col) coordinates.\n\n    Returns:\n        A tuple containing (min_row, min_col, max_row, max_col, height, width).\n        Returns (-1, -1, -1, -1, 0, 0) if coords is empty.\n    \"\"\"\n    if coords.shape[0] == 0:\n        return -1, -1, -1, -1, 0, 0\n\n    min_row = np.min(coords[:, 0])\n    min_col = np.min(coords[:, 1])\n    max_row = np.max(coords[:, 0])\n    max_col = np.max(coords[:, 1])\n\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    return min_row, min_col, max_row, max_col, height, width\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to NumPy array\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # Initialize output grid with background color (white=0)\n    output_array = np.zeros_like(input_array, dtype=int)\n\n    # Find unique colors in the input, excluding background (0) and gray (5)\n    unique_colors = np.unique(input_array)\n    colors_to_process = [c for c in unique_colors if c != 0 and c != 5]\n\n    # Process each relevant color\n    for color in colors_to_process:\n        # Find all coordinates for the current color\n        coords = np.argwhere(input_array == color)\n\n        # Skip if no pixels of this color exist\n        if coords.shape[0] == 0:\n            continue\n\n        # Calculate bounding box and dimensions\n        min_r, min_c, max_r, max_c, height, width = get_bounding_box(coords)\n        coord_set = set(tuple(c) for c in coords) # For efficient checking\n\n        # Check for Pattern 1 (2x2 Diagonal):\n        # Bbox is 2x2, exactly 2 pixels, located at top-left and bottom-right of bbox\n        if height == 2 and width == 2 and len(coord_set) == 2 and \\\n           (min_r, min_c) in coord_set and (max_r, max_c) in coord_set:\n            # Apply the specific 6-pixel transformation for this pattern\n            # Target coordinates relative to top-left (min_r, min_c):\n            target_coords_relative = [(0, 0), (1, 1), (0, 2), (2, 0), (2, 1), (2, 2)]\n            for dr, dc in target_coords_relative:\n                plot_r, plot_c = min_r + dr, min_c + dc\n                # Check grid boundaries before plotting\n                if 0 <= plot_r < rows and 0 <= plot_c < cols:\n                    output_array[plot_r, plot_c] = color\n\n        # Check for Pattern 2 (3x3 Anti-Diagonal):\n        # Bbox is 3x3, exactly 2 pixels, located at top-right and bottom-left of bbox\n        elif height == 3 and width == 3 and len(coord_set) == 2 and \\\n             (min_r, max_c) in coord_set and (max_r, min_c) in coord_set:\n             # Apply the specific 6-pixel transformation for this pattern\n             # Target coordinates are absolute based on bbox corners\n             target_coords_absolute = [\n                 (min_r, min_c), (min_r, max_c), (min_r + 1, min_c + 1),\n                 (max_r, min_c), (max_r, min_c + 1), (max_r, max_c)\n             ]\n             for plot_r, plot_c in target_coords_absolute:\n                  # Check grid boundaries before plotting\n                  if 0 <= plot_r < rows and 0 <= plot_c < cols:\n                      output_array[plot_r, plot_c] = color\n\n        # Check for Pattern 3 (General 3x3):\n        # Bbox is 3x3, but doesn't match the specific anti-diagonal pattern\n        elif height == 3 and width == 3:\n            # Fill the 3x3 bounding box in the output grid\n            output_array[min_r : max_r + 1, min_c : max_c + 1] = color\n\n        # Fallback (Other):\n        # Applies if none of the specific patterns above matched\n        else:\n            # Copy the original object pixels to the output grid\n            for r, c in coords:\n                 output_array[r, c] = color\n\n    # Convert the output NumPy array back to a list of lists\n    output_grid = output_array.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23792,
    "candidates_token_count": 2495,
    "total_token_count": 26287,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.968914,
  "retries": 1
}