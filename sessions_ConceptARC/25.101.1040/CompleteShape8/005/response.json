{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the color and spatial arrangement of its pixels.\n\n1. Initialize a new output grid of the same dimensions as the input grid, filled entirely with the white background color (0).\n2. Identify all unique non-white (0) and non-gray (5) colors present in the input grid.\n3. For each unique non-gray color identified:\n    a. Find the coordinates `C` of all pixels in the input grid that have this color. Let `(min_r, min_c)` be the top-left coordinate and `(max_r, max_c)` be the bottom-right coordinate defining the minimum bounding box `B` enclosing these pixels.\n    b. Calculate the height `H = max_r - min_r + 1` and width `W = max_c - min_c + 1` of the bounding box `B`.\n    c. Case 1 (3x3 Bounding Box): If `H` is 3 and `W` is 3:\n        i. Fill the entire rectangular area defined by the bounding box `B` (from `min_r` to `max_r` and `min_c` to `max_c`) in the output grid with the current color.\n    d. Case 2 (Specific 2x2 Diagonal Pattern): If `H` is 2 and `W` is 2, AND the set of coordinates `C` contains exactly two pixels: the top-left `(min_r, min_c)` and the bottom-right `(max_r, max_c)` of the bounding box:\n        i. Add pixels to the output grid at the following six coordinates, using the current color: `(min_r, min_c)`, `(max_r, max_c)`, `(min_r, max_c + 1)`, `(max_r + 1, min_c)`, `(max_r + 1, min_c + 1)`, `(max_r + 1, max_c + 1)`. (Ensure these coordinates are within the grid boundaries).\n    e. Case 3 (Other): Otherwise (if neither Case 1 nor Case 2 applies):\n        i. For each original pixel coordinate in `C`, set the corresponding pixel in the output grid to the current color.\n4. Return the completed output grid. Gray pixels (5) from the input are implicitly ignored.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\ndef get_bounding_box(coords: np.ndarray) -> Tuple[int, int, int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box and its dimensions for a set of coordinates.\n\n    Args:\n        coords: A NumPy array of shape (N, 2) containing (row, col) coordinates.\n\n    Returns:\n        A tuple containing (min_row, min_col, max_row, max_col, height, width).\n        Returns (-1, -1, -1, -1, 0, 0) if coords is empty.\n    \"\"\"\n    if coords.shape[0] == 0:\n        return -1, -1, -1, -1, 0, 0\n\n    min_row = np.min(coords[:, 0])\n    min_col = np.min(coords[:, 1])\n    max_row = np.max(coords[:, 0])\n    max_col = np.max(coords[:, 1])\n\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    return min_row, min_col, max_row, max_col, height, width\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # Convert input to NumPy array\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # Initialize output grid with background color (white=0)\n    output_array = np.zeros_like(input_array, dtype=int)\n\n    # Find unique colors in the input, excluding background (0) and gray (5)\n    unique_colors = np.unique(input_array)\n    colors_to_process = [c for c in unique_colors if c != 0 and c != 5]\n\n    # Process each relevant color\n    for color in colors_to_process:\n        # Find all coordinates for the current color\n        coords = np.argwhere(input_array == color)\n\n        # If the color exists in the grid\n        if coords.shape[0] > 0:\n            # Calculate bounding box and dimensions\n            min_r, min_c, max_r, max_c, height, width = get_bounding_box(coords)\n\n            # Case 1: Bounding box is exactly 3x3\n            if height == 3 and width == 3:\n                # Fill the 3x3 bounding box in the output grid\n                output_array[min_r:max_r + 1, min_c:max_c + 1] = color\n\n            # Case 2: Specific 2x2 diagonal pattern\n            elif height == 2 and width == 2 and coords.shape[0] == 2:\n                # Check if the only two pixels are top-left and bottom-right of bbox\n                coord_set = set(tuple(c) for c in coords)\n                if (min_r, min_c) in coord_set and (max_r, max_c) in coord_set:\n                     # Define the 6 target coordinates relative to the top-left (min_r, min_c)\n                     # Original TL: (min_r, min_c)\n                     # Original BR: (max_r, max_c) == (min_r+1, min_c+1)\n                     # New positions based on expected output for train_2 orange:\n                     # (2, 1), (3, 2) -> (2, 1), (3, 2), (2, 3), (4, 1), (4, 2), (4, 3)\n                     # Relative to TL (min_r, min_c):\n                     # (0, 0), (1, 1), (0, 2), (2, 0), (2, 1), (2, 2)\n                     target_coords_relative = [\n                         (0, 0), (1, 1), (0, 2), (2, 0), (2, 1), (2, 2)\n                     ]\n                     # Calculate absolute coordinates and plot\n                     for dr, dc in target_coords_relative:\n                         plot_r, plot_c = min_r + dr, min_c + dc\n                         # Check grid boundaries before plotting\n                         if 0 <= plot_r < rows and 0 <= plot_c < cols:\n                             output_array[plot_r, plot_c] = color\n                else:\n                    # If it's 2x2 but not the specific diagonal pattern, copy original pixels (fallback)\n                    for r, c in coords:\n                        output_array[r, c] = color\n            # Case 3: All other cases (not 3x3, not the specific 2x2 diagonal)\n            else:\n                # Copy the original object pixels to the output grid\n                for r, c in coords:\n                    output_array[r, c] = color\n\n    # Convert the output NumPy array back to a list of lists\n    output_grid = output_array.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16747,
    "candidates_token_count": 2311,
    "total_token_count": 19058,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.732387,
  "retries": 1
}