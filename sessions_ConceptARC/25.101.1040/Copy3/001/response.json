{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\n\n\"\"\"\nThis function transforms an input grid based on the presence or absence of magenta pixels (color 6).\n\n1. Checks if magenta (color 6) is present in the input grid.\n\n2. If no magenta is present:\n   - Assumes the grid width `W` is even.\n   - Copies the left half of the grid (columns 0 to W/2 - 1) to the right half (columns W/2 to W - 1), overwriting the original content of the right half.\n   - The left half remains unchanged.\n\n3. If magenta is present:\n   - Identifies connected components of non-white pixels.\n   - Filters these components to find the \"main pattern\" `P`: the component with the largest bounding box area that does *not* contain only magenta pixels.\n   - Identifies magenta pixels/components. Finds the \"marker\" magenta component `M`: the top-most, left-most magenta component whose minimum column index is greater than the maximum column index of the main pattern `P`.\n   - Calculates a destination top-left corner `(dest_row, dest_col)` based on the marker's top-left corner `(row_M, col_M)` using the formula `(row_M + 2, col_M)`.\n   - Copies the content of the bounding box of the main pattern `P` to the calculated destination area in the output grid, overwriting existing content.\n   - All other parts of the grid remain unchanged from the input.\n\"\"\"\n\ndef find_connected_components(grid: list[list[int]], ignore_color: int = 0) -> list[dict]:\n    \"\"\"\n    Finds all connected components in the grid, ignoring a specific color (usually white background).\n\n    Args:\n        grid: The input grid (list of lists of integers).\n        ignore_color: The color value to ignore (treat as background).\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a component and contains:\n        - 'coords': A set of (row, col) tuples belonging to the component.\n        - 'colors': A set of color values present in the component.\n        - 'bounding_box': A tuple (min_row, min_col, max_row, max_col).\n        - 'bounding_box_area': The area of the bounding box.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    components = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] != ignore_color and (r, c) not in visited:\n                component_coords = set()\n                component_colors = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    component_colors.add(grid[row][col])\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr][nc] != ignore_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                bbox = (min_r, min_c, max_r, max_c)\n                bbox_area = (max_r - min_r + 1) * (max_c - min_c + 1)\n                components.append({\n                    'coords': component_coords,\n                    'colors': component_colors,\n                    'bounding_box': bbox,\n                    'bounding_box_area': bbox_area\n                })\n    return components\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on magenta presence.\n\n    Args:\n        input_grid: The input grid (list of lists of integers).\n\n    Returns:\n        The transformed output grid (list of lists of integers).\n    \"\"\"\n    height = len(input_grid)\n    width = len(input_grid[0])\n    output_grid = copy.deepcopy(input_grid)\n    magenta_color = 6\n    white_color = 0\n\n    # Check for magenta presence\n    has_magenta = any(magenta_color in row for row in input_grid)\n\n    if not has_magenta:\n        # Case 1: No magenta - Copy left half to right half\n        if width % 2 == 0: # Ensure width is even as per observation\n            mid_col = width // 2\n            for r in range(height):\n                for c in range(mid_col):\n                    # Copy pixel from left half (r, c) to right half (r, c + mid_col)\n                    output_grid[r][c + mid_col] = input_grid[r][c]\n        # If width is odd and no magenta, the rule is undefined by examples. Return input copy.\n        # Update: Example 2 has odd width *and* magenta. Example 1 has even width *and* no magenta.\n        # Assume the condition is just 'no magenta' leads to mirroring if width is even.\n        # If width is odd and no magenta, based on current examples, do nothing.\n        \n    else:\n        # Case 2: Magenta is present - Find pattern, marker, and copy\n        components = find_connected_components(input_grid, ignore_color=white_color)\n\n        # Identify the main pattern P (largest non-magenta-only component by bbox area)\n        main_pattern = None\n        max_area = -1\n        non_magenta_components = [comp for comp in components if not (comp['colors'] == {magenta_color})]\n        \n        if not non_magenta_components: # Should not happen based on example 2, but handle edge case\n             return output_grid # Or raise error? Return copy for now.\n\n        # Heuristic: Find the component with the largest bounding box area among those not solely magenta\n        for comp in non_magenta_components:\n             if comp['bounding_box_area'] > max_area:\n                 max_area = comp['bounding_box_area']\n                 main_pattern = comp\n             # Tie-breaking: if areas are equal, maybe prefer top-most, then left-most?\n             # For now, first one encountered with max area is chosen.\n             elif comp['bounding_box_area'] == max_area:\n                 if main_pattern is None or comp['bounding_box'][0] < main_pattern['bounding_box'][0] or \\\n                    (comp['bounding_box'][0] == main_pattern['bounding_box'][0] and comp['bounding_box'][1] < main_pattern['bounding_box'][1]):\n                     main_pattern = comp\n\n\n        if not main_pattern:\n            # No suitable pattern found\n            return output_grid \n\n        # Identify magenta components\n        magenta_components = [comp for comp in components if magenta_color in comp['colors']]\n\n        if not magenta_components:\n             # Magenta pixels exist but not forming components? Or logic error.\n             return output_grid # Return copy\n\n        # Identify the marker M (top-most, left-most magenta component starting after pattern P ends horizontally)\n        pattern_min_r, pattern_min_c, pattern_max_r, pattern_max_c = main_pattern['bounding_box']\n        \n        relevant_markers = []\n        for comp in magenta_components:\n            marker_min_r, marker_min_c, _, _ = comp['bounding_box']\n            # Condition: marker starts to the right of the pattern\n            if marker_min_c > pattern_max_c:\n                relevant_markers.append(comp)\n\n        if not relevant_markers:\n            # No marker found to the right of the pattern\n            return output_grid # Return copy\n\n        # Sort relevant markers: primary key = min_row (top-most), secondary key = min_col (left-most)\n        relevant_markers.sort(key=lambda comp: (comp['bounding_box'][0], comp['bounding_box'][1]))\n        \n        marker_component = relevant_markers[0] # Select the top-most, left-most\n        marker_min_r, marker_min_c, _, _ = marker_component['bounding_box']\n\n\n        # Calculate destination top-left corner\n        dest_row_start = marker_min_r + 2\n        dest_col_start = marker_min_c\n\n        # Copy the pattern P's bounding box content to the destination\n        pattern_height = pattern_max_r - pattern_min_r + 1\n        pattern_width = pattern_max_c - pattern_min_c + 1\n\n        for r_offset in range(pattern_height):\n            for c_offset in range(pattern_width):\n                src_r, src_c = pattern_min_r + r_offset, pattern_min_c + c_offset\n                dest_r, dest_c = dest_row_start + r_offset, dest_col_start + c_offset\n\n                # Check if source pixel is part of the actual component (not just bbox)\n                # and destination is within grid bounds\n                # Note: We copy the *entire bounding box content* as per example 2.\n                # If we only wanted to copy the component shape, we'd check `(src_r, src_c) in main_pattern['coords']`\n                if 0 <= dest_r < height and 0 <= dest_c < width:\n                    output_grid[dest_r][dest_c] = input_grid[src_r][src_c]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4508,
    "candidates_token_count": 3390,
    "total_token_count": 7898,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 26.400278,
  "retries": 1
}