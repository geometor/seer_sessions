{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport collections\nimport numpy as np\n\n\"\"\"\nTransforms an input grid based on the presence or absence of magenta pixels (color 6).\n\nTwo distinct rules apply:\n\nRule 1: No Magenta Pixels Present\n  - Assumes the grid width `W` is even.\n  - Identifies all non-white pixels within the left half of the grid (columns 0 to W/2 - 1).\n  - Determines the minimal bounding box enclosing these left-half non-white pixels.\n  - Copies the rectangular region defined by this bounding box from the input grid's left half to the output grid's right half.\n  - The top-left corner of the copied region in the output grid is `(bbox_min_row, W/2)`.\n  - The left half of the grid remains unchanged. The right half is overwritten by the copied region.\n  - If no non-white pixels are found in the left half, or if the width is odd, the grid remains unchanged.\n\nRule 2: Magenta Pixels Present\n  - Finds all distinct non-white connected components in the entire grid.\n  - Identifies the 'main pattern' (P): The non-magenta-only component with the largest bounding box area (ties broken by top-most, then left-most).\n  - Identifies the 'marker' (M): The magenta-containing component whose top-left corner's column is greater than the main pattern's rightmost column. Among candidates, selects the one with the minimum row, then minimum column (top-most, left-most).\n  - Calculates a destination top-left corner based on the marker's position: `(marker_min_row + 2, marker_min_col)`.\n  - Copies the entire rectangular region defined by the main pattern's (P) bounding box from the input grid to the calculated destination area in the output grid.\n  - All other parts of the grid (outside the destination copy area) remain unchanged from the input.\n  - If either the main pattern (P) or the marker (M) cannot be identified according to the rules, the grid remains unchanged.\n\"\"\"\n\ndef find_connected_components(grid: list[list[int]], ignore_color: int = 0, bounds: tuple = None) -> list[dict]:\n    \"\"\"\n    Finds all connected components in the grid or within specified bounds, ignoring a specific color.\n    Uses 4-connectivity (horizontal/vertical).\n\n    Args:\n        grid: The input grid (list of lists of integers).\n        ignore_color: The color value to ignore (treat as background).\n        bounds: Optional tuple (min_r, min_c, max_r, max_c) defining the search area.\n                Components must start within bounds and only connected pixels within bounds are included.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a component.\n    \"\"\"\n    grid_np = np.array(grid)\n    height, width = grid_np.shape\n    \n    if bounds:\n        min_r_bound, min_c_bound, max_r_bound, max_c_bound = bounds\n        min_r_bound = max(0, min_r_bound)\n        min_c_bound = max(0, min_c_bound)\n        max_r_bound = min(height - 1, max_r_bound)\n        max_c_bound = min(width - 1, max_c_bound)\n    else:\n        min_r_bound, min_c_bound = 0, 0\n        max_r_bound, max_c_bound = height - 1, width - 1\n\n    visited = set()\n    components = []\n    component_id_counter = 0\n\n    for r in range(min_r_bound, max_r_bound + 1):\n        for c in range(min_c_bound, max_c_bound + 1):\n            if grid_np[r, c] != ignore_color and (r, c) not in visited:\n                component_id_counter += 1\n                component_coords = set()\n                component_colors = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    # Use item() to get native Python int if necessary, though sets handle numpy ints fine\n                    component_colors.add(grid_np[row, col].item()) \n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if min_r_bound <= nr <= max_r_bound and min_c_bound <= nc <= max_c_bound and \\\n                           grid_np[nr, nc] != ignore_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                if component_coords:\n                    bbox = (min_r, min_c, max_r, max_c)\n                    bbox_area = (max_r - min_r + 1) * (max_c - min_c + 1)\n                    components.append({\n                        'id': component_id_counter,\n                        'coords': component_coords,\n                        'colors': component_colors,\n                        'bounding_box': bbox,\n                        'bounding_box_area': bbox_area,\n                        'pixel_count': len(component_coords)\n                    })\n    return components\n\ndef get_bounding_box_of_pixels(pixels: set, grid_shape: tuple) -> tuple | None:\n    \"\"\"\n    Calculates the minimal bounding box enclosing a set of pixel coordinates.\n\n    Args:\n        pixels: A set of (row, col) tuples.\n        grid_shape: A tuple (height, width) for boundary checks (though pixels should be valid).\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col) or None if the set is empty.\n    \"\"\"\n    if not pixels:\n        return None\n    min_r = grid_shape[0]\n    min_c = grid_shape[1]\n    max_r = -1\n    max_c = -1\n    for r, c in pixels:\n        min_r = min(min_r, r)\n        min_c = min(min_c, c)\n        max_r = max(max_r, r)\n        max_c = max(max_c, c)\n    # Ensure valid bounds if only one pixel or a line exists\n    if max_r == -1: # Should not happen if pixels is not empty, but safe check\n        return None\n    return (min_r, min_c, max_r, max_c)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules based on magenta presence.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    grid_np = np.array(input_grid)\n    height, width = grid_np.shape\n    magenta_color = 6\n    white_color = 0\n\n    # Check for magenta presence\n    has_magenta = np.any(grid_np == magenta_color)\n\n    if not has_magenta:\n        # --- Rule 1: No Magenta ---\n        # Check if width is even (rule assumption)\n        if width % 2 == 0:\n            mid_col = width // 2\n            \n            # Find all non-white pixels in the left half\n            left_half_pixels = set()\n            for r in range(height):\n                for c in range(mid_col):\n                    if grid_np[r, c] != white_color:\n                        left_half_pixels.add((r, c))\n\n            # If non-white pixels exist, find their bounding box\n            if left_half_pixels:\n                source_bbox = get_bounding_box_of_pixels(left_half_pixels, (height, width))\n                \n                if source_bbox:\n                    bbox_min_r, bbox_min_c, bbox_max_r, bbox_max_c = source_bbox\n                    dest_start_col = mid_col\n\n                    # Copy the region defined by the bounding box\n                    for r_offset in range(bbox_max_r - bbox_min_r + 1):\n                        for c_offset in range(bbox_max_c - bbox_min_c + 1):\n                            src_r = bbox_min_r + r_offset\n                            src_c = bbox_min_c + c_offset\n                            \n                            # Ensure source coords are valid and within the left half\n                            if 0 <= src_r < height and 0 <= src_c < mid_col: \n                                dest_r = src_r  # Destination row is the same as source row\n                                dest_c = dest_start_col + c_offset # Destination col starts at mid_col\n\n                                # Check destination bounds before writing\n                                if 0 <= dest_r < height and 0 <= dest_c < width:\n                                    output_grid[dest_r][dest_c] = input_grid[src_r][src_c]\n        # Implicit: If width is odd and no magenta, return the initial copy.\n\n    else:\n        # --- Rule 2: Magenta Present ---\n        # Find all components in the entire grid\n        all_components = find_connected_components(input_grid, ignore_color=white_color)\n\n        # Identify the main pattern (P)\n        main_pattern = None\n        non_magenta_only_components = [\n            comp for comp in all_components if not (comp['colors'] == {magenta_color})\n        ]\n        if non_magenta_only_components:\n            non_magenta_only_components.sort(key=lambda c: (-c['bounding_box_area'], c['bounding_box'][0], c['bounding_box'][1]))\n            main_pattern = non_magenta_only_components[0]\n\n        # Identify the marker (M)\n        marker = None\n        magenta_components = [\n            comp for comp in all_components if magenta_color in comp['colors']\n        ]\n        if main_pattern and magenta_components:\n            pattern_max_c = main_pattern['bounding_box'][3]\n            relevant_markers = [\n                m for m in magenta_components if m['bounding_box'][1] > pattern_max_c\n            ]\n            if relevant_markers:\n                relevant_markers.sort(key=lambda c: (c['bounding_box'][0], c['bounding_box'][1]))\n                marker = relevant_markers[0]\n\n        # Perform the copy if both pattern and marker were found\n        if main_pattern and marker:\n            pattern_min_r, pattern_min_c, pattern_max_r, pattern_max_c = main_pattern['bounding_box']\n            marker_min_r, marker_min_c, _, _ = marker['bounding_box']\n\n            dest_row_start = marker_min_r + 2\n            dest_col_start = marker_min_c\n\n            pattern_height = pattern_max_r - pattern_min_r + 1\n            pattern_width = pattern_max_c - pattern_min_c + 1\n\n            for r_offset in range(pattern_height):\n                for c_offset in range(pattern_width):\n                    src_r = pattern_min_r + r_offset\n                    src_c = pattern_min_c + c_offset\n                    dest_r = dest_row_start + r_offset\n                    dest_c = dest_col_start + c_offset\n\n                    if 0 <= dest_r < height and 0 <= dest_c < width:\n                        # Source coords should be valid if bbox is correct\n                         if 0 <= src_r < height and 0 <= src_c < width:\n                             output_grid[dest_r][dest_c] = input_grid[src_r][src_c]\n\n    # Return the potentially modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 30069,
    "candidates_token_count": 3514,
    "total_token_count": 33583,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.553358,
  "retries": 1
}