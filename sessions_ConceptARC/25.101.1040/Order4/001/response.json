{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies vertical blocks of non-background colors separated by background (0) columns.\nFor each block, it determines the primary color (MainColor, not 0 or 5) and an impurity color (ImpurityColor, either 0 or 5).\nBased on the ImpurityColor, a specific color transformation map is applied to the MainColor to determine the OutputColor.\nThe output grid is created by filling the spatial extent (min/max rows and columns) of each input block with its corresponding OutputColor.\n\"\"\"\n\ndef find_blocks(grid: np.ndarray) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Identifies the bounding boxes (min_row, max_row, col_start, col_end) of vertical blocks.\n    Blocks are regions containing non-background pixels, separated by columns of only background pixels.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        A list of tuples, where each tuple represents a block's bounding box:\n        (min_row, max_row, col_start, col_end).\n    \"\"\"\n    rows, cols = grid.shape\n    non_bg_cols = np.any(grid != 0, axis=0)\n    blocks = []\n    \n    col_start = -1\n    for c in range(cols):\n        if non_bg_cols[c] and col_start == -1:\n            # Start of a potential block\n            col_start = c\n        elif not non_bg_cols[c] and col_start != -1:\n            # End of the block\n            col_end = c # Exclusive end index initially\n            \n            # Find min/max rows for this block\n            block_cols_grid = grid[:, col_start:col_end]\n            non_bg_rows_in_block = np.where(np.any(block_cols_grid != 0, axis=1))[0]\n            \n            if len(non_bg_rows_in_block) > 0:\n                min_row = non_bg_rows_in_block.min()\n                max_row = non_bg_rows_in_block.max()\n                blocks.append((min_row, max_row, col_start, col_end - 1)) # Inclusive col_end\n                \n            col_start = -1 # Reset for the next block\n            \n    # Handle block extending to the last column\n    if col_start != -1:\n        col_end = cols # Exclusive end index\n        block_cols_grid = grid[:, col_start:col_end]\n        non_bg_rows_in_block = np.where(np.any(block_cols_grid != 0, axis=1))[0]\n        if len(non_bg_rows_in_block) > 0:\n             min_row = non_bg_rows_in_block.min()\n             max_row = non_bg_rows_in_block.max()\n             blocks.append((min_row, max_row, col_start, col_end - 1)) # Inclusive col_end\n\n    return blocks\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by identifying colored blocks, determining their\n    main and impurity colors, applying a color transformation rule based on the\n    impurity, and filling the block area in the output grid with the new color.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    \n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_np = np.zeros_like(input_np)\n\n    # Define the color transformation maps\n    map_impurity_5 = {1: 4, 2: 2, 3: 1, 4: 3} # {Blue: Yellow, Red: Red, Green: Blue, Yellow: Green}\n    map_impurity_0 = {2: 7, 4: 6, 6: 2, 7: 4} # {Red: Orange, Yellow: Magenta, Magenta: Red, Orange: Yellow}\n\n    # Find all blocks in the input grid\n    blocks = find_blocks(input_np)\n\n    # Process each block\n    for min_row, max_row, col_start, col_end in blocks:\n        # Extract the relevant subgrid for analysis (includes potential impurity 0)\n        block_subgrid = input_np[min_row:max_row+1, col_start:col_end+1]\n        \n        # Find unique colors within the block's bounding box\n        unique_colors = np.unique(block_subgrid)\n        \n        # Determine MainColor and ImpurityColor\n        main_color = -1\n        impurity_color = -1\n        \n        # Check for impurity 5 first\n        if 5 in unique_colors:\n            impurity_color = 5\n            # Find the main color (not 0 and not 5)\n            for color in unique_colors:\n                if color != 0 and color != 5:\n                    main_color = color\n                    break\n        # If impurity is not 5, check if impurity is 0 (within the block bounds)\n        elif 0 in unique_colors:\n             impurity_color = 0\n             # Find the main color (the only non-zero color)\n             for color in unique_colors:\n                if color != 0:\n                    main_color = color\n                    break\n        else:\n            # Should not happen based on examples, but handle defensively\n            # If only one non-zero color and it's not 5, treat it as main\n             for color in unique_colors:\n                if color != 0:\n                    main_color = color\n                    break\n            # This case might need refinement if new examples appear\n\n        # Determine the OutputColor using the appropriate map\n        output_color = -1 # Default/error value\n        if impurity_color == 5 and main_color in map_impurity_5:\n            output_color = map_impurity_5[main_color]\n        elif impurity_color == 0 and main_color in map_impurity_0:\n            output_color = map_impurity_0[main_color]\n        elif impurity_color == -1 and main_color != -1:\n             # Fallback if no impurity detected but a main color exists\n             # (e.g., a solid block of a single color other than 5)\n             # Based on example 1 (red block), it seems the color remains unchanged if impurity 5 isn't present.\n             # Let's assume the map_impurity_5 is the default or applies if only one color is present?\n             # Example 1's red block (2) becomes red (2) -> Consistent with map_impurity_5.\n             # Let's apply map_impurity_5 as default if no impurity 0 is found.\n             if main_color in map_impurity_5:\n                 output_color = map_impurity_5[main_color]\n             else:\n                 # If not in map_impurity_5 either, maybe it stays the same?\n                 output_color = main_color # Best guess\n\n\n        # Fill the corresponding area in the output grid\n        if output_color != -1:\n             output_np[min_row:max_row+1, col_start:col_end+1] = output_color\n        else:\n             # If we couldn't determine an output color, copy the original block? Or leave as bg?\n             # Leaving as background (initial state) seems safer.\n             print(f\"Warning: Could not determine output color for block at rows {min_row}-{max_row}, cols {col_start}-{col_end}\")\n\n\n    # Convert the NumPy array back to a list of lists\n    output_grid = output_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3085,
    "candidates_token_count": 2595,
    "total_token_count": 5680,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.48863,
  "retries": 1
}