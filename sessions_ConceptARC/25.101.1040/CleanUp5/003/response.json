{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nTransforms an input grid based on the number and values of distinct non-white colors present.\n\nTransformation Rules:\n\n1.  **Analyze Input Colors**: Identify all distinct non-white (non-zero) colors in the input grid.\n2.  **Count Distinct Colors**: Let the number of distinct non-white colors be `N`.\n3.  **Apply Conditional Rules**:\n    *   **If `N > 1` (Multiple distinct non-white colors):**\n        *   Find the non-white color with the highest numerical value.\n        *   Remove all pixels of this highest color by changing them to white (0).\n    *   **If `N == 1` (Single distinct non-white color):**\n        *   Let the single non-white color be `C`.\n        *   Find all connected components (using 8-way adjacency) formed by pixels of color `C`.\n        *   Identify pixels to remove based on component properties:\n            *   Remove all pixels belonging to components of size 1 (isolated pixels).\n            *   For components consisting of exactly two pixels arranged horizontally, remove the leftmost pixel.\n        *   Keep all other pixels of color `C`.\n    *   **If `N == 0` (No non-white colors):**\n        *   The grid remains unchanged (all white).\n\"\"\"\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the number and values of non-white colors.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Create a copy to modify for the output\n    output_array = np.copy(input_array)\n\n    # Find unique non-zero colors in the grid\n    non_zero_colors = np.unique(input_array[input_array != 0])\n    num_distinct_colors = len(non_zero_colors)\n\n    # --- Apply transformation based on the number of distinct non-white colors ---\n\n    if num_distinct_colors > 1:\n        # Case 1: More than one non-white color present\n        # Find the maximum color value among the non-zero colors\n        max_color = np.max(non_zero_colors)\n        # Set all pixels with the maximum color to 0 (white) in the output array\n        output_array[output_array == max_color] = 0\n\n    elif num_distinct_colors == 1:\n        # Case 2: Exactly one non-white color present\n        single_color = non_zero_colors[0]\n\n        # Create a boolean mask where the grid matches the single color\n        mask = input_array == single_color\n\n        # Define the connectivity structure for finding components (8-way adjacency)\n        # This means pixels are considered connected if they touch at sides or corners\n        structure = np.array([[1, 1, 1],\n                              [1, 1, 1],\n                              [1, 1, 1]], dtype=bool)\n\n        # Find connected components in the boolean mask\n        # labeled_array assigns a unique integer label to each component\n        # num_features gives the total number of components found (excluding background)\n        labeled_array, num_features = label(mask, structure=structure)\n\n        # Keep track of pixel coordinates that need to be removed (set to white)\n        pixels_to_remove = set()\n\n        # Iterate through each component found (labels are 1-based)\n        for i in range(1, num_features + 1):\n            # Get the coordinates (row, column) of all pixels belonging to the current component\n            component_coords = np.argwhere(labeled_array == i)\n            component_size = len(component_coords)\n\n            if component_size == 1:\n                # Rule: Remove components of size 1 (isolated pixels)\n                # Get the single coordinate and add it to the removal set\n                pixel_coord = tuple(component_coords[0])\n                pixels_to_remove.add(pixel_coord)\n\n            elif component_size == 2:\n                # Rule: For components of size 2, check if they form a horizontal line\n                p1 = component_coords[0] # Coordinates of the first pixel\n                p2 = component_coords[1] # Coordinates of the second pixel\n\n                # Check if rows are the same and columns differ by exactly 1\n                if p1[0] == p2[0] and abs(p1[1] - p2[1]) == 1:\n                    # This is a horizontal line of size 2\n                    # Find the leftmost pixel (the one with the smaller column index)\n                    leftmost_pixel_coord = tuple(p1) if p1[1] < p2[1] else tuple(p2)\n                    # Add the leftmost pixel to the removal set\n                    pixels_to_remove.add(leftmost_pixel_coord)\n\n                # Note: Based on examples, vertical lines of size 2 or other size 2 configurations\n                # are not explicitly targeted for removal.\n\n        # Apply the removals: Iterate through the collected coordinates and set them to white\n        for r, c in pixels_to_remove:\n            output_array[r, c] = 0\n\n    # Case 3 (Implicit): If num_distinct_colors is 0, the output_array (a copy of input)\n    # is already all white (or contains only 0s), so no changes are needed.\n\n    # Convert the final NumPy array back to a list of lists format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19398,
    "candidates_token_count": 1710,
    "total_token_count": 21108,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 11.759929,
  "retries": 1
}