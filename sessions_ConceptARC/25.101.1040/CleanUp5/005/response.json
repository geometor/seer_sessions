{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nTransforms an input grid based on the number and values of distinct non-white colors present.\n\nTransformation Rules:\n\n1.  **Analyze Input Colors**: Identify all distinct non-white (non-zero) colors in the input grid. Count the number of distinct non-white colors, `N`.\n2.  **Conditional Transformation**: Apply rules based on the value of `N`:\n    *   **If `N` equals 1 (Single Non-White Color `C`):**\n        1.  Find all connected components (8-way adjacency) of color `C`.\n        2.  Identify pixels to change:\n            *   Any pixel belonging to a component containing only 1 pixel (an isolated pixel).\n            *   The pixel with the smaller column index (leftmost) in any component consisting of exactly two pixels positioned horizontally adjacent to each other.\n        3.  Change the color of all identified pixels to white (0). Other pixels remain unchanged.\n    *   **If `N` is greater than 1 (Multiple Non-White Colors):**\n        1.  Identify the non-white color with the highest numerical value (`C_max`) and the non-white color with the second-highest numerical value (`C_next`).\n        2.  Examine each pixel `p` at location `(r, c)` that has the color `C_max`.\n        3.  Determine the final color for pixel `p` based on these conditions:\n            *   Check if the pixel's row index `r` is exactly 3.\n            *   Check if the pixel `p` is \"isolated\" with respect to `C_max` (none of its 8 neighbors have color `C_max`).\n            *   Check if the pixel `p` is part of a \"horizontal pair\" with respect to `C_max` (exactly one of its horizontal neighbors, `(r, c-1)` or `(r, c+1)`, has color `C_max`, and no other neighbors have color `C_max`).\n            *   **If** the pixel is on row 3 **AND** (it is isolated **OR** it is part of a horizontal pair), then change the color of this pixel to `C_next`.\n            *   **Else**, change the color of this pixel to white (0).\n        4.  Pixels that *do not* have the color `C_max` retain their original color.\n    *   **If `N` equals 0 (No Non-White Colors):**\n        1.  The output grid is identical to the input grid.\n\"\"\"\n\n\ndef _get_neighbor_coords(r, c, height, width):\n    \"\"\"Generates valid 8-way neighbor coordinates.\"\"\"\n    coords = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                coords.append((nr, nc))\n    return coords\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the rules described above.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n    # Create a copy to modify for the output\n    output_array = np.copy(input_array)\n\n    # Find unique non-zero colors in the grid\n    non_zero_colors = sorted(np.unique(input_array[input_array != 0]), reverse=True) # Sort descending\n    num_distinct_colors = len(non_zero_colors)\n\n    # --- Apply transformation based on the number of distinct non-white colors ---\n\n    if num_distinct_colors == 0:\n        # Case 0: No non-white colors, return input as is\n        pass # Output array is already a copy\n\n    elif num_distinct_colors == 1:\n        # Case 1: Exactly one non-white color present\n        single_color = non_zero_colors[0]\n\n        # Create a boolean mask where the grid matches the single color\n        mask = input_array == single_color\n\n        # Define the connectivity structure for finding components (8-way adjacency)\n        structure = np.array([[1, 1, 1],\n                              [1, 1, 1],\n                              [1, 1, 1]], dtype=bool)\n\n        # Find connected components in the boolean mask\n        labeled_array, num_features = label(mask, structure=structure)\n\n        # Keep track of pixel coordinates that need to be removed (set to white)\n        pixels_to_remove = set()\n\n        # Iterate through each component found (labels are 1-based)\n        for i in range(1, num_features + 1):\n            # Get the coordinates (row, column) of all pixels belonging to the current component\n            component_coords = np.argwhere(labeled_array == i)\n            component_size = len(component_coords)\n\n            if component_size == 1:\n                # Rule: Remove components of size 1 (isolated pixels)\n                pixel_coord = tuple(component_coords[0])\n                pixels_to_remove.add(pixel_coord)\n\n            elif component_size == 2:\n                # Rule: For components of size 2, check if they form a horizontal line\n                p1 = component_coords[0] # Coordinates of the first pixel\n                p2 = component_coords[1] # Coordinates of the second pixel\n\n                # Check if rows are the same and columns differ by exactly 1\n                if p1[0] == p2[0] and abs(p1[1] - p2[1]) == 1:\n                    # This is a horizontal line of size 2\n                    # Find the leftmost pixel (the one with the smaller column index)\n                    leftmost_pixel_coord = tuple(p1) if p1[1] < p2[1] else tuple(p2)\n                    # Add the leftmost pixel to the removal set\n                    pixels_to_remove.add(leftmost_pixel_coord)\n\n        # Apply the removals: Iterate through the collected coordinates and set them to white\n        for r, c in pixels_to_remove:\n            output_array[r, c] = 0\n\n    elif num_distinct_colors > 1:\n        # Case 2: More than one non-white color present\n        c_max = non_zero_colors[0]  # Highest color value\n        c_next = non_zero_colors[1] # Second highest color value\n\n        # Iterate through each pixel potentially affected (only C_max pixels)\n        for r in range(height):\n            for c in range(width):\n                if input_array[r, c] == c_max:\n                    # This pixel has the max color, determine its fate\n                    \n                    # Check neighbors for C_max\n                    cmax_neighbors = 0\n                    cmax_horizontal_neighbors = 0\n                    neighbor_coords = _get_neighbor_coords(r, c, height, width)\n\n                    for nr, nc in neighbor_coords:\n                        if input_array[nr, nc] == c_max:\n                            cmax_neighbors += 1\n                            # Check if it's a horizontal neighbor\n                            if nr == r and abs(nc - c) == 1:\n                                cmax_horizontal_neighbors += 1\n\n                    # Determine conditions\n                    is_isolated = (cmax_neighbors == 0)\n                    # Check if it's a horizontal pair element (exactly one horizontal neighbor, and no others)\n                    is_horizontal_pair_element = (cmax_neighbors == 1 and cmax_horizontal_neighbors == 1)\n\n                    # Apply the specific rule for row 3\n                    if r == 3 and (is_isolated or is_horizontal_pair_element):\n                        output_array[r, c] = c_next # Change to second highest color\n                    else:\n                        output_array[r, c] = 0 # Change to white\n\n    # Convert the final NumPy array back to a list of lists format\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 30463,
    "candidates_token_count": 2582,
    "total_token_count": 33045,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.134714,
  "retries": 1
}