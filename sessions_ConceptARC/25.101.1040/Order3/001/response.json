{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1. Identify vertical separator columns composed entirely of the background color (0).\n2. Define blocks as the vertical segments between these separators.\n3. If there are fewer than two blocks, return the input unchanged.\n4. Within the first and last blocks, identify the majority (M) and minority (m) non-background colors.\n5. Extract the relative coordinates (row, col_within_block) of the minority color pixels within the first block (Pattern_First).\n6. Extract the relative coordinates of the minority color pixels within the last block (Pattern_Last).\n7. Create a copy of the input grid.\n8. Modify the first block in the copy:\n    - Change pixels at original minority locations (Pattern_First) to the majority color (M).\n    - Change pixels at locations corresponding to Pattern_Last to the minority color (m).\n9. Modify the last block in the copy:\n    - Change pixels at original minority locations (Pattern_Last) to the majority color (M).\n    - Change pixels at locations corresponding to Pattern_First to the minority color (m).\n10. Return the modified grid.\n\nThis rule is derived primarily from train_2 and might not perfectly match train_1.\n\"\"\"\n\ndef find_separator_columns(grid: list[list[int]], background_color: int = 0) -> list[int]:\n    \"\"\"Finds columns composed entirely of the background color.\"\"\"\n    if not grid:\n        return []\n    height = len(grid)\n    width = len(grid[0])\n    separator_cols = []\n    for c in range(width):\n        is_separator = True\n        for r in range(height):\n            if grid[r][c] != background_color:\n                is_separator = False\n                break\n        if is_separator:\n            separator_cols.append(c)\n    return separator_cols\n\ndef define_blocks(separator_cols: list[int], width: int) -> list[tuple[int, int]]:\n    \"\"\"Defines block boundaries (start_col, end_col_exclusive) based on separators.\"\"\"\n    blocks = []\n    start_col = 0\n    for sep_col in separator_cols:\n        # If there's content before the separator\n        if sep_col > start_col:\n            blocks.append((start_col, sep_col))\n        start_col = sep_col + 1\n    # Check for content after the last separator\n    if start_col < width:\n        blocks.append((start_col, width))\n\n    # Adjust for grids starting/ending with separators\n    filtered_blocks = []\n    if blocks:\n        # Remove block definition starting at col 0 if col 0 is a separator\n        if separator_cols and separator_cols[0] == 0 and blocks[0][0] == 0:\n             pass # block implicitly starts after separator\n        else:\n             # Check if first block actually starts *at* col 0 if col 0 isn't separator\n             first_block_start = 0\n             if separator_cols and separator_cols[0] > 0:\n                 first_block_start = 0 # Content before first separator\n             elif not separator_cols and width > 0:\n                 first_block_start = 0 # No separators, one block\n\n        current_start = first_block_start\n        for sep_col in separator_cols:\n            if sep_col > current_start:\n                 filtered_blocks.append((current_start, sep_col))\n            current_start = sep_col + 1\n\n        if current_start < width:\n             filtered_blocks.append((current_start, width))\n\n\n    return filtered_blocks\n\n\ndef get_block_colors(grid: list[list[int]], block_bounds: tuple[int, int], background_color: int = 0) -> tuple[int | None, int | None]:\n    \"\"\"Identifies the majority and minority non-background colors in a block.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(grid)\n    colors = []\n    for r in range(height):\n        for c in range(start_col, end_col):\n            if grid[r][c] != background_color:\n                colors.append(grid[r][c])\n\n    if not colors:\n        return None, None # No non-background colors\n\n    counts = Counter(colors)\n    if len(counts) == 1:\n        # Only one non-background color, consider it the majority\n        majority_color = list(counts.keys())[0]\n        minority_color = None # Or potentially the same? Task examples suggest 2 distinct colors.\n                              # Let's stick to None if only one is present.\n    elif len(counts) >= 2:\n        # Find the two most common (or only two if exactly two)\n        sorted_colors = counts.most_common()\n        majority_color = sorted_colors[0][0]\n        minority_color = sorted_colors[1][0]\n        # Handle potential ties for minority if more than 2 colors exist - assumes minority is the second most frequent\n    else: # Should not happen if colors list is not empty\n         majority_color = None\n         minority_color = None\n\n    return majority_color, minority_color\n\n\ndef extract_minority_pattern(grid: list[list[int]], block_bounds: tuple[int, int], minority_color: int) -> list[tuple[int, int]]:\n    \"\"\"Extracts relative coordinates (row, col_in_block) of the minority color.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(grid)\n    pattern = []\n    if minority_color is None: # Handle cases where a block might not have a defined minority color\n        return []\n    for r in range(height):\n        for c in range(start_col, end_col):\n            if grid[r][c] == minority_color:\n                pattern.append((r, c - start_col))\n    return pattern\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies blocks separated by background color columns, then swaps the\n    pattern of 'minority' color pixels between the first and last blocks.\n    \"\"\"\n    # Make a deep copy to avoid modifying the original input\n    output_grid = copy.deepcopy(input_grid)\n    if not input_grid or not input_grid[0]:\n        return output_grid # Handle empty grid case\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0 # Assuming white is always background\n\n    # 1. Identify Background and Separators\n    separator_cols = find_separator_columns(input_grid, background_color)\n\n    # 2. Define Blocks\n    blocks = define_blocks(separator_cols, width)\n\n    # 3. Handle Edge Cases (fewer than 2 blocks)\n    if len(blocks) < 2:\n        return output_grid # Return original grid if less than 2 blocks\n\n    # 4. Identify Colors and Patterns for first and last blocks\n    first_block_bounds = blocks[0]\n    last_block_bounds = blocks[-1]\n\n    # Determine colors based on the first block (assuming consistency)\n    # Need robust way if first block has only one color or is empty\n    majority_color, minority_color = get_block_colors(input_grid, first_block_bounds, background_color)\n\n    # If colors couldn't be determined (e.g., empty block), try last block\n    if majority_color is None or minority_color is None:\n         maj_last, min_last = get_block_colors(input_grid, last_block_bounds, background_color)\n         # Prioritize using colors if found in either block\n         if majority_color is None: majority_color = maj_last\n         if minority_color is None: minority_color = min_last\n\n    # If still no minority color identified (e.g., both blocks have only one color type), cannot perform swap\n    if minority_color is None or majority_color is None:\n         # print(\"Warning: Could not definitively identify majority/minority colors for swapping.\")\n         return output_grid # Or return original? Returning original seems safer.\n\n\n    pattern_first = extract_minority_pattern(input_grid, first_block_bounds, minority_color)\n    pattern_last = extract_minority_pattern(input_grid, last_block_bounds, minority_color)\n\n    # 5. Perform Swap\n    first_block_start_col = first_block_bounds[0]\n    last_block_start_col = last_block_bounds[0]\n\n    # 5.b Update the first block (B1)\n    # 5.b.i Change original minority pixels to majority\n    for r, c_rel in pattern_first:\n        abs_c = first_block_start_col + c_rel\n        if 0 <= r < height and first_block_bounds[0] <= abs_c < first_block_bounds[1]:\n             # Check if the pixel was indeed minority before changing\n             if output_grid[r][abs_c] == minority_color:\n                 output_grid[r][abs_c] = majority_color\n\n    # 5.b.ii Change pixels according to last block's pattern to minority\n    for r, c_rel in pattern_last:\n        abs_c = first_block_start_col + c_rel\n        # Ensure the target pixel is within grid bounds and the first block's column range\n        # Also ensure we are not overwriting background/separator pixels\n        if 0 <= r < height and first_block_bounds[0] <= abs_c < first_block_bounds[1]:\n            if input_grid[r][abs_c] != background_color: # Check original input grid color\n                 output_grid[r][abs_c] = minority_color\n\n    # 5.c Update the last block (Bn)\n    # 5.c.i Change original minority pixels to majority\n    for r, c_rel in pattern_last:\n        abs_c = last_block_start_col + c_rel\n        if 0 <= r < height and last_block_bounds[0] <= abs_c < last_block_bounds[1]:\n            if output_grid[r][abs_c] == minority_color:\n                 output_grid[r][abs_c] = majority_color\n\n    # 5.c.ii Change pixels according to first block's pattern to minority\n    for r, c_rel in pattern_first:\n        abs_c = last_block_start_col + c_rel\n        if 0 <= r < height and last_block_bounds[0] <= abs_c < last_block_bounds[1]:\n             if input_grid[r][abs_c] != background_color: # Check original input grid color\n                output_grid[r][abs_c] = minority_color\n\n    # 6. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3122,
    "candidates_token_count": 3302,
    "total_token_count": 6424,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 25.797717,
  "retries": 1
}