{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify vertical separator columns composed entirely of the background color (white/0).\n2.  Define blocks as the contiguous vertical segments between separators (or grid edges). Let N be the number of blocks.\n3.  If N < 2, return the input grid unchanged.\n4.  Determine the majority color (M) and minority color (m) present in the non-background areas (assume consistency). If M or m cannot be found, return the input grid unchanged.\n5.  Extract the relative minority pattern P[i] = {(row, col_relative)} for each block i (0-indexed) from the input grid.\n6.  Determine the target output pattern for each block based on the parity of N:\n    *   If N is ODD:\n        *   Block 0 gets the pattern from input Block N-1, with relative columns shifted left by 1 (min 0).\n        *   Blocks 1 to N-2 get the pattern from input Block i (unchanged).\n        *   Block N-1 gets the pattern from input Block 0.\n    *   If N is EVEN:\n        *   Block 0 gets the pattern from input Block N-2, with relative columns shifted left by 1 (min 0).\n        *   Blocks 1 to N-2 get the pattern from input Block i-1 (pattern shifts right).\n        *   Block N-1 gets the pattern from input Block N-1 (unchanged).\n7.  Create a copy of the input grid as the output grid.\n8.  For each block j in the output grid:\n    *   Iterate through its cells (r, c).\n    *   If the cell is not background color:\n        *   Calculate the relative column `c_rel`.\n        *   Check if `(r, c_rel)` exists in the target pattern determined in step 6 for block j.\n        *   If yes, set the output cell color to `m`.\n        *   If no, set the output cell color to `M`.\n9.  Return the modified output grid.\n\"\"\"\n\ndef find_separator_columns(grid: list[list[int]], background_color: int = 0) -> list[int]:\n    \"\"\"Finds columns composed entirely of the background color.\"\"\"\n    if not grid or not grid[0]:\n        return []\n    height = len(grid)\n    width = len(grid[0])\n    separator_cols = []\n    for c in range(width):\n        is_separator = True\n        for r in range(height):\n            if grid[r][c] != background_color:\n                is_separator = False\n                break\n        if is_separator:\n            separator_cols.append(c)\n    return separator_cols\n\ndef define_blocks(separator_cols: list[int], width: int) -> list[tuple[int, int]]:\n    \"\"\"Defines block boundaries (start_col, end_col_exclusive) based on separators.\"\"\"\n    blocks = []\n    start_col = 0\n    for sep_col in separator_cols:\n        if sep_col > start_col:\n            blocks.append((start_col, sep_col))\n        start_col = sep_col + 1\n    if start_col < width:\n        blocks.append((start_col, width))\n    return blocks\n\ndef get_majority_minority_colors(grid: list[list[int]], blocks: list[tuple[int, int]], background_color: int = 0) -> tuple[int | None, int | None]:\n    \"\"\"Identifies the majority and minority non-background colors across all blocks.\"\"\"\n    colors = []\n    height = len(grid)\n    for start_col, end_col in blocks:\n        for r in range(height):\n            for c in range(start_col, end_col):\n                if grid[r][c] != background_color:\n                    colors.append(grid[r][c])\n\n    if not colors:\n        return None, None\n\n    counts = Counter(colors)\n    sorted_colors = counts.most_common()\n\n    if len(sorted_colors) >= 2:\n        majority_color = sorted_colors[0][0]\n        minority_color = sorted_colors[1][0]\n        # Ensure minority is actually less frequent than majority\n        if counts[minority_color] > counts[majority_color]:\n             majority_color, minority_color = minority_color, majority_color\n        elif counts[minority_color] == counts[majority_color]:\n             # Tie-breaking: arbitrary but consistent? Or error?\n             # Let's assume the task guarantees distinct counts or the first one is M.\n             pass\n\n    elif len(sorted_colors) == 1:\n        majority_color = sorted_colors[0][0]\n        minority_color = None # Cannot perform swap without a minority color\n    else:\n        majority_color = None\n        minority_color = None\n\n    return majority_color, minority_color\n\n\ndef extract_minority_pattern(grid: list[list[int]], block_bounds: tuple[int, int], minority_color: int) -> set[tuple[int, int]]:\n    \"\"\"Extracts relative coordinates (row, col_in_block) of the minority color as a set.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(grid)\n    pattern = set()\n    if minority_color is None:\n        return pattern\n    for r in range(height):\n        for c in range(start_col, end_col):\n            if grid[r][c] == minority_color:\n                pattern.add((r, c - start_col))\n    return pattern\n\ndef apply_pattern_to_block(output_grid: list[list[int]], block_bounds: tuple[int, int], target_pattern: set[tuple[int, int]], majority_color: int, minority_color: int, background_color: int = 0):\n    \"\"\"Applies the target pattern to a block in the output grid.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(output_grid)\n    for r in range(height):\n        for c in range(start_col, end_col):\n            # Only modify non-background cells\n            if output_grid[r][c] != background_color:\n                relative_col = c - start_col\n                if (r, relative_col) in target_pattern:\n                    output_grid[r][c] = minority_color\n                else:\n                    output_grid[r][c] = majority_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the grid by rearranging minority color patterns within blocks,\n    with the rule depending on whether the number of blocks is odd or even.\n    Includes a column shift for patterns moving into the first block.\n    \"\"\"\n    # --- Initialization and Grid Analysis ---\n    output_grid = copy.deepcopy(input_grid)\n    if not input_grid or not input_grid[0]:\n        return output_grid\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0\n\n    # 1. Identify Separators\n    separator_cols = find_separator_columns(input_grid, background_color)\n\n    # 2. Define Blocks\n    blocks = define_blocks(separator_cols, width)\n    num_blocks = len(blocks)\n\n    # 3. Handle Simple Case (N < 2)\n    if num_blocks < 2:\n        return output_grid\n\n    # 4. Identify Colors\n    majority_color, minority_color = get_majority_minority_colors(input_grid, blocks, background_color)\n\n    # Cannot proceed if minority color isn't defined\n    if minority_color is None or majority_color is None:\n        return output_grid # Return original grid copy\n\n    # --- Pattern Extraction ---\n    # 5. Extract Input Patterns (0-indexed)\n    input_patterns = [extract_minority_pattern(input_grid, bounds, minority_color) for bounds in blocks]\n\n    # --- Determine Target Patterns based on Parity ---\n    # 6. Determine Output Patterns\n    output_patterns = [set() for _ in range(num_blocks)] # Initialize list of empty sets\n\n    if num_blocks % 2 != 0: # Odd number of blocks (N >= 3)\n        # Block 0 gets shifted pattern from Block N-1\n        last_pattern = input_patterns[num_blocks - 1]\n        shifted_last_pattern = set((r, max(0, c_rel - 1)) for r, c_rel in last_pattern)\n        output_patterns[0] = shifted_last_pattern\n\n        # Blocks 1 to N-2 are unchanged (get pattern P[i])\n        for i in range(1, num_blocks - 1):\n            output_patterns[i] = input_patterns[i]\n\n        # Block N-1 gets pattern from Block 0\n        output_patterns[num_blocks - 1] = input_patterns[0]\n\n    else: # Even number of blocks (N >= 2)\n        # Block 0 gets shifted pattern from Block N-2\n        # Handle N=2 case separately as N-2 would be 0\n        if num_blocks == 2:\n             # B0 gets shifted P0, B1 gets P1\n             pattern_0 = input_patterns[0]\n             shifted_pattern_0 = set((r, max(0, c_rel - 1)) for r, c_rel in pattern_0)\n             output_patterns[0] = shifted_pattern_0\n             output_patterns[1] = input_patterns[1] # Last block unchanged\n        else: # N >= 4\n            pattern_n_minus_2 = input_patterns[num_blocks - 2]\n            shifted_pattern_n_minus_2 = set((r, max(0, c_rel - 1)) for r, c_rel in pattern_n_minus_2)\n            output_patterns[0] = shifted_pattern_n_minus_2\n\n            # Blocks 1 to N-2 get pattern from Block i-1\n            for i in range(1, num_blocks - 1):\n                output_patterns[i] = input_patterns[i - 1]\n\n            # Block N-1 is unchanged (gets pattern P[N-1])\n            output_patterns[num_blocks - 1] = input_patterns[num_blocks - 1]\n\n\n    # --- Apply Transformations ---\n    # 7. Apply the determined patterns to the output grid\n    for i, block_bounds in enumerate(blocks):\n        apply_pattern_to_block(\n            output_grid,\n            block_bounds,\n            output_patterns[i],\n            majority_color,\n            minority_color,\n            background_color\n        )\n\n    # 8. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11987,
    "candidates_token_count": 4201,
    "total_token_count": 16188,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 32.321275,
  "retries": 1
}