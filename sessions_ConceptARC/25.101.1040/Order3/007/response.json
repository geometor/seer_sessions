{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n\n1.  Identify vertical separator columns composed entirely of the background color (white/0).\n2.  Define blocks as the contiguous vertical segments between separators (or grid edges). Let N be the number of blocks.\n3.  If N < 2, return the input grid unchanged.\n4.  Determine the majority color (M) and minority color (m) present in the non-background areas across all blocks. If M or m cannot be found, return the input grid unchanged.\n5.  Extract the relative minority pattern P[i] = {(row, col_relative)} for each block i (0-indexed) from the input grid.\n6.  Determine the target output pattern for each block based on the parity of N:\n    *   If N is ODD (and N >= 3):\n        *   Output Block 0 gets the pattern from input Block N-1.\n        *   Output Blocks 1 to N-2 get the pattern from the corresponding input Block i.\n        *   Output Block N-1 gets the pattern from input Block 0.\n    *   If N is EVEN (and N >= 2):\n        *   Output Block 0 gets the pattern from input Block N-2.\n        *   Output Blocks 1 to N-2 get the pattern from the preceding input Block i-1.\n        *   Output Block N-1 gets the pattern from input Block N-1 (unchanged).\n7.  Create a copy of the input grid as the output grid.\n8.  For each block j in the output grid:\n    *   Iterate through its non-background cells (r, c).\n    *   Calculate the relative column `c_rel`.\n    *   Check if `(r, c_rel)` exists in the target pattern determined in step 6 for block j.\n    *   If yes, set the output cell color to `m`.\n    *   If no, set the output cell color to `M`.\n9.  Return the modified output grid.\n\"\"\"\n\nimport copy\nfrom collections import Counter\n\n# --- Helper Functions ---\n\ndef find_separator_columns(grid: list[list[int]], background_color: int = 0) -> list[int]:\n    \"\"\"Finds columns composed entirely of the background color.\"\"\"\n    if not grid or not grid[0]:\n        return []\n    height = len(grid)\n    width = len(grid[0])\n    separator_cols = []\n    for c in range(width):\n        is_separator = True\n        for r in range(height):\n            if grid[r][c] != background_color:\n                is_separator = False\n                break\n        if is_separator:\n            separator_cols.append(c)\n    return separator_cols\n\ndef define_blocks(separator_cols: list[int], width: int) -> list[tuple[int, int]]:\n    \"\"\"Defines block boundaries (start_col, end_col_exclusive) based on separators.\"\"\"\n    blocks = []\n    start_col = 0\n    for sep_col in separator_cols:\n        # Add block if content exists before the separator\n        if sep_col > start_col:\n            blocks.append((start_col, sep_col))\n        # Next block starts after the separator\n        start_col = sep_col + 1\n    # Add the last block if content exists after the last separator\n    if start_col < width:\n        blocks.append((start_col, width))\n    return blocks\n\ndef get_majority_minority_colors(grid: list[list[int]], blocks: list[tuple[int, int]], background_color: int = 0) -> tuple[int | None, int | None]:\n    \"\"\"Identifies the majority and minority non-background colors across all blocks.\"\"\"\n    colors = []\n    height = len(grid)\n    for start_col, end_col in blocks:\n        for r in range(height):\n            for c in range(start_col, end_col):\n                if grid[r][c] != background_color:\n                    colors.append(grid[r][c])\n\n    if not colors:\n        return None, None # No non-background colors found\n\n    counts = Counter(colors)\n    sorted_colors = counts.most_common()\n\n    if len(sorted_colors) >= 2:\n        majority_color = sorted_colors[0][0]\n        minority_color = sorted_colors[1][0]\n        # Ensure the less frequent one is minority, handle ties by picking second\n        if counts[minority_color] > counts[majority_color]:\n             majority_color, minority_color = minority_color, majority_color\n    elif len(sorted_colors) == 1:\n        # Only one non-background color present\n        majority_color = sorted_colors[0][0]\n        minority_color = None # Cannot perform pattern swap logic\n    else: # Should not happen if colors list is not empty\n        majority_color = None\n        minority_color = None\n\n    return majority_color, minority_color\n\ndef extract_minority_pattern(grid: list[list[int]], block_bounds: tuple[int, int], minority_color: int) -> set[tuple[int, int]]:\n    \"\"\"Extracts relative coordinates (row, col_in_block) of the minority color as a set.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(grid)\n    pattern = set()\n    # Return empty set if minority color wasn't identified\n    if minority_color is None:\n        return pattern\n    for r in range(height):\n        for c in range(start_col, end_col):\n            if grid[r][c] == minority_color:\n                pattern.add((r, c - start_col))\n    return pattern\n\ndef apply_pattern_to_block(output_grid: list[list[int]], input_grid: list[list[int]], block_bounds: tuple[int, int], target_pattern: set[tuple[int, int]], majority_color: int, minority_color: int, background_color: int = 0):\n    \"\"\"Applies the target pattern to a block in the output grid by setting colors.\"\"\"\n    start_col, end_col = block_bounds\n    height = len(output_grid)\n    # Ensure minority color is valid before proceeding\n    if minority_color is None or majority_color is None:\n        return\n\n    for r in range(height):\n        for c in range(start_col, end_col):\n            # Only modify cells that were originally non-background\n            if input_grid[r][c] != background_color:\n                relative_col = c - start_col\n                if (r, relative_col) in target_pattern:\n                    output_grid[r][c] = minority_color\n                else:\n                    output_grid[r][c] = majority_color\n            # else: keep background color\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # 1. Initialize output grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    if not input_grid or not input_grid[0]:\n        return output_grid # Handle empty grid case\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0\n\n    # 2. Identify Background and Separators\n    separator_cols = find_separator_columns(input_grid, background_color)\n\n    # 3. Define Blocks\n    blocks = define_blocks(separator_cols, width)\n    num_blocks = len(blocks)\n\n    # 4. Handle Simple Case (N < 2)\n    if num_blocks < 2:\n        return output_grid\n\n    # 5. Identify Majority (M) and Minority (m) Colors\n    majority_color, minority_color = get_majority_minority_colors(input_grid, blocks, background_color)\n\n    # Cannot proceed if minority color isn't defined\n    if minority_color is None or majority_color is None:\n        # If only majority exists, the output should just be the majority color in non-background areas\n        if majority_color is not None:\n             for r in range(height):\n                  for c in range(width):\n                       if output_grid[r][c] != background_color:\n                            output_grid[r][c] = majority_color\n        return output_grid # Return potentially modified grid or original copy\n\n\n    # 6. Extract Input Patterns (0-indexed)\n    input_patterns = [extract_minority_pattern(input_grid, bounds, minority_color) for bounds in blocks]\n\n    # 7. Determine Target Output Patterns based on Parity of N\n    output_patterns = [set() for _ in range(num_blocks)] # Initialize list of empty sets\n\n    if num_blocks % 2 != 0: # Odd number of blocks (N >= 3)\n        # Rule: B0<-P[N-1], B[1..N-2]<-P[i], B[N-1]<-P[0]\n        output_patterns[0] = input_patterns[num_blocks - 1]\n        for i in range(1, num_blocks - 1):\n            output_patterns[i] = input_patterns[i]\n        if num_blocks > 0: # Avoid index error if somehow N=1 reached here\n             output_patterns[num_blocks - 1] = input_patterns[0]\n\n    else: # Even number of blocks (N >= 2)\n        # Rule: B0<-P[N-2], B[1..N-2]<-P[i-1], B[N-1]<-P[N-1]\n        if num_blocks >= 2: # N=2 case: B0<-P[0], B1<-P1, so N-2 is P[0]\n            output_patterns[0] = input_patterns[num_blocks - 2]\n            for i in range(1, num_blocks - 1): # This loop runs only if N >= 4\n                output_patterns[i] = input_patterns[i - 1]\n            output_patterns[num_blocks - 1] = input_patterns[num_blocks - 1]\n        # Note: If N=0, this section isn't reached due to step 4.\n\n\n    # 8. Apply Transformations (Coloring based on target patterns)\n    for i, block_bounds in enumerate(blocks):\n        apply_pattern_to_block(\n            output_grid,\n            input_grid, # Pass input grid to check original background\n            block_bounds,\n            output_patterns[i],\n            majority_color,\n            minority_color,\n            background_color\n        )\n\n    # 9. Return Output\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28868,
    "candidates_token_count": 2853,
    "total_token_count": 31721,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.932576,
  "retries": 1
}