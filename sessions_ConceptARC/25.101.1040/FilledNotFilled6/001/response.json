{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis module transforms an input grid based on the solidity of its non-background objects.\n\nThe transformation rule involves:\n1. Identifying distinct connected objects (groups of non-white pixels).\n2. For each object:\n   a. Determine its color and bounding box.\n   b. Check if the object completely fills its bounding box (is \"solid\").\n   c. If the object is solid: Hollow it out by changing its interior pixels (those whose 8 neighbors are also part of the object) to white (0).\n   d. If the object is not solid (hollow): Fill its internal holes by changing any white pixels within its bounding box to the object's color.\n3. Pixels outside any object's bounding box remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid: np.ndarray) -> list[tuple[int, set[tuple[int, int]]]]:\n    \"\"\"\n    Finds connected components of non-background pixels in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - The color (int) of the object.\n        - A set of (row, col) tuples representing the coordinates of the object's pixels.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0 # Assuming white (0) is the background\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n\n                    # Check 4-directional neighbors (can use 8 if needed, but 4 is typical for connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append((color, obj_pixels))\n    return objects\n\ndef get_bounding_box(pixels: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the minimum bounding box for a set of pixels.\n\n    Args:\n        pixels: A set of (row, col) tuples.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    if not pixels:\n        return (0, 0, -1, -1) # Indicate empty or invalid\n    min_r = min(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return min_r, min_c, max_r, max_c\n\ndef get_neighbors_8(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets the 8 neighboring coordinates (including diagonals) for a pixel.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the fill/hollow transformation to objects in the grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n\n    # 1. Identify all distinct connected objects\n    objects = find_objects(input_np)\n\n    # 2. Process each object\n    for color, obj_pixels in objects:\n        if not obj_pixels:\n            continue\n\n        # 3a. Determine color (already have)\n        # 3b. Find coordinates (already have)\n        # 3c. Calculate bounding box\n        min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n        bbox_height = max_r - min_r + 1\n        bbox_width = max_c - min_c + 1\n\n        # 3d. Determine if the object is solid\n        is_solid = True\n        # Check if any background pixel exists within the bounding box\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if input_np[r, c] == background_color:\n                    is_solid = False\n                    break\n            if not is_solid:\n                break\n        \n        # An alternative solidity check: count pixels vs bbox area\n        # is_solid = len(obj_pixels) == (bbox_height * bbox_width)\n\n        # 3e. If solid, hollow it out\n        if is_solid:\n            for r, c in obj_pixels:\n                # Check if this pixel is an interior pixel\n                is_interior = True\n                neighbors = get_neighbors_8(r, c, height, width)\n                if len(neighbors) < 8: # Pixel is on the grid edge, not strictly interior\n                    is_interior = False\n                else:\n                     # Check if all 8 neighbors belong to the *same* object\n                     # (i.e., have the object's color in the input grid)\n                     for nr, nc in neighbors:\n                         if input_np[nr, nc] != color:\n                              is_interior = False\n                              break\n                \n                if is_interior:\n                    output_np[r, c] = background_color\n\n        # 3f. If hollow, fill it\n        else: # not is_solid\n            for r in range(min_r, max_r + 1):\n                for c in range(min_c, max_c + 1):\n                    # If the pixel is inside the bounding box and is background...\n                    if input_np[r, c] == background_color:\n                        # ...change it to the object's color in the output\n                        output_np[r, c] = color\n\n    # Convert back to list of lists and return\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2974,
    "candidates_token_count": 2784,
    "total_token_count": 5758,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.402235,
  "retries": 1
}