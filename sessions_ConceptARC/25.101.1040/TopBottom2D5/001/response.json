{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all distinct colored objects in the input grid. \nFilters these objects to find only those that match a 'T' shape pattern (5 pixels: a 3-pixel line and a 2-pixel perpendicular stem attached to the center).\nIf multiple 'T' shapes are found, selects the one whose highest point (minimum row index) is lowest on the grid (maximum row index).\nConstructs an output grid of the same dimensions as the input, initially filled with the background color (white, 0).\nDraws the selected 'T' shape (if any) onto the output grid in its original position and color.\nIf no 'T' shapes are found, returns the empty grid.\n\"\"\"\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\" Helper to get valid neighbors of a cell \"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\" Finds all contiguous objects of non-background color (0) \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r = r\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row) # Keep track of the topmost row\n\n                    for nr, nc in _get_neighbors(row, col, height, width):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                objects.append({'color': color, 'pixels': obj_pixels, 'top_row': min_r})\n    \n    return objects\n\ndef _is_t_shape(pixels: set) -> bool:\n    \"\"\" Checks if a set of pixels forms a T-shape (5 pixels) \"\"\"\n    if len(pixels) != 5:\n        return False\n\n    rows = sorted([r for r, c in pixels])\n    cols = sorted([c for r, c in pixels])\n    \n    min_r, max_r = rows[0], rows[-1]\n    min_c, max_c = cols[0], cols[-1]\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check bounding box dimensions and pixel relative positions\n    # Normalize coordinates relative to the top-left of the bounding box\n    normalized_pixels = set((r - min_r, c - min_c) for r, c in pixels)\n\n    # Define the 4 canonical T shapes relative to a 0,0 origin within their bounding box\n    t_shapes = [\n        # T (3x2)\n        set([(0,0), (0,1), (0,2), (1,1), (2,1)]), # Correction: T stem is 2 pixels, shape is 3x2 or 2x3\n        # Corrected T (3 wide, 2 high) - stem down\n        set([(0,0), (0,1), (0,2), (1,1)]), # Missing one pixel.. let's redefine\n        \n        # Let's define by structure: 3 collinear, 2 collinear perpendicular from middle of the 3\n        \n        # Possible T shapes (relative coordinates)\n        # 1. T (stem down) BBox: W=3, H=2\n        set([(0,0), (0,1), (0,2), (1,1)]), # Still 4 pixels... T is 5 pixels.\n        # A 3-pixel line segment with a 2-pixel perpendicular stem attached to the center pixel.\n\n        # Canonical T shapes (5 pixels) normalized to top-left\n        # T (stem down): 3 horizontal, 1 vertical from center\n        # xxx\n        #  x\n        #  x  <-- No, stem is 2 pixels total (1 base + 1 extension)\n        # xxx\n        #  x\n        set([(0,0), (0,1), (0,2), (1,1)]), # 4 pixels... hmm. Let's check the examples again.\n        \n        # Example 1: Blue T\n        # (1,1), (1,3) -> (0,0), (0,2)\n        # (2,1), (2,2), (2,3) -> (1,0), (1,1), (1,2)  -> This is inverted T\n        # {(0,0), (0,2), (1,0), (1,1), (1,2)} normalized -> {(0,0), (0,2), (1,0), (1,1), (1,2)} NO\n        # Pixels: (1,1), (1,3), (2,1), (2,2), (2,3). Color 1. Min R=1.\n        # Pixels: (1,5), (1,7), (2,5), (2,6), (2,7). Color 2. Min R=1.\n        # Pixels: (6,3), (6,5), (7,3), (7,4), (7,5). Color 6. Min R=6. <-- This is the one kept. Lowest top_row.\n\n        # Let's manually define the shapes again based on example 1's magenta shape:\n        # (6,3) (6,5)\n        # (7,3) (7,4) (7,5)\n        # Relative coords (min_r=6, min_c=3):\n        # (0,0) (0,2)\n        # (1,0) (1,1) (1,2)\n        # This is an inverted T shape. BBox: W=3, H=2. \n        inv_t = set([(0,0), (0,2), (1,0), (1,1), (1,2)])\n\n        # T (stem up): 3 horizontal, 1 vertical up from center\n        #  x\n        # xxx\n        # BBox: W=3, H=2\n        t_up = set([(0,1), (1,0), (1,1), (1,2)]) # Still 4.. Ah, T has 5 pixels total.\n        #  x  -> (0,1)\n        # xxx -> (1,0), (1,1), (1,2)\n        # Plus the center pixel itself (1,1) is part of both lines.\n        \n        # Let's retry the definition: 5 pixels total.\n        # Central pixel.\n        # Two pixels extending in one direction (left/right or up/down).\n        # Two pixels extending perpendicularly from the center.\n\n        # Let's use the examples again.\n        # Example 1, Blue (color 1): (1,1), (2,1), (2,2), (2,3), (1,3).  Looks like an inverted T.\n        #   Relative coords (min_r=1, min_c=1): (0,0), (1,0), (1,1), (1,2), (0,2). Set: {(0,0), (0,2), (1,0), (1,1), (1,2)}. Matches inv_t.\n        # Example 1, Red (color 2): (1,5), (2,5), (2,6), (2,7), (1,7). Looks like an inverted T.\n        #   Relative coords (min_r=1, min_c=5): (0,0), (1,0), (1,1), (1,2), (0,2). Set: {(0,0), (0,2), (1,0), (1,1), (1,2)}. Matches inv_t.\n        # Example 1, Magenta (color 6): (6,3), (7,3), (7,4), (7,5), (6,5). Looks like an inverted T.\n        #   Relative coords (min_r=6, min_c=3): (0,0), (1,0), (1,1), (1,2), (0,2). Set: {(0,0), (0,2), (1,0), (1,1), (1,2)}. Matches inv_t.\n\n        # Example 2, Green (color 3): (2,1), (2,2), (2,3), (3,1). This is 4 pixels. Not a T. (It's an L shape)\n        # Example 2, Orange (color 7): (2,6), (2,7), (2,8), (3,6). 4 pixels. L shape.\n        # Example 2, Azure (color 8): (5,3), (5,4), (5,5), (6,3). 4 pixels. L shape.\n        # Example 2, Red (color 2): (8,7), (8,8), (8,9), (9,7). 4 pixels. L shape. --> Output is this Red L shape??\n        # Output 2 is: Red shape (8,7), (8,8), (8,9), (9,7).\n        # Wait, the description says T shape, but example 2 output is an L shape. Let's re-read the prompt and look at the examples again.\n\n        # Re-evaluating Example 2:\n        # Input: Green L, Orange L, Azure L, Red L.\n        # Output: Only the Red L.\n        # Why red L? It's the lowest one vertically based on its highest point.\n        # Green L: top_row = 2\n        # Orange L: top_row = 2\n        # Azure L: top_row = 5\n        # Red L: top_row = 8 <-- Lowest top_row.\n\n        # Re-evaluating Example 3:\n        # Input: Yellow L, Azure T, Green T.\n        # Yellow L: top_row = 4\n        # Azure T: (6,7),(6,9), (7,7),(7,8),(7,9). top_row = 6. Shape: Inverted T.\n        # Green T: (7,0),(7,2), (8,0),(8,1),(8,2). top_row = 7. Shape: Inverted T.\n        # Output: Only the Green T.\n        # Why Green T? It's the lowest T shape.\n        # Azure T top_row = 6\n        # Green T top_row = 7 <-- Lowest T.\n\n        # Re-evaluating Example 1:\n        # Input: Blue T, Red T, Magenta T.\n        # Blue T: top_row = 1\n        # Red T: top_row = 1\n        # Magenta T: top_row = 6\n        # Output: Only Magenta T.\n        # Why Magenta T? It's the lowest T shape.\n\n        # Okay, the rule seems to be:\n        # 1. Find all objects.\n        # 2. Identify which objects are 'T' shapes (inverted T in the examples shown).\n        # 3. If there are any 'T' shapes, select the 'T' shape whose top_row is maximum (lowest on the grid).\n        # 4. If there are NO 'T' shapes, identify which objects are 'L' shapes (4 pixels).\n        # 5. If there are any 'L' shapes (and no T shapes), select the 'L' shape whose top_row is maximum.\n        # 6. If there are no T or L shapes, return empty grid.\n\n        # Let's define the L shape (4 pixels) based on Example 2, Red:\n        # (8,7) (8,8) (8,9)\n        # (9,7)\n        # Relative coords (min_r=8, min_c=7):\n        # (0,0) (0,1) (0,2)\n        # (1,0)\n        # This is one L shape. There are 8 possible L shapes (4 rotations, 2 mirror images).\n        \n        # Let's redefine the helper functions:\n        # `is_t_shape(pixels)` -> returns True if 5 pixels form an inverted T.\n        # `is_l_shape(pixels)` -> returns True if 4 pixels form an L shape.\n        # `get_shape_type(pixels)` -> returns 'T', 'L', or 'Other'.\n\n        # Define the canonical inverted T shape (relative coords):\n        inv_t_shape = set([(0,0), (0,2), (1,0), (1,1), (1,2)]) # Width=3, Height=2\n\n        # Define the 4 rotated versions of inverted T\n        # T (stem up) W=3, H=2: set([(0,1), (1,0), (1,1), (1,2)]) -- No, this is 4 pix again.\n        \n        # Let's simplify. Check if the shape, when normalized and potentially rotated/flipped, matches the canonical inverted T.\n\n        # Check for inverted T specifically first, as seen in examples 1 & 3.\n        if width == 3 and height == 2:\n            if normalized_pixels == inv_t_shape:\n                return True\n        elif width == 2 and height == 3:\n            # Check rotated versions\n            # T (stem right)\n            # x 0 -> (0,0)\n            # x x -> (1,0), (1,1)\n            # x 0 -> (2,0)\n            # Normalized: set([(0,0), (1,0), (1,1), (2,0)]) <-- 4 pixels again.\n            \n            # Let's just stick to the specific inverted T seen.\n            # Maybe the task only considers this specific orientation? It's common in ARC.\n            \n            # Okay, let's assume ONLY the inverted T counts as 'T'.\n            # Bbox W=3, H=2\n            if width == 3 and height == 2 and normalized_pixels == set([(0,0), (0,2), (1,0), (1,1), (1,2)]):\n                 return True\n            # Bbox W=2, H=3 (rotated 90 deg)\n            # x x  -> (0,0), (0,1)\n            # 0 x  -> (1,1)\n            # 0 x  -> (2,1)\n            if width == 2 and height == 3 and normalized_pixels == set([(0,0),(0,1),(1,1),(2,1)]): # 4 pixels..\n                 pass # This isn't the 5 pixel T\n\n            # Recheck Example 3 Green T: (7,0),(7,2), (8,0),(8,1),(8,2). Pixels: {(7, 0), (7, 2), (8, 0), (8, 1), (8, 2)}\n            # min_r=7, max_r=8, min_c=0, max_c=2. H=2, W=3.\n            # Normalized: {(0,0), (0,2), (1,0), (1,1), (1,2)}. Matches `inv_t_shape`. Okay.\n\n            # Recheck Example 3 Azure T: (6,7),(6,9), (7,7),(7,8),(7,9). Pixels: {(6, 7), (6, 9), (7, 7), (7, 8), (7, 9)}\n            # min_r=6, max_r=7, min_c=7, max_c=9. H=2, W=3.\n            # Normalized: {(0,0), (0,2), (1,0), (1,1), (1,2)}. Matches `inv_t_shape`. Okay.\n            \n            # It seems only the inverted T shape counts.\n            \n            # If a shape is W=3, H=2 or W=2, H=3 and has 5 pixels, check if it matches any rotation of the base T.\n            # Base T: {(0,1), (1,0), (1,1), (1,2), (2,1)}  (Stem down, W=3, H=3 - center at 1,1) No, 5 pixels.\n            # Base T can be defined as center + 4 neighbors where 2 pairs are collinear.\n            \n            # Let's try center-based definition.\n            # Find center pixel (average row/col often not integer).\n            # Find centroid (median row/col)?\n            rows = [r for r,c in pixels]\n            cols = [c for r,c in pixels]\n            center_r = sorted(rows)[2]\n            center_c = sorted(cols)[2]\n            center_pixel = None\n            # Check if median pixel exists in the set\n            if (center_r, center_c) in pixels:\n                 center_pixel = (center_r, center_c)\n            else: # If median is not in the set, the shape is likely asymmetric -> not a T\n                 return False # Or maybe the median point isn't the geometric center for T?\n\n            # Try bounding box center approx\n            center_r_bb = min_r + (max_r - min_r) / 2\n            center_c_bb = min_c + (max_c - min_c) / 2\n            \n            # Find pixel closest to bounding box center\n            min_dist_sq = float('inf')\n            potential_center = None\n            for r,c in pixels:\n                dist_sq = (r - center_r_bb)**2 + (c - center_c_bb)**2\n                if dist_sq < min_dist_sq:\n                    min_dist_sq = dist_sq\n                    potential_center = (r,c)\n                elif dist_sq == min_dist_sq: # Ambiguous center\n                    potential_center = None # Mark as ambiguous, might not be T\n                    # break # Or maybe allow multiple potential centers? Unlikely for T.\n            \n            if potential_center is None: return False\n\n            pr, pc = potential_center\n            neighbors = 0\n            # Check neighbors relative to potential center\n            has_up = (pr-1, pc) in pixels\n            has_down = (pr+1, pc) in pixels\n            has_left = (pr, pc-1) in pixels\n            has_right = (pr, pc+1) in pixels\n            \n            # A T shape has the center pixel connected to 3 other pixels\n            if sum([has_up, has_down, has_left, has_right]) != 3:\n                 return False\n\n            # The 3 connected neighbors must form one straight line and one perpendicular\n            # Case 1: Up, Left, Right neighbors -> T shape (stem down)\n            if has_up and has_left and has_right:\n                # Need the 5th pixel down from the center: (pr+1, pc)\n                return (pr+1, pc) in pixels # Check stem\n            # Case 2: Down, Left, Right neighbors -> Inverted T shape (stem up)\n            elif has_down and has_left and has_right:\n                 # Need the 5th pixel up from the center: (pr-1, pc)\n                 return (pr-1, pc) in pixels # Check stem\n            # Case 3: Up, Down, Left neighbors -> T shape (stem right)\n            elif has_up and has_down and has_left:\n                 # Need the 5th pixel right from the center: (pr, pc+1)\n                 return (pr, pc+1) in pixels # Check stem\n            # Case 4: Up, Down, Right neighbors -> T shape (stem left)\n            elif has_up and has_down and has_right:\n                 # Need the 5th pixel left from the center: (pr, pc-1)\n                 return (pr, pc-1) in pixels # Check stem\n            else:\n                 # Should not happen if neighbor count was 3\n                 return False\n                 \n        # Fallthrough if not 5 pixels\n        return False\n\n\ndef _is_l_shape(pixels: set) -> bool:\n    \"\"\" Checks if a set of pixels forms an L-shape (4 pixels) \"\"\"\n    if len(pixels) != 4:\n        return False\n        \n    rows = sorted([r for r, c in pixels])\n    cols = sorted([c for r, c in pixels])\n    \n    min_r, max_r = rows[0], rows[-1]\n    min_c, max_c = cols[0], cols[-1]\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # An L shape (4 pixels) has bounding box 3x2 or 2x3.\n    if not ((width == 3 and height == 2) or (width == 2 and height == 3)):\n        return False\n\n    # Check for the corner pixel. An L shape has one pixel with 2 neighbors within the shape.\n    corner_pixel = None\n    for r, c in pixels:\n        neighbor_count = 0\n        # Check 4 cardinal neighbors\n        if (r+1, c) in pixels: neighbor_count += 1\n        if (r-1, c) in pixels: neighbor_count += 1\n        if (r, c+1) in pixels: neighbor_count += 1\n        if (r, c-1) in pixels: neighbor_count += 1\n        \n        if neighbor_count == 2:\n            if corner_pixel is not None: # More than one pixel has 2 neighbors -> not L\n                 return False\n            corner_pixel = (r, c)\n        elif neighbor_count > 2: # Not possible for L shape exterior pixels\n             return False\n             \n    # Exactly one pixel must have 2 neighbors (the corner).\n    # The other 3 pixels must have 1 neighbor within the shape.\n    return corner_pixel is not None\n\ndef _get_shape_type(pixels: set) -> str:\n    \"\"\" Determines if the shape is T, L, or Other \"\"\"\n    if _is_t_shape(pixels):\n        return 'T'\n    elif _is_l_shape(pixels):\n        return 'L'\n    else:\n        return 'Other'\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Identifies T or L shapes in the input grid. \n    If T shapes exist, selects the lowest one (max top_row).\n    If no T shapes exist but L shapes exist, selects the lowest L shape.\n    Draws the selected shape onto an empty grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    \n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # Find all distinct objects in the grid\n    objects = _find_objects(input_np)\n    \n    t_shapes = []\n    l_shapes = []\n\n    # Classify shapes\n    for obj in objects:\n        shape_type = _get_shape_type(obj['pixels'])\n        if shape_type == 'T':\n            t_shapes.append(obj)\n        elif shape_type == 'L':\n            l_shapes.append(obj)\n\n    selected_shape = None\n\n    # Priority 1: Find the lowest T shape\n    if t_shapes:\n        # Sort by top_row descending (lowest first)\n        t_shapes.sort(key=lambda x: x['top_row'], reverse=True)\n        selected_shape = t_shapes[0]\n    # Priority 2: If no T shapes, find the lowest L shape\n    elif l_shapes:\n        # Sort by top_row descending (lowest first)\n        l_shapes.sort(key=lambda x: x['top_row'], reverse=True)\n        selected_shape = l_shapes[0]\n\n    # Draw the selected shape onto the output grid\n    if selected_shape:\n        color = selected_shape['color']\n        for r, c in selected_shape['pixels']:\n            if 0 <= r < height and 0 <= c < width: # Bounds check just in case\n                 output_grid[r, c] = color\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3237,
    "candidates_token_count": 6833,
    "total_token_count": 10070,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 51.812332,
  "retries": 1
}