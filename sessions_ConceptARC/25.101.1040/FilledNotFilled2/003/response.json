{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nDetermines the dimensions of an all-white output grid based on properties of objects in the input grid.\nThe core logic compares the number of distinct objects (N) to the number of unique non-white colors (C).\n\n1. If N equals C, it searches for an object where its height matches its color value. The output grid dimensions become the height and width of that specific object. If no such object exists, it defaults to the N != C rule.\n2. If N does not equal C, the output grid dimensions are set to the maximum height (MaxH) found among all objects by (C - 1).\n3. The final output grid is filled entirely with white pixels (0).\n\"\"\"\n\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous objects of non-white colors in the grid using Breadth-First Search.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its color, pixels (list of tuples), bounding box coordinates\n        (min_r, max_r, min_c, max_c), height, and width.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the cell is non-white and not yet visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional adjacency)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Calculate height and width from bounding box\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_r': min_r, 'max_r': max_r,\n                    'min_c': min_c, 'max_c': max_c,\n                    'height': height,\n                    'width': width\n                })\n    return objects\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid into an all-white grid whose dimensions\n    are determined by the rules based on object counts, colors, and heights.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct non-white objects and their properties.\n    objects = find_objects(grid_np)\n\n    # Handle edge case: If there are no non-white objects, return a 1x1 white grid.\n    if not objects:\n        return [[0]]\n\n    # 2. Calculate N (number of objects), C (number of unique colors), and MaxH (max height).\n    num_objects = len(objects)\n    unique_colors = set(obj['color'] for obj in objects)\n    num_unique_colors = len(unique_colors)\n    max_height = max(obj['height'] for obj in objects) # Guaranteed > 0 if objects exist\n\n    output_height = 0\n    output_width = 0\n\n    # 3. Apply rules based on comparing N and C.\n    if num_objects == num_unique_colors:\n        # Rule 1: N == C\n        found_special_object = False\n        # 3a. Search for an object where height == color.\n        for obj in objects:\n            if obj['height'] == obj['color']:\n                # 3b. If found, use its dimensions.\n                output_height = obj['height']\n                output_width = obj['width']\n                found_special_object = True\n                break\n        # 3c. Fallback: If no such object is found, use the N != C rule.\n        if not found_special_object:\n            output_height = max_height\n            output_width = max(0, num_unique_colors - 1) # Ensure width is not negative\n    else:\n        # Rule 2: N != C\n        # 3d. Use MaxH for height and (C - 1) for width.\n        output_height = max_height\n        output_width = max(0, num_unique_colors - 1) # Ensure width is not negative\n\n    # 4. Handle potential zero dimensions for the output grid. Default to 1x1 if needed.\n    #    (Although current logic with max(0, C-1) should prevent negative widths,\n    #     and height should be > 0 if objects exist. Width could be 0 if C=1).\n    if output_height <= 0 or output_width <= 0:\n         output_height = max(1, output_height)\n         output_width = max(1, output_width)\n\n\n    # 5. Create the output grid with the determined dimensions, filled with white (0).\n    output_grid_np = np.zeros((output_height, output_width), dtype=int)\n\n    # 6. Convert back to list of lists and return.\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9232,
    "candidates_token_count": 1865,
    "total_token_count": 11097,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.874209,
  "retries": 1
}