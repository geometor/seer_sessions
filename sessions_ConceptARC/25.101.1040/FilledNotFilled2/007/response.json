{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nDetermines the dimensions of an all-white output grid based on comparing properties\nof objects in the input grid. It calculates two potential dimension sets:\n1. Dims_A: Based on a 'special object' (where height equals color value), only\n   applicable if the number of objects (N) equals the number of unique colors (C)\n   and such an object exists. Dimensions are height x width of that object.\n2. Dims_B: Based on the maximum height (MaxH) of any object and the number of\n   unique colors (C). Dimensions are MaxH x max(0, C - 1).\n\nThe final output dimensions are chosen by selecting the dimension set (A or B)\nthat results in the larger grid area (Height * Width). If Set A is applicable\nand the areas are equal, Set A is chosen. The resulting grid is filled with\nwhite pixels (0).\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous objects of non-white colors in the grid using\n    Breadth-First Search (4-way adjacency).\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its color, pixels, bounding box coordinates, height, and width.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Check if the cell is non-white and not yet visited\n            if color != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional adjacency)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Calculate height and width from bounding box\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'min_r': min_r, 'max_r': max_r,\n                    'min_c': min_c, 'max_c': max_c,\n                    'height': height,\n                    'width': width\n                })\n    return objects\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on object properties and the 'max area'\n    selection criterion between two dimension calculation methods.\n    \"\"\"\n    grid_np = np.array(input_grid, dtype=int)\n\n    # 1. Identify all distinct non-white objects and their properties.\n    objects = find_objects(grid_np)\n\n    # Handle edge case: If there are no non-white objects, return a 1x1 white grid.\n    if not objects:\n        return [[0]]\n\n    # 2. Calculate N (number of objects), C (number of unique colors), and MaxH (max height).\n    num_objects = len(objects)\n    unique_colors = set(obj['color'] for obj in objects)\n    num_unique_colors = len(unique_colors)\n    max_height = max(obj['height'] for obj in objects) # Guaranteed > 0\n\n    # 3. Calculate Potential Dimensions B (Dims_B) and its area (Area_B).\n    # Dims_B = MaxH x max(0, C - 1)\n    h_B = max_height\n    w_B = max(0, num_unique_colors - 1)\n    dims_B = (h_B, w_B)\n    area_B = h_B * w_B\n\n    # 4. Initialize Potential Dimensions A (Dims_A) and Area_A as not applicable.\n    dims_A = None\n    area_A = -1 # Use -1 to indicate not applicable or area 0\n\n    # 5. Check if N == C to determine if Dims_A can be calculated.\n    if num_objects == num_unique_colors:\n        # 5a. Search for a \"special object\" where height == color.\n        for obj in objects:\n            if obj['height'] == obj['color']:\n                # 5b. If found, calculate Dims_A and Area_A.\n                h_A = obj['height']\n                w_A = obj['width']\n                dims_A = (h_A, w_A)\n                area_A = h_A * w_A\n                break # Assume only one such object matters or take the first\n\n    # 6. Select Final Dimensions based on the 'max area' rule.\n    final_dims = None\n    # Choose A if it's applicable (dims_A is not None) AND its area is >= Area B\n    if dims_A is not None and area_A >= area_B:\n        final_dims = dims_A\n    else:\n        # Otherwise, choose B (either A wasn't applicable or B had a larger area)\n        final_dims = dims_B\n\n    # 7. Ensure final dimensions are at least 1x1.\n    final_height = max(1, final_dims[0])\n    final_width = max(1, final_dims[1])\n\n    # 8. Create the output grid with the final dimensions, filled with white (0).\n    output_grid_np = np.zeros((final_height, final_width), dtype=int)\n\n    # 9. Convert back to list of lists and return.\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28308,
    "candidates_token_count": 1836,
    "total_token_count": 30144,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.921609,
  "retries": 1
}