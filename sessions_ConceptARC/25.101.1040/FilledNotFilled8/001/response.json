{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation rule:\n1. Identify the primary non-white color (C) and the single contiguous object made of this color in the input grid.\n2. Determine if the object is \"solid\" or \"hollow\".\n    - An object is \"solid\" if at least one pixel of color C has all 8 of its neighbors also being color C.\n    - Otherwise, the object is \"hollow\".\n3. If the object is \"solid\", create an \"outline\" of the object.\n    - The outline consists of only those pixels of color C from the input that were adjacent (8 directions) to at least one background pixel (0). All other pixels become background (0).\n4. If the object is \"hollow\", create a \"filled\" version of the shape.\n    - Start with the input grid.\n    - Change any background pixel (0) to color C if it has pixels of color C both to its left and right on the same row, OR if it has pixels of color C both above and below it in the same column.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Tuple, Set\n\ndef _get_neighbors(r: int, c: int, height: int, width: int) -> List[Tuple[int, int]]:\n    \"\"\"Get valid 8-directional neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_object_pixels(grid: np.ndarray) -> Tuple[int, Set[Tuple[int, int]]]:\n    \"\"\"Find the non-background color and the set of coordinates for the object.\"\"\"\n    object_color = -1\n    object_pixels = set()\n    height, width = grid.shape\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                if object_color == -1:\n                    object_color = grid[r, c]\n                elif grid[r, c] != object_color:\n                    # Assuming only one object color besides background\n                    # This case shouldn't happen based on examples, but good practice\n                    pass # Or raise an error\n                \n                if grid[r, c] == object_color:\n                     object_pixels.add((r, c))\n\n    if object_color == -1: # Handle case of all background\n        object_color = 0 # Default to background if no object found\n\n    return object_color, object_pixels\n\ndef _is_solid(grid: np.ndarray, object_pixels: Set[Tuple[int, int]], object_color: int) -> bool:\n    \"\"\"Check if any object pixel has all 8 neighbors of the same object color.\"\"\"\n    height, width = grid.shape\n    for r, c in object_pixels:\n        neighbors = _get_neighbors(r, c, height, width)\n        if len(neighbors) < 8: # Pixel on the edge cannot be fully surrounded\n             continue\n        \n        all_neighbors_are_object_color = True\n        for nr, nc in neighbors:\n            if grid[nr, nc] != object_color:\n                all_neighbors_are_object_color = False\n                break\n        \n        if all_neighbors_are_object_color:\n            return True # Found an interior pixel, so it's solid\n            \n    return False # No interior pixel found\n\ndef _create_outline(grid: np.ndarray, object_pixels: Set[Tuple[int, int]], object_color: int) -> np.ndarray:\n    \"\"\"Keep only object pixels adjacent to background.\"\"\"\n    height, width = grid.shape\n    output_grid = np.zeros_like(grid) # Start with all background\n\n    for r, c in object_pixels:\n        is_boundary = False\n        neighbors = _get_neighbors(r, c, height, width)\n        for nr, nc in neighbors:\n            if grid[nr, nc] == 0: # Check if adjacent to background\n                is_boundary = True\n                break\n        \n        if is_boundary:\n            output_grid[r, c] = object_color\n            \n    return output_grid\n\ndef _fill_shape(grid: np.ndarray, object_color: int) -> np.ndarray:\n    \"\"\"Fill the shape defined by the hollow object.\"\"\"\n    height, width = grid.shape\n    output_grid = grid.copy() # Start with the input grid\n\n    for r in range(height):\n        for c in range(width):\n            if output_grid[r, c] == 0: # Only consider filling background pixels\n                # Check horizontal containment\n                found_left = any(output_grid[r, j] == object_color for j in range(c))\n                found_right = any(output_grid[r, j] == object_color for j in range(c + 1, width))\n                horizontal_contained = found_left and found_right\n\n                # Check vertical containment\n                found_up = any(output_grid[i, c] == object_color for i in range(r))\n                found_down = any(output_grid[i, c] == object_color for i in range(r + 1, height))\n                vertical_contained = found_up and found_down\n\n                # Fill if horizontally OR vertically contained\n                if horizontal_contained or vertical_contained:\n                    output_grid[r, c] = object_color\n                    \n    return output_grid\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by either filling a hollow shape or creating an outline \n    of a solid shape.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Find the object's color and pixel coordinates\n    object_color, object_pixels = _find_object_pixels(grid_np)\n\n    # Handle edge case: no object found or empty grid\n    if object_color == 0 or not object_pixels:\n        return input_grid # Return original grid if no object pixels\n\n    # Determine if the object is solid or hollow\n    solid = _is_solid(grid_np, object_pixels, object_color)\n\n    # Apply the corresponding transformation\n    if solid:\n        # If solid, create the outline\n        output_grid_np = _create_outline(grid_np, object_pixels, object_color)\n    else:\n        # If hollow, fill the shape\n        # Note: The fill logic needs the original pixel locations, \n        # so we pass the original grid_np, not just object_pixels\n        output_grid_np = _fill_shape(grid_np, object_color)\n\n    # Convert the resulting numpy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3710,
    "candidates_token_count": 2526,
    "total_token_count": 6236,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.880769,
  "retries": 1
}