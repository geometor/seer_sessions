{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies all unique non-background colors in the input grid.\nFor each color, finds and counts the number of distinct contiguous objects (using 8-way adjacency).\nSelects the color(s) with the maximum number of objects.\nIf there's a tie in the object count, calculates the bounding box encompassing all pixels of each tied color.\nSelects the color among the tied ones whose bounding box has the largest area (height * width).\nDetermines the bounding box of the finally selected color.\nCreates an output grid with the dimensions of this final bounding box, filled entirely with the selected color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_objects(grid: np.ndarray, color: int) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds all distinct contiguous objects of a given color in the grid.\n    Uses Breadth-First Search (BFS) with 8-way adjacency.\n\n    Args:\n        grid: The input grid as a NumPy array.\n        color: The target color to find objects for.\n\n    Returns:\n        A list of sets, where each set contains the (row, col) coordinates\n        of the pixels belonging to one object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    # Define 8-way adjacent neighbor offsets\n    neighbors = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),           (0, 1),\n        (1, -1), (1, 0), (1, 1),\n    ]\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                # Start BFS for a new object\n                current_object = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_object.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Explore neighbors\n                    for dr, dc in neighbors:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds and if the neighbor is the correct color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_object.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                objects.append(current_object)\n                \n    return objects\n\ndef _get_bounding_box(grid: np.ndarray, color: int) -> tuple[int, int, int, int, int, int] | None:\n    \"\"\"\n    Calculates the bounding box enclosing all pixels of a given color.\n\n    Args:\n        grid: The input grid as a NumPy array.\n        color: The target color.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col, height, width) \n        or None if the color is not present.\n    \"\"\"\n    coords = np.argwhere(grid == color)\n    if coords.size == 0:\n        return None\n        \n    min_row, min_col = coords.min(axis=0)\n    max_row, max_col = coords.max(axis=0)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    return min_row, min_col, max_row, max_col, height, width\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on object count and bounding box area.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    \n    # 1. Identify unique non-background colors\n    unique_colors = np.unique(grid[grid != 0]) # Exclude background color 0 (white)\n    \n    if unique_colors.size == 0:\n        # Handle edge case: input grid is all background or empty\n        return [] \n        \n    # 2. & 3. Find objects and count for each color\n    object_counts = {}\n    for color in unique_colors:\n        objects = _find_objects(grid, color)\n        object_counts[color] = len(objects)\n\n    # 4. Determine max object count and candidate colors\n    if not object_counts: # Should not happen if unique_colors > 0, but for safety\n        return []\n    max_count = max(object_counts.values())\n    candidate_colors = [color for color, count in object_counts.items() if count == max_count]\n    \n    selected_color = -1 # Initialize\n\n    # 5. Check if only one candidate\n    if len(candidate_colors) == 1:\n        selected_color = candidate_colors[0]\n    else:\n        # 6. Tie-breaker: Largest bounding box area\n        max_area = -1\n        best_color = -1\n        \n        for color in candidate_colors:\n            bbox = _get_bounding_box(grid, color)\n            if bbox:\n                _, _, _, _, height, width = bbox\n                area = height * width\n                # print(f\"Color {color}: Area {area}\") # Debug print\n                if area > max_area:\n                    max_area = area\n                    best_color = color\n                # If areas are equal, the first one encountered with max area is kept.\n                # Could add secondary tie-breaker (e.g., lowest color index) if needed.\n                \n        selected_color = best_color\n\n    if selected_color == -1:\n         # Should not happen if there were unique colors, but handle defensively\n        return [] \n\n    # 7. Get final bounding box for the selected color\n    final_bbox = _get_bounding_box(grid, selected_color)\n    if not final_bbox:\n        # Should not happen if the color was selected, but handle defensively\n        return []\n        \n    _, _, _, _, output_height, output_width = final_bbox\n    \n    # 8. & 9. Create and fill the output grid\n    output_grid_np = np.full((output_height, output_width), selected_color, dtype=int)\n    \n    return output_grid_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3176,
    "candidates_token_count": 2591,
    "total_token_count": 5767,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.269251,
  "retries": 1
}