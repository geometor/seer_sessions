{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the transformation rule for a grid based on the uniformity of its corner pixels.\n\n1. Check if all four corner pixels (top-left, top-right, bottom-left, bottom-right) of the input grid have the same color.\n2. If the corners DO NOT match:\n   - Find the most frequent color across the entire grid (overall dominant color). Break ties by choosing the smallest color index.\n   - Fill the output grid entirely with this overall dominant color.\n3. If the corners DO match:\n   - Identify the common corner color as the 'background_color'.\n   - Identify all pixels that are NOT the background_color as 'foreground_pixels'.\n   - Find the most frequent color among the foreground_pixels ('dominant_foreground_color'). Break ties by choosing the smallest color index. Handle the case where there are no foreground pixels.\n   - Find the most frequent color across the entire grid ('overall_dominant_color'). Break ties similarly.\n   - If the dominant_foreground_color is the same as the background_color, OR if the background_color is the same as the overall_dominant_color:\n     - Fill the output grid entirely with the background_color.\n   - Otherwise:\n     - Create an output grid filled initially with the background_color.\n     - For every position where the input grid had a foreground_pixel, set the corresponding position in the output grid to the dominant_foreground_color.\n4. Return the resulting output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_dominant_color(pixels: np.ndarray) -> int | None:\n    \"\"\"\n    Finds the most frequent color in a flattened array of pixels.\n    Handles ties by returning the smallest color index.\n    Returns None if the input array is empty.\n    \"\"\"\n    if pixels.size == 0:\n        return None # No pixels, no dominant color\n\n    counts = Counter(pixels.flatten())\n    if not counts: # Handles cases like an array of empty lists? Should not happen with numpy arrays normally.\n        return None\n\n    # Find the maximum count\n    max_count = 0\n    for count in counts.values():\n        if count > max_count:\n            max_count = count\n\n    # Get all colors with the maximum count\n    dominant_colors = [color for color, count in counts.items() if count == max_count]\n\n    # Return the smallest color index in case of a tie\n    return min(dominant_colors)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation based on corner uniformity and dominant colors.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier indexing and operations\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Handle edge case of 1x1 grid\n    if height == 1 and width == 1:\n        return input_grid # 1x1 grid is already uniform\n\n    # Check corner pixels\n    top_left = grid_np[0, 0]\n    top_right = grid_np[0, width - 1]\n    bottom_left = grid_np[height - 1, 0]\n    bottom_right = grid_np[height - 1, width - 1]\n\n    corners_match = (top_left == top_right == bottom_left == bottom_right)\n\n    if corners_match:\n        # Case 1: Corners match\n        background_color = top_left\n\n        # Identify foreground pixels (pixels not matching the background)\n        foreground_mask = (grid_np != background_color)\n        foreground_pixels = grid_np[foreground_mask]\n\n        # Find dominant foreground color\n        dominant_foreground_color = find_dominant_color(foreground_pixels)\n\n        # Handle case where there are no foreground pixels\n        if dominant_foreground_color is None:\n             # If no foreground, the grid is already uniform with the background color\n             output_grid_np = np.full_like(grid_np, background_color)\n             return output_grid_np.tolist() # Return early\n\n        # Find overall dominant color\n        overall_dominant_color = find_dominant_color(grid_np) # Cannot be None here unless grid is empty (checked earlier implicitly)\n\n        # Decision logic based on colors\n        if dominant_foreground_color == background_color or background_color == overall_dominant_color:\n            # Fill output grid entirely with background_color\n            output_grid_np = np.full_like(grid_np, background_color)\n        else:\n            # Initialize output with background color\n            output_grid_np = np.full_like(grid_np, background_color)\n            # Place dominant foreground color where foreground pixels were\n            output_grid_np[foreground_mask] = dominant_foreground_color\n\n    else:\n        # Case 2: Corners do not match\n        # Find the overall dominant color\n        overall_dominant_color = find_dominant_color(grid_np)\n        # Fill the entire output grid with the overall dominant color\n        # Handle potential None case if grid was somehow empty, though unlikely\n        fill_color = overall_dominant_color if overall_dominant_color is not None else 0 # Default fill if somehow empty\n        output_grid_np = np.full_like(grid_np, fill_color)\n\n\n    # Convert the NumPy array back to a list of lists for the final output\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10919,
    "candidates_token_count": 1680,
    "total_token_count": 12599,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.404617,
  "retries": 1
}