{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nChecks if the input grid has a uniform border (all perimeter pixels are the same color).\nIf a uniform border exists:\n  - The border pixels in the output grid retain the border color.\n  - All interior pixels (not on the border) in the output grid are filled with the most frequent color found within the interior region of the input grid.\nIf no uniform border exists:\n  - The entire output grid is filled with the single most frequent color found across the entire input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_dominant_color(pixels: np.ndarray) -> int:\n    \"\"\"\n    Finds the most frequent color in a flattened array of pixels.\n    Handles ties by returning the smallest color index.\n    \"\"\"\n    if pixels.size == 0:\n        # Handle empty region case if necessary, though unlikely based on examples\n        return 0 # Default to white or raise error? Defaulting for now.\n    \n    counts = Counter(pixels.flatten())\n    # Find the maximum count\n    max_count = 0\n    for color, count in counts.items():\n        if count > max_count:\n            max_count = count\n            \n    # Get all colors with the maximum count\n    dominant_colors = [color for color, count in counts.items() if count == max_count]\n    \n    # Return the smallest color index in case of a tie\n    return min(dominant_colors)\n\ndef has_uniform_border(grid: np.ndarray) -> tuple[bool, int | None]:\n    \"\"\"\n    Checks if the grid has a uniform border.\n    Returns (True, border_color) if uniform, otherwise (False, None).\n    Handles 1xN and Nx1 grids.\n    \"\"\"\n    height, width = grid.shape\n    \n    # Handle trivial cases (1x1 grid has a 'uniform' border)\n    if height == 1 and width == 1:\n        return True, grid[0, 0]\n        \n    border_color = grid[0, 0]\n    \n    # Check top and bottom rows\n    if height > 0:\n        for c in range(width):\n            if grid[0, c] != border_color:\n                return False, None\n            if height > 1 and grid[height - 1, c] != border_color:\n                 return False, None\n                 \n    # Check left and right columns (excluding corners already checked)\n    if width > 0:\n        for r in range(1, height - 1): # Exclude corners\n            if grid[r, 0] != border_color:\n                 return False, None\n            if width > 1 and grid[r, width - 1] != border_color:\n                return False, None\n\n    return True, border_color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on border detection and dominant color filling.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier slicing and operations\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n    \n    # Initialize output_grid as a NumPy array of the same shape\n    output_grid_np = np.zeros_like(grid_np)\n\n    # Check for a uniform border\n    is_uniform, border_color = has_uniform_border(grid_np)\n\n    if is_uniform and border_color is not None:\n        # Case 1: Uniform border exists\n        \n        # Define the interior region (handle grids smaller than 3x3)\n        if height > 2 and width > 2:\n            interior_region = grid_np[1:-1, 1:-1]\n        elif height <= 2 or width <= 2 : # No interior if height/width is 1 or 2\n             interior_region = np.array([]) # empty interior\n        # else: # This logic seems redundant given the check for <=2 above. Simplified.\n        #     interior_region = np.array([]) # Should not happen if is_uniform is True unless 1xN or Nx1 with H,W > 2? No, handled above.\n\n        # Find the dominant color in the interior\n        # If interior is empty (e.g., 2xN grid), dominant color doesn't matter as it won't be used.\n        # Default to border color if interior is empty to avoid errors, though fill logic handles this.\n        dominant_interior_color = find_dominant_color(interior_region) if interior_region.size > 0 else border_color\n\n        # Create the output grid: Fill interior first\n        output_grid_np.fill(dominant_interior_color)\n        \n        # Apply the border color to the perimeter\n        if height > 0:\n            output_grid_np[0, :] = border_color  # Top row\n            if height > 1:\n                output_grid_np[height - 1, :] = border_color # Bottom row\n        if width > 0:\n             output_grid_np[:, 0] = border_color  # Left column\n             if width > 1:\n                output_grid_np[:, width - 1] = border_color # Right column\n                \n    else:\n        # Case 2: No uniform border\n        \n        # Find the dominant color across the entire grid\n        overall_dominant_color = find_dominant_color(grid_np)\n        \n        # Fill the entire output grid with the overall dominant color\n        output_grid_np.fill(overall_dominant_color)\n\n    # Convert the NumPy array back to a list of lists for the final output\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2934,
    "candidates_token_count": 1831,
    "total_token_count": 4765,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 14.329683,
  "retries": 1
}