{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid based on the uniformity of its corner pixels and a comparison between the corner color and the overall dominant color.\n\n1.  Examine the four corner pixels (top-left, top-right, bottom-left, bottom-right).\n2.  If the four corner pixels do NOT all have the same color:\n    a.  Find the 'overall_dominant_color' (most frequent color across the entire grid, ties broken by smallest color index).\n    b.  Fill the entire output grid with the 'overall_dominant_color'.\n3.  If the four corner pixels DO all have the same color:\n    a.  Identify this common corner color as the 'background_color'.\n    b.  Find the 'overall_dominant_color'.\n    c.  If the 'background_color' is the same as the 'overall_dominant_color':\n        i. Fill the entire output grid with the 'background_color'.\n    d.  Else (the 'background_color' is different from the 'overall_dominant_color'):\n        i. Identify 'interior_pixels' (not on the perimeter).\n        ii. Find the 'dominant_interior_non_background_color' (most frequent color among interior pixels whose color is not 'background_color', ties broken by smallest index).\n        iii. Create the output grid.\n        iv. Fill all perimeter pixels of the output grid with 'background_color'.\n        v. Fill interior pixels: if the corresponding input pixel was 'background_color', use 'background_color'; otherwise, use 'dominant_interior_non_background_color'. (Handles grids < 3x3 correctly as they have no interior to modify).\n4.  Return the resulting output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef find_dominant_color(pixels: np.ndarray) -> int | None:\n    \"\"\"\n    Finds the most frequent color in a flattened array of pixels.\n    Handles ties by returning the smallest color index.\n    Returns None if the input array is empty.\n    \"\"\"\n    if pixels.size == 0:\n        return None # No pixels, no dominant color\n\n    counts = Counter(pixels.flatten())\n    if not counts: # Check if counter is empty\n        return None\n\n    # Find the maximum count\n    max_count = 0\n    # Use counts.most_common(1) for potentially slightly better performance?\n    # Or iterate as before:\n    for count in counts.values():\n         if count > max_count:\n             max_count = count\n\n    # Get all colors with the maximum count\n    dominant_colors = [color for color, count in counts.items() if count == max_count]\n\n    # Return the smallest color index in case of a tie\n    return min(dominant_colors)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation based on corner uniformity and dominant colors.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier indexing and operations\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Handle edge case of 1x1 grid (already uniform)\n    if height == 1 and width == 1:\n        return input_grid\n\n    # Check corner pixels\n    top_left = grid_np[0, 0]\n    top_right = grid_np[0, width - 1]\n    bottom_left = grid_np[height - 1, 0]\n    bottom_right = grid_np[height - 1, width - 1]\n\n    corners_match = (top_left == top_right == bottom_left == bottom_right)\n\n    if not corners_match:\n        # Case 1: Corners do not match\n        # Find the overall dominant color\n        overall_dominant_color = find_dominant_color(grid_np)\n        # Fill the entire output grid with the overall dominant color\n        # Handle case where grid is empty (shouldn't happen based on ARC constraints)\n        fill_color = overall_dominant_color if overall_dominant_color is not None else 0 # Default fill\n        output_grid_np = np.full_like(grid_np, fill_color)\n\n    else:\n        # Case 2: Corners match\n        background_color = top_left\n\n        # Find overall dominant color\n        overall_dominant_color = find_dominant_color(grid_np)\n        \n        # Check if background color is the overall dominant color\n        if background_color == overall_dominant_color:\n            # Subcase 2a: Background IS dominant\n            # Fill output grid entirely with background_color\n            output_grid_np = np.full_like(grid_np, background_color)\n        else:\n            # Subcase 2b: Background is NOT dominant\n            # Initialize output grid with background color (covers perimeter and background pixels in interior)\n            output_grid_np = np.full_like(grid_np, background_color)\n\n            # Check if grid has an interior region\n            if height > 2 and width > 2:\n                # Extract interior region from input\n                interior_region = grid_np[1:-1, 1:-1]\n                \n                # Find pixels in the interior that are not the background color\n                interior_non_background_pixels = interior_region[interior_region != background_color]\n                \n                # Find the dominant color among these non-background interior pixels\n                dominant_interior_fill_color = find_dominant_color(interior_non_background_pixels)\n\n                # If there were non-background pixels in the interior, fill them in the output\n                if dominant_interior_fill_color is not None:\n                    # Iterate through interior indices and update output grid\n                    for r in range(1, height - 1):\n                        for c in range(1, width - 1):\n                            if grid_np[r, c] != background_color:\n                                output_grid_np[r, c] = dominant_interior_fill_color\n            # Else (no interior): The grid is already correctly filled with background_color\n\n\n    # Convert the final NumPy array back to a list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18162,
    "candidates_token_count": 2829,
    "total_token_count": 20991,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.987102,
  "retries": 1
}