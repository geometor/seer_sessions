{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all contiguous non-white objects in the input grid. Filters these \nobjects to find those whose pixels exactly form the perimeter of their square \nbounding box. Selects the square perimeter object with the largest bounding box \nsize (side length). Creates a new output grid of the same size as the selected \nobject's bounding box. The output grid contains a hollow square frame: the \nperimeter is filled with the color of the selected object, and the interior \nis filled with white (0).\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its color, set of pixel coordinates, and bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != 0: # Non-white and not visited\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (4-directional)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef is_square_perimeter(obj: dict) -> tuple[bool, int]:\n    \"\"\"\n    Checks if an object's pixels form the exact perimeter of its square bounding box.\n\n    Args:\n        obj: A dictionary representing an object with 'color', 'pixels', and 'bbox'.\n\n    Returns:\n        A tuple: (True, side_length) if it's a square perimeter, \n                 (False, 0) otherwise.\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Check if the bounding box is a square\n    if width != height:\n        return False, 0\n        \n    side_length = width # or height\n    \n    # Check if it's just a single point (1x1 square) - technically a perimeter, but trivial\n    if side_length == 1:\n        return len(obj['pixels']) == 1, 1\n\n    # Calculate expected perimeter pixels\n    expected_perimeter_pixels = set()\n    # Top and bottom rows\n    for c in range(min_c, max_c + 1):\n        expected_perimeter_pixels.add((min_r, c))\n        expected_perimeter_pixels.add((max_r, c))\n    # Left and right columns (excluding corners already added)\n    for r in range(min_r + 1, max_r):\n        expected_perimeter_pixels.add((r, min_c))\n        expected_perimeter_pixels.add((r, max_c))\n\n    # Check if the object's pixels exactly match the calculated perimeter pixels\n    if obj['pixels'] == expected_perimeter_pixels:\n        return True, side_length\n    else:\n        return False, 0\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by finding the largest square perimeter object and \n    outputting it as a hollow square frame.\n    \"\"\"\n    \n    # Convert input list of lists to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # 1. Scan the input grid to identify all distinct contiguous blocks of non-white pixels.\n    objects = find_objects(grid_np)\n    \n    # 2. & 3. Filter objects to find those that are square perimeters.\n    square_perimeters = []\n    for obj in objects:\n        is_sq_perimeter, side_length = is_square_perimeter(obj)\n        if is_sq_perimeter:\n            obj['side_length'] = side_length\n            square_perimeters.append(obj)\n\n    # Handle cases where no square perimeter is found\n    if not square_perimeters:\n        # Based on examples, we expect at least one. \n        # Returning an empty grid or handling as an error might be appropriate.\n        # Let's return an empty grid for now if this unexpected case occurs.\n        return [] \n\n    # 4. Identify the square perimeter object with the maximum side length.\n    largest_perimeter_obj = max(square_perimeters, key=lambda obj: obj['side_length'])\n\n    # 5. Get the properties of the largest perimeter object.\n    color = largest_perimeter_obj['color']\n    side = largest_perimeter_obj['side_length']\n    \n    # 6. Create a new output grid of the determined size, initialized to white (0).\n    output_grid_np = np.zeros((side, side), dtype=int)\n\n    # 7. Fill the perimeter cells of the output grid with the object's color.\n    if side > 0:\n        output_grid_np[0, :] = color    # Top row\n        output_grid_np[-1, :] = color   # Bottom row\n        output_grid_np[:, 0] = color    # Left column\n        output_grid_np[:, -1] = color   # Right column\n        \n    # 8. Interior is already filled with white (0) due to np.zeros initialization.\n\n    # 9. Convert numpy array back to list of lists for the final output.\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10919,
    "candidates_token_count": 2030,
    "total_token_count": 12949,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 14.438311,
  "retries": 1
}