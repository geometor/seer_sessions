{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\n\n\"\"\"\nThis transformation rule identifies three key colors in the input grid: Background (B), Subject (S), and Reactant (R).\nThe Background color is assumed to be the most frequent color (typically white/0). \nAmong the two other dominant non-background colors, the Subject (S) color is identified as the one that occurs less frequently in the input grid, and the remaining color is the Reactant (R).\n\nThe transformation proceeds in two main steps, modifying only the pixels with the Subject color:\n\n1.  **Change to Reactant Color:** Any Subject pixel that is cardinally adjacent (up, down, left, right) to a Reactant pixel changes its color to the Reactant color.\n\n2.  **Change to Background Color:** Any Subject pixel that did *not* change in step 1 is then considered. If such a pixel is cardinally adjacent to a Background pixel AND it is *not* cardinally adjacent to any \"stable\" Subject pixel (i.e., another Subject pixel that is also *not* changing to the Reactant color in step 1), then it changes its color to the Background color.\n\nPixels that are not Subject color, or Subject pixels that do not meet the conditions for changing to Reactant or Background color, remain unchanged. The changes identified in step 1 take precedence.\n\"\"\"\n\ndef identify_colors(grid: list[list[int]]) -> tuple[int, int, int]:\n    \"\"\"\n    Identifies the Background (B), Subject (S), and Reactant (R) colors.\n    Assumes Background is the most frequent color.\n    Assumes Subject is the less frequent of the two other main colors.\n    \n    Args:\n        grid: The input grid.\n        \n    Returns:\n        A tuple (background_color, subject_color, reactant_color).\n        Returns (None, None, None) if fewer than 3 distinct colors are present.\n    \"\"\"\n    counts = collections.Counter(cell for row in grid for cell in row)\n    \n    if len(counts) < 3:\n        # Cannot determine B, S, R if fewer than 3 colors exist.\n        # Or handle specific cases? For now, assume task always has 3+.\n         # Find the most frequent color anyway for B\n        if not counts: return (0, -1, -1) # Empty grid defaults\n        background_color = counts.most_common(1)[0][0]\n        \n        non_background_colors = [c for c in counts if c != background_color]\n        if len(non_background_colors) == 1:\n            # Only B and one other color. Let's call the other S. No R.\n            return (background_color, non_background_colors[0], -1) \n        elif len(non_background_colors) == 0:\n             # Only B color\n             return (background_color, -1, -1)\n        else: # Should not happen based on initial check, but defensive coding\n            return (background_color, -1, -1)\n\n\n    # More than 3 colors, but let's focus on the top 3 frequencies\n    # B is the most frequent\n    background_color = counts.most_common(1)[0][0]\n    \n    # Find the two most frequent non-background colors\n    non_background_counts = {k: v for k, v in counts.items() if k != background_color}\n    \n    if len(non_background_counts) < 2:\n         # Handle cases with only B and one other color, or just B\n        if len(non_background_counts) == 1:\n             return (background_color, list(non_background_counts.keys())[0], -1)\n        else:\n             return (background_color, -1, -1)\n\n\n    # Sort non-background colors by frequency (ascending)\n    sorted_non_background = sorted(non_background_counts.items(), key=lambda item: item[1])\n    \n    # Assume Subject (S) is the least frequent of the two main non-background colors\n    # Assume Reactant (R) is the more frequent of the two\n    # This handles cases where there might be other minor colors present.\n    # We consider the two *most frequent* non-background colors.\n    if len(sorted_non_background) >= 2:\n        subject_color = sorted_non_background[0][0]\n        reactant_color = sorted_non_background[1][0]\n        # Check if R might actually be less frequent than S among top 2 non-bg\n        if counts[subject_color] > counts[reactant_color]:\n             subject_color, reactant_color = reactant_color, subject_color # Swap\n    else: # Only one non-background color\n         subject_color = sorted_non_background[0][0]\n         reactant_color = -1 # Indicate no reactant color\n\n    return background_color, subject_color, reactant_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on neighbor interactions.\n    Identifies Background (B), Subject (S), and Reactant (R) colors.\n    S pixels change to R if adjacent to R.\n    Remaining S pixels change to B if adjacent to B and not adjacent to a stable S pixel.\n    \"\"\"\n    \n    output_grid = [row[:] for row in input_grid] # Deep copy\n    height = len(input_grid)\n    if height == 0:\n        return []\n    width = len(input_grid[0])\n    if width == 0:\n        return [[] for _ in range(height)]\n\n    # 1. Identify the three primary colors\n    background_color, subject_color, reactant_color = identify_colors(input_grid)\n\n    # Handle edge cases where colors couldn't be identified properly\n    if subject_color == -1: # No subject color found\n        return output_grid # Return copy of input as no transformation applies\n\n    changes_to_R = set()\n    changes_to_B = set()\n    \n    # Define cardinal directions\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # 3. First Pass: Identify Subject pixels changing to Reactant color\n    # Skip this pass if no reactant color identified\n    if reactant_color != -1:\n        for r in range(height):\n            for c in range(width):\n                if input_grid[r][c] == subject_color:\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < height and 0 <= nc < width:\n                            if input_grid[nr][nc] == reactant_color:\n                                changes_to_R.add((r, c))\n                                break # Found an R neighbor, mark for change and stop checking neighbors for this pixel\n\n    # 4. Second Pass: Identify Subject pixels changing to Background color\n    for r in range(height):\n        for c in range(width):\n            # Consider only Subject pixels that are NOT already changing to R\n            if input_grid[r][c] == subject_color and (r, c) not in changes_to_R:\n                has_B_neighbor = False\n                has_protecting_S_neighbor = False\n                \n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < height and 0 <= nc < width:\n                        neighbor_color = input_grid[nr][nc]\n                        # Check for Background neighbor\n                        if neighbor_color == background_color:\n                            has_B_neighbor = True\n                        # Check for stable Subject neighbor\n                        elif neighbor_color == subject_color and (nr, nc) not in changes_to_R:\n                            has_protecting_S_neighbor = True\n                            \n                # Apply the rule: Change to B if adjacent to B AND NOT protected by a stable S\n                if has_B_neighbor and not has_protecting_S_neighbor:\n                    changes_to_B.add((r, c))\n\n    # 5. Modify the output grid based on the collected changes\n    for r, c in changes_to_R:\n        output_grid[r][c] = reactant_color\n        \n    for r, c in changes_to_B:\n        output_grid[r][c] = background_color\n\n    # 6. Return the final output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3286,
    "candidates_token_count": 3767,
    "total_token_count": 7053,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 30.273446,
  "retries": 1
}