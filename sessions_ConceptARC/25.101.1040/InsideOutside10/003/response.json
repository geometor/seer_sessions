{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\nfrom collections import deque\n\n\"\"\"\nThe transformation rule identifies three key colors in the input grid: Background (B), Subject (S), and Reactant (R).\n- Background (B) is the most frequent color.\n- Subject (S) is the less frequent of the two most common non-background colors.\n- Reactant (R) is the more frequent of the two most common non-background colors.\n\nThe transformation modifies only the Subject (S) pixels based on their cardinal neighbors in the input grid:\n\n1.  **Change to Reactant (R):** An S pixel changes to R if it is cardinally adjacent to an R pixel. This rule has the highest priority.\n2.  **Protection:** An S pixel P (that is not changing to R) is considered \"protected\" if it is cardinally adjacent to another S pixel P' which IS changing to R (Rule 1), OR if P is cardinally adjacent to another S pixel P'' which is itself \"protected\". Protection propagates through contiguous S pixels originating from those adjacent to S->R pixels.\n3.  **Change to Background (B):** An S pixel changes to B if it is NOT changing to R (Rule 1), IS cardinally adjacent to a B pixel, AND is NOT \"protected\" (Rule 2).\n4.  **Remain Subject (S):** If an S pixel does not meet the conditions to change to R or B, it remains S.\n\"\"\"\n\ndef identify_colors(grid: list[list[int]]) -> tuple[int | None, int | None, int | None]:\n    \"\"\"\n    Identifies the Background (B), Subject (S), and Reactant (R) colors.\n    Assumes B is most frequent.\n    Assumes S is less frequent non-B, R is more frequent non-B.\n    \n    Args:\n        grid: The input grid.\n        \n    Returns:\n        A tuple (background_color, subject_color, reactant_color).\n        Returns (None, None, None) if roles cannot be determined (e.g., < 3 colors).\n    \"\"\"\n    counts = collections.Counter(cell for row in grid for cell in row)\n    \n    if not counts:\n        return 0, None, None # Default for empty grid\n\n    # Sort by count descending, then color value ascending\n    sorted_counts = sorted(counts.items(), key=lambda item: (-item[1], item[0]))\n\n    if len(sorted_counts) < 3:\n        # Handle cases with 1 or 2 colors\n        background_color = sorted_counts[0][0]\n        if len(sorted_counts) == 1:\n             return background_color, None, None\n        else: # Exactly 2 colors\n             # Treat the second color as S? Or R? The logic requires S and R.\n             # Let's assume the less frequent non-bg is S. Here there's only one non-bg.\n             subject_color = sorted_counts[1][0]\n             return background_color, subject_color, None # No Reactant\n\n    background_color = sorted_counts[0][0]\n    \n    # Consider the top two most frequent non-background colors\n    non_background_counts = {k: v for k, v in counts.items() if k != background_color}\n    \n    # Sort non-background by count ascending, then color index ascending\n    sorted_non_bg = sorted(non_background_counts.items(), key=lambda item: (item[1], item[0]))\n\n    # S is the one with the lower count, R is the one with the higher count among the two main ones\n    # If counts are equal, lower color index is S, higher is R.\n    subject_color = sorted_non_bg[0][0]\n    reactant_color = sorted_non_bg[1][0]\n\n    # Verify assumption: S is less frequent than R\n    if counts[subject_color] > counts[reactant_color]:\n         subject_color, reactant_color = reactant_color, subject_color # Swap\n\n    return background_color, subject_color, reactant_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # Initialize output_grid as a deep copy\n    output_grid = [row[:] for row in input_grid]\n\n    # 1. Identify Colors\n    background_color, subject_color, reactant_color = identify_colors(input_grid)\n\n    # If S or R cannot be determined, no transformation occurs based on the rules\n    if subject_color is None or reactant_color is None:\n        return output_grid\n\n    # Define cardinal directions\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # 2. Identify S->R Changes\n    changes_to_R = set()\n    for r in range(height):\n        for c in range(width):\n            if input_grid[r][c] == subject_color:\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == reactant_color:\n                        changes_to_R.add((r, c))\n                        break # Move to next pixel once an R neighbor is found\n\n    # 3. Identify Protected S Pixels using BFS\n    protected_S = set()\n    queue = deque()\n\n    # Initial protected set: S pixels (not changing to R) adjacent to S->R pixels\n    for r_change, c_change in changes_to_R:\n        for dr, dc in directions:\n            nr, nc = r_change + dr, c_change + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbor_coord = (nr, nc)\n                if input_grid[nr][nc] == subject_color and neighbor_coord not in changes_to_R and neighbor_coord not in protected_S:\n                    protected_S.add(neighbor_coord)\n                    queue.append(neighbor_coord)\n\n    # Propagate protection\n    while queue:\n        pr, pc = queue.popleft()\n        for dr, dc in directions:\n            nr, nc = pr + dr, pc + dc\n            neighbor_coord = (nr, nc)\n            if 0 <= nr < height and 0 <= nc < width:\n                 if input_grid[nr][nc] == subject_color and neighbor_coord not in changes_to_R and neighbor_coord not in protected_S:\n                     protected_S.add(neighbor_coord)\n                     queue.append(neighbor_coord)\n\n    # 4. Apply Changes to Output Grid\n    # Apply S->R changes first\n    for r, c in changes_to_R:\n        output_grid[r][c] = reactant_color\n\n    # Apply S->B changes\n    for r in range(height):\n        for c in range(width):\n            coord = (r, c)\n            # Consider only S pixels that did NOT change to R\n            if input_grid[r][c] == subject_color and coord not in changes_to_R:\n                is_adjacent_to_B = False\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == background_color:\n                        is_adjacent_to_B = True\n                        break\n                \n                # Change to B if adjacent to B AND not protected\n                if is_adjacent_to_B and coord not in protected_S:\n                    output_grid[r][c] = background_color\n                    \n    # 5. Return the final output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21307,
    "candidates_token_count": 2109,
    "total_token_count": 23416,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 17.238859,
  "retries": 1
}