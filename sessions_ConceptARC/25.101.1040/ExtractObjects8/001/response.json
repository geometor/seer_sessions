{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on finding a frame and analyzing its inner content.\n1. Finds the background color (most frequent).\n2. Finds potential frame candidates (connected components of non-background colors).\n3. Validates candidates to find *the* unique, 1-pixel thick, hollow rectangular frame\n   that encloses only background-colored pixels.\n4. Extracts the inner content grid.\n5. If the inner content is square, return the inner content grid.\n6. If the inner content is rectangular, construct an output grid based on repeating\n   columns derived from the inner content and frame color, matching the frame's height.\n\"\"\"\n\ndef find_background_color(grid_np):\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    # Fallback for empty grid\n    if grid_np.size == 0:\n        return 0 # Default to white/0 if grid is empty\n        \n    colors, counts = np.unique(grid_np, return_counts=True)\n    # Handle tie-breaking if needed, though typically not required in ARC\n    # For simplicity, np.argmax takes the first max occurrence.\n    return colors[np.argmax(counts)]\n\ndef find_potential_frames(grid_np, bg_color):\n    \"\"\"\n    Finds potential frame candidates by identifying connected components of\n    non-background pixels. Returns a list of dictionaries, each containing\n    frame color, bounding box, and the set of pixels in the component.\n    \"\"\"\n    height, width = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    frames = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if we find a non-background pixel not yet visited\n            if grid_np[r, c] != bg_color and not visited[r, c]:\n                frame_color = grid_np[r, c]\n                q = [(r, c)]\n                visited[r, c] = True\n                component_pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                is_single_color_component = True # Assume component uses only frame_color\n\n                # Breadth-First Search to find all connected pixels of this component\n                queue_idx = 0\n                while queue_idx < len(q):\n                    curr_r, curr_c = q[queue_idx]\n                    queue_idx += 1\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity is sufficient for frame borders)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds and if visited\n                        if 0 <= nr < height and 0 <= nc < width and not visited[nr, nc]:\n                            pixel_color = grid_np[nr, nc]\n                            # If neighbor is non-background, process it\n                            if pixel_color != bg_color:\n                                visited[nr, nc] = True\n                                # Check if the color matches the initial frame color\n                                if pixel_color != frame_color:\n                                    is_single_color_component = False\n                                component_pixels.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Store the component if it consists of a single non-background color\n                if is_single_color_component:\n                    frames.append({\n                        \"color\": frame_color,\n                        \"bounds\": (min_r, max_r, min_c, max_c),\n                        \"pixels\": component_pixels\n                    })\n    return frames\n\n\ndef validate_frame(grid_np, frame_info, bg_color):\n    \"\"\"\n    Checks if a potential frame candidate is a valid frame according to the rules:\n    - 1-pixel thick hollow rectangle.\n    - Encloses an area containing *only* the background color.\n    - The component pixels must exactly match the perimeter pixels.\n    \"\"\"\n    r_min, r_max, c_min, c_max = frame_info[\"bounds\"]\n    frame_color = frame_info[\"color\"]\n    height, width = grid_np.shape\n\n    # Frame must be at least 3x3 to enclose anything\n    if r_max - r_min < 2 or c_max - c_min < 2:\n        return False\n\n    # Check if all pixels on the perimeter defined by bounds match the frame_color\n    perimeter_pixels_expected = set()\n    # Top and bottom rows\n    for c in range(c_min, c_max + 1):\n        if grid_np[r_min, c] != frame_color or grid_np[r_max, c] != frame_color:\n            return False\n        perimeter_pixels_expected.add((r_min, c))\n        perimeter_pixels_expected.add((r_max, c))\n    # Left and right columns (excluding corners already checked)\n    for r in range(r_min + 1, r_max):\n        if grid_np[r, c_min] != frame_color or grid_np[r, c_max] != frame_color:\n            return False\n        perimeter_pixels_expected.add((r, c_min))\n        perimeter_pixels_expected.add((r, c_max))\n\n    # Check if the actual pixels found in the component match the expected perimeter pixels\n    # This ensures the shape is exactly the hollow rectangle perimeter and 1-pixel thick\n    if frame_info[\"pixels\"] != perimeter_pixels_expected:\n         return False\n\n    # Check if all inner pixels are the background color\n    for r in range(r_min + 1, r_max):\n        for c in range(c_min + 1, c_max):\n            if grid_np[r, c] != bg_color:\n                return False # Found a non-background pixel inside\n\n    # If all checks pass, it's a valid frame enclosing only background\n    return True\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on finding a frame and analyzing its inner content.\n    Follows the logic derived from the examples and natural language description.\n    \"\"\"\n    if not input_grid or not input_grid[0]:\n        return [] # Handle empty input grid\n\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n\n    # Step 1: Determine background color\n    bg_color = find_background_color(grid_np)\n\n    # Step 2: Find potential frame candidates\n    potential_frames = find_potential_frames(grid_np, bg_color)\n\n    # Step 3: Validate candidates to find the correct frame\n    # We need the unique frame that encloses *only* background pixels.\n    valid_frame = None\n    for frame_info in potential_frames:\n        if validate_frame(grid_np, frame_info, bg_color):\n            if valid_frame is not None:\n                 # This case should ideally not happen based on problem description (\"the unique frame\")\n                 # but example 2 suggests multiple frames might exist.\n                 # If it happens, we might need a more specific rule.\n                 # For now, we stick to the first valid one found.\n                 print(\"Warning: Multiple valid frames found meeting criteria. Using the first one.\")\n            valid_frame = frame_info\n            # Removed break to ensure check for multiple valid frames (for warning)\n            # However, will proceed with the *last* valid frame found if multiple exist.\n            # If uniqueness is guaranteed, this loop finds the one.\n\n    if valid_frame is None:\n        print(\"Error: No valid frame found matching the criteria.\")\n        # Returning input might be required by ARC rules if transformation fails\n        return input_grid\n\n    # Extract frame details\n    frame_color = valid_frame[\"color\"]\n    r_min, r_max, c_min, c_max = valid_frame[\"bounds\"]\n\n    # Step 4: Extract the inner content grid\n    # Validation ensures r_max-r_min >= 2 and c_max-c_min >= 2\n    inner_grid_np = grid_np[r_min + 1 : r_max, c_min + 1 : c_max]\n    CH, CW = inner_grid_np.shape # Inner Content Height, Width\n    FH = r_max - r_min + 1       # Frame Height\n\n    if CH <= 0 or CW <= 0:\n         print(\"Error: Frame found but inner content dimensions are invalid.\")\n         return input_grid # Should not happen if validate_frame is correct\n\n    # Step 5: Check if InnerGrid is square (CH == CW)\n    if CH == CW:\n        # Case_Square: Output is the InnerGrid directly\n        output_grid = inner_grid_np.tolist()\n    else:\n        # Step 6: Case_Rectangle: Construct the new output grid\n        # Output dimensions: CH x FH\n\n        # Define ContentColumn (ColC): first column of InnerGrid\n        ColC = inner_grid_np[:, 0] # Shape (CH,)\n\n        # Define ModifiedColumn (ColM): ColC with top/bottom pixels replaced by frame_color\n        ColM = ColC.copy()\n        ColM[0] = frame_color\n        ColM[CH - 1] = frame_color # Index is CH-1\n\n        # Assemble the sequence of output columns\n        output_columns = []\n        # Repeat [ColM, ColC] CW times\n        for _ in range(CW):\n            output_columns.append(ColM)\n            output_columns.append(ColC)\n\n        # Fill remaining columns with ColC until the total number of columns is FH\n        while len(output_columns) < FH:\n            output_columns.append(ColC)\n\n        # Truncate if the sequence is somehow longer than FH (defensive coding)\n        if len(output_columns) > FH:\n            output_columns = output_columns[:FH]\n\n        # Ensure we have columns to stack\n        if not output_columns:\n             # Create an empty grid with CH rows and 0 columns\n             output_grid = [[] for _ in range(CH)]\n        else:\n            # Stack the collected columns horizontally to form the output grid\n            output_grid_np = np.stack(output_columns, axis=1) # Shape (CH, FH)\n            output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2666,
    "candidates_token_count": 8670,
    "total_token_count": 11336,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 63.414361,
  "retries": 1
}