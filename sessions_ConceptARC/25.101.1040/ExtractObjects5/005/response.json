{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies key objects based on their bounding box dimensions relative to the largest square bounding box present. It then creates output segments of a uniform size 'S' (derived from the minimum dimension of key objects). The content of each segment depends on whether the original key object's bounding box was exactly SxS (in which case the pattern is copied) or larger (in which case a solid square is created). These segments are assembled horizontally based on the original objects' left-to-right order.\n\n1.  Identify all distinct, contiguous objects of non-white color in the input grid. Record color, bounding box (height H, width W), and leftmost column index (min_col) for each.\n2.  Find the dimension M of the largest square bounding box (max H where H == W). Default M=0 if none.\n3.  Select \"key\" objects where H >= M-1 and W >= M-1.\n4.  If no key objects, output an empty grid.\n5.  Determine the target size S = min(min(H, W)) for all key objects. Ensure S > 0.\n6.  Sort key objects by min_col.\n7.  Create S x S output segments:\n    *   If H == S and W == S for a key object, extract the S x S pattern from the input grid at the object's location.\n    *   Otherwise (H > S or W > S), create a solid S x S square of the object's color.\n8.  Assemble segments horizontally in sorted order.\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds all contiguous objects of non-background color (0) in the grid.\n    \n    Args:\n        grid: A numpy array representing the input grid.\n        \n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains its color, pixels (list of (r, c) tuples), and\n        bounding box information (min_row, max_row, min_col, max_col, height, width).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels, # Retained for potential future use, not strictly needed here\n                    'min_row': min_r, 'max_row': max_r,\n                    'min_col': min_c, 'max_col': max_c,\n                    'height': height, 'width': width\n                })\n    return objects\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    \n    # 1. Find all objects and their properties\n    all_objects = find_objects(input_np)\n    if not all_objects:\n        return [] # Return empty if no objects found\n\n    # 2. Find the maximum dimension 'M' of square bounding boxes\n    max_square_dim = 0\n    for obj in all_objects:\n        if obj['height'] == obj['width']:\n            max_square_dim = max(max_square_dim, obj['height'])\n            \n    # 3. Filter objects to select key objects (H >= M-1 and W >= M-1)\n    filter_threshold = max_square_dim - 1\n    key_objects = [\n        obj for obj in all_objects \n        if obj['height'] >= filter_threshold and obj['width'] >= filter_threshold\n    ]\n\n    # 4. Handle case where no key objects are found\n    if not key_objects:\n        return [] \n\n    # 5. Determine output square size 'S' (minimum dimension among key objects)\n    min_dims_for_S = []\n    for obj in key_objects:\n        min_dims_for_S.append(min(obj['height'], obj['width']))\n    \n    if not min_dims_for_S: # Should not happen if key_objects is not empty\n         return []\n         \n    S = min(min_dims_for_S)\n    \n    # Check for S=0 which would be invalid\n    if S <= 0:\n        print(f\"Warning: Calculated output size S={S} is invalid. Aborting.\")\n        return []\n\n    # 6. Sort key objects by horizontal position (min_col)\n    key_objects.sort(key=lambda obj: obj['min_col'])\n\n    # 7. Create output segments (S x S grids)\n    output_segments = []\n    for obj in key_objects:\n        H = obj['height']\n        W = obj['width']\n        color = obj['color']\n        \n        # Conditional transformation based on object size vs target size S\n        if H == S and W == S:\n            # Extract the S x S pattern from the input grid\n            min_r, min_c = obj['min_row'], obj['min_col']\n            segment_grid = input_np[min_r : min_r + S, min_c : min_c + S]\n        else:\n            # Create a solid S x S square\n            segment_grid = np.full((S, S), color, dtype=int)\n            \n        output_segments.append(segment_grid)\n\n    # 8. Assemble the final output grid horizontally\n    if not output_segments:\n        # This case might occur if S was invalid or segment creation failed unexpectedly\n        return []\n        \n    # Use hstack to concatenate the segments horizontally\n    output_grid_np = np.hstack(output_segments)\n    \n    # Convert back to list of lists for the required output format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17722,
    "candidates_token_count": 2093,
    "total_token_count": 19815,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 14.036724,
  "retries": 1
}