{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct, contiguous, non-white rectangular blocks in the input grid.\nAssume blocks are vertically arranged and start in the same column (usually column 0).\nRecord each block's color, pixel data (shape), height, width, and original top row index.\nMaintain the original top-to-bottom order of the blocks.\nCalculate the vertical gaps (number of white rows) between consecutive blocks in the original order.\nSort the blocks based on their width in ascending order.\nCreate a new empty output grid of the same dimensions as the input, filled with white (0).\nPlace the sorted blocks onto the output grid sequentially from top to bottom.\nThe starting row for the first sorted block is the starting row of the first block in the original input order.\nThe vertical gap placed *after* placing the k-th sorted block is the gap that originally existed *after* the k-th block in the *original* input order.\nReturn the completed output grid.\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds contiguous blocks of non-white pixels in the grid.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'color', 'pixels', 'top_row', 'left_col', 'height', 'width'.\n        The list is sorted by the 'top_row' of the objects.\n    \"\"\"\n    objects = []\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_object_pixels = set([(r, c)])\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            current_object_pixels.add((nr, nc))\n\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                # Extract the pixel data for the block\n                block_pixels = np.zeros((height, width), dtype=int)\n                for pr, pc in current_object_pixels:\n                    block_pixels[pr - min_r, pc - min_c] = color\n\n                objects.append({\n                    'color': color,\n                    'pixels': block_pixels,\n                    'top_row': min_r,\n                    'left_col': min_c, # Assuming all start at col 0 based on examples\n                    'height': height,\n                    'width': width,\n                })\n\n    # Sort objects by their top row to get the original vertical order\n    objects.sort(key=lambda obj: obj['top_row'])\n    return objects\n\ndef calculate_gaps(objects: list[dict]) -> list[int]:\n    \"\"\"\n    Calculates the vertical gaps between consecutive objects.\n\n    Args:\n        objects: A list of object dictionaries, sorted by top_row.\n\n    Returns:\n        A list of integers representing the gap size below each object\n        (except the last one).\n    \"\"\"\n    gaps = []\n    for i in range(len(objects) - 1):\n        current_obj = objects[i]\n        next_obj = objects[i+1]\n        gap = next_obj['top_row'] - (current_obj['top_row'] + current_obj['height'])\n        gaps.append(gap)\n    return gaps\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by reordering rectangular blocks based on width.\n\n    1. Finds non-white rectangular blocks.\n    2. Calculates vertical gaps between them in the original order.\n    3. Sorts the blocks by width (ascending).\n    4. Reconstructs the grid with sorted blocks, preserving original gaps relative\n       to the *original* block order index.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # 1. Find objects and maintain original order\n    original_objects = find_objects(input_array)\n    if not original_objects:\n        return input_grid # Return original if no objects found\n\n    # 2. Calculate vertical gaps based on original order\n    original_gaps = calculate_gaps(original_objects)\n\n    # 3. Sort objects by width\n    sorted_objects = sorted(original_objects, key=lambda obj: obj['width'])\n\n    # 4. Initialize output grid\n    output_array = np.zeros_like(input_array, dtype=int)\n\n    # 5. Place sorted objects onto the output grid\n    current_top_row = original_objects[0]['top_row'] # Start at the top row of the first original object\n\n    for i, obj in enumerate(sorted_objects):\n        # Determine placement position\n        top = current_top_row\n        left = obj['left_col'] # Use original left column (assumed constant here)\n        height = obj['height']\n        width = obj['width']\n        pixels = obj['pixels']\n\n        # Place the object\n        if top + height <= rows and left + width <= cols:\n             # Ensure the pixel block fits the identified dimensions\n             actual_pixel_height, actual_pixel_width = pixels.shape\n             if actual_pixel_height == height and actual_pixel_width == width:\n                 output_array[top:top + height, left:left + width] = np.where(\n                     pixels != 0, pixels, output_array[top:top + height, left:left + width]\n                 )\n             else: # Fallback if dimensions mismatch somehow (shouldn't happen with rects)\n                 print(f\"Warning: Dimension mismatch for object {i}. Using detected shape.\")\n                 output_array[top:top + actual_pixel_height, left:left + actual_pixel_width] = np.where(\n                     pixels != 0, pixels, output_array[top:top + actual_pixel_height, left:left + actual_pixel_width]\n                 )\n\n\n        # Update current_top_row for the next block\n        # The gap added is the gap that followed the i-th block in the *original* order\n        if i < len(sorted_objects) - 1:\n            gap_to_add = original_gaps[i] if i < len(original_gaps) else 0 # Handle potential index out of bounds if gaps are fewer\n            current_top_row += height + gap_to_add\n        # Else: it's the last block, no need to update further\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2919,
    "candidates_token_count": 2373,
    "total_token_count": 5292,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.475659,
  "retries": 1
}