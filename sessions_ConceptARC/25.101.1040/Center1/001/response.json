{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nIdentifies hollow rectangular frames (1 pixel thick, single non-white color) in the input grid.\nIf a frame is 3x3, fills the entire 3x3 area (frame and interior) with the frame's color.\nIf a frame is larger than 3x3, fills the single centermost pixel of the hollow interior with the frame's color.\nPixels not part of identified frames or their modified interiors remain unchanged.\n\"\"\"\n\ndef _is_valid(r, c, height, width):\n    \"\"\"Check if coordinates are within grid boundaries.\"\"\"\n    return 0 <= r < height and 0 <= c < width\n\ndef _find_frames(grid: np.ndarray) -> list[tuple[int, int, int, int, int]]:\n    \"\"\"\n    Finds all hollow rectangular frames in the grid.\n\n    A frame is defined by:\n    - A 1-pixel thick border of a single non-white color.\n    - A rectangular interior filled entirely with the background color (0).\n\n    Returns:\n        A list of tuples, where each tuple represents a frame:\n        (top_row, left_col, height, width, frame_color)\n    \"\"\"\n    frames = []\n    height, width = grid.shape\n    visited_corners = set() # To avoid detecting the same frame multiple times from different corners\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Potential top-left corner: non-white pixel\n            if color != 0 and (r, c) not in visited_corners:\n                # Check potential frame properties starting from this corner\n                \n                # 1. Find potential width (w) along the top edge\n                potential_w = 0\n                for i in range(c, width):\n                    if grid[r, i] == color:\n                        potential_w += 1\n                    else:\n                        break\n                if potential_w < 3: continue # Minimum frame width is 3\n\n                # 2. Find potential height (h) along the left edge\n                potential_h = 0\n                for j in range(r, height):\n                    if grid[j, c] == color:\n                        potential_h += 1\n                    else:\n                        break\n                if potential_h < 3: continue # Minimum frame height is 3\n\n                # 3. Verify if it's a hollow rectangle\n                is_frame = True\n                # Check right edge\n                for j in range(r, r + potential_h):\n                    if not _is_valid(j, c + potential_w - 1, height, width) or grid[j, c + potential_w - 1] != color:\n                        is_frame = False\n                        break\n                if not is_frame: continue\n\n                # Check bottom edge\n                for i in range(c, c + potential_w):\n                     if not _is_valid(r + potential_h - 1, i, height, width) or grid[r + potential_h - 1, i] != color:\n                        is_frame = False\n                        break\n                if not is_frame: continue\n\n                # Check interior (must be background color 0)\n                for row_inner in range(r + 1, r + potential_h - 1):\n                    for col_inner in range(c + 1, c + potential_w - 1):\n                        if not _is_valid(row_inner, col_inner, height, width) or grid[row_inner, col_inner] != 0:\n                            is_frame = False\n                            break\n                    if not is_frame: break\n                if not is_frame: continue\n\n                # If all checks pass, it's a frame\n                frames.append((r, c, potential_h, potential_w, color))\n                # Mark corners to avoid re-detection\n                visited_corners.add((r, c))\n                visited_corners.add((r, c + potential_w - 1))\n                visited_corners.add((r + potential_h - 1, c))\n                visited_corners.add((r + potential_h - 1, c + potential_w - 1))\n\n    return frames\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on identified hollow rectangular frames.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Find all hollow rectangular frames\n    frames = _find_frames(input_np)\n\n    # Process each found frame\n    for r, c, h, w, color in frames:\n        # Condition: Frame size is 3x3\n        if h == 3 and w == 3:\n            # Action: Fill the entire 3x3 area with the frame's color\n            for i in range(r, r + 3):\n                for j in range(c, c + 3):\n                    # Check boundaries just in case, though find_frames should ensure validity\n                    if _is_valid(i, j, height, width):\n                        output_np[i, j] = color\n        # Condition: Frame size is greater than 3x3\n        elif h > 3 and w > 3:\n            # Action: Fill the center of the hollow interior\n            # Calculate interior dimensions and top-left corner\n            interior_r = r + 1\n            interior_c = c + 1\n            interior_h = h - 2\n            interior_w = w - 2\n\n            # Calculate the geometric center of the interior\n            # // is integer division, equivalent to floor for positive results\n            center_r = interior_r + (interior_h - 1) // 2\n            center_c = interior_c + (interior_w - 1) // 2\n\n            # Change the color of the center pixel\n            if _is_valid(center_r, center_c, height, width):\n                 output_np[center_r, center_c] = color\n\n    # Convert the result back to a list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2734,
    "candidates_token_count": 2579,
    "total_token_count": 5313,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.324608,
  "retries": 1
}