{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\n\n\"\"\"\nTransformation rule:\nIdentify distinct objects composed of non-background pixels (color > 0).\nFor each object, determine all colors involved: the colors of the object's pixels and any background (0) pixels that are fully enclosed within the object's structure (i.e., cannot reach the grid border via other background pixels).\nIf an object, including its enclosed background pixels, consists of exactly two distinct colors, identify the 'frame' color (the one touching the external background) and the 'internal' color (the one not touching the external background, or the background color 0 if it's enclosed).\nCheck if the (internal_color, frame_color) pair matches specific removal criteria: (Blue(1), Red(2)), (Orange(7), Green(3)), or (White(0), Yellow(4)).\nIf a match is found, remove the object by replacing all of its original non-background pixels with the background color (0). Otherwise, keep the object unchanged.\n\"\"\"\n\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\"Gets valid neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    if r > 0:\n        neighbors.append((r - 1, c))\n    if r < height - 1:\n        neighbors.append((r + 1, c))\n    if c > 0:\n        neighbors.append((r, c - 1))\n    if c < width - 1:\n        neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_objects(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds connected components of non-background pixels using Breadth-First Search (BFS).\n    \n    Args:\n        grid: The input grid (list of lists of integers).\n\n    Returns:\n        A list of sets, where each set contains the (row, col) coordinates\n        of the pixels belonging to a distinct object.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Look for non-background pixels that haven't been visited yet\n            if grid[r][c] != background_color and (r, c) not in visited:\n                # Found the start of a new object, perform BFS\n                obj_coords = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n                        # Add neighbor to object if it's non-background and not visited\n                        if (nr, nc) not in visited and grid[nr][nc] != background_color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                # Add the completed object to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef _find_border_background(grid: list[list[int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all background pixels connected to the grid border using BFS.\n    This helps identify enclosed background pixels later.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A set of (row, col) coordinates of background pixels connected to the border.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    border_background = set()\n    q = collections.deque()\n    visited = set()\n    background_color = 0\n\n    # Initialize queue with all background pixels on the border\n    for r in range(height):\n        if grid[r][0] == background_color and (r, 0) not in visited:\n            q.append((r, 0))\n            visited.add((r, 0))\n        # Check width > 1 to avoid index error on 1-wide grids\n        if width > 1 and grid[r][width - 1] == background_color and (r, width - 1) not in visited:\n            q.append((r, width - 1))\n            visited.add((r, width - 1))\n    for c in range(width):\n        if grid[0][c] == background_color and (0, c) not in visited:\n             q.append((0, c))\n             visited.add((0, c))\n        # Check height > 1 to avoid index error on 1-high grids\n        if height > 1 and grid[height - 1][c] == background_color and (height - 1, c) not in visited:\n             q.append((height - 1, c))\n             visited.add((height - 1, c))\n    \n    border_background.update(visited) # Add initial border pixels found\n\n    # Perform BFS starting from the border background pixels\n    while q:\n        curr_r, curr_c = q.popleft()\n        for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n            # If neighbor is background and not visited, add it\n            if (nr, nc) not in visited and grid[nr][nc] == background_color:\n                visited.add((nr, nc))\n                border_background.add((nr, nc))\n                q.append((nr, nc))\n\n    return border_background\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies objects composed of exactly two colors (where one might be enclosed background).\n    Removes objects if their (internal_color, frame_color) pair matches specific criteria:\n    (Blue(1), Red(2)), (Orange(7), Green(3)), or (White(0), Yellow(4)).\n\n    Args:\n        input_grid: The input grid represented as a list of lists of integers.\n\n    Returns:\n        The transformed grid as a list of lists of integers.\n    \"\"\"\n    # Create a deep copy to modify, preserving the original input\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0\n\n    # Define the specific pairs (internal_color, frame_color) to be removed\n    # (Blue, Red), (Orange, Green), (White, Yellow)\n    removal_pairs = {(1, 2), (7, 3), (0, 4)}\n\n    # Find all distinct objects (connected components of non-background colors)\n    objects = _find_objects(input_grid)\n\n    # Pre-calculate which background pixels are connected to the border\n    # This helps efficiently determine if a background pixel is enclosed\n    border_background_coords = _find_border_background(input_grid)\n\n    # Process each identified object\n    for obj_coords in objects:\n        if not obj_coords: continue # Skip if object is somehow empty\n\n        # 1. Determine colors within the object's non-background pixels\n        obj_colors_non_zero = {input_grid[r][c] for r, c in obj_coords}\n\n        # 2. Find the bounding box of the object for efficient enclosed background check\n        min_r = min(r for r, c in obj_coords)\n        max_r = max(r for r, c in obj_coords)\n        min_c = min(c for r, c in obj_coords)\n        max_c = max(c for r, c in obj_coords)\n\n        # 3. Check for enclosed background pixels within the bounding box\n        # An enclosed background pixel is one with color 0, within the bbox,\n        # and not connected to the border background.\n        has_enclosed_background = False\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                coord = (r, c)\n                # Check if pixel is background and NOT connected to the border background\n                if input_grid[r][c] == background_color and coord not in border_background_coords:\n                     # Also check if this enclosed background pixel is adjacent to the current object\n                     # to ensure it's relevant to *this* object's structure.\n                     is_adjacent_to_object = False\n                     for nr, nc in _get_neighbors(r, c, height, width):\n                         if (nr, nc) in obj_coords:\n                             is_adjacent_to_object = True\n                             break\n                     if is_adjacent_to_object:\n                        has_enclosed_background = True\n                        break # Found one relevant enclosed background pixel, no need to check further\n            if has_enclosed_background:\n                break\n\n        # 4. Combine object colors and potentially the enclosed background color (0)\n        all_obj_colors = set(obj_colors_non_zero)\n        if has_enclosed_background:\n            all_obj_colors.add(background_color)\n\n        # 5. Proceed only if the object involves exactly two colors in total\n        if len(all_obj_colors) == 2:\n            colors = list(all_obj_colors)\n            c1, c2 = colors[0], colors[1]\n\n            # 6. Determine which color is the frame (touches external background)\n            # External background means pixels outside the object that are connected to the border background.\n            c1_touches_external = False\n            c2_touches_external = False\n\n            for r, c in obj_coords:\n                pixel_color = input_grid[r][c]\n                # Check neighbors for external background connection\n                for nr, nc in _get_neighbors(r, c, height, width):\n                    neighbor_coord = (nr, nc)\n                    # Check if neighbor is outside the object's coordinates, is background, and touches the border\n                    if neighbor_coord not in obj_coords and input_grid[nr][nc] == background_color and neighbor_coord in border_background_coords:\n                        if pixel_color == c1:\n                            c1_touches_external = True\n                        elif pixel_color == c2:\n                            c2_touches_external = True\n                        # Optimization: if both touch, we know enough for this pixel check\n                        if c1_touches_external and c2_touches_external: break\n                # Optimization: if both touch external, no need to check more pixels of the object\n                if c1_touches_external and c2_touches_external: break\n\n            # 7. Assign frame and internal based on which color touches the external background\n            frame_color = -1 # Sentinel value indicates ambiguity or error\n            internal_color = -1\n\n            if c1_touches_external and not c2_touches_external:\n                 # c1 touches external, c2 does not -> c1 is frame, c2 is internal\n                 frame_color = c1\n                 internal_color = c2\n            elif c2_touches_external and not c1_touches_external:\n                 # c2 touches external, c1 does not -> c2 is frame, c1 is internal\n                 frame_color = c2\n                 internal_color = c1\n            elif not c1_touches_external and not c2_touches_external:\n                 # Neither touches external background.\n                 # This occurs if the object is fully enclosed by another structure,\n                 # or if the only background it touches is itself enclosed background.\n                 # If one of the colors is background(0) (meaning it was enclosed), it must be the internal color.\n                 if c1 == background_color:\n                      internal_color = c1\n                      frame_color = c2\n                 elif c2 == background_color:\n                      internal_color = c2\n                      frame_color = c1\n                 # else: Both are non-background and don't touch external -> Treat as non-removable based on this rule\n            elif c1_touches_external and c2_touches_external:\n                 # Both touch external background. Example: adjacent stripes of two colors.\n                 # This structure doesn't fit the 'frame/internal' model clearly.\n                 # However, if one color is background(0), it must be internal (this case should be unlikely\n                 # if background(0) is identified correctly as enclosed, which shouldn't touch external).\n                 # If background(0) is one of the colors and it somehow touches external, treat it as internal.\n                 if c1 == background_color:\n                      internal_color = c1\n                      frame_color = c2\n                 elif c2 == background_color:\n                      internal_color = c2\n                      frame_color = c1\n                 # else: Both are non-background, both touch external -> Not a frame/internal structure, keep object.\n\n            # 8. Check if the identified (internal, frame) pair is in the removal set\n            should_remove = False\n            if internal_color != -1 and frame_color != -1: # Check if colors were successfully assigned\n                if (internal_color, frame_color) in removal_pairs:\n                    should_remove = True\n\n            # 9. If removal criteria met, update the output grid\n            # Replace all pixels of the original object (non-zero colors) with the background color\n            if should_remove:\n                for r_obj, c_obj in obj_coords:\n                    output_grid[r_obj][c_obj] = background_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3715,
    "candidates_token_count": 12363,
    "total_token_count": 16078,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 84.035189,
  "retries": 1
}