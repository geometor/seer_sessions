{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\nimport numpy as np\n\n\"\"\"\nIdentifies distinct objects composed of non-background pixels (color > 0).\nFor each object, determines all colors involved: the colors of the object's pixels \nand any background (0) pixels that are effectively enclosed by the object \n(adjacent to the object but not connected to the grid border via background paths).\nIf an object, including its enclosed background pixels, consists of exactly two \ndistinct colors, identify the 'frame' color (the one touching the external \nbackground connected to the border) and the 'internal' color (the one not \ntouching the external background, or the background color 0 if it's enclosed).\nChecks if the (internal_color, frame_color) pair matches specific removal \ncriteria: (Blue(1), Red(2)), (Orange(7), Green(3)), or (White(0), Yellow(4)).\nIf a match is found, removes the object by replacing all of its original \nnon-background pixels with the background color (0). Otherwise, keeps the \nobject unchanged.\n\"\"\"\n\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\"Gets valid neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    if r > 0:\n        neighbors.append((r - 1, c))\n    if r < height - 1:\n        neighbors.append((r + 1, c))\n    if c > 0:\n        neighbors.append((r, c - 1))\n    if c < width - 1:\n        neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_objects(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds connected components of non-background pixels using Breadth-First Search (BFS).\n    \n    Args:\n        grid: The input grid (list of lists of integers).\n\n    Returns:\n        A list of sets, where each set contains the (row, col) coordinates\n        of the pixels belonging to a distinct object.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Look for non-background pixels that haven't been visited yet\n            if grid[r][c] != background_color and (r, c) not in visited:\n                # Found the start of a new object, perform BFS\n                obj_coords = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n                        # Add neighbor to object if it's non-background and not visited\n                        if (nr, nc) not in visited and grid[nr][nc] != background_color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                # Add the completed object to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef _find_border_background(grid: list[list[int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all background pixels connected to the grid border using BFS.\n    This helps identify enclosed background pixels later.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A set of (row, col) coordinates of background pixels connected to the border.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    border_background = set()\n    q = collections.deque()\n    visited = set()\n    background_color = 0\n\n    # Initialize queue with all background pixels on the border\n    for r in range(height):\n        if grid[r][0] == background_color and (r, 0) not in visited:\n            q.append((r, 0))\n            visited.add((r, 0))\n        # Check width > 1 to avoid index error on 1-wide grids and duplicate adds\n        if width > 1 and grid[r][width - 1] == background_color and (r, width - 1) not in visited:\n            q.append((r, width - 1))\n            visited.add((r, width - 1))\n    for c in range(width):\n        # Check height > 1 to avoid duplicate adds\n        if grid[0][c] == background_color and (0, c) not in visited:\n             q.append((0, c))\n             visited.add((0, c))\n        # Check height > 1 to avoid index error on 1-high grids and duplicate adds\n        if height > 1 and grid[height - 1][c] == background_color and (height - 1, c) not in visited:\n             q.append((height - 1, c))\n             visited.add((height - 1, c))\n    \n    border_background.update(visited) # Add initial border pixels found\n\n    # Perform BFS starting from the border background pixels\n    while q:\n        curr_r, curr_c = q.popleft()\n        for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n            # If neighbor is background and not visited, add it\n            if (nr, nc) not in visited and grid[nr][nc] == background_color:\n                visited.add((nr, nc))\n                border_background.add((nr, nc))\n                q.append((nr, nc))\n\n    return border_background\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies objects composed of exactly two colors (potentially including enclosed background).\n    Removes objects if their (internal_color, frame_color) pair matches specific criteria.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0\n\n    # Define the specific pairs (internal_color, frame_color) to be removed\n    # (Blue, Red), (Orange, Green), (White, Yellow)\n    removal_pairs = {(1, 2), (7, 3), (0, 4)}\n\n    # Find all background pixels connected to the border (external background)\n    border_background_coords = _find_border_background(input_grid)\n\n    # Find all distinct objects (connected components of non-background colors)\n    objects = _find_objects(input_grid)\n\n    # Process each identified object\n    for obj_coords in objects:\n        if not obj_coords: continue # Skip if object is somehow empty\n\n        # --- Step 1: Determine object colors including potential enclosed background ---\n        \n        # Get colors of the object's actual pixels\n        obj_colors_non_zero = {input_grid[r][c] for r, c in obj_coords}\n        \n        # Check for adjacent background pixels that are NOT connected to the border\n        has_enclosed_background = False\n        adjacent_background = set()\n        for r_obj, c_obj in obj_coords:\n            for nr, nc in _get_neighbors(r_obj, c_obj, height, width):\n                # Check if neighbor is background and outside the current object itself\n                if (nr, nc) not in obj_coords and input_grid[nr][nc] == background_color:\n                    adjacent_background.add((nr,nc))\n        \n        # Check if any adjacent background is NOT border background\n        for r_bg, c_bg in adjacent_background:\n             if (r_bg, c_bg) not in border_background_coords:\n                 has_enclosed_background = True\n                 break # Found one, no need to check more\n\n        # Combine non-zero colors and potentially enclosed background color (0)\n        all_obj_colors = set(obj_colors_non_zero)\n        if has_enclosed_background:\n            all_obj_colors.add(background_color)\n\n        # --- Step 2: Check if the object has exactly two colors ---\n        if len(all_obj_colors) == 2:\n            colors = list(all_obj_colors)\n            c1, c2 = colors[0], colors[1]\n\n            # --- Step 3: Determine which color is frame (touches external) and internal ---\n            c1_touches_external = False\n            c2_touches_external = False\n\n            # Check each pixel of the object for adjacency to external background\n            for r_obj, c_obj in obj_coords:\n                pixel_color = input_grid[r_obj][c_obj]\n                # Optimization: Skip if this color already known to touch external\n                if (pixel_color == c1 and c1_touches_external) or \\\n                   (pixel_color == c2 and c2_touches_external):\n                   continue\n                   \n                for nr, nc in _get_neighbors(r_obj, c_obj, height, width):\n                    neighbor_coord = (nr, nc)\n                    # Check if neighbor is background AND part of the border-connected set\n                    if neighbor_coord not in obj_coords and input_grid[nr][nc] == background_color and neighbor_coord in border_background_coords:\n                        if pixel_color == c1:\n                            c1_touches_external = True\n                        elif pixel_color == c2:\n                            c2_touches_external = True\n                        # Optimization: if both touch, we know enough for this pixel check\n                        if c1_touches_external and c2_touches_external: break\n                # Optimization: if both touch external, no need to check more pixels of the object\n                if c1_touches_external and c2_touches_external: break\n            \n            # Assign frame and internal based on touching external background\n            frame_color = -1 # Sentinel value\n            internal_color = -1\n\n            if c1_touches_external and not c2_touches_external:\n                 frame_color = c1\n                 internal_color = c2\n            elif c2_touches_external and not c1_touches_external:\n                 frame_color = c2\n                 internal_color = c1\n            elif not c1_touches_external and not c2_touches_external:\n                 # Neither touches external. Check if one is enclosed background (0).\n                 if c1 == background_color:\n                      internal_color = c1\n                      frame_color = c2\n                 elif c2 == background_color:\n                      internal_color = c2\n                      frame_color = c1\n                 # Else: Both non-background, neither touches external -> Cannot determine frame/internal clearly.\n            # Case: Both touch external (c1_touches_external and c2_touches_external)\n            # This doesn't fit the frame/internal model, so no assignment made.\n            # (Unless one is background(0), which is unlikely if correctly identified as enclosed).\n\n            # --- Step 4: Check for removal criteria ---\n            should_remove = False\n            if internal_color != -1 and frame_color != -1: # Check if colors were successfully assigned\n                if (internal_color, frame_color) in removal_pairs:\n                    should_remove = True\n\n            # --- Step 5: Apply removal if needed ---\n            if should_remove:\n                # Replace all pixels of the original object with the background color\n                for r_obj, c_obj in obj_coords:\n                    output_grid[r_obj][c_obj] = background_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17335,
    "candidates_token_count": 3415,
    "total_token_count": 20750,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 22.601619,
  "retries": 1
}