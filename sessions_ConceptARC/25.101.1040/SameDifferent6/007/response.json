{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nimport copy\n\n\"\"\"\nIdentify distinct objects composed of non-background pixels (color > 0).\nFor each object, determine all colors involved: the colors of the object's pixels \nand any background (0) pixels that are effectively enclosed by the object \n(adjacent to the object but not connected to the grid border via background paths).\nIf an object, including its enclosed background pixels, consists of exactly two \ndistinct colors, identify the 'frame' color (the one touching the external \nbackground connected to the border) and the 'internal' color (the one not \ntouching the external background, or the background color 0 if it's enclosed).\nCheck if the (internal_color, frame_color) pair matches specific removal \ncriteria: (Blue(1), Red(2)), (Orange(7), Green(3)), or (White(0), Yellow(4)).\nIf a match is found, remove the object by replacing all of its original \nnon-background pixels with the background color (0). Otherwise, keep the \nobject unchanged.\n\"\"\"\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\"Gets valid neighbor coordinates (up, down, left, right).\"\"\"\n    neighbors = []\n    if r > 0:\n        neighbors.append((r - 1, c))\n    if r < height - 1:\n        neighbors.append((r + 1, c))\n    if c > 0:\n        neighbors.append((r, c - 1))\n    if c < width - 1:\n        neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_objects(grid: list[list[int]]) -> list[set[tuple[int, int]]]:\n    \"\"\"\n    Finds connected components of non-background pixels using Breadth-First Search (BFS).\n    \n    Args:\n        grid: The input grid (list of lists of integers).\n\n    Returns:\n        A list of sets, where each set contains the (row, col) coordinates\n        of the pixels belonging to a distinct object.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Look for non-background pixels that haven't been visited yet\n            if grid[r][c] != background_color and (r, c) not in visited:\n                # Found the start of a new object, perform BFS\n                obj_coords = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                obj_coords.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n                        # Add neighbor to object if it's non-background and not visited\n                        if (nr, nc) not in visited and grid[nr][nc] != background_color:\n                            visited.add((nr, nc))\n                            obj_coords.add((nr, nc))\n                            q.append((nr, nc))\n                # Add the completed object to the list\n                if obj_coords:\n                    objects.append(obj_coords)\n    return objects\n\ndef _find_border_background(grid: list[list[int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds all background pixels connected to the grid border using BFS.\n    This helps identify enclosed background pixels later.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A set of (row, col) coordinates of background pixels connected to the border.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    border_background = set()\n    q = collections.deque()\n    visited = set()\n    background_color = 0\n\n    # Initialize queue with all background pixels on the border\n    for r in range(height):\n        if grid[r][0] == background_color and (r, 0) not in visited:\n            q.append((r, 0))\n            visited.add((r, 0))\n        # Check width > 1 to avoid index error on 1-wide grids and duplicate adds\n        if width > 1 and grid[r][width - 1] == background_color and (r, width - 1) not in visited:\n            q.append((r, width - 1))\n            visited.add((r, width - 1))\n    for c in range(width):\n        # Check to avoid duplicate adds with corners\n        if grid[0][c] == background_color and (0, c) not in visited:\n             q.append((0, c))\n             visited.add((0, c))\n        # Check height > 1 to avoid index error on 1-high grids and duplicate adds\n        if height > 1 and grid[height - 1][c] == background_color and (height - 1, c) not in visited:\n             q.append((height - 1, c))\n             visited.add((height - 1, c))\n    \n    border_background.update(visited) # Add initial border pixels found\n\n    # Perform BFS starting from the border background pixels\n    while q:\n        curr_r, curr_c = q.popleft()\n        for nr, nc in _get_neighbors(curr_r, curr_c, height, width):\n            # If neighbor is background and not visited, add it\n            if (nr, nc) not in visited and grid[nr][nc] == background_color:\n                visited.add((nr, nc))\n                border_background.add((nr, nc))\n                q.append((nr, nc))\n\n    return border_background\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # 1. Create an output_grid as a deep copy of the input_grid.\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0\n\n    # Define the specific pairs (internal_color, frame_color) to be removed\n    removal_pairs = {(1, 2), (7, 3), (0, 4)}\n\n    # 2. Identify the set of border_background_coords.\n    border_background_coords = _find_border_background(input_grid)\n\n    # 3. Find all distinct objects (sets of coordinates).\n    objects = _find_objects(input_grid)\n\n    # 4. Iterate through the list of found objects.\n    for obj_coords in objects:\n        if not obj_coords: continue # Skip if object is somehow empty\n\n        # 4a. Initialize should_remove flag.\n        should_remove = False \n\n        # 4b. Determine non-zero colors.\n        obj_colors_non_zero = {input_grid[r][c] for r, c in obj_coords}\n        \n        # 4c. Check for enclosed background.\n        has_enclosed_background = False\n        adjacent_background_coords = set()\n        for r_obj, c_obj in obj_coords:\n            for nr, nc in _get_neighbors(r_obj, c_obj, height, width):\n                if (nr, nc) not in obj_coords and input_grid[nr][nc] == background_color:\n                    adjacent_background_coords.add((nr,nc))\n        for r_bg, c_bg in adjacent_background_coords:\n             if (r_bg, c_bg) not in border_background_coords:\n                 has_enclosed_background = True\n                 break \n\n        # 4d. Create the full set of relevant colors.\n        all_obj_colors = set(obj_colors_non_zero)\n        if has_enclosed_background:\n            all_obj_colors.add(background_color)\n\n        # 4e. Check if exactly two colors.\n        if len(all_obj_colors) == 2:\n            # 4e.i. Identify the two colors.\n            colors = list(all_obj_colors)\n            c1, c2 = colors[0], colors[1]\n\n            # 4e.ii & 4e.iii. Check adjacency to external background.\n            c1_touches_external = False\n            c2_touches_external = False\n            for r_obj, c_obj in obj_coords:\n                pixel_color = input_grid[r_obj][c_obj]\n                if c1_touches_external and c2_touches_external: break\n                if (pixel_color == c1 and c1_touches_external) or \\\n                   (pixel_color == c2 and c2_touches_external):\n                   continue\n                for nr, nc in _get_neighbors(r_obj, c_obj, height, width):\n                    neighbor_coord = (nr, nc)\n                    if neighbor_coord not in obj_coords and input_grid[nr][nc] == background_color and neighbor_coord in border_background_coords:\n                        if pixel_color == c1: c1_touches_external = True\n                        elif pixel_color == c2: c2_touches_external = True\n                        if c1_touches_external and c2_touches_external: break\n            \n            # 4e.iv. Assign internal/frame colors (defaulting to invalid -1).\n            internal_color = -1\n            frame_color = -1\n\n            # 4e.v, 4e.vi, 4e.vii. Apply assignment logic.\n            if c1_touches_external and not c2_touches_external:\n                 frame_color = c1; internal_color = c2\n            elif c2_touches_external and not c1_touches_external:\n                 frame_color = c2; internal_color = c1\n            elif not c1_touches_external and not c2_touches_external:\n                 if c1 == background_color:\n                      internal_color = c1; frame_color = c2\n                 elif c2 == background_color:\n                      internal_color = c2; frame_color = c1\n            \n            # 4e.viii. Check if assignment was valid.\n            if internal_color != -1 and frame_color != -1:\n                # 4e.ix. Check if the pair matches removal criteria.\n                if (internal_color, frame_color) in removal_pairs:\n                    # 4e.x. Set flag if match.\n                    should_remove = True\n\n        # 4f. If removal flag is set, modify the output grid.\n        if should_remove:\n            # 4f.i. Iterate through the object's coordinates.\n            for r_obj, c_obj in obj_coords:\n                # 4f.ii. Set pixel to background color.\n                output_grid[r_obj][c_obj] = background_color\n\n    # 5. Return the final output_grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 37906,
    "candidates_token_count": 3034,
    "total_token_count": 40940,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.911355,
  "retries": 1
}