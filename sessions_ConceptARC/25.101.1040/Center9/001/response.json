{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies two parallel boundary lines (horizontal or vertical) and a single 'moving' pixel between them. \nThe moving pixel is moved parallel to the boundaries, away from the closer boundary. \nThe distance moved is half the distance (floor division) between the pixel and the farther boundary.\nThe original position of the moving pixel is set to the background color (assumed to be 0).\n\"\"\"\n\ndef find_boundary_lines(grid: np.ndarray) -> tuple[int, list[int], str | None]:\n    \"\"\"\n    Finds the two parallel boundary lines in the grid.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple containing:\n        - boundary_color: The color of the boundary lines.\n        - boundary_indices: A list containing the row or column indices of the two lines.\n        - orientation: 'horizontal' or 'vertical', or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    background_color = 0 # Assuming 0 is background\n\n    # Check for horizontal lines\n    horizontal_lines = {}\n    for r in range(height):\n        row = grid[r, :]\n        unique_colors = np.unique(row)\n        if len(unique_colors) == 1 and unique_colors[0] != background_color:\n            color = unique_colors[0]\n            if color not in horizontal_lines:\n                horizontal_lines[color] = []\n            horizontal_lines[color].append(r)\n\n    for color, indices in horizontal_lines.items():\n        if len(indices) == 2:\n            return color, sorted(indices), 'horizontal'\n\n    # Check for vertical lines\n    vertical_lines = {}\n    for c in range(width):\n        col = grid[:, c]\n        unique_colors = np.unique(col)\n        if len(unique_colors) == 1 and unique_colors[0] != background_color:\n            color = unique_colors[0]\n            if color not in vertical_lines:\n                vertical_lines[color] = []\n            vertical_lines[color].append(c)\n\n    for color, indices in vertical_lines.items():\n        if len(indices) == 2:\n            return color, sorted(indices), 'vertical'\n\n    return -1, [], None # Should not happen based on examples\n\ndef find_moving_pixel(grid: np.ndarray, background_color: int, boundary_color: int) -> tuple[int, int, int]:\n    \"\"\"\n    Finds the single pixel that is not background or boundary color.\n\n    Args:\n        grid: The input grid as a numpy array.\n        background_color: The color of the background.\n        boundary_color: The color of the boundary lines.\n\n    Returns:\n        A tuple containing:\n        - row: The row index of the moving pixel.\n        - col: The column index of the moving pixel.\n        - color: The color of the moving pixel.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and color != boundary_color:\n                return r, c, color\n    return -1, -1, -1 # Should not happen\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule: moves a single pixel within two parallel boundaries.\n    The pixel moves away from the closer boundary by half the distance (floor) to the farther boundary.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    background_color = 0 # Assuming background is 0\n\n    # 1. Find the boundary lines and their orientation\n    boundary_color, boundary_indices, orientation = find_boundary_lines(grid)\n    if orientation is None:\n         # Handle cases where boundaries aren't found as expected, maybe return input?\n         # For now, assume boundaries are always present per task description\n         return input_grid # Or raise an error\n\n    b1, b2 = boundary_indices\n\n    # 2. Find the moving pixel\n    r, c, pixel_color = find_moving_pixel(grid, background_color, boundary_color)\n    if r == -1:\n         # Handle cases where moving pixel isn't found\n         return input_grid # Or raise an error\n\n    # 3. Calculate the new position based on orientation and proximity\n    r_new, c_new = r, c\n\n    if orientation == 'horizontal':\n        # Boundaries are rows b1 and b2\n        dist_b1 = abs(r - b1)\n        dist_b2 = abs(r - b2)\n\n        if dist_b1 < dist_b2: # Closer to b1 (upper boundary)\n            b_close = b1\n            b_far = b2\n            dist_far = dist_b2\n            direction = 1 # Move down\n        elif dist_b2 < dist_b1: # Closer to b2 (lower boundary)\n            b_close = b2\n            b_far = b1\n            dist_far = dist_b1\n            direction = -1 # Move up\n        else: # Equidistant (unclear from examples, assume no move or default?)\n              # Let's assume closer to b1 if equidistant, move down\n              b_close = b1\n              b_far = b2\n              dist_far = dist_b2\n              direction = 1\n\n        steps = math.floor(dist_far / 2)\n        r_new = r + direction * steps\n\n    elif orientation == 'vertical':\n        # Boundaries are columns b1 and b2\n        dist_b1 = abs(c - b1)\n        dist_b2 = abs(c - b2)\n\n        if dist_b1 < dist_b2: # Closer to b1 (left boundary)\n            b_close = b1\n            b_far = b2\n            dist_far = dist_b2\n            direction = 1 # Move right\n        elif dist_b2 < dist_b1: # Closer to b2 (right boundary)\n            b_close = b2\n            b_far = b1\n            dist_far = dist_b1\n            direction = -1 # Move left\n        else: # Equidistant\n              # Assume closer to b1 if equidistant, move right\n              b_close = b1\n              b_far = b2\n              dist_far = dist_b2\n              direction = 1\n\n        steps = math.floor(dist_far / 2)\n        c_new = c + direction * steps\n\n    # 4. Update the output grid\n    # Ensure the new position is within bounds (should be if logic is correct and pixel starts between lines)\n    height, width = output_grid.shape\n    if 0 <= r_new < height and 0 <= c_new < width:\n        output_grid[r, c] = background_color # Clear original position\n        output_grid[r_new, c_new] = pixel_color # Place pixel at new position\n    else:\n        # This case indicates an issue with the logic or input assumptions\n        print(f\"Warning: Calculated new position ({r_new}, {c_new}) is out of bounds.\")\n        # Optionally return the original grid or handle the error\n        return input_grid\n\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3237,
    "candidates_token_count": 2170,
    "total_token_count": 5407,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.90286,
  "retries": 1
}