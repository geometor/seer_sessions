{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n\n1. Identify the two distinct non-white colors (Color A, Color B) and their pixel locations (Coords A, Coords B) in the input grid.\n2. Determine which object is 'interrupted' by the other. This is done by:\n    a. Temporarily removing Color B's pixels (setting them to white) and checking if Color A's pixels remain a single connected component.\n    b. Temporarily removing Color A's pixels and checking if Color B's pixels remain a single connected component.\n3. The 'kept' color for the output is the color of the object that *became disconnected* in the test above (i.e., the 'interrupted' object).\n4. Calculate the union of the pixel locations of both original non-white objects (Union Coords = Coords A U Coords B).\n5. Create an output grid of the same dimensions as the input, filled with the background color (white, 0).\n6. Fill the pixels corresponding to the calculated Union Coords with the 'kept' color.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\n\ndef find_colors(grid: np.ndarray) -> tuple[int, int] | None:\n    \"\"\"Finds the two distinct non-background (0) colors in the grid.\"\"\"\n    unique_colors = np.unique(grid)\n    non_background_colors = unique_colors[unique_colors != 0]\n    if len(non_background_colors) == 2:\n        return tuple(non_background_colors)\n    else:\n        # Handle cases not matching the expected pattern (e.g., 0, 1, or >2 colors)\n        # Returning None allows the caller to handle this.\n        return None\n\ndef get_pixel_coords(grid: np.ndarray, color: int) -> set[tuple[int, int]]:\n    \"\"\"Gets the coordinates of all pixels with the specified color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return set(zip(rows, cols))\n\ndef is_connected(grid: np.ndarray, color: int) -> bool:\n    \"\"\"Checks if all pixels of a given color form a single connected component (4-connectivity).\"\"\"\n    # Create a binary mask for the target color\n    mask = (grid == color)\n    \n    # Check if there are any pixels of the target color first\n    if not np.any(mask):\n        return True # No pixels means trivially connected (or perhaps should be False?) - Let's align with scipy: 0 features if empty.\n\n    # Define 4-connectivity structure (von Neumann neighborhood)\n    # [[0,1,0],\n    #  [1,1,1],\n    #  [0,1,0]]\n    connectivity_structure = generate_binary_structure(2, 1) \n    \n    # Label connected components\n    labeled_array, num_features = label(mask, structure=connectivity_structure)\n    \n    # Return True if exactly one component is found (or zero if no pixels)\n    return num_features <= 1\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid based on the object interruption rule.\n    The output object takes the shape of the union of the two input objects\n    and the color of the object that was 'interrupted' (split into pieces)\n    by the other object.\n    \"\"\"\n    \n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    height, width = grid_np.shape\n    background_color = 0\n\n    # 1. Identify the two distinct non-white colors and their pixels\n    colors = find_colors(grid_np)\n    if colors is None:\n        # If not exactly two colors, return a background grid (or input?)\n        # Returning background seems safer based on ARC principles.\n        return [[background_color for _ in range(width)] for _ in range(height)]\n        \n    color_a, color_b = colors\n    coords_a = get_pixel_coords(grid_np, color_a)\n    coords_b = get_pixel_coords(grid_np, color_b)\n    \n    # Handle cases where one color might be identified but has no pixels (unlikely given find_colors logic but safe)\n    if not coords_a or not coords_b:\n        return [[background_color for _ in range(width)] for _ in range(height)]\n\n    # 2. & 3. Determine which color is interrupted / kept\n    \n    # Create a temporary grid removing color B to check A's connectivity\n    temp_grid_a = grid_np.copy()\n    for r, c in coords_b:\n        temp_grid_a[r, c] = background_color\n    a_remains_connected = is_connected(temp_grid_a, color_a)\n\n    # Create a temporary grid removing color A to check B's connectivity\n    temp_grid_b = grid_np.copy()\n    for r, c in coords_a:\n        temp_grid_b[r, c] = background_color\n    b_remains_connected = is_connected(temp_grid_b, color_b)\n\n    kept_color = -1 # Initialize with invalid value\n\n    # The kept color belongs to the object that DID NOT remain connected\n    if not a_remains_connected and b_remains_connected:\n        # A became disconnected when B was removed, B remained connected when A was removed.\n        # This means B interrupted A. Keep color A.\n        kept_color = color_a\n    elif a_remains_connected and not b_remains_connected:\n        # B became disconnected when A was removed, A remained connected when B was removed.\n        # This means A interrupted B. Keep color B.\n        kept_color = color_b\n    else:\n        # Ambiguous case: both remained connected, both became disconnected, or an issue with connectivity check.\n        # Based on examples, this shouldn't happen. Return background grid.\n        return [[background_color for _ in range(width)] for _ in range(height)]\n        \n    # 4. Calculate the union of pixel locations\n    union_coords = coords_a.union(coords_b)\n\n    # 5. Create the output grid, initially filled with background color\n    output_grid_np = np.full((height, width), background_color, dtype=int)\n\n    # 6. Fill the union shape with the kept color\n    for r, c in union_coords:\n        # Ensure coordinates are within bounds (should be by definition, but safe)\n        if 0 <= r < height and 0 <= c < width:\n            output_grid_np[r, c] = kept_color\n\n    # Convert back to list of lists for the required output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8926,
    "candidates_token_count": 2025,
    "total_token_count": 10951,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.961499,
  "retries": 1
}