{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the two distinct colored objects in the input grid against a white background.\nDetermines the smaller object (based on bounding box area) as the \"mover\" and the larger as \"stationary\".\nCalculates the translation needed to move the \"mover\" object directly towards the \"stationary\" object until they are adjacent (1 pixel apart) along the primary axis of separation (horizontal or vertical).\nApplies this translation to the mover object, erasing it from its original position and drawing it in the new position, leaving the stationary object and background unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> list[dict]:\n    \"\"\"\n    Finds connected components (objects) of non-background colors in the grid.\n\n    Args:\n        grid: The input grid as a numpy array.\n        background_color: The integer value representing the background.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'color', 'coords' (set of (r, c) tuples), and 'bbox'\n        (min_r, min_c, max_r, max_c). Returns empty list if no objects found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 8 neighbors (including diagonals for connectivity)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                objects.append({\n                    'color': color,\n                    'coords': coords,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef get_bounding_box(coords: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of coordinates.\"\"\"\n    if not coords:\n        return (0, 0, 0, 0)\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef calculate_area(bbox: tuple[int, int, int, int]) -> int:\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return (max_r - min_r + 1) * (max_c - min_c + 1)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Moves the smaller of two objects adjacent to the larger object.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    background_color = 0 # Assuming white is background\n\n    # 1. Identify the two distinct colored objects\n    objects = find_objects(input_np, background_color)\n\n    # Ensure exactly two objects are found\n    if len(objects) != 2:\n        # If not exactly two objects, return the original grid\n        return input_grid\n\n    # 2. Determine bounding boxes and areas\n    obj1 = objects[0]\n    obj2 = objects[1]\n    obj1['area'] = calculate_area(obj1['bbox'])\n    obj2['area'] = calculate_area(obj2['bbox'])\n\n    # 3. Designate mover (smaller) and stationary (larger)\n    if obj1['area'] <= obj2['area']: # Treat equal area case arbitrarily or check pixel count? Sticking to area for now.\n        mover = obj1\n        stationary = obj2\n    else:\n        mover = obj2\n        stationary = obj1\n\n    # Extract bounding box coordinates for easier access\n    m_min_r, m_min_c, m_max_r, m_max_c = mover['bbox']\n    s_min_r, s_min_c, s_max_r, s_max_c = stationary['bbox']\n\n    # 4. Determine the primary axis of separation and direction\n    # Calculate center points (approximate)\n    mover_center_r = (m_min_r + m_max_r) / 2\n    mover_center_c = (m_min_c + m_max_c) / 2\n    stat_center_r = (s_min_r + s_max_r) / 2\n    stat_center_c = (s_min_c + s_max_c) / 2\n\n    delta_r = stat_center_r - mover_center_r\n    delta_c = stat_center_c - mover_center_c\n\n    move_horizontally = abs(delta_c) >= abs(delta_r) # Move along the axis with greater separation\n\n    # 5. Calculate the target position and translation delta (dx, dy)\n    dx = 0\n    dy = 0\n\n    if move_horizontally:\n        # Move left or right\n        if delta_c > 0: # Mover is to the left of stationary, move right\n            target_min_c = s_min_c - 1 - (m_max_c - m_min_c)\n            dx = target_min_c - m_min_c\n        else: # Mover is to the right of stationary, move left\n            target_min_c = s_max_c + 1\n            dx = target_min_c - m_min_c\n    else:\n        # Move up or down\n        if delta_r > 0: # Mover is above stationary, move down\n            target_min_r = s_min_r - 1 - (m_max_r - m_min_r)\n            dy = target_min_r - m_min_r\n        else: # Mover is below stationary, move up\n            target_min_r = s_max_r + 1\n            dy = target_min_r - m_min_r\n\n    # 6. Create the output grid: erase old, draw new\n    # Erase mover from original position\n    mover_color = mover['color']\n    for r, c in mover['coords']:\n        output_grid[r, c] = background_color\n\n    # Draw mover at the new position\n    for r, c in mover['coords']:\n        new_r, new_c = r + dy, c + dx\n        # Check bounds just in case, although logic should keep it within grid\n        if 0 <= new_r < output_grid.shape[0] and 0 <= new_c < output_grid.shape[1]:\n            output_grid[new_r, new_c] = mover_color\n        else:\n             # This case indicates an issue with calculation or assumptions\n             print(f\"Warning: Calculated new position ({new_r}, {new_c}) is out of bounds.\")\n\n\n    # Convert back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3607,
    "candidates_token_count": 2541,
    "total_token_count": 6148,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.337799,
  "retries": 1
}