{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThis module transforms an input grid based on the ARC task rules.\nThe transformation identifies a horizontal and a vertical line within the grid.\nIt finds the shortest path composed of white pixels (color 0) connecting these two lines.\nThese identified 'gap' pixels are then filled with a specific color determined by the orientation\nof the gap path:\n- If the gap path is vertical (all gap pixels share the same column), it's filled with the color\n  of the vertical line.\n- If the gap path is horizontal (all gap pixels share the same row), it's filled with the color\n  of the horizontal line.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid_np: np.ndarray) -> list[dict]:\n    \"\"\"\n    Finds connected components (objects) of the same non-background color (0)\n    in the grid and identifies those that form straight horizontal or vertical lines.\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a line object\n        and contains its color, pixels, orientation ('horizontal' or 'vertical'),\n        and bounding coordinates/indices. Returns an empty list if no lines are found.\n    \"\"\"\n    rows, cols = grid_np.shape\n    visited = np.zeros_like(grid_np, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid_np[r, c]\n            # If it's a non-background color (not 0) and not visited yet\n            if color != 0 and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Perform Breadth-First Search (BFS) to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    # Update bounding box\n                    min_r, max_r = min(min_r, row), max(max_r, row)\n                    min_c, max_c = min(min_c, col), max(max_c, col)\n\n                    # Explore neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check grid boundaries and if neighbor is the same color and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid_np[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # After finding all pixels of the object, check if it forms a straight line\n                is_line = False\n                orientation = None\n                if len(obj_pixels) > 0:\n                     # Calculate object's width and height from bounding box\n                     width = max_c - min_c + 1\n                     height = max_r - min_r + 1\n                     \n                     # A vertical line has width 1 and height equal to the number of pixels\n                     if width == 1 and height == len(obj_pixels):\n                         orientation = 'vertical'\n                         is_line = True\n                     # A horizontal line has height 1 and width equal to the number of pixels\n                     elif height == 1 and width == len(obj_pixels):\n                         orientation = 'horizontal'\n                         is_line = True\n                \n                # Store the object details if it's identified as a line\n                if is_line:\n                     objects.append({\n                         'color': color,\n                         'pixels': sorted(obj_pixels), # Sort pixels for consistent processing\n                         'orientation': orientation,\n                         'row': min_r if orientation == 'horizontal' else None, # Row index for H-line\n                         'col': min_c if orientation == 'vertical' else None,   # Col index for V-line\n                         'rows': (min_r, max_r) if orientation == 'vertical' else None, # Row span for V-line\n                         'cols': (min_c, max_c) if orientation == 'horizontal' else None, # Col span for H-line\n                     })\n    return objects\n\ndef manhattan_distance(p1: tuple[int, int], p2: tuple[int, int]) -> int:\n    \"\"\"Calculates the Manhattan distance between two points (row, col).\"\"\"\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies a horizontal and a vertical line, finds the white pixel gap\n    between their closest points, and fills the gap based on its orientation.\n\n    Args:\n        input_grid: A list of lists representing the input grid with integer colors.\n\n    Returns:\n        A list of lists representing the transformed output grid. Returns the\n        original grid if the expected pattern (one horizontal, one vertical line)\n        is not found or if no gap exists.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify; the original input remains unchanged\n    output_np = np.copy(input_np)\n    rows, cols = input_np.shape\n\n    # --- 1. Identify the horizontal and vertical lines ---\n    # Find all line objects in the grid\n    objects = find_objects(input_np)\n\n    h_line = None\n    v_line = None\n    # Assign the found lines based on their orientation\n    for obj in objects:\n        if obj['orientation'] == 'horizontal':\n            h_line = obj\n        elif obj['orientation'] == 'vertical':\n            v_line = obj\n    \n    # Check if exactly one horizontal and one vertical line were found\n    # If not, the input doesn't match the expected pattern, return the original grid\n    if h_line is None or v_line is None:\n         return input_grid \n\n    # --- 2. Find the pair of closest pixels between the two lines ---\n    min_dist = float('inf')\n    h_closest = None # Pixel on the horizontal line closest to the vertical line\n    v_closest = None # Pixel on the vertical line closest to the horizontal line\n\n    # Compare every pixel in the horizontal line with every pixel in the vertical line\n    for hp in h_line['pixels']:\n        for vp in v_line['pixels']:\n            # Calculate the Manhattan distance between the pair of pixels\n            dist = manhattan_distance(hp, vp)\n            # If this distance is smaller than the minimum found so far, update\n            if dist < min_dist:\n                min_dist = dist\n                h_closest = hp\n                v_closest = vp\n\n    # If closest points couldn't be determined (e.g., if a line was empty, though find_objects should prevent this)\n    if h_closest is None or v_closest is None:\n        return input_grid \n\n    # --- 3. Determine the gap path, axis, and fill color ---\n    gap_pixels = [] # List to store coordinates (row, col) of pixels in the gap\n    fill_color = 0  # Color to fill the gap with (initialized to background)\n\n    hr, hc = h_closest # Coordinates of the closest pixel on the H-line\n    vr, vc = v_closest # Coordinates of the closest pixel on the V-line\n\n    # Check if the closest points align vertically (share the same column index)\n    if hc == vc:\n        # This indicates a potential vertical gap along column 'hc'\n        # Rule: Fill vertical gap with the vertical line's color\n        fill_color = v_line['color']\n        # Iterate through rows strictly between the closest points' rows\n        # The range ensures we only consider pixels *between* the lines\n        for r in range(min(hr, vr) + 1, max(hr, vr)):\n            # Check if the coordinate is within the grid bounds\n            if 0 <= r < rows and 0 <= hc < cols:\n                 # If the pixel at (r, hc) is white (0), it's part of the gap\n                 if input_np[r, hc] == 0:\n                     gap_pixels.append((r, hc))\n                 else:\n                     # If any pixel on this path isn't white, it's not a valid gap\n                     gap_pixels = [] # Discard potential gap pixels found so far\n                     break # Stop checking this path\n            else: # If coordinate is out of bounds, path is invalid\n                 gap_pixels = []\n                 break\n\n    # Check if the closest points align horizontally (share the same row index)\n    elif hr == vr:\n        # This indicates a potential horizontal gap along row 'hr'\n        # Rule: Fill horizontal gap with the horizontal line's color\n        fill_color = h_line['color']\n        # Iterate through columns strictly between the closest points' columns\n        for c in range(min(hc, vc) + 1, max(hc, vc)):\n             # Check if the coordinate is within the grid bounds\n             if 0 <= hr < rows and 0 <= c < cols:\n                  # If the pixel at (hr, c) is white (0), it's part of the gap\n                  if input_np[hr, c] == 0:\n                      gap_pixels.append((hr, c))\n                  else:\n                      # If any pixel on this path isn't white, it's not a valid gap\n                      gap_pixels = [] # Discard potential gap pixels\n                      break # Stop checking this path\n             else: # If coordinate is out of bounds, path is invalid\n                 gap_pixels = []\n                 break\n    \n    # If the closest points are neither vertically nor horizontally aligned,\n    # it implies a diagonal relationship or an unexpected configuration.\n    # In such cases, gap_pixels remains empty, and no filling occurs.\n\n    # --- 4. Fill the identified gap pixels in the output grid ---\n    # Check if a valid gap was found (gap_pixels is not empty) and a fill color was determined\n    if gap_pixels and fill_color != 0:\n        # Iterate through the coordinates of the gap pixels\n        for r_gap, c_gap in gap_pixels:\n            # Update the corresponding pixel in the output grid with the fill color\n            output_np[r_gap, c_gap] = fill_color\n\n    # Convert the modified NumPy array back to a standard Python list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2699,
    "candidates_token_count": 14252,
    "total_token_count": 16951,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 98.966072,
  "retries": 1
}