{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nMove a single pixel towards a boundary line until adjacent.\n\nThe transformation identifies a single 'moving' pixel and a 'boundary' line \n(a horizontal or vertical line of a single color along one edge of the grid).\nThe moving pixel is moved in a straight line, perpendicular to the boundary, \nuntil it reaches the position immediately adjacent to the boundary line. \nThe background color is assumed to be 0 (white).\n\"\"\"\n\ndef find_boundary_line(grid: list[list[int]]) -> tuple[int, str, int] | None:\n    \"\"\"\n    Finds the boundary line in the grid.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing (color, orientation, index) if found, else None.\n        orientation is 'h' for horizontal, 'v' for vertical.\n        index is the row index for 'h' or column index for 'v'.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    background_color = 0 # Assuming white background\n\n    # Check top edge (horizontal)\n    first_pixel_color = grid[0][0]\n    if first_pixel_color != background_color and all(grid[0][j] == first_pixel_color for j in range(width)):\n        return first_pixel_color, 'h', 0\n\n    # Check bottom edge (horizontal)\n    first_pixel_color = grid[height - 1][0]\n    if first_pixel_color != background_color and all(grid[height - 1][j] == first_pixel_color for j in range(width)):\n        return first_pixel_color, 'h', height - 1\n\n    # Check left edge (vertical)\n    first_pixel_color = grid[0][0]\n    if first_pixel_color != background_color and all(grid[i][0] == first_pixel_color for i in range(height)):\n        # Check if top edge wasn't already identified as the boundary\n        top_edge_color = grid[0][0]\n        is_top_edge_boundary = top_edge_color != background_color and all(grid[0][j] == top_edge_color for j in range(width))\n        if not is_top_edge_boundary:\n             return first_pixel_color, 'v', 0\n        # Need to be careful here - if the top-left corner belongs to both a horizontal and vertical line.\n        # Let's refine: Find the *predominant* line color on the edge.\n\n    # Check right edge (vertical)\n    first_pixel_color = grid[0][width - 1]\n    if first_pixel_color != background_color and all(grid[i][width - 1] == first_pixel_color for i in range(height)):\n         return first_pixel_color, 'v', width - 1\n\n    # Refined edge check - handle corners and partial lines more explicitly\n    # Scan edges again, prioritizing full lines\n    \n    # Top edge\n    if grid[0][0] != background_color and all(grid[0][j] == grid[0][0] for j in range(width)):\n        return grid[0][0], 'h', 0\n    # Bottom edge\n    if grid[height-1][0] != background_color and all(grid[height-1][j] == grid[height-1][0] for j in range(width)):\n        return grid[height-1][0], 'h', height - 1\n    # Left edge\n    if grid[0][0] != background_color and all(grid[i][0] == grid[0][0] for i in range(height)):\n         # Avoid conflict if top-left is part of horizontal boundary already checked\n         is_top_boundary = grid[0][0] != background_color and all(grid[0][j] == grid[0][0] for j in range(width))\n         if not is_top_boundary:\n            return grid[0][0], 'v', 0\n    # Right edge\n    if grid[0][width-1] != background_color and all(grid[i][width-1] == grid[0][width-1] for i in range(height)):\n        # Avoid conflict if top-right is part of horizontal boundary\n        is_top_boundary = grid[0][0] != background_color and all(grid[0][j] == grid[0][0] for j in range(width))\n        # This check isn't quite right. Let's check if the pixel grid[0][width-1] could belong to the top boundary\n        top_boundary_color_if_exists = grid[0][0] if is_top_boundary else -1 # Use -1 if no top boundary\n        if not (is_top_boundary and grid[0][width-1] == top_boundary_color_if_exists) :\n             return grid[0][width-1], 'v', width - 1\n\n    # If full lines weren't found (e.g. example 1), check again allowing variations,\n    # or maybe rethink the definition based on examples.\n    # Example 1: Vertical line at col 9, color 4.\n    # Example 2: Horizontal line at row 0, color 3.\n\n    # Let's find the most frequent non-background color on each edge.\n    edge_candidates = []\n    # Top\n    colors = [grid[0][j] for j in range(width) if grid[0][j] != background_color]\n    if colors:\n        top_color = max(set(colors), key=colors.count)\n        if all(c == top_color or c == background_color for c in grid[0]): # Allow background gaps\n             edge_candidates.append({'color': top_color, 'orientation': 'h', 'index': 0, 'count': colors.count(top_color)})\n             \n    # Bottom\n    colors = [grid[height-1][j] for j in range(width) if grid[height-1][j] != background_color]\n    if colors:\n        bottom_color = max(set(colors), key=colors.count)\n        if all(c == bottom_color or c == background_color for c in grid[height-1]):\n             edge_candidates.append({'color': bottom_color, 'orientation': 'h', 'index': height - 1, 'count': colors.count(bottom_color)})\n             \n    # Left\n    colors = [grid[i][0] for i in range(height) if grid[i][0] != background_color]\n    if colors:\n        left_color = max(set(colors), key=colors.count)\n        if all(c == left_color or c == background_color for c in [grid[i][0] for i in range(height)]):\n             edge_candidates.append({'color': left_color, 'orientation': 'v', 'index': 0, 'count': colors.count(left_color)})\n             \n    # Right\n    colors = [grid[i][width-1] for i in range(height) if grid[i][width-1] != background_color]\n    if colors:\n        right_color = max(set(colors), key=colors.count)\n        if all(c == right_color or c == background_color for c in [grid[i][width-1] for i in range(height)]):\n             edge_candidates.append({'color': right_color, 'orientation': 'v', 'index': width - 1, 'count': colors.count(right_color)})\n             \n    # Choose the candidate with the most pixels (longest line)\n    if edge_candidates:\n        best_candidate = max(edge_candidates, key=lambda x: x['count'])\n        return best_candidate['color'], best_candidate['orientation'], best_candidate['index']\n        \n    return None # No clear boundary line found\n\n\ndef find_moving_pixel(grid: list[list[int]], boundary_color: int) -> tuple[int, int, int] | None:\n    \"\"\"\n    Finds the single moving pixel (not background and not boundary color).\n\n    Args:\n        grid: The input grid.\n        boundary_color: The color of the boundary line.\n\n    Returns:\n        A tuple containing (color, row, column) if found, else None.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    background_color = 0 # Assuming white background\n    moving_pixel = None\n    count = 0\n\n    for r in range(height):\n        for c in range(width):\n            pixel_color = grid[r][c]\n            if pixel_color != background_color and pixel_color != boundary_color:\n                # Check if this pixel is part of the boundary line even if color matches? No, boundary is on edge.\n                moving_pixel = (pixel_color, r, c)\n                count += 1\n\n    # Expect exactly one moving pixel\n    if count == 1:\n        return moving_pixel\n    else:\n        # Handle cases with zero or multiple potential movers if needed,\n        # but based on examples, expect exactly one.\n        # print(f\"Warning: Found {count} potential moving pixels.\")\n        return None\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Moves a single colored pixel towards a static boundary line along an edge \n    until it is immediately adjacent to the boundary. The movement is perpendicular \n    to the boundary line.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n    background_color = 0 # Assuming white background\n\n    # 1. Identify the boundary line\n    boundary_info = find_boundary_line(output_grid)\n    if boundary_info is None:\n        # print(\"Error: Boundary line not found.\")\n        return output_grid # Return original grid if no boundary found\n    boundary_color, boundary_orientation, boundary_index = boundary_info\n    \n    # 2. Identify the moving pixel\n    mover_info = find_moving_pixel(output_grid, boundary_color)\n    if mover_info is None:\n        # print(\"Error: Moving pixel not found or ambiguous.\")\n        return output_grid # Return original grid if no mover found\n    mover_color, original_row, original_col = mover_info\n\n    # 3. Erase the moving pixel from its original position\n    output_grid[original_row][original_col] = background_color\n\n    # 4. Determine the target position\n    target_row, target_col = original_row, original_col # Initialize\n\n    if boundary_orientation == 'h': # Horizontal boundary\n        # Mover moves vertically\n        target_col = original_col # Column stays the same\n        if boundary_index == 0: # Top boundary\n            target_row = boundary_index + 1\n        elif boundary_index == height - 1: # Bottom boundary\n             target_row = boundary_index - 1\n        else: # Should not happen based on find_boundary_line logic\n            # print(\"Error: Horizontal boundary not at top or bottom edge?\")\n            return output_grid \n            \n    elif boundary_orientation == 'v': # Vertical boundary\n        # Mover moves horizontally\n        target_row = original_row # Row stays the same\n        if boundary_index == 0: # Left boundary\n            target_col = boundary_index + 1\n        elif boundary_index == width - 1: # Right boundary\n             target_col = boundary_index - 1\n        else: # Should not happen\n             # print(\"Error: Vertical boundary not at left or right edge?\")\n             return output_grid\n\n    # 5. Place the moving pixel at the target position\n    # Ensure target position is within bounds (should be guaranteed by logic)\n    if 0 <= target_row < height and 0 <= target_col < width:\n        output_grid[target_row][target_col] = mover_color\n    else:\n        # print(f\"Error: Calculated target position ({target_row}, {target_col}) is out of bounds.\")\n        # Revert the erase operation? Or return partially modified grid?\n        # Let's revert for safety, although this indicates a logic flaw.\n        output_grid[original_row][original_col] = mover_color # Put it back\n        return output_grid\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2709,
    "candidates_token_count": 3884,
    "total_token_count": 6593,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 28.565232,
  "retries": 1
}