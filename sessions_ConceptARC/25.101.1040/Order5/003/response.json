{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nimport numpy as np\n\n\"\"\"\nThe transformation operates on a grid divided into four sections by vertical green lines.\nSections are defined by column ranges: Sec 1 (1-4), Sec 2 (6-9), Sec 3 (11-14), Sec 4 (16-19).\nThe transformation involves swapping the yellow pixel (color 4) patterns between sections.\n\nThe scope of the swap depends on the total count of yellow pixels in the input grid:\n1. If the total yellow count is EVEN:\n   - The pattern in Section 1 is swapped with the pattern in Section 4.\n   - The pattern in Section 2 is swapped with the pattern in Section 3.\n2. If the total yellow count is ODD:\n   - ONLY the pattern in Section 1 is swapped with the pattern in Section 4.\n   - Sections 2 and 3 remain unchanged.\n\nPatterns are defined by the relative positions of yellow pixels within a section, anchored by the top-leftmost yellow pixel. When swapped, the pattern retains its shape, and its top-left anchor is placed at the same row as the original anchor but in the starting column of the destination section.\n\"\"\"\n\ndef find_yellow_pattern(grid: list[list[int]], start_col: int, end_col: int) -> tuple[int | None, int | None, list[tuple[int, int]]]:\n    \"\"\"\n    Finds all yellow pixels within the specified column bounds.\n    Calculates their coordinates relative to the top-leftmost yellow pixel found.\n\n    Args:\n        grid: The input grid.\n        start_col: The starting column index (inclusive) of the section.\n        end_col: The ending column index (inclusive) of the section.\n\n    Returns:\n        A tuple containing:\n        - The row index of the top-leftmost yellow pixel (or None if no yellow pixels).\n        - The column index of the top-leftmost yellow pixel (or None if no yellow pixels).\n        - A list of relative coordinates (row_offset, col_offset) for all yellow pixels \n          relative to the top-leftmost pixel (or an empty list if none found).\n    \"\"\"\n    coords = []\n    min_row, min_col = float('inf'), float('inf')\n    found_yellow = False\n    height = len(grid)\n    \n    for r in range(height):\n        # Ensure column index is within grid bounds\n        current_end_col = min(end_col, len(grid[0]) - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] == 4: # 4 is yellow\n                coords.append((r, c))\n                found_yellow = True\n                if r < min_row:\n                    min_row = r\n                    min_col = c # Reset min_col when a new min_row is found\n                elif r == min_row and c < min_col:\n                    min_col = c # Update min_col if on the same min_row\n\n    if not found_yellow:\n        return None, None, []\n\n    # Calculate relative coordinates based on the found top-leftmost pixel\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    \n    return min_row, min_col, relative_coords\n\ndef clear_section(grid: list[list[int]], start_col: int, end_col: int):\n    \"\"\"\n    Sets all pixels within the specified column bounds to white (0).\n\n    Args:\n        grid: The grid to modify (should be the output grid).\n        start_col: The starting column index (inclusive).\n        end_col: The ending column index (inclusive).\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    for r in range(height):\n         # Ensure column index is within grid bounds\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            grid[r][c] = 0 # 0 is white\n\ndef place_pattern(grid: list[list[int]], anchor_row: int, target_start_col: int, relative_coords: list[tuple[int, int]]):\n    \"\"\"\n    Places a pattern of yellow pixels onto the grid based on an anchor point and relative coordinates.\n\n    Args:\n        grid: The grid to modify (should be the output grid).\n        anchor_row: The row index for the top-leftmost pixel of the pattern.\n        target_start_col: The column index for the top-leftmost pixel of the pattern.\n        relative_coords: A list of (row_offset, col_offset) tuples defining the pattern.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    for rel_r, rel_c in relative_coords:\n        target_row = anchor_row + rel_r\n        target_col = target_start_col + rel_c\n        # Check if the target coordinates are within the grid bounds\n        if 0 <= target_row < height and 0 <= target_col < width:\n            grid[target_row][target_col] = 4 # 4 is yellow\n\ndef count_total_yellows(grid: list[list[int]]) -> int:\n    \"\"\"Counts the total number of yellow pixels (4) in the grid.\"\"\"\n    count = 0\n    for row in grid:\n        for cell in row:\n            if cell == 4:\n                count += 1\n    return count\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    \n    # Count total yellow pixels to determine swap scope\n    total_yellows = count_total_yellows(input_grid)\n    swap_all = (total_yellows % 2 == 0)\n\n    # Define section column boundaries (inclusive)\n    sections = {\n        1: (1, 4),\n        2: (6, 9),\n        3: (11, 14),\n        4: (16, 19)\n    }\n    \n    # --- Step 1: Identify all patterns ---\n    patterns = {}\n    for sec_id, (start, end) in sections.items():\n        patterns[sec_id] = find_yellow_pattern(input_grid, start, end) # (anchor_row, anchor_col, rel_coords)\n\n    # --- Step 2: Clear relevant sections in the output grid ---\n    clear_section(output_grid, sections[1][0], sections[1][1])\n    clear_section(output_grid, sections[4][0], sections[4][1])\n    if swap_all:\n        clear_section(output_grid, sections[2][0], sections[2][1])\n        clear_section(output_grid, sections[3][0], sections[3][1])\n\n    # --- Step 3: Place swapped patterns ---\n    \n    # Swap 1 <-> 4 (always happens)\n    anchor_row1, _, rel_coords1 = patterns[1]\n    anchor_row4, _, rel_coords4 = patterns[4]\n    \n    if anchor_row1 is not None:\n        place_pattern(output_grid, anchor_row1, sections[4][0], rel_coords1) # Place P1 in Sec 4\n    if anchor_row4 is not None:\n        place_pattern(output_grid, anchor_row4, sections[1][0], rel_coords4) # Place P4 in Sec 1\n\n    # Conditionally swap 2 <-> 3\n    if swap_all:\n        anchor_row2, _, rel_coords2 = patterns[2]\n        anchor_row3, _, rel_coords3 = patterns[3]\n\n        if anchor_row2 is not None:\n            place_pattern(output_grid, anchor_row2, sections[3][0], rel_coords2) # Place P2 in Sec 3\n        if anchor_row3 is not None:\n            place_pattern(output_grid, anchor_row3, sections[2][0], rel_coords3) # Place P3 in Sec 2\n    # Else (if not swap_all): Sections 2 and 3 remain as they were in the initial deepcopy\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15581,
    "candidates_token_count": 2421,
    "total_token_count": 18002,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.752926,
  "retries": 1
}