{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n# No other standard libraries like numpy are needed based on the logic.\n\n\"\"\"\nThe transformation operates on a grid divided into four sections by vertical green lines (color 3).\nSections are defined by column ranges: Sec 1 (cols 1-4), Sec 2 (cols 6-9), Sec 3 (cols 11-14), Sec 4 (cols 16-19).\nThe transformation involves moving the yellow pixel (color 4) patterns between sections based on a condition.\n\nCondition: Count the number of yellow pixels in Section 3 (cols 11-14) of the input grid.\nRule A (If count == 3): Swap patterns between Section 1 and Section 4. Sections 2 and 3 remain unchanged.\nRule B (If count != 3): Cycle patterns: Pattern from Section 1 moves to Section 3, pattern from Section 3 moves to Section 4, pattern from Section 4 moves to Section 1. Section 2 remains unchanged.\n\nPatterns are defined by the relative positions of yellow pixels within a section, anchored by the top-leftmost yellow pixel. When moved, the pattern retains its shape, and its top-left anchor is placed at the same row as the original anchor but in the starting column of the destination section.\n\"\"\"\n\ndef find_yellow_pattern(grid: list[list[int]], start_col: int, end_col: int) -> tuple[int | None, list[tuple[int, int]]]:\n    \"\"\"\n    Finds all yellow pixels within the specified column bounds.\n    Calculates their coordinates relative to the top-leftmost yellow pixel found.\n\n    Args:\n        grid: The input grid.\n        start_col: The starting column index (inclusive) of the section.\n        end_col: The ending column index (inclusive) of the section.\n\n    Returns:\n        A tuple containing:\n        - The row index of the top-leftmost yellow pixel (or None if no yellow pixels).\n        - A list of relative coordinates (row_offset, col_offset) for all yellow pixels \n          relative to the top-leftmost pixel (or an empty list if none found).\n    \"\"\"\n    coords = []\n    min_row, min_col = float('inf'), float('inf')\n    found_yellow = False\n    height = len(grid)\n    \n    for r in range(height):\n        # Ensure column index is within grid bounds\n        current_end_col = min(end_col, len(grid[0]) - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] == 4: # 4 is yellow\n                coords.append((r, c))\n                found_yellow = True\n                if r < min_row:\n                    min_row = r\n                    min_col = c # Reset min_col when a new min_row is found\n                elif r == min_row and c < min_col:\n                    min_col = c # Update min_col if on the same min_row\n\n    if not found_yellow:\n        return None, []\n\n    # Calculate relative coordinates based on the found top-leftmost pixel\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    \n    return min_row, relative_coords\n\ndef clear_section(grid: list[list[int]], start_col: int, end_col: int):\n    \"\"\"\n    Sets all pixels within the specified column bounds to white (0) in the given grid.\n\n    Args:\n        grid: The grid to modify (should be the output grid).\n        start_col: The starting column index (inclusive).\n        end_col: The ending column index (inclusive).\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    for r in range(height):\n         # Ensure column index is within grid bounds\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            # Only clear if it's within bounds, don't clear separators (color 3)\n            if grid[r][c] != 3: \n                grid[r][c] = 0 # 0 is white\n\ndef place_pattern(grid: list[list[int]], anchor_row: int | None, target_start_col: int, relative_coords: list[tuple[int, int]]):\n    \"\"\"\n    Places a pattern of yellow pixels onto the grid based on an anchor point and relative coordinates.\n    Does nothing if anchor_row is None.\n\n    Args:\n        grid: The grid to modify (should be the output grid).\n        anchor_row: The row index for the top-leftmost pixel of the pattern.\n        target_start_col: The column index for the top-leftmost pixel of the pattern.\n        relative_coords: A list of (row_offset, col_offset) tuples defining the pattern.\n    \"\"\"\n    if anchor_row is None:\n        return # No pattern to place\n\n    height = len(grid)\n    width = len(grid[0])\n    for rel_r, rel_c in relative_coords:\n        target_row = anchor_row + rel_r\n        target_col = target_start_col + rel_c\n        # Check if the target coordinates are within the grid bounds\n        if 0 <= target_row < height and 0 <= target_col < width:\n            grid[target_row][target_col] = 4 # 4 is yellow\n\ndef count_yellows_in_section(grid: list[list[int]], start_col: int, end_col: int) -> int:\n    \"\"\"Counts the number of yellow pixels (4) within the specified column bounds.\"\"\"\n    count = 0\n    height = len(grid)\n    for r in range(height):\n        current_end_col = min(end_col, len(grid[0]) - 1)\n        for c in range(start_col, current_end_col + 1):\n             if grid[r][c] == 4:\n                 count += 1\n    return count\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    \n    # Define section boundaries (inclusive) and start columns\n    sections = {\n        # id: (start_col, end_col)\n        1: (1, 4),\n        2: (6, 9),\n        3: (11, 14),\n        4: (16, 19)\n    }\n    section_start_cols = {\n        1: 1,\n        2: 6,\n        3: 11,\n        4: 16\n    }\n\n    # --- Step 1: Identify all patterns from INPUT grid ---\n    patterns = {} # Stores {sec_id: (anchor_row, relative_coords)}\n    for sec_id, (start, end) in sections.items():\n        anchor_row, rel_coords = find_yellow_pattern(input_grid, start, end)\n        patterns[sec_id] = (anchor_row, rel_coords)\n\n    # --- Step 2: Determine the rule based on Section 3 yellow count ---\n    sec3_yellow_count = count_yellows_in_section(input_grid, sections[3][0], sections[3][1])\n    \n    # --- Step 3: Apply transformation rule ---\n    if sec3_yellow_count == 3:\n        # Rule A: Swap 1 <=> 4. Keep 2, 3 unchanged.\n        # We only need to modify sections 1 and 4 in the output grid.\n        \n        # Clear target sections in output grid\n        clear_section(output_grid, sections[1][0], sections[1][1])\n        clear_section(output_grid, sections[4][0], sections[4][1])\n\n        # Place pattern from input Sec 1 into output Sec 4\n        anchor_row1, rel_coords1 = patterns[1]\n        place_pattern(output_grid, anchor_row1, section_start_cols[4], rel_coords1)\n        \n        # Place pattern from input Sec 4 into output Sec 1\n        anchor_row4, rel_coords4 = patterns[4]\n        place_pattern(output_grid, anchor_row4, section_start_cols[1], rel_coords4)\n        \n        # Sections 2 and 3 implicitly remain unchanged due to the initial deepcopy\n\n    else:\n        # Rule B: Cycle 1 -> 3 -> 4 -> 1. Keep 2 unchanged.\n        # We need to modify sections 1, 3, and 4 in the output grid.\n        \n        # Clear target sections in output grid\n        clear_section(output_grid, sections[1][0], sections[1][1])\n        clear_section(output_grid, sections[3][0], sections[3][1])\n        clear_section(output_grid, sections[4][0], sections[4][1])\n\n        # Place pattern from input Sec 1 into output Sec 3\n        anchor_row1, rel_coords1 = patterns[1]\n        place_pattern(output_grid, anchor_row1, section_start_cols[3], rel_coords1)\n\n        # Place pattern from input Sec 3 into output Sec 4\n        anchor_row3, rel_coords3 = patterns[3]\n        place_pattern(output_grid, anchor_row3, section_start_cols[4], rel_coords3)\n\n        # Place pattern from input Sec 4 into output Sec 1\n        anchor_row4, rel_coords4 = patterns[4]\n        place_pattern(output_grid, anchor_row4, section_start_cols[1], rel_coords4)\n\n        # Section 2 implicitly remains unchanged due to the initial deepcopy\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24827,
    "candidates_token_count": 2931,
    "total_token_count": 27758,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.205862,
  "retries": 1
}