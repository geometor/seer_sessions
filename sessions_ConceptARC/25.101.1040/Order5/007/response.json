{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nThe transformation operates on a grid divided into four sections by vertical green lines (color 3).\nSections are defined by column ranges: Sec 1 (cols 1-4), Sec 2 (cols 6-9), Sec 3 (cols 11-14), Sec 4 (cols 16-19).\nThe transformation rule depends on the count of yellow pixels (color 4) in Section 3 (cols 11-14) of the input grid.\n\nRule A (If count == 3):\n- Swap Section 1 and Section 4 content using direct column translation.\n- Yellow pixels from input Sec 1 move +15 columns to output Sec 4.\n- Yellow pixels from input Sec 4 move -15 columns to output Sec 1.\n- Sections 2 and 3 remain unchanged.\n\nRule B (If count != 3):\n- Cycle patterns using anchor-based relative placement: 1 -> 3, 3 -> 4, 4 -> 1.\n- The pattern (relative coordinates) is identified based on the top-leftmost yellow pixel (anchor) in the source section.\n- The pattern is placed in the target section such that the anchor lands at its original row but in the starting column of the target section.\n- Section 2 remains unchanged.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef count_yellows_in_section(grid: list[list[int]], start_col: int, end_col: int) -> int:\n    \"\"\"Counts the number of yellow pixels (4) within the specified column bounds.\"\"\"\n    count = 0\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    for r in range(height):\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] == 4:\n                count += 1\n    return count\n\ndef get_yellow_pixels_coords(grid: list[list[int]], start_col: int, end_col: int) -> list[tuple[int, int]]:\n    \"\"\"Gets absolute coordinates (r, c) of all yellow pixels in a section.\"\"\"\n    coords = []\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    for r in range(height):\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] == 4:\n                coords.append((r, c))\n    return coords\n\ndef find_yellow_pattern_anchor_relative(grid: list[list[int]], start_col: int, end_col: int) -> tuple[int | None, list[tuple[int, int]]]:\n    \"\"\"\n    Finds the top-leftmost yellow pixel's row (anchor_row) and \n    the relative coordinates of all yellow pixels in the section.\n    \"\"\"\n    coords = []\n    min_row, min_col = float('inf'), float('inf')\n    found_yellow = False\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    \n    for r in range(height):\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] == 4: # 4 is yellow\n                coords.append((r, c))\n                found_yellow = True\n                if r < min_row:\n                    min_row = r\n                    min_col = c \n                elif r == min_row and c < min_col:\n                    min_col = c \n\n    if not found_yellow:\n        return None, []\n\n    relative_coords = [(r - min_row, c - min_col) for r, c in coords]\n    return min_row, relative_coords\n\ndef clear_section(grid: list[list[int]], start_col: int, end_col: int):\n    \"\"\"Sets all non-green (3) pixels within the column bounds to white (0).\"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    for r in range(height):\n        current_end_col = min(end_col, width - 1)\n        for c in range(start_col, current_end_col + 1):\n            if grid[r][c] != 3: # Don't clear green separators\n                grid[r][c] = 0\n\ndef place_translated_pixels(grid: list[list[int]], source_coords: list[tuple[int, int]], col_offset: int):\n    \"\"\"Places yellow pixels by translating source coordinates.\"\"\"\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    for r, c in source_coords:\n        target_c = c + col_offset\n        if 0 <= r < height and 0 <= target_c < width:\n            grid[r][target_c] = 4\n\ndef place_relative_pattern(grid: list[list[int]], anchor_row: int | None, target_start_col: int, relative_coords: list[tuple[int, int]]):\n    \"\"\"Places a pattern using anchor row and relative coordinates.\"\"\"\n    if anchor_row is None:\n        return \n\n    height = len(grid)\n    width = len(grid[0]) if height > 0 else 0\n    for rel_r, rel_c in relative_coords:\n        target_row = anchor_row + rel_r\n        target_col = target_start_col + rel_c\n        if 0 <= target_row < height and 0 <= target_col < width:\n            grid[target_row][target_col] = 4\n\n\n# --- Main Transform Function ---\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n    \n    # Define section boundaries (inclusive) and start columns\n    sections = {\n        # id: (start_col, end_col)\n        1: (1, 4),\n        2: (6, 9),\n        3: (11, 14),\n        4: (16, 19)\n    }\n    section_start_cols = {\n        1: 1,\n        2: 6,\n        3: 11,\n        4: 16\n    }\n\n    # Determine the rule based on Section 3 yellow count\n    sec3_start, sec3_end = sections[3]\n    sec3_yellow_count = count_yellows_in_section(input_grid, sec3_start, sec3_end)\n    \n    # Apply transformation rule\n    if sec3_yellow_count == 3:\n        # Rule A: Swap 1 <=> 4 using translation. Keep 2, 3 unchanged.\n        \n        # Get source pixel coordinates\n        sec1_coords = get_yellow_pixels_coords(input_grid, sections[1][0], sections[1][1])\n        sec4_coords = get_yellow_pixels_coords(input_grid, sections[4][0], sections[4][1])\n\n        # Clear target sections in output grid\n        clear_section(output_grid, sections[1][0], sections[1][1])\n        clear_section(output_grid, sections[4][0], sections[4][1])\n\n        # Place translated pixels\n        place_translated_pixels(output_grid, sec1_coords, 15) # Sec 1 -> Sec 4 (+15)\n        place_translated_pixels(output_grid, sec4_coords, -15) # Sec 4 -> Sec 1 (-15)\n        \n        # Sections 2 and 3 are implicitly unchanged\n\n    else:\n        # Rule B: Cycle 1 -> 3 -> 4 -> 1 using anchor/relative placement. Keep 2 unchanged.\n        \n        # Get source patterns (anchor row, relative coordinates)\n        anchor_row1, rel_coords1 = find_yellow_pattern_anchor_relative(input_grid, sections[1][0], sections[1][1])\n        anchor_row3, rel_coords3 = find_yellow_pattern_anchor_relative(input_grid, sections[3][0], sections[3][1])\n        anchor_row4, rel_coords4 = find_yellow_pattern_anchor_relative(input_grid, sections[4][0], sections[4][1])\n\n        # Clear target sections in output grid\n        clear_section(output_grid, sections[1][0], sections[1][1])\n        clear_section(output_grid, sections[3][0], sections[3][1])\n        clear_section(output_grid, sections[4][0], sections[4][1])\n\n        # Place patterns in cycled positions\n        place_relative_pattern(output_grid, anchor_row1, section_start_cols[3], rel_coords1) # 1 -> 3\n        place_relative_pattern(output_grid, anchor_row3, section_start_cols[4], rel_coords3) # 3 -> 4\n        place_relative_pattern(output_grid, anchor_row4, section_start_cols[1], rel_coords4) # 4 -> 1\n\n        # Section 2 is implicitly unchanged\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34017,
    "candidates_token_count": 2822,
    "total_token_count": 36839,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 18.429891,
  "retries": 1
}