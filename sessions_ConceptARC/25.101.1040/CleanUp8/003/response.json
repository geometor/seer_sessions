{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport collections\nfrom typing import List, Tuple, Set\n\n\"\"\"\nTransforms an input grid based on two criteria related to 2x2 squares:\n1. Identifies contiguous objects of the same non-white color. If an object's bounding box is exactly 2x2, the corresponding 2x2 area in the output grid is filled with the object's color.\n2. Scans the input grid for any 2x2 area composed entirely of the same non-white color. If found, the corresponding 2x2 area in the output grid is filled with that color.\nThe final output grid contains all such identified 2x2 squares, filled with their respective colors, on a white background. Duplicates identified by both criteria are handled implicitly by drawing onto the same output location.\n\"\"\"\n\ndef find_objects(grid: list[list[int]]) -> list[tuple[int, set[tuple[int, int]]]]:\n    \"\"\"\n    Identifies all distinct contiguous objects of non-white pixels in the grid\n    using 4-way adjacency.\n\n    Args:\n        grid: The input 2D list representing the grid.\n\n    Returns:\n        A list of tuples, where each tuple contains:\n        - The color (int) of the object.\n        - A set of (row, col) tuples representing the pixels of the object.\n    \"\"\"\n    if not grid or not grid[0]:\n        return []\n    \n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] != 0 and (r, c) not in visited:\n                color = grid[r][c]\n                obj_pixels = set()\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds and if the neighbor is the same color and not visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr][nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append((color, obj_pixels))\n                    \n    return objects\n\ndef calculate_bounding_box(pixels: set[tuple[int, int]]) -> tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box (top-left corner, height, width) of a set of pixels.\n\n    Args:\n        pixels: A set of (row, col) tuples.\n\n    Returns:\n        A tuple containing (min_row, min_col, height, width).\n        Returns (0, 0, 0, 0) if pixels is empty.\n    \"\"\"\n    if not pixels:\n        return 0, 0, 0, 0\n        \n    min_row = min(r for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    return min_row, min_col, height, width\n\ndef find_solid_2x2_squares(grid: list[list[int]]) -> Set[Tuple[int, Tuple[int, int]]]:\n    \"\"\"\n    Finds all 2x2 squares in the grid that are solidly filled with the same\n    non-white color.\n\n    Args:\n        grid: The input 2D list representing the grid.\n\n    Returns:\n        A set of tuples, where each tuple contains:\n        - The color (int) of the solid square.\n        - A tuple (row, col) representing the top-left corner of the square.\n    \"\"\"\n    solid_squares = set()\n    if not grid or not grid[0]:\n        return solid_squares\n\n    height = len(grid)\n    width = len(grid[0])\n\n    # Iterate through possible top-left corners (r, c) for a 2x2 square\n    for r in range(height - 1):\n        for c in range(width - 1):\n            # Get the color of the top-left pixel\n            color = grid[r][c]\n            \n            # Check if it's a non-white color and if all four pixels match\n            if color != 0 and \\\n               grid[r+1][c] == color and \\\n               grid[r][c+1] == color and \\\n               grid[r+1][c+1] == color:\n                solid_squares.add((color, (r, c)))\n                \n    return solid_squares\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    if not input_grid or not input_grid[0]:\n        return []\n\n    height = len(input_grid)\n    width = len(input_grid[0])\n    \n    # initialize output_grid with background color (white, 0)\n    output_grid = [[0 for _ in range(width)] for _ in range(height)]\n    \n    # Use a set to store the (color, top_left_coords) of squares to draw, avoiding duplicates\n    squares_to_draw: Set[Tuple[int, Tuple[int, int]]] = set()\n\n    # --- Step 1: Identify squares based on object bounding boxes ---\n    # Find all contiguous non-white objects\n    objects = find_objects(input_grid)\n    \n    # Iterate through each object\n    for color, pixels in objects:\n        # Calculate its bounding box\n        min_row, min_col, bb_height, bb_width = calculate_bounding_box(pixels)\n        \n        # Check if the bounding box is exactly 2x2\n        if bb_height == 2 and bb_width == 2:\n            # Add its color and top-left corner to the set\n            squares_to_draw.add((color, (min_row, min_col)))\n\n    # --- Step 2: Identify squares based on solid 2x2 patterns ---\n    # Find all solid 2x2 non-white squares directly in the grid\n    solid_squares = find_solid_2x2_squares(input_grid)\n    \n    # Add these squares to the set (duplicates are handled automatically by the set)\n    squares_to_draw.update(solid_squares)\n\n    # --- Step 3: Generate the output grid ---\n    # Iterate through the unique squares identified\n    for color, (r, c) in squares_to_draw:\n        # Fill the 2x2 area in the output grid\n        # Ensure drawing stays within bounds (should generally be safe given how squares are found)\n        if r + 1 < height and c + 1 < width:\n             output_grid[r][c] = color\n             output_grid[r+1][c] = color\n             output_grid[r][c+1] = color\n             output_grid[r+1][c+1] = color\n             \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8106,
    "candidates_token_count": 2138,
    "total_token_count": 10244,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.816125,
  "retries": 1
}