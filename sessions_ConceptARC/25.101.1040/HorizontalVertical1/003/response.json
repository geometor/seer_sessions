{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying enclosed white regions (color 0) and filling them based on the color of the single surrounding shape. The specific fill color applied depends on the total number of distinct non-white colors present in the entire input grid.\n\n1.  **Analyze Grid Colors:** Count the number of unique non-white colors (`num_distinct_shape_colors`) in the input grid.\n2.  **Identify White Regions:** Find contiguous areas of white pixels (0) using 8-way adjacency.\n3.  **Determine Enclosure Status:** A white region is \"enclosed\" if:\n    a.  It does not touch the grid border.\n    b.  All immediately adjacent non-white pixels belong to a single shape and have the same color (`enclosing_color`).\n4.  **Select Fill Mapping:** Choose a fill rule based on `num_distinct_shape_colors`:\n    *   If `num_distinct_shape_colors` is 2 or less: Red(2) fills Green(3), Yellow(4) fills Orange(7).\n    *   If `num_distinct_shape_colors` is 3 or more: Red(2) fills Orange(7), Yellow(4) fills Green(3). Regions enclosed by Orange(7) are *not* filled (remain white).\n5.  **Apply Transformations:** Create a copy of the input grid. For each \"enclosed\" white region, determine the fill color using the selected mapping and the region's `enclosing_color`. Update the pixels within the region in the copied grid.\n6.  **Return Output:** Return the modified grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_enclosed_regions(grid: np.ndarray) -> list[tuple[set[tuple[int, int]], set[int], bool]]:\n    \"\"\"\n    Identifies contiguous white regions and checks their enclosure status.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list where each element represents a white region and contains:\n        - A set of (row, col) tuples for pixels in the region.\n        - A set of adjacent non-white colors.\n        - A boolean indicating if the region touches the border.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions_data = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS for a new white region if not visited\n            if grid[r, c] == 0 and not visited[r, c]:\n                region_pixels = set()\n                adjacent_colors = set()\n                is_border_touching = False\n                queue = deque([(r, c)])\n                visited[r, c] = True\n\n                while queue:\n                    curr_r, curr_c = queue.popleft()\n                    region_pixels.add((curr_r, curr_c))\n\n                    # Check if the current pixel touches the border\n                    if curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1:\n                        is_border_touching = True\n\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check if neighbor is within bounds\n                            if 0 <= nr < height and 0 <= nc < width:\n                                neighbor_color = grid[nr, nc]\n                                if neighbor_color == 0: # Neighbor is white\n                                    if not visited[nr, nc]:\n                                        visited[nr, nc] = True\n                                        queue.append((nr, nc))\n                                else: # Neighbor is non-white (part of a potential enclosing shape)\n                                    adjacent_colors.add(neighbor_color)\n                            # else: neighbor is out of bounds, implies border touching for the region pixel\n                            # This is implicitly handled by the border check on curr_r, curr_c\n\n                regions_data.append((region_pixels, adjacent_colors, is_border_touching))\n\n    return regions_data\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by filling enclosed white regions based on\n    the color of the enclosing shape and the total number of distinct\n    shape colors in the grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n\n    # 1. Analyze Grid Colors: Count distinct non-white colors\n    shape_colors = set(grid[grid > 0])\n    num_distinct_shape_colors = len(shape_colors)\n\n    # 4. Select Fill Mapping based on the count\n    fill_map = {}\n    if num_distinct_shape_colors <= 2:\n        # Rule Set A (for 2 or fewer distinct colors)\n        fill_map = {\n            2: 3,  # Red -> Green\n            4: 7,  # Yellow -> Orange\n        }\n    else:\n        # Rule Set B (for 3 or more distinct colors)\n        # Note: Orange(7) is intentionally left out based on Example 2 output\n        fill_map = {\n            2: 7,  # Red -> Orange\n            4: 3,  # Yellow -> Green\n            # 7: 3, # Removed based on failed test analysis\n        }\n\n    # 2. & 3. Identify White Regions and Determine Enclosure Status\n    regions_data = find_enclosed_regions(grid)\n\n    # 5. Apply Transformations\n    for region_pixels, adjacent_colors, is_border_touching in regions_data:\n        # Check enclosure criteria\n        is_enclosed = (not is_border_touching) and (len(adjacent_colors) == 1)\n\n        if is_enclosed:\n            enclosing_color = list(adjacent_colors)[0]\n            # Check if the enclosing color has a mapping in the selected rule set\n            if enclosing_color in fill_map:\n                fill_color = fill_map[enclosing_color]\n                # Fill the region in the output grid\n                for pr, pc in region_pixels:\n                    output_grid[pr, pc] = fill_color\n            # Else: If enclosing_color is not in the map (like Orange(7) in rule B),\n            # the region remains white (0), no action needed as output_grid is a copy.\n\n    # 6. Return Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13097,
    "candidates_token_count": 2135,
    "total_token_count": 15232,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.613787,
  "retries": 1
}