{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies the most frequent non-white color (key_color) in the input grid (ties broken by lowest color value).\nDetermines the bounding box encompassing all pixels of the key_color.\nIteratively shrinks this bounding box: if any edge (top, bottom, left, right) contains exactly one pixel of the key_color, that edge is moved inwards by one step. This shrinking process repeats until no edge shrinks in a full iteration.\nCreates an output grid of the same dimensions as the input, initially filled with white (0).\nDraws a hollow rectangle on the output grid using the key_color, defined by the final, adjusted bounding box.\n\"\"\"\n\ndef find_key_pixels(grid: np.ndarray, key_color: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with the key_color.\"\"\"\n    locations = np.argwhere(grid == key_color)\n    return [tuple(loc) for loc in locations]\n\ndef calculate_bounding_box(locations: list[tuple[int, int]]) -> tuple[int, int, int, int] | None:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for given locations.\"\"\"\n    if not locations:\n        return None\n    rows = [r for r, c in locations]\n    cols = [c for r, c in locations]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef count_pixels_on_border(locations: list[tuple[int, int]], border_type: str, bbox: tuple[int, int, int, int]) -> int:\n    \"\"\"Counts how many key locations lie on a specific border of the bbox.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    count = 0\n    if border_type == 'top':\n        target_r = min_r\n        for r, c in locations:\n            if r == target_r and min_c <= c <= max_c:\n                count += 1\n    elif border_type == 'bottom':\n        target_r = max_r\n        for r, c in locations:\n            if r == target_r and min_c <= c <= max_c:\n                count += 1\n    elif border_type == 'left':\n        target_c = min_c\n        for r, c in locations:\n            if c == target_c and min_r <= r <= max_r:\n                count += 1\n    elif border_type == 'right':\n        target_c = max_c\n        for r, c in locations:\n            if c == target_c and min_r <= r <= max_r:\n                count += 1\n    return count\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the identified rules:\n    1. Find the most frequent non-white color (key_color).\n    2. Find the bounding box of key_color pixels.\n    3. Adjust the bounding box by shrinking edges with exactly one key_color pixel.\n    4. Draw the final adjusted bounding box as a hollow frame on a white background.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    H, W = input_array.shape\n\n    # 1. Count non-white colors and find the key_color\n    color_counts = Counter()\n    for r in range(H):\n        for c in range(W):\n            color = input_array[r, c]\n            if color != 0:\n                color_counts[color] += 1\n\n    key_color = 0 # Default if no non-white colors\n    max_freq = 0\n    if color_counts:\n        # Sort by frequency (desc), then color value (asc)\n        sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n        key_color = sorted_colors[0][0]\n\n    # 2. Find locations of key_color pixels\n    key_pixel_locations = find_key_pixels(input_array, key_color)\n\n    # Handle edge case: no key pixels found\n    if not key_pixel_locations:\n        # Return an all-white grid\n        return np.zeros((H, W), dtype=int).tolist()\n\n    # 3. Calculate initial bounding box\n    initial_bbox = calculate_bounding_box(key_pixel_locations)\n    if initial_bbox is None: # Should not happen if key_pixel_locations is not empty\n         return np.zeros((H, W), dtype=int).tolist()\n\n    final_min_r, final_min_c, final_max_r, final_max_c = initial_bbox\n\n    # 4. Adjust bounding box iteratively\n    while True:\n        shrunk_this_iteration = False\n        current_bbox = (final_min_r, final_min_c, final_max_r, final_max_c)\n\n        # Check top border\n        if final_min_r < final_max_r: # Check if height > 0\n            top_count = count_pixels_on_border(key_pixel_locations, 'top', current_bbox)\n            if top_count == 1:\n                final_min_r += 1\n                shrunk_this_iteration = True\n                # Update bbox immediately for subsequent checks in the same iteration?\n                # Let's stick to the plan: check all based on the *start* of iteration bbox\n                # Update: The NL program suggests adjusting immediately. Let's re-evaluate.\n                # Re-reading step 8: It suggests checking each border sequentially and updating.\n                # Let's update the bbox immediately after shrinking.\n                current_bbox = (final_min_r, final_min_c, final_max_r, final_max_c)\n\n\n        # Check bottom border\n        if final_max_r > final_min_r: # Check if height > 0\n             bottom_count = count_pixels_on_border(key_pixel_locations, 'bottom', current_bbox)\n             if bottom_count == 1:\n                final_max_r -= 1\n                shrunk_this_iteration = True\n                current_bbox = (final_min_r, final_min_c, final_max_r, final_max_c)\n\n\n        # Check left border\n        if final_min_c < final_max_c: # Check if width > 0\n            left_count = count_pixels_on_border(key_pixel_locations, 'left', current_bbox)\n            if left_count == 1:\n                final_min_c += 1\n                shrunk_this_iteration = True\n                current_bbox = (final_min_r, final_min_c, final_max_r, final_max_c)\n\n\n        # Check right border\n        if final_max_c > final_min_c: # Check if width > 0\n             right_count = count_pixels_on_border(key_pixel_locations, 'right', current_bbox)\n             if right_count == 1:\n                final_max_c -= 1\n                shrunk_this_iteration = True\n                # No need to update current_bbox here as it's the last check in the loop\n\n\n        # Exit loop if no shrinking occurred\n        if not shrunk_this_iteration:\n            break\n        \n        # Add safety break if bbox collapses completely (shouldn't happen with checks)\n        if final_min_r > final_max_r or final_min_c > final_max_c:\n            # This indicates an issue or an empty resulting frame. Output all white?\n            # Let's default to drawing whatever shape remains, even if invalid, for now.\n            # Or maybe return all white is safer.\n             return np.zeros((H, W), dtype=int).tolist()\n\n\n    # 5. Create output grid and draw the frame\n    output_grid = np.zeros((H, W), dtype=int)\n\n    # Check if the final box is valid before drawing\n    if final_min_r <= final_max_r and final_min_c <= final_max_c:\n        for r in range(final_min_r, final_max_r + 1):\n            for c in range(final_min_c, final_max_c + 1):\n                # Check if the pixel is on the border\n                is_border = (r == final_min_r or r == final_max_r or\n                             c == final_min_c or c == final_max_c)\n                if is_border:\n                    output_grid[r, c] = key_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3280,
    "candidates_token_count": 3085,
    "total_token_count": 6365,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.192089,
  "retries": 1
}