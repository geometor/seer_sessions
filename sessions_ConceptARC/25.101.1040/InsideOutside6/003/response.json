{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nFilters a grid based on pixel adjacency rules derived from examples.\n\nThe transformation identifies three color roles: background (assumed to be 0), \n'target', and 'context'. \nIf exactly two non-background colors exist, the 'target' color is the one \nwith the lower frequency count, and the 'context' color is the one with the \nhigher frequency count. If only one non-background color exists, it's treated \nas the 'target' color, and there is no 'context' color.\n\nThe rule is to keep 'target' color pixels in the output grid *only if* they \nare NOT adjacent (horizontally, vertically, or diagonally - 8-connectivity) \nto any 'context' color pixel in the input grid. \n\nAll 'context' color pixels, as well as 'target' color pixels that *are* \nadjacent to 'context' pixels, are replaced with the background color in the \noutput. Pixels that are already the background color remain so.\n\nIf zero, more than two non-background colors exist, or if the two \nnon-background colors have equal frequency (making the target/context roles \nambiguous based on the frequency heuristic), the function returns a grid \nfilled entirely with the background color.\n\nThe grid dimensions remain unchanged.\n\"\"\"\n\ndef identify_colors(grid: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Identifies background, target, and context colors based on frequency.\n    Assumes background=0. Finds non-background colors.\n    Hypothesis: If two non-background colors exist, Target color is less \n                frequent than context color.\n    Returns: (background_color, target_color, context_color)\n             target_color or context_color can be -1 if not applicable/found.\n             Special negative codes (-2, -3) indicate ambiguity or errors.\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    background_color = 0\n    non_background_colors = {c: count for c, count in color_counts.items() if c != background_color}\n    num_non_background = len(non_background_colors)\n\n    target_color = -1\n    context_color = -1\n\n    if num_non_background == 0:\n        # Only background color present\n        pass # target/context remain -1\n    elif num_non_background == 1:\n        # Only one non-background color, assume it's target, no context\n        target_color = list(non_background_colors.keys())[0]\n        context_color = -1 # No context color\n    elif num_non_background == 2:\n        # Exactly two non-background colors, apply frequency heuristic\n        colors = list(non_background_colors.keys())\n        counts_list = list(non_background_colors.values())\n\n        # Assign based on frequency (target is less frequent)\n        if counts_list[0] < counts_list[1]:\n            target_color = colors[0]\n            context_color = colors[1]\n        elif counts_list[1] < counts_list[0]:\n            target_color = colors[1]\n            context_color = colors[0]\n        else:\n             # Tie in counts - ambiguous based on heuristic.\n             # print(\"Warning: Tie in non-background color counts, cannot distinguish target/context.\")\n             target_color = -2 # Indicate ambiguity\n             context_color = -2\n\n    else: # More than two non-background colors\n        # print(\"Warning: More than two non-background colors found.\")\n        # Cannot determine target/context based on the observed pattern.\n        target_color = -3 # Indicate >2 colors\n        context_color = -3\n\n    return background_color, target_color, context_color\n\ndef check_neighbors_for_color(grid: np.ndarray, r: int, c: int, color_to_find: int) -> bool:\n    \"\"\"\n    Checks the 8 neighbors (Moore neighborhood) of cell (r, c) in the grid\n    to see if any neighbor has the specified color_to_find.\n    Returns True if found, False otherwise.\n    Handles boundary conditions gracefully.\n    \"\"\"\n    rows, cols = grid.shape\n    # Iterate through the 3x3 neighborhood centered at (r, c)\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            # Skip the center cell itself\n            if dr == 0 and dc == 0:\n                continue\n\n            # Calculate neighbor coordinates\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor coordinates are within the grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor has the color we're looking for\n                if grid[nr, nc] == color_to_find:\n                    return True # Found the color in a neighbor\n\n    # If the loop completes without finding the color\n    return False\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule: Keeps target pixels only if they are not\n    adjacent (8-way connectivity) to any context pixel. Context pixels are removed.\n    Target/context colors are identified based on frequency (target is less frequent).\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n\n    # Step 1: Identify background, target, and context colors\n    background_color, target_color, context_color = identify_colors(input_grid)\n\n    # Step 2: Handle edge cases where color identification fails or is ambiguous\n    # If no target identified, or ambiguous, or too many colors, return an empty grid.\n    if target_color < 0: # Includes -1 (no target), -2 (ambiguous), -3 (>2 colors)\n        # print(f\"Color identification issue (code: {target_color}). Returning empty grid.\")\n        output_grid = np.full((rows, cols), background_color, dtype=int)\n        return output_grid.tolist()\n\n    # Step 3: Create a new grid initialized with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Step 4: Iterate through each pixel in the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Step 5: Check if the current pixel is the target color\n            if input_grid[r, c] == target_color:\n\n                # Step 6: Determine if the target pixel should be kept\n                keep_pixel = True # Assume keep unless adjacent to context\n\n                # Step 7: Check adjacency only if a context color exists\n                if context_color != -1: # context_color is -1 if only one non-bg color exists\n                    is_near_context = check_neighbors_for_color(input_grid, r, c, context_color)\n                    if is_near_context:\n                        keep_pixel = False # Rule: remove if adjacent to context\n\n                # Step 8: If the pixel should be kept, place it in the output grid\n                if keep_pixel:\n                    output_grid[r, c] = target_color\n            # Step 9: Pixels that are not the target color (i.e., background or context)\n            # are implicitly left as the background color initialized in output_grid.\n\n    # Step 10: Convert the resulting numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14956,
    "candidates_token_count": 2288,
    "total_token_count": 17244,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.785787,
  "retries": 1
}