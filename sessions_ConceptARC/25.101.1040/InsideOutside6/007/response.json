{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nFilters a grid based on pixel adjacency rules derived from examples.\n\nThe transformation identifies three color roles: background (assumed to be 0), \n'target', and 'context'. \nIf exactly two non-background colors exist, the 'target' color is the one \nwith the lower frequency count, and the 'context' color is the one with the \nhigher frequency count. If only one non-background color exists, it's treated \nas the 'target' color, and there is no 'context' color.\n\nThe primary rule is to keep 'target' color pixels in the output grid *only if* \nthey are NOT adjacent (horizontally, vertically, or diagonally - 8-connectivity) \nto any 'context' color pixel in the input grid. \n\nAll 'context' color pixels, as well as 'target' color pixels that *are* \nadjacent to 'context' pixels, are replaced with the background color in the \noutput. Pixels that are already the background color remain so.\n\nIf zero, more than two non-background colors exist, or if the two \nnon-background colors have equal frequency (making the target/context roles \nambiguous based on the frequency heuristic), the function returns a grid \nfilled entirely with the background color.\n\nThe grid dimensions remain unchanged.\n\nNote: This rule implementation matches most transformations in the provided \nexamples but differs for a few specific target pixels that are removed in the \nexpected output despite not being adjacent to any context pixel (e.g., \nT1(3,5), T1(4,5), T1(6,6), T2(10,7)). The exact rule for these exceptions is \nnot captured here.\n\"\"\"\n\ndef _identify_colors(grid: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    Identifies background, target, and context colors based on frequency.\n    Assumes background=0. Finds non-background colors.\n    Hypothesis: If two non-background colors exist, Target color is less \n                frequent than context color.\n    Returns: (background_color, target_color, context_color)\n             target_color or context_color can be -1 if not applicable/found.\n             Special negative codes (-2, -3) indicate ambiguity or errors.\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    background_color = 0\n    # Filter out the background color to find non-background colors and their counts\n    non_background_colors = {c: count for c, count in color_counts.items() if c != background_color}\n    num_non_background = len(non_background_colors)\n\n    target_color = -1  # Default: No target color found\n    context_color = -1 # Default: No context color found\n\n    if num_non_background == 0:\n        # Only background color present in the input grid\n        pass # target/context remain -1\n    elif num_non_background == 1:\n        # Exactly one non-background color exists, treat it as the target color\n        target_color = list(non_background_colors.keys())[0]\n        context_color = -1 # No context color in this case\n    elif num_non_background == 2:\n        # Exactly two non-background colors exist, determine roles by frequency\n        colors = list(non_background_colors.keys())\n        counts_list = list(non_background_colors.values())\n\n        # Assign target to the less frequent color, context to the more frequent\n        if counts_list[0] < counts_list[1]:\n            target_color = colors[0]\n            context_color = colors[1]\n        elif counts_list[1] < counts_list[0]:\n            target_color = colors[1]\n            context_color = colors[0]\n        else:\n             # Frequencies are equal, roles are ambiguous based on this heuristic\n             target_color = -2 # Indicate ambiguity\n             context_color = -2\n    else: \n        # More than two non-background colors found, roles are ambiguous\n        target_color = -3 # Indicate >2 colors issue\n        context_color = -3\n\n    return background_color, target_color, context_color\n\ndef _check_neighbors_for_color(grid: np.ndarray, r: int, c: int, color_to_find: int) -> bool:\n    \"\"\"\n    Checks the 8 neighbors (Moore neighborhood) of cell (r, c) in the grid\n    to see if any neighbor has the specified color_to_find.\n    Returns True if a neighbor with the color is found, False otherwise.\n    Handles boundary conditions gracefully.\n    \"\"\"\n    rows, cols = grid.shape\n    # Iterate through the 3x3 neighborhood centered at (r, c)\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            # Skip the center cell itself\n            if dr == 0 and dc == 0:\n                continue\n\n            # Calculate neighbor coordinates\n            nr, nc = r + dr, c + dc\n\n            # Check if the neighbor coordinates are within the grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbor has the color we're looking for\n                if grid[nr, nc] == color_to_find:\n                    return True # Found the color in a neighbor, no need to check further\n\n    # If the loop completes without finding the color in any neighbor\n    return False\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:  \n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n\n    # Step 1: Identify background, target, and context colors using the frequency heuristic\n    background_color, target_color, context_color = _identify_colors(input_grid)\n\n    # Step 2: Handle edge cases or ambiguous color roles\n    # If no target color identified, or roles are ambiguous, return a grid filled with background color\n    if target_color < 0: # Covers -1 (no target), -2 (ambiguous tie), -3 (>2 colors)\n        output_grid = np.full((rows, cols), background_color, dtype=int)\n        return output_grid.tolist()\n\n    # Step 3: Initialize the output grid with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Step 4: Iterate through each pixel of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Step 5: Check if the current pixel is the target color\n            if input_grid[r, c] == target_color:\n\n                # Step 6: Assume the target pixel should be kept, unless proven otherwise\n                keep_pixel = True \n\n                # Step 7: Check for adjacent context pixels ONLY if a context color exists\n                if context_color != -1: # A context color exists (i.e., exactly 2 non-bg colors found)\n                    # Call helper to check 8 neighbors for the context color\n                    is_near_context = _check_neighbors_for_color(input_grid, r, c, context_color)\n                    # If any neighbor is the context color, mark this pixel for removal\n                    if is_near_context:\n                        keep_pixel = False \n\n                # Step 8: If the pixel is marked to be kept, place its color in the output grid\n                if keep_pixel:\n                    output_grid[r, c] = target_color\n            \n            # Step 9: Pixels that are not the target color (background or context) \n            # remain as the background color in the output grid (due to initialization).\n\n    # Step 10: Convert the final numpy array grid back to a list of lists and return\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 34755,
    "candidates_token_count": 2287,
    "total_token_count": 37042,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 13.479848,
  "retries": 1
}