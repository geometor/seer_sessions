{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\n\n\"\"\"\nTransforms the input grid based on the pair of non-white colors present.\nThe transformation depends on the specific pair of non-white colors (C1, C2) found in the grid.\nLet C_low be the color with the lower index and C_high be the color with the higher index.\n\n1.  If the pair is {1 (Blue), 2 (Red)} or {4 (Yellow), 6 (Magenta)}:\n    - The object composed of C_low pixels is identified.\n    - This object is shifted one column to the left.\n    - The original positions of the shifted object become background (white, 0).\n    - The shifted object overwrites any pixels in its new path.\n\n2.  If the pair is {3 (Green), 4 (Yellow)}:\n    - Pixels of color C_high (Yellow) are changed to color C_low (Green) if they have a C_low (Green) neighbor directly to their right OR directly below them.\n\n3.  If the pair is {1 (Blue), 5 (Gray)}:\n    - Pixels of color C_high (Gray) are changed to color C_low (Blue) if they have a C_low (Blue) neighbor directly to their right.\n\"\"\"\n\ndef find_colors(grid: list[list[int]]) -> tuple[int | None, int | None]:\n    \"\"\"Finds the two unique non-background colors in the grid.\n\n    Args:\n        grid: The input grid.\n\n    Returns:\n        A tuple containing the lower and higher color index (c_low, c_high),\n        or (None, None) if exactly two non-white colors are not found.\n    \"\"\"\n    colors = set()\n    height = len(grid)\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] != 0:\n                colors.add(grid[r][c])\n    # Ensure exactly two colors are found\n    if len(colors) != 2:\n        return None, None\n    color_list = sorted(list(colors))\n    # Returns the color with the lower index first (c_low), then higher (c_high)\n    return color_list[0], color_list[1]\n\ndef find_object_pixels(grid: list[list[int]], color: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with the specified color.\n\n    Args:\n        grid: The input grid.\n        color: The color value to find.\n\n    Returns:\n        A list of (row, col) tuples for pixels matching the color.\n    \"\"\"\n    pixels = []\n    height = len(grid)\n    width = len(grid[0])\n    for r in range(height):\n        for c in range(width):\n            if grid[r][c] == color:\n                pixels.append((r, c))\n    return pixels\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule based on the pair of non-white colors present.\n    \"\"\"\n    # Initialize output_grid as a deep copy of the input to avoid modifying the original\n    output_grid = copy.deepcopy(input_grid)\n    height = len(input_grid)\n    width = len(input_grid[0])\n\n    # 1. Identify the two unique non-white colors and determine low/high index\n    c_low, c_high = find_colors(input_grid)\n\n    # If colors are not as expected (e.g., not exactly 2 non-white), return the original grid\n    if c_low is None:\n        print(\"Warning: Expected exactly two non-white colors, found different.\")\n        return output_grid\n\n    color_pair = {c_low, c_high}\n\n    # 2. Determine and execute the transformation based on the color pair\n\n    # Case 1: Shift Left (pairs {1, 2} or {4, 6})\n    if color_pair == {1, 2} or color_pair == {4, 6}:\n        # Find original pixels of the object to be shifted (c_low)\n        pixels_to_shift = find_object_pixels(input_grid, c_low)\n\n        # Calculate new locations after shifting left\n        new_pixel_locations = []\n        for r, c in pixels_to_shift:\n            new_c = c - 1\n            # Check boundary conditions for the new column\n            if 0 <= new_c < width:\n                 new_pixel_locations.append((r, new_c))\n\n        # Clear original locations in output grid\n        # Note: This happens *before* painting new locations, correctly handling overlaps\n        for r, c in pixels_to_shift:\n            output_grid[r][c] = 0 # Set to white/background\n\n        # Fill new locations in output grid with c_low\n        for r, new_c in new_pixel_locations:\n             output_grid[r][new_c] = c_low\n\n    # Case 2: Color Bleed (pairs {1, 5} or {3, 4})\n    elif color_pair == {1, 5} or color_pair == {3, 4}:\n        # Find pixels of the higher color object (potential targets for change)\n        pixels_high = find_object_pixels(input_grid, c_high)\n        pixels_to_change = []\n\n        # Iterate through the higher color pixels to check for required adjacency\n        for r_high, c_high_px in pixels_high:\n            change_pixel = False\n\n            # Rule for {3, 4} (Green changes adjacent Yellow)\n            if color_pair == {3, 4}:\n                # Check if neighbor to the RIGHT (r_high, c_high_px + 1) is c_low (Green)\n                has_green_right = (c_high_px + 1 < width and input_grid[r_high][c_high_px + 1] == c_low)\n                # Check if neighbor BELOW (r_high + 1, c_high_px) is c_low (Green)\n                has_green_below = (r_high + 1 < height and input_grid[r_high + 1][c_high_px] == c_low)\n                # If either condition is true, mark for change\n                if has_green_right or has_green_below:\n                    change_pixel = True\n\n            # Rule for {1, 5} (Blue changes adjacent Gray)\n            elif color_pair == {1, 5}:\n                 # Check if neighbor to the RIGHT (r_high, c_high_px + 1) is c_low (Blue)\n                 # Rule: Gray pixel (r_high, c_high_px) changes if Blue pixel is at (r_high, c_high_px + 1)\n                 if c_high_px + 1 < width and input_grid[r_high][c_high_px + 1] == c_low:\n                     change_pixel = True\n\n            # If conditions met, mark this pixel for color change\n            if change_pixel:\n                pixels_to_change.append((r_high, c_high_px))\n\n        # Apply the color changes to the output grid\n        for r_change, c_change in pixels_to_change:\n            output_grid[r_change][c_change] = c_low\n\n    # 3. Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3713,
    "candidates_token_count": 9765,
    "total_token_count": 13478,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 69.44578,
  "retries": 1
}