{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransforms an input grid by swapping the vertical positions of the two distinct \nnon-background color groups present. It identifies the upper and lower groups \nbased on their bounding boxes. The lower group remains in its original position. \nThe upper group is moved vertically downwards so that it is positioned directly \nbelow the lower group, while preserving the original vertical gap (number of \nbackground rows) that existed between their bounding boxes in the input.\n\"\"\"\n\ndef get_color_group_properties(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds non-background colors and properties of their pixel groups.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A dictionary where keys are colors (int > 0) and values are \n        dictionaries containing:\n          'coords': A set of (row, col) tuples for all pixels of that color.\n          'bbox': A tuple (min_r, max_r, min_c, max_c) representing the \n                  bounding box of the color group.\n        Returns an empty dictionary if no non-background pixels are found or \n        if grid dimensions are invalid.\n    \"\"\"\n    if grid.ndim != 2 or grid.shape[0] == 0 or grid.shape[1] == 0:\n        return {} # Handle empty or invalid grid\n        \n    rows, cols = grid.shape\n    # Use defaultdict to easily initialize data for each new color found\n    # Initialize min values high and max values low\n    color_groups = defaultdict(lambda: {'coords': set(), 'min_r': rows, 'max_r': -1, 'min_c': cols, 'max_c': -1})\n    found_non_background = False\n\n    # Iterate through the grid to find pixels and update group properties\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0:  # Ignore background color (0)\n                found_non_background = True\n                group = color_groups[color]\n                # Add coordinate to the set for this color\n                group['coords'].add((r, c))\n                # Update bounding box extents\n                group['min_r'] = min(group['min_r'], r)\n                group['max_r'] = max(group['max_r'], r)\n                group['min_c'] = min(group['min_c'], c)\n                group['max_c'] = max(group['max_c'], c)\n\n    if not found_non_background:\n        return {} # Return empty if only background exists\n\n    # Convert defaultdict to a regular dict and finalize the bbox structure\n    result = {}\n    for color, group_data in color_groups.items():\n         result[color] = {\n             'coords': group_data['coords'],\n             'bbox': (group_data['min_r'], group_data['max_r'], group_data['min_c'], group_data['max_c'])\n         }\n    return result\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the vertical color group swapping transformation based on bounding boxes.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle potential empty input grid\n    if input_array.size == 0:\n        return []\n        \n    rows, cols = input_array.shape\n    \n    # 5. Initialize an output grid of the same size, filled with background color.\n    output_array = np.zeros_like(input_array)\n\n    # 1. Identify the two distinct non-background colors and their properties.\n    color_groups = get_color_group_properties(input_array)\n\n    # Check if exactly two non-background colors were found.\n    # If not, return the original grid (as per analysis of examples).\n    if len(color_groups) != 2:\n        # print(f\"Warning: Expected 2 non-background colors, found {len(color_groups)}. Returning original grid.\")\n        return input_grid\n        \n    # 2. Get the two colors and their group data.\n    colors = list(color_groups.keys())\n    color1, color2 = colors[0], colors[1]\n    group1, group2 = color_groups[color1], color_groups[color2]\n\n    # 3. Designate the 'upper group' and 'lower group' based on bounding box minimum row.\n    if group1['bbox'][0] < group2['bbox'][0]:\n        upper_group, lower_group = group1, group2\n        upper_color, lower_color = color1, color2\n    else:\n        upper_group, lower_group = group2, group1\n        upper_color, lower_color = color2, color1\n        \n    # Extract specific bounding box values for clarity.\n    upper_min_r, upper_max_r, _, _ = upper_group['bbox']\n    lower_min_r, lower_max_r, _, _ = lower_group['bbox']\n    \n    # 4. Calculate the vertical gap between the bounding boxes.\n    # gap = top row of lower bbox - bottom row of upper bbox - 1\n    gap = lower_min_r - upper_max_r - 1\n    \n    # Ensure gap is not negative (shouldn't happen if bboxes don't overlap vertically)\n    gap = max(0, gap) \n\n    # 6. Copy all pixels belonging to the 'lower group' to the output grid at original positions.\n    for r, c in lower_group['coords']:\n        # Basic bounds check (defensive programming)\n        if 0 <= r < rows and 0 <= c < cols:\n            output_array[r, c] = lower_color\n        \n    # 7. Calculate the necessary downward vertical shift for the 'upper group' pixels.\n    # The new top row for the upper group = bottom row of lower group + gap + 1\n    new_upper_group_start_row = lower_max_r + gap + 1\n    # shift = difference between new start row and original start row\n    shift = new_upper_group_start_row - upper_min_r\n    \n    # 8. Copy all pixels belonging to the 'upper group' to the output grid at shifted positions.\n    for r, c in upper_group['coords']:\n        new_r = r + shift\n        # Check if the new position is within grid bounds before placing the pixel.\n        if 0 <= new_r < rows and 0 <= c < cols:\n             output_array[new_r, c] = upper_color\n        # else:\n            # Optional: Warning if pixels are shifted out of bounds\n            # print(f\"Warning: Calculated new row {new_r} for upper group pixel at ({r},{c}) is out of bounds ({rows}x{cols}). Pixel omitted.\")\n\n    # Convert the final output NumPy array back to a list of lists for the required return type.\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 40373,
    "candidates_token_count": 2033,
    "total_token_count": 42406,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 14.511383,
  "retries": 1
}