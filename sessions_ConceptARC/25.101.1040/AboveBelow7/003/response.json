{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentifies the two distinct non-background color groups in the input grid.\nDetermines which group is vertically above the other based on their bounding boxes.\nCalculates the vertical gap between their bounding boxes.\nCreates an output grid where the original lower color group maintains its position,\nand the original upper color group is moved directly below the lower group, \npreserving the original vertical gap between their bounding boxes.\n\"\"\"\n\ndef get_color_group_properties(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds non-background colors and properties of their pixel groups.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A dictionary where keys are colors (int > 0) and values are \n        dictionaries containing:\n          'coords': A set of (row, col) tuples for all pixels of that color.\n          'bbox': A tuple (min_r, max_r, min_c, max_c) representing the \n                  bounding box of the color group.\n        Returns an empty dictionary if no non-background pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    color_groups = defaultdict(lambda: {'coords': set(), 'min_r': rows, 'max_r': -1, 'min_c': cols, 'max_c': -1})\n    found_non_background = False\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0:\n                found_non_background = True\n                group = color_groups[color]\n                group['coords'].add((r, c))\n                # Update bounding box extents\n                group['min_r'] = min(group['min_r'], r)\n                group['max_r'] = max(group['max_r'], r)\n                group['min_c'] = min(group['min_c'], c)\n                group['max_c'] = max(group['max_c'], c)\n\n    if not found_non_background:\n        return {}\n\n    # Convert defaultdict to regular dict and finalize bbox structure\n    result = {}\n    for color, group_data in color_groups.items():\n         result[color] = {\n             'coords': group_data['coords'],\n             'bbox': (group_data['min_r'], group_data['max_r'], group_data['min_c'], group_data['max_c'])\n         }\n    return result\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid by swapping the vertical positions of the two \n    non-background color groups, keeping the lower one fixed and moving the \n    upper one below it, preserving the gap.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # Initialize output grid with background color (0)\n    output_array = np.zeros_like(input_array)\n\n    # Find the color groups and their properties\n    color_groups = get_color_group_properties(input_array)\n\n    # Check if exactly two non-background colors were found\n    if len(color_groups) != 2:\n        # If not 2 colors, return the original grid (or handle as error)\n        # Based on examples, we expect exactly two colors.\n        # Returning input grid might be safest for unexpected test cases.\n        print(f\"Warning: Expected 2 non-background colors, found {len(color_groups)}. Returning original grid.\")\n        return input_grid\n        \n    # Identify the two colors\n    colors = list(color_groups.keys())\n    color1 = colors[0]\n    color2 = colors[1]\n    group1 = color_groups[color1]\n    group2 = color_groups[color2]\n\n    # Determine which group is upper and which is lower based on min_row\n    if group1['bbox'][0] < group2['bbox'][0]:\n        upper_group = group1\n        lower_group = group2\n        upper_color = color1\n        lower_color = color2\n    else:\n        upper_group = group2\n        lower_group = group1\n        upper_color = color2\n        lower_color = color1\n        \n    # Extract bounding box info for easier access\n    upper_min_r, upper_max_r, _, _ = upper_group['bbox']\n    lower_min_r, lower_max_r, _, _ = lower_group['bbox']\n    \n    # Calculate the vertical gap between the bounding boxes of the groups\n    # gap = top row of lower group - bottom row of upper group - 1\n    gap = lower_min_r - upper_max_r - 1\n    \n    # Place the lower group in the output grid at its original position\n    for r, c in lower_group['coords']:\n        # Basic boundary check (shouldn't be necessary if input is valid)\n        if 0 <= r < rows and 0 <= c < cols:\n            output_array[r, c] = lower_color\n        \n    # Determine the new starting row for the top of the upper group's bbox\n    # It should start below the lower group's bbox, maintaining the gap\n    # new_upper_top_row = bottom row of lower group + gap + 1\n    new_upper_group_start_row = lower_max_r + gap + 1\n    \n    # Calculate the vertical shift needed for the upper group's pixels\n    shift = new_upper_group_start_row - upper_min_r\n    \n    # Place the upper group in the output grid at its new shifted position\n    for r, c in upper_group['coords']:\n        new_r = r + shift\n        # Check if the new position is within grid bounds\n        if 0 <= new_r < rows and 0 <= c < cols:\n             output_array[new_r, c] = upper_color\n        else:\n            # This might indicate an issue if the shifted object goes off-grid\n            print(f\"Warning: Calculated new row {new_r} for upper group pixel at ({r},{c}) is out of bounds ({rows}x{cols}). Pixel omitted.\")\n\n    # Convert the output NumPy array back to a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20527,
    "candidates_token_count": 2037,
    "total_token_count": 22564,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 15.346372,
  "retries": 1
}