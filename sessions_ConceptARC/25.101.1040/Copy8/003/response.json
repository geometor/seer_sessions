{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np # numpy isn't used in the current code but often useful\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies pairs of identical objects (anchors) based on shape \nand color within the input grid. For each anchor pair, it searches for any \nother object (source) located spatially relative to one anchor (reference). \nIt then calculates the corresponding relative position for the second anchor \n(target). If an identical source object is not already present at this target \nlocation in the grid (specifically, if the area is background or incomplete), \nthe source object is copied and pasted into that location. The pasting process \nonly overwrites background pixels (color 0). This procedure is applied \nsymmetrically, considering each anchor in a pair as both a potential reference \nand target.\n\"\"\"\n\nclass ObjectInfo:\n    \"\"\"\n    Helper class to store information about a detected object.\n    Includes color, pixel coordinates, bounding box, shape, height, and width.\n    Provides equality comparison based on color and shape.\n    \"\"\"\n    def __init__(self, color, pixels, grid):\n        self.color = color\n        self.pixels = set(pixels) # set of (r, c) tuples\n        if not self.pixels:\n             # Handle case of potentially finding an empty object (shouldn't happen with BFS start condition)\n             self.bbox = (0, 0, -1, -1)\n             self.shape = []\n             self.height = 0\n             self.width = 0\n             self.top_left = (-1, -1)\n        else:\n            # Calculate bbox first\n            min_r = min(r for r, c in self.pixels)\n            max_r = max(r for r, c in self.pixels)\n            min_c = min(c for r, c in self.pixels)\n            max_c = max(c for r, c in self.pixels)\n            self.bbox = (min_r, min_c, max_r, max_c)\n\n            # Calculate dimensions\n            self.height = self.bbox[2] - self.bbox[0] + 1\n            self.width = self.bbox[3] - self.bbox[1] + 1\n            self.top_left = (self.bbox[0], self.bbox[1])\n\n            # Now extract shape using calculated dimensions\n            self.shape = self._extract_shape(grid) # list of lists relative to bbox top-left\n\n    def _extract_shape(self, grid):\n        # Extracts the object's shape relative to its top-left corner.\n        # Represents shape as a grid filled with 0 or the object's color.\n        if not self.pixels:\n            return []\n        min_r, min_c, _, _ = self.bbox\n        # Initialize shape grid with background color (0)\n        shape_grid = [[0] * self.width for _ in range(self.height)]\n        for r, c in self.pixels:\n            # Calculate relative coordinates within the shape grid\n            rel_r, rel_c = r - min_r, c - min_c\n            # Ensure relative coordinates are within the bounds of the shape grid\n            if 0 <= rel_r < self.height and 0 <= rel_c < self.width:\n                 shape_grid[rel_r][rel_c] = self.color\n        return shape_grid\n\n    def __eq__(self, other):\n        # Defines equality based on color and shape.\n        if not isinstance(other, ObjectInfo):\n            return NotImplemented\n        return self.color == other.color and self.shape == other.shape\n\n    def __hash__(self):\n        # Allows objects to be used in sets/dictionaries based on color and shape.\n        shape_tuple = tuple(tuple(row) for row in self.shape)\n        return hash((self.color, shape_tuple))\n    \n    def __repr__(self):\n        # String representation for debugging.\n        return f\"Object(color={self.color}, top_left={self.top_left}, shape={self.shape})\"\n\n\ndef find_objects(grid: list[list[int]], ignore_color: int = 0) -> list[ObjectInfo]:\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color in the grid.\n    Uses Breadth-First Search (BFS) with 8-way connectivity.\n    Returns a list of ObjectInfo instances.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            # If pixel is not visited and not the ignored color, start BFS\n            if (r, c) not in visited and grid[r][c] != ignore_color:\n                color = grid[r][c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            \n                            # Check bounds and if neighbor has same color and not visited\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               (nr, nc) not in visited and grid[nr][nc] == color:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                                \n                # Create ObjectInfo instance if pixels were found\n                if obj_pixels:\n                    objects.append(ObjectInfo(color, obj_pixels, grid))\n                    \n    return objects\n\ndef check_if_present(grid: list[list[int]], target_top_left: tuple[int, int], \n                     source_shape: list[list[int]], source_color: int) -> bool:\n    \"\"\"\n    Checks if an object identical to the source (shape and color) exists \n    at the target_top_left position in the grid by checking pixel values.\n    Note: This checks for the *presence* of the exact pixels, not necessarily\n          if it forms a complete, isolated object identical to the source.\n    \"\"\"\n    shape_h = len(source_shape)\n    if shape_h == 0: return True # An empty shape is considered present.\n    shape_w = len(source_shape[0])\n    grid_h = len(grid)\n    grid_w = len(grid[0])\n    start_r, start_c = target_top_left\n\n    for r in range(shape_h):\n        for c in range(shape_w):\n            # Only check pixels that are part of the source object's shape\n            if source_shape[r][c] == source_color: \n                gr, gc = start_r + r, start_c + c\n                # Check bounds: if the source pixel position is outside the grid, it's not present\n                if not (0 <= gr < grid_h and 0 <= gc < grid_w):\n                    return False \n                # Check color match: if the grid color doesn't match, it's not present\n                if grid[gr][gc] != source_color:\n                    return False\n                    \n    # If all source pixels were found at the target location with correct color and within bounds\n    return True\n\n\ndef paste_object(grid: list[list[int]], target_top_left: tuple[int, int], \n                 source_shape: list[list[int]], source_color: int):\n    \"\"\"\n    Pastes the source_shape onto the grid at target_top_left.\n    Only overwrites pixels with color 0 (background).\n    Modifies the grid in place.\n    \"\"\"\n    shape_h = len(source_shape)\n    if shape_h == 0: return # Nothing to paste for an empty shape\n    shape_w = len(source_shape[0])\n    grid_h = len(grid)\n    grid_w = len(grid[0])\n    start_r, start_c = target_top_left\n\n    for r in range(shape_h):\n        for c in range(shape_w):\n            # If the current position in the shape belongs to the object\n            if source_shape[r][c] == source_color: \n                gr, gc = start_r + r, start_c + c\n                # Check if the target grid coordinates are within bounds\n                if 0 <= gr < grid_h and 0 <= gc < grid_w:\n                    # Only overwrite if the target pixel is background (color 0)\n                    if grid[gr][gc] == 0:\n                        grid[gr][gc] = source_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Initialize output_grid as a deep copy of the input grid\n    output_grid = [row[:] for row in input_grid]\n    \n    # Find all distinct objects in the input grid\n    objects = find_objects(input_grid)\n    \n    # --- Identify pairs of identical anchor objects ---\n    anchor_pairs = []\n    num_objects = len(objects)\n    # Use indices to avoid redundant checks and comparing an object to itself\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            # Check for identity using ObjectInfo.__eq__ (color and shape)\n            # The find_objects ensures pixel sets are different if they are different objects\n            if objects[i] == objects[j]: \n                 # Store the actual ObjectInfo instances\n                 anchor_pairs.append((objects[i], objects[j]))\n\n    # --- Process each anchor pair to find and potentially copy relative objects ---\n    processed_sources_targets = set() # Keep track of (source_hash, target_top_left) to avoid redundant pastes\n\n    for anchor1, anchor2 in anchor_pairs:\n        # Iterate through all identified objects to check if they are 'source' objects relative to anchors\n        for source_obj in objects:\n            # A source object cannot be one of the anchors in the current pair\n            if source_obj == anchor1: # Equality check handles both shape and color\n                continue\n\n            # -- Check relative position: anchor1 -> anchor2 --\n            # Calculate relative offset of source_obj's top-left wrt anchor1's top-left\n            dr1 = source_obj.top_left[0] - anchor1.top_left[0]\n            dc1 = source_obj.top_left[1] - anchor1.top_left[1]\n            \n            # Calculate the potential target top-left position relative to anchor2\n            target_r1 = anchor2.top_left[0] + dr1\n            target_c1 = anchor2.top_left[1] + dc1\n            target_top_left1 = (target_r1, target_c1)\n            \n            # Create a unique key for this potential paste operation\n            paste_key1 = (hash(source_obj), target_top_left1)\n\n            # Check if this source object is already present at the target location relative to anchor2\n            # Check against the potentially modified output_grid\n            # Also check if we've already processed this exact paste operation\n            if paste_key1 not in processed_sources_targets and \\\n               not check_if_present(output_grid, target_top_left1, source_obj.shape, source_obj.color):\n                 # If not present, paste the object onto the output grid\n                 paste_object(output_grid, target_top_left1, source_obj.shape, source_obj.color)\n                 processed_sources_targets.add(paste_key1) # Mark as processed\n\n\n            # -- Check relative position: anchor2 -> anchor1 (Symmetry) --\n            # Calculate relative offset of source_obj's top-left wrt anchor2's top-left\n            dr2 = source_obj.top_left[0] - anchor2.top_left[0]\n            dc2 = source_obj.top_left[1] - anchor2.top_left[1]\n\n            # Calculate the potential target top-left position relative to anchor1\n            target_r2 = anchor1.top_left[0] + dr2\n            target_c2 = anchor1.top_left[1] + dc2\n            target_top_left2 = (target_r2, target_c2)\n\n            # Create a unique key for this potential paste operation\n            paste_key2 = (hash(source_obj), target_top_left2)\n            \n            # Check if this source object is already present at the target location relative to anchor1\n            # Check against the potentially modified output_grid\n            # Also check if we've already processed this exact paste operation\n            if paste_key2 not in processed_sources_targets and \\\n               not check_if_present(output_grid, target_top_left2, source_obj.shape, source_obj.color):\n                 # If not present, paste the object onto the output grid\n                 paste_object(output_grid, target_top_left2, source_obj.shape, source_obj.color)\n                 processed_sources_targets.add(paste_key2) # Mark as processed\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11064,
    "candidates_token_count": 3745,
    "total_token_count": 14809,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.236978,
  "retries": 1
}