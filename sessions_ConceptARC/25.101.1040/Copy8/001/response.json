{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies pairs of identical objects (anchors) in the input grid. \nFor each anchor pair, it finds any other object (source) that is positioned \nvertically relative to one of the anchors (the reference anchor). \nIf the second anchor (the target anchor) does not have an identical source object \nin the same relative position, the source object is copied and placed there. \nThe placement only overwrites background pixels (color 0).\n\"\"\"\n\nclass ObjectInfo:\n    \"\"\"\n    Helper class to store information about a detected object.\n    Includes color, pixel coordinates, bounding box, shape, height, and width.\n    Provides equality comparison based on color and shape.\n    \"\"\"\n    def __init__(self, color, pixels, grid):\n        self.color = color\n        self.pixels = set(pixels) # set of (r, c) tuples\n        self.bbox = self._calculate_bbox() # (min_r, min_c, max_r, max_c)\n        self.shape = self._extract_shape(grid) # list of lists relative to bbox top-left\n        self.height = self.bbox[2] - self.bbox[0] + 1\n        self.width = self.bbox[3] - self.bbox[1] + 1\n        self.top_left = (self.bbox[0], self.bbox[1])\n\n    def _calculate_bbox(self):\n        if not self.pixels:\n            return (0, 0, -1, -1) # Handle empty object case if necessary\n        min_r = min(r for r, c in self.pixels)\n        max_r = max(r for r, c in self.pixels)\n        min_c = min(c for r, c in self.pixels)\n        max_c = max(c for r, c in self.pixels)\n        return (min_r, min_c, max_r, max_c)\n\n    def _extract_shape(self, grid):\n        if not self.pixels:\n            return []\n        min_r, min_c, _, _ = self.bbox\n        shape_grid = [[0] * self.width for _ in range(self.height)]\n        for r, c in self.pixels:\n            # Ensure coordinates are within bounds before access\n            if 0 <= r - min_r < self.height and 0 <= c - min_c < self.width:\n                 shape_grid[r - min_r][c - min_c] = self.color\n            # Consider adding error handling or logging if out of bounds\n        return shape_grid\n\n    def __eq__(self, other):\n        if not isinstance(other, ObjectInfo):\n            return NotImplemented\n        # Compare based on color and shape (implicitly size)\n        return self.color == other.color and self.shape == other.shape\n\n    def __hash__(self):\n        # Hash based on color and shape tuple to allow use in sets/dicts\n        shape_tuple = tuple(tuple(row) for row in self.shape)\n        return hash((self.color, shape_tuple))\n    \n    def __repr__(self):\n         return f\"Object(color={self.color}, top_left={self.top_left}, shape={self.shape})\"\n\n\ndef find_objects(grid: list[list[int]], ignore_color: int = 0) -> list[ObjectInfo]:\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color in the grid.\n    Uses Breadth-First Search (BFS).\n    Returns a list of ObjectInfo instances.\n    \"\"\"\n    height = len(grid)\n    width = len(grid[0])\n    visited = set()\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if (r, c) not in visited and grid[r][c] != ignore_color:\n                color = grid[r][c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               (nr, nc) not in visited and grid[nr][nc] == color:\n                                visited.add((nr, nc))\n                                q.append((nr, nc))\n                                \n                if obj_pixels:\n                    objects.append(ObjectInfo(color, obj_pixels, grid))\n                    \n    return objects\n\ndef check_if_present(grid: list[list[int]], target_top_left: tuple[int, int], \n                     source_shape: list[list[int]], source_color: int) -> bool:\n    \"\"\"\n    Checks if an object identical to the source (shape and color) exists \n    at the target_top_left position in the grid.\n    \"\"\"\n    shape_h = len(source_shape)\n    if shape_h == 0: return True # Empty shape is technically always present\n    shape_w = len(source_shape[0])\n    grid_h = len(grid)\n    grid_w = len(grid[0])\n    start_r, start_c = target_top_left\n\n    for r in range(shape_h):\n        for c in range(shape_w):\n            if source_shape[r][c] == source_color: # Only check object pixels\n                gr, gc = start_r + r, start_c + c\n                # Check bounds and color match\n                if not (0 <= gr < grid_h and 0 <= gc < grid_w and grid[gr][gc] == source_color):\n                    return False\n                \n    # Check if the area contains *only* the object pixels (no extra pixels of the same color connected)\n    # This might be too strict based on examples, let's omit for now and rely on the pixel match.\n    # If needed, could run a mini-BFS from the target area to ensure the shape matches exactly.\n                    \n    return True\n\n\ndef paste_object(grid: list[list[int]], target_top_left: tuple[int, int], \n                 source_shape: list[list[int]], source_color: int):\n    \"\"\"\n    Pastes the source_shape onto the grid at target_top_left.\n    Only overwrites pixels with color 0 (background).\n    Modifies the grid in place.\n    \"\"\"\n    shape_h = len(source_shape)\n    if shape_h == 0: return\n    shape_w = len(source_shape[0])\n    grid_h = len(grid)\n    grid_w = len(grid[0])\n    start_r, start_c = target_top_left\n\n    for r in range(shape_h):\n        for c in range(shape_w):\n            if source_shape[r][c] == source_color: # If it's part of the object shape\n                gr, gc = start_r + r, start_c + c\n                # Check bounds before writing\n                if 0 <= gr < grid_h and 0 <= gc < grid_w:\n                    # Only overwrite background color\n                    if grid[gr][gc] == 0:\n                        grid[gr][gc] = source_color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by finding pairs of identical anchor objects,\n    identifying associated source objects relative to one anchor, and copying\n    the source object to the corresponding relative position of the other anchor\n    if it's missing.\n    \"\"\"\n    # Initialize output_grid as a deep copy\n    output_grid = [row[:] for row in input_grid]\n    \n    # Find all objects in the input grid\n    objects = find_objects(input_grid)\n    \n    # Identify pairs of identical anchor objects\n    anchor_pairs = []\n    num_objects = len(objects)\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            # Check for identity using the overloaded __eq__\n            # Also ensure they are not the exact same object instance (though find_objects should prevent this)\n            # and that their positions are different.\n            if objects[i] == objects[j] and objects[i].pixels != objects[j].pixels:\n                 anchor_pairs.append((objects[i], objects[j]))\n\n    # Process each anchor pair\n    for anchor1, anchor2 in anchor_pairs:\n        # Find source objects associated with anchor1\n        for source_obj in objects:\n            # Source must be different from the anchors\n            if source_obj.pixels == anchor1.pixels or source_obj.pixels == anchor2.pixels:\n                continue\n\n            # Calculate relative position of source_obj wrt anchor1\n            # Using top-left corners of bounding boxes\n            dr = source_obj.top_left[0] - anchor1.top_left[0]\n            dc = source_obj.top_left[1] - anchor1.top_left[1]\n            \n            # Calculate potential target top-left position wrt anchor2\n            target_r = anchor2.top_left[0] + dr\n            target_c = anchor2.top_left[1] + dc\n            target_top_left = (target_r, target_c)\n\n            # Check if the source object already exists at the target location in the *output* grid\n            # Crucially check against the potentially modified output_grid\n            if not check_if_present(output_grid, target_top_left, source_obj.shape, source_obj.color):\n                 # If not present, paste the object onto the output grid\n                 paste_object(output_grid, target_top_left, source_obj.shape, source_obj.color)\n\n        # Find source objects associated with anchor2 (Symmetry check)\n        # This ensures if the pattern exists around anchor2 but not anchor1, it gets copied too.\n        for source_obj in objects:\n             if source_obj.pixels == anchor1.pixels or source_obj.pixels == anchor2.pixels:\n                continue\n             \n             dr = source_obj.top_left[0] - anchor2.top_left[0]\n             dc = source_obj.top_left[1] - anchor2.top_left[1]\n\n             target_r = anchor1.top_left[0] + dr\n             target_c = anchor1.top_left[1] + dc\n             target_top_left = (target_r, target_c)\n\n             if not check_if_present(output_grid, target_top_left, source_obj.shape, source_obj.color):\n                  paste_object(output_grid, target_top_left, source_obj.shape, source_obj.color)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3859,
    "candidates_token_count": 5108,
    "total_token_count": 8967,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 38.086628,
  "retries": 1
}