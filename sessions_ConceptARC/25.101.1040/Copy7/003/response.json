{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying three distinct non-background objects: a 'pattern' object, a 'source' object that contains it, and a 'target' object. Containment is defined by the pattern object's bounding box being strictly within the source object's bounding box.\n2. Determining the type of pattern (e.g., anti-diagonal, main diagonal offset) and its characteristic parameter (k_s) based on the pattern pixels' coordinates relative to the source object's top-left bounding box corner.\n3. Calculating a corresponding parameter (k_t) for the target object, based on the pattern type and the target object's bounding box dimensions (specifically, height H_t for anti-diagonal, or k_s itself for main diagonal offset).\n4. Applying the pattern rule (using k_t and the pattern object's color) to modify the pixels within the target object's bounding box in the output grid.\n\"\"\"\n\ndef find_connected_components(grid_np: np.ndarray, background_color: int = 0) -> list[dict]:\n    \"\"\"\n    Finds all distinct connected components (objects) of non-background colors.\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'id', 'color', 'coords' (list of tuples), and 'bbox'\n        (tuple: min_r, min_c, max_r, max_c). Returns empty list if no\n        non-background objects are found.\n    \"\"\"\n    objects = []\n    binary_grid = grid_np != background_color\n    # Use default connectivity (orthogonal neighbors)\n    labeled_array, num_features = label(binary_grid)\n\n    if num_features == 0:\n        return objects\n\n    slices = find_objects(labeled_array)\n    for i, slc in enumerate(slices):\n        obj_id = i + 1\n        # Check if the slice is valid and corresponds to a feature\n        if slc is None:\n             continue # Should not happen with find_objects output normally\n             \n        coords_raw = np.argwhere(labeled_array == obj_id)\n        if coords_raw.size == 0: continue # No pixels for this label\n\n        # Use the color of the first pixel found for this component\n        obj_color = grid_np[coords_raw[0, 0], coords_raw[0, 1]]\n        # Ensure coords are tuples\n        coords = [tuple(coord) for coord in coords_raw]\n\n        # Calculate bounding box directly from coordinates\n        min_r = np.min(coords_raw[:, 0])\n        min_c = np.min(coords_raw[:, 1])\n        max_r = np.max(coords_raw[:, 0])\n        max_c = np.max(coords_raw[:, 1])\n        bbox = (min_r, min_c, max_r, max_c)\n\n        # Store object info only if it's not background\n        if obj_color != background_color:\n            objects.append({\n                'id': obj_id,\n                'color': obj_color,\n                'coords': coords,\n                'bbox': bbox,\n                'size': len(coords)\n            })\n    return objects\n\ndef is_contained(bbox_inner: tuple, bbox_outer: tuple) -> bool:\n    \"\"\"Checks if bbox_inner is strictly contained within bbox_outer.\"\"\"\n    r1_i, c1_i, r2_i, c2_i = bbox_inner\n    r1_o, c1_o, r2_o, c2_o = bbox_outer\n    # Check strict containment (inner must be smaller or equal and inside)\n    contained = r1_o <= r1_i and c1_o <= c1_i and r2_i <= r2_o and c2_i <= c2_o\n    # Check if inner is strictly smaller in at least one dimension OR if coords are exactly the same\n    # This handles cases where the \"pattern\" might touch the edge of the frame bbox\n    smaller = (r2_i - r1_i < r2_o - r1_o) or (c2_i - c1_i < c2_o - c1_o) or (bbox_inner == bbox_outer)\n\n    # Refined check: strictly inside OR identical bounds (for pattern touching frame)\n    # AND must be truly inside (not equal)\n    # Let's simplify: Inner box corners must be >= outer box corners,\n    # and inner box must not be identical to outer box IF they have different object IDs.\n    strictly_inside = r1_o <= r1_i and c1_o <= c1_i and r2_i <= r2_o and c2_i <= c2_o\n    # We require the *object* bbox to be contained, not necessarily strictly smaller bbox\n    # if they represent different objects conceptually.\n\n    return strictly_inside\n\n\ndef identify_objects(components: list[dict]) -> tuple[dict | None, dict | None, dict | None]:\n    \"\"\"\n    Identifies the pattern, source, and target objects based on containment.\n\n    Args:\n        components: A list of object dictionaries from find_connected_components.\n\n    Returns:\n        A tuple (pattern_obj, source_obj, target_obj). Returns (None, None, None)\n        if identification fails (e.g., wrong number of objects, no containment).\n    \"\"\"\n    if len(components) < 2: # Need at least pattern and source, ideally 3\n        return None, None, None\n\n    pattern_obj = None\n    source_obj = None\n    target_obj = None\n\n    # Iterate through all pairs to find containment relationship\n    for i in range(len(components)):\n        for j in range(len(components)):\n            if i == j: continue # Don't compare object with itself\n\n            potential_pattern = components[i]\n            potential_source = components[j]\n\n            if is_contained(potential_pattern['bbox'], potential_source['bbox']):\n                 # Check if potential pattern is strictly smaller than potential source\n                 # This helps avoid ambiguity if bounding boxes accidentally match\n                 ppb = potential_pattern['bbox']\n                 psb = potential_source['bbox']\n                 p_h, p_w = ppb[2]-ppb[0]+1, ppb[3]-ppb[1]+1\n                 s_h, s_w = psb[2]-psb[0]+1, psb[3]-psb[1]+1\n\n                 # Pattern must be smaller or equal in size and strictly contained\n                 # or have the same bbox but different ID (pattern on edge)\n                 if (p_h <= s_h and p_w <= s_w) and \\\n                    (potential_pattern['id'] != potential_source['id']): # Ensure different objects\n                        # Found a candidate pair\n                        pattern_obj = potential_pattern\n                        source_obj = potential_source\n                        break # Assume only one such relationship exists\n        if pattern_obj:\n            break\n\n    if not pattern_obj or not source_obj:\n        return None, None, None # Containment relationship not found\n\n    # The target object is the remaining one\n    for obj in components:\n        if obj['id'] != pattern_obj['id'] and obj['id'] != source_obj['id']:\n            target_obj = obj\n            break # Assume only one target\n\n    if not target_obj:\n         # Handle cases with only 2 objects (pattern+source, no separate target?)\n         # This shouldn't happen based on examples, return failure\n         return None, None, None\n\n    return pattern_obj, source_obj, target_obj\n\ndef get_pattern_relative_coords(pattern_obj: dict, source_obj: dict) -> list[tuple[int, int]]:\n    \"\"\"Calculates pattern coords relative to the source bbox top-left.\"\"\"\n    rel_coords = []\n    src_min_r, src_min_c, _, _ = source_obj['bbox']\n    for r, c in pattern_obj['coords']:\n        dr = r - src_min_r\n        dc = c - src_min_c\n        rel_coords.append((dr, dc))\n    return rel_coords\n\ndef determine_pattern_rule(relative_coords: list[tuple[int, int]]) -> tuple[str | None, int | None]:\n    \"\"\"Determines pattern type ('anti_diag', 'main_diag_offset') and parameter k_s.\"\"\"\n    if not relative_coords:\n        return None, None\n\n    # Sort for consistent checking, although mathematically not always needed\n    relative_coords.sort()\n    dr0, dc0 = relative_coords[0]\n\n    # Check for anti-diagonal: dr + dc = k_s\n    k_s_anti = dr0 + dc0\n    is_anti_diag = all(dr + dc == k_s_anti for dr, dc in relative_coords)\n    if is_anti_diag:\n        return 'anti_diag', k_s_anti\n\n    # Check for main diagonal offset: dr - dc = k_s\n    k_s_main = dr0 - dc0\n    is_main_diag = all(dr - dc == k_s_main for dr, dc in relative_coords)\n    if is_main_diag:\n        return 'main_diag_offset', k_s_main\n\n    # Add other patterns here if needed (e.g., horizontal, vertical)\n    # k_s_horiz = dr0\n    # is_horiz = all(dr == k_s_horiz for dr, dc in relative_coords)\n    # if is_horiz: return 'horiz', k_s_horiz\n    # k_s_vert = dc0\n    # is_vert = all(dc == k_s_vert for dr, dc in relative_coords)\n    # if is_vert: return 'vert', k_s_vert\n\n    return None, None # Unknown pattern\n\ndef calculate_target_parameter(pattern_type: str, k_s: int, target_obj: dict) -> int | None:\n    \"\"\"Calculates the corresponding parameter k_t for the target bbox.\"\"\"\n    min_r, min_c, max_r, max_c = target_obj['bbox']\n    H_t = max_r - min_r + 1\n    # W_t = max_c - min_c + 1 # Width might be needed for other patterns\n\n    if pattern_type == 'main_diag_offset':\n        return k_s # Parameter seems constant for this type\n    elif pattern_type == 'anti_diag':\n        # Rule derived from examples: k_t depends on target height\n        return H_t - 1\n    # Add rules for other pattern types here\n    # elif pattern_type == 'horiz': return k_s\n    # elif pattern_type == 'vert': return k_s\n    else:\n        return None # Unsupported pattern type\n\ndef apply_pattern_rule(output_grid_np: np.ndarray, target_obj: dict, pattern_type: str, k_t: int, pattern_color: int):\n    \"\"\"Applies the pattern rule to modify the output grid within the target bbox.\"\"\"\n    min_r, min_c, max_r, max_c = target_obj['bbox']\n    H_t = max_r - min_r + 1\n    W_t = max_c - min_c + 1\n\n    for dr_t in range(H_t):\n        for dc_t in range(W_t):\n            apply = False\n            if pattern_type == 'main_diag_offset' and dr_t - dc_t == k_t:\n                apply = True\n            elif pattern_type == 'anti_diag' and dr_t + dc_t == k_t:\n                apply = True\n            # Add conditions for other pattern types here\n            # elif pattern_type == 'horiz' and dr_t == k_t: apply = True\n            # elif pattern_type == 'vert' and dc_t == k_t: apply = True\n\n            if apply:\n                # Calculate absolute coordinates\n                abs_r = min_r + dr_t\n                abs_c = min_c + dc_t\n                # Check if coordinates are within grid bounds before painting\n                if 0 <= abs_r < output_grid_np.shape[0] and 0 <= abs_c < output_grid_np.shape[1]:\n                    output_grid_np[abs_r, abs_c] = pattern_color\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    background_color = 0 # Assuming background is 0 (white)\n\n    # 1. Find all distinct non-background objects\n    components = find_connected_components(input_array, background_color)\n    if not components:\n         return input_grid # Return original if no objects found\n\n    # 2. Identify pattern, source, and target objects based on containment\n    pattern_obj, source_obj, target_obj = identify_objects(components)\n    if not pattern_obj or not source_obj or not target_obj:\n         # Failed to identify the three required roles\n         return input_grid # Return original\n\n    # 3. Extract pattern color\n    pattern_color = pattern_obj['color']\n\n    # 4. Calculate pattern coordinates relative to source bbox\n    relative_coords = get_pattern_relative_coords(pattern_obj, source_obj)\n    if not relative_coords:\n         # Should not happen if pattern_obj has coordinates, but check anyway\n         return input_grid\n\n    # 5. Determine pattern rule (type and k_s) from source relative coordinates\n    pattern_type, k_s = determine_pattern_rule(relative_coords)\n    if not pattern_type:\n        # Unknown or unsupported pattern type\n        return input_grid\n\n    # 6. Calculate the corresponding parameter k_t for the target context\n    k_t = calculate_target_parameter(pattern_type, k_s, target_obj)\n    if k_t is None:\n        # Could not determine target parameter for this pattern type\n        return input_grid\n\n    # 7. Apply the pattern rule using k_t within the target bbox on the output grid\n    apply_pattern_rule(output_array, target_obj, pattern_type, k_t, pattern_color)\n\n    # Convert back to list of lists for the required output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17151,
    "candidates_token_count": 3776,
    "total_token_count": 20927,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 28.788174,
  "retries": 1
}