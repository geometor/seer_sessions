{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom typing import List, Tuple, Dict, Optional\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying three distinct non-background objects: a 'pattern' object, a 'source' object whose bounding box contains the pattern object's bounding box, and a 'target' object (the remaining object).\n2. Determining the type of linear pattern (anti-diagonal or main-diagonal-offset) and its characteristic parameter (k_s) based on the pattern pixels' coordinates relative to the source object's top-left bounding box corner.\n3. Calculating a corresponding parameter (k_t) for the target object. If the pattern is anti-diagonal, k_t = H_t - 1 (where H_t is target bbox height). If the pattern is a main-diagonal-offset, k_t = k_s.\n4. Applying the identified pattern rule (using k_t and the pattern object's color) to modify the pixels within the target object's bounding box in the output grid. Pixels satisfying the rule (dr_t + dc_t == k_t for anti-diag, dr_t - dc_t == k_t for main-diag-offset) are recolored.\n\"\"\"\n\n# ================= HELPER FUNCTIONS =================\n\ndef find_connected_components(grid_np: np.ndarray, background_color: int = 0) -> List[Dict]:\n    \"\"\"\n    Finds all distinct connected components (objects) of non-background colors\n    using 4-connectivity (orthogonal neighbors).\n\n    Args:\n        grid_np: A numpy array representing the input grid.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'id', 'color', 'coords' (list of tuples), and 'bbox'\n        (tuple: min_r, min_c, max_r, max_c). Returns empty list if no\n        non-background objects are found.\n    \"\"\"\n    objects = []\n    binary_grid = grid_np != background_color\n    # Use default connectivity (structure=np.array([[0,1,0],[1,1,1],[0,1,0]]))\n    labeled_array, num_features = label(binary_grid)\n\n    if num_features == 0:\n        return objects\n\n    slices = find_objects(labeled_array)\n    for i, slc in enumerate(slices):\n        obj_id = i + 1\n        if slc is None: continue # Skip if slice is invalid\n             \n        coords_raw = np.argwhere(labeled_array == obj_id)\n        if coords_raw.size == 0: continue # No pixels for this label\n\n        obj_color = grid_np[coords_raw[0, 0], coords_raw[0, 1]]\n        coords = [tuple(coord) for coord in coords_raw]\n\n        min_r = np.min(coords_raw[:, 0])\n        min_c = np.min(coords_raw[:, 1])\n        max_r = np.max(coords_raw[:, 0])\n        max_c = np.max(coords_raw[:, 1])\n        bbox = (min_r, min_c, max_r, max_c)\n\n        if obj_color != background_color:\n            objects.append({\n                'id': obj_id,\n                'color': obj_color,\n                'coords': coords,\n                'bbox': bbox,\n                'size': len(coords)\n            })\n    return objects\n\ndef is_contained(bbox_inner: Tuple[int, int, int, int], bbox_outer: Tuple[int, int, int, int]) -> bool:\n    \"\"\"Checks if bbox_inner is contained within or equal to bbox_outer.\"\"\"\n    r1_i, c1_i, r2_i, c2_i = bbox_inner\n    r1_o, c1_o, r2_o, c2_o = bbox_outer\n    return r1_o <= r1_i and c1_o <= c1_i and r2_i <= r2_o and c2_i <= c2_o\n\ndef identify_objects(components: List[Dict]) -> Tuple[Optional[Dict], Optional[Dict], Optional[Dict]]:\n    \"\"\"\n    Identifies the pattern, source, and target objects based on containment.\n    Assumes exactly one containment relationship exists among the objects.\n\n    Args:\n        components: A list of object dictionaries.\n\n    Returns:\n        A tuple (pattern_obj, source_obj, target_obj). Returns (None, None, None)\n        if the expected structure (e.g., 3 objects, one containment) is not found.\n    \"\"\"\n    if len(components) != 3: # Expecting exactly 3 objects based on examples\n        return None, None, None\n\n    pattern_obj = None\n    source_obj = None\n    target_obj = None\n\n    # Iterate through all pairs to find the containment relationship\n    found_containment = False\n    for i in range(len(components)):\n        for j in range(len(components)):\n            if i == j: continue # Don't compare object with itself\n\n            potential_pattern = components[i]\n            potential_source = components[j]\n\n            # Check if potential_pattern's bbox is contained in potential_source's bbox\n            if is_contained(potential_pattern['bbox'], potential_source['bbox']):\n                # Ensure they are distinct objects (different IDs)\n                if potential_pattern['id'] != potential_source['id']:\n                    pattern_obj = potential_pattern\n                    source_obj = potential_source\n                    found_containment = True\n                    break # Found the relationship, assume only one\n        if found_containment:\n            break\n\n    if not pattern_obj or not source_obj:\n        return None, None, None # Containment relationship not found\n\n    # The target object is the one remaining\n    for obj in components:\n        if obj['id'] != pattern_obj['id'] and obj['id'] != source_obj['id']:\n            target_obj = obj\n            break\n\n    if not target_obj:\n         # Should not happen if len(components) == 3 and containment found\n         return None, None, None\n\n    return pattern_obj, source_obj, target_obj\n\ndef get_pattern_relative_coords(pattern_obj: Dict, source_obj: Dict) -> List[Tuple[int, int]]:\n    \"\"\"Calculates pattern coords relative to the source bbox top-left corner.\"\"\"\n    rel_coords = []\n    src_min_r, src_min_c, _, _ = source_obj['bbox']\n    for r, c in pattern_obj['coords']:\n        dr = r - src_min_r\n        dc = c - src_min_c\n        rel_coords.append((dr, dc))\n    return rel_coords\n\ndef determine_pattern_rule(relative_coords: List[Tuple[int, int]]) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"Determines pattern type ('anti_diag', 'main_diag_offset') and parameter k_s.\"\"\"\n    if not relative_coords:\n        return None, None\n\n    # Sort coords to ensure consistent parameter calculation if needed (optional here)\n    # relative_coords.sort()\n    dr0, dc0 = relative_coords[0]\n\n    # Check for anti-diagonal: dr + dc = k_s\n    k_s_anti = dr0 + dc0\n    is_anti_diag = all(dr + dc == k_s_anti for dr, dc in relative_coords)\n    if is_anti_diag:\n        return 'anti_diag', k_s_anti\n\n    # Check for main diagonal offset: dr - dc = k_s\n    k_s_main = dr0 - dc0\n    is_main_diag = all(dr - dc == k_s_main for dr, dc in relative_coords)\n    if is_main_diag:\n        return 'main_diag_offset', k_s_main\n\n    return None, None # Unknown pattern\n\ndef calculate_target_parameter(pattern_type: str, k_s: int, target_obj: Dict) -> Optional[int]:\n    \"\"\"Calculates the corresponding parameter k_t for the target bbox.\"\"\"\n    min_r, _, max_r, _ = target_obj['bbox']\n    H_t = max_r - min_r + 1\n\n    if pattern_type == 'main_diag_offset':\n        return k_s\n    elif pattern_type == 'anti_diag':\n        return H_t - 1\n    else:\n        return None # Unsupported pattern type\n\ndef apply_pattern_rule(output_grid_np: np.ndarray, target_obj: Dict, pattern_type: str, k_t: int, pattern_color: int):\n    \"\"\"Applies the pattern rule to modify the output grid within the target bbox.\"\"\"\n    min_r, min_c, max_r, max_c = target_obj['bbox']\n    H_t = max_r - min_r + 1\n    W_t = max_c - min_c + 1\n\n    for dr_t in range(H_t):\n        for dc_t in range(W_t):\n            apply_pixel = False\n            # Check if the current relative coordinate satisfies the pattern rule\n            if pattern_type == 'main_diag_offset' and dr_t - dc_t == k_t:\n                apply_pixel = True\n            elif pattern_type == 'anti_diag' and dr_t + dc_t == k_t:\n                apply_pixel = True\n            \n            if apply_pixel:\n                # Calculate absolute coordinates\n                abs_r = min_r + dr_t\n                abs_c = min_c + dc_t\n                # Paint if within grid bounds\n                if 0 <= abs_r < output_grid_np.shape[0] and 0 <= abs_c < output_grid_np.shape[1]:\n                    output_grid_np[abs_r, abs_c] = pattern_color\n\n# ================= MAIN TRANSFORM FUNCTION =================\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Main function to transform the input grid based on the identified pattern transfer rule.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_array = np.copy(input_array)\n    background_color = 0 # Assuming background is 0 (white)\n\n    # --- Step 1: Find all distinct non-background objects ---\n    components = find_connected_components(input_array, background_color)\n    if not components:\n         return input_grid # Return original if no objects found\n\n    # --- Step 2: Identify pattern, source, and target objects ---\n    pattern_obj, source_obj, target_obj = identify_objects(components)\n    if not pattern_obj or not source_obj or not target_obj:\n         # Failed to identify the required roles or structure\n         return input_grid # Return original\n\n    # --- Step 3: Extract pattern color ---\n    pattern_color = pattern_obj['color']\n\n    # --- Step 4: Calculate pattern coordinates relative to source bbox ---\n    relative_coords = get_pattern_relative_coords(pattern_obj, source_obj)\n    if not relative_coords:\n         # Should not happen if pattern_obj has coordinates\n         return input_grid\n\n    # --- Step 5: Determine pattern rule (type and k_s) from relative coordinates ---\n    pattern_type, k_s = determine_pattern_rule(relative_coords)\n    if not pattern_type or k_s is None:\n        # Unknown or unsupported pattern type found\n        return input_grid\n\n    # --- Step 6: Calculate the corresponding parameter k_t for the target context ---\n    k_t = calculate_target_parameter(pattern_type, k_s, target_obj)\n    if k_t is None:\n        # Could not determine target parameter for this pattern type\n        return input_grid\n\n    # --- Step 7: Apply the pattern rule using k_t within the target bbox on the output grid ---\n    apply_pattern_rule(output_array, target_obj, pattern_type, k_t, pattern_color)\n\n    # --- Step 8: Convert back to list of lists for the required output format ---\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 28129,
    "candidates_token_count": 3461,
    "total_token_count": 31590,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 23.444347,
  "retries": 1
}