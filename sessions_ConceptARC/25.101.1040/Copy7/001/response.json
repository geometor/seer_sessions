{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, center_of_mass\n\n\"\"\"\nIdentify two primary non-background objects. One object (source) contains an internal pattern, typically a diagonal line of a distinct color. The other object (target) is initially solid.\nCopy the pattern's type (e.g., diagonal, anti-diagonal) and color from the source object's bounding box context to the target object's bounding box context.\nThe pattern's specific parameter (like the constant sum for an anti-diagonal) is determined relative to the target bounding box dimensions.\nThe pattern is applied by changing the color of the pixels within the target's bounding box that satisfy the derived pattern rule for the target context.\n\"\"\"\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"Finds connected components of non-background colors.\"\"\"\n    objects = {}\n    binary_grid = grid != background_color\n    labeled_array, num_features = label(binary_grid)\n\n    if num_features == 0:\n        return objects\n\n    slices = find_objects(labeled_array)\n    for i, slc in enumerate(slices):\n        obj_id = i + 1\n        obj_mask = labeled_array[slc] == obj_id\n        coords_raw = np.argwhere(labeled_array == obj_id)\n        # Use the color of the first pixel found for this component\n        # This assumes components are single-colored, which holds for ARC objects\n        obj_color = grid[coords_raw[0, 0], coords_raw[0, 1]]\n\n        # Ensure coords are relative to the full grid, not the slice\n        coords = list(tuple(coord) for coord in coords_raw)\n\n        min_r = np.min(coords_raw[:, 0])\n        min_c = np.min(coords_raw[:, 1])\n        max_r = np.max(coords_raw[:, 0])\n        max_c = np.max(coords_raw[:, 1])\n        bbox = (min_r, min_c, max_r, max_c)\n\n        # Store object info: color, coordinates, bounding box\n        if obj_color != background_color:\n             # Use center of mass row as a unique-enough key for the object\n             # center_r, center_c = center_of_mass(grid, labeled_array, obj_id)\n             # obj_key = round(center_r * grid.shape[1] + center_c) # Simple hash\n             obj_key = obj_id # Use label id as key\n             objects[obj_key] = {\n                 'color': obj_color,\n                 'coords': coords,\n                 'bbox': bbox\n            }\n\n    return objects\n\ndef get_pixels_in_bbox(grid, bbox):\n    \"\"\"Extracts all pixels (r, c, color) within a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    pixels = []\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n             # Check bounds just in case bbox extends beyond grid (shouldn't happen with find_objects)\n             if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:\n                pixels.append((r, c, grid[r, c]))\n    return pixels\n\ndef identify_source_target(objects, grid, background_color=0):\n    \"\"\"Identifies source (has pattern) and target (no pattern) objects.\"\"\"\n    source_obj = None\n    target_obj = None\n    pattern_color = -1 # Invalid color initially\n\n    obj_keys = list(objects.keys())\n    if len(obj_keys) < 2:\n        # Need at least two objects for source and target\n        return None, None, -1\n\n    potential_sources = []\n    potential_targets = []\n\n    for obj_key, obj_data in objects.items():\n        obj_color = obj_data['color']\n        bbox = obj_data['bbox']\n        pixels_in_bbox = get_pixels_in_bbox(grid, bbox)\n        has_pattern = False\n        local_pattern_color = -1\n\n        for r, c, color in pixels_in_bbox:\n            if color != background_color and color != obj_color:\n                # Found a pixel within the bbox that's not background and not the object's main color\n                has_pattern = True\n                local_pattern_color = color # Assume pattern is one color\n                break # Only need one pattern pixel to classify\n\n        if has_pattern:\n            potential_sources.append((obj_key, local_pattern_color))\n        else:\n            potential_targets.append(obj_key)\n\n    # Basic assumption: one source, one target\n    if len(potential_sources) == 1 and len(potential_targets) >= 1:\n        source_key, pattern_color = potential_sources[0]\n        source_obj = objects[source_key]\n        # Find the target object that is *different* from the source object\n        # In simple cases, there might be only one potential target.\n        # If multiple, this logic might need refinement (e.g., nearest, largest).\n        # Let's pick the first one found that isn't the source.\n        for target_key in potential_targets:\n             if target_key != source_key:\n                 target_obj = objects[target_key]\n                 break # Found a distinct target\n\n    return source_obj, target_obj, pattern_color\n\n\ndef get_pattern_relative_coords(grid, source_bbox, source_color, pattern_color, background_color=0):\n    \"\"\"Finds pattern pixels within source bbox and returns their relative coordinates.\"\"\"\n    min_r, min_c, max_r, max_c = source_bbox\n    relative_coords = []\n    pixels_in_bbox = get_pixels_in_bbox(grid, source_bbox)\n\n    for r, c, color in pixels_in_bbox:\n        if color == pattern_color:\n            # Ensure this pixel is truly inside the bbox bounds defined\n            if min_r <= r <= max_r and min_c <= c <= max_c:\n                 dr = r - min_r\n                 dc = c - min_c\n                 relative_coords.append((dr, dc))\n\n    return relative_coords\n\ndef determine_pattern_rule(relative_coords, H_s, W_s):\n    \"\"\"Determines pattern type and parameter k_s from relative coordinates.\"\"\"\n    if not relative_coords:\n        return 'unknown', -1\n\n    # Use the first point to guess the rule parameter k\n    dr0, dc0 = relative_coords[0]\n\n    # Check for anti-diagonal: dr + dc = k_s\n    k_s_anti = dr0 + dc0\n    is_anti_diag = all(dr + dc == k_s_anti for dr, dc in relative_coords)\n    if is_anti_diag:\n        return 'anti_diag', k_s_anti\n\n    # Check for main diagonal offset: dr = dc + k_s => k_s = dr - dc\n    k_s_main = dr0 - dc0\n    is_main_diag = all(dr - dc == k_s_main for dr, dc in relative_coords)\n    if is_main_diag:\n        return 'main_diag_offset', k_s_main\n\n    # Check for horizontal line: dr = k_s\n    k_s_horiz = dr0\n    is_horiz = all(dr == k_s_horiz for dr, dc in relative_coords)\n    if is_horiz:\n         return 'horiz', k_s_horiz\n\n    # Check for vertical line: dc = k_s\n    k_s_vert = dc0\n    is_vert = all(dc == k_s_vert for dr, dc in relative_coords)\n    if is_vert:\n         return 'vert', k_s_vert\n\n    return 'unknown', -1\n\n\ndef calculate_target_parameter(pattern_type, k_s, H_t, W_t):\n    \"\"\"Calculates the corresponding parameter k_t for the target bbox.\"\"\"\n    if pattern_type == 'main_diag_offset':\n        # Offset relative to main diagonal seems constant\n        return k_s\n    elif pattern_type == 'anti_diag':\n        # Anti-diagonal position depends on the target dimensions.\n        # Based on train_2, where k_s=4 (for 5x5) became k_t=2 (for 3x3)\n        # k_t = H_t - 1 seems to work. Let's use that.\n        # Alternative: k_t = H_t - 1 + W_t - 1 - k_s might map opposite corners but failed test.\n        return H_t - 1 # Tentative rule\n    elif pattern_type == 'horiz':\n        # Horizontal line at specific row index relative to bbox top\n        return k_s\n    elif pattern_type == 'vert':\n         # Vertical line at specific col index relative to bbox left\n         return k_s\n    else:\n        return -1 # Unknown or unsupported pattern\n\ndef apply_pattern_rule(output_grid, target_bbox, pattern_type, k_t, pattern_color):\n    \"\"\"Applies the pattern rule to modify the output grid within the target bbox.\"\"\"\n    if pattern_type == 'unknown' or k_t == -1:\n        return # Cannot apply unknown pattern\n\n    min_r, min_c, max_r, max_c = target_bbox\n    H_t = max_r - min_r + 1\n    W_t = max_c - min_c + 1\n\n    for dr_t in range(H_t):\n        for dc_t in range(W_t):\n            apply = False\n            if pattern_type == 'main_diag_offset' and dr_t - dc_t == k_t:\n                apply = True\n            elif pattern_type == 'anti_diag' and dr_t + dc_t == k_t:\n                 apply = True\n            elif pattern_type == 'horiz' and dr_t == k_t:\n                 apply = True\n            elif pattern_type == 'vert' and dc_t == k_t:\n                 apply = True\n\n            if apply:\n                # Calculate absolute coordinates\n                abs_r = min_r + dr_t\n                abs_c = min_c + dc_t\n                # Check if coordinates are within grid bounds before painting\n                if 0 <= abs_r < output_grid.shape[0] and 0 <= abs_c < output_grid.shape[1]:\n                    output_grid[abs_r, abs_c] = pattern_color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by identifying a source object with a pattern\n    and a target object, then copying the pattern type (e.g., diagonal)\n    and color to the target object's bounding box, adjusting its parameters\n    relative to the target dimensions.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    background_color = 0 # Assuming background is 0 (white)\n\n    # 1. Find all distinct non-background objects\n    objects = find_connected_components(input_array, background_color)\n    if not objects or len(objects) < 2:\n         # Need at least source and target\n         return input_grid # Return original if cannot proceed\n\n    # 2. Identify Source (with pattern) and Target (without)\n    source_obj, target_obj, pattern_color = identify_source_target(objects, input_array, background_color)\n\n    if source_obj is None or target_obj is None or pattern_color == -1:\n        # Failed to identify required components\n        return input_grid\n\n    # 3. Get bounding boxes and source object details\n    source_bbox = source_obj['bbox']\n    target_bbox = target_obj['bbox']\n    source_color = source_obj['color']\n    H_s = source_bbox[2] - source_bbox[0] + 1\n    W_s = source_bbox[3] - source_bbox[1] + 1\n    H_t = target_bbox[2] - target_bbox[0] + 1\n    W_t = target_bbox[3] - target_bbox[1] + 1\n\n    # 4. Find pattern pixels relative to source bbox\n    relative_coords = get_pattern_relative_coords(input_array, source_bbox, source_color, pattern_color, background_color)\n    if not relative_coords:\n         # No pattern pixels found where expected\n         return input_grid\n\n    # 5. Determine pattern rule (type and k_s) from source relative coordinates\n    pattern_type, k_s = determine_pattern_rule(relative_coords, H_s, W_s)\n\n    # 6. Calculate the corresponding parameter k_t for the target context\n    k_t = calculate_target_parameter(pattern_type, k_s, H_t, W_t)\n\n    # 7. Apply the pattern rule using k_t within the target bbox\n    apply_pattern_rule(output_array, target_bbox, pattern_type, k_t, pattern_color)\n\n    # Convert back to list of lists for the required output format\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2641,
    "candidates_token_count": 11030,
    "total_token_count": 13671,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 85.607711,
  "retries": 1
}