{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Find all non-background pixels in the input grid. If none exist, return the input grid.\n2.  **Identify the Agent:**\n    *   a. Check if there's a largest group of same-colored pixels (minimum 2) forming a single horizontal or vertical line.\n    *   b. If such a line structure exists and there is *exactly one* other non-background pixel remaining, designate that single pixel as the **agent**.\n    *   c. If step (b) did not identify an agent, check if there is *exactly one* pixel whose color is unique across the entire grid. If so, designate that pixel as the **agent**.\n    *   d. If steps (b) and (c) did not identify an agent, check if there is *exactly one* pixel that has no neighbors (including diagonals) of the same color. If so, designate that pixel as the **agent**.\n    *   e. If no agent was identified, return the input grid unchanged.\n3.  Designate all non-background pixels that are *not* the agent as **obstacles**. Note the agent's color (C) and position (r0, c0).\n4.  Analyze the obstacle positions: Determine if they occupy only a single row OR a single column (structure is 'solid_line'), or if they occupy multiple rows AND columns (structure is 'scattered'). Record the set of rows (R_O) and columns (C_O) occupied by any obstacle.\n5.  Determine the drawing direction vector (dr, dc) based on the agent's position (r0, c0). The direction moves away from the nearest grid edge or corner (ties favor Up and/or Left components).\n6.  Initialize the current drawing position (r, c) to the agent's position (r0, c0).\n7.  **Draw the Line:**\n    *   Repeatedly calculate the next potential position (nr, nc) = (r + dr, c + dc).\n    *   Stop drawing if (nr, nc) is outside the grid boundaries.\n    *   **Check Stopping Conditions:**\n        *   If the obstacle structure is 'solid_line':\n            *   If moving vertically (`dc == 0`) and the next row `nr` is in R_O, stop drawing *before* coloring (nr, nc).\n            *   If moving horizontally (`dr == 0`) and the next column `nc` is in C_O, stop drawing *before* coloring (nr, nc).\n            *   If moving diagonally (`dr != 0` and `dc != 0`) and the next row `nr` is in R_O OR the next column `nc` is in C_O, stop drawing *before* coloring (nr, nc).\n        *   If the obstacle structure is 'scattered':\n            *   If the next row `nr` is in R_O OR the next column `nc` is in C_O, plan to stop drawing *after* coloring this pixel (nr, nc).\n    *   If the decision was made to stop *before* coloring, exit the drawing loop now.\n    *   Color the pixel at (nr, nc) with the agent's color C.\n    *   If the decision was made to stop *after* coloring (in the 'scattered' case), exit the drawing loop now.\n    *   Update the current position (r, c) = (nr, nc) and continue the loop.\n8.  Output the resulting grid.\n\"\"\"\n\n\n# Helper Functions\n\ndef find_non_background_pixels(grid: np.ndarray) -> list[tuple[int, int, int]]:\n    \"\"\"Finds all non-background (non-zero) pixels.\n\n    Args:\n        grid: The input numpy array representation of the grid.\n\n    Returns:\n        A list of tuples, where each tuple is (row, column, color).\n    \"\"\"\n    pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                pixels.append((r, c, int(grid[r, c])))\n    return pixels\n\ndef get_neighbors(r: int, c: int, shape: tuple[int, int]) -> list[tuple[int, int]]:\n    \"\"\"Gets the coordinates of the 8 neighboring pixels (Moore neighborhood).\n\n    Args:\n        r: The row index of the center pixel.\n        c: The column index of the center pixel.\n        shape: A tuple (height, width) representing the grid dimensions.\n\n    Returns:\n        A list of (row, column) tuples for valid neighbors within grid bounds.\n    \"\"\"\n    neighbors = []\n    height, width = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_largest_line_structure(non_bg_pixels: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    \"\"\"Finds the largest group of same-colored pixels in a single row or column.\n\n    Args:\n        non_bg_pixels: List of (r, c, color) tuples for all non-background pixels.\n\n    Returns:\n        A list of (r, c, color) tuples representing the pixels in the largest line found,\n        or an empty list if no line structure (at least 2 pixels) is found or multiple\n        lines have the same maximum size. Returns the first encountered max line in case of tie.\n    \"\"\"\n    if not non_bg_pixels:\n        return []\n\n    pixels_by_color = defaultdict(list)\n    for r, c, color in non_bg_pixels:\n        pixels_by_color[color].append((r, c, color))\n\n    largest_line = []\n    max_len = 0\n\n    # Iterate consistently (e.g., by color value) to handle ties predictably\n    sorted_colors = sorted(pixels_by_color.keys())\n\n    for color in sorted_colors:\n        pixels = pixels_by_color[color]\n        if len(pixels) < 2: # A line needs at least 2 points\n            continue\n\n        rows = set(r for r, c, _ in pixels)\n        cols = set(c for r, c, _ in pixels)\n\n        # Check for horizontal line\n        if len(rows) == 1:\n            if len(pixels) > max_len:\n                max_len = len(pixels)\n                largest_line = pixels\n            # Tie breaking: first encountered (implicit by loop order and > condition)\n\n        # Check for vertical line\n        elif len(cols) == 1: # Use elif to avoid counting grids of single points as both\n            if len(pixels) > max_len:\n                max_len = len(pixels)\n                largest_line = pixels\n            # Tie breaking: first encountered (implicit by loop order and > condition)\n\n    # Return only if a line structure was found (max_len >= 2)\n    return largest_line if max_len >= 2 else []\n\n\ndef identify_agent_and_obstacles_refined(grid: np.ndarray) -> tuple[tuple[int, int, int] | None, list[tuple[int, int, int]]]:\n    \"\"\"\n    Identifies the agent pixel and obstacle pixels using refined, prioritized rules.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple containing:\n        - agent_info: A tuple (row, col, color) for the agent, or None if no agent found.\n        - obstacle_list: A list of (row, col, color) tuples for all obstacles.\n    \"\"\"\n    non_bg_pixels = find_non_background_pixels(grid)\n    if not non_bg_pixels:\n        return None, []\n\n    agent_pixel_info = None\n    obstacle_pixels = []\n    non_bg_pixel_set = set((p[0], p[1]) for p in non_bg_pixels) # For quick lookup\n\n    # Rule 1: Structural Separation\n    line_pixels = find_largest_line_structure(non_bg_pixels)\n    if line_pixels:\n        line_pixel_coords = set((p[0], p[1]) for p in line_pixels)\n        potential_agent_coords = non_bg_pixel_set - line_pixel_coords\n        if len(potential_agent_coords) == 1:\n            agent_coord = potential_agent_coords.pop()\n            # Find the full agent info (r, c, color)\n            for r, c, color in non_bg_pixels:\n                if (r, c) == agent_coord:\n                    agent_pixel_info = (r, c, color)\n                    break\n            obstacle_pixels = line_pixels # Obstacles are the line pixels\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 2: Unique Color\n    if not agent_pixel_info:\n        color_counts = Counter(p[2] for p in non_bg_pixels)\n        unique_colors = [color for color, count in color_counts.items() if count == 1]\n        if len(unique_colors) == 1:\n            agent_color = unique_colors[0]\n            temp_obstacles = []\n            for r, c, color in non_bg_pixels:\n                if color == agent_color:\n                    agent_pixel_info = (r, c, color)\n                else:\n                    temp_obstacles.append((r, c, color))\n            obstacle_pixels = temp_obstacles\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 3: Unique Spatial Isolation\n    if not agent_pixel_info:\n        isolated_pixels = []\n        pixel_map = {(p[0], p[1]): p[2] for p in non_bg_pixels}\n        # Iterate consistently (e.g., row-major) to handle ties predictably\n        sorted_non_bg_pixels = sorted(non_bg_pixels)\n        for r, c, color in sorted_non_bg_pixels:\n            is_isolated = True\n            neighbors = get_neighbors(r, c, grid.shape)\n            for nr, nc in neighbors:\n                if pixel_map.get((nr, nc)) == color:\n                    is_isolated = False\n                    break\n            if is_isolated:\n                isolated_pixels.append((r, c, color))\n\n        if len(isolated_pixels) == 1:\n            agent_pixel_info = isolated_pixels[0]\n            # Rebuild obstacle list excluding the found agent\n            obstacle_pixels = [p for p in non_bg_pixels if (p[0], p[1]) != (agent_pixel_info[0], agent_pixel_info[1])]\n            return agent_pixel_info, obstacle_pixels\n\n    # If no agent identified by any rule\n    return None, non_bg_pixels\n\n\ndef get_obstacle_info(obstacle_pixels: list[tuple[int, int, int]]) -> tuple[set[int], set[int]]:\n    \"\"\"Extracts the sets of rows and columns occupied by obstacles.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        A tuple containing (set_of_occupied_rows, set_of_occupied_columns).\n    \"\"\"\n    occupied_rows = set(r for r, c, color in obstacle_pixels)\n    occupied_cols = set(c for r, c, color in obstacle_pixels)\n    return occupied_rows, occupied_cols\n\ndef classify_obstacle_structure(obstacle_pixels: list[tuple[int, int, int]]) -> str:\n    \"\"\"Classifies obstacle arrangement as 'solid_line' or 'scattered'.\n\n    'solid_line' means all obstacles fall within a single row OR a single column.\n    'scattered' means obstacles occupy multiple rows AND multiple columns.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        'solid_line' or 'scattered'.\n    \"\"\"\n    if not obstacle_pixels:\n        return 'scattered' # Treat no obstacles as scattered for stopping logic\n\n    occupied_rows, occupied_cols = get_obstacle_info(obstacle_pixels)\n\n    # Check if all obstacles are confined to a single row or single column\n    # Note: len <= 1 allows single-pixel obstacles to be treated as 'solid_line'\n    if len(occupied_rows) <= 1 or len(occupied_cols) <= 1:\n        return 'solid_line'\n    else:\n        return 'scattered'\n\n\ndef determine_direction(agent_pos: tuple[int, int], grid_shape: tuple[int, int]) -> tuple[int, int]:\n    \"\"\"Determines the drawing direction (dr, dc) away from the nearest grid edge/corner.\n       Ties favor Up and/or Left.\n\n    Args:\n        agent_pos: A tuple (row, col) of the agent's position.\n        grid_shape: A tuple (height, width) of the grid dimensions.\n\n    Returns:\n        A tuple (dr, dc) representing the change in row and column for the next step.\n        Example: (-1, 0) is Up, (1, 1) is Down-Right.\n    \"\"\"\n    r, c = agent_pos\n    h, w = grid_shape\n\n    # Handle 1x1 grid case\n    if h == 1 and w == 1:\n        return (0, 0)\n\n    # Calculate distances to edges\n    dist_top = r\n    dist_bottom = h - 1 - r\n    dist_left = c\n    dist_right = w - 1 - c\n\n    # Find the minimum distance to any edge\n    min_dist = min(dist_top, dist_bottom, dist_left, dist_right)\n\n    # Determine potential directions (away from closest edges), prioritizing Up/Left in ties\n    dr, dc = 0, 0\n    # Vertical component: Prioritize Up (-1) if bottom is equidistant or closer than top\n    if dist_bottom <= dist_top and dist_bottom == min_dist:\n        dr = -1 # Move Up\n    elif dist_top == min_dist:\n        dr = 1  # Move Down\n\n    # Horizontal component: Prioritize Left (-1) if right is equidistant or closer than left\n    if dist_right <= dist_left and dist_right == min_dist:\n        dc = -1 # Move Left\n    elif dist_left == min_dist:\n        dc = 1  # Move Right\n\n    # Ensure direction is non-zero if grid > 1x1 and initial dr/dc are 0\n    # This can happen if perfectly centered\n    if dr == 0 and dc == 0 and (h > 1 or w > 1):\n         # Default: away from top-left -> down-right\n         dr, dc = 1, 1\n         # Apply tie-breaking priorities if applicable\n         if dist_bottom <= dist_top: dr = -1\n         if dist_right <= dist_left: dc = -1\n\n\n    return dr, dc\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n    \"\"\"\n    # Initialize grid using numpy for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    h, w = grid.shape\n\n    # --- Step 1-3: Identify agent and obstacles using refined rules ---\n    agent_info, obstacles = identify_agent_and_obstacles_refined(grid)\n\n    # If no agent identified, return the original grid\n    if agent_info is None:\n        return input_grid # Return as list of lists\n\n    agent_r, agent_c, agent_color = agent_info\n\n    # --- Step 4: Get obstacle information and classify structure ---\n    obstacle_rows, obstacle_cols = get_obstacle_info(obstacles)\n    structure = classify_obstacle_structure(obstacles)\n\n    # --- Step 5: Determine drawing direction ---\n    dr, dc = determine_direction((agent_r, agent_c), (h, w))\n\n    # If direction is (0,0) (e.g., 1x1 grid), no drawing needed\n    if dr == 0 and dc == 0:\n        return output_grid.tolist() # Return current grid as list of lists\n\n    # --- Step 6 & 7: Draw line with appropriate stopping condition ---\n    curr_r, curr_c = agent_r, agent_c\n\n    while True:\n        # Calculate the *next* potential position\n        next_r, next_c = curr_r + dr, curr_c + dc\n\n        # Check if next position is within grid bounds\n        if not (0 <= next_r < h and 0 <= next_c < w):\n            break # Stop drawing if out of bounds\n\n        # Initialize stop flags for this iteration\n        stop_before_coloring = False\n        stop_after_coloring = False\n\n        # Check stopping conditions based on obstacle structure\n        if structure == 'solid_line':\n            # Check if the next step enters the obstacle line's row/column\n            if dr != 0 and dc == 0: # Pure vertical move\n                if next_r in obstacle_rows: stop_before_coloring = True\n            elif dr == 0 and dc != 0: # Pure horizontal move\n                if next_c in obstacle_cols: stop_before_coloring = True\n            elif dr != 0 and dc != 0: # Diagonal move\n                if next_r in obstacle_rows or next_c in obstacle_cols: stop_before_coloring = True\n\n        elif structure == 'scattered':\n            # Check if the next step enters any row or column occupied by obstacles\n            if next_r in obstacle_rows or next_c in obstacle_cols:\n                stop_after_coloring = True # Stop after coloring this pixel\n\n        # --- Apply Stop Conditions ---\n        # If stopping before coloring, break the loop now\n        if stop_before_coloring:\n            break\n\n        # --- Color the Pixel ---\n        output_grid[next_r, next_c] = agent_color\n\n        # If stopping after coloring, break the loop now\n        if stop_after_coloring:\n            break\n\n        # --- Update Position ---\n        # Update current position for the next iteration\n        curr_r, curr_c = next_r, next_c\n\n    # --- Step 8: Return the modified grid ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 30146,
    "candidates_token_count": 5025,
    "total_token_count": 35171,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 29.545306,
  "retries": 1
}