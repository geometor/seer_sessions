{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule Description:\n\nThe transformation identifies a single 'agent' pixel and multiple 'obstacle' pixels within the input grid. The agent pixel is determined first by checking for a non-background color that appears only once in the grid. If no such unique color exists, the agent is identified as the first non-background pixel found that is spatially isolated (has no neighbors of the same color). All other non-background pixels are considered obstacles.\n\nBased on the agent pixel's position relative to the grid boundaries (specifically, the nearest edge or corner), a drawing direction (up, down, left, right, or diagonal) is determined, always moving away from that nearest boundary.\n\nA line is then drawn starting from the agent's position, moving step-by-step in the determined direction, and coloring the pixels with the agent's color.\n\nThe stopping condition for the line depends on the spatial arrangement of the obstacle pixels:\n1.  If all obstacle pixels lie entirely within a single row OR a single column ('solid_line' structure), the line stops *just before* drawing a pixel that would enter that obstacle row or column.\n2.  If the obstacle pixels are dispersed across multiple rows and columns ('scattered' structure), the line stops *immediately after* drawing the first pixel whose row OR column contains any obstacle pixel.\n\nThe final output grid includes the newly drawn line segment.\n\"\"\"\n\n# Helper Functions\n\ndef find_non_background_pixels(grid: np.ndarray) -> list[tuple[int, int, int]]:\n    \"\"\"Finds all non-background (non-zero) pixels.\n\n    Args:\n        grid: The input numpy array representation of the grid.\n\n    Returns:\n        A list of tuples, where each tuple is (row, column, color).\n    \"\"\"\n    pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                pixels.append((r, c, int(grid[r, c])))\n    return pixels\n\ndef get_neighbors(r: int, c: int, shape: tuple[int, int]) -> list[tuple[int, int]]:\n    \"\"\"Gets the coordinates of the 8 neighboring pixels (Moore neighborhood).\n\n    Args:\n        r: The row index of the center pixel.\n        c: The column index of the center pixel.\n        shape: A tuple (height, width) representing the grid dimensions.\n\n    Returns:\n        A list of (row, column) tuples for valid neighbors within grid bounds.\n    \"\"\"\n    neighbors = []\n    height, width = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef identify_agent_and_obstacles(grid: np.ndarray) -> tuple[tuple[int, int, int] | None, list[tuple[int, int, int]]]:\n    \"\"\"\n    Identifies the agent pixel and obstacle pixels based on uniqueness rules.\n\n    Agent criteria precedence:\n    1. Pixel with a color that appears only once in the grid.\n    2. If no unique color, the first spatially isolated pixel found\n       (no neighbors of the same color).\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple containing:\n        - agent_info: A tuple (row, col, color) for the agent, or None if no agent found.\n        - obstacle_list: A list of (row, col, color) tuples for all obstacles.\n    \"\"\"\n    non_bg_pixels = find_non_background_pixels(grid)\n    if not non_bg_pixels:\n        return None, []\n\n    # Count color frequencies\n    color_counts = Counter(p[2] for p in non_bg_pixels)\n    unique_colors = [color for color, count in color_counts.items() if count == 1]\n\n    agent_pixel_info = None\n    obstacle_pixels = []\n\n    # Criterion 1: Unique color\n    if len(unique_colors) == 1:\n        agent_color = unique_colors[0]\n        for r, c, color in non_bg_pixels:\n            if color == agent_color:\n                agent_pixel_info = (r, c, color)\n            else:\n                obstacle_pixels.append((r, c, color))\n        return agent_pixel_info, obstacle_pixels\n    elif len(unique_colors) > 1:\n         # Ambiguous case not present in examples, treat all as obstacles for now\n         return None, non_bg_pixels\n\n\n    # Criterion 2: Spatial isolation (if no unique color was found)\n    if not agent_pixel_info:\n        pixel_map = {(p[0], p[1]): p[2] for p in non_bg_pixels}\n        for r, c, color in non_bg_pixels:\n            is_isolated = True\n            neighbors = get_neighbors(r, c, grid.shape)\n            for nr, nc in neighbors:\n                if pixel_map.get((nr, nc)) == color:\n                    is_isolated = False\n                    break\n            if is_isolated:\n                agent_pixel_info = (r, c, color)\n                # Rebuild obstacle list excluding the found agent\n                obstacle_pixels = [p for p in non_bg_pixels if (p[0], p[1]) != (r, c)]\n                return agent_pixel_info, obstacle_pixels\n\n    # If no agent identified by either criterion\n    return None, non_bg_pixels\n\n\ndef get_obstacle_info(obstacle_pixels: list[tuple[int, int, int]]) -> tuple[set[int], set[int]]:\n    \"\"\"Extracts the sets of rows and columns occupied by obstacles.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        A tuple containing (set_of_occupied_rows, set_of_occupied_columns).\n    \"\"\"\n    occupied_rows = set(r for r, c, color in obstacle_pixels)\n    occupied_cols = set(c for r, c, color in obstacle_pixels)\n    return occupied_rows, occupied_cols\n\ndef classify_obstacle_structure(obstacle_pixels: list[tuple[int, int, int]]) -> str:\n    \"\"\"Classifies obstacle arrangement as 'solid_line' or 'scattered'.\n\n    'solid_line' means all obstacles fall within a single row OR a single column.\n    'scattered' means obstacles occupy multiple rows AND multiple columns.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        'solid_line' or 'scattered'.\n    \"\"\"\n    if not obstacle_pixels:\n        return 'scattered' # Treat no obstacles as scattered for stopping logic\n\n    occupied_rows, occupied_cols = get_obstacle_info(obstacle_pixels)\n\n    # Check if all obstacles are confined to a single row or single column\n    if len(occupied_rows) == 1 or len(occupied_cols) == 1:\n        return 'solid_line'\n    else:\n        return 'scattered'\n\ndef determine_direction(agent_pos: tuple[int, int], grid_shape: tuple[int, int]) -> tuple[int, int]:\n    \"\"\"Determines the drawing direction (dr, dc) away from the nearest grid edge/corner.\n\n    Args:\n        agent_pos: A tuple (row, col) of the agent's position.\n        grid_shape: A tuple (height, width) of the grid dimensions.\n\n    Returns:\n        A tuple (dr, dc) representing the change in row and column for the next step.\n        Example: (-1, 0) is Up, (1, 1) is Down-Right.\n    \"\"\"\n    r, c = agent_pos\n    h, w = grid_shape\n\n    # Calculate distances to edges\n    dist_top = r\n    dist_bottom = h - 1 - r\n    dist_left = c\n    dist_right = w - 1 - c\n\n    # Find the minimum distance to any edge\n    min_dist = min(dist_top, dist_bottom, dist_left, dist_right)\n\n    # Determine direction components (move away from the closest edge)\n    dr, dc = 0, 0\n    if dist_top == min_dist:\n        dr = 1  # Move Down\n    if dist_bottom == min_dist:\n        dr = -1 # Move Up\n    if dist_left == min_dist:\n        dc = 1  # Move Right\n    if dist_right == min_dist:\n        dc = -1 # Move Left\n\n    # Adjust if multiple edges are equidistant (corners / exact centers)\n    # If tied for closest vertical edge, dr might be +/-1. If tied for horizontal, dc might be +/-1.\n    # If tied between a vertical and horizontal edge (corner case):\n    is_top = dist_top == min_dist\n    is_bottom = dist_bottom == min_dist\n    is_left = dist_left == min_dist\n    is_right = dist_right == min_dist\n\n    # Explicitly set corner directions\n    if is_top and is_left: dr, dc = 1, 1      # Away from Top-Left\n    elif is_top and is_right: dr, dc = 1, -1     # Away from Top-Right\n    elif is_bottom and is_left: dr, dc = -1, 1    # Away from Bottom-Left\n    elif is_bottom and is_right: dr, dc = -1, -1   # Away from Bottom-Right\n    # If tied top/bottom or left/right, the individual assignments above handle it.\n    # e.g., if tied top/bottom only, dr might be set twice, ending as -1 (up).\n    # e.g., if tied left/right only, dc might be set twice, ending as -1 (left).\n    # Let's rethink the tie logic slightly: set direction based on *first* hit minimum.\n    dr_final, dc_final = 0, 0\n    if dist_top == min_dist: dr_final = 1\n    elif dist_bottom == min_dist: dr_final = -1\n\n    if dist_left == min_dist: dc_final = 1\n    elif dist_right == min_dist: dc_final = -1\n\n    # Ensure diagonals are captured if both vertical and horizontal are min_dist\n    if (is_top or is_bottom) and (is_left or is_right):\n         # Use the individually determined components\n         dr, dc = dr_final, dc_final\n    elif is_top or is_bottom: # Only vertical edge is closest\n         dr, dc = dr_final, 0\n    elif is_left or is_right: # Only horizontal edge is closest\n         dr, dc = 0, dc_final\n    # If agent is perfectly centered and h,w > 1, min_dist > 0.\n    # This logic might result in (0,0) if perfectly centered. Add default.\n    if dr == 0 and dc == 0 and (h > 1 or w > 1):\n         # Default: try moving away from top-left? (arbitrary consistent choice)\n         if h > 1 : dr = 1\n         if w > 1 : dc = 1\n         if dr == 0 and dc == 0 : # if h=1 and w=1\n             pass # direction remains (0,0)\n\n    return dr, dc\n\n# Main Transformation Function\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Initialize grid using numpy for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    h, w = grid.shape\n\n    # --- Step 1: Identify agent and obstacles ---\n    agent_info, obstacles = identify_agent_and_obstacles(grid)\n\n    # If no agent identified, return the original grid\n    if agent_info is None:\n        return input_grid\n\n    agent_r, agent_c, agent_color = agent_info\n\n    # --- Step 2: Get obstacle information ---\n    obstacle_rows, obstacle_cols = get_obstacle_info(obstacles)\n\n    # --- Step 3: Classify obstacle structure ---\n    structure = classify_obstacle_structure(obstacles)\n\n    # --- Step 4: Determine drawing direction ---\n    dr, dc = determine_direction((agent_r, agent_c), (h, w))\n\n    # If direction is (0,0) (e.g., 1x1 grid or error), no drawing needed\n    if dr == 0 and dc == 0:\n        return input_grid\n\n    # --- Step 5 & 6/7: Draw line with appropriate stopping condition ---\n    curr_r, curr_c = agent_r, agent_c\n\n    while True:\n        # Calculate the *next* potential position\n        next_r, next_c = curr_r + dr, curr_c + dc\n\n        # Check if next position is within grid bounds\n        if not (0 <= next_r < h and 0 <= next_c < w):\n            break # Stop drawing if out of bounds\n\n        # Check stopping conditions based on obstacle structure\n        stop_drawing = False\n        if structure == 'solid_line':\n            # Stop *before* drawing on the obstacle row/column\n            if dr != 0 and next_r in obstacle_rows: # Moving vertically into obstacle row\n                 stop_drawing = True\n            elif dc != 0 and next_c in obstacle_cols: # Moving horizontally into obstacle col\n                 stop_drawing = True\n            # Handle diagonal moves towards a line (stop if either row or col matches)\n            elif dr != 0 and dc != 0 and (next_r in obstacle_rows or next_c in obstacle_cols):\n                 stop_drawing = True\n\n            if stop_drawing:\n                break # Break before coloring next_r, next_c\n\n        elif structure == 'scattered':\n            # Stop *after* drawing on the first row/column that contains an obstacle\n            if next_r in obstacle_rows or next_c in obstacle_cols:\n                output_grid[next_r, next_c] = agent_color # Color the stopping pixel\n                stop_drawing = True                     # Set flag to break after coloring\n                # Note: coloring happens below if not stopping yet\n\n        # If we determined to stop *before* coloring (solid_line case hit), exit loop\n        # (Already handled by the 'break' inside the 'solid_line' block)\n\n        # Color the next pixel if we haven't decided to stop yet\n        if not stop_drawing:\n             output_grid[next_r, next_c] = agent_color\n\n        # If we determined to stop *after* coloring (scattered case hit), exit loop now\n        if stop_drawing and structure == 'scattered':\n            break\n\n        # Update current position for the next iteration\n        curr_r, curr_c = next_r, next_c\n\n    # --- Step 8: Return the modified grid ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4208,
    "candidates_token_count": 11235,
    "total_token_count": 15443,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 84.547437,
  "retries": 1
}