{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule Description:\n\n1.  Find all non-background pixels in the input grid. If none exist, return the input grid.\n2.  **Identify the Agent:**\n    *   a. Find the largest possible group (minimum 2 pixels) of non-background pixels that share the same color AND all lie on the same single row OR the same single column (this is the 'line structure'). If there's a tie for largest, use the first one found (determined by consistent iteration order).\n    *   b. If such a line structure exists and there is *exactly one* other non-background pixel anywhere else in the grid, designate that single pixel as the **agent**. The pixels in the line structure become the **obstacles**.\n    *   c. If step (b) did not identify an agent, check if there is *exactly one* pixel whose color is unique across the entire grid. If so, designate that pixel as the **agent**. All other non-background pixels become **obstacles**.\n    *   d. If steps (b) and (c) did not identify an agent, check if there is *exactly one* non-background pixel that has no neighbors (including diagonals) of the same color (first found in a consistent scan). If so, designate that pixel as the **agent**. All other non-background pixels become **obstacles**.\n    *   e. If no agent was identified by steps (b), (c), or (d), return the input grid unchanged.\n3.  Note the agent's color (C) and position (r0, c0).\n4.  Analyze the **obstacle** positions: Determine if they occupy only a single row OR a single column (structure is 'solid_line'), or if they occupy multiple rows AND columns (structure is 'scattered'). Record the set of rows (R_O) and columns (C_O) occupied by any obstacle.\n5.  Determine the drawing direction vector (dr, dc) based on the agent's position (r0, c0). The direction moves away from the nearest grid edge or corner (ties favor Up and/or Left components).\n6.  Initialize the current drawing position (r, c) to the agent's position (r0, c0).\n7.  **Draw the Line:**\n    *   Repeatedly calculate the next potential position (nr, nc) = (r + dr, c + dc).\n    *   Stop drawing if (nr, nc) is outside the grid boundaries.\n    *   **Check Stopping Conditions:**\n        *   If the obstacle structure is 'solid_line':\n            *   If moving purely vertically (`dc == 0`) and the next row `nr` is in R_O, stop drawing *before* coloring (nr, nc).\n            *   If moving purely horizontally (`dr == 0`) and the next column `nc` is in C_O, stop drawing *before* coloring (nr, nc).\n            *   If moving diagonally (`dr != 0` and `dc != 0`) and (the next row `nr` is in R_O OR the next column `nc` is in C_O), stop drawing *before* coloring (nr, nc).\n        *   If the obstacle structure is 'scattered':\n            *   If the next row `nr` is in R_O OR the next column `nc` is in C_O, plan to stop drawing *after* coloring this pixel (nr, nc).\n    *   If the decision was made to stop *before* coloring, exit the drawing loop now.\n    *   Color the pixel at (nr, nc) with the agent's color C.\n    *   If the decision was made to stop *after* coloring (in the 'scattered' case), exit the drawing loop now.\n    *   Update the current position (r, c) = (nr, nc) and continue the loop.\n8.  Output the resulting grid.\n\"\"\"\n\n# Helper Functions\n\ndef find_non_background_pixels(grid: np.ndarray) -> list[tuple[int, int, int]]:\n    \"\"\"Finds all non-background (non-zero) pixels.\"\"\"\n    pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                pixels.append((r, c, int(grid[r, c])))\n    return pixels\n\ndef get_neighbors(r: int, c: int, shape: tuple[int, int]) -> list[tuple[int, int]]:\n    \"\"\"Gets the coordinates of the 8 neighboring pixels (Moore neighborhood).\"\"\"\n    neighbors = []\n    height, width = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_largest_line_structure(non_bg_pixels: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    \"\"\"\n    Finds the largest subset of same-colored pixels (min 2) forming a single row or column.\n    Returns the pixels of the first largest line found in case of ties.\n    \"\"\"\n    if not non_bg_pixels: return []\n\n    pixels_by_color = defaultdict(list)\n    for r, c, color in non_bg_pixels:\n        pixels_by_color[color].append((r, c)) # Store coordinates only\n\n    overall_largest_line_pixels_full_info = []\n    max_len = 0\n\n    # Iterate consistently (e.g., by color value) to handle ties predictably\n    sorted_colors = sorted(pixels_by_color.keys())\n    for color in sorted_colors:\n        pixel_coords = pixels_by_color[color]\n        if len(pixel_coords) < 2: continue # Need at least 2 points for a line structure\n\n        # Check rows\n        rows_count = Counter(r for r, c in pixel_coords)\n        for r, count in rows_count.items():\n            if count > max_len:\n                max_len = count\n                # Store full (r, c, color) info for the line pixels\n                overall_largest_line_pixels_full_info = [(r_pix, c, color) for r_pix, c in pixel_coords if r_pix == r]\n            # Tie breaking: keep the first one found (implicit)\n\n        # Check columns\n        cols_count = Counter(c for r, c in pixel_coords)\n        for c, count in cols_count.items():\n            if count > max_len:\n                max_len = count\n                # Store full (r, c, color) info for the line pixels\n                overall_largest_line_pixels_full_info = [(r, c_pix, color) for r, c_pix in pixel_coords if c_pix == c]\n            # Tie breaking: keep the first one found (implicit)\n\n    # Return only if a line structure of at least 2 pixels was found\n    return overall_largest_line_pixels_full_info if max_len >= 2 else []\n\n\ndef identify_agent_and_obstacles_refined(grid: np.ndarray) -> tuple[tuple[int, int, int] | None, list[tuple[int, int, int]]]:\n    \"\"\"\n    Identifies the agent pixel and obstacle pixels using refined, prioritized rules.\n    \"\"\"\n    non_bg_pixels = find_non_background_pixels(grid)\n    if not non_bg_pixels:\n        return None, []\n\n    agent_pixel_info = None\n    obstacle_pixels = []\n    non_bg_pixel_set = set((p[0], p[1]) for p in non_bg_pixels) # Set of (r, c) for quick lookup\n\n    # Rule 1: Structural Separation\n    line_pixels_info = find_largest_line_structure(non_bg_pixels) # Gets list of (r,c,color)\n    if line_pixels_info:\n        line_pixel_coords = set((p[0], p[1]) for p in line_pixels_info)\n        potential_agent_coords = non_bg_pixel_set - line_pixel_coords\n        if len(potential_agent_coords) == 1:\n            agent_coord = potential_agent_coords.pop()\n            # Find the full agent info (r, c, color)\n            for r, c, color in non_bg_pixels:\n                if (r, c) == agent_coord:\n                    agent_pixel_info = (r, c, color)\n                    break\n            # Obstacles are precisely the pixels forming the line structure\n            obstacle_pixels = line_pixels_info\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 2: Unique Color\n    if not agent_pixel_info:\n        color_counts = Counter(p[2] for p in non_bg_pixels)\n        unique_colors = [color for color, count in color_counts.items() if count == 1]\n        if len(unique_colors) == 1:\n            agent_color = unique_colors[0]\n            temp_obstacles = []\n            for r, c, color in non_bg_pixels:\n                if color == agent_color:\n                    agent_pixel_info = (r, c, color)\n                else:\n                    temp_obstacles.append((r, c, color))\n            obstacle_pixels = temp_obstacles\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 3: Unique Spatial Isolation\n    if not agent_pixel_info:\n        isolated_pixels = []\n        pixel_map = {(p[0], p[1]): p[2] for p in non_bg_pixels}\n        # Iterate consistently (e.g., row-major) to handle ties predictably\n        sorted_non_bg_pixels = sorted(non_bg_pixels)\n        for r, c, color in sorted_non_bg_pixels:\n            is_isolated = True\n            neighbors = get_neighbors(r, c, grid.shape)\n            for nr, nc in neighbors:\n                if pixel_map.get((nr, nc)) == color:\n                    is_isolated = False\n                    break\n            if is_isolated:\n                isolated_pixels.append((r, c, color))\n\n        if len(isolated_pixels) == 1:\n            agent_pixel_info = isolated_pixels[0]\n            # Rebuild obstacle list excluding the found agent\n            obstacle_pixels = [p for p in non_bg_pixels if (p[0], p[1]) != (agent_pixel_info[0], agent_pixel_info[1])]\n            return agent_pixel_info, obstacle_pixels\n\n    # If no agent identified by any rule\n    return None, non_bg_pixels\n\n\ndef get_obstacle_info(obstacle_pixels: list[tuple[int, int, int]]) -> tuple[set[int], set[int]]:\n    \"\"\"Extracts the sets of rows and columns occupied by obstacles.\"\"\"\n    occupied_rows = set(r for r, c, color in obstacle_pixels)\n    occupied_cols = set(c for r, c, color in obstacle_pixels)\n    return occupied_rows, occupied_cols\n\ndef classify_obstacle_structure(obstacle_pixels: list[tuple[int, int, int]]) -> str:\n    \"\"\"\n    Classifies obstacle arrangement as 'solid_line' or 'scattered'.\n    'solid_line' if obstacles occupy <= 1 row OR <= 1 column.\n    \"\"\"\n    if not obstacle_pixels:\n        return 'scattered' # Treat no obstacles as scattered for stopping logic\n    occupied_rows, occupied_cols = get_obstacle_info(obstacle_pixels)\n    # Check if all obstacles are confined to a single row or single column\n    if len(occupied_rows) <= 1 or len(occupied_cols) <= 1:\n        return 'solid_line'\n    else:\n        return 'scattered'\n\n\ndef determine_direction(agent_pos: tuple[int, int], grid_shape: tuple[int, int]) -> tuple[int, int]:\n    \"\"\"\n    Determines the drawing direction (dr, dc) away from the nearest grid edge/corner.\n    Ties favor Up (-1 for dr) and/or Left (-1 for dc).\n    \"\"\"\n    r, c = agent_pos\n    h, w = grid_shape\n\n    # Handle 1x1 grid case\n    if h == 1 and w == 1:\n        return (0, 0)\n\n    # Calculate distances to edges\n    dist_top = r\n    dist_bottom = h - 1 - r\n    dist_left = c\n    dist_right = w - 1 - c\n\n    # Find the minimum distance to any edge\n    min_dist = min(dist_top, dist_bottom, dist_left, dist_right)\n\n    # Determine potential directions (away from closest edges), prioritizing Up/Left in ties\n    dr, dc = 0, 0\n    # Vertical component: Prioritize Up (-1) if bottom is equidistant or closer than top\n    if dist_bottom <= dist_top and dist_bottom == min_dist:\n        dr = -1 # Move Up (away from bottom)\n    elif dist_top == min_dist:\n        dr = 1  # Move Down (away from top)\n\n    # Horizontal component: Prioritize Left (-1) if right is equidistant or closer than left\n    if dist_right <= dist_left and dist_right == min_dist:\n        dc = -1 # Move Left (away from right)\n    elif dist_left == min_dist:\n        dc = 1  # Move Right (away from left)\n\n    # Ensure direction is non-zero if grid > 1x1 and initial dr/dc are 0 (can happen if perfectly centered)\n    if dr == 0 and dc == 0 and (h > 1 or w > 1):\n         # Default: away from top-left -> down-right initially\n         dr_default, dc_default = 1, 1\n         # Apply tie-breaking priorities if applicable\n         if dist_bottom <= dist_top: dr_default = -1\n         if dist_right <= dist_left: dc_default = -1\n         dr, dc = dr_default, dc_default\n\n    return dr, dc\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Step 0: Initialize\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    h, w = grid.shape\n\n    # Step 1 & 2: Identify agent and obstacles using refined rules\n    agent_info, obstacles = identify_agent_and_obstacles_refined(grid)\n\n    # Step 2e: If no agent identified, return the original grid\n    if agent_info is None:\n        return input_grid # Return original list of lists\n\n    # Step 3: Note agent info\n    agent_r, agent_c, agent_color = agent_info\n\n    # Step 4: Analyze obstacles\n    obstacle_rows, obstacle_cols = get_obstacle_info(obstacles)\n    structure = classify_obstacle_structure(obstacles)\n\n    # Step 5: Determine drawing direction\n    dr, dc = determine_direction((agent_r, agent_c), (h, w))\n\n    # Handle case where direction is (0,0) (e.g., 1x1 grid)\n    if dr == 0 and dc == 0:\n        return output_grid.tolist() # Return current grid state\n\n    # Step 6: Initialize current position\n    curr_r, curr_c = agent_r, agent_c\n\n    # Step 7: Draw the Line loop\n    while True:\n        # Calculate the *next* potential position\n        next_r, next_c = curr_r + dr, curr_c + dc\n\n        # Stop drawing if out of bounds\n        if not (0 <= next_r < h and 0 <= next_c < w):\n            break\n\n        # Initialize stop flags for this iteration\n        stop_before_coloring = False\n        stop_after_coloring = False\n\n        # Check Stopping Conditions based on obstacle structure\n        if structure == 'solid_line':\n            # Stop *before* entering the line's row/col based on move direction\n            if dr != 0 and dc == 0: # Pure vertical move\n                if next_r in obstacle_rows: stop_before_coloring = True\n            elif dr == 0 and dc != 0: # Pure horizontal move\n                if next_c in obstacle_cols: stop_before_coloring = True\n            elif dr != 0 and dc != 0: # Diagonal move\n                if next_r in obstacle_rows or next_c in obstacle_cols: stop_before_coloring = True\n\n        elif structure == 'scattered':\n            # Stop *after* entering any row or column occupied by obstacles\n            if next_r in obstacle_rows or next_c in obstacle_cols:\n                stop_after_coloring = True # Stop after coloring this pixel\n\n        # --- Apply Stop Conditions ---\n        # If stopping before coloring, break the loop now\n        if stop_before_coloring:\n            break\n\n        # --- Color the Pixel ---\n        output_grid[next_r, next_c] = agent_color\n\n        # If stopping after coloring, break the loop now\n        if stop_after_coloring:\n            break\n\n        # --- Update Position ---\n        # Update current position for the next iteration\n        curr_r, curr_c = next_r, next_c\n\n    # Step 8: Return the modified grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 47058,
    "candidates_token_count": 4673,
    "total_token_count": 51731,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.74122,
  "retries": 1
}