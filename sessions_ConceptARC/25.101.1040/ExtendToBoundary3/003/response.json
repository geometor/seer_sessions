{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransformation Rule Description:\n\nThe transformation identifies a single 'agent' pixel and multiple 'obstacle' pixels within the input grid. The agent pixel is identified using a prioritized set of rules:\n1.  Structural Separation: If the largest group of same-colored pixels forming a line (horizontal or vertical) can be identified, and there is exactly one other non-background pixel remaining, that single remaining pixel is the agent.\n2.  Unique Color: If rule 1 doesn't apply, if there's exactly one pixel whose color appears only once in the entire grid, that pixel is the agent.\n3.  Unique Spatial Isolation: If rules 1 and 2 don't apply, if there's exactly one non-background pixel with no neighbors (Moore neighborhood) of the same color, that pixel is the agent.\nIf no agent is identified, the grid remains unchanged.\n\nAll non-background pixels that are not the agent are considered 'obstacles'.\n\nBased on the agent pixel's position relative to the grid boundaries (specifically, the nearest edge or corner), a drawing direction (up, down, left, right, or diagonal) is determined, always moving away from that nearest boundary.\n\nA line is then drawn starting one step away from the agent's position, moving step-by-step in the determined direction, and coloring the pixels with the agent's color.\n\nThe stopping condition for the line depends on the spatial arrangement of the obstacle pixels:\n1.  Solid Line Obstacles: If all obstacle pixels lie entirely within a single row OR a single column ('solid_line' structure), the line stops *just before* drawing a pixel that would enter that obstacle row or column.\n2.  Scattered Obstacles: If the obstacle pixels are dispersed across multiple rows and columns ('scattered' structure), the line stops *immediately after* drawing the first pixel whose row OR column contains any obstacle pixel.\n\nThe final output grid includes the newly drawn line segment.\n\"\"\"\n\n# Imports\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n# Helper Functions\n\ndef find_non_background_pixels(grid: np.ndarray) -> list[tuple[int, int, int]]:\n    \"\"\"Finds all non-background (non-zero) pixels.\n\n    Args:\n        grid: The input numpy array representation of the grid.\n\n    Returns:\n        A list of tuples, where each tuple is (row, column, color).\n    \"\"\"\n    pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0:\n                pixels.append((r, c, int(grid[r, c])))\n    return pixels\n\ndef get_neighbors(r: int, c: int, shape: tuple[int, int]) -> list[tuple[int, int]]:\n    \"\"\"Gets the coordinates of the 8 neighboring pixels (Moore neighborhood).\n\n    Args:\n        r: The row index of the center pixel.\n        c: The column index of the center pixel.\n        shape: A tuple (height, width) representing the grid dimensions.\n\n    Returns:\n        A list of (row, column) tuples for valid neighbors within grid bounds.\n    \"\"\"\n    neighbors = []\n    height, width = shape\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue # Skip self\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_largest_line_structure(non_bg_pixels: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    \"\"\"Finds the largest group of same-colored pixels in a single row or column.\n\n    Args:\n        non_bg_pixels: List of (r, c, color) tuples for all non-background pixels.\n\n    Returns:\n        A list of (r, c, color) tuples representing the pixels in the largest line found,\n        or an empty list if no line structure (at least 2 pixels) is found or multiple\n        lines have the same maximum size.\n    \"\"\"\n    if not non_bg_pixels:\n        return []\n\n    pixels_by_color = defaultdict(list)\n    for r, c, color in non_bg_pixels:\n        pixels_by_color[color].append((r, c, color))\n\n    largest_line = []\n    max_len = 0\n\n    for color, pixels in pixels_by_color.items():\n        if len(pixels) < 2: # A line needs at least 2 points\n            continue\n\n        rows = set(r for r, c, _ in pixels)\n        cols = set(c for r, c, _ in pixels)\n\n        # Check for horizontal line\n        if len(rows) == 1:\n            if len(pixels) > max_len:\n                max_len = len(pixels)\n                largest_line = pixels\n            elif len(pixels) == max_len:\n                 # Tie case - invalidate by returning empty? Or pick first? Let's invalidate for now.\n                 # If ties are allowed, this might need adjusting based on examples.\n                 # For now, assume a unique largest line is required for Rule 1.\n                 # Revisit if examples contradict this. Let's stick with picking the first for now.\n                 # If we stick with the first, the condition 'len(pixels) > max_len' handles it.\n                 pass\n\n\n        # Check for vertical line\n        elif len(cols) == 1: # Use elif to avoid counting grids of single points as both\n            if len(pixels) > max_len:\n                max_len = len(pixels)\n                largest_line = pixels\n            elif len(pixels) == max_len:\n                 # Tie case - see above comment.\n                 pass\n\n    # Return only if a line structure was found (max_len >= 2)\n    return largest_line if max_len >= 2 else []\n\n\ndef identify_agent_and_obstacles_refined(grid: np.ndarray) -> tuple[tuple[int, int, int] | None, list[tuple[int, int, int]]]:\n    \"\"\"\n    Identifies the agent pixel and obstacle pixels using refined, prioritized rules.\n\n    Args:\n        grid: The input numpy array grid.\n\n    Returns:\n        A tuple containing:\n        - agent_info: A tuple (row, col, color) for the agent, or None if no agent found.\n        - obstacle_list: A list of (row, col, color) tuples for all obstacles.\n    \"\"\"\n    non_bg_pixels = find_non_background_pixels(grid)\n    if not non_bg_pixels:\n        return None, []\n\n    agent_pixel_info = None\n    obstacle_pixels = []\n    non_bg_pixel_set = set((p[0], p[1]) for p in non_bg_pixels) # For quick lookup\n\n    # Rule 1: Structural Separation\n    line_pixels = find_largest_line_structure(non_bg_pixels)\n    if line_pixels:\n        line_pixel_coords = set((p[0], p[1]) for p in line_pixels)\n        potential_agent_coords = non_bg_pixel_set - line_pixel_coords\n        if len(potential_agent_coords) == 1:\n            agent_coord = potential_agent_coords.pop()\n            # Find the full agent info (r, c, color)\n            for r, c, color in non_bg_pixels:\n                if (r, c) == agent_coord:\n                    agent_pixel_info = (r, c, color)\n                    break\n            obstacle_pixels = line_pixels # Obstacles are the line pixels\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 2: Unique Color\n    if not agent_pixel_info:\n        color_counts = Counter(p[2] for p in non_bg_pixels)\n        unique_colors = [color for color, count in color_counts.items() if count == 1]\n        if len(unique_colors) == 1:\n            agent_color = unique_colors[0]\n            temp_obstacles = []\n            for r, c, color in non_bg_pixels:\n                if color == agent_color:\n                    agent_pixel_info = (r, c, color)\n                else:\n                    temp_obstacles.append((r, c, color))\n            obstacle_pixels = temp_obstacles\n            return agent_pixel_info, obstacle_pixels\n\n    # Rule 3: Unique Spatial Isolation\n    if not agent_pixel_info:\n        isolated_pixels = []\n        pixel_map = {(p[0], p[1]): p[2] for p in non_bg_pixels}\n        for r, c, color in non_bg_pixels:\n            is_isolated = True\n            neighbors = get_neighbors(r, c, grid.shape)\n            for nr, nc in neighbors:\n                if pixel_map.get((nr, nc)) == color:\n                    is_isolated = False\n                    break\n            if is_isolated:\n                isolated_pixels.append((r, c, color))\n\n        if len(isolated_pixels) == 1:\n            agent_pixel_info = isolated_pixels[0]\n            # Rebuild obstacle list excluding the found agent\n            obstacle_pixels = [p for p in non_bg_pixels if (p[0], p[1]) != (agent_pixel_info[0], agent_pixel_info[1])]\n            return agent_pixel_info, obstacle_pixels\n\n    # If no agent identified by any rule\n    # Assign obstacles as all non-bg pixels if no agent found.\n    # This ensures obstacle info is available even if drawing doesn't happen.\n    return None, non_bg_pixels\n\n\ndef get_obstacle_info(obstacle_pixels: list[tuple[int, int, int]]) -> tuple[set[int], set[int]]:\n    \"\"\"Extracts the sets of rows and columns occupied by obstacles.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        A tuple containing (set_of_occupied_rows, set_of_occupied_columns).\n    \"\"\"\n    occupied_rows = set(r for r, c, color in obstacle_pixels)\n    occupied_cols = set(c for r, c, color in obstacle_pixels)\n    return occupied_rows, occupied_cols\n\ndef classify_obstacle_structure(obstacle_pixels: list[tuple[int, int, int]]) -> str:\n    \"\"\"Classifies obstacle arrangement as 'solid_line' or 'scattered'.\n\n    'solid_line' means all obstacles fall within a single row OR a single column.\n    'scattered' means obstacles occupy multiple rows AND multiple columns.\n\n    Args:\n        obstacle_pixels: A list of (row, col, color) tuples for obstacles.\n\n    Returns:\n        'solid_line' or 'scattered'.\n    \"\"\"\n    if not obstacle_pixels:\n        return 'scattered' # Treat no obstacles as scattered for stopping logic\n\n    occupied_rows, occupied_cols = get_obstacle_info(obstacle_pixels)\n\n    # Check if all obstacles are confined to a single row or single column\n    if len(occupied_rows) <= 1 or len(occupied_cols) <= 1: # Allow single point \"lines\"\n        return 'solid_line'\n    else:\n        return 'scattered'\n\n\ndef determine_direction(agent_pos: tuple[int, int], grid_shape: tuple[int, int]) -> tuple[int, int]:\n    \"\"\"Determines the drawing direction (dr, dc) away from the nearest grid edge/corner.\n\n    Args:\n        agent_pos: A tuple (row, col) of the agent's position.\n        grid_shape: A tuple (height, width) of the grid dimensions.\n\n    Returns:\n        A tuple (dr, dc) representing the change in row and column for the next step.\n        Example: (-1, 0) is Up, (1, 1) is Down-Right.\n    \"\"\"\n    r, c = agent_pos\n    h, w = grid_shape\n\n    # Handle 1x1 grid case\n    if h == 1 and w == 1:\n        return (0, 0)\n\n    # Calculate distances to edges\n    dist_top = r\n    dist_bottom = h - 1 - r\n    dist_left = c\n    dist_right = w - 1 - c\n\n    # Find the minimum distance to any edge\n    min_dist = min(dist_top, dist_bottom, dist_left, dist_right)\n\n    # Determine potential directions (away from closest edges)\n    dr, dc = 0, 0\n    if dist_top == min_dist:\n        dr = 1  # Move Down (away from top)\n    if dist_bottom == min_dist:\n        # If dr is already 1 (meaning top was also min_dist), bottom wins (move Up)\n        dr = -1 # Move Up (away from bottom)\n    if dist_left == min_dist:\n        dc = 1  # Move Right (away from left)\n    if dist_right == min_dist:\n        # If dc is already 1 (meaning left was also min_dist), right wins (move Left)\n        dc = -1 # Move Left (away from right)\n\n    # Check if exactly centered in one dimension (e.g., r = (h-1)/2)\n    # If centered vertically and only vertical edges are minimal\n    if h > 1 and dist_top == dist_bottom == min_dist and dist_left > min_dist and dist_right > min_dist:\n         dr = -1 # Prioritize Up if centered vertically\n         dc = 0\n    # If centered horizontally and only horizontal edges are minimal\n    elif w > 1 and dist_left == dist_right == min_dist and dist_top > min_dist and dist_bottom > min_dist:\n         dc = -1 # Prioritize Left if centered horizontally\n         dr = 0\n    # If perfectly centered in both dimensions (and grid > 1x1)\n    elif h > 1 and w > 1 and dist_top == dist_bottom == dist_left == dist_right == min_dist:\n         dr, dc = -1, -1 # Prioritize Up-Left if perfectly centered\n\n    # Ensure direction is non-zero if grid > 1x1 (should be covered above, but as fallback)\n    if dr == 0 and dc == 0 and (h > 1 or w > 1):\n        # Default: move away from top-left corner\n        if dist_top <= dist_bottom: dr = 1\n        else: dr = -1\n        if dist_left <= dist_right: dc = 1\n        else: dc = -1\n\n    return dr, dc\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the described transformation to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Initialize grid using numpy for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    h, w = grid.shape\n\n    # --- Step 1-3: Identify agent and obstacles using refined rules ---\n    agent_info, obstacles = identify_agent_and_obstacles_refined(grid)\n\n    # If no agent identified, return the original grid\n    if agent_info is None:\n        return input_grid # Return as list of lists\n\n    agent_r, agent_c, agent_color = agent_info\n\n    # --- Step 4: Get obstacle information and classify structure ---\n    obstacle_rows, obstacle_cols = get_obstacle_info(obstacles)\n    structure = classify_obstacle_structure(obstacles)\n\n    # --- Step 5: Determine drawing direction ---\n    dr, dc = determine_direction((agent_r, agent_c), (h, w))\n\n    # If direction is (0,0) (e.g., 1x1 grid), no drawing needed\n    if dr == 0 and dc == 0:\n        return output_grid.tolist() # Return current grid as list of lists\n\n    # --- Step 6 & 7: Draw line with appropriate stopping condition ---\n    curr_r, curr_c = agent_r, agent_c\n\n    while True:\n        # Calculate the *next* potential position\n        next_r, next_c = curr_r + dr, curr_c + dc\n\n        # Check if next position is within grid bounds\n        if not (0 <= next_r < h and 0 <= next_c < w):\n            break # Stop drawing if out of bounds\n\n        # Check stopping conditions based on obstacle structure\n        stop_drawing_after_color = False\n        stop_drawing_before_color = False\n\n        if structure == 'solid_line':\n            # Stop *before* drawing on the obstacle row/column\n            if next_r in obstacle_rows or next_c in obstacle_cols:\n                 stop_drawing_before_color = True\n\n            if stop_drawing_before_color:\n                break # Break before coloring next_r, next_c\n\n        elif structure == 'scattered':\n            # Stop *after* drawing on the first row/column that contains an obstacle\n            if next_r in obstacle_rows or next_c in obstacle_cols:\n                stop_drawing_after_color = True\n                # Action: Color this pixel, then stop.\n\n        # Color the next pixel (unless stopping before coloring)\n        output_grid[next_r, next_c] = agent_color\n\n        # If we determined to stop *after* coloring (scattered case hit), exit loop now\n        if stop_drawing_after_color:\n            break\n\n        # Update current position for the next iteration\n        curr_r, curr_c = next_r, next_c\n\n    # --- Step 8: Return the modified grid ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16495,
    "candidates_token_count": 5470,
    "total_token_count": 21965,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 36.856525,
  "retries": 1
}