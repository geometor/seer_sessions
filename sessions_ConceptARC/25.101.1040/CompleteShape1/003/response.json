{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom copy import deepcopy\n\n\"\"\"\nThe transformation rule identifies maximal contiguous rectangular areas of white pixels (color 0). \nFor each such white rectangle 'W':\n1. It checks for a 'Vertical Bridge Below': Is there a monochromatic, non-white horizontal segment 'S' directly below W (sharing the same columns)? Is the entire rectangular space between W and S composed only of white pixels? If yes, W is filled with the color of S.\n2. If the vertical check doesn't apply, it checks for a 'Horizontal Bridge': Are there monochromatic, non-white vertical segments 'SL' and 'SR' immediately to the left and right of W, respectively (sharing the same rows)? Do SL and SR have the *same* color? If yes, W is filled with that color.\nThe vertical check takes priority. Only one fill operation is applied per white rectangle.\n\"\"\"\n\ndef find_maximal_white_rectangles(grid: np.ndarray) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of white pixels (0).\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples, where each tuple represents a rectangle\n        as (r1, c1, r2, c2) (top-left and bottom-right coordinates, inclusive).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 0 and not visited[r, c]:\n                start_r, start_c = r, c\n                \n                # Find max width\n                max_width = 0\n                while start_c + max_width < cols and grid[start_r, start_c + max_width] == 0 and not visited[start_r, start_c + max_width]:\n                    max_width += 1\n                \n                if max_width == 0: continue\n\n                # Find max height for this width\n                max_height = 0\n                possible_height = True\n                while start_r + max_height < rows and possible_height:\n                    # Check if the entire row segment is white and unvisited\n                    for w_offset in range(max_width):\n                        if grid[start_r + max_height, start_c + w_offset] != 0 or visited[start_r + max_height, start_c + w_offset]:\n                            possible_height = False\n                            break\n                    if possible_height:\n                        max_height += 1\n                    else:\n                        break \n\n                # Record rectangle and mark visited\n                if max_height > 0 and max_width > 0:\n                    r1, c1 = start_r, start_c\n                    r2, c2 = start_r + max_height - 1, start_c + max_width - 1\n                    rectangles.append((r1, c1, r2, c2))\n                    visited[r1:r2+1, c1:c2+1] = True\n    return rectangles\n\ndef is_monochromatic_non_white(segment: np.ndarray) -> tuple[bool, int]:\n    \"\"\"Checks if a segment is monochromatic and not white (0).\"\"\"\n    if segment.size == 0:\n        return False, -1\n    first_color = segment.flat[0]\n    if first_color == 0:\n        return False, 0\n    if np.all(segment == first_color):\n        return True, first_color\n    return False, -1\n\ndef is_all_white(segment: np.ndarray) -> bool:\n    \"\"\"Checks if a segment contains only white pixels (0).\"\"\"\n    if segment.size == 0: # An empty gap is considered \"all white\"\n        return True\n    return np.all(segment == 0)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to fill specific white rectangles\n    based on vertical or horizontal bridging patterns.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Find all potential white rectangles to fill\n    white_rectangles = find_maximal_white_rectangles(grid)\n\n    # Process each white rectangle\n    for r1, c1, r2, c2 in white_rectangles:\n        filled = False # Flag to track if this rectangle was filled\n\n        # --- 1. Vertical Bridging Check (Below) ---\n        r_below = r2 + 1\n        \n        # Search for the first non-white row below the rectangle within its columns\n        first_non_white_row_idx = -1\n        for r_scan in range(r_below, rows):\n            if np.any(grid[r_scan, c1 : c2 + 1] != 0):\n                first_non_white_row_idx = r_scan\n                break\n        \n        if first_non_white_row_idx != -1:\n            # Check if the segment in that first non-white row is monochromatic non-white\n            segment_below = grid[first_non_white_row_idx, c1 : c2 + 1]\n            is_mono, fill_color = is_monochromatic_non_white(segment_below)\n\n            if is_mono:\n                # Check if the gap between the rectangle and the segment is all white\n                gap_segment = grid[r_below : first_non_white_row_idx, c1 : c2 + 1]\n                if is_all_white(gap_segment):\n                    # Conditions met: Fill the rectangle\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True\n\n        # --- 2. Horizontal Bridging Check (Left and Right) ---\n        if not filled:\n            # Check conditions for potential left and right segments\n            has_left = c1 > 0\n            has_right = c2 < cols - 1\n\n            if has_left and has_right:\n                segment_left = grid[r1 : r2 + 1, c1 - 1]\n                segment_right = grid[r1 : r2 + 1, c2 + 1]\n\n                is_mono_left, color_left = is_monochromatic_non_white(segment_left)\n                is_mono_right, color_right = is_monochromatic_non_white(segment_right)\n\n                # Check if both sides are monochromatic, non-white, and the *same* color\n                if is_mono_left and is_mono_right and color_left == color_right:\n                    # Conditions met: Fill the rectangle\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = color_left\n                    # No need to set 'filled = True' as it's the last check for this rectangle\n\n    # Convert back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13447,
    "candidates_token_count": 3118,
    "total_token_count": 16565,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 24.465644,
  "retries": 1
}