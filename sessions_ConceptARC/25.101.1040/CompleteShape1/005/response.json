{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom copy import deepcopy\n\n\"\"\"\nThe transformation rule identifies maximal contiguous rectangular areas of white pixels (color 0). \nFor each such white rectangle 'W' that meets a size constraint (height <= 2 or width <= 2):\n1. It checks for a 'Vertical Bridge Below': Is there a monochromatic, non-white horizontal segment 'S' below W (sharing the same columns)? Is the entire rectangular space between W and S composed only of white pixels? If yes, W is filled with the color of S.\n2. If the vertical check doesn't apply, it checks for 'Horizontal Extension Left': Is there a monochromatic, non-white vertical segment 'SL' immediately to the left of W (sharing the same rows)? If yes, W is filled with the color of SL.\n3. If neither of the above applies, it checks for 'Horizontal Extension Right': Is there a monochromatic, non-white vertical segment 'SR' immediately to the right of W (sharing the same rows)? If yes, W is filled with the color of SR.\nThe checks are performed in this order (Vertical Below > Horizontal Left > Horizontal Right). Only the first rule that applies results in a fill for a given white rectangle.\n\"\"\"\n\ndef find_maximal_white_rectangles(grid: np.ndarray) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of white pixels (0).\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples, where each tuple represents a rectangle\n        as (r1, c1, r2, c2) (top-left and bottom-right coordinates, inclusive).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 0 and not visited[r, c]:\n                start_r, start_c = r, c\n                \n                # Find max width greedy\n                max_width = 0\n                while start_c + max_width < cols and grid[start_r, start_c + max_width] == 0 and not visited[start_r, start_c + max_width]:\n                    max_width += 1\n                \n                if max_width == 0: continue # Should not happen\n\n                # Find max height for this width greedy\n                max_height = 0\n                possible_height = True\n                while start_r + max_height < rows and possible_height:\n                    # Check if the entire row segment is white and unvisited\n                    all_white_and_unvisited = True\n                    for w_offset in range(max_width):\n                        if grid[start_r + max_height, start_c + w_offset] != 0 or visited[start_r + max_height, start_c + w_offset]:\n                            all_white_and_unvisited = False\n                            break\n                    \n                    if all_white_and_unvisited:\n                         # If row is valid, mark it as visited temporarily for width calculation\n                         # for the *next* row, preventing overlapping starts from splitting rects\n                         # Mark only if we extend height\n                         if max_height > 0: \n                            for w_offset in range(max_width):\n                                visited[start_r + max_height -1, start_c + w_offset] = True\n                         max_height += 1\n                    else:\n                        possible_height = False # Stop extending height\n\n                # Finalize rectangle coordinates and mark fully visited\n                if max_height > 0 and max_width > 0:\n                    r1, c1 = start_r, start_c\n                    r2, c2 = start_r + max_height - 1, start_c + max_width - 1\n                    rectangles.append((r1, c1, r2, c2))\n                    # Ensure all pixels in the final maximal rectangle are marked visited\n                    visited[r1:r2+1, c1:c2+1] = True\n    return rectangles\n\ndef is_monochromatic_non_white(segment: np.ndarray) -> tuple[bool, int]:\n    \"\"\"Checks if a segment is monochromatic and not white (0).\"\"\"\n    if segment.size == 0:\n        return False, -1 # Not monochromatic if empty\n    first_color = segment.flat[0]\n    if first_color == 0:\n        return False, 0 # White\n    if np.all(segment == first_color):\n        return True, int(first_color) # Use int() to ensure standard python int\n    return False, -1 # Not monochromatic\n\ndef is_all_white(segment: np.ndarray) -> bool:\n    \"\"\"Checks if a segment contains only white pixels (0).\"\"\"\n    if segment.size == 0: # An empty gap is considered \"all white\"\n        return True\n    return np.all(segment == 0)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to fill specific white rectangles\n    based on vertical or horizontal bridging/extension patterns.\n    \"\"\"\n    # Convert to numpy array for easier slicing and operations\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Find all maximal white rectangles\n    white_rectangles = find_maximal_white_rectangles(grid)\n\n    # Process each white rectangle\n    for r1, c1, r2, c2 in white_rectangles:\n        filled = False # Flag to track if this rectangle was filled\n        \n        # Calculate height and width\n        rect_h = r2 - r1 + 1\n        rect_w = c2 - c1 + 1\n\n        # 4. Apply Size Constraint Check\n        if rect_h > 2 and rect_w > 2:\n            continue # Skip large rectangles\n\n        # --- 5. Vertical Bridge Below Check ---\n        # Find the first row below the rectangle that contains a non-white pixel in the rectangle's columns\n        first_non_white_row_idx = -1\n        for r_scan in range(r2 + 1, rows):\n            segment_in_row = grid[r_scan, c1 : c2 + 1]\n            if np.any(segment_in_row != 0):\n                first_non_white_row_idx = r_scan\n                break\n        \n        # If such a row was found within bounds\n        if first_non_white_row_idx != -1:\n            # Check if the segment in that row is monochromatic non-white\n            segment_below = grid[first_non_white_row_idx, c1 : c2 + 1]\n            is_mono, fill_color = is_monochromatic_non_white(segment_below)\n\n            if is_mono:\n                # Check if the gap between the rectangle and the segment is all white\n                gap_segment = grid[r2 + 1 : first_non_white_row_idx, c1 : c2 + 1]\n                if is_all_white(gap_segment):\n                    # Conditions met: Fill the rectangle in the output grid\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True\n\n        # --- 6. Horizontal Extension Left Check ---\n        if not filled:\n            # Check if there's a column to the left\n            if c1 > 0:\n                # Extract the segment immediately to the left\n                segment_left = grid[r1 : r2 + 1, c1 - 1]\n                # Check if it's monochromatic and non-white\n                is_mono, fill_color = is_monochromatic_non_white(segment_left)\n                \n                if is_mono:\n                    # Conditions met: Fill the rectangle\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True\n\n        # --- 7. Horizontal Extension Right Check ---\n        if not filled:\n             # Check if there's a column to the right\n             if c2 < cols - 1:\n                # Extract the segment immediately to the right\n                segment_right = grid[r1 : r2 + 1, c2 + 1]\n                 # Check if it's monochromatic and non-white\n                is_mono, fill_color = is_monochromatic_non_white(segment_right)\n\n                if is_mono:\n                    # Conditions met: Fill the rectangle\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True # Not strictly needed as it's the last check, but good practice\n\n    # Convert the result back to a list of lists for the final output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23293,
    "candidates_token_count": 2321,
    "total_token_count": 25614,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 16.229937,
  "retries": 1
}