{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom copy import deepcopy\n\n\"\"\"\nThe transformation rule identifies maximal contiguous rectangular areas 'W' composed entirely of white pixels (color 0).\nFor each identified white rectangle W:\n1. A size constraint is applied: If the height H > 2 AND width W > 2, the rectangle is skipped.\n2. If the size constraint is met, a 'Vertical Bridge Below' check is performed:\n   a. Search downwards from W's bottom edge (within W's columns) for the first row 'r_below' containing a non-white pixel.\n   b. If found, check if the segment 'S_below' at r_below (within W's columns) is monochromatic non-white (color C).\n   c. Check if the rectangular gap 'G' between W and S_below is entirely white.\n   d. If all conditions are met, fill W in the output grid with color C.\n3. If the Vertical Bridge check did not result in a fill, a 'Horizontal Extension Left' check is performed:\n   a. Check if a column exists immediately left of W.\n   b. Check if the vertical segment 'S_left' adjacent to W's left edge is monochromatic non-white (color C).\n   c. If yes, fill W in the output grid with color C.\n4. If neither of the above checks resulted in a fill, a 'Horizontal Extension Right' check is performed:\n   a. Check if a column exists immediately right of W.\n   b. Check if the vertical segment 'S_right' adjacent to W's right edge is monochromatic non-white (color C).\n   c. If yes, fill W in the output grid with color C.\nThe checks are prioritized: Vertical Below > Horizontal Left > Horizontal Right. Only the first matching rule triggers a fill for a given rectangle W.\n\"\"\"\n\ndef find_maximal_white_rectangles(grid: np.ndarray) -> list[tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all maximal contiguous rectangular areas of white pixels (0).\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples, where each tuple represents a rectangle\n        as (r1, c1, r2, c2) (top-left and bottom-right coordinates, inclusive).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    rectangles = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start search if pixel is white and not already part of a found rectangle\n            if grid[r, c] == 0 and not visited[r, c]:\n                start_r, start_c = r, c\n                \n                # Find max width starting from (r, c) in the current row\n                current_width = 0\n                while start_c + current_width < cols and \\\n                      grid[start_r, start_c + current_width] == 0 and \\\n                      not visited[start_r, start_c + current_width]:\n                    current_width += 1\n                \n                if current_width == 0: continue # Should not happen based on initial check\n\n                # Find max height for this width, ensuring all rows are contiguous white rectangles\n                current_height = 0\n                possible_height = True\n                while start_r + current_height < rows and possible_height:\n                    # Check if the entire segment in this row matches the width and is white/unvisited\n                    all_white_and_unvisited = True\n                    for w_offset in range(current_width):\n                        if start_c + w_offset >= cols or \\\n                           grid[start_r + current_height, start_c + w_offset] != 0 or \\\n                           visited[start_r + current_height, start_c + w_offset]:\n                            all_white_and_unvisited = False\n                            break\n                    \n                    if all_white_and_unvisited:\n                        current_height += 1\n                    else:\n                        possible_height = False # Stop extending height\n\n                # If a valid rectangle is found, store it and mark visited\n                if current_height > 0 and current_width > 0:\n                    r1, c1 = start_r, start_c\n                    r2, c2 = start_r + current_height - 1, start_c + current_width - 1\n                    rectangles.append((r1, c1, r2, c2))\n                    # Mark pixels within this maximal rectangle as visited\n                    visited[r1:r2+1, c1:c2+1] = True\n    return rectangles\n\ndef is_monochromatic_non_white(segment: np.ndarray) -> tuple[bool, int]:\n    \"\"\"\n    Checks if a numpy array segment is monochromatic (all same color) and not white (0).\n\n    Args:\n        segment: The numpy array segment to check.\n\n    Returns:\n        A tuple (is_mono_non_white, color).\n        is_mono_non_white is True if the conditions are met, False otherwise.\n        color is the monochromatic color if conditions are met, otherwise -1 (or 0 if white).\n    \"\"\"\n    if segment.size == 0:\n        return False, -1 # Cannot be monochromatic if empty\n    first_color = segment.flat[0]\n    if first_color == 0:\n        return False, 0 # It's white\n    if np.all(segment == first_color):\n        return True, int(first_color) # Monochromatic and non-white\n    return False, -1 # Not monochromatic\n\ndef is_all_white(segment: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a numpy array segment contains only white pixels (0).\n\n    Args:\n        segment: The numpy array segment to check.\n\n    Returns:\n        True if all pixels are 0, False otherwise. An empty segment is considered all white.\n    \"\"\"\n    if segment.size == 0: \n        return True # An empty gap between W and S is valid\n    return np.all(segment == 0)\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    # Convert input to numpy array for efficient operations\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Find all maximal white rectangles\n    white_rectangles = find_maximal_white_rectangles(grid)\n\n    # Iterate through each found white rectangle W\n    for r1, c1, r2, c2 in white_rectangles:\n        filled = False # Flag to track if this rectangle has been filled by a rule\n\n        # Calculate height (H) and width (W)\n        rect_h = r2 - r1 + 1\n        rect_w = c2 - c1 + 1\n\n        # 1. Apply Size Constraint Filter\n        if rect_h > 2 and rect_w > 2:\n            continue # Skip this rectangle if it's too large in both dimensions\n\n        # 2. Perform Vertical Bridge Below Check\n        # Search for the first row below W containing a non-white pixel within W's columns\n        first_non_white_row_idx = -1\n        for r_scan in range(r2 + 1, rows):\n            segment_in_row = grid[r_scan, c1 : c2 + 1]\n            if np.any(segment_in_row != 0):\n                first_non_white_row_idx = r_scan\n                break\n        \n        # If such a row was found within grid bounds\n        if first_non_white_row_idx != -1:\n            # Extract the segment S_below in that row\n            segment_below = grid[first_non_white_row_idx, c1 : c2 + 1]\n            # Check if S_below is monochromatic non-white\n            is_mono, fill_color = is_monochromatic_non_white(segment_below)\n\n            if is_mono:\n                # Extract the gap region G between W and S_below\n                gap_segment = grid[r2 + 1 : first_non_white_row_idx, c1 : c2 + 1]\n                # Check if the gap G is entirely white\n                if is_all_white(gap_segment):\n                    # All conditions met: Fill W in the output grid\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True # Mark as filled\n\n        # 3. Perform Horizontal Extension Left Check (only if not filled yet)\n        if not filled:\n            # Check if a column exists to the left\n            if c1 > 0:\n                # Extract the vertical segment S_left immediately to the left of W\n                segment_left = grid[r1 : r2 + 1, c1 - 1]\n                # Check if S_left is monochromatic non-white\n                is_mono, fill_color = is_monochromatic_non_white(segment_left)\n                \n                if is_mono:\n                    # Conditions met: Fill W in the output grid\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    filled = True # Mark as filled\n\n        # 4. Perform Horizontal Extension Right Check (only if not filled yet)\n        if not filled:\n             # Check if a column exists to the right\n             if c2 < cols - 1:\n                # Extract the vertical segment S_right immediately to the right of W\n                segment_right = grid[r1 : r2 + 1, c2 + 1]\n                # Check if S_right is monochromatic non-white\n                is_mono, fill_color = is_monochromatic_non_white(segment_right)\n\n                if is_mono:\n                    # Conditions met: Fill W in the output grid\n                    output_grid[r1 : r2 + 1, c1 : c2 + 1] = fill_color\n                    # No need to set filled=True as it's the last check\n\n    # Convert the final output grid back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 32920,
    "candidates_token_count": 2982,
    "total_token_count": 35902,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.064038,
  "retries": 1
}