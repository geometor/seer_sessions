{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule identifies maximal contiguous rectangular areas of white pixels (color 0) within the input grid.\nFor each such white rectangle, it attempts to determine a fill color based on adjacent or aligned non-white monochromatic shapes, following specific priority rules:\n\n1.  **Vertical Completion Below:** It checks if there is a non-white monochromatic shape S located directly below the white rectangle W, perfectly aligned horizontally (sharing the same columns), and separated from W only by other white pixels. If such a shape S exists, the white rectangle W is filled with the color of S.\n2.  **Horizontal Completion Left:** If the vertical check does not result in a fill, it checks if there is a non-white monochromatic shape S located immediately to the left of the white rectangle W, perfectly aligned vertically (sharing the same rows). If such a shape S exists, the white rectangle W is filled with the color of S.\n\nIf a fill occurs based on rule 1, rule 2 is not checked for that white rectangle. The process is repeated for all identified maximal white rectangles. The output grid reflects these fill operations.\n\"\"\"\n\nimport numpy as np\nfrom copy import deepcopy\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to fill specific white rectangles.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # Keep track of white pixels already part of a processed maximal rectangle\n    visited = np.zeros((rows, cols), dtype=bool)\n    rectangles_to_process = []\n\n    # Find all maximal white rectangles (color 0)\n    for r in range(rows):\n        for c in range(cols):\n            # Start search if pixel is white and not visited\n            if grid[r, c] == 0 and not visited[r, c]:\n                start_r, start_c = r, c\n                \n                # Find the maximum width of white pixels starting at (start_r, start_c)\n                current_width = 0\n                while start_c + current_width < cols and grid[start_r, start_c + current_width] == 0 and not visited[start_r, start_c + current_width]:\n                    current_width += 1\n                \n                if current_width == 0: continue # Should not happen based on initial check, but safety\n\n                # Find the maximum height for this width, ensuring all cells are white & unvisited\n                current_height = 0\n                possible_height = True\n                while start_r + current_height < rows and possible_height:\n                    # Check if the entire segment in this row is white and unvisited\n                    for w_offset in range(current_width):\n                        if grid[start_r + current_height, start_c + w_offset] != 0 or visited[start_r + current_height, start_c + w_offset]:\n                            possible_height = False\n                            break\n                    if possible_height:\n                        current_height += 1\n                    else:\n                        break # Height expansion stopped\n\n                # If a valid rectangle is found, store it and mark visited\n                if current_height > 0 and current_width > 0:\n                    r1, c1 = start_r, start_c\n                    r2, c2 = start_r + current_height - 1, start_c + current_width - 1\n                    rectangles_to_process.append((r1, c1, r2, c2)) \n\n                    # Mark pixels within this maximal rectangle as visited\n                    for i in range(r1, r2 + 1):\n                        for j in range(c1, c2 + 1):\n                            visited[i, j] = True\n\n    # Process each found white rectangle according to the rules\n    for r1, c1, r2, c2 in rectangles_to_process:\n        filled = False # Flag to track if this rectangle has been filled\n\n        # Rule 1: Check for Vertical Completion Below\n        \n        # Find the first row below the rectangle (r2 + 1)\n        shape_start_r = r2 + 1\n        \n        # Check if this row is within grid bounds\n        if shape_start_r < rows:\n            # Check if the space between W and the potential shape S is purely white\n            is_gap_white = True\n            # Note: For this rule, the gap *must* start at r2+1. We check if the row shape_start_r\n            # is the *first* non-white row below W aligned with its columns.\n            # A more rigorous check would trace the gap row by row, but let's check shape_start_r first.\n            \n            # Check if the segment in shape_start_r aligned with W is monochromatic and non-white\n            potential_color = grid[shape_start_r, c1]\n            is_segment_mono = False\n            if potential_color != 0: # Must be non-white\n                 if np.all(grid[shape_start_r, c1 : c2 + 1] == potential_color):\n                     is_segment_mono = True\n\n            if is_segment_mono:\n                 # Now verify the gap between W (ending at r2) and S (starting at shape_start_r) is white\n                 gap_is_truly_white = True\n                 for gap_r in range(r2 + 1, shape_start_r):\n                      if not np.all(grid[gap_r, c1 : c2 + 1] == 0):\n                           gap_is_truly_white = False\n                           break\n                 \n                 if gap_is_truly_white:\n                      # All conditions met for Rule 1\n                      fill_color = potential_color\n                      output_grid[r1:r2+1, c1:c2+1] = fill_color\n                      filled = True\n\n\n        # Rule 2: Check for Horizontal Completion Left (only if not filled by Rule 1)\n        if not filled:\n            # Check if column c1-1 exists (i.e., c1 > 0)\n            if c1 > 0:\n                # Check if the column segment adjacent left is monochromatic and non-white\n                adj_col_segment = grid[r1:r2+1, c1-1]\n                potential_color = adj_col_segment[0]\n\n                if potential_color != 0: # Must be non-white\n                    if np.all(adj_col_segment == potential_color):\n                        # All conditions met for Rule 2 (adjacency is implicit)\n                        fill_color = potential_color\n                        output_grid[r1:r2+1, c1:c2+1] = fill_color\n                        filled = True # Mark filled, though loop for this rect ends here\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3309,
    "candidates_token_count": 6120,
    "total_token_count": 9429,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 50.670795,
  "retries": 1
}