{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies objects in the grid based on color contiguity.\nDetermines a \"Frame\" object, often U-shaped or partially enclosing others, potentially by identifying the non-background object whose bounding box touches the most grid edges.\nIdentifies \"Inner\" objects adjacent to the Frame.\nApplies a transformation based on the color of the Inner objects:\n1. If any Inner object has the color Green (3), adjacent pixels of the Frame object change their color to Green (3).\n2. If no Inner object is Green (3), adjacent pixels of the Inner objects change their color to match the Frame object's color.\nThe background color is assumed to be White (0). Adjacency is defined by 4-connectivity (sharing a side).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'coords' (set of tuples (r, c)).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0 # Assuming white is background\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and not visited[r, c]:\n                # Start BFS to find the extent of this object\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n                \n                objects.append({'color': color, 'coords': obj_coords})\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\" Calculates min/max row/col from a set of coordinates \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef count_touching_edges(bbox, grid_height, grid_width):\n    \"\"\" Counts how many grid edges the bbox touches \"\"\"\n    if bbox is None:\n        return 0\n    min_r, min_c, max_r, max_c = bbox\n    count = 0\n    if min_r == 0: count += 1\n    if max_r == grid_height - 1: count += 1\n    if min_c == 0: count += 1\n    if max_c == grid_width - 1: count += 1\n    return count\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on object adjacency and color rules.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n    green_color = 3\n\n    # 1. Find all non-background objects\n    objects = find_objects(input_np)\n    if not objects:\n        return output_grid.tolist() # No objects to transform\n\n    # 2. Identify Frame and Inner objects\n    frame_object = None\n    inner_objects = []\n    \n    # Heuristic: Frame is the object touching the most grid edges\n    max_edges = -1\n    for obj in objects:\n        bbox = get_bounding_box(obj['coords'])\n        edges = count_touching_edges(bbox, height, width)\n        if edges > max_edges:\n            max_edges = edges\n            frame_object = obj\n        elif edges == max_edges:\n             # Ambiguity: If multiple objects touch the same max number of edges,\n             # this heuristic might fail. We might need a tie-breaker (e.g., largest area?).\n             # For now, arbitrarily pick the first one found with max edges.\n             # A more robust solution might be needed if tie-breaking is important.\n             pass \n\n    if frame_object is None:\n        # Fallback or error handling if no clear frame is found\n        # For now, assume the largest object if edge heuristic fails?\n        if objects:\n           frame_object = max(objects, key=lambda o: len(o['coords']))\n        else: # Should not happen if objects is not empty, but defensive check\n           return output_grid.tolist()\n\n\n    frame_color = frame_object['color']\n    frame_coords = frame_object['coords']\n    inner_colors = set()\n    inner_coords_map = {} # Map color to set of coordinates\n\n    for obj in objects:\n        if obj != frame_object:\n            inner_objects.append(obj)\n            inner_colors.add(obj['color'])\n            if obj['color'] not in inner_coords_map:\n                inner_coords_map[obj['color']] = set()\n            inner_coords_map[obj['color']].update(obj['coords'])\n\n    # 3. Check if Green (3) is among inner colors\n    green_is_inner = green_color in inner_colors\n\n    # 4. Apply transformation rule\n    if green_is_inner:\n        # Rule 1: Change adjacent Frame pixels to Green\n        for r, c in frame_coords:\n            # Check 4 neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Check if neighbor is within grid bounds and is Green\n                if 0 <= nr < height and 0 <= nc < width and input_np[nr, nc] == green_color:\n                    # Check if the green neighbor belongs to an *inner* object\n                    # (This check prevents green frame pixels changing adjacent frame pixels)\n                    if (nr, nc) in inner_coords_map.get(green_color, set()):\n                       output_grid[r, c] = green_color\n                       break # Change the frame pixel and move to the next frame pixel\n    \n    else:\n        # Rule 2: Change adjacent Inner pixels to Frame color\n        for inner_obj in inner_objects:\n            inner_color = inner_obj['color']\n            for r, c in inner_obj['coords']:\n                 # Check 4 neighbors\n                 for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                     nr, nc = r + dr, c + dc\n                     # Check if neighbor is within grid bounds and is the Frame color\n                     if 0 <= nr < height and 0 <= nc < width and input_np[nr, nc] == frame_color:\n                        # Check if the frame-colored neighbor actually belongs to the identified frame object\n                         if (nr, nc) in frame_coords:\n                            output_grid[r, c] = frame_color\n                            break # Change the inner pixel and move to the next inner pixel\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2996,
    "candidates_token_count": 1843,
    "total_token_count": 4839,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.722615,
  "retries": 1
}