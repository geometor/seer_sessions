{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the largest contiguous object (non-background color 0) in the input grid based on pixel count.\nIterate through all pixels in the input grid.\nIf a pixel is not part of the largest object and not the background color:\n  Check its 8 neighbors (horizontal, vertical, diagonal) in the original input grid.\n  If any neighbor belongs to the largest object, change the pixel's color in the output grid to the largest object's color.\n  If no neighbor belongs to the largest object, change the pixel's color in the output grid to the background color (0).\nPixels belonging to the largest object or the background remain unchanged initially.\n\"\"\"\n\ndef _get_neighbors(r, c, height, width):\n    \"\"\" Helper function to get valid 8-directional neighbors for a cell \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects(grid, background_color=0):\n    \"\"\" Finds all contiguous objects of the same color, ignoring background \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = [] # List to store tuples: (color, set_of_coordinates)\n\n    for r in range(height):\n        for c in range(width):\n            if (r, c) in visited or grid[r, c] == background_color:\n                continue\n\n            color = grid[r, c]\n            current_object_coords = set()\n            q = deque([(r, c)])\n            visited.add((r, c))\n            \n            while q:\n                row, col = q.popleft()\n                current_object_coords.add((row, col))\n\n                # Use 4-connectivity for defining an object itself\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                # Use 8-connectivity if required by task definition - let's re-read\n                # The description implies objects are contiguous blocks. Usually means 4-connectivity.\n                # But the adjacency rule uses 8. Let's stick to 4 for object definition unless examples contradict.\n                # Example 1: Red object is clearly 4-connected.\n                # Example 2: Green object is 4-connected. Okay, 4-connectivity for object definition.\n                \n                # Corrected loop for neighbors (4-connectivity for object finding)\n                #for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                # Let's use 8-connectivity for finding objects too, based on the YAML definition mentioning diagonal adjacency.\n                # This might matter if an object looks like a checkerboard.\n                 for dr in [-1, 0, 1]:\n                     for dc in [-1, 0, 1]:\n                         if dr == 0 and dc == 0:\n                             continue\n                         nr, nc = row + dr, col + dc\n\n                         if 0 <= nr < height and 0 <= nc < width and \\\n                            (nr, nc) not in visited and \\\n                            grid[nr, nc] == color:\n                             visited.add((nr, nc))\n                             q.append((nr, nc))\n\n            if current_object_coords:\n                objects.append((color, current_object_coords))\n                \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on adjacency to the largest object.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    background_color = 0\n\n    # Find all non-background objects\n    objects = _find_objects(input_grid_np, background_color)\n\n    # If there are no objects, return the original grid\n    if not objects:\n        return input_grid\n\n    # Find the largest object\n    largest_object = max(objects, key=lambda obj: len(obj[1]))\n    largest_color = largest_object[0]\n    largest_coords_set = largest_object[1]\n\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid_np)\n\n    # Iterate through each pixel of the input grid\n    for r in range(height):\n        for c in range(width):\n            current_color = input_grid_np[r, c]\n            current_pos = (r, c)\n\n            # Check if the pixel is NOT background and NOT part of the largest object\n            if current_color != background_color and current_pos not in largest_coords_set:\n                is_adjacent_to_largest = False\n                # Check 8 neighbors in the *original* input grid\n                for nr, nc in _get_neighbors(r, c, height, width):\n                    if (nr, nc) in largest_coords_set:\n                        is_adjacent_to_largest = True\n                        break \n                \n                # Apply transformation rule\n                if is_adjacent_to_largest:\n                    output_grid[r, c] = largest_color # Absorb color\n                else:\n                    output_grid[r, c] = background_color # Erase\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2764,
    "candidates_token_count": 1303,
    "total_token_count": 4067,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.035121,
  "retries": 1
}