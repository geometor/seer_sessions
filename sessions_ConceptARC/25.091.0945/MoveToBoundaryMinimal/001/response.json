{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a boundary line (horizontal or vertical) and a single 'mover' pixel of a different color.\nMoves the 'mover' pixel in a straight line (horizontally or vertically) towards the boundary line.\nThe movement stops when the 'mover' pixel reaches the cell immediately adjacent to the boundary line along its path.\nThe original position of the mover pixel becomes background (white, 0).\nAll other pixels remain unchanged.\n\"\"\"\n\ndef find_boundary(grid):\n    \"\"\"\n    Finds a solid horizontal or vertical line of a single non-white color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (orientation, index, color)\n               orientation (str): 'horizontal' or 'vertical'.\n               index (int): Row index if horizontal, column index if vertical.\n               color (int): The color of the boundary line.\n               Returns (None, -1, -1) if no boundary is found.\n    \"\"\"\n    rows, cols = grid.shape\n\n    # Check for horizontal boundary\n    for r in range(rows):\n        row_colors = np.unique(grid[r, :])\n        non_white_colors = row_colors[row_colors != 0]\n        # Check if the row consists of exactly one non-white color\n        if len(non_white_colors) == 1 and np.all(grid[r, :] == non_white_colors[0]):\n            # Check if it spans the full width (or is at least substantial)\n            # In the examples, they span the full width/height.\n             if np.all(grid[r,:] == non_white_colors[0]): # Full row check\n                 return 'horizontal', r, non_white_colors[0]\n\n\n    # Check for vertical boundary\n    for c in range(cols):\n        col_colors = np.unique(grid[:, c])\n        non_white_colors = col_colors[col_colors != 0]\n         # Check if the col consists of exactly one non-white color\n        if len(non_white_colors) == 1 and np.all(grid[:, c] == non_white_colors[0]):\n             # Check if it spans the full height\n             if np.all(grid[:, c] == non_white_colors[0]): # Full col check\n                 return 'vertical', c, non_white_colors[0]\n\n    return None, -1, -1 # No boundary found\n\ndef find_mover(grid, boundary_color):\n    \"\"\"\n    Finds the single pixel that is not background (0) and not the boundary color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        boundary_color (int): The color of the boundary line.\n\n    Returns:\n        tuple: (position, color)\n               position (tuple): (row, col) of the mover pixel.\n               color (int): The color of the mover pixel.\n               Returns (None, -1) if no mover is found.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = grid[r, c]\n            # Check if the pixel is not background and not the boundary color\n            if pixel_color != 0 and pixel_color != boundary_color:\n                # Assuming there's only one such pixel based on examples\n                return (r, c), pixel_color\n    return None, -1 # No mover found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Moves a single pixel towards a boundary line, stopping one step before it.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n\n    # 1. Identify the boundary object\n    orientation, boundary_index, boundary_color = find_boundary(grid)\n\n    # Handle case where boundary isn't found as expected\n    if orientation is None:\n        print(\"Warning: Boundary not found.\")\n        return input_grid # Return original grid if no boundary\n\n    # 2. Identify the single 'mover' pixel\n    mover_pos, mover_color = find_mover(grid, boundary_color)\n\n    # Handle case where mover isn't found as expected\n    if mover_pos is None:\n        print(\"Warning: Mover pixel not found.\")\n        return input_grid # Return original grid if no mover\n\n    mover_row, mover_col = mover_pos\n\n    # 3. Determine the direction of movement (implicit in target calculation)\n    # 4. Determine the target position\n    target_row, target_col = -1, -1 # Initialize target coordinates\n\n    if orientation == 'vertical':\n        # Move horizontally towards the boundary column\n        target_row = mover_row # Row remains the same\n        # Stop one step before the boundary\n        if mover_col < boundary_index:\n            target_col = boundary_index - 1\n        else: # mover_col > boundary_index (though examples only show left-to-right)\n            target_col = boundary_index + 1\n            \n    elif orientation == 'horizontal':\n        # Move vertically towards the boundary row\n        target_col = mover_col # Column remains the same\n        # Stop one step before the boundary\n        if mover_row < boundary_index: # Mover is above boundary (not in examples)\n             target_row = boundary_index - 1\n        else: # mover_row > boundary_index (as in example 2)\n             target_row = boundary_index + 1\n\n    # Check if target position is valid\n    if 0 <= target_row < rows and 0 <= target_col < cols:\n        # 5. Create the output grid (already done via np.copy)\n        # 6. Set the pixel at the mover's initial position to white (0)\n        output_grid[mover_row, mover_col] = 0\n        # 7. Set the pixel at the calculated target position to the mover's color\n        output_grid[target_row, target_col] = mover_color\n    else:\n        # Handle cases where target is out of bounds (shouldn't happen with current logic/examples)\n        print(f\"Warning: Calculated target position ({target_row}, {target_col}) is out of bounds.\")\n        return input_grid # Return original grid if target is invalid\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2849,
    "candidates_token_count": 1547,
    "total_token_count": 4396,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.503289,
  "retries": 1
}