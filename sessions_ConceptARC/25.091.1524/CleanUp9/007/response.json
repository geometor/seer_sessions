{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following multi-step process:\n1.  Determine the background color (most frequent color).\n2.  Identify the target color (most frequent non-background color). If none exists, return a grid filled with the background color.\n3.  Find all connected components (8-way adjacency) of the target color in the input grid.\n4.  Filter out components consisting of only a single pixel (\"singleton components\"). Collect all pixels belonging to the remaining (\"valid\") components.\n5.  If no valid components remain, return a grid filled with the background color.\n6.  Calculate the bounding box enclosing all pixels from the valid components.\n7.  Create an intermediate grid: fill the bounding box with the target color, and the outside with the background color.\n8.  Modify the intermediate grid: for each pixel within the bounding box, if the corresponding pixel in the *original input grid* was the background color, set the intermediate grid pixel back to the background color (\"background punch-out\").\n9.  Find connected components (8-way) of the target color in this modified intermediate grid.\n10. Create the final output grid by copying the modified intermediate grid. Then, for any target color component found in the *modified intermediate grid* (from step 9) that has a size of exactly 1, change its pixel(s) in the final output grid to the background color.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label\n\n# --- Helper Functions ---\n\ndef find_most_frequent_color(grid_flat):\n    \"\"\"Finds the most frequent color in a flattened grid list.\"\"\"\n    if not grid_flat:\n        return 0 # Default to white/0 if grid is empty\n    counts = Counter(grid_flat)\n    # Check if counts is empty (can happen for single-element grids processed strangely)\n    if not counts:\n         # If grid_flat has elements, return the first, else default to 0\n         return grid_flat[0] if grid_flat else 0\n    most_common = counts.most_common(1)\n    return most_common[0][0]\n\ndef find_target_color(grid_flat, background_color):\n    \"\"\"Finds the most frequent non-background color in a flattened grid list.\"\"\"\n    non_background_colors = [c for c in grid_flat if c != background_color]\n    if not non_background_colors:\n        return None # No target color found\n    counts = Counter(non_background_colors)\n    most_common = counts.most_common(1)\n    return most_common[0][0] if most_common else None\n\ndef get_component_pixels(labeled_array, num_features):\n    \"\"\"Extracts pixel coordinates for each component from a labeled array.\"\"\"\n    # component_pixels maps component label (int > 0) to list of [row, col] coords\n    component_pixels = {}\n    for i in range(1, num_features + 1):\n        coords = np.argwhere(labeled_array == i)\n        component_pixels[i] = coords\n    return component_pixels\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"Applies the complex transformation logic to the input grid.\"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    grid_flat = input_array.flatten().tolist()\n\n    # 1. Determine the background color\n    background_color = find_most_frequent_color(grid_flat)\n\n    # 2. Identify the 'target' color\n    target_color = find_target_color(grid_flat, background_color)\n\n    # Initialize output grid with background color (handles early exit cases)\n    output_array = np.full((rows, cols), background_color, dtype=int)\n\n    # 3. If no target color exists, return the background grid\n    if target_color is None:\n        return output_array.tolist()\n\n    # 4. Locate all pixels matching the target color in input\n    target_mask_input = (input_array == target_color)\n\n    # 5. Group input target pixels into connected components (8-way adjacency)\n    structure = np.ones((3, 3), dtype=bool) # 8-way connectivity\n    labeled_input, num_features_input = label(target_mask_input, structure=structure)\n\n    # 6. Identify all pixels belonging to input components > 1 pixel ('valid target pixels')\n    valid_target_pixels_coords = []\n    component_pixel_map_input = get_component_pixels(labeled_input, num_features_input)\n    for i in range(1, num_features_input + 1):\n        # If component size is greater than 1\n        if len(component_pixel_map_input[i]) > 1:\n            valid_target_pixels_coords.extend(component_pixel_map_input[i]) # Add coords to list\n\n    # 7. If no valid components remain, return the background grid\n    if not valid_target_pixels_coords:\n        return output_array.tolist()\n\n    # 8. Calculate the overall bounding box for the valid pixels\n    valid_target_pixels_coords_array = np.array(valid_target_pixels_coords)\n    min_row = np.min(valid_target_pixels_coords_array[:, 0])\n    max_row = np.max(valid_target_pixels_coords_array[:, 0])\n    min_col = np.min(valid_target_pixels_coords_array[:, 1])\n    max_col = np.max(valid_target_pixels_coords_array[:, 1])\n\n    # 9. Create an intermediate grid: target color in bbox, background outside\n    intermediate_grid = np.full((rows, cols), background_color, dtype=int)\n    intermediate_grid[min_row:max_row+1, min_col:max_col+1] = target_color\n\n    # 10. Apply background punch-out within the bounding box\n    # Iterate only within the bounding box for efficiency\n    for r in range(min_row, max_row + 1):\n        for c in range(min_col, max_col + 1):\n            # If the corresponding pixel in the ORIGINAL input was background...\n            if input_array[r, c] == background_color:\n                # ...set the intermediate grid pixel to background.\n                intermediate_grid[r, c] = background_color\n\n    # 11. Create the final output grid (copy of intermediate for now)\n    output_array = np.copy(intermediate_grid)\n\n    # 12. Find connected components (8-way) of the target color *in the modified intermediate grid*\n    target_mask_intermediate = (intermediate_grid == target_color)\n    labeled_intermediate, num_features_intermediate = label(target_mask_intermediate, structure=structure)\n\n    # 13. Remove singleton components from the final output grid\n    component_pixel_map_intermediate = get_component_pixels(labeled_intermediate, num_features_intermediate)\n    for i in range(1, num_features_intermediate + 1):\n        component_coords = component_pixel_map_intermediate[i]\n        # If this component in the *intermediate* grid is a singleton...\n        if len(component_coords) == 1:\n            # ...change the single pixel of this component to background color in the final output.\n            r, c = component_coords[0]\n            output_array[r, c] = background_color\n\n    # 14. Return the final output grid as a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13983,
    "candidates_token_count": 1778,
    "total_token_count": 15761,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.382235,
  "retries": 1
}