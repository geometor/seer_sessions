{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following multi-step process:\n1.  Determine the background color (most frequent color).\n2.  Identify the target color (most frequent non-background color).\n3.  Find all connected components (8-way adjacency) of the target color in the input.\n4.  Filter out components consisting of only a single pixel.\n5.  If no components remain, the output is filled with the background color.\n6.  Otherwise, calculate the bounding box enclosing all pixels from the remaining (valid) components.\n7.  Create an intermediate grid: fill the bounding box with the target color, and the outside with the background color.\n8.  Modify the intermediate grid: for each pixel within the bounding box, if the corresponding pixel in the *original input grid* was the background color, set the intermediate grid pixel to the background color.\n9.  Find connected components (8-way) of the target color in this modified intermediate grid.\n10. Create the final output grid: copy the modified intermediate grid. Then, for any target color component found in step 9 that has a size of exactly 1, change its pixel(s) in the final output grid to the background color.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nfrom scipy.ndimage import label\n\n# --- Helper Functions ---\n\ndef find_most_frequent_color(grid_flat):\n    \"\"\"Finds the most frequent color in a flattened grid.\"\"\"\n    if not grid_flat:\n        return 0 # Default to white if grid is empty\n    counts = Counter(grid_flat)\n    most_common = counts.most_common(1)\n    # Handle case where grid contains only one color or is empty\n    if not most_common:\n        return grid_flat[0] if grid_flat else 0\n    return most_common[0][0]\n\ndef find_target_color(grid_flat, background_color):\n    \"\"\"Finds the most frequent non-background color.\"\"\"\n    non_background_colors = [c for c in grid_flat if c != background_color]\n    if not non_background_colors:\n        return None # No target color found\n    counts = Counter(non_background_colors)\n    most_common = counts.most_common(1)\n    return most_common[0][0] if most_common else None\n\ndef get_component_pixels(labeled_array, num_features):\n    \"\"\"Extracts pixel coordinates for each component.\"\"\"\n    component_pixels = {}\n    for i in range(1, num_features + 1):\n        coords = np.argwhere(labeled_array == i)\n        component_pixels[i] = coords\n    return component_pixels\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"Applies the complex transformation logic to the input grid.\"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    grid_flat = input_array.flatten().tolist()\n\n    # 1. Determine the background color\n    background_color = find_most_frequent_color(grid_flat)\n\n    # 2. Identify the 'target' color\n    target_color = find_target_color(grid_flat, background_color)\n\n    # Initialize output grid with background color (default if no target)\n    output_array = np.full((rows, cols), background_color, dtype=int)\n\n    # If no target color exists, return the background grid\n    if target_color is None:\n        return output_array.tolist()\n\n    # 3. Locate all pixels matching the target color\n    target_mask = (input_array == target_color)\n\n    # 4. Group target pixels into connected components (8-way adjacency)\n    structure = np.ones((3, 3), dtype=bool) # 8-way connectivity\n    labeled_array, num_features = label(target_mask, structure=structure)\n\n    # 5. Identify all pixels belonging to components > 1 pixel ('valid target pixels')\n    valid_target_pixels_coords = []\n    component_pixel_map = get_component_pixels(labeled_array, num_features)\n    for i in range(1, num_features + 1):\n        if len(component_pixel_map[i]) > 1:\n            valid_target_pixels_coords.extend(component_pixel_map[i])\n\n    # 6. If no components remain, return the background grid\n    if not valid_target_pixels_coords:\n        return output_array.tolist()\n\n    # 7. Calculate the overall bounding box for the valid pixels\n    valid_target_pixels_coords = np.array(valid_target_pixels_coords)\n    min_row = np.min(valid_target_pixels_coords[:, 0])\n    max_row = np.max(valid_target_pixels_coords[:, 0])\n    min_col = np.min(valid_target_pixels_coords[:, 1])\n    max_col = np.max(valid_target_pixels_coords[:, 1])\n\n    # 8. Create an intermediate grid: target color in bbox, background outside\n    intermediate_grid = np.full((rows, cols), background_color, dtype=int)\n    intermediate_grid[min_row:max_row+1, min_col:max_col+1] = target_color\n\n    # 9. Apply background punch-out within the bounding box\n    for r in range(min_row, max_row + 1):\n        for c in range(min_col, max_col + 1):\n            if input_array[r, c] == background_color:\n                intermediate_grid[r, c] = background_color\n\n    # 10. Create the final output grid (copy of intermediate for now)\n    output_array = np.copy(intermediate_grid)\n\n    # 11. Find connected components (8-way) of the target color *in the intermediate grid*\n    target_mask_intermediate = (intermediate_grid == target_color)\n    labeled_intermediate, num_features_intermediate = label(target_mask_intermediate, structure=structure)\n\n    # 12. Remove singleton components from the final output grid\n    component_pixel_map_intermediate = get_component_pixels(labeled_intermediate, num_features_intermediate)\n    for i in range(1, num_features_intermediate + 1):\n        component_coords = component_pixel_map_intermediate[i]\n        if len(component_coords) == 1:\n            # Change the single pixel of this component to background color\n            r, c = component_coords[0]\n            output_array[r, c] = background_color\n\n    # 13. Return the final output grid as a list of lists\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18859,
    "candidates_token_count": 1569,
    "total_token_count": 20428,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.781223,
  "retries": 1
}