{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid by identifying 'noise' pixels and replacing their color based on their neighbors.\n\n1.  **Analyze Color Frequencies:** Count the occurrences of each color (0-9) in the input grid.\n2.  **Identify Noise Colors:** Determine the color(s) that appear least frequently in the grid (must appear at least once). These are designated as \"noise\" colors.\n3.  **Initialize Output Grid:** Create a new grid identical to the input grid. This will be modified to become the output.\n4.  **Iterate and Replace:** Go through each pixel of the input grid, checking its color:\n    *   **If the pixel's color is a noise color:**\n        a.  **Examine Neighbors:** Identify the colors of its cardinal neighbors (pixels directly above, below, left, and right, staying within the grid boundaries).\n        b.  **Filter Neighbors:** Ignore any neighbors whose colors are also noise colors. Consider only the \"non-noise\" neighbors.\n        c.  **Find Majority Neighbor Color:** If there are any non-noise neighbors:\n            i.  Count the occurrences of each color among the non-noise neighbors.\n            ii. Identify the color(s) that appear most frequently.\n            iii. **Resolve Ties:** If only one color is most frequent, select that color. If there's a tie (multiple colors share the highest frequency), select the color with the largest numerical value among the tied colors.\n            iv. **Update Output:** Change the color of the corresponding pixel in the output grid to the selected replacement color.\n        d.  **No Non-Noise Neighbors:** If the noise pixel has no non-noise neighbors, leave its color unchanged in the output grid.\n    *   **If the pixel's color is not a noise color:** Keep its color unchanged in the output grid.\n5.  **Final Output:** The modified grid, after checking and potentially replacing all noise pixels, is the final output.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Replaces the least frequent color(s) in a grid with the most frequent\n    color among their non-noise neighbors.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # Step 1: Analyze Color Frequencies\n    all_pixels = input_array.flatten()\n    color_counts = Counter(all_pixels)\n\n    # Filter out colors that don't appear (count = 0)\n    present_color_counts = {color: count for color, count in color_counts.items() if count > 0}\n\n    # Handle empty grid or grid with only one color type that doesn't need changing\n    if not present_color_counts or len(present_color_counts) == 1:\n        return output_array.tolist() # No noise possible or needed\n\n    # Step 2: Identify Noise Colors\n    min_frequency = min(present_color_counts.values())\n    noise_colors = {color for color, count in present_color_counts.items() if count == min_frequency}\n\n    # Step 3 is implicitly done by creating output_array as a copy initially\n\n    # Step 4: Iterate and Replace\n    for r in range(height):\n        for c in range(width):\n            current_color = input_array[r, c]\n\n            # Check if the current pixel is a noise pixel\n            if current_color in noise_colors:\n                non_noise_neighbor_colors = []\n                # a. Examine Neighbors & b. Filter Neighbors\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < height and 0 <= nc < width:\n                        neighbor_color = input_array[nr, nc]\n                        # Filter out noise colors\n                        if neighbor_color not in noise_colors:\n                            non_noise_neighbor_colors.append(neighbor_color)\n\n                # c. Find Majority Neighbor Color (only if non-noise neighbors exist)\n                if non_noise_neighbor_colors:\n                    neighbor_counts = Counter(non_noise_neighbor_colors)\n                    max_neighbor_freq = 0\n                    # Find the maximum frequency among non-noise neighbors\n                    for count in neighbor_counts.values():\n                         if count > max_neighbor_freq:\n                             max_neighbor_freq = count\n\n                    # Identify all colors with that maximum frequency\n                    most_frequent_neighbors = [\n                        color for color, count in neighbor_counts.items() if count == max_neighbor_freq\n                    ]\n\n                    # iii. Resolve Ties by choosing the largest numerical color value\n                    replacement_color = max(most_frequent_neighbors)\n\n                    # iv. Update Output\n                    output_array[r, c] = replacement_color\n                # d. No Non-Noise Neighbors: Do nothing, color remains as copied initially\n\n            # Else (pixel is not noise): Do nothing, color remains as copied initially\n\n    # Step 5: Final Output\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3115,
    "candidates_token_count": 1187,
    "total_token_count": 4302,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.194089,
  "retries": 1
}