{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\ndef find_topmost_object(grid: np.ndarray) -> tuple[dict[tuple[int, int], int], int]:\n    \"\"\"\n    Finds the topmost non-background object(s) in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - A dictionary mapping coordinates (r, c) of the topmost object pixels \n          to their colors. Returns an empty dict if no non-background pixels exist.\n        - The maximum row index (max_r) occupied by the topmost object. \n          Returns -1 if no object is found.\n    \"\"\"\n    height, width = grid.shape\n    background_color = 0\n    \n    # Find all non-background pixels\n    non_background_coords = list(zip(*np.where(grid != background_color)))\n\n    if not non_background_coords:\n        return {}, -1 # No object found\n\n    # Determine the minimum row index with non-background pixels\n    min_r = min(r for r, c in non_background_coords)\n\n    # Identify all connected non-background pixels forming the topmost object(s) using BFS.\n    # Start BFS from all non-background pixels located at min_r.\n    q = collections.deque([(r, c) for r, c in non_background_coords if r == min_r])\n    visited = set(q)\n    topmost_object_pixels = {} # Store {(r, c): color}\n    max_r = -1\n\n    while q:\n        r, c = q.popleft()\n        \n        # Record the pixel and its color, update max_r\n        color = grid[r, c]\n        # Ensure we are only adding non-background pixels (should be guaranteed by neighbors check, but safe)\n        if color != background_color:\n            topmost_object_pixels[(r, c)] = color\n            max_r = max(max_r, r)\n        else:\n            continue # Should not happen with the check below\n\n        # Explore neighbors (4-connectivity: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check boundaries and if the neighbor is non-background and not visited\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] != background_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n                \n    return topmost_object_pixels, max_r\n\ndef calculate_shift(grid: np.ndarray, max_r: int) -> int:\n    \"\"\"\n    Calculates the downward shift distance based on consecutive all-background \n    rows below the object's maximum row extent.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        max_r: The maximum row index occupied by the object.\n\n    Returns:\n        The calculated downward shift distance.\n    \"\"\"\n    height = grid.shape[0]\n    background_color = 0\n    shift = 0\n    \n    # Start checking from the row immediately below the object\n    for r_check in range(max_r + 1, height):\n        # Check if the entire row is composed of the background color\n        if np.all(grid[r_check, :] == background_color):\n            shift += 1\n        else:\n            # Stop counting at the first row that is not entirely background\n            break \n            \n    return shift\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Identifies the topmost non-background object in the input grid, calculates a \n    vertical downward shift distance based on the number of consecutive all-background \n    rows immediately below the object, and moves only this topmost object down by \n    that distance. All other objects in the grid remain stationary.\n\n    1. Convert input list of lists to a NumPy array.\n    2. Find the topmost non-background object and its maximum row index (`max_r`).\n    3. If no object is found, return the original grid.\n    4. Calculate the downward `shift` distance by counting consecutive all-background rows below `max_r`.\n    5. Create a copy of the input grid to serve as the output grid.\n    6. Erase the original topmost object from the output grid by setting its pixels to the background color.\n    7. Draw the topmost object in the output grid at its new position, shifted down by `shift` rows, ensuring pixels stay within grid bounds.\n    8. Convert the output NumPy array back to a list of lists and return it.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n    background_color = 0\n\n    # Find the topmost object and its maximum row extent\n    topmost_object_pixels, max_r = find_topmost_object(grid)\n\n    # If no object was found (e.g., grid is all background), return original\n    if not topmost_object_pixels:\n        return input_grid\n\n    # Calculate the downward shift distance\n    shift = calculate_shift(grid, max_r)\n\n    # Create the output grid as a copy of the input\n    output_grid = grid.copy()\n\n    # Erase the original topmost object from the output grid\n    for r, c in topmost_object_pixels.keys():\n        output_grid[r, c] = background_color\n\n    # Draw the shifted topmost object onto the output grid\n    for (r, c), color in topmost_object_pixels.items():\n        new_r = r + shift\n        # Draw the pixel only if the new row is within the grid height\n        if 0 <= new_r < height:\n            output_grid[new_r, c] = color\n            \n    # Convert the final NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9215,
    "candidates_token_count": 1407,
    "total_token_count": 10622,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.447224,
  "retries": 1
}