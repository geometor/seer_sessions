{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a unique horizontal dividing line in the input grid. \nThis line is characterized by either consisting of a single solid color \n(not the background color 0) or an alternating two-color pattern \n(where at least one color is not 0) that spans the full width. \nThe transformation keeps all rows from the top of the grid down to \nand including the dividing line, and replaces all rows below the \ndividing line with the background color (0).\n\"\"\"\n\ndef _is_divider_row(row):\n    \"\"\"\n    Checks if a numpy array representing a row qualifies as a dividing line.\n    A dividing line is either:\n    1. A solid row of a single non-background color (e.g., [2, 2, 2]).\n    2. A row alternating between two different colors (A, B, A, B...), \n       where at least one of A or B is not the background color (0) \n       (e.g., [8, 0, 8, 0] or [1, 3, 1, 3]).\n\n    Args:\n        row (np.array): A 1D numpy array representing a grid row.\n\n    Returns:\n        bool: True if the row is a divider, False otherwise.\n    \"\"\"\n    # Handle empty or None rows\n    if row is None or len(row) == 0:\n        return False\n        \n    unique_colors = np.unique(row)\n    \n    # Check Condition 1: Solid non-background color\n    if len(unique_colors) == 1 and unique_colors[0] != 0:\n        return True\n        \n    # Check Condition 2: Alternating two-color pattern\n    # Requires exactly two distinct colors and row length > 1\n    if len(unique_colors) == 2 and len(row) > 1:\n        color1 = row[0]\n        color2 = row[1]\n        \n        # The two alternating colors must be different\n        if color1 == color2:\n            return False\n            \n        # At least one color must not be the background color (0)\n        if color1 == 0 and color2 == 0:\n            return False\n\n        # Verify the alternating pattern A, B, A, B... across the row\n        pattern_holds = True\n        for i in range(len(row)):\n            expected_color = color1 if i % 2 == 0 else color2\n            if row[i] != expected_color:\n                pattern_holds = False\n                break\n        \n        if pattern_holds:\n            return True\n            \n    # Handle single-column grids specifically if not already covered\n    # If len(row) == 1, Condition 1 (solid non-background) is the only way to be a divider.\n    # This is implicitly handled by Condition 1 check.\n            \n    # If neither condition is met\n    return False\n\ndef find_divider_row_index(grid):\n    \"\"\"\n    Scans the grid (NumPy array) row by row from top to bottom.\n    Returns the index of the first row found that matches the divider criteria \n    as defined by _is_divider_row.\n    Returns -1 if no such dividing row is found in the grid.\n\n    Args:\n        grid (np.array): The input grid as a 2D NumPy array.\n\n    Returns:\n        int: The row index of the divider, or -1 if not found.\n    \"\"\"\n    # Iterate through each row index and the row data\n    for r in range(grid.shape[0]):\n        # Check if the current row meets the criteria for being a divider\n        if _is_divider_row(grid[r]):\n            # Return the index of the first matching row found\n            return r\n            \n    # If the loop completes without finding a divider row\n    return -1 \n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on a horizontal dividing line.\n\n    1. Converts the input grid (list of lists) to a NumPy array.\n    2. Finds the index of the dividing line row using `find_divider_row_index`.\n    3. Creates a copy of the input array to serve as the output grid.\n    4. If a dividing line is found (index >= 0):\n       - Calculates the index of the first row below the divider.\n       - If such rows exist (index < grid height), sets all values \n         in these rows below the divider to the background color (0).\n    5. Converts the modified NumPy array back to a list of lists format.\n    6. Returns the transformed grid.\n    \n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists of integers.\n        \n    Returns:\n        list of lists: The transformed grid in the same format.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    \n    # Handle potential empty input grid\n    if input_array.size == 0:\n        return []\n        \n    height, width = input_array.shape\n    \n    # Create the initial output grid as a copy of the input\n    output_grid = np.copy(input_array)\n    \n    # Locate the dividing line row within the input array\n    divider_index = find_divider_row_index(input_array)\n    \n    # Proceed only if a valid divider line was identified\n    if divider_index != -1:\n        # Calculate the index of the first row that needs to be cleared (the row immediately after the divider)\n        first_row_to_clear = divider_index + 1\n        \n        # Check if there are actually rows below the divider to clear (i.e., divider wasn't the last row)\n        if first_row_to_clear < height:\n            # Set all cells in all rows from `first_row_to_clear` to the end of the grid to the background color (0)\n            # The slicing `[first_row_to_clear:, :]` selects all rows from `first_row_to_clear` onwards, and all columns.\n            output_grid[first_row_to_clear:, :] = 0\n            \n    # If no divider is found (divider_index == -1), the function currently returns a copy\n    # of the original grid. This assumes valid inputs always contain a divider based on examples.\n            \n    # Convert the final NumPy array back to a standard Python list of lists format for the return value\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3696,
    "candidates_token_count": 1514,
    "total_token_count": 5210,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 72.702133,
  "retries": 1
}