{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Any\n\n\"\"\"\nIdentify the unique horizontal line that spans the full width of the input grid.\nRecord its color (line_color) and row index (line_row).\nIdentify all distinct horizontal, contiguous blocks of pixels whose color is \nneither white (0) nor line_color.\nCreate a copy of the input grid to serve as the output grid.\nFor each identified block:\n  Determine its row index (block_row), leftmost column index (col_start), \n  and rightmost column index (col_end).\n  Compare block_row to line_row:\n    If block_row < line_row (block is above the line), update the pixel at \n      (block_row, col_start) in the output grid to line_color.\n    If block_row > line_row (block is below the line), update the pixel at \n      (block_row, col_end) in the output grid to line_color.\nReturn the modified output grid.\n\"\"\"\n\ndef find_reference_line(grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Finds the horizontal line spanning the grid width.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A tuple (line_color, line_row) if found, otherwise raises ValueError.\n    \"\"\"\n    height, width = grid.shape\n    for r in range(height):\n        row = grid[r, :]\n        first_pixel_color = row[0]\n        if first_pixel_color != 0 and np.all(row == first_pixel_color):\n            # Check if it truly spans the whole width (might be redundant if np.all passed)\n             if len(np.unique(row)) == 1:\n                 return int(first_pixel_color), r\n    raise ValueError(\"No reference line found in the grid.\")\n\ndef find_target_blocks(grid: np.ndarray, line_color: int, line_row: int) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds all horizontal blocks that are not the background or the reference line.\n\n    Args:\n        grid: The input grid as a numpy array.\n        line_color: The color of the reference line.\n        line_row: The row index of the reference line.\n\n    Returns:\n        A list of dictionaries, each representing a block with keys:\n        'row', 'col_start', 'col_end', 'color'.\n    \"\"\"\n    blocks = []\n    height, width = grid.shape\n    processed = np.zeros_like(grid, dtype=bool) # Keep track of visited block pixels\n\n    for r in range(height):\n        if r == line_row: # Skip the reference line itself\n            continue\n        for c in range(width):\n            if processed[r, c]:\n                continue\n\n            pixel_color = grid[r, c]\n            # Check if the pixel is part of a potential target block\n            if pixel_color != 0 and pixel_color != line_color:\n                # Found the start of a potential block\n                col_start = c\n                col_end = c\n                # Find the end of the horizontal contiguous block of the same color\n                while col_end + 1 < width and grid[r, col_end + 1] == pixel_color:\n                    col_end += 1\n                    # Ensure we don't process parts of the same block multiple times\n                    if col_end < width:\n                         processed[r, col_end] = True\n\n                # Store block information\n                blocks.append({\n                    'row': r,\n                    'col_start': col_start,\n                    'col_end': col_end,\n                    'color': int(pixel_color)\n                })\n\n                # Mark the starting pixel as processed\n                processed[r, c] = True\n                # Important: The outer loop continues, but inner checks `processed`\n            else:\n                 # Mark non-target pixels as processed so we don't re-check them\n                 processed[r, c] = True\n\n    return blocks\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Identifies a horizontal reference line and modifies specific pixels\n    in other horizontal blocks based on their position relative to the line.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = grid_np.copy()\n    height, width = grid_np.shape\n\n    # 1. Identify the unique horizontal reference line\n    try:\n        line_color, line_row = find_reference_line(grid_np)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        # Handle error case: maybe return input grid or raise further\n        return input_grid # Return original if line not found as per examples\n\n    # 2. Identify all target horizontal blocks\n    target_blocks = find_target_blocks(grid_np, line_color, line_row)\n\n    # 3. Apply modifications to the output grid based on block position\n    for block in target_blocks:\n        block_row = block['row']\n        col_start = block['col_start']\n        col_end = block['col_end']\n\n        # Determine which pixel to change based on position relative to the line\n        if block_row < line_row:\n            # Block is above the line: change leftmost pixel\n            output_grid_np[block_row, col_start] = line_color\n        elif block_row > line_row:\n            # Block is below the line: change rightmost pixel\n            output_grid_np[block_row, col_end] = line_color\n        # Blocks on the same row as the line are ignored (and shouldn't be found by find_target_blocks)\n\n    # Convert back to list of lists for the required output format\n    output_grid = output_grid_np.tolist()\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2941,
    "candidates_token_count": 1441,
    "total_token_count": 4382,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.625889,
  "retries": 1
}