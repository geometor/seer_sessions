{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies all distinct contiguous non-white objects (using 8-way connectivity) \nin the input grid. Verifies that exactly two objects exist. Selects the object \nwhose topmost pixel has the minimum row index (appears higher in the grid). \nCreates a new output grid containing only the selected object, cropped to its \nminimal bounding box. Pixels within the bounding box but not part of the \nselected object are set to white (0).\n\"\"\"\n\ndef find_objects_8_way(grid):\n    \"\"\"\n    Finds all contiguous objects (8-way connectivity) of non-white pixels in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'pixels' (set of (r, c) tuples),\n              'bbox' (min_row, min_col, max_row, max_col), and 'top_row'.\n              Returns an empty list if no non-white pixels are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    # Define 8 directions for connectivity check\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if a non-white, unvisited pixel is found\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search (BFS)\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n\n                    # Update bounding box and find minimum row (top_row)\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (8-directional)\n                    for dr, dc in directions:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds, has the same color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store object details\n                objects.append({\n                    'color': color,\n                    'pixels': obj_pixels,\n                    'bbox': (min_r, min_c, max_r, max_c),\n                    'top_row': min_r\n                })\n                \n    return objects\n\ndef crop_object(grid, obj):\n    \"\"\"\n    Creates a new grid containing only the specified object, cropped to its bounding box.\n    Pixels within the bounding box not belonging to the object are white (0).\n\n    Args:\n        grid (np.array): The original input grid (used to get object colors).\n        obj (dict): The object dictionary containing 'pixels' and 'bbox'.\n\n    Returns:\n        np.array: The cropped output grid.\n    \"\"\"\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    # Initialize output grid with background color (white, 0)\n    output_grid = np.zeros((height, width), dtype=int)\n\n    # Copy object pixels to the output grid, adjusting coordinates\n    for r, c in obj['pixels']:\n        # Calculate relative position in the cropped grid\n        output_r = r - min_r\n        output_c = c - min_c\n        # Ensure coordinates are within the bounds of the new grid (should always be true)\n        if 0 <= output_r < height and 0 <= output_c < width:\n             # Use the color from the original grid\n             output_grid[output_r, output_c] = grid[r, c] \n\n    return output_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by selecting the highest object and cropping it.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid. Returns an empty list if not \n                       exactly two objects are found.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    grid_np = np.array(input_grid, dtype=int)\n\n    # Find all distinct non-white objects using 8-way connectivity\n    objects = find_objects_8_way(grid_np)\n\n    # Verify that exactly two objects were found, as per task constraints\n    if len(objects) != 2:\n        # Handle unexpected number of objects (return empty or raise error)\n        # Based on training examples, this case assumes valid input has 2 objects.\n        # Returning empty list seems safer than potentially wrong output.\n        print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning empty grid.\")\n        return [[]] \n\n    # Determine the object with the minimum top_row index (the highest one)\n    # The `min` function with a lambda key works perfectly here.\n    selected_object = min(objects, key=lambda obj: obj['top_row'])\n\n    # Create the output grid by cropping the selected object\n    output_grid_np = crop_object(grid_np, selected_object)\n\n    # Convert the resulting NumPy array back to a list of lists format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8985,
    "candidates_token_count": 1446,
    "total_token_count": 10431,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.418056,
  "retries": 1
}