{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies distinct horizontal rectangular blocks of non-background color in the input grid.\nDetermines the vertical order of these blocks based on their top row.\nSwaps the first (top-most) and the last (bottom-most) blocks in this vertical sequence.\nReconstructs the stack of blocks in the output grid, starting from the original top row of the stack, \nmaintaining the blocks' original horizontal positions, widths, and heights, but using the modified vertical order.\nThe background color fills the rest of the grid.\n\"\"\"\n\nimport numpy as np\nfrom typing import List, Dict, Tuple, Any\n\ndef find_blocks(grid: np.ndarray) -> List[Dict[str, Any]]:\n    \"\"\"\n    Finds all distinct, maximal, horizontal rectangular blocks of non-background color.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        and contains 'color', 'top_row', 'left_col', 'height', 'width'.\n        Returns an empty list if no non-background blocks are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color and not visited[r, c]:\n                # Found the start of a potential block\n                \n                # Find horizontal extent\n                start_c = c\n                end_c = c\n                while end_c + 1 < width and grid[r, end_c + 1] == color and not visited[r, end_c + 1]:\n                    end_c += 1\n                \n                block_width = end_c - start_c + 1\n\n                # Find vertical extent (check if rows below match exactly)\n                start_r = r\n                end_r = r\n                while end_r + 1 < height:\n                    match = True\n                    for current_c in range(start_c, end_c + 1):\n                        if grid[end_r + 1, current_c] != color or visited[end_r + 1, current_c]:\n                            match = False\n                            break\n                    if match:\n                        end_r += 1\n                    else:\n                        break\n                \n                block_height = end_r - start_r + 1\n\n                # Store block info\n                blocks.append({\n                    'color': color,\n                    'top_row': start_r,\n                    'left_col': start_c,\n                    'height': block_height,\n                    'width': block_width\n                })\n\n                # Mark cells as visited\n                for row_idx in range(start_r, end_r + 1):\n                    for col_idx in range(start_c, end_c + 1):\n                        visited[row_idx, col_idx] = True\n                        \n                # Optimization: continue search after the found block in the current row\n                # We already scanned up to end_c for this row 'r'\n                # No need to re-check columns start_c to end_c for row 'r'\n                # The outer loop's `c` will advance. Correcting this:\n                # Actually, the outer loop `c` advancing handles this implicitly\n                # because `visited` prevents reprocessing. No explicit `c` jump needed.\n\n\n    return blocks\n\ndef draw_block(output_grid: np.ndarray, block: Dict[str, Any], start_row: int):\n    \"\"\"Draws a block onto the output grid at the specified start row.\"\"\"\n    top = start_row\n    bottom = start_row + block['height']\n    left = block['left_col']\n    right = block['left_col'] + block['width']\n    output_grid[top:bottom, left:right] = block['color']\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule: find colored blocks, sort vertically,\n    swap top and bottom, reconstruct the stack.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    height, width = input_arr.shape\n    background_color = 0\n\n    # Find all colored rectangular blocks\n    blocks = find_blocks(input_arr)\n\n    # If no blocks or only one block, return the input as is\n    if len(blocks) < 2:\n        return input_grid\n\n    # Sort blocks by their top row index to determine vertical order\n    blocks.sort(key=lambda b: b['top_row'])\n\n    # Record the original top row of the entire stack\n    original_stack_top_row = blocks[0]['top_row']\n\n    # Swap the first (top-most) and last (bottom-most) blocks in the sequence\n    blocks[0], blocks[-1] = blocks[-1], blocks[0]\n\n    # Initialize the output grid with the background color\n    output_arr = np.full((height, width), background_color, dtype=int)\n\n    # Reconstruct the stack in the output grid\n    current_row = original_stack_top_row\n    for block in blocks:\n        # Draw the block at the current vertical position, using its original horizontal position and dimensions\n        draw_block(output_arr, block, current_row)\n        # Update the starting row for the next block\n        current_row += block['height']\n\n    # Convert the numpy array back to a list of lists\n    output_grid = output_arr.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3477,
    "candidates_token_count": 1346,
    "total_token_count": 4823,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.460452,
  "retries": 1
}