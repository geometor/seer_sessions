{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n# -*- coding: utf-8 -*-\n\"\"\"\nIdentifies 'template' structures in the input grid, where a 'container' object encloses a 'content' object based on specific spatial criteria (bounding box inclusion, no border adjacency for content).\n\nFinds other 'target' objects elsewhere in the grid that are identical in shape, size, and color to the 'content' object and are located outside the original 'container'.\n\nFor each unique target found, copies the corresponding template structure (container and content) and pastes it onto the grid. The pasting aligns the copied content precisely with the original target object, maintaining the container's relative position around it.\n\nThe original template structures and targets remain in the input part of the grid unless overwritten by a paste operation initiated by a different template/target pair. Uses 8-way connectivity for object detection.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors (value 0) in the grid\n    using 8-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'id' (int), 'color' (int), 'coords' (set of (r, c) tuples),\n              'bbox' (tuple: min_r, min_c, max_r, max_c), and 'size' (tuple: height, width).\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    obj_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS if a non-background pixel hasn't been visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                visited_in_obj = set([(r,c)]) # Track visited for this specific BFS traversal\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Process the current pixel\n                    visited[curr_r, curr_c] = True\n                    coords.add((curr_r, curr_c))\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore 8-way neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check if neighbor is valid, same color, and not yet visited in this BFS\n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               grid[nr, nc] == current_color and \\\n                               (nr, nc) not in visited_in_obj:\n                                visited_in_obj.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Store the found object\n                if coords:\n                    objects.append({\n                        'id': obj_id_counter,\n                        'color': current_color,\n                        'coords': coords,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'size': (max_r - min_r + 1, max_c - min_c + 1)\n                    })\n                    obj_id_counter += 1\n    return objects\n\ndef get_relative_mask(obj):\n    \"\"\"\n    Calculates the relative coordinates (mask) of an object's pixels\n    with respect to its bounding box top-left corner.\n\n    Args:\n        obj (dict): An object dictionary from find_objects.\n\n    Returns:\n        dict: Contains 'mask' (set of (rel_r, rel_c) tuples) and\n              'size' (tuple: height, width).\n    \"\"\"\n    min_r, min_c, _, _ = obj['bbox']\n    mask = set()\n    for r, c in obj['coords']:\n        mask.add((r - min_r, c - min_c))\n    # Size is already calculated in find_objects, reuse it\n    return {'mask': mask, 'size': obj['size']}\n\ndef check_containment(container_obj, content_obj, grid):\n    \"\"\"\n    Checks if container_obj encloses content_obj based on revised criteria:\n    - Different colors.\n    - Content bounding box is strictly inside container bounding box.\n    - No coordinate overlap between container and content.\n    - Content object is not adjacent (8-way) to the grid border.\n\n    Args:\n        container_obj (dict): Potential container object.\n        content_obj (dict): Potential content object.\n        grid (np.array): The input grid.\n\n    Returns:\n        bool: True if containment is confirmed, False otherwise.\n    \"\"\"\n    height, width = grid.shape\n    content_bbox = content_obj['bbox']\n    container_bbox = container_obj['bbox']\n\n    # 1. Check different colors\n    if container_obj['color'] == content_obj['color']:\n        return False\n\n    # 2. Check bounding box relationship (content strictly inside container bbox)\n    if not (content_bbox[0] > container_bbox[0] and\n            content_bbox[1] > container_bbox[1] and\n            content_bbox[2] < container_bbox[2] and\n            content_bbox[3] < container_bbox[3]):\n        return False\n\n    # 3. Check no overlap between container and content coords\n    if content_obj['coords'].intersection(container_obj['coords']):\n        return False\n\n    # 4. Check if content is adjacent to the grid border (8-way)\n    for r_cont, c_cont in content_obj['coords']:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0: continue\n                nr, nc = r_cont + dr, c_cont + dc\n                # If a neighbor coordinate is outside the grid, the content pixel is adjacent to the border\n                if not (0 <= nr < height and 0 <= nc < width):\n                    return False # Content is adjacent to border\n\n    # If all checks pass, it's considered contained by these rules\n    return True\n\n\ndef are_identical(obj1_mask, obj2_mask):\n    \"\"\"\n    Checks if two objects are identical based on their relative masks.\n\n    Args:\n        obj1_mask (dict): Relative mask dict for object 1.\n        obj2_mask (dict): Relative mask dict for object 2.\n\n    Returns:\n        bool: True if identical shape and size, False otherwise.\n    \"\"\"\n    # Check size first for quick exit\n    if obj1_mask['size'] != obj2_mask['size']:\n        return False\n    # Check the set of relative coordinates\n    return obj1_mask['mask'] == obj2_mask['mask']\n\ndef is_bbox_outside(inner_bbox, outer_bbox):\n    \"\"\"\n    Checks if inner_bbox is entirely outside outer_bbox.\n\n    Args:\n        inner_bbox (tuple): Bbox of the object to check (min_r, min_c, max_r, max_c).\n        outer_bbox (tuple): Bbox of the reference area (min_r, min_c, max_r, max_c).\n\n    Returns:\n        bool: True if inner_bbox is completely outside outer_bbox, False otherwise.\n    \"\"\"\n    inner_min_r, inner_min_c, inner_max_r, inner_max_c = inner_bbox\n    outer_min_r, outer_min_c, outer_max_r, outer_max_c = outer_bbox\n\n    # Check for non-overlap: inner ends before outer starts OR inner starts after outer ends\n    is_outside_vertical = inner_max_r < outer_min_r or inner_min_r > outer_max_r\n    is_outside_horizontal = inner_max_c < outer_min_c or inner_min_c > outer_max_c\n\n    # If it's outside either vertically or horizontally, it cannot overlap.\n    # To be strictly outside, it must not overlap at all.\n    # An overlap occurs if NOT is_outside_vertical AND NOT is_outside_horizontal.\n    # Therefore, it is outside if is_outside_vertical OR is_outside_horizontal.\n    return is_outside_vertical or is_outside_horizontal\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: identifies container/content/target triplets\n    based on revised containment rules and copies the container/content structure\n    to replace the target.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # 1. Find all objects in the input grid\n    objects = find_objects(input_grid)\n    if not objects:\n        return output_grid # Return copy if no objects found\n\n    # 2. Pre-calculate relative masks for all objects for efficient comparison\n    object_masks = {obj['id']: get_relative_mask(obj) for obj in objects}\n\n    # 3. Identify containment pairs (template pairs) using the revised check\n    containment_pairs = []\n    for i in range(len(objects)):\n        for j in range(len(objects)):\n            if i == j: continue # An object cannot contain itself\n            container_candidate = objects[i]\n            content_candidate = objects[j]\n            # Use the revised containment check function\n            if check_containment(container_candidate, content_candidate, input_grid):\n                containment_pairs.append({\n                    'container_idx': i,\n                    'content_idx': j,\n                    'container_obj': container_candidate, # Store refs for convenience\n                    'content_obj': content_candidate\n                })\n\n    # 4. Identify triplets (container, content, target)\n    triplets = []\n    # Keep track of targets already assigned to ensure uniqueness\n    assigned_target_indices = set()\n\n    for pair in containment_pairs:\n        content_obj = pair['content_obj']\n        content_idx = pair['content_idx']\n        content_mask = object_masks[content_idx]\n        container_obj = pair['container_obj']\n        container_idx = pair['container_idx']\n        container_bbox = container_obj['bbox'] # Bbox of the original container\n\n        # Iterate through all objects to find potential targets\n        for k in range(len(objects)):\n            # Target cannot be the container or content of the current pair\n            if k == container_idx or k == content_idx: continue\n            # Target must not have already been assigned\n            if k in assigned_target_indices: continue\n\n            target_candidate = objects[k]\n\n            # Check if target candidate has the same color and shape/size as the content\n            if target_candidate['color'] == content_obj['color']:\n                target_mask = object_masks[k]\n                if are_identical(content_mask, target_mask):\n                    # Check if target is outside the original container's bounding box\n                    if is_bbox_outside(target_candidate['bbox'], container_bbox):\n                        # If it's a valid, outside, and unassigned target, record the triplet\n                        triplets.append({\n                            'container_idx': container_idx,\n                            'content_idx': content_idx,\n                            'target_idx': k\n                        })\n                        # Mark this target index (k) as assigned\n                        assigned_target_indices.add(k)\n                        # Important: Break if you only want one target per content type?\n                        # The prompt implies finding *all* valid targets and copying for each.\n                        # The uniqueness constraint is on the *target* object itself.\n\n\n    # 5. Perform replacements based on identified triplets\n    # Note: The previous step already ensures targets are unique via assigned_target_indices.\n    for triplet in triplets:\n        # Get the original container, content, and target objects using their indices\n        container = objects[triplet['container_idx']]\n        content = objects[triplet['content_idx']]\n        target = objects[triplet['target_idx']]\n\n        # Calculate the relative offset of the content's top-left corner\n        # within the container's bounding box.\n        cont_min_r, cont_min_c, _, _ = content['bbox']\n        cr_min_r, cr_min_c, _, _ = container['bbox']\n        offset_r = cont_min_r - cr_min_r\n        offset_c = cont_min_c - cr_min_c\n\n        # Determine the top-left corner where the *new container* should be pasted.\n        # This is based on the target's top-left corner minus the content's offset\n        # relative to its container. This ensures the copied content aligns with the target.\n        target_min_r, target_min_c, _, _ = target['bbox']\n        paste_cr_top_left_r = target_min_r - offset_r\n        paste_cr_top_left_c = target_min_c - offset_c\n\n        # --- Perform the pasting onto the output grid ---\n\n        # a) Paste the container pixels\n        container_color = container['color']\n        cr_mask = object_masks[triplet['container_idx']]['mask']\n        for rel_r, rel_c in cr_mask:\n            out_r = paste_cr_top_left_r + rel_r\n            out_c = paste_cr_top_left_c + rel_c\n            # Ensure pasted pixel is within grid bounds before writing\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = container_color\n\n        # b) Paste the content pixels (overwriting container pixels if necessary)\n        # Paste content aligned with the original target position.\n        content_color = content['color']\n        cont_mask = object_masks[triplet['content_idx']]['mask']\n        for rel_r, rel_c in cont_mask:\n            out_r = target_min_r + rel_r\n            out_c = target_min_c + rel_c\n            # Ensure pasted pixel is within grid bounds before writing\n            if 0 <= out_r < height and 0 <= out_c < width:\n                output_grid[out_r, out_c] = content_color\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18215,
    "candidates_token_count": 3498,
    "total_token_count": 21713,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.071192,
  "retries": null
}