{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies 'seed' pixels (single pixels of a non-white color) and uses them as anchor points to copy patterns.\nThe pattern associated with a seed color is derived from the bounding box content of the largest contiguous object of that same color found elsewhere in the input grid.\nThe copied pattern overwrites the existing grid content at the target location, starting with the top-left of the pattern aligned with the seed pixel's location.\nPixels not part of a seed or overwritten by a pattern copy remain unchanged.\n\nWorkflow:\n1. Initialize the output grid as a copy of the input grid.\n2. Find all unique non-white colors present in the input grid.\n3. For each unique color C:\n    a. Find all contiguous objects of color C using Breadth-First Search (BFS). Record their pixel coordinates and sizes.\n    b. Identify objects of size 1 (seed pixels) and objects larger than 1.\n    c. If there are seed pixels of color C and also larger objects of color C:\n        i. Find the largest object(s) of color C among those with size > 1.\n        ii. If multiple objects share the maximum size, select one (e.g., the first one found, or based on top-left position).\n        iii. Determine the bounding box of the selected largest object.\n        iv. Extract the rectangular region (template pattern) from the *input grid* corresponding to this bounding box.\n        v. For each seed pixel of color C at location (r, c):\n            - Paste the extracted template pattern onto the *output grid*, with the top-left of the template placed at (r, c). Handle boundary clipping if the pattern extends beyond the grid edges.\n4. Return the final output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a specific color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append(obj_pixels)\n                    \n    return objects\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box for a set of pixel coordinates.\"\"\"\n    if not pixels:\n        return None\n    \n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    \n    return min_r, min_c, max_r, max_c\n\ndef paste_pattern(output_grid, pattern, start_row, start_col):\n    \"\"\"Pastes a pattern onto the output grid at the specified location, handling boundaries.\"\"\"\n    pattern_rows, pattern_cols = pattern.shape\n    grid_rows, grid_cols = output_grid.shape\n\n    # Determine the intersection of the pattern area and the grid boundaries\n    paste_start_row = start_row\n    paste_start_col = start_col\n    paste_end_row = start_row + pattern_rows\n    paste_end_col = start_col + pattern_cols\n\n    pattern_start_r_offset = 0\n    pattern_start_c_offset = 0\n\n    # Adjust for top/left boundaries\n    if paste_start_row < 0:\n        pattern_start_r_offset = -paste_start_row\n        paste_start_row = 0\n    if paste_start_col < 0:\n        pattern_start_c_offset = -paste_start_col\n        paste_start_col = 0\n        \n    # Adjust for bottom/right boundaries\n    paste_end_row = min(paste_end_row, grid_rows)\n    paste_end_col = min(paste_end_col, grid_cols)\n\n    # Calculate the actual dimensions to paste\n    paste_height = paste_end_row - paste_start_row\n    paste_width = paste_end_col - paste_start_col\n\n    # Check if there is anything to paste\n    if paste_height <= 0 or paste_width <= 0:\n        return # Nothing to paste within grid bounds\n\n    # Extract the relevant part of the pattern\n    pattern_slice = pattern[pattern_start_r_offset : pattern_start_r_offset + paste_height,\n                            pattern_start_c_offset : pattern_start_c_offset + paste_width]\n\n    # Paste the slice onto the output grid\n    output_grid[paste_start_row:paste_end_row, paste_start_col:paste_end_col] = pattern_slice\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: copies patterns based on largest objects\n    triggered by seed pixels of the same color.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # Find unique non-white colors\n    unique_colors = np.unique(input_grid)\n    non_white_colors = unique_colors[unique_colors != 0]\n\n    # Process each color\n    for color in non_white_colors:\n        # Find all objects of this color\n        objects = find_objects(input_grid, color)\n        \n        if not objects:\n            continue\n\n        # Separate seeds (size 1) from larger objects\n        seeds = [obj for obj in objects if len(obj) == 1]\n        larger_objects = [obj for obj in objects if len(obj) > 1]\n\n        # Only proceed if both seeds and larger objects exist for this color\n        if not seeds or not larger_objects:\n            continue\n\n        # Find the largest object(s) among the larger ones\n        largest_size = 0\n        largest_object_pixels = None\n        for obj in larger_objects:\n            if len(obj) > largest_size:\n                largest_size = len(obj)\n                largest_object_pixels = obj\n            # Simple tie-breaking: keep the first one found with max size\n\n        # If a largest object was found, define the template\n        if largest_object_pixels:\n            # Get bounding box of the largest object\n            bbox = get_bounding_box(largest_object_pixels)\n            min_r, min_c, max_r, max_c = bbox\n            \n            # Extract the template pattern from the input grid\n            template_pattern = input_grid[min_r : max_r + 1, min_c : max_c + 1]\n            \n            # Apply the template for each seed of this color\n            for seed_obj in seeds:\n                seed_r, seed_c = list(seed_obj)[0] # Get the single coordinate\n                paste_pattern(output_grid, template_pattern, seed_r, seed_c)\n\n    return output_grid.tolist() # Return as list of lists per ARC standard\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4310,
    "candidates_token_count": 1812,
    "total_token_count": 6122,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.884227,
  "retries": null
}