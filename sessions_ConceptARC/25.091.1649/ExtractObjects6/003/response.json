{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport math\n\n\"\"\"\nProcesses an input grid by performing the following steps:\n\n1.  **Find Separator:** Locates a solid horizontal or vertical line of yellow (4) pixels that divides the grid. Records the orientation (horizontal/vertical) and index.\n2.  **Divide Input:** Splits the input grid into two subgrids based on the separator, discarding the separator line itself. Notes the original relative orientation (top/bottom or left/right).\n3.  **Process Each Subgrid:** For each subgrid:\n    a.  **Check for Special Case:** Determines if the subgrid contains both green (3) and gray (5) pixels.\n    b.  **Extract Feature Pixels:**\n        i.  **If Special Case (Green and Gray):** Identifies green (3) pixels adjacent (sharing an edge) to *any* non-green pixel within that subgrid. Collects these 'perimeter' green pixel coordinates. The feature color is green (3).\n        ii. **If General Case:** Identifies the primary object color(s) (non-background, non-yellow). Finds the background (most frequent non-yellow). Collects coordinates of all non-background, non-yellow pixels. If multiple object colors, picks the most frequent one as the feature color and filters coordinates accordingly.\n    c.  **Create Output Subgrid:** Calculates the minimal bounding box of the collected feature pixels. Creates a new grid (filled with white 0) of the bounding box size. Places the feature pixels (using the determined feature color) into this new grid at relative positions. If no feature pixels are found, returns a 1x1 white grid. Records the output subgrid's dimensions.\n4.  **Standardize Dimensions:** Compares the dimensions of the two processed subgrids.\n    a.  **If Separator was Horizontal (Row):** Finds the maximum width. Pads the narrower subgrid with white (0) columns (centered horizontally) to match the maximum width.\n    b.  **If Separator was Vertical (Column):** Finds the maximum height. Pads the shorter subgrid with white (0) rows (centered vertically) to match the maximum height.\n5.  **Combine Results:** Concatenates the two standardized subgrids based on the original separator orientation (vertically for row separator, horizontally for column separator).\n\"\"\"\n\ndef find_separator(grid):\n    \"\"\"Finds a horizontal or vertical solid line of yellow (4).\"\"\"\n    h, w = grid.shape\n    # Check for horizontal separator\n    for r in range(h):\n        if np.all(grid[r, :] == 4):\n            return 'h', r # Horizontal line at row r\n    # Check for vertical separator\n    for c in range(w):\n        if np.all(grid[:, c] == 4):\n            return 'v', c # Vertical line at column c\n    return None, -1 # No separator found\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box for a list of coordinates.\"\"\"\n    if not coords:\n        return 0, -1, 0, -1 # Indicate empty box\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return min_r, max_r, min_c, max_c\n\ndef find_green_perimeter_refined(subgrid):\n    \"\"\"Finds green pixels adjacent to any non-green pixel within the subgrid.\"\"\"\n    h, w = subgrid.shape\n    perimeter_coords = []\n    green_coords = np.argwhere(subgrid == 3)\n\n    for r, c in green_coords:\n        is_perimeter = False\n        # Check 4 neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w:\n                # If neighbor is NOT green (could be gray, background, etc.)\n                if subgrid[nr, nc] != 3:\n                    is_perimeter = True\n                    break\n        if is_perimeter:\n            perimeter_coords.append((r, c))\n\n    # Return coordinates and the feature color (always green for this case)\n    return perimeter_coords, 3\n\ndef extract_feature(subgrid):\n    \"\"\"Extracts the main feature/object from a subgrid.\"\"\"\n    h, w = subgrid.shape\n    unique_colors = np.unique(subgrid)\n    feature_coords = []\n    feature_color = 0 # Default to 0 (white)\n\n    # Handle empty or single-color subgrids early\n    if h == 0 or w == 0:\n         return np.zeros((1, 1), dtype=int), (1, 1)\n    non_yellow_colors = [c for c in unique_colors if c != 4]\n    if len(non_yellow_colors) <= 1: # Only background or only yellow separator remnants\n         return np.zeros((1, 1), dtype=int), (1, 1)\n\n\n    # Check for the special green (3) and gray (5) case\n    if 3 in unique_colors and 5 in unique_colors:\n        feature_coords, feature_color = find_green_perimeter_refined(subgrid)\n    else:\n        # General case: extract non-background, non-yellow pixels\n        counts = Counter(subgrid.flatten())\n        \n        # Find likely background (most frequent, non-yellow)\n        bg_color = -1\n        max_count = -1\n        sorted_counts = sorted(counts.items(), key=lambda item: item[1], reverse=True)\n        for color, count in sorted_counts:\n             if color != 4: # ignore yellow separator remnants if any\n                 bg_color = color\n                 break\n        # If calculation failed (e.g., only yellow?), default background to white?\n        if bg_color == -1: bg_color = 0 # Fallback\n\n        object_colors = set()\n        temp_feature_coords = [] # Store potential feature coords before filtering by color\n        for r in range(h):\n            for c in range(w):\n                color = subgrid[r, c]\n                if color != bg_color and color != 4:\n                    temp_feature_coords.append((r, c))\n                    object_colors.add(color)\n\n        if not object_colors: # No object pixels found\n            pass # feature_coords remains empty\n        elif len(object_colors) == 1:\n             feature_color = object_colors.pop()\n             feature_coords = temp_feature_coords # All collected coords belong to the single object color\n        else: # Multiple object colors found\n             # Heuristic: pick the most frequent non-background, non-yellow color\n             obj_counts = {c: counts[c] for c in object_colors}\n             feature_color = max(obj_counts, key=obj_counts.get)\n             # Filter coords to only include the chosen feature color\n             feature_coords = [(r,c) for r,c in temp_feature_coords if subgrid[r,c] == feature_color]\n\n\n    # Create the output subgrid based on bounding box\n    if not feature_coords:\n        # Return a minimal 1x1 white grid if no feature was extracted\n        return np.zeros((1, 1), dtype=int), (1, 1)\n\n    min_r, max_r, min_c, max_c = get_bounding_box(feature_coords)\n    # Check for invalid bounding box (e.g., from empty coords)\n    if max_r < min_r or max_c < min_c:\n         return np.zeros((1, 1), dtype=int), (1, 1)\n\n    out_h = max_r - min_r + 1\n    out_w = max_c - min_c + 1\n    output_subgrid = np.zeros((out_h, out_w), dtype=int) # Fill with white (0)\n\n    # Place feature pixels into the output subgrid\n    for r, c in feature_coords:\n        # Make sure the pixel being placed belongs to the designated feature_color\n        # This handles the case where multiple object colors existed initially\n        if subgrid[r,c] == feature_color:\n             output_subgrid[r - min_r, c - min_c] = feature_color\n\n    return output_subgrid, (out_h, out_w)\n\n\ndef pad_grid(grid, target_h, target_w, bg_color=0):\n    \"\"\"Pads a grid to target dimensions, centering the content.\"\"\"\n    h, w = grid.shape\n    \n    # Ensure target dimensions are at least the current dimensions\n    target_h = max(h, target_h)\n    target_w = max(w, target_w)\n\n    pad_h = target_h - h\n    pad_w = target_w - w\n\n    pad_top = pad_h // 2\n    pad_bottom = pad_h - pad_top\n    pad_left = pad_w // 2\n    pad_right = pad_w - pad_left\n    \n    # np.pad requires non-negative padding amounts\n    if pad_top < 0 or pad_bottom < 0 or pad_left < 0 or pad_right < 0:\n         # This should not happen with max() check above, but as safety:\n         print(f\"Warning: Negative padding calculated unexpectedly. Grid shape: ({h},{w}), Target: ({target_h},{target_w})\")\n         return grid # Return original grid if something went wrong\n\n    padded_grid = np.pad(\n        grid,\n        ((pad_top, pad_bottom), (pad_left, pad_right)),\n        mode='constant',\n        constant_values=bg_color\n    )\n    return padded_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n\n    # 1. Find Separator\n    orientation, index = find_separator(input_array)\n    if orientation is None:\n        # If no separator, maybe return input or handle as error?\n        # Based on task structure, separator is expected.\n        # Returning input for safety, though it likely indicates an issue.\n        print(\"Warning: No separator found.\")\n        return input_grid\n\n    # 2. Divide Input\n    subgrids = []\n    split_orientation = None # Determines how to standardize and combine\n    if orientation == 'h': # Horizontal separator (row) -> top/bottom regions\n        if index > 0:\n            subgrids.append(input_array[:index, :])\n        if index < input_array.shape[0] - 1:\n            subgrids.append(input_array[index+1:, :])\n        split_orientation = 'vertical' # Regions are top/bottom -> stack vertically\n    elif orientation == 'v': # Vertical separator (column) -> left/right regions\n        if index > 0:\n            subgrids.append(input_array[:, :index])\n        if index < input_array.shape[1] - 1:\n             subgrids.append(input_array[:, index+1:])\n        split_orientation = 'horizontal' # Regions are left/right -> stack horizontally\n\n    # Handle cases where splitting might yield fewer than 2 grids (e.g., separator at edge)\n    if len(subgrids) == 0:\n         print(\"Warning: Splitting resulted in zero subgrids.\")\n         return [[]] # Return empty grid\n    elif len(subgrids) == 1:\n         # If only one region, process it and return (no standardization/combination needed)\n         processed, (h, w) = extract_feature(subgrids[0])\n         return processed.tolist()\n\n    # 3. Process Each Subgrid (expecting 2 subgrids now)\n    processed_subgrids = []\n    dimensions = []\n    for subgrid in subgrids:\n        processed, (h, w) = extract_feature(subgrid)\n        processed_subgrids.append(processed)\n        dimensions.append((h, w))\n\n    if not processed_subgrids or len(processed_subgrids) != 2:\n         print(\"Warning: Incorrect number of processed subgrids.\")\n         return [[]] # Return empty\n\n    # 4. Standardize Dimensions\n    standardized_subgrids = []\n    grid1, grid2 = processed_subgrids[0], processed_subgrids[1]\n    (h1, w1), (h2, w2) = dimensions[0], dimensions[1]\n\n    if split_orientation == 'vertical': # Row separator -> standardize width\n        max_w = max(w1, w2)\n        std1 = pad_grid(grid1, h1, max_w)\n        std2 = pad_grid(grid2, h2, max_w)\n        standardized_subgrids = [std1, std2]\n\n    elif split_orientation == 'horizontal': # Column separator -> standardize height\n        max_h = max(h1, h2)\n        std1 = pad_grid(grid1, max_h, w1)\n        std2 = pad_grid(grid2, max_h, w2)\n        standardized_subgrids = [std1, std2]\n\n    # 5. Combine Results\n    if not standardized_subgrids:\n        print(\"Warning: Standardization failed.\")\n        return [[]] # Return empty grid if processing failed\n\n    output_array = None\n    if split_orientation == 'vertical':\n        output_array = np.vstack(standardized_subgrids)\n    elif split_orientation == 'horizontal':\n        output_array = np.hstack(standardized_subgrids)\n\n    if output_array is None:\n         print(\"Warning: Combination failed.\")\n         return [[]]\n\n    # Convert final numpy array back to list of lists\n    output_grid = output_array.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16033,
    "candidates_token_count": 3300,
    "total_token_count": 19333,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.379651,
  "retries": 1
}