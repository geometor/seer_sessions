{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the background color (0), a frame color (major non-background color near the edge), and inner color(s) (other colors).\nFinds the bounding box of all pixels matching the inner color(s).\nRefines this bounding box by iteratively trimming edges (bottom, right, top, left) if they consist entirely of the frame color.\nExtracts the subgrid defined by the final bounding box from the input.\nReplaces any pixels matching the frame color within the extracted subgrid with the background color.\nReturns the resulting subgrid.\n\"\"\"\n\nimport numpy as np\n\ndef find_bounding_box(grid, target_colors):\n    \"\"\"\n    Finds the minimum bounding box containing any of the target colors.\n    \n    Args:\n        grid (np.array): The input grid.\n        target_colors (set): A set of colors to find the bounding box for.\n\n    Returns:\n        list or None: A list [min_r, max_r, min_c, max_c] or None if no target pixels found.\n    \"\"\"\n    rows, cols = np.where(np.isin(grid, list(target_colors)))\n    if rows.size == 0:\n        return None  # No target pixels found\n    min_r, max_r = np.min(rows), np.max(rows)\n    min_c, max_c = np.min(cols), np.max(cols)\n    # Return as a mutable list for easier modification during refinement\n    return [int(min_r), int(max_r), int(min_c), int(max_c)] \n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting an inner object, refining its\n    bounding box by trimming frame-colored edges, and replacing frame color \n    remnants within the final box with the background color.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    \n    if grid.size == 0:\n        return [] # Handle empty input\n        \n    # 1. Identify Colors\n    background_color = 0\n    unique_colors = np.unique(grid)\n    non_background_colors = set(unique_colors) - {background_color}\n\n    # Heuristic for frame color: check grid[1,1] if possible and not background\n    frame_color = -1 \n    if grid.shape[0] > 1 and grid.shape[1] > 1:\n        candidate_frame = grid[1, 1]\n        if candidate_frame != background_color:\n            frame_color = candidate_frame\n\n    # Fallback/Alternative: If grid[1,1] failed, try another near-border point or common color logic\n    # For this task, grid[1,1] seems sufficient for the examples provided. \n    # If not identified, maybe pick the most frequent non-background?\n    if frame_color == -1 and non_background_colors:\n         # A more robust heuristic might be needed for general cases.\n         # Example 2: grid[1,1] is 0, but grid[1,3] is 3 (frame).\n         # Let's refine: Check (1,1), then maybe iterate along row 1 or col 1?\n         # Or, use the most frequent non-background color. Let's try that as a fallback.\n         if non_background_colors:\n              counts = {c: np.sum(grid == c) for c in non_background_colors}\n              if counts:\n                   frame_color = max(counts, key=counts.get) # Assume most frequent non-bg is frame\n    \n    # If still no frame color found (e.g., only background), return empty or handle as error\n    if frame_color == -1:\n         # If only background exists, return empty? Or original? Assume empty based on task pattern.\n         return []\n\n    inner_colors = non_background_colors - {frame_color}\n\n    if not inner_colors:\n        # No inner colors found, which contradicts the examples' patterns.\n         return [] \n\n    # 2. Find Inner Region Bounding Box\n    bbox = find_bounding_box(grid, inner_colors)\n\n    if bbox is None:\n        # No inner pixels actually found\n        return [] \n\n    # 3. Refine Bounding Box by trimming pure frame-color edges\n    # bbox = [min_r, max_r, min_c, max_c]\n    refined = True\n    while refined:\n        refined = False\n        min_r, max_r, min_c, max_c = bbox\n\n        # Check bottom row (if valid box)\n        if min_r <= max_r and min_c <= max_c:\n            bottom_row_slice = grid[max_r, min_c:max_c+1]\n            if np.all(bottom_row_slice == frame_color):\n                bbox[1] -= 1 # max_r decreases\n                refined = True\n                if bbox[1] < bbox[0]: break # Box became invalid\n\n        # Check right column (if valid box)\n        if bbox[0] <= bbox[1] and bbox[2] <= bbox[3]: # Re-check bounds after potential row trim\n             right_col_slice = grid[bbox[0]:bbox[1]+1, bbox[3]]\n             if np.all(right_col_slice == frame_color):\n                 bbox[3] -= 1 # max_c decreases\n                 refined = True\n                 if bbox[3] < bbox[2]: break # Box became invalid\n\n        # Check top row (if valid box)\n        if bbox[0] <= bbox[1] and bbox[2] <= bbox[3]: # Re-check bounds\n            top_row_slice = grid[bbox[0], bbox[2]:bbox[3]+1]\n            if np.all(top_row_slice == frame_color):\n                bbox[0] += 1 # min_r increases\n                refined = True\n                if bbox[0] > bbox[1]: break # Box became invalid\n        \n        # Check left column (if valid box)\n        if bbox[0] <= bbox[1] and bbox[2] <= bbox[3]: # Re-check bounds\n             left_col_slice = grid[bbox[0]:bbox[1]+1, bbox[2]]\n             if np.all(left_col_slice == frame_color):\n                 bbox[2] += 1 # min_c increases\n                 refined = True\n                 if bbox[2] > bbox[3]: break # Box became invalid\n\n    # Check if refinement made the box invalid\n    if bbox[0] > bbox[1] or bbox[2] > bbox[3]:\n         return [] # Return empty if refinement eliminated the box\n\n    # 4. Extract Subgrid based on final bounding box\n    min_r, max_r, min_c, max_c = bbox\n    output_grid = grid[min_r:max_r+1, min_c:max_c+1].copy()\n\n    # 5. Clean Up: Replace Frame color with Background color in the extracted grid\n    output_grid[output_grid == frame_color] = background_color\n\n    # 6. Output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12580,
    "candidates_token_count": 1678,
    "total_token_count": 14258,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.698302,
  "retries": 1
}