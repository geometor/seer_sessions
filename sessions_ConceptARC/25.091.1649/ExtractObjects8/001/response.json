{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom typing import List, Tuple, Set, Optional\n\n\"\"\"\nIdentifies the background color as the most frequent color in the input grid.\nFinds all contiguous objects of non-background colors.\nSearches for an object that forms a closed loop around a rectangular region composed solely of the background color.\nExtracts this enclosed rectangular region as the output grid.\nAssumes exactly one such enclosing object exists per input grid.\n\"\"\"\n\nGrid = List[List[int]]\nPoint = Tuple[int, int]\nObject = Set[Point]\n\ndef _find_background_color(grid_np: np.ndarray) -> int:\n    \"\"\"Finds the most frequent color in the grid.\"\"\"\n    counts = Counter(grid_np.flatten())\n    return counts.most_common(1)[0][0]\n\ndef _get_neighbors(point: Point, rows: int, cols: int) -> List[Point]:\n    \"\"\"Gets 4-directionally adjacent neighbors within grid bounds.\"\"\"\n    r, c = point\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < rows - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < cols - 1: neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_objects(grid_np: np.ndarray, background_color: int) -> List[Tuple[int, Object]]:\n    \"\"\"Finds all contiguous objects of non-background colors using BFS.\"\"\"\n    rows, cols = grid_np.shape\n    visited: Set[Point] = set()\n    objects: List[Tuple[int, Object]] = []\n\n    for r in range(rows):\n        for c in range(cols):\n            point = (r, c)\n            color = grid_np[r, c]\n            if color != background_color and point not in visited:\n                obj_color = color\n                current_object: Object = set()\n                queue: List[Point] = [point]\n                visited.add(point)\n\n                while queue:\n                    current_point = queue.pop(0)\n                    current_object.add(current_point)\n\n                    for nr, nc in _get_neighbors(current_point, rows, cols):\n                        neighbor_point = (nr, nc)\n                        if (neighbor_point not in visited and\n                            grid_np[nr, nc] == obj_color):\n                            visited.add(neighbor_point)\n                            queue.append(neighbor_point)\n                \n                if current_object:\n                    objects.append((obj_color, current_object))\n    \n    return objects\n\ndef _get_bounding_box(obj: Object) -> Tuple[int, int, int, int]:\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for an object.\"\"\"\n    min_r = min(r for r, c in obj)\n    min_c = min(c for r, c in obj)\n    max_r = max(r for r, c in obj)\n    max_c = max(c for r, c in obj)\n    return min_r, min_c, max_r, max_c\n\ndef _check_enclosure(grid_np: np.ndarray, obj: Object, bbox: Tuple[int, int, int, int], background_color: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Checks if the object encloses a rectangular region of background color.\n    Returns the bounds of the enclosed region (r1, c1, r2, c2) or None.\n    \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    rows, cols = grid_np.shape\n\n    # Define potential enclosed region bounds (exclusive of object bounds)\n    enclosed_r1, enclosed_c1 = min_r + 1, min_c + 1\n    enclosed_r2, enclosed_c2 = max_r - 1, max_c - 1\n\n    # Check if the potential enclosed region is valid (at least 1x1)\n    if enclosed_r1 > enclosed_r2 or enclosed_c1 > enclosed_c2:\n        return None\n\n    # 1. Check if all cells within the potential enclosed region are background color\n    for r in range(enclosed_r1, enclosed_r2 + 1):\n        for c in range(enclosed_c1, enclosed_c2 + 1):\n            if grid_np[r, c] != background_color:\n                return None # Found non-background color inside\n\n    # 2. Check if the background region is truly enclosed by the object\n    # Perform a flood fill (BFS) starting from a point inside the potential enclosure.\n    # If the fill reaches the grid boundary or escapes the bounding box without hitting the object, it's not enclosed.\n    \n    q: List[Point] = [(enclosed_r1, enclosed_c1)] # Start fill from top-left inner corner\n    visited_fill: Set[Point] = {(enclosed_r1, enclosed_c1)}\n    \n    while q:\n        curr_r, curr_c = q.pop(0)\n\n        # Check neighbors\n        for nr, nc in _get_neighbors((curr_r, curr_c), rows, cols):\n            neighbor = (nr, nc)\n            \n            # If neighbor is outside the object's bounding box, it means the background escaped\n            if not (min_r <= nr <= max_r and min_c <= nc <= max_c):\n                 return None # Escaped the bounding box\n\n            # If neighbor is part of the object, we stop exploring this path (it's bounded)\n            if neighbor in obj:\n                continue\n                \n            # If neighbor is background and inside the potential enclosure bounds and not visited\n            if (enclosed_r1 <= nr <= enclosed_r2 and \n                enclosed_c1 <= nc <= enclosed_c2 and \n                neighbor not in visited_fill and\n                grid_np[nr, nc] == background_color):\n                 visited_fill.add(neighbor)\n                 q.append(neighbor)\n            # If neighbor is background BUT outside the inner rectangle (i.e., between bbox and inner rect)\n            # it must be bounded by the object. If we reach here without hitting the object, it implies\n            # a gap in the enclosing object. However, the previous check for non-background inside *should*\n            # implicitly handle this alongside the bounding box check.\n            # A simpler check: did the fill cover ALL background cells within the inner rectangle?\n            \n    # After the fill, check if all cells in the inner rectangle were visited.\n    # If not, it means the inner area wasn't contiguous or the fill was stopped prematurely (shouldn't happen here).\n    # But more importantly, the fill should *not* have escaped the bounding box. If we reached here, it implies\n    # the fill was contained.\n    \n    # Verify that every cell *on the boundary* of the inner rectangle has a neighbor in the object\n    # This adds robustness.\n    for r in range(enclosed_r1, enclosed_r2 + 1):\n        for c in [enclosed_c1, enclosed_c2]: # Left and Right boundaries\n             if grid_np[r,c] == background_color: # Only check background cells on boundary\n                has_obj_neighbor = False\n                for nr, nc in _get_neighbors((r, c), rows, cols):\n                    if (nr, nc) in obj:\n                        has_obj_neighbor = True\n                        break\n                if not has_obj_neighbor: return None # Gap found\n                \n    for c in range(enclosed_c1 + 1, enclosed_c2): # Top and Bottom boundaries (excluding corners already checked)\n         for r in [enclosed_r1, enclosed_r2]:\n             if grid_np[r,c] == background_color: # Only check background cells on boundary\n                has_obj_neighbor = False\n                for nr, nc in _get_neighbors((r, c), rows, cols):\n                    if (nr, nc) in obj:\n                        has_obj_neighbor = True\n                        break\n                if not has_obj_neighbor: return None # Gap found\n\n    # If all checks pass, it's enclosed\n    return enclosed_r1, enclosed_c1, enclosed_r2, enclosed_c2\n\n\ndef transform(input_grid: Grid) -> Grid:\n    \"\"\"\n    Transforms the input grid by finding a non-background object that encloses\n    a rectangular area of the background color, and returning that area.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    if rows == 0 or cols == 0:\n        return [] # Handle empty input\n\n    # 1. Identify the background color\n    background_color = _find_background_color(input_grid_np)\n\n    # 2. Find all distinct non-background objects\n    objects = _find_objects(input_grid_np, background_color)\n\n    # 3. Search for the enclosing object and its enclosed region\n    enclosed_region_bounds = None\n    for obj_color, obj_coords in objects:\n        if not obj_coords: continue # Skip if object is somehow empty\n\n        # Calculate bounding box\n        bbox = _get_bounding_box(obj_coords)\n        \n        # Check if this object encloses a background rectangle\n        potential_bounds = _check_enclosure(input_grid_np, obj_coords, bbox, background_color)\n\n        if potential_bounds:\n            # Found the enclosing object and region, assume only one exists\n            enclosed_region_bounds = potential_bounds\n            break # Stop searching\n\n    # 4. Extract the enclosed region if found\n    if enclosed_region_bounds:\n        r1, c1, r2, c2 = enclosed_region_bounds\n        # Slice the numpy array to get the subgrid\n        output_grid_np = input_grid_np[r1:r2+1, c1:c2+1]\n        # Convert back to list of lists\n        output_grid = output_grid_np.tolist()\n    else:\n        # If no enclosing object is found (or the logic doesn't match an example)\n        # return an empty grid or handle as an error/default case.\n        # For now, returning an empty grid based on the primary hypothesis.\n        # This part might need revision based on Example 2's discrepancy.\n        output_grid = [] \n        # Alternatively, could return the input or a specific error pattern.\n        # Given the discrepancy, returning empty seems safest for now.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 5596,
            "end_index": 5822,
            "uri": "https://github.com/Anuj-cs20/IIITDMK_CSE_Coursework",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3000,
    "candidates_token_count": 2526,
    "total_token_count": 5526,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.150744,
  "retries": 1
}