{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies unique non-white colors in the input grid. For each color, it finds all contiguous objects, counts them, and identifies the 'largest' object (most pixels, tie-broken by top-left position). It determines the bounding box (height H, width W) and top-left position (r, c) of this largest object. The output grid height is H (assumed consistent across largest objects of all colors). The width of the rectangle for each color is W, plus 1 if its object count equals the maximum object count found across all colors. These rectangles are then ordered based on the (r, c) position of their corresponding largest objects in the input and concatenated horizontally to form the final output grid.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"Finds all contiguous objects of a specific color in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and not visited[r, c]:\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store object pixels and bounding box info\n                objects.append({\n                    'pixels': obj_pixels,\n                    'size': len(obj_pixels),\n                    'top_left': (min_r, min_c),\n                    'bounding_box': (min_r, min_c, max_r, max_c) \n                })\n    return objects\n\ndef get_bounding_box_dims(bbox):\n    \"\"\"Calculates height and width from bounding box coordinates.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height, width\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described logic.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n    \n    # 1. Identify unique non-white colors\n    unique_colors = sorted([c for c in np.unique(input_grid_np) if c != 0])\n    \n    color_data = []\n    max_obj_count = 0\n    output_height = -1 # Initialize to check consistency later\n\n    # 2. Process each color\n    for color in unique_colors:\n        # a. Find all objects of this color\n        objects = find_objects(input_grid_np, color)\n        if not objects: # Should not happen if color was found by unique\n            continue \n            \n        # b. Count objects\n        obj_count = len(objects)\n        max_obj_count = max(max_obj_count, obj_count)\n        \n        # c. Find the largest object (size, then top-left tiebreak)\n        largest_object = max(objects, key=lambda obj: (obj['size'], -obj['top_left'][0], -obj['top_left'][1]))\n        \n        # d. Determine bounding box dimensions of largest object\n        bbox = largest_object['bounding_box']\n        height, width = get_bounding_box_dims(bbox)\n\n        # e. Record top-left position of largest object\n        top_left_r, top_left_c = largest_object['top_left']\n\n        # Store data for this color\n        color_data.append({\n            'color': color,\n            'obj_count': obj_count,\n            'largest_obj_H': height,\n            'largest_obj_W': width,\n            'largest_obj_r': top_left_r,\n            'largest_obj_c': top_left_c,\n        })\n\n        # 3. Check and set output height (should be consistent)\n        if output_height == -1:\n            output_height = height\n        elif output_height != height:\n            # This case might require adjustment if heights differ, \n            # but based on examples, they seem consistent.\n            print(f\"Warning: Inconsistent largest object heights found ({output_height} vs {height} for color {color}). Using first found height.\")\n\n\n    # 4. (Max object count already found in step 2)\n    \n    # 5. Sort color data based on largest object position (row, then column)\n    # Step 6 combined here\n    sorted_color_data = sorted(color_data, key=lambda x: (x['largest_obj_r'], x['largest_obj_c']))\n\n    # 7. Construct output grid\n    output_rectangles = []\n    for data in sorted_color_data:\n        # a. Determine rectangle width\n        base_width = data['largest_obj_W']\n        output_width = base_width + 1 if data['obj_count'] == max_obj_count else base_width\n        \n        # b. Create solid rectangle\n        rectangle = np.full((output_height, output_width), data['color'], dtype=input_grid_np.dtype)\n        \n        # c. Append to list\n        output_rectangles.append(rectangle)\n\n    # 8. Concatenate rectangles horizontally\n    if not output_rectangles: # Handle empty input or input with only background\n        return np.array([[]], dtype=input_grid_np.dtype) # Or handle as appropriate\n\n    output_grid = np.hstack(output_rectangles)\n    \n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4228,
    "candidates_token_count": 1538,
    "total_token_count": 5766,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.522647,
  "retries": 1
}