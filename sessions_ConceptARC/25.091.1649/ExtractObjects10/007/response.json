{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nAnalyzes the input grid to determine the most frequent pixel color (background_color).\nSearches the input grid exhaustively to identify all unique rectangular subgrids (patterns) \nand counts their occurrences. Filters these patterns to keep only those that are repeating \n(appear more than once), are not monochromatic (contain more than one color), and do not \ncontain the background_color. From the remaining valid patterns, selects the one with the \nlargest area (height * width). Assumes a unique largest pattern exists among the valid \ncandidates based on the provided examples. Returns a single instance of this selected pattern.\n\"\"\"\n\ndef find_most_frequent_color(grid_np):\n    \"\"\"\n    Finds the most frequent color in a numpy grid.\n    Handles empty grid case.\n    In case of a tie, returns the color with the lowest numerical value among the most frequent ones\n    due to how np.unique and np.argmax work.\n    \"\"\"\n    if grid_np.size == 0:\n        return -1 # Indicate error or empty grid\n    colors, counts = np.unique(grid_np, return_counts=True)\n    if counts.size == 0:\n         return -1 # Should not happen if grid_np.size > 0, but safe check\n    return colors[np.argmax(counts)]\n\ndef is_monochromatic(grid_np):\n    \"\"\"\n    Checks if a numpy grid contains only one unique color value.\n    Considers empty grids or grids with only one pixel as monochromatic.\n    \"\"\"\n    # Ensure the grid is not empty before checking unique elements\n    if grid_np.size == 0:\n        return True # Define empty grid as monochromatic for safety\n    return np.unique(grid_np).size <= 1\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies and returns the largest, repeating, non-monochromatic pattern\n    that does not contain the input grid's most frequent color.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the identified pattern, or an empty list\n        if no such pattern is found or the input is invalid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    try:\n        grid_np = np.array(input_grid, dtype=int)\n    except ValueError:\n        # Handle potentially inconsistent row lengths or non-integer data\n        return [] \n\n    H, W = grid_np.shape\n\n    # Handle edge case of empty input grid\n    if H == 0 or W == 0:\n        return []\n\n    # Step 1: Determine the background color (most frequent color)\n    background_color = find_most_frequent_color(grid_np)\n    if background_color == -1:\n        # This case implies the grid was effectively empty or finding color failed\n        return []\n\n    # Step 2: Identify all unique subgrids and count their occurrences.\n    # Store patterns using a key derived from bytes and shape for efficiency and hashability.\n    pattern_info = defaultdict(lambda: {'count': 0, 'array': None})\n\n    # Iterate through all possible pattern heights (ph) and widths (pw)\n    for ph in range(1, H + 1):\n        for pw in range(1, W + 1):\n            # Iterate through all possible top-left starting positions (r, c)\n            for r in range(H - ph + 1):\n                for c in range(W - pw + 1):\n                    # Extract the subgrid\n                    subgrid_np = grid_np[r:r+ph, c:c+pw]\n                    # Create a robust key including shape information\n                    subgrid_key = subgrid_np.tobytes() + b\"_\" + str(subgrid_np.shape).encode()\n\n                    # Increment count for this pattern\n                    pattern_info[subgrid_key]['count'] += 1\n                    # Store the numpy array representation only once\n                    if pattern_info[subgrid_key]['array'] is None:\n                         pattern_info[subgrid_key]['array'] = subgrid_np\n\n    # Step 3: Filter patterns to find candidates meeting criteria\n    candidate_patterns = []\n    for pattern_data in pattern_info.values():\n        # Ensure pattern data is valid (array was stored)\n        if pattern_data['array'] is None:\n            continue\n            \n        count = pattern_data['count']\n        pattern_np = pattern_data['array']\n\n        # Check criteria:\n        # a. Appears more than once (repeating)\n        if count > 1:\n            # b. Is not monochromatic\n            if not is_monochromatic(pattern_np):\n                # c. Does not contain the background color\n                # Need to check if pattern_np is empty before calling np.unique\n                if pattern_np.size > 0 and background_color not in np.unique(pattern_np):\n                    # This pattern meets all criteria, add it to candidates\n                    candidate_patterns.append(pattern_np)\n\n    # Step 4: Select the pattern with the largest area from the candidates\n    if not candidate_patterns:\n        # No pattern found matching all criteria\n        return []\n    else:\n        # Find the pattern with the maximum area (height * width).\n        # Python's max function with a key is suitable here.\n        # Assumes a unique largest pattern exists based on examples.\n        # No specific tie-breaking rule defined beyond max area.\n        largest_pattern = max(candidate_patterns, key=lambda p: p.shape[0] * p.shape[1])\n\n        # Step 5: Return the selected pattern as a list of lists\n        return largest_pattern.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11315,
    "candidates_token_count": 1322,
    "total_token_count": 12637,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.863894,
  "retries": 1
}