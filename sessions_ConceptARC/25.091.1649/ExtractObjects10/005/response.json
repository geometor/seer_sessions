{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nDetermines the most frequent color in the input grid (background_color).\nIdentifies all unique rectangular subgrids (patterns) and counts their occurrences.\nFilters these patterns to keep only those that:\n1. Appear more than once (are repeating).\n2. Are not monochromatic (contain more than one color).\n3. Do not contain the background_color.\nAssumes exactly one pattern meets these criteria and returns it.\n\"\"\"\n\ndef find_most_frequent_color(grid_np):\n    \"\"\"\n    Finds the most frequent color in a numpy grid.\n    Handles empty grid case.\n    In case of a tie, returns the color with the lowest numerical value among the most frequent ones\n    due to how np.unique and np.argmax work.\n    \"\"\"\n    if grid_np.size == 0:\n        return -1 # Indicate error or empty grid\n    colors, counts = np.unique(grid_np, return_counts=True)\n    if counts.size == 0:\n         return -1 # Should not happen if grid_np.size > 0, but safe check\n    return colors[np.argmax(counts)]\n\ndef is_monochromatic(grid_np):\n    \"\"\"\n    Checks if a numpy grid contains only one unique color value.\n    Considers empty grids or grids with only one pixel as monochromatic.\n    \"\"\"\n    return np.unique(grid_np).size <= 1\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies and returns a unique repeating, non-monochromatic pattern\n    that does not contain the input grid's most frequent color.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the identified pattern, or an empty list\n        if no such pattern is found or the input is invalid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    try:\n        grid_np = np.array(input_grid, dtype=int)\n    except ValueError:\n        # Handle potentially inconsistent row lengths or non-integer data\n        return [] \n\n    H, W = grid_np.shape\n\n    # Handle edge case of empty input grid\n    if H == 0 or W == 0:\n        return []\n\n    # Step 1: Determine the background color (most frequent color)\n    background_color = find_most_frequent_color(grid_np)\n    if background_color == -1:\n        # This case implies the grid was effectively empty after conversion or contained no elements\n        return []\n\n    # Step 2 & 3: Identify all unique subgrids and count their occurrences.\n    # Store patterns using their byte representation as a key for efficiency and hashability.\n    pattern_info = defaultdict(lambda: {'count': 0, 'array': None})\n\n    # Iterate through all possible pattern heights (ph) and widths (pw)\n    for ph in range(1, H + 1):\n        for pw in range(1, W + 1):\n            # Iterate through all possible top-left starting positions (r, c)\n            for r in range(H - ph + 1):\n                for c in range(W - pw + 1):\n                    # Extract the subgrid\n                    subgrid_np = grid_np[r:r+ph, c:c+pw]\n                    # Use the byte representation of the array as the key\n                    subgrid_key = subgrid_np.tobytes() \n\n                    # Increment count for this pattern\n                    pattern_info[subgrid_key]['count'] += 1\n                    # Store the numpy array representation only once\n                    if pattern_info[subgrid_key]['array'] is None:\n                         pattern_info[subgrid_key]['array'] = subgrid_np\n\n    # Step 4: Filter patterns to find candidates meeting criteria\n    candidate_patterns = []\n    for pattern_data in pattern_info.values():\n        # Ensure pattern data is valid (array was stored)\n        if pattern_data['array'] is None:\n            continue\n            \n        count = pattern_data['count']\n        pattern_np = pattern_data['array']\n\n        # Check criteria:\n        # a. Appears more than once\n        if count > 1:\n            # b. Is not monochromatic\n            if not is_monochromatic(pattern_np):\n                # c. Does not contain the background color\n                if background_color not in np.unique(pattern_np):\n                    # This pattern meets all criteria, add it to candidates\n                    candidate_patterns.append(pattern_np)\n\n    # Step 5: Select and return the assumed unique pattern\n    if len(candidate_patterns) == 1:\n        # Found exactly one pattern meeting all criteria\n        # Return the chosen pattern converted back to list of lists format\n        return candidate_patterns[0].tolist()\n    elif len(candidate_patterns) > 1:\n        # If multiple candidates exist (unexpected based on examples),\n        # default to returning the one with the smallest area, then smallest height as a fallback tie-breaker.\n        # This matches the initial guess before uniqueness was assumed.\n        # You might want to refine this logic if the task allows multiple valid outputs.\n        candidate_patterns.sort(key=lambda p: (p.shape[0] * p.shape[1], p.shape[0]))\n        print(\"Warning: Multiple candidate patterns found. Returning the smallest one.\")\n        return candidate_patterns[0].tolist()\n    else:\n        # No pattern found matching all criteria\n        return []\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8667,
    "candidates_token_count": 1270,
    "total_token_count": 9937,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.279912,
  "retries": 1
}