{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nAnalyzes the input grid to find the most frequent pixel color (background_color).\nSearches the input grid for all unique subgrids (patterns) that appear more than once.\nFilters these repeating patterns to exclude any that are monochromatic or contain the background_color.\nFrom the remaining valid candidate patterns, selects the one with the largest area (height * width).\nIf there's a tie in area, the current implementation relies on the stability of the sort or the first encountered pattern during iteration, which seems sufficient for the provided examples.\nReturns a single instance of the selected pattern.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\n\ndef find_most_frequent_color(grid_np):\n    \"\"\"\n    Finds the most frequent color in a numpy grid.\n    Handles empty grid case.\n    In case of a tie, returns the color with the lowest numerical value among the most frequent ones\n    due to how np.unique and np.argmax work.\n    \"\"\"\n    if grid_np.size == 0:\n        return -1 # Indicate error or empty grid\n    colors, counts = np.unique(grid_np, return_counts=True)\n    if counts.size == 0:\n         return -1 # Should not happen if grid_np.size > 0, but safe check\n    return colors[np.argmax(counts)]\n\ndef is_monochromatic(grid_np):\n    \"\"\"\n    Checks if a numpy grid contains only one unique color value.\n    Considers empty grids or grids with only one pixel as monochromatic.\n    \"\"\"\n    return np.unique(grid_np).size <= 1\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies the largest, non-monochromatic, repeating pattern in the input grid\n    that does not contain the grid's most frequent color (background color).\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the identified pattern, or an empty list\n        if no such pattern is found or the input is invalid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    try:\n        grid_np = np.array(input_grid, dtype=int)\n    except ValueError:\n        return [] # Handle potentially inconsistent row lengths\n\n    H, W = grid_np.shape\n\n    # Handle edge case of empty input grid\n    if H == 0 or W == 0:\n        return []\n\n    # Step 1: Identify the background color (most frequent color)\n    background_color = find_most_frequent_color(grid_np)\n    # Handle case where finding color failed (e.g., truly empty grid processed unexpectedly)\n    if background_color == -1:\n        return []\n\n    # Step 2: Find all unique subgrids and count their occurrences.\n    # Store patterns as tuples (hashable key) mapped to their count and np array.\n    pattern_info = defaultdict(lambda: {'count': 0, 'array': None})\n\n    # Iterate through all possible pattern heights (ph) and widths (pw)\n    for ph in range(1, H + 1):\n        for pw in range(1, W + 1):\n            # Iterate through all possible top-left starting positions (r, c)\n            for r in range(H - ph + 1):\n                for c in range(W - pw + 1):\n                    # Extract the subgrid\n                    subgrid_np = grid_np[r:r+ph, c:c+pw]\n                    # Convert the numpy subgrid to a tuple of tuples for use as a dictionary key\n                    # Using bytes representation can be faster for hashing large arrays\n                    subgrid_key = subgrid_np.tobytes() + str(subgrid_np.shape)\n\n                    # Increment count for this pattern\n                    pattern_info[subgrid_key]['count'] += 1\n                    # Store the numpy array representation if not already stored\n                    if pattern_info[subgrid_key]['array'] is None:\n                         pattern_info[subgrid_key]['array'] = subgrid_np\n\n    # Step 3: Filter patterns to find candidates meeting criteria\n    candidate_patterns = []\n    for pattern_data in pattern_info.values():\n        # Ensure pattern data is valid before processing\n        if pattern_data['array'] is None:\n            continue\n            \n        count = pattern_data['count']\n        pattern_np = pattern_data['array']\n\n        # Check if pattern repeats (appears more than once)\n        if count > 1:\n            # Check if pattern is non-monochromatic\n            if not is_monochromatic(pattern_np):\n                # Check if pattern contains the background color\n                if background_color not in np.unique(pattern_np):\n                    # This pattern meets all criteria, add it to candidates\n                    candidate_patterns.append(pattern_np)\n\n    # Step 4 & 5: Select the final pattern (largest area) from candidates and return it\n    if not candidate_patterns:\n        # No pattern found matching all criteria\n        return []\n    else:\n        # Select the 'best' one: largest area (height * width).\n        # Python's max function with a key is efficient here.\n        # No explicit tie-breaking needed based on examples; max naturally picks one if ties exist.\n        largest_pattern = max(candidate_patterns, key=lambda p: p.shape[0] * p.shape[1])\n\n        # Return the chosen pattern converted back to list of lists format\n        return largest_pattern.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8900,
    "candidates_token_count": 1262,
    "total_token_count": 10162,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.01118,
  "retries": 1
}