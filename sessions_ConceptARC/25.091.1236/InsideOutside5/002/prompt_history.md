
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 0 3 3 3 3 0 0 0
0 0 2 0 0 0 0 0 0 2 0 3 0 0 3 0 0 0
0 0 2 0 4 4 4 0 0 2 0 3 0 0 3 0 0 0
0 0 2 0 4 0 4 0 0 2 0 3 3 3 3 0 0 0
0 0 2 0 4 4 4 0 0 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 2 0 0 6 6 6 0 0 0
0 0 2 2 2 2 2 2 2 2 0 0 6 0 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
6 6 0 0 4 0 4 0 0 0 0 0 0 0 0
6 6 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 5 5 5 5 5 5 0 0
7 7 7 0 0 0 0 5 0 0 0 0 5 0 0
7 7 7 0 0 0 0 5 0 3 3 0 5 0 0
7 7 7 0 0 0 0 5 0 3 3 0 5 0 0
0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 5 5 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0 0 0
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 9 9 9 9 9 0 0
0 0 7 0 0 8 8 8 8 8 8 8 8 8 8 0 7 0 9 0 0 0 9 0 0
0 0 7 0 0 8 0 0 0 0 0 0 0 0 8 0 7 0 9 0 0 0 9 0 0
0 0 7 0 0 8 0 0 3 3 3 3 0 0 8 0 7 0 9 9 9 9 9 0 0
0 0 7 0 0 8 0 0 3 3 3 3 0 0 8 0 7 0 0 0 0 0 0 0 0
0 0 7 0 0 8 0 0 0 0 0 0 0 0 8 0 7 0 3 3 3 3 3 3 3
0 0 7 0 0 8 8 8 8 8 8 8 8 8 8 0 7 0 3 0 0 0 0 0 3
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 3 0 8 8 8 0 3
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 3 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 3 3 3 3 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 3 3 3 3 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's break down this task.

**Perception**

1.  **Input Structure:** The input grids contain multiple distinct shapes or objects, each composed of pixels of a single color, set against a white background (color 0).
2.  **Object Types:** Many objects appear to be hollow rectangular frames or closed loops (e.g., the red, green, magenta frames in train_1; gray, orange, maroon, green frames in train_2 and train_3). Other objects are solid shapes found *inside* these frames (e.g., yellow 'C' in train_1; green rectangle in train_2; green cross and azure 'T' in train_3). Some objects are neither frames nor inside frames (e.g., magenta 'L', yellow 'C', orange block in train_2).
3.  **Output Structure:** The output grid is the same size as the input grid. It contains only a subset of the objects present in the input, placed in their original positions. All other pixels, including the background and removed objects, are white (color 0).
4.  **Transformation Logic:** The core transformation seems to involve identifying objects that are enclosed or contained within other objects (specifically, the frame-like objects). Crucially, only the *innermost* contained objects are preserved in the output. The containing objects (frames) themselves are removed, as are any objects not contained within another.
5.  **Containment Definition:** An object appears to be "contained" if it resides entirely within the boundary of a frame object without touching the frame's pixels. In cases of nested containment (like the green cross inside the azure frame inside the orange frame in train_3), only the object that is contained but does not itself contain another object is kept.

**Facts**


```yaml
task_elements:
  - object_type: Grid
    description: A 2D array of pixels with integer values 0-9 representing colors.
  - object_type: Pixel
    properties:
      - color: Integer value 0-9. White (0) typically represents the background.
      - position: (row, column) coordinates within the grid.
  - object_type: Object
    description: A contiguous group of pixels of the same non-white color.
    properties:
      - color: The color of the pixels forming the object.
      - pixels: Set of (row, column) coordinates belonging to the object.
      - bounding_box: The minimum rectangle enclosing all pixels of the object.
    relationships:
      - spatial_relation: Can be contained within another object.
      - spatial_relation: Can contain another object.
      - spatial_relation: Can be adjacent to another object.
  - object_type: Frame
    description: A specific type of object, often appearing as a hollow shape or closed loop, capable of enclosing other objects.
    properties: Inherits properties from Object.
  - object_type: Content
    description: An object that can potentially be located inside a Frame.
    properties: Inherits properties from Object.

actions:
  - name: Identify Objects
    description: Segment the input grid into distinct, contiguous non-white objects.
  - name: Determine Containment
    description: For each pair of objects (A, B), determine if object A is fully contained within object B without touching it. This might involve checking bounding boxes and spatial relationships, potentially considering the area enclosed by frame-like objects.
  - name: Filter Objects
    description: Select only those objects that meet specific criteria based on containment relationships.
  - name: Construct Output
    description: Create a new grid of the same dimensions as the input, initially all white. Place the selected/filtered objects onto this grid in their original positions and colors.

transformation_rule:
  - step: Identify all distinct non-white objects in the input grid.
  - step: For each object, determine if it contains any other object(s) within its boundaries.
  - step: For each object, determine if it is contained within another object.
  - step: Retain only those objects that are contained within another object *but* do not themselves contain any other object (i.e., the innermost contained objects).
  - step: Generate the output grid by placing the retained objects at their original positions on a white background of the same size as the input grid. Discard all other objects (including frames and objects not contained).
```


**Natural Language Program**

1.  Initialize an empty output grid with the same dimensions as the input grid, filled with the background color (white, 0).
2.  Find all connected components (objects) of non-background-colored pixels in the input grid. Record each object's color, pixel coordinates, and bounding box.
3.  Create two lists: `contained_objects` and `containing_objects`.
4.  Iterate through all pairs of distinct identified objects (Object A, Object B):
    a.  Check if Object A is strictly geometrically contained within the bounding box of Object B.
    b.  Check if Object A's pixels are not adjacent (including diagonally) to any pixel *outside* the bounding box of Object B (this helps confirm it's truly "inside" and not just touching an edge of B that coincides with the grid boundary).
    c.  Check if Object A's pixels are not adjacent (including diagonally) to any of Object B's pixels.
    d.  If all conditions (a, b, c) are met, consider Object A to be contained by Object B. Add Object A to the `contained_objects` list and Object B to the `containing_objects` list.
5.  Identify the set of "innermost" objects: These are the objects present in the `contained_objects` list but *not* present in the `containing_objects` list.
6.  For each identified "innermost" object:
    a.  Retrieve its original color and pixel coordinates.
    b.  Draw these pixels onto the output grid using their original color.
7.  Return the final output grid.
```python
import numpy as np
from collections import deque

"""
Transformation Rule:
1. Identify all distinct non-white objects (connected components of the same color) in the input grid.
2. For each object, determine if it is contained within another object. An object 'A' is considered contained within object 'B' if all pixels of 'A' are within the bounding box of 'B', and no pixel of 'A' is adjacent (including diagonally) to any pixel of 'B'.
3. Identify objects that are contained within at least one other object.
4. Identify objects that contain at least one other object.
5. Select only those objects that are contained but do not themselves contain any other object (i.e., the innermost contained objects).
6. Create an output grid of the same dimensions as the input, initialized with the background color (white, 0).
7. Draw the selected innermost objects onto the output grid in their original positions and colors. Discard all other objects.
"""

def _get_neighbors(r, c, rows, cols):
    """ Get 8-connectivity neighbors within grid bounds """
    neighbors = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbors.append((nr, nc))
    return neighbors

def _find_objects(grid):
    """ Finds all connected components (objects) of non-background colors. """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    object_id_counter = 0

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_coords = set()
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, min_c = r, c
                max_r, max_c = r, c

                while q:
                    curr_r, curr_c = q.popleft()
                    obj_coords.add((curr_r, curr_c))
                    min_r = min(min_r, curr_r)
                    min_c = min(min_c, curr_c)
                    max_r = max(max_r, curr_r)
                    max_c = max(max_c, curr_c)

                    # Find neighbors of the same color using 4-connectivity for object definition
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                         nr, nc = curr_r + dr, curr_c + dc
                         if 0 <= nr < rows and 0 <= nc < cols and \
                            not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))

                objects.append({
                    'id': object_id_counter,
                    'color': color,
                    'coords': obj_coords,
                    'bbox': (min_r, min_c, max_r, max_c)
                })
                object_id_counter += 1
    return objects

def _is_strictly_contained(obj_a, obj_b, grid_shape):
    """ Checks if obj_a is strictly contained within obj_b without touching. """
    coords_a = obj_a['coords']
    coords_b = obj_b['coords']
    bbox_a = obj_a['bbox']
    bbox_b = obj_b['bbox']
    rows, cols = grid_shape

    # 1. Bounding box check: A's bbox must be strictly inside B's bbox
    if not (bbox_b[0] < bbox_a[0] and bbox_b[1] < bbox_a[1] and \
            bbox_a[2] < bbox_b[2] and bbox_a[3] < bbox_b[3]):
         # Allow bbox edges to touch if frame is thin
         if not (bbox_b[0] <= bbox_a[0] and bbox_b[1] <= bbox_a[1] and \
                 bbox_a[2] <= bbox_b[2] and bbox_a[3] <= bbox_b[3]):
            return False
         # If bounding boxes touch or overlap exactly, still need further checks


    # 2. Adjacency check: No pixel in A should be adjacent (8-way) to any pixel in B
    for r_a, c_a in coords_a:
        for nr, nc in _get_neighbors(r_a, c_a, rows, cols):
            if (nr, nc) in coords_b:
                return False # Adjacent to B

    # 3. Ensure A is actually "inside" B.
    # A simple proxy: check if any point in A can reach the boundary of B's bbox
    # without crossing B. A more robust check involves pathfinding, but let's
    # assume the adjacency check is sufficient for typical frame structures.
    # If A's bbox is inside B's bbox and they are not adjacent, it implies containment for simple shapes.

    # Check if A's coordinates are all contained within B's bounding box
    for r_a, c_a in coords_a:
        if not (bbox_b[0] <= r_a <= bbox_b[2] and bbox_b[1] <= c_a <= bbox_b[3]):
            return False # A pixel of A is outside B's bounding box

    return True


def transform(input_grid):
    """
    Identifies objects contained within other objects but not containing any themselves,
    and places these innermost objects on a new grid.
    """
    rows, cols = input_grid.shape
    output_grid = np.zeros_like(input_grid)

    # 1. Find all objects
    objects = _find_objects(input_grid)
    if not objects:
        return output_grid

    num_objects = len(objects)
    is_contained_by = [set() for _ in range(num_objects)] # Stores IDs of containers for each object
    contains = [set() for _ in range(num_objects)]       # Stores IDs of contained objects for each object

    # 2. Determine containment relationships
    for i in range(num_objects):
        for j in range(num_objects):
            if i == j:
                continue
            obj_a = objects[i]
            obj_b = objects[j]
            # Check if object i is strictly contained within object j
            if _is_strictly_contained(obj_a, obj_b, (rows, cols)):
                is_contained_by[i].add(j)
                contains[j].add(i)

    # 3. Identify innermost objects
    innermost_objects = []
    for i in range(num_objects):
        # Object i is contained (is_contained_by[i] is not empty)
        # AND Object i does not contain any other object (contains[i] is empty)
        if is_contained_by[i] and not contains[i]:
            innermost_objects.append(objects[i])

    # 4. Construct the output grid
    for obj in innermost_objects:
        color = obj['color']
        for r, c in obj['coords']:
            output_grid[r, c] = color

    return output_grid
```
