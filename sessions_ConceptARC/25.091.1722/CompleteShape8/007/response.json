{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identifies all unique colors present in the input grid, excluding the background color (white, 0) and gray (5). These are 'target colors'.\n2. For each target color:\n    a. Finds all pixels in the input grid matching that color.\n    b. Calculates the top-left corner (minimum row, minimum column) of the bounding box containing *all* pixels of that color collectively.\n    c. Draws a single 3x3 square of that target color onto an initially white output grid, starting at the calculated overall top-left corner. If squares for different colors overlap, the behavior for overlaps isn't explicitly defined by the examples but processing colors numerically seems reasonable (higher values overwrite lower).\n3. Gray pixels (5) from the input are ignored and effectively removed in the output.\n4. The output grid has the same dimensions as the input grid and is initialized to white (0).\n\"\"\"\n\ndef get_color_pixels(grid, color):\n    \"\"\"\n    Finds all coordinates (row, col) in the grid matching the specified color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to find.\n\n    Returns:\n        list: A list of (row, col) tuples for pixels matching the color.\n              Returns an empty list if the color is not found.\n    \"\"\"\n    # Use np.where to efficiently find the indices where the grid matches the color\n    rows, cols = np.where(grid == color)\n    # Combine the row and column indices into a list of (row, col) tuples\n    return list(zip(rows, cols))\n\ndef get_overall_bounding_box_top_left(pixels):\n    \"\"\"\n    Calculates the top-left corner (min_row, min_col) of the bounding box\n    encompassing the given list of pixel coordinates. This considers all\n    provided pixels together to find the overall minimum row and column.\n\n    Args:\n        pixels (list): A list of (row, col) coordinates for ALL pixels of a given color.\n\n    Returns:\n        tuple: (min_row, min_col) representing the top-left corner.\n               Returns (None, None) if the pixels list is empty.\n    \"\"\"\n    if not pixels:\n        return None, None\n    # Find the minimum row index among all pixel coordinates\n    min_row = min(r for r, c in pixels)\n    # Find the minimum column index among all pixel coordinates\n    min_col = min(c for r, c in pixels)\n    return min_row, min_col\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert the input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # Initialize the output grid with the same dimensions, filled with the background color (0)\n    output_grid = np.zeros_like(input_np)\n\n    # Find all unique colors present in the input grid\n    unique_colors = np.unique(input_np)\n    # Sort the unique colors numerically. This ensures a consistent order if squares overlap.\n    # Based on example 1, overlaps don't seem intended, but sorting provides determinism.\n    unique_colors = sorted(unique_colors)\n\n\n    # Iterate through each unique color found in the input\n    for color in unique_colors:\n        # Rule 3: Skip the background color (0)\n        if color == 0:\n            continue\n        # Rule 3: Skip the ignored gray color (5)\n        if color == 5:\n            continue\n\n        # Rule 2a: Get all pixel coordinates for the current target color\n        pixels = get_color_pixels(input_np, color)\n\n        # Proceed only if pixels of this color exist\n        if pixels:\n            # Rule 2b: Calculate the top-left corner of the SINGLE bounding box for ALL these pixels\n            min_row, min_col = get_overall_bounding_box_top_left(pixels)\n\n            # Check if a valid top-left corner was found (i.e., pixels list was not empty)\n            if min_row is not None and min_col is not None:\n                # Rule 2c: Draw ONE 3x3 square of the current color onto the output grid\n                # starting from the calculated overall top-left corner.\n                for r_offset in range(3):\n                    for c_offset in range(3):\n                        # Calculate the target row and column in the output grid\n                        r_target = min_row + r_offset\n                        c_target = min_col + c_offset\n                        # Check if the target coordinates are within the grid boundaries\n                        if 0 <= r_target < height and 0 <= c_target < width:\n                            # Assign the color to the pixel in the output grid\n                            # If squares from different colors overlap, the color processed later (higher value due to sorting) will overwrite previous ones.\n                            output_grid[r_target, c_target] = color\n\n    # Convert the resulting NumPy array back to a standard list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8999,
    "candidates_token_count": 1246,
    "total_token_count": 10245,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 119.9291,
  "retries": 2
}