{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nIdentifies the largest connected component of a non-background color (main object) \nin the input grid. Finds all enclosed regions (holes) of the background color (0) \nthat are fully enclosed by this main object. \n\nThe filling logic depends on the number and properties of internal holes found:\n- If no internal holes are found, the grid remains unchanged.\n- If one or more internal holes are found:\n    - The sizes (pixel counts) of all internal holes are determined.\n    - If there is a unique largest hole among them (exactly one hole has the maximum size), all *other* internal holes (those smaller than the max size) are filled with the main object's color.\n    - Otherwise (if there is a tie for the largest hole size, or if there is only one hole), *all* internal holes are filled with the main object's color.\n\"\"\"\n\ndef get_neighbors(coords, grid_shape):\n    \"\"\" \n    Gets the set of unique orthogonal neighbor coordinates for a given set of coordinates,\n    ensuring neighbors are within grid bounds and not part of the original coordinate set.\n    \n    Args:\n        coords (np.array): A Nx2 array of coordinates (row, col).\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        set: A set of unique neighbor coordinates (row, col) tuples.\n    \"\"\"\n    neighbors = set()\n    H, W = grid_shape\n    coord_set = set(tuple(coord) for coord in coords) # For quick checking if neighbor is part of the original set\n\n    for r, c in coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal neighbors\n            nr, nc = r + dr, c + dc\n            # Check bounds and if the neighbor is not part of the original component\n            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in coord_set:\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef get_component_details(labeled_array, label_idx):\n    \"\"\"Gets coordinates and size of a specific component label.\"\"\"\n    coords = np.argwhere(labeled_array == label_idx)\n    size = len(coords)\n    return coords, size\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the hole-filling transformation based on the number and size of holes.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    background_color = 0\n\n    # Step 1: Find all connected components of non-background colors.\n    labeled_objects, num_objects = label(input_grid != background_color)\n\n    # Handle case with no non-background objects\n    if num_objects == 0:\n        return output_grid\n\n    # Step 2: Determine the largest connected component (main object).\n    object_sizes = []\n    for i in range(1, num_objects + 1):\n        coords, size = get_component_details(labeled_objects, i)\n        if size > 0:\n            object_sizes.append({'label': i, 'size': size, 'coords': coords})\n\n    if not object_sizes: # Should not happen if num_objects > 0, but safety check\n         return output_grid\n         \n    # Find the component with the maximum size\n    main_object_info = max(object_sizes, key=lambda item: item['size'])\n    main_object_label = main_object_info['label']\n    main_object_coords_arr = main_object_info['coords']\n    # Create a set for efficient neighbor checking later\n    main_object_coords_set = set(tuple(coord) for coord in main_object_coords_arr)\n    # Get the color of the main object\n    main_object_color = input_grid[main_object_coords_arr[0, 0], main_object_coords_arr[0, 1]]\n\n    # Step 3: Find all connected components of the background color.\n    labeled_background, num_bg_components = label(input_grid == background_color)\n\n    # Step 4: Identify internal holes enclosed solely by the main object.\n    internal_holes = [] \n    for i in range(1, num_bg_components + 1):\n        bg_coords, hole_size = get_component_details(labeled_background, i)\n        if hole_size == 0: continue \n\n        # Check if the component touches the border\n        touches_border = np.any((bg_coords[:, 0] == 0) | (bg_coords[:, 0] == H - 1) | \n                                (bg_coords[:, 1] == 0) | (bg_coords[:, 1] == W - 1))\n        if touches_border:\n            continue # Not an internal hole if it touches the border\n\n        # Check if this component is fully enclosed ONLY by the main object\n        is_enclosed_by_main = True\n        neighbor_coords = get_neighbors(bg_coords, (H, W))\n\n        if not neighbor_coords: \n             # Isolated background component with no neighbors? Cannot be enclosed.\n             is_enclosed_by_main = False\n        else:\n            for neighbor_coord in neighbor_coords:\n                # If any neighbor is NOT part of the main object, it's not solely enclosed by it.\n                if neighbor_coord not in main_object_coords_set:\n                     is_enclosed_by_main = False\n                     break \n                 \n        if is_enclosed_by_main:\n            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})\n\n    # Step 5: Determine which holes to fill based on the rules.\n    num_internal_holes = len(internal_holes)\n    \n    # If no internal holes, return the original grid\n    if num_internal_holes == 0:\n        return output_grid\n\n    holes_to_fill = [] # List to store hole objects (dicts) to be filled\n\n    if num_internal_holes == 1:\n        # Fill the single hole\n        holes_to_fill.append(internal_holes[0])\n    else: # num_internal_holes > 1\n        # Multiple holes: check sizes\n        hole_sizes = [h['size'] for h in internal_holes]\n        max_hole_size = max(hole_sizes)\n        max_size_count = hole_sizes.count(max_hole_size)\n        \n        if max_size_count == 1:\n            # Unique largest: fill all EXCEPT the largest\n            for hole in internal_holes:\n                if hole['size'] != max_hole_size:\n                    holes_to_fill.append(hole)\n        else:\n            # Tie for largest: fill ALL internal holes\n            holes_to_fill = internal_holes # Fill all of them\n\n    # Step 6: Fill the selected holes in the output grid.\n    for hole in holes_to_fill:\n        coords_array = hole['coords']\n        for r, c in coords_array:\n            # Check bounds just in case\n            if 0 <= r < H and 0 <= c < W:\n                output_grid[r, c] = main_object_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14161,
    "candidates_token_count": 1729,
    "total_token_count": 15890,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.736706,
  "retries": 1
}