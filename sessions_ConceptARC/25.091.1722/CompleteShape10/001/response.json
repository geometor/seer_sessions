{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nIdentifies the largest connected component of a non-background color in the input grid.\nFinds all enclosed regions (holes) of the background color within this largest component.\nCalculates the size of each hole.\nIf there is a unique largest hole among all internal holes, fills all *other* holes with the color of the largest component.\nOtherwise (if there's a tie for the largest hole, or only one hole exists), fills *all* internal holes with the color of the largest component.\nThe background color is assumed to be white (0).\n\"\"\"\n\ndef find_connected_components(grid, target_value=None, background_value=None):\n    \"\"\"\n    Finds connected components in a grid.\n\n    Args:\n        grid (np.array): The input grid.\n        target_value (int, optional): If provided, find components of this value.\n        background_value (int, optional): If provided, find components *not* of this value.\n\n    Returns:\n        tuple: (labeled_array, num_features) from scipy.ndimage.label\n               or (None, 0) if no components found or invalid args.\n    \"\"\"\n    if target_value is not None:\n        binary_grid = (grid == target_value)\n    elif background_value is not None:\n        binary_grid = (grid != background_value)\n    else:\n        # Requires either target_value or background_value\n        return None, 0\n        \n    # Default connectivity (structure) considers orthogonal neighbors:\n    # [[0,1,0],\n    #  [1,1,1],\n    #  [0,1,0]]\n    labeled_array, num_features = label(binary_grid)\n    return labeled_array, num_features\n\ndef get_component_coords(labeled_array, label_idx):\n    \"\"\"Gets the coordinates of pixels belonging to a specific component label.\"\"\"\n    return np.argwhere(labeled_array == label_idx)\n\ndef get_component_size(labeled_array, label_idx):\n    \"\"\"Gets the size (pixel count) of a specific component label.\"\"\"\n    return np.sum(labeled_array == label_idx)\n\ndef transform(input_grid):\n    \"\"\"\n    Fills internal background holes within the largest colored object,\n    except for the uniquely largest hole, if one exists.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    background_color = 0\n\n    # 1. Find all connected components of non-background colors.\n    labeled_objects, num_objects = find_connected_components(input_grid, background_value=background_color)\n\n    # Handle case with no non-background objects\n    if num_objects == 0:\n        return output_grid\n\n    # 2. Determine the largest connected component (main object).\n    object_sizes = [get_component_size(labeled_objects, i) for i in range(1, num_objects + 1)]\n    largest_object_size = 0\n    main_object_label = 0\n    if object_sizes:\n       largest_object_size = max(object_sizes)\n       # Find the first label corresponding to the max size (handles ties by picking one)\n       main_object_label = object_sizes.index(largest_object_size) + 1 \n       \n    # Handle edge case maybe? if main_object_label remains 0 something went wrong or no objects\n    if main_object_label == 0:\n         return output_grid # Should have been caught by num_objects == 0 check\n\n    # 3. Get the color of the main object.\n    main_object_coords = get_component_coords(labeled_objects, main_object_label)\n    # Check if coords were found before accessing\n    if len(main_object_coords) == 0:\n        # This shouldn't happen if main_object_label > 0 and based on a valid size\n        return output_grid \n    main_object_color = input_grid[main_object_coords[0, 0], main_object_coords[0, 1]]\n\n    # 4. Find all connected components of the background color.\n    labeled_background, num_background_components = find_connected_components(input_grid, target_value=background_color)\n\n    # 5. Identify internal holes (background components not touching the border).\n    internal_holes = [] # Store tuples of (label_index, size, coordinates)\n    for i in range(1, num_background_components + 1):\n        bg_coords = get_component_coords(labeled_background, i)\n        if len(bg_coords) == 0:\n            continue # Skip if component somehow has no coords\n\n        # Check if any coordinate touches the border\n        touches_border = np.any((bg_coords[:, 0] == 0) | (bg_coords[:, 0] == H - 1) | \n                                (bg_coords[:, 1] == 0) | (bg_coords[:, 1] == W - 1))\n\n        if not touches_border:\n            # It's an internal hole candidate. We assume based on task structure\n            # that these are holes within the 'main object' context.\n            hole_size = len(bg_coords)\n            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})\n\n    # 6. If no internal holes are found, return the original grid.\n    if not internal_holes:\n        return output_grid\n\n    # 7. Calculate sizes and find the maximum size among internal holes.\n    hole_sizes = [hole['size'] for hole in internal_holes]\n    if not hole_sizes: # Should be caught by 'if not internal_holes', but safety check\n        return output_grid\n        \n    max_hole_size = max(hole_sizes)\n\n    # 8. Count how many holes share this maximum size.\n    max_size_count = hole_sizes.count(max_hole_size)\n\n    # 9. Determine which holes to fill and modify the output grid.\n    holes_to_fill = []\n    if max_size_count == 1:\n        # Fill all holes EXCEPT the unique largest one\n        for hole in internal_holes:\n            if hole['size'] != max_hole_size:\n                holes_to_fill.append(hole)\n    else:\n        # Fill ALL internal holes (tie for largest, or only one hole exists which is max)\n        holes_to_fill = internal_holes\n\n    # 10. Fill the selected holes with the main object's color.\n    for hole in holes_to_fill:\n        for r, c in hole['coords']:\n            # Ensure coordinates are within bounds (should be, but safe)\n            if 0 <= r < H and 0 <= c < W:\n                output_grid[r, c] = main_object_color\n\n    # 11. Return the modified grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4961,
    "candidates_token_count": 1640,
    "total_token_count": 6601,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.47661,
  "retries": 1
}