
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0
0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 0 0 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0
0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples to understand the transformation rule.

**Perception:**

1.  **Input/Output Structure:** Both examples show an input grid containing a large shape made of a single color (green=3 in ex1, blue=1 in ex2) on a white (0) background. This main shape contains one or more enclosed areas (holes) of the background color (white). The output grid is largely identical to the input, except that some or all of these white holes within the main shape have been filled with the color of the main shape.
2.  **Example 1 Analysis:**
    *   The main shape is green (3).
    *   There are two distinct enclosed white regions (holes) within the green shape. One is larger (6 pixels at rows 10-11, cols 7-9) and another is smaller (2 pixels at row 15, cols 6-7).
    *   In the output, only the smaller hole (at row 15) is filled with green. The larger hole remains white.
3.  **Example 2 Analysis:**
    *   The main shape is blue (1).
    *   There are two distinct enclosed white regions (holes) within the blue shape. One is at row 7, cols 8-11 (4 pixels). The other is at row 8, cols 8-11 (4 pixels). They are of equal size.
    *   In the output, *both* holes are filled with blue.
4.  **Identifying the Pattern:** The transformation identifies enclosed regions (holes) of the background color within the largest non-background object. It seems to fill these holes based on their size relative to other holes. Specifically, it appears to fill all internal holes *except* for the uniquely largest one. If there is a tie for the largest hole (as in example 2), or only one hole exists, then all holes are filled.

**Facts:**


```yaml
task_description: Fill internal background-colored holes within the largest colored object, based on hole size.

elements:
  - object: grid
    description: A 2D array of pixels with colors 0-9.
  - object: background
    property:
      color: white (0)
      role: Surrounds and potentially fills areas within other objects.
  - object: colored_shape
    property:
      color: Any color other than white (0). Green (3) in ex1, Blue (1) in ex2.
      connectivity: Forms contiguous regions (components).
      role: The primary element containing potential holes. In these examples, there's one dominant colored shape.
  - object: hole
    property:
      color: white (0)
      connectivity: Forms contiguous regions.
      location: Completely surrounded by a single `colored_shape`.
      relation: Defined by being enclosed within a `colored_shape`. Cannot reach the grid boundary by moving only through `background` pixels.
      size: Number of pixels in the connected component.
    identified_in_ex1:
      - hole_1: size 6, location rows 10-11 / cols 7-9
      - hole_2: size 2, location row 15 / cols 6-7
    identified_in_ex2:
      - hole_1: size 4, location row 7 / cols 8-11
      - hole_2: size 4, location row 8 / cols 8-11

actions:
  - action: identify_largest_object
    input: grid
    output: the largest connected component of non-background color (main_object), its color (C)
  - action: identify_internal_holes
    input: grid, main_object
    output: a list of connected components of background color fully enclosed by main_object (internal_holes)
  - action: measure_hole_sizes
    input: internal_holes
    output: a list of sizes corresponding to each internal_hole
  - action: determine_holes_to_fill
    input: internal_holes, hole_sizes
    output: a list of internal holes to be filled (fill_holes)
    logic: Find max_size. Count holes with max_size. If count is 1, fill_holes = all internal_holes except the one with max_size. Else (count is not 1), fill_holes = all internal_holes.
  - action: fill_holes
    input: grid, fill_holes, color C
    output: modified grid where pixels in fill_holes are set to C

relationships:
  - relation: enclosure
    subject: colored_shape
    object: hole
    description: A hole is spatially enclosed by a colored_shape.
  - relation: size_comparison
    subject: hole
    object: hole
    description: Holes are compared based on their pixel count (size).
  - relation: uniqueness
    subject: largest_hole
    description: Whether there is exactly one hole with the maximum size among all internal holes.

transformation:
  rule: Fill all internal background holes within the largest colored object, unless a hole is uniquely the largest among all internal holes, in which case that unique largest hole is not filled.
  based_on_examples:
    - ex1: Hole 1 (size 6) is unique largest. Only Hole 2 (size 2) is filled.
    - ex2: Holes 1 and 2 tie for largest (size 4). No unique largest hole. Both are filled.
```


**Natural Language Program:**

1.  Identify the background color, which is white (0).
2.  Find all connected components of non-background colors in the input grid.
3.  Determine the largest connected component among these (by pixel count). Let this be the 'main object' and note its color, C. If there's a tie for the largest component, choose any one (the rule seems independent of which tied component is chosen, as holes are defined relative to *one* component).
4.  Find all connected components of the background color (white).
5.  For each white component, determine if it is an 'internal hole' relative to the main object. A white component is an internal hole if all its neighboring pixels (up, down, left, right, and optionally diagonal - need to confirm, but examples suggest cardinal neighbors are sufficient to define enclosure) are either part of the white component itself or part of the main object. Equivalently, check if the white component can reach the grid boundary by moving only through white cells; if it cannot, it is internal.
6.  Create a list of all identified internal holes.
7.  If no internal holes are found, the output grid is identical to the input grid.
8.  If internal holes are found, calculate the size (number of pixels) of each internal hole.
9.  Find the maximum size among these internal holes.
10. Count how many internal holes share this maximum size.
11. Prepare the output grid by copying the input grid.
12. If exactly one internal hole has the maximum size (i.e., there is a unique largest hole), iterate through all *other* internal holes (those not uniquely largest) and change the color of their pixels to color C in the output grid.
13. If there is *not* a unique largest hole (either because there was a tie for the largest size, or there was only one hole to begin with), iterate through *all* internal holes and change the color of their pixels to color C in the output grid.
14. Return the final output grid.
