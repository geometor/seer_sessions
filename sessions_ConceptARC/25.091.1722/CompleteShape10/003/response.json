{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\n\"\"\"\nIdentifies the largest connected component of a non-background color (main object) \nin the input grid. Finds all enclosed regions (holes) of the background color (0) \nthat are fully enclosed by this main object. \n\nThe filling logic depends on the number of internal holes found:\n- If exactly one internal hole is found, it is filled with the main object's color.\n- If multiple internal holes are found:\n    - The sizes (pixel counts) of all internal holes are determined.\n    - If there is a unique largest hole among them, all *other* internal holes are filled.\n    - If there is a tie for the largest hole size, *all* internal holes are filled.\n- If no internal holes are found, the grid remains unchanged.\n\"\"\"\n\ndef get_neighbors(coords, grid_shape):\n    \"\"\" \n    Gets the set of unique orthogonal neighbor coordinates for a given set of coordinates.\n    \n    Args:\n        coords (np.array): A Nx2 array of coordinates (row, col).\n        grid_shape (tuple): The (height, width) of the grid.\n\n    Returns:\n        set: A set of unique neighbor coordinates (row, col) tuples.\n    \"\"\"\n    neighbors = set()\n    H, W = grid_shape\n    coord_set = set(tuple(coord) for coord in coords) # For quick checking if neighbor is part of the original set\n\n    for r, c in coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal neighbors\n            nr, nc = r + dr, c + dc\n            # Check bounds and if the neighbor is not part of the original component\n            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in coord_set:\n                neighbors.add((nr, nc))\n    return neighbors\n\ndef get_component_details(labeled_array, label_idx):\n    \"\"\"Gets coordinates and size of a specific component label.\"\"\"\n    coords = np.argwhere(labeled_array == label_idx)\n    size = len(coords)\n    return coords, size\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the hole-filling transformation based on the number and size of holes.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    H, W = input_grid.shape\n    background_color = 0\n\n    # 1. Find all connected components of non-background colors.\n    labeled_objects, num_objects = label(input_grid != background_color)\n\n    # Handle case with no non-background objects\n    if num_objects == 0:\n        return output_grid\n\n    # 2. Determine the largest connected component (main object).\n    object_sizes = []\n    for i in range(1, num_objects + 1):\n        coords, size = get_component_details(labeled_objects, i)\n        if size > 0:\n            object_sizes.append({'label': i, 'size': size, 'coords': coords})\n\n    if not object_sizes: # Should not happen if num_objects > 0, but safety check\n         return output_grid\n         \n    main_object_info = max(object_sizes, key=lambda item: item['size'])\n    main_object_label = main_object_info['label']\n    main_object_coords_arr = main_object_info['coords']\n    main_object_coords_set = set(tuple(coord) for coord in main_object_coords_arr)\n    main_object_color = input_grid[main_object_coords_arr[0, 0], main_object_coords_arr[0, 1]]\n\n    # 3. Find all connected components of the background color.\n    labeled_background, num_bg_components = label(input_grid == background_color)\n\n    # 4. Identify the 'outer' background component (touching border or largest).\n    outer_background_label = 0\n    border_labels = set(labeled_background[0, :]) | \\\n                    set(labeled_background[-1, :]) | \\\n                    set(labeled_background[:, 0]) | \\\n                    set(labeled_background[:, -1])\n    border_labels.discard(0) # Remove the 0 label if present\n\n    if border_labels:\n        # Typically there's only one background component touching the border\n        outer_background_label = min(border_labels) # Take the first one found\n    elif num_bg_components > 0:\n        # If no background touches border, find the largest background component\n        bg_sizes = []\n        for i in range(1, num_bg_components + 1):\n            coords, size = get_component_details(labeled_background, i)\n            if size > 0:\n                 bg_sizes.append({'label': i, 'size': size})\n        if bg_sizes:\n             outer_background_label = max(bg_sizes, key=lambda item: item['size'])['label']\n    # If outer_background_label is still 0, means no background components found.\n\n    # 5. Identify internal holes enclosed by the main object.\n    internal_holes = [] \n    for i in range(1, num_bg_components + 1):\n        # Skip the outer background component\n        if i == outer_background_label:\n            continue \n            \n        bg_coords, hole_size = get_component_details(labeled_background, i)\n        if hole_size == 0: continue # Should not happen with labels > 0\n\n        # Check if this component is fully enclosed by the main object\n        is_enclosed_by_main = True\n        neighbor_coords = get_neighbors(bg_coords, (H, W))\n\n        if not neighbor_coords: # An isolated background pixel not next to anything? Unlikely for a hole.\n            is_enclosed_by_main = False\n\n        for neighbor_coord in neighbor_coords:\n            # If neighbor is NOT part of the main object, it's not enclosed\n            if neighbor_coord not in main_object_coords_set:\n                 is_enclosed_by_main = False\n                 break \n                 \n        if is_enclosed_by_main:\n            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})\n\n    # 6. Determine which holes to fill based on the rules.\n    num_internal_holes = len(internal_holes)\n    holes_to_fill_coords = [] # List to store coordinates of holes to be filled\n\n    if num_internal_holes == 1:\n        # Fill the single hole\n        holes_to_fill_coords.append(internal_holes[0]['coords'])\n    elif num_internal_holes > 1:\n        # Multiple holes: check sizes\n        hole_sizes = [h['size'] for h in internal_holes]\n        max_hole_size = max(hole_sizes)\n        max_size_count = hole_sizes.count(max_hole_size)\n        \n        if max_size_count == 1:\n            # Unique largest: fill all EXCEPT the largest\n            for hole in internal_holes:\n                if hole['size'] != max_hole_size:\n                    holes_to_fill_coords.append(hole['coords'])\n        else:\n            # Tie for largest: fill ALL internal holes\n            for hole in internal_holes:\n                holes_to_fill_coords.append(hole['coords'])\n\n    # 7. Fill the selected holes in the output grid.\n    for coords_array in holes_to_fill_coords:\n        for r, c in coords_array:\n            # Double check bounds just in case, though get_component_details should be correct\n            if 0 <= r < H and 0 <= c < W:\n                output_grid[r, c] = main_object_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25110,
    "candidates_token_count": 1858,
    "total_token_count": 26968,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.260732,
  "retries": 1
}