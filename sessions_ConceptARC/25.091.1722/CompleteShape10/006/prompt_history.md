
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0
0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 0 0 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0
0 0 0 0 0 3 3 3 3 3 3 3 0 0 0 0 0
0 0 0 0 3 3 3 0 0 0 3 3 3 0 0 0 0
0 0 0 3 3 3 3 0 0 0 3 3 3 3 0 0 0
0 0 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0
0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0
0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples to understand the transformation rule.

**Perception:**

1.  **Input/Output Structure:** Both examples show an input grid containing a large shape made of a single color (green=3 in ex1, blue=1 in ex2) on a white (0) background. This main shape contains one or more enclosed areas (holes) of the background color (white). The output grid is largely identical to the input, except that some or all of these white holes within the main shape have been filled with the color of the main shape.
2.  **Example 1 Analysis:**
    *   The main shape is green (3).
    *   There are two distinct enclosed white regions (holes) within the green shape. One is larger (6 pixels at rows 10-11, cols 7-9) and another is smaller (2 pixels at row 15, cols 6-7).
    *   In the output, only the smaller hole (at row 15) is filled with green. The larger hole remains white.
3.  **Example 2 Analysis:**
    *   The main shape is blue (1).
    *   There are two distinct enclosed white regions (holes) within the blue shape. One is at row 7, cols 8-11 (4 pixels). The other is at row 8, cols 8-11 (4 pixels). They are of equal size.
    *   In the output, *both* holes are filled with blue.
4.  **Identifying the Pattern:** The transformation identifies enclosed regions (holes) of the background color within the largest non-background object. It seems to fill these holes based on their size relative to other holes. Specifically, it appears to fill all internal holes *except* for the uniquely largest one. If there is a tie for the largest hole (as in example 2), or only one hole exists, then all holes are filled.

**Facts:**


```yaml
task_description: Fill internal background-colored holes within the largest colored object, based on hole size.

elements:
  - object: grid
    description: A 2D array of pixels with colors 0-9.
  - object: background
    property:
      color: white (0)
      role: Surrounds and potentially fills areas within other objects.
  - object: colored_shape
    property:
      color: Any color other than white (0). Green (3) in ex1, Blue (1) in ex2.
      connectivity: Forms contiguous regions (components).
      role: The primary element containing potential holes. In these examples, there's one dominant colored shape.
  - object: hole
    property:
      color: white (0)
      connectivity: Forms contiguous regions.
      location: Completely surrounded by a single `colored_shape`.
      relation: Defined by being enclosed within a `colored_shape`. Cannot reach the grid boundary by moving only through `background` pixels.
      size: Number of pixels in the connected component.
    identified_in_ex1:
      - hole_1: size 6, location rows 10-11 / cols 7-9
      - hole_2: size 2, location row 15 / cols 6-7
    identified_in_ex2:
      - hole_1: size 4, location row 7 / cols 8-11
      - hole_2: size 4, location row 8 / cols 8-11

actions:
  - action: identify_largest_object
    input: grid
    output: the largest connected component of non-background color (main_object), its color (C)
  - action: identify_internal_holes
    input: grid, main_object
    output: a list of connected components of background color fully enclosed by main_object (internal_holes)
  - action: measure_hole_sizes
    input: internal_holes
    output: a list of sizes corresponding to each internal_hole
  - action: determine_holes_to_fill
    input: internal_holes, hole_sizes
    output: a list of internal holes to be filled (fill_holes)
    logic: Find max_size. Count holes with max_size. If count is 1, fill_holes = all internal_holes except the one with max_size. Else (count is not 1), fill_holes = all internal_holes.
  - action: fill_holes
    input: grid, fill_holes, color C
    output: modified grid where pixels in fill_holes are set to C

relationships:
  - relation: enclosure
    subject: colored_shape
    object: hole
    description: A hole is spatially enclosed by a colored_shape.
  - relation: size_comparison
    subject: hole
    object: hole
    description: Holes are compared based on their pixel count (size).
  - relation: uniqueness
    subject: largest_hole
    description: Whether there is exactly one hole with the maximum size among all internal holes.

transformation:
  rule: Fill all internal background holes within the largest colored object, unless a hole is uniquely the largest among all internal holes, in which case that unique largest hole is not filled.
  based_on_examples:
    - ex1: Hole 1 (size 6) is unique largest. Only Hole 2 (size 2) is filled.
    - ex2: Holes 1 and 2 tie for largest (size 4). No unique largest hole. Both are filled.
```


**Natural Language Program:**

1.  Identify the background color, which is white (0).
2.  Find all connected components of non-background colors in the input grid.
3.  Determine the largest connected component among these (by pixel count). Let this be the 'main object' and note its color, C. If there's a tie for the largest component, choose any one (the rule seems independent of which tied component is chosen, as holes are defined relative to *one* component).
4.  Find all connected components of the background color (white).
5.  For each white component, determine if it is an 'internal hole' relative to the main object. A white component is an internal hole if all its neighboring pixels (up, down, left, right, and optionally diagonal - need to confirm, but examples suggest cardinal neighbors are sufficient to define enclosure) are either part of the white component itself or part of the main object. Equivalently, check if the white component can reach the grid boundary by moving only through white cells; if it cannot, it is internal.
6.  Create a list of all identified internal holes.
7.  If no internal holes are found, the output grid is identical to the input grid.
8.  If internal holes are found, calculate the size (number of pixels) of each internal hole.
9.  Find the maximum size among these internal holes.
10. Count how many internal holes share this maximum size.
11. Prepare the output grid by copying the input grid.
12. If exactly one internal hole has the maximum size (i.e., there is a unique largest hole), iterate through all *other* internal holes (those not uniquely largest) and change the color of their pixels to color C in the output grid.
13. If there is *not* a unique largest hole (either because there was a tie for the largest size, or there was only one hole to begin with), iterate through *all* internal holes and change the color of their pixels to color C in the output grid.
14. Return the final output grid.
```python
import numpy as np
from scipy.ndimage import label

"""
Identifies the largest connected component of a non-background color in the input grid.
Finds all enclosed regions (holes) of the background color within this largest component.
Calculates the size of each hole.
If there is a unique largest hole among all internal holes, fills all *other* holes with the color of the largest component.
Otherwise (if there's a tie for the largest hole, or only one hole exists), fills *all* internal holes with the color of the largest component.
The background color is assumed to be white (0).
"""

def find_connected_components(grid, target_value=None, background_value=None):
    """
    Finds connected components in a grid.

    Args:
        grid (np.array): The input grid.
        target_value (int, optional): If provided, find components of this value.
        background_value (int, optional): If provided, find components *not* of this value.

    Returns:
        tuple: (labeled_array, num_features) from scipy.ndimage.label
               or (None, 0) if no components found or invalid args.
    """
    if target_value is not None:
        binary_grid = (grid == target_value)
    elif background_value is not None:
        binary_grid = (grid != background_value)
    else:
        # Requires either target_value or background_value
        return None, 0
        
    # Default connectivity (structure) considers orthogonal neighbors:
    # [[0,1,0],
    #  [1,1,1],
    #  [0,1,0]]
    labeled_array, num_features = label(binary_grid)
    return labeled_array, num_features

def get_component_coords(labeled_array, label_idx):
    """Gets the coordinates of pixels belonging to a specific component label."""
    return np.argwhere(labeled_array == label_idx)

def get_component_size(labeled_array, label_idx):
    """Gets the size (pixel count) of a specific component label."""
    return np.sum(labeled_array == label_idx)

def transform(input_grid):
    """
    Fills internal background holes within the largest colored object,
    except for the uniquely largest hole, if one exists.
    """
    output_grid = np.copy(input_grid)
    H, W = input_grid.shape
    background_color = 0

    # 1. Find all connected components of non-background colors.
    labeled_objects, num_objects = find_connected_components(input_grid, background_value=background_color)

    # Handle case with no non-background objects
    if num_objects == 0:
        return output_grid

    # 2. Determine the largest connected component (main object).
    object_sizes = [get_component_size(labeled_objects, i) for i in range(1, num_objects + 1)]
    largest_object_size = 0
    main_object_label = 0
    if object_sizes:
       largest_object_size = max(object_sizes)
       # Find the first label corresponding to the max size (handles ties by picking one)
       main_object_label = object_sizes.index(largest_object_size) + 1 
       
    # Handle edge case maybe? if main_object_label remains 0 something went wrong or no objects
    if main_object_label == 0:
         return output_grid # Should have been caught by num_objects == 0 check

    # 3. Get the color of the main object.
    main_object_coords = get_component_coords(labeled_objects, main_object_label)
    # Check if coords were found before accessing
    if len(main_object_coords) == 0:
        # This shouldn't happen if main_object_label > 0 and based on a valid size
        return output_grid 
    main_object_color = input_grid[main_object_coords[0, 0], main_object_coords[0, 1]]

    # 4. Find all connected components of the background color.
    labeled_background, num_background_components = find_connected_components(input_grid, target_value=background_color)

    # 5. Identify internal holes (background components not touching the border).
    internal_holes = [] # Store tuples of (label_index, size, coordinates)
    for i in range(1, num_background_components + 1):
        bg_coords = get_component_coords(labeled_background, i)
        if len(bg_coords) == 0:
            continue # Skip if component somehow has no coords

        # Check if any coordinate touches the border
        touches_border = np.any((bg_coords[:, 0] == 0) | (bg_coords[:, 0] == H - 1) | 
                                (bg_coords[:, 1] == 0) | (bg_coords[:, 1] == W - 1))

        if not touches_border:
            # It's an internal hole candidate. We assume based on task structure
            # that these are holes within the 'main object' context.
            hole_size = len(bg_coords)
            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})

    # 6. If no internal holes are found, return the original grid.
    if not internal_holes:
        return output_grid

    # 7. Calculate sizes and find the maximum size among internal holes.
    hole_sizes = [hole['size'] for hole in internal_holes]
    if not hole_sizes: # Should be caught by 'if not internal_holes', but safety check
        return output_grid
        
    max_hole_size = max(hole_sizes)

    # 8. Count how many holes share this maximum size.
    max_size_count = hole_sizes.count(max_hole_size)

    # 9. Determine which holes to fill and modify the output grid.
    holes_to_fill = []
    if max_size_count == 1:
        # Fill all holes EXCEPT the unique largest one
        for hole in internal_holes:
            if hole['size'] != max_hole_size:
                holes_to_fill.append(hole)
    else:
        # Fill ALL internal holes (tie for largest, or only one hole exists which is max)
        holes_to_fill = internal_holes

    # 10. Fill the selected holes with the main object's color.
    for hole in holes_to_fill:
        for r, c in hole['coords']:
            # Ensure coordinates are within bounds (should be, but safe)
            if 0 <= r < H and 0 <= c < W:
                output_grid[r, c] = main_object_color

    # 11. Return the modified grid.
    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label

"""
Identifies the largest connected component of a non-background color (main object) 
in the input grid. Finds all enclosed regions (holes) of the background color (0) 
that are fully enclosed by this main object. 

The filling logic depends on the number of internal holes found:
- If exactly one internal hole is found, it is filled with the main object's color.
- If multiple internal holes are found:
    - The sizes (pixel counts) of all internal holes are determined.
    - If there is a unique largest hole among them, all *other* internal holes are filled.
    - If there is a tie for the largest hole size, *all* internal holes are filled.
- If no internal holes are found, the grid remains unchanged.
"""

def get_neighbors(coords, grid_shape):
    """ 
    Gets the set of unique orthogonal neighbor coordinates for a given set of coordinates.
    
    Args:
        coords (np.array): A Nx2 array of coordinates (row, col).
        grid_shape (tuple): The (height, width) of the grid.

    Returns:
        set: A set of unique neighbor coordinates (row, col) tuples.
    """
    neighbors = set()
    H, W = grid_shape
    coord_set = set(tuple(coord) for coord in coords) # For quick checking if neighbor is part of the original set

    for r, c in coords:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal neighbors
            nr, nc = r + dr, c + dc
            # Check bounds and if the neighbor is not part of the original component
            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in coord_set:
                neighbors.add((nr, nc))
    return neighbors

def get_component_details(labeled_array, label_idx):
    """Gets coordinates and size of a specific component label."""
    coords = np.argwhere(labeled_array == label_idx)
    size = len(coords)
    return coords, size

def transform(input_grid):
    """
    Applies the hole-filling transformation based on the number and size of holes.
    """
    output_grid = np.copy(input_grid)
    H, W = input_grid.shape
    background_color = 0

    # 1. Find all connected components of non-background colors.
    labeled_objects, num_objects = label(input_grid != background_color)

    # Handle case with no non-background objects
    if num_objects == 0:
        return output_grid

    # 2. Determine the largest connected component (main object).
    object_sizes = []
    for i in range(1, num_objects + 1):
        coords, size = get_component_details(labeled_objects, i)
        if size > 0:
            object_sizes.append({'label': i, 'size': size, 'coords': coords})

    if not object_sizes: # Should not happen if num_objects > 0, but safety check
         return output_grid
         
    main_object_info = max(object_sizes, key=lambda item: item['size'])
    main_object_label = main_object_info['label']
    main_object_coords_arr = main_object_info['coords']
    main_object_coords_set = set(tuple(coord) for coord in main_object_coords_arr)
    main_object_color = input_grid[main_object_coords_arr[0, 0], main_object_coords_arr[0, 1]]

    # 3. Find all connected components of the background color.
    labeled_background, num_bg_components = label(input_grid == background_color)

    # 4. Identify the 'outer' background component (touching border or largest).
    outer_background_label = 0
    border_labels = set(labeled_background[0, :]) | \
                    set(labeled_background[-1, :]) | \
                    set(labeled_background[:, 0]) | \
                    set(labeled_background[:, -1])
    border_labels.discard(0) # Remove the 0 label if present

    if border_labels:
        # Typically there's only one background component touching the border
        outer_background_label = min(border_labels) # Take the first one found
    elif num_bg_components > 0:
        # If no background touches border, find the largest background component
        bg_sizes = []
        for i in range(1, num_bg_components + 1):
            coords, size = get_component_details(labeled_background, i)
            if size > 0:
                 bg_sizes.append({'label': i, 'size': size})
        if bg_sizes:
             outer_background_label = max(bg_sizes, key=lambda item: item['size'])['label']
    # If outer_background_label is still 0, means no background components found.

    # 5. Identify internal holes enclosed by the main object.
    internal_holes = [] 
    for i in range(1, num_bg_components + 1):
        # Skip the outer background component
        if i == outer_background_label:
            continue 
            
        bg_coords, hole_size = get_component_details(labeled_background, i)
        if hole_size == 0: continue # Should not happen with labels > 0

        # Check if this component is fully enclosed by the main object
        is_enclosed_by_main = True
        neighbor_coords = get_neighbors(bg_coords, (H, W))

        if not neighbor_coords: # An isolated background pixel not next to anything? Unlikely for a hole.
            is_enclosed_by_main = False

        for neighbor_coord in neighbor_coords:
            # If neighbor is NOT part of the main object, it's not enclosed
            if neighbor_coord not in main_object_coords_set:
                 is_enclosed_by_main = False
                 break 
                 
        if is_enclosed_by_main:
            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})

    # 6. Determine which holes to fill based on the rules.
    num_internal_holes = len(internal_holes)
    holes_to_fill_coords = [] # List to store coordinates of holes to be filled

    if num_internal_holes == 1:
        # Fill the single hole
        holes_to_fill_coords.append(internal_holes[0]['coords'])
    elif num_internal_holes > 1:
        # Multiple holes: check sizes
        hole_sizes = [h['size'] for h in internal_holes]
        max_hole_size = max(hole_sizes)
        max_size_count = hole_sizes.count(max_hole_size)
        
        if max_size_count == 1:
            # Unique largest: fill all EXCEPT the largest
            for hole in internal_holes:
                if hole['size'] != max_hole_size:
                    holes_to_fill_coords.append(hole['coords'])
        else:
            # Tie for largest: fill ALL internal holes
            for hole in internal_holes:
                holes_to_fill_coords.append(hole['coords'])

    # 7. Fill the selected holes in the output grid.
    for coords_array in holes_to_fill_coords:
        for r, c in coords_array:
            # Double check bounds just in case, though get_component_details should be correct
            if 0 <= r < H and 0 <= c < W:
                output_grid[r, c] = main_object_color

    return output_grid
```
```python
import numpy as np
from scipy.ndimage import label

"""
Identifies the largest connected component of a non-background color (main object) 
in the input grid. Finds all enclosed regions (holes) of the background color (0) 
that are fully enclosed by this main object. 

The filling logic depends on the number and properties of internal holes found:
- If no internal holes are found, the grid remains unchanged.
- If one or more internal holes are found:
    - The sizes (pixel counts) of all internal holes are determined.
    - If there is a unique largest hole among them (exactly one hole has the maximum size), all *other* internal holes (those smaller than the max size) are filled with the main object's color.
    - Otherwise (if there is a tie for the largest hole size, or if there is only one hole), *all* internal holes are filled with the main object's color.
"""

def get_neighbors(coords, grid_shape):
    """ 
    Gets the set of unique orthogonal neighbor coordinates for a given set of coordinates,
    ensuring neighbors are within grid bounds and not part of the original coordinate set.
    
    Args:
        coords (np.array): A Nx2 array of coordinates (row, col).
        grid_shape (tuple): The (height, width) of the grid.

    Returns:
        set: A set of unique neighbor coordinates (row, col) tuples.
    """
    neighbors = set()
    H, W = grid_shape
    coord_set = set(tuple(coord) for coord in coords) # For quick checking if neighbor is part of the original set

    for r, c in coords:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Orthogonal neighbors
            nr, nc = r + dr, c + dc
            # Check bounds and if the neighbor is not part of the original component
            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in coord_set:
                neighbors.add((nr, nc))
    return neighbors

def get_component_details(labeled_array, label_idx):
    """Gets coordinates and size of a specific component label."""
    coords = np.argwhere(labeled_array == label_idx)
    size = len(coords)
    return coords, size

def transform(input_grid):
    """
    Applies the hole-filling transformation based on the number and size of holes.
    """
    output_grid = np.copy(input_grid)
    H, W = input_grid.shape
    background_color = 0

    # Step 1: Find all connected components of non-background colors.
    labeled_objects, num_objects = label(input_grid != background_color)

    # Handle case with no non-background objects
    if num_objects == 0:
        return output_grid

    # Step 2: Determine the largest connected component (main object).
    object_sizes = []
    for i in range(1, num_objects + 1):
        coords, size = get_component_details(labeled_objects, i)
        if size > 0:
            object_sizes.append({'label': i, 'size': size, 'coords': coords})

    if not object_sizes: # Should not happen if num_objects > 0, but safety check
         return output_grid
         
    # Find the component with the maximum size
    main_object_info = max(object_sizes, key=lambda item: item['size'])
    main_object_label = main_object_info['label']
    main_object_coords_arr = main_object_info['coords']
    # Create a set for efficient neighbor checking later
    main_object_coords_set = set(tuple(coord) for coord in main_object_coords_arr)
    # Get the color of the main object
    main_object_color = input_grid[main_object_coords_arr[0, 0], main_object_coords_arr[0, 1]]

    # Step 3: Find all connected components of the background color.
    labeled_background, num_bg_components = label(input_grid == background_color)

    # Step 4: Identify internal holes enclosed solely by the main object.
    internal_holes = [] 
    for i in range(1, num_bg_components + 1):
        bg_coords, hole_size = get_component_details(labeled_background, i)
        if hole_size == 0: continue 

        # Check if the component touches the border
        touches_border = np.any((bg_coords[:, 0] == 0) | (bg_coords[:, 0] == H - 1) | 
                                (bg_coords[:, 1] == 0) | (bg_coords[:, 1] == W - 1))
        if touches_border:
            continue # Not an internal hole if it touches the border

        # Check if this component is fully enclosed ONLY by the main object
        is_enclosed_by_main = True
        neighbor_coords = get_neighbors(bg_coords, (H, W))

        if not neighbor_coords: 
             # Isolated background component with no neighbors? Cannot be enclosed.
             is_enclosed_by_main = False
        else:
            for neighbor_coord in neighbor_coords:
                # If any neighbor is NOT part of the main object, it's not solely enclosed by it.
                if neighbor_coord not in main_object_coords_set:
                     is_enclosed_by_main = False
                     break 
                 
        if is_enclosed_by_main:
            internal_holes.append({'label': i, 'size': hole_size, 'coords': bg_coords})

    # Step 5: Determine which holes to fill based on the rules.
    num_internal_holes = len(internal_holes)
    
    # If no internal holes, return the original grid
    if num_internal_holes == 0:
        return output_grid

    holes_to_fill = [] # List to store hole objects (dicts) to be filled

    if num_internal_holes == 1:
        # Fill the single hole
        holes_to_fill.append(internal_holes[0])
    else: # num_internal_holes > 1
        # Multiple holes: check sizes
        hole_sizes = [h['size'] for h in internal_holes]
        max_hole_size = max(hole_sizes)
        max_size_count = hole_sizes.count(max_hole_size)
        
        if max_size_count == 1:
            # Unique largest: fill all EXCEPT the largest
            for hole in internal_holes:
                if hole['size'] != max_hole_size:
                    holes_to_fill.append(hole)
        else:
            # Tie for largest: fill ALL internal holes
            holes_to_fill = internal_holes # Fill all of them

    # Step 6: Fill the selected holes in the output grid.
    for hole in holes_to_fill:
        coords_array = hole['coords']
        for r, c in coords_array:
            # Check bounds just in case
            if 0 <= r < H and 0 <= c < W:
                output_grid[r, c] = main_object_color

    return output_grid
```
