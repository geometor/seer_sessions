{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef _find_objects(grid):\n    \"\"\"\n    Finds connected components of non-background (non-zero) pixels using BFS.\n    \n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color' (int) and 'coords' (set of (row, col) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if a non-background pixel is found that hasn't been visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and if visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'color': color, 'coords': obj_coords})\n    return objects\n\ndef _get_line_details(obj):\n    \"\"\"\n    Checks if a given object (set of coordinates) forms a straight \n    horizontal or vertical line and returns its details.\n\n    Args:\n        obj (dict): An object dictionary with 'color' and 'coords'.\n\n    Returns:\n        dict or None: A dictionary with line details ('type', 'color', \n                      'row'/'col', 'cols'/'rows', 'coords') if it's a line, \n                      otherwise None.\n    \"\"\"\n    coords = obj['coords']\n    color = obj['color']\n    \n    if not coords:\n        return None\n\n    rows = {r for r, c in coords}\n    cols = {c for r, c in coords}\n\n    # Check if it's a potential vertical line (all coords in the same column)\n    if len(cols) == 1:\n        col = list(cols)[0]\n        min_row = min(rows)\n        max_row = max(rows)\n        # Check for contiguity: the number of pixels must match the line length\n        if len(coords) == (max_row - min_row + 1):\n             # Verify all pixels within the line's bounding box are part of the object\n             is_contiguous = True\n             for r in range(min_row, max_row + 1):\n                 if (r, col) not in coords:\n                     is_contiguous = False\n                     break\n             if is_contiguous:\n                return {'type': 'v', 'color': color, 'col': col, 'rows': (min_row, max_row), 'coords': coords}\n\n    # Check if it's a potential horizontal line (all coords in the same row)\n    if len(rows) == 1:\n        row = list(rows)[0]\n        min_col = min(cols)\n        max_col = max(cols)\n        # Check for contiguity: the number of pixels must match the line length\n        if len(coords) == (max_col - min_col + 1):\n            # Verify all pixels within the line's bounding box are part of the object\n            is_contiguous = True\n            for c in range(min_col, max_col + 1):\n                if (row, c) not in coords:\n                    is_contiguous = False\n                    break\n            if is_contiguous:\n                return {'type': 'h', 'color': color, 'row': row, 'cols': (min_col, max_col), 'coords': coords}\n\n    # If neither vertical nor horizontal contiguous line, return None\n    return None\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid_list):\n    \"\"\"\n    Identifies one horizontal and one vertical line in the input grid that are \n    separated by a single row or column gap consisting entirely of white pixels (0). \n    It then extends the appropriate line to fill this gap. If the gap is vertical \n    (along a column), the vertical line is extended using its color. If the gap \n    is horizontal (along a row), the horizontal line is extended using its color.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = np.copy(input_grid)\n    \n    # Find all distinct connected non-white objects in the grid\n    objects = _find_objects(input_grid)\n    \n    # Identify which objects are the horizontal and vertical lines\n    h_line = None\n    v_line = None\n    for obj in objects:\n        line_details = _get_line_details(obj)\n        if line_details:\n            if line_details['type'] == 'h':\n                h_line = line_details\n            elif line_details['type'] == 'v':\n                v_line = line_details\n                \n    # Proceed only if exactly one horizontal and one vertical line are found\n    if h_line is None or v_line is None:\n        # If the expected lines aren't found, return the unchanged grid\n        # This handles unexpected inputs gracefully.\n        return output_grid.tolist() \n        \n    # Extract properties of the horizontal line\n    h_row, h_cols, h_color = h_line['row'], h_line['cols'], h_line['color']\n    # Extract properties of the vertical line\n    v_col, v_rows, v_color = v_line['col'], v_line['rows'], v_line['color']\n\n    # --- Check for Vertical Gap ---\n    # Condition: The vertical line's column must align with the horizontal line's span\n    if h_cols[0] <= v_col <= h_cols[1]:\n        gap_rows = []\n        # Determine the rows that constitute the gap\n        if h_row < v_rows[0]: # Horizontal line is above vertical line\n            gap_rows = range(h_row + 1, v_rows[0])\n        elif h_row > v_rows[1]: # Horizontal line is below vertical line\n            gap_rows = range(v_rows[1] + 1, h_row)\n            \n        # If a potential gap exists (gap_rows is not empty)\n        if gap_rows:\n            # Check if all pixels in the gap path along the vertical line's column are white (0)\n            is_clear = all(input_grid[r, v_col] == 0 for r in gap_rows)\n            if is_clear:\n                # Fill the gap in the output grid using the vertical line's color\n                for r in gap_rows:\n                    output_grid[r, v_col] = v_color\n                # The transformation is complete, return the result\n                return output_grid.tolist() \n\n    # --- Check for Horizontal Gap ---\n    # Condition: The horizontal line's row must align with the vertical line's span\n    if v_rows[0] <= h_row <= v_rows[1]:\n        gap_cols = []\n        # Determine the columns that constitute the gap\n        if v_col < h_cols[0]: # Vertical line is to the left of horizontal line\n            gap_cols = range(v_col + 1, h_cols[0])\n        elif v_col > h_cols[1]: # Vertical line is to the right of horizontal line\n            gap_cols = range(h_cols[1] + 1, v_col)\n            \n        # If a potential gap exists (gap_cols is not empty)\n        if gap_cols:\n            # Check if all pixels in the gap path along the horizontal line's row are white (0)\n            is_clear = all(input_grid[h_row, c] == 0 for c in gap_cols)\n            if is_clear:\n                # Fill the gap in the output grid using the horizontal line's color\n                for c in gap_cols:\n                    output_grid[h_row, c] = h_color\n                # The transformation is complete, return the result\n                return output_grid.tolist() \n\n    # If no gap was found and filled according to the rules, \n    # return the grid copy (which is identical to the input).\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2410,
    "candidates_token_count": 2121,
    "total_token_count": 4531,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 139.564362,
  "retries": 2
}