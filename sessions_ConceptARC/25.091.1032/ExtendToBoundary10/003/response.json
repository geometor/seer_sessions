{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\n1. Create a copy of the input grid for the output.\n2. Identify all yellow (4) pixels in the input grid. Determine the largest connected component (using 4-way adjacency) formed by these pixels - this constitutes the 'main boundary'. Store the coordinates of these boundary pixels.\n3. If a main boundary exists, calculate its minimum and maximum row indices (`min_boundary_row`, `max_boundary_row`).\n4. Identify all orange (7) 'seed' pixels in the input grid.\n5. For each seed pixel at `(r, c)`:\n    a. Set the pixel `(r, c)` in the output grid to orange (7).\n    b. Determine the fill direction based on the seed's row `r` relative to the main boundary's row span:\n        - If a boundary exists and `min_boundary_row <= r <= max_boundary_row`, the fill is horizontal.\n        - Otherwise (boundary doesn't exist, or `r` is outside the span), the fill is vertical.\n    c. Perform ray casting fill along the determined axis:\n        - **Horizontal Fill:**\n            - Cast left from `(r, c-1)`: Change white (0) pixels in the input to orange (7) in the output until a main boundary pixel or the left grid edge is hit.\n            - Cast right from `(r, c+1)`: Change white (0) pixels in the input to orange (7) in the output until a main boundary pixel or the right grid edge is hit.\n        - **Vertical Fill:**\n            - If `r < min_boundary_row` (or no boundary): Cast *downwards* from `(r+1, c)`. Change white (0) pixels to orange (7) until a main boundary pixel or the bottom grid edge is hit.\n            - If `r > max_boundary_row` (or no boundary): Cast *upwards* from `(r-1, c)`. Change white (0) pixels to orange (7) until a main boundary pixel or the top grid edge is hit.\n            - *Note:* The examples suggest seeds outside the boundary only fill towards the boundary.\n6. Return the modified output grid.\n\"\"\"\n\ndef find_largest_connected_component(grid, target_color):\n    \"\"\"Finds the coordinates of the largest connected component (4-way adjacency) of a given color.\"\"\"\n    height, width = grid.shape\n    visited = set()\n    largest_component_coords = set()\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and (r, c) not in visited:\n                current_component_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_component_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (von Neumann)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_component_coords.add((nr, nc))\n                            q.append((nr, nc))\n\n                if len(current_component_coords) > len(largest_component_coords):\n                    largest_component_coords = current_component_coords\n\n    return largest_component_coords\n\ndef get_row_span(component_coords):\n    \"\"\"Calculates the min and max row indices for a set of coordinates.\"\"\"\n    if not component_coords:\n        return -1, -1 # Indicate no component found or empty component\n    rows = [r for r, c in component_coords]\n    return min(rows), max(rows)\n\ndef transform(input_grid):\n    \"\"\"Applies the directional ray-cast fill transformation.\"\"\"\n    \n    # Convert to numpy array for easier manipulation\n    input_arr = np.array(input_grid, dtype=int)\n    # Create a copy to modify for the output\n    output_arr = np.copy(input_arr)\n    height, width = input_arr.shape\n\n    # Define colors\n    WHITE = 0\n    YELLOW = 4\n    ORANGE = 7\n\n    # --- Step 2: Identify the largest yellow component (main boundary) ---\n    main_boundary_coords = find_largest_connected_component(input_arr, YELLOW)\n\n    # --- Step 3: Calculate the boundary's row span ---\n    min_boundary_row, max_boundary_row = get_row_span(main_boundary_coords)\n    boundary_exists = bool(main_boundary_coords) # True if the set is not empty\n\n    # --- Step 4: Find all orange seed pixels ---\n    seed_coords = []\n    for r in range(height):\n        for c in range(width):\n            if input_arr[r, c] == ORANGE:\n                seed_coords.append((r, c))\n\n    # --- Step 5: Process each seed pixel ---\n    for r_seed, c_seed in seed_coords:\n        \n        # --- Step 5a: Ensure seed pixel is orange in output ---\n        output_arr[r_seed, c_seed] = ORANGE\n\n        # --- Step 5b: Determine fill type (Horizontal or Vertical) ---\n        is_horizontal_fill = False\n        if boundary_exists and min_boundary_row <= r_seed <= max_boundary_row:\n            is_horizontal_fill = True\n\n        # --- Step 5c: Perform ray casting fill ---\n        if is_horizontal_fill:\n            # Fill Left\n            for c in range(c_seed - 1, -1, -1):\n                current_coord = (r_seed, c)\n                if current_coord in main_boundary_coords:\n                    break # Stop at boundary\n                # Check the *input* array for white, modify the *output* array\n                if input_arr[r_seed, c] == WHITE:\n                    output_arr[r_seed, c] = ORANGE\n                # Note: Based on analysis, fill continues through non-white, non-boundary pixels.\n                # If it should stop at any non-white, add: elif input_arr[r_seed, c] != WHITE: break\n\n            # Fill Right\n            for c in range(c_seed + 1, width):\n                current_coord = (r_seed, c)\n                if current_coord in main_boundary_coords:\n                    break # Stop at boundary\n                if input_arr[r_seed, c] == WHITE:\n                    output_arr[r_seed, c] = ORANGE\n                # elif input_arr[r_seed, c] != WHITE: break\n\n        else: # Vertical Fill (Directional)\n            # Determine direction based on seed position relative to boundary\n            fill_up = False\n            fill_down = False\n\n            if not boundary_exists:\n                 # If no boundary, maybe fill both ways? Let's assume fill both based on lack of constraint.\n                 # However, examples had boundaries. Let's stick to example-driven logic first.\n                 # Refined logic: If outside boundary, fill *towards* boundary.\n                 pass # No fill if no boundary and seed isn't inside hypothetical span? Seems unlikely.\n                 # Let's assume the task implies a boundary exists if vertical fill happens.\n                 # Revisit if a test case without boundary appears.\n            elif r_seed < min_boundary_row:\n                fill_down = True\n            elif r_seed > max_boundary_row:\n                fill_up = True\n            # If r_seed is on the boundary row but outside the horizontal span logic\n            # this 'else' branch wouldn't be reached due to the `is_horizontal_fill` check.\n\n            # Fill Upwards (if applicable)\n            if fill_up:\n                for r in range(r_seed - 1, -1, -1):\n                    current_coord = (r, c_seed)\n                    if current_coord in main_boundary_coords:\n                        break # Stop at boundary\n                    if input_arr[r, c_seed] == WHITE:\n                        output_arr[r, c_seed] = ORANGE\n                    # elif input_arr[r, c_seed] != WHITE: break\n\n            # Fill Downwards (if applicable)\n            if fill_down:\n                 for r in range(r_seed + 1, height):\n                    current_coord = (r, c_seed)\n                    if current_coord in main_boundary_coords:\n                        break # Stop at boundary\n                    if input_arr[r, c_seed] == WHITE:\n                        output_arr[r, c_seed] = ORANGE\n                    # elif input_arr[r, c_seed] != WHITE: break\n\n\n    # --- Step 6: Return the final grid ---\n    # Convert back to list of lists for the required output format\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10865,
    "candidates_token_count": 2122,
    "total_token_count": 12987,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.178485,
  "retries": 1
}