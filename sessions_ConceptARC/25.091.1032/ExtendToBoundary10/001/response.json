{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation rule:\n1. Identify the largest connected component of yellow (4) pixels, which forms the main boundary structure.\n2. Calculate the vertical span (minimum and maximum row indices) of this main boundary structure.\n3. Find all orange (7) 'seed' pixels.\n4. For each orange seed pixel at (r, c):\n    a. Determine the fill direction based on its row 'r' relative to the boundary's vertical span. If 'r' is within the span (inclusive), fill horizontally. Otherwise, fill vertically.\n    b. Perform a 'ray cast' fill along the determined axis (row 'r' or column 'c').\n    c. Starting from the seed pixel's location, change adjacent white (0) pixels in the input grid to orange (7) in the output grid along the determined axis (in both directions).\n    d. Stop the fill in a given direction when a pixel belonging to the main yellow boundary component is encountered or the grid edge is reached.\n    e. The original seed pixel location is also colored orange (7) in the output grid.\n5. All other pixels retain their original colors.\n\"\"\"\n\ndef find_largest_connected_component(grid, target_color):\n    \"\"\"Finds the largest connected component of a given color in the grid.\"\"\"\n    height, width = grid.shape\n    visited = set()\n    largest_component = set()\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == target_color and (r, c) not in visited:\n                current_component = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors (including diagonals for connectivity)\n                    # Although ARC usually uses 4-way adjacency for objects,\n                    # let's use 4-way (von Neumann) for finding the component itself.\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == target_color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_component.add((nr, nc))\n                            q.append((nr, nc))\n\n                if len(current_component) > len(largest_component):\n                    largest_component = current_component\n\n    return largest_component\n\ndef get_bounding_box_rows(component_coords):\n    \"\"\"Calculates the min and max row indices for a set of coordinates.\"\"\"\n    if not component_coords:\n        return -1, -1 # Indicate no component found or empty component\n    rows = [r for r, c in component_coords]\n    return min(rows), max(rows)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the ray-cast fill transformation based on orange seeds and a yellow boundary.\n    \"\"\"\n    input_arr = np.array(input_grid, dtype=int)\n    output_arr = np.copy(input_arr)\n    height, width = input_arr.shape\n\n    # Define colors\n    WHITE = 0\n    YELLOW = 4\n    ORANGE = 7\n\n    # 1. Identify the largest connected component of yellow (4) pixels\n    main_boundary_coords = find_largest_connected_component(input_arr, YELLOW)\n\n    # Handle case where no boundary is found (though unlikely based on examples)\n    if not main_boundary_coords:\n         # If no boundary, maybe default behavior? Or just return copy?\n         # For now, assume boundary exists. If needed, add logic here.\n         # Let's proceed assuming boundary exists. Find seeds first anyway.\n         min_boundary_row, max_boundary_row = -1, -1 # Indicate no boundary impact\n    else:\n       # 2. Calculate the vertical span (min/max rows) of the main boundary\n       min_boundary_row, max_boundary_row = get_bounding_box_rows(main_boundary_coords)\n\n\n    # 3. Find all orange (7) seed pixels\n    seed_coords = []\n    for r in range(height):\n        for c in range(width):\n            if input_arr[r, c] == ORANGE:\n                seed_coords.append((r, c))\n\n    # 4. Process each seed pixel\n    for r_seed, c_seed in seed_coords:\n        # Set the seed pixel itself to orange in the output\n        output_arr[r_seed, c_seed] = ORANGE\n\n        # 4a. Determine fill direction\n        # If no boundary was found, default to vertical? Or horizontal? Let's default to vertical.\n        is_horizontal = False\n        if min_boundary_row != -1 : # Check if boundary exists\n             is_horizontal = (min_boundary_row <= r_seed <= max_boundary_row)\n\n\n        # 4b/c/d. Perform ray cast fill\n        if is_horizontal:\n            # Fill left\n            for c in range(c_seed - 1, -1, -1):\n                if (r_seed, c) in main_boundary_coords:\n                    break # Stop at boundary\n                if input_arr[r_seed, c] == WHITE:\n                    output_arr[r_seed, c] = ORANGE\n                # Optional: Should it stop if it hits *any* non-white pixel?\n                # Based on examples, it seems to only stop at the *main* boundary yellow.\n                # Let's stick to stopping only at main boundary or grid edge.\n\n            # Fill right\n            for c in range(c_seed + 1, width):\n                if (r_seed, c) in main_boundary_coords:\n                    break # Stop at boundary\n                if input_arr[r_seed, c] == WHITE:\n                    output_arr[r_seed, c] = ORANGE\n\n        else: # Vertical fill\n            # Fill up\n            for r in range(r_seed - 1, -1, -1):\n                if (r, c_seed) in main_boundary_coords:\n                    break # Stop at boundary\n                if input_arr[r, c_seed] == WHITE:\n                    output_arr[r, c_seed] = ORANGE\n\n            # Fill down\n            for r in range(r_seed + 1, height):\n                if (r, c_seed) in main_boundary_coords:\n                    break # Stop at boundary\n                if input_arr[r, c_seed] == WHITE:\n                    output_arr[r, c_seed] = ORANGE\n\n    # Convert back to list of lists for the required output format\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3849,
    "candidates_token_count": 1606,
    "total_token_count": 5455,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.931448,
  "retries": 1
}