{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n\"\"\"\nTransformation Rule:\n1. Identify the two distinct non-white connected objects in the input grid.\n2. Determine which object acts as the 'outer_frame' (it encloses the other object) and which is the 'inner_object'.\n3. Record the color of the 'inner_object' ('inner_color').\n4. Identify the 'interior white pixels': these are the pixels that have color white (0) in the input grid AND are not reachable by a flood fill starting from the white pixels on the grid's border.\n5. Create a copy of the input grid.\n6. Change the color of only the identified 'interior white pixels' in the copied grid to the 'inner_color'.\n7. Return the modified grid.\n\"\"\"\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"\n    Finds connected components of non-background colors.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to treat as background.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'label', 'color', 'coords', 'slice', 'size', 'bbox'.\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    objects = []\n    # Create a boolean mask where non-background pixels are True\n    mask = grid != background_color\n    # Label connected components (using default connectivity=1, 4-neighbors)\n    # For 8-connectivity (including diagonals), use structure=np.ones((3,3))\n    labeled_array, num_features = label(mask) \n    \n    if num_features == 0:\n        return objects\n\n    # Find the locations (slices) of each labeled feature\n    slices = find_objects(labeled_array)\n    \n    for i in range(num_features):\n        component_label = i + 1\n        loc = slices[i]\n        # Get the coordinates of the pixels belonging to this component relative to the grid origin\n        coords = np.argwhere(labeled_array == component_label)\n        # Determine the color of the component (assuming it's uniform)\n        # Take the color of the first pixel in the component\n        if coords.size > 0:\n            color = grid[coords[0, 0], coords[0, 1]] \n            # Calculate size (number of pixels)\n            size = len(coords)\n            # Bounding box: (min_row, min_col, max_row, max_col) inclusive\n            min_row = loc[0].start\n            min_col = loc[1].start\n            max_row = loc[0].stop - 1 # slices are exclusive at stop\n            max_col = loc[1].stop - 1\n            bbox = (min_row, min_col, max_row, max_col)\n\n            objects.append({\n                'label': component_label,\n                'color': color,\n                'coords': coords,\n                'slice': loc,\n                'size': size,\n                'bbox': bbox \n            })\n        \n    # Sort objects by size (descending) - might be useful but not strictly necessary for enclosure check\n    # objects.sort(key=lambda o: o['size'], reverse=True) \n    \n    return objects\n\ndef flood_fill_exterior(grid, background_color=0):\n    \"\"\"\n    Performs a flood fill from the borders to identify exterior white pixels.\n    \n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color representing the background/empty space.\n\n    Returns:\n        np.array: A boolean mask of the same shape as grid. \n                  True indicates an exterior pixel (reachable background from border) \n                  or a non-background pixel. \n                  False indicates an interior background pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    # Mask to keep track of visited/exterior pixels, initialized to False\n    exterior_mask = np.zeros_like(grid, dtype=bool)\n    \n    # Queue for BFS (row, col)\n    queue = []\n\n    # Add all border background pixels to the queue and mark as exterior\n    for r in range(rows):\n        if grid[r, 0] == background_color and not exterior_mask[r, 0]:\n            queue.append((r, 0))\n            exterior_mask[r, 0] = True\n        if grid[r, cols - 1] == background_color and not exterior_mask[r, cols - 1]:\n            queue.append((r, cols - 1))\n            exterior_mask[r, cols - 1] = True\n            \n    for c in range(cols):\n        if grid[0, c] == background_color and not exterior_mask[0, c]:\n            queue.append((0, c))\n            exterior_mask[0, c] = True\n        if grid[rows - 1, c] == background_color and not exterior_mask[rows - 1, c]:\n            queue.append((rows - 1, c))\n            exterior_mask[rows - 1, c] = True\n\n    # Define 4-directional neighbors\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # BFS\n    head = 0\n    while head < len(queue):\n        r, c = queue[head]\n        head += 1\n\n        for dr, dc in moves:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If neighbor is background and not yet visited\n                if grid[nr, nc] == background_color and not exterior_mask[nr, nc]:\n                    exterior_mask[nr, nc] = True\n                    queue.append((nr, nc))\n                    \n    # Also mark all non-background pixels as non-interior (part of exterior_mask)\n    # This prevents flood fill from crossing object boundaries implicitly\n    # and ensures non-background pixels are never considered 'interior white'.\n    exterior_mask[grid != background_color] = True\n\n    return exterior_mask\n\ndef is_bbox_contained(inner_bbox, outer_bbox):\n    \"\"\"Checks if inner_bbox is strictly contained within outer_bbox.\"\"\"\n    inner_min_r, inner_min_c, inner_max_r, inner_max_c = inner_bbox\n    outer_min_r, outer_min_c, outer_max_r, outer_max_c = outer_bbox\n    return (outer_min_r < inner_min_r and\n            outer_min_c < inner_min_c and\n            outer_max_r > inner_max_r and\n            outer_max_c > inner_max_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Fills the empty white space (0) inside an outer boundary shape \n    with the color of an inner shape, leaving the inner shape itself intact.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    background_color = 0\n    \n    # --- 1. Identify Objects ---\n    objects = find_connected_components(input_grid, background_color=background_color)\n    \n    # Expect exactly two objects for this task based on examples\n    if len(objects) != 2:\n        # If not exactly two objects, the pattern doesn't match; return original grid.\n        # This handles cases with no objects, one object, or more than two.\n        # print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning original grid.\")\n        return output_grid \n        \n    # --- 2. Determine Outer Frame and Inner Object ---\n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # Check which object's bounding box contains the other's\n    # Note: Using strict containment '<' and '>' to avoid ambiguity if boxes touch.\n    if is_bbox_contained(obj2['bbox'], obj1['bbox']):\n        outer_frame = obj1\n        inner_object = obj2\n    elif is_bbox_contained(obj1['bbox'], obj2['bbox']):\n        outer_frame = obj2\n        inner_object = obj1\n    else:\n        # Bounding boxes don't show clear containment, pattern might be different\n        # or objects might be side-by-side. Return original grid.\n        # print(\"Warning: Could not determine clear enclosure based on bounding boxes. Returning original grid.\")\n        return output_grid\n\n    inner_color = inner_object['color']\n\n    # --- 3. Identify Interior White Pixels using Flood Fill ---\n    # exterior_mask is True for exterior background and all non-background pixels.\n    # False indicates interior background pixels.\n    exterior_mask = flood_fill_exterior(input_grid, background_color=background_color)\n\n    # --- 4. Define the mask for pixels to be filled ---\n    # Pixels to fill are those that are background (0) AND not exterior (i.e., interior)\n    interior_white_mask = (input_grid == background_color) & (~exterior_mask)\n                \n    # --- 5. Fill Interior White Pixels ---\n    # Use the boolean mask to update only the interior white pixels in the output grid\n    output_grid[interior_white_mask] = inner_color\n                \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18529,
    "candidates_token_count": 2230,
    "total_token_count": 20759,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.614669,
  "retries": 1
}