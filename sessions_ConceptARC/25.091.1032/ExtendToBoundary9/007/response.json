{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransformation Rule:\n1. Identify the two distinct non-white connected objects in the input grid using 8-way connectivity. Assume one acts as an 'outer_frame' enclosing the other, the 'inner_object'.\n2. Determine which object is the outer frame and which is the inner object based on bounding box containment. If exactly two objects are not found, or if neither encloses the other, return the original grid.\n3. Record the color of the 'inner_object' ('inner_color').\n4. Determine the minimum and maximum row indices occupied by the 'inner_object' ('inner_min_row', 'inner_max_row').\n5. Create a copy of the input grid.\n6. Iterate through each row 'r' from 'inner_min_row' to 'inner_max_row'.\n7. For each row 'r', find the minimum ('min_col_frame') and maximum ('max_col_frame') column indices where the 'outer_frame' exists in that specific row.\n8. Within row 'r', iterate through columns 'c' from 'min_col_frame' to 'max_col_frame'.\n9. If the pixel at (r, c) in the *input* grid has the background color (0), change its color in the *output* grid to 'inner_color'.\n10. Return the modified output grid.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\n\n# Define 8-connectivity structure for scipy.ndimage.label\nCONNECTIVITY_STRUCTURE_8 = np.ones((3, 3), dtype=bool)\n\ndef find_connected_components(grid, background_color=0, connectivity_structure=CONNECTIVITY_STRUCTURE_8):\n    \"\"\"\n    Finds connected components of non-background colors using specified connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to treat as background.\n        connectivity_structure (np.array): The structure defining pixel connectivity.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'label', 'color', 'coords', 'slice', 'size', 'bbox'.\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    objects = []\n    mask = grid != background_color\n    # Label connected components using the specified connectivity structure\n    labeled_array, num_features = label(mask, structure=connectivity_structure) \n    \n    if num_features == 0:\n        return objects\n\n    slices = find_objects(labeled_array)\n    \n    for i in range(num_features):\n        component_label = i + 1\n        # Ensure slices[i] is not None before accessing its attributes\n        if slices[i] is None:\n            continue # Should not happen if num_features > 0, but good practice\n\n        loc = slices[i]\n        coords = np.argwhere(labeled_array == component_label)\n        \n        if coords.size > 0:\n            color = grid[coords[0, 0], coords[0, 1]] \n            size = len(coords)\n            # Ensure loc has the expected structure (tuple of slices)\n            if isinstance(loc, tuple) and len(loc) == 2 and \\\n               isinstance(loc[0], slice) and isinstance(loc[1], slice):\n                min_row = loc[0].start\n                min_col = loc[1].start\n                max_row = loc[0].stop - 1 \n                max_col = loc[1].stop - 1\n                bbox = (min_row, min_col, max_row, max_col)\n\n                objects.append({\n                    'label': component_label,\n                    'color': color,\n                    'coords': coords, # Array of [row, col] pairs\n                    'slice': loc,\n                    'size': size,\n                    'bbox': bbox \n                })\n            else:\n                # Handle unexpected slice format if necessary\n                print(f\"Warning: Unexpected slice format for component {component_label}: {loc}\")\n                # Fallback: calculate bbox from coords\n                min_row = np.min(coords[:, 0])\n                min_col = np.min(coords[:, 1])\n                max_row = np.max(coords[:, 0])\n                max_col = np.max(coords[:, 1])\n                bbox = (min_row, min_col, max_row, max_col)\n                objects.append({\n                    'label': component_label,\n                    'color': color,\n                    'coords': coords,\n                    'slice': loc, # Store original slice even if format was odd\n                    'size': size,\n                    'bbox': bbox\n                })\n\n    return objects\n\ndef is_bbox_contained(inner_bbox, outer_bbox):\n    \"\"\"Checks if inner_bbox is strictly contained within outer_bbox.\"\"\"\n    inner_min_r, inner_min_c, inner_max_r, inner_max_c = inner_bbox\n    outer_min_r, outer_min_c, outer_max_r, outer_max_c = outer_bbox\n    # Use strict inequality to ensure the inner object is truly inside\n    return (outer_min_r < inner_min_r and\n            outer_min_c < inner_min_c and\n            outer_max_r > inner_max_r and\n            outer_max_c > inner_max_c)\n\ndef transform(input_grid):\n    # initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    background_color = 0\n    \n    # --- Step 1: Identify Objects using 8-way connectivity ---\n    objects = find_connected_components(input_grid, background_color=background_color, connectivity_structure=CONNECTIVITY_STRUCTURE_8)\n    \n    # --- Step 2: Verify exactly two objects and determine frame/inner ---\n    if len(objects) != 2:\n        # If not exactly two objects, pattern doesn't match; return original grid.\n        return output_grid \n        \n    obj1 = objects[0]\n    obj2 = objects[1]\n    \n    # Check for bounding box containment to identify outer and inner\n    if is_bbox_contained(obj2['bbox'], obj1['bbox']):\n        outer_frame = obj1\n        inner_object = obj2\n    elif is_bbox_contained(obj1['bbox'], obj2['bbox']):\n        outer_frame = obj2\n        inner_object = obj1\n    else:\n        # No clear containment, pattern doesn't match; return original grid.\n        return output_grid\n\n    # --- Step 3: Record inner object's color ---\n    inner_color = inner_object['color']\n\n    # --- Step 4: Determine row range of the inner object ---\n    inner_min_row, _, inner_max_row, _ = inner_object['bbox']\n\n    # Precompute frame coordinates for efficient lookup per row\n    frame_coords_set = set(tuple(coord) for coord in outer_frame['coords'])\n\n    # --- Steps 5-9: Iterate through relevant rows and columns and fill ---\n    # Iterate through each row spanned by the inner object\n    for r in range(inner_min_row, inner_max_row + 1):\n        # Find the horizontal extent (min/max columns) of the outer frame *in this specific row*\n        frame_cols_in_row = [c for row, c in outer_frame['coords'] if row == r]\n        \n        # If the frame doesn't exist in this row (e.g., concave shapes), skip row? \n        # Or should we use the overall bbox col limits? \n        # Based on example 1, seems we need frame boundary in that row.\n        if not frame_cols_in_row:\n            continue # Skip rows where the outer frame has no presence\n\n        min_col_frame = min(frame_cols_in_row)\n        max_col_frame = max(frame_cols_in_row)\n\n        # Iterate through columns within the frame's bounds for this row\n        for c in range(min_col_frame, max_col_frame + 1):\n            # Check if the pixel in the *input* grid is background\n            if input_grid[r, c] == background_color:\n                 # Fill the corresponding pixel in the output grid\n                 output_grid[r, c] = inner_color\n\n    # --- Step 10: Return the modified grid ---\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17468,
    "candidates_token_count": 1989,
    "total_token_count": 19457,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.820444,
  "retries": 1
}