{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransformation Rule:\n\n1. Identify a barrier object composed of gray (5) pixels. Determine if it forms a predominantly vertical or horizontal line.\n2. Find all 'source' pixels, which are pixels neither white (0) nor gray (5).\n3. For each source pixel:\n    a. If the barrier is vertical at column `barrier_col`:\n        - If the source pixel is to the left (`source_col < barrier_col`), fill the row horizontally to the right with the source pixel's color, stopping just before the barrier column.\n        - If the source pixel is to the right (`source_col > barrier_col`), fill the row horizontally to the left with the source pixel's color, stopping just after the barrier column.\n    b. If the barrier is horizontal at row `barrier_row`:\n        - If the source pixel is above (`source_row < barrier_row`), fill the column vertically downwards with the source pixel's color, stopping just before the barrier row.\n        - If the source pixel is below (`source_row > barrier_row`), fill the column vertically upwards with the source pixel's color, stopping just after the barrier row.\n4. Pixels belonging to the barrier or the background remain unchanged unless painted over by the extension process.\n\"\"\"\n\ndef find_barrier(grid):\n    \"\"\"\n    Finds the coordinates of gray (5) pixels and determines the barrier orientation.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple: (orientation, index)\n        - orientation: 'horizontal', 'vertical', or None if no clear line barrier.\n        - index: The row index if horizontal, the column index if vertical, or None.\n        Returns (None, None) if no barrier is found.\n    \"\"\"\n    gray_coords = np.argwhere(grid == 5)\n    if gray_coords.size == 0:\n        return None, None  # No barrier found\n\n    rows = gray_coords[:, 0]\n    cols = gray_coords[:, 1]\n\n    # Check if all gray pixels are in the same row (horizontal line)\n    if np.all(rows == rows[0]):\n        return 'horizontal', rows[0]\n\n    # Check if all gray pixels are in the same column (vertical line)\n    if np.all(cols == cols[0]):\n        return 'vertical', cols[0]\n\n    # If neither, it's not a simple line barrier as seen in examples\n    # Might need more complex logic for other shapes, but based on examples:\n    return None, None\n\n\ndef find_source_pixels(grid):\n    \"\"\"\n    Finds the coordinates and colors of source pixels (not white 0, not gray 5).\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of tuples: [(row, col, color), ...]\n    \"\"\"\n    source_pixels = []\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != 0 and color != 5:\n                source_pixels.append((r, c, color))\n    return source_pixels\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    Extends source pixels towards a gray barrier line.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    height, width = grid.shape\n\n    # 1. Identify the barrier\n    barrier_orientation, barrier_index = find_barrier(grid)\n\n    # If no barrier is found or it's not a simple line, return the original grid (or handle error)\n    if barrier_orientation is None:\n        return output_grid.tolist() # Return as list of lists per spec\n\n    # 2. Find source pixels\n    source_pixels = find_source_pixels(grid)\n\n    # 3. Process each source pixel\n    for r, c, color in source_pixels:\n        if barrier_orientation == 'vertical':\n            barrier_col = barrier_index\n            # a. Extend horizontally\n            if c < barrier_col:\n                # Extend right towards the barrier\n                for fill_c in range(c + 1, barrier_col):\n                    # Check bounds just in case, though range should handle it\n                    if 0 <= fill_c < width:\n                         # Only paint over background (0) - added this constraint based on potential interpretation\n                         # Re-evaluating: examples show painting over background only. Let's stick to the original plan.\n                         # Examples show painting only happens on background (0) pixels. Let's confirm train_1.\n                         # train_1 output confirms painting occurs only on 0s.\n                         # Let's undo the constraint below, paint regardless, as per initial interpretation.\n                         # Correction: The original interpretation fills the space regardless of what's there,\n                         # but the *examples* only show filling over 0s. Let's fill the range.\n                        output_grid[r, fill_c] = color\n            elif c > barrier_col:\n                # Extend left towards the barrier\n                # range(start, stop) goes up to stop-1. We want to go from barrier_col+1 up to c-1.\n                for fill_c in range(barrier_col + 1, c):\n                     if 0 <= fill_c < width:\n                        output_grid[r, fill_c] = color\n\n        elif barrier_orientation == 'horizontal':\n            barrier_row = barrier_index\n            # b. Extend vertically\n            if r < barrier_row:\n                # Extend down towards the barrier\n                for fill_r in range(r + 1, barrier_row):\n                    if 0 <= fill_r < height:\n                        output_grid[fill_r, c] = color\n            elif r > barrier_row:\n                # Extend up towards the barrier\n                for fill_r in range(barrier_row + 1, r):\n                     if 0 <= fill_r < height:\n                        output_grid[fill_r, c] = color\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3151,
    "candidates_token_count": 1446,
    "total_token_count": 4597,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.454842,
  "retries": 1
}