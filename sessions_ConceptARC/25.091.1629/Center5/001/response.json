{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects as scipy_find_objects, center_of_mass\n\n\"\"\"\nIdentify all distinct non-background colored objects (connected components) in the \ninput grid. Determine the largest object; this is the \"line\". All other objects \nare \"dots\". Find the orientation (horizontal or vertical) and the midpoint \ncoordinate of the line along its main axis (column for horizontal, row for vertical).\nCalculate the centroid coordinate (average row and column) of all pixels belonging \nto the \"dot\" objects combined. Compare the centroid coordinate to the line's \nmidpoint coordinate along the line's main axis to determine the movement direction \n(left/right for horizontal lines, up/down for vertical lines) and magnitude (the \nabsolute difference between the centroid and midpoint coordinates along that axis). \nCreate the output grid by copying the input grid. Erase the original \"dot\" objects \nfrom the output grid. Draw the \"dot\" objects in their new positions by shifting \neach original dot pixel according to the calculated direction and magnitude.\n\"\"\"\n\ndef find_all_objects(grid):\n    \"\"\"\n    Finds all connected components of non-background colors.\n    Returns a list of objects, where each object is a tuple: \n    (color, list_of_coordinates).\n    \"\"\"\n    objects = []\n    # Iterate through colors 1 to 9\n    for color in range(1, 10):\n        # Create a binary mask for the current color\n        binary_mask = (grid == color).astype(int)\n        # Label connected components of this color\n        labeled_array, num_features = label(binary_mask)\n        if num_features > 0:\n            # Find the locations (slices) of each component\n            locations = scipy_find_objects(labeled_array)\n            for i in range(num_features):\n                loc = locations[i]\n                # Get coordinates where the labeled array matches the current component index\n                coords = np.argwhere(labeled_array[loc] == (i + 1))\n                # Adjust coordinates relative to the original grid\n                coords[:, 0] += loc[0].start\n                coords[:, 1] += loc[1].start\n                # Store as list of (row, col) tuples\n                coord_list = [tuple(c) for c in coords]\n                objects.append({'color': color, 'coords': coord_list, 'size': len(coord_list)})\n    return objects\n\ndef get_line_properties(obj_coords):\n    \"\"\"\n    Determines orientation, midpoint, min/max row/col for a line object.\n    Returns a dictionary with properties or None if not a line.\n    \"\"\"\n    if not obj_coords:\n        return None\n\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n\n    is_horizontal = all(r == min_row for r in rows) and (max_col - min_col + 1 == len(obj_coords))\n    is_vertical = all(c == min_col for c in cols) and (max_row - min_row + 1 == len(obj_coords))\n\n    if is_horizontal:\n        midpoint_row = min_row\n        midpoint_col = (min_col + max_col) / 2.0\n        return {\n            'orientation': 'horizontal',\n            'midpoint': (midpoint_row, midpoint_col),\n            'min_row': min_row, 'max_row': max_row,\n            'min_col': min_col, 'max_col': max_col\n        }\n    elif is_vertical:\n        midpoint_row = (min_row + max_row) / 2.0\n        midpoint_col = min_col\n        return {\n            'orientation': 'vertical',\n            'midpoint': (midpoint_row, midpoint_col),\n            'min_row': min_row, 'max_row': max_row,\n            'min_col': min_col, 'max_col': max_col\n        }\n    else:\n        # This function assumes the largest object is always a line per the analysis.\n        # If it could be something else, more robust checks are needed.\n        # Let's add a basic fallback for slightly imperfect lines found by connectivity.\n        if max_row == min_row: # Horizontal tendency\n            midpoint_row = min_row\n            midpoint_col = (min_col + max_col) / 2.0\n            return {\n                'orientation': 'horizontal',\n                'midpoint': (midpoint_row, midpoint_col),\n                'min_row': min_row, 'max_row': max_row,\n                'min_col': min_col, 'max_col': max_col\n            }\n        elif max_col == min_col: # Vertical tendency\n             midpoint_row = (min_row + max_row) / 2.0\n             midpoint_col = min_col\n             return {\n                'orientation': 'vertical',\n                'midpoint': (midpoint_row, midpoint_col),\n                'min_row': min_row, 'max_row': max_row,\n                'min_col': min_col, 'max_col': max_col\n            }\n        return None # Not identifiable as a simple line\n\n\ndef get_combined_centroid(objects_list):\n    \"\"\"Calculates the centroid of all coordinates from a list of objects.\"\"\"\n    all_coords = []\n    for obj in objects_list:\n        all_coords.extend(obj['coords'])\n    \n    if not all_coords:\n        return None\n\n    rows = [r for r, c in all_coords]\n    cols = [c for r, c in all_coords]\n    \n    centroid_row = sum(rows) / len(all_coords)\n    centroid_col = sum(cols) / len(all_coords)\n    \n    return (centroid_row, centroid_col)\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving dot objects relative to a central line object.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    output_array = np.copy(input_array)\n    height, width = input_array.shape\n\n    # 1. Identify all distinct non-background colored objects\n    all_objects = find_all_objects(input_array)\n\n    if not all_objects:\n        return input_grid # No objects, return original grid\n\n    # 2. Determine the largest object (line) and others (dots)\n    all_objects.sort(key=lambda x: x['size'], reverse=True)\n    line_object = all_objects[0]\n    dot_objects = all_objects[1:]\n\n    # 3. & 4. Find line properties (orientation, midpoint)\n    line_properties = get_line_properties(line_object['coords'])\n    if line_properties is None:\n        # Fallback or error handling if largest object isn't a line\n        print(\"Warning: Largest object doesn't appear to be a simple line.\")\n        # As a fallback, perhaps don't move anything? Or make a best guess?\n        # For now, return original grid if line isn't clear.\n        return input_grid \n        \n    line_midpoint = line_properties['midpoint']\n    line_orientation = line_properties['orientation']\n\n    if not dot_objects:\n        return input_grid # No dots to move\n\n    # 5. Calculate the combined centroid of all dot objects\n    dots_centroid = get_combined_centroid(dot_objects)\n    if dots_centroid is None:\n         return input_grid # Should not happen if dot_objects is not empty\n\n    dots_centroid_row, dots_centroid_col = dots_centroid\n\n    # 6. Determine movement vector (direction and magnitude)\n    move_dr = 0\n    move_dc = 0\n    \n    if line_orientation == 'horizontal':\n        line_midpoint_col = line_midpoint[1]\n        magnitude = abs(dots_centroid_col - line_midpoint_col)\n        # Round magnitude to nearest integer for grid movement\n        move_magnitude = int(round(magnitude)) \n        if dots_centroid_col < line_midpoint_col:\n            move_dc = move_magnitude  # Move right\n        elif dots_centroid_col > line_midpoint_col:\n            move_dc = -move_magnitude # Move left\n            \n    elif line_orientation == 'vertical':\n        line_midpoint_row = line_midpoint[0]\n        magnitude = abs(dots_centroid_row - line_midpoint_row)\n         # Round magnitude to nearest integer for grid movement\n        move_magnitude = int(round(magnitude))\n        if dots_centroid_row < line_midpoint_row:\n            move_dr = move_magnitude  # Move down\n        elif dots_centroid_row > line_midpoint_row:\n            move_dr = -move_magnitude # Move up\n\n    # 7. Create the output grid (already done by copying)\n\n    # 8. Erase original dot objects\n    for dot_obj in dot_objects:\n        for r, c in dot_obj['coords']:\n            if 0 <= r < height and 0 <= c < width:\n                output_array[r, c] = 0 # Set to background color (white)\n\n    # 9. Draw dot objects in new positions\n    for dot_obj in dot_objects:\n        color = dot_obj['color']\n        for r, c in dot_obj['coords']:\n            new_r, new_c = r + move_dr, c + move_dc\n            # Draw only if the new position is within grid bounds\n            if 0 <= new_r < height and 0 <= new_c < width:\n                output_array[new_r, new_c] = color\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3552,
    "candidates_token_count": 2365,
    "total_token_count": 5917,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.71644,
  "retries": 1
}