
## train_1

**input:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 4 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 2 0 0 0 0 0 0 0 0 0 2 0
2 0 0 0 0 0 0 0 0 0 0 0 2
0 2 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 2 0 0 0 0 0 0 0 0 0 2 0
2 0 0 0 0 0 4 0 0 0 0 0 2
0 2 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 7
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 7 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 8 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## Perception

The task involves identifying two primary objects in the input grid based on color: a larger "container" object and a smaller, often single-pixel, "content" object. The container object can be hollow (like the diamond in example 1 or the rectangle frame in example 2) or solid (like the rectangle in example 3). The content object is always located outside the main structure of the container object in the input. The transformation consists of moving the content object to the geometric center of the container object. The original location of the content object is then replaced with the background color (white/0). The container object itself remains unchanged. The color of the content object is preserved during the move.

## Facts


```yaml
objects:
  - type: container
    description: The largest contiguous or structured group of non-white pixels. Can be solid or hollow. Defines a region.
    examples:
      - train_1: Red (2) diamond shape.
      - train_2: Green (3) rectangular frame.
      - train_3: Yellow (4) solid rectangle.
  - type: content
    description: A smaller, often single-pixel, non-white object distinct from the container. Located outside the container in the input.
    examples:
      - train_1: Single yellow (4) pixel.
      - train_2: Single orange (7) pixel.
      - train_3: Single azure (8) pixel.
  - type: background
    description: The default grid color, white (0).

relationships:
  - type: spatial
    description: The content object is initially outside the container object's main area or bounding box.
  - type: containment (implied in output)
    description: The content object is moved to be inside the container object's central region in the output.

actions:
  - action: identify_objects
    description: Distinguish the container object, the content object(s), and the background based on color and size/structure. The container is typically the largest object.
  - action: find_center
    description: Calculate the geometric center coordinates (row, column) of the container object. This might be the center of its bounding box.
  - action: erase_original_content
    description: Change the pixel(s) at the original location of the content object to the background color (white/0).
  - action: place_content_at_center
    description: Change the pixel at the calculated center coordinates of the container object to the color of the content object.

properties:
  - property: color
    description: Pixels have colors (0-9). Colors distinguish objects. The content object's color is preserved.
  - property: location
    description: Pixels have (row, column) coordinates. The location of the content object changes.
  - property: shape/structure
    description: Objects have shapes (diamond, rectangle, etc.). The container's shape determines the center point.
  - property: size
    description: Objects have sizes (pixel count or bounding box). Size helps differentiate the container from the content.
```


## Natural Language Program

1.  **Identify** all distinct non-white objects in the input grid.
2.  **Determine** which object is the "container" (typically the largest object by pixel count or bounding box area) and which is the "content" (the other non-white object, often a single pixel). Store the color and original location(s) of the content object.
3.  **Calculate** the coordinates (row, column) of the geometric center of the container object. This can be approximated by finding the center of the container's bounding box: `center_row = floor((min_row + max_row) / 2)`, `center_col = floor((min_col + max_col) / 2)`.
4.  **Create** a copy of the input grid to serve as the output grid.
5.  **Modify** the output grid:
    a.  Change the pixel(s) at the original location of the content object to the background color (white/0).
    b.  Change the pixel at the calculated center coordinates to the stored color of the content object.
6.  **Return** the modified grid as the output.
```python
import numpy as np
import math

"""
Identifies two distinct non-white objects in the input grid: a larger 'container' object and a smaller 'content' object. 
Calculates the geometric center of the container object's bounding box.
Creates an output grid by copying the input grid.
In the output grid, replaces the original location(s) of the content object with the background color (white/0).
Places the content object's color at the calculated center coordinates within the container object.
"""

def find_objects(grid, background_color=0):
    """
    Finds all contiguous objects of the same color in the grid, excluding the background color.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color designated as the background.

    Returns:
        list: A list of dictionaries, where each dictionary represents an object
              and contains 'color' (int) and 'coords' (list of tuples (row, col)).
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    for r in range(rows):
        for c in range(cols):
            color = grid[r, c]
            # Start search if pixel is not background and not visited
            if color != background_color and not visited[r, c]:
                current_object_coords = []
                q = [(r, c)]  # Queue for BFS
                visited[r, c] = True
                
                while q:
                    row, col = q.pop(0)
                    current_object_coords.append((row, col))
                    
                    # Check 4-directional neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        # Check bounds, if neighbor has same color, and not visited
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            q.append((nr, nc))
                            
                objects.append({'color': color, 'coords': current_object_coords})
    return objects

def get_bounding_box(coords):
    """
    Calculates the bounding box (min/max row/col) for a set of coordinates.

    Args:
        coords (list): A list of tuples (row, col).

    Returns:
        tuple: (min_row, max_row, min_col, max_col)
    """
    if not coords:
        return None # Or raise an error
    rows = [r for r, c in coords]
    cols = [c for r, c in coords]
    return min(rows), max(rows), min(cols), max(cols)

def transform(input_grid):
    """
    Transforms the input grid by moving a 'content' object to the center 
    of a 'container' object.

    Args:
        input_grid (list of lists): The input grid representation.

    Returns:
        list of lists: The transformed grid representation.
    """
    # Convert input to numpy array for easier manipulation
    input_np = np.array(input_grid, dtype=int)
    output_grid = np.copy(input_np)
    background_color = 0

    # 1. Identify all distinct non-white objects
    objects = find_objects(input_np, background_color)

    # Handle cases with unexpected number of objects
    if len(objects) != 2:
        # Depending on ARC rules, might return input, raise error, or guess.
        # Based on examples, we expect exactly two objects.
        # Let's return the original grid if the assumption doesn't hold.
        # print(f"Warning: Expected 2 objects, found {len(objects)}. Returning original grid.")
        return input_grid # Or handle error appropriately

    # 2. Determine container and content objects (container is larger)
    obj1_size = len(objects[0]['coords'])
    obj2_size = len(objects[1]['coords'])

    if obj1_size > obj2_size:
        container_object = objects[0]
        content_object = objects[1]
    else:
        container_object = objects[1]
        content_object = objects[0]

    content_color = content_object['color']
    content_coords = content_object['coords']
    container_coords = container_object['coords']

    # 3. Calculate the geometric center of the container object's bounding box
    min_row, max_row, min_col, max_col = get_bounding_box(container_coords)
    center_row = (min_row + max_row) // 2  # Floor division for integer index
    center_col = (min_col + max_col) // 2  # Floor division for integer index

    # 4. Modify the output grid (already initialized as a copy)
    # 5a. Erase the original content object
    for r, c in content_coords:
        # Check if coordinates are within grid bounds (safety check)
         if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:
             output_grid[r, c] = background_color

    # 5b. Place the content object's color at the calculated center
    # Check if center coordinates are within grid bounds (safety check)
    if 0 <= center_row < output_grid.shape[0] and 0 <= center_col < output_grid.shape[1]:
        output_grid[center_row, center_col] = content_color
    else:
        # Handle case where center is somehow outside grid - unlikely with bounding box logic
        # print(f"Warning: Calculated center ({center_row}, {center_col}) is outside grid bounds.")
        pass 

    # Convert back to list of lists for the standard ARC format
    return output_grid.tolist()
```
