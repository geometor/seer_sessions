{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, defaultdict, Counter\nimport statistics\n\n\"\"\"\nTransformation Rule:\n1. Find all distinct, contiguous, non-background (non-zero color) objects in the input grid.\n2. For each object found:\n    a. Determine its color (C).\n    b. Calculate its bounding box (B).\n    c. Extract the subgrid (S) defined by the bounding box B from the input grid.\n    d. Check if this subgrid S contains ONLY the object's color C and the background color 0.\n    e. If the check in (d) passes, this object is considered a \"candidate\". Store its color (C), bounding box (B), bounding box area (A), and the extracted subgrid (S).\n3. If no candidates are found, return a default small grid (e.g., [[0]]).\n4. Determine the \"border color\" (BC): Find the color of the largest object (by pixel count) that touches any of the outer edges of the input grid.\n5. Collect the areas (A) of all candidate objects. Find the median area (median_A) among these candidates. If there's an even number of candidates, use the lower of the two middle area values after sorting.\n6. Filter the candidates, keeping only those whose area A equals the median_A.\n7. If only one candidate remains after filtering by median area, select its subgrid (S) as the output.\n8. If multiple candidates remain (tied by having the median area):\n    a. Check if any of the tied candidates' colors (C) match the border color (BC).\n    b. If exactly one tied candidate's color matches BC, select its subgrid (S) as the output.\n    c. If zero or more than one tied candidate's color matches BC, find the median color among these tied candidates. Sort their colors (C) numerically. If there's an odd number, the median is the middle value. If there's an even number, the median color is the lower of the two middle values. Select the subgrid (S) belonging to the candidate with this median color.\n9. Return the selected subgrid S.\n\"\"\"\n\ndef find_objects(grid, colors_to_find=None, connectivity=4):\n    \"\"\"\n    Finds all connected components (objects) of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): A set of color values to search for.\n                                         If None, searches for all non-background (0) colors.\n        connectivity (int): 4 for cardinal directions, 8 for cardinal and diagonal.\n\n    Returns:\n        dict: A dictionary where keys are colors and values are lists of objects.\n              Each object is represented as a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = defaultdict(list)\n\n    if colors_to_find is None:\n        # Find all unique non-zero colors present in the grid\n        unique_colors = np.unique(grid)\n        colors_to_find = set(unique_colors[unique_colors != 0])\n\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in colors_to_find and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Define neighbors based on connectivity\n                    if connectivity == 4:\n                        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                    else: # connectivity == 8\n                         neighbors = [\n                            (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1),\n                            (row - 1, col - 1), (row - 1, col + 1), (row + 1, col - 1), (row + 1, col + 1)\n                         ]\n\n                    for nr, nc in neighbors:\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n\n                if obj_coords:\n                    objects[color].append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"Calculates the bounding box of an object.\"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return (min_r, min_c, max_r, max_c)\n\ndef get_border_color(grid):\n    \"\"\"Finds the color of the largest object (by pixel count) touching the grid borders.\"\"\"\n    rows, cols = grid.shape\n\n    # Find all non-background objects first\n    all_objects = find_objects(grid)\n    largest_border_object_size = -1\n    determined_border_color = 0 # Default to background\n\n    for color, objects_list in all_objects.items():\n        for obj_coords in objects_list:\n            touches_border = False\n            for r, c in obj_coords:\n                if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                    touches_border = True\n                    break\n            if touches_border:\n                obj_size = len(obj_coords)\n                if obj_size > largest_border_object_size:\n                    largest_border_object_size = obj_size\n                    determined_border_color = color\n                # Tie-breaking for largest border object size isn't specified,\n                # assume the first one found with max size determines the color,\n                # or that there won't be ties in the relevant cases.\n\n    return determined_border_color\n\ndef get_median_low(data):\n    \"\"\"Calculates the median, choosing the lower value for even counts.\"\"\"\n    sorted_data = sorted(data)\n    n = len(sorted_data)\n    if n == 0:\n        return None # Or raise error\n    if n % 2 == 1:\n        return sorted_data[n // 2]\n    else:\n        # Lower median for even count\n        return sorted_data[n // 2 - 1]\n\ndef transform(input_grid):\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Find all non-background objects\n    all_objects = find_objects(grid)\n\n    candidates = []\n    # 2-4. Identify Candidate Objects/Subgrids\n    for color, objects_list in all_objects.items():\n        for obj_coords in objects_list:\n            bbox = get_bounding_box(obj_coords)\n            if bbox:\n                min_r, min_c, max_r, max_c = bbox\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                bbox_area = height * width\n\n                # Extract subgrid\n                subgrid = grid[min_r : max_r + 1, min_c : max_c + 1]\n\n                # Check if subgrid contains only object color and background (0)\n                unique_colors_in_subgrid = np.unique(subgrid)\n                allowed_colors = {color, 0}\n                is_candidate = True\n                for c_sub in unique_colors_in_subgrid:\n                    if c_sub not in allowed_colors:\n                        is_candidate = False\n                        break\n\n                if is_candidate:\n                    candidates.append({\n                        'color': color,\n                        'bbox': bbox,\n                        'area': bbox_area,\n                        'subgrid': subgrid\n                    })\n\n    # 3. Handle no candidates\n    if not candidates:\n        return [[0]] # Default output\n\n    # 4. Determine Border Color\n    border_color = get_border_color(grid)\n\n    # 5. Find Median Area\n    candidate_areas = [cand['area'] for cand in candidates]\n    median_area = get_median_low(candidate_areas)\n\n    # 6. Filter by Median Area\n    median_area_candidates = [cand for cand in candidates if cand['area'] == median_area]\n\n    selected_candidate = None\n    # 7. Select if only one candidate has median area\n    if len(median_area_candidates) == 1:\n        selected_candidate = median_area_candidates[0]\n    # 8. Handle ties in median area"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12052,
    "candidates_token_count": 2128,
    "total_token_count": 14180,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 68.9648,
  "retries": 1
}