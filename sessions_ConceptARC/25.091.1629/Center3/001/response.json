{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\n1. Identify the 'border color' by finding the color (excluding white/0) of the largest object that touches the edges of the input grid.\n2. Scan the input grid to find all distinct contiguous objects made of a single color (excluding white/0).\n3. For each object found, determine its bounding box.\n4. Check if the object is a 'solid rectangle' by verifying that the number of pixels in the object equals the area of its bounding box.\n5. Calculate the area (width * height) of the bounding box for each solid rectangle.\n6. Identify the maximum area found among all solid rectangles.\n7. Filter the list of solid rectangles to keep only those with the maximum area.\n8. If only one solid rectangle has the maximum area, select this rectangle.\n9. If multiple solid rectangles share the maximum area (a tie):\n    a. Check if any of the tied rectangles have the same color as the 'border color'.\n    b. If exactly one tied rectangle matches the border color, select that rectangle.\n    c. If none of the tied rectangles match the border color (or more than one matches), collect the color indices of all the tied rectangles. Find the median value among these indices. Select the rectangle whose color index is this median value. If there's an even number of tied colors, use the lower of the two middle values after sorting.\n10. Create the output grid containing only the pixels of the selected target rectangle, defined by its bounding box.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque, defaultdict, Counter\nimport statistics\n\ndef find_objects(grid, colors_to_find=None, connectivity=4):\n    \"\"\"\n    Finds all connected components (objects) of specified colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_find (set, optional): A set of color values to search for.\n                                         If None, searches for all non-background (0) colors.\n        connectivity (int): 4 for cardinal directions, 8 for cardinal and diagonal.\n\n    Returns:\n        dict: A dictionary where keys are colors and values are lists of objects.\n              Each object is represented as a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = defaultdict(list)\n\n    if colors_to_find is None:\n        colors_to_find = set(np.unique(grid)) - {0}\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color in colors_to_find and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Define neighbors based on connectivity\n                    if connectivity == 4:\n                        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n                    else: # connectivity == 8\n                         neighbors = [\n                            (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1),\n                            (row - 1, col - 1), (row - 1, col + 1), (row + 1, col - 1), (row + 1, col + 1)\n                         ]\n\n                    for nr, nc in neighbors:\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            obj_coords.add((nr, nc))\n\n                if obj_coords:\n                    objects[color].append(obj_coords)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"Calculates the bounding box of an object.\"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    return (min_r, min_c, max_r, max_c)\n\ndef get_border_color(grid):\n    \"\"\"Finds the color of the largest object touching the grid borders.\"\"\"\n    rows, cols = grid.shape\n    border_pixels = set()\n    for r in range(rows):\n        border_pixels.add((r, 0))\n        border_pixels.add((r, cols - 1))\n    for c in range(cols):\n        border_pixels.add((0, c))\n        border_pixels.add((rows - 1, c))\n\n    border_object_sizes = Counter()\n    visited = np.zeros_like(grid, dtype=bool)\n    max_size = -1\n    border_color = 0 # Default to background if no border objects\n\n    for r_start, c_start in border_pixels:\n        color = grid[r_start, c_start]\n        if color != 0 and not visited[r_start, c_start]:\n            current_object_coords = set()\n            q = deque([(r_start, c_start)])\n            visited[r_start, c_start] = True\n            current_object_coords.add((r_start, c_start))\n            is_border_object = False\n\n            while q:\n                r, c = q.popleft()\n                if (r == 0 or r == rows - 1 or c == 0 or c == cols - 1):\n                     is_border_object = True\n\n                # 4-connectivity for neighbors\n                neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]\n                for nr, nc in neighbors:\n                    if 0 <= nr < rows and 0 <= nc < cols and \\\n                       not visited[nr, nc] and grid[nr, nc] == color:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n                        current_object_coords.add((nr, nc))\n\n            if is_border_object:\n                 obj_size = len(current_object_coords)\n                 # Accumulate size for the color (in case a border object is found multiple times)\n                 # This part is tricky, maybe just finding the single largest connected border object is better.\n                 # Let's reset the visited check and find all objects first, then check border touch & size.\n\n    # Alternative approach: Find all non-background objects first\n    all_objects = find_objects(grid)\n    largest_border_object_size = -1\n    determined_border_color = 0\n\n    for color, objects_list in all_objects.items():\n        for obj_coords in objects_list:\n            touches_border = False\n            for r, c in obj_coords:\n                if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                    touches_border = True\n                    break\n            if touches_border:\n                obj_size = len(obj_coords)\n                if obj_size > largest_border_object_size:\n                    largest_border_object_size = obj_size\n                    determined_border_color = color\n                # Handle tie in size? Specification says \"largest\", implying unique. Assume unique for now.\n\n    return determined_border_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting a specific solid rectangle based on area and border color rules.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify the border color\n    border_color = get_border_color(grid)\n    # print(f\"Identified Border Color: {border_color}\") # Debug\n\n    # 2. Find all non-white objects\n    all_objects = find_objects(grid)\n\n    solid_rectangles = []\n\n    # 3-5. Find solid rectangles and calculate area\n    for color, objects_list in all_objects.items():\n        for obj_coords in objects_list:\n            bbox = get_bounding_box(obj_coords)\n            if bbox:\n                min_r, min_c, max_r, max_c = bbox\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                bbox_area = height * width\n                obj_size = len(obj_coords)\n\n                # Check if it's a solid rectangle (object size matches bounding box area)\n                if obj_size == bbox_area:\n                    solid_rectangles.append({\n                        'color': color,\n                        'bbox': bbox,\n                        'area': bbox_area\n                    })\n                    # print(f\"Found Solid Rectangle: Color={color}, Area={bbox_area}, BBox={bbox}\") # Debug\n\n\n    if not solid_rectangles:\n        # Handle cases where no solid rectangles are found (return empty or original?)\n        # Based on examples, there's always at least one. Assume this won't happen.\n         # Or maybe return a 1x1 grid of black? Let's stick to finding one.\n         # If this fails, need to re-evaluate. For now, assume it finds some.\n         print(\"Warning: No solid rectangles found.\") # Should not happen based on examples\n         return [[0]] # Placeholder for error or unexpected case\n\n\n    # 6. Find the maximum area\n    max_area = 0\n    if solid_rectangles:\n       max_area = max(rect['area'] for rect in solid_rectangles)\n    # print(f\"Max Area: {max_area}\") # Debug\n\n\n    # 7. Filter rectangles with maximum area\n    max_area_rectangles = [rect for rect in solid_rectangles if rect['area'] == max_area]\n    # print(f\"Max Area Rectangles ({len(max_area_rectangles)}): {max_area_rectangles}\") # Debug\n\n\n    selected_rectangle = None\n\n    # 8. Select if only one\n    if len(max_area_rectangles) == 1:\n        selected_rectangle = max_area_rectangles[0]\n        # print(\"Selected: Single max area\") # Debug\n\n    # 9. Handle ties\n    elif len(max_area_rectangles) > 1:\n        # 9a. Check for border color match\n        border_color_matches = [rect for rect in max_area_rectangles if rect['color'] == border_color]\n        # print(f\"Border Color Matches ({len(border_color_matches)}): {border_color_matches}\") # Debug\n\n\n        # 9b. Select if exactly one matches border color\n        if len(border_color_matches) == 1:\n            selected_rectangle = border_color_matches[0]\n            # print(\"Selected: Single border color match\") # Debug\n\n        # 9c. Use median color if no match or multiple matches\n        else:\n            tied_colors = sorted([rect['color'] for rect in max_area_rectangles])\n            # print(f\"Tied Colors for Median Calc: {tied_colors}\") # Debug\n\n            num_tied = len(tied_colors)\n            if num_tied % 2 == 1:\n                median_color = statistics.median(tied_colors)\n            else:\n                # Choose the lower of the two middle values for even counts\n                median_color = tied_colors[num_tied // 2 - 1]\n\n            # print(f\"Median Color: {median_color}\") # Debug\n\n\n            # Find the rectangle with the median color\n            # (Assumption: there will be exactly one rectangle with the median color among the tied ones)\n            for rect in max_area_rectangles:\n                if rect['color'] == median_color:\n                    selected_rectangle = rect\n                    # print(f\"Selected: Median color ({median_color})\") # Debug\n                    break\n\n\n    # 10. Create output grid\n    if selected_rectangle:\n        min_r, min_c, max_r, max_c = selected_rectangle['bbox']\n        # Extract the subgrid corresponding to the bounding box\n        output_grid_np = grid[min_r : max_r + 1, min_c : max_c + 1]\n        return output_grid_np.tolist()\n    else:\n        # Should not happen given the logic and examples, but as a fallback:\n        print(\"Error: Could not select a rectangle.\")\n        return [[0]] # Return minimal grid indicating failure\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3790,
    "candidates_token_count": 2995,
    "total_token_count": 6785,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.029156,
  "retries": 1
}