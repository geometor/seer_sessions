{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentifies two parallel lines (horizontal or vertical) and a single 'mover' pixel in the input grid.\nThe background color is assumed to be the most frequent color (typically white/0).\nThe lines and background remain unchanged in the output.\nThe mover pixel is moved along the axis perpendicular to the lines.\nThe direction of movement is away from the closer line and towards the farther line.\nThe distance moved is calculated as half the difference between the distance to the farther line and the distance to the closer line (using integer division).\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by moving a single pixel based on its proximity to two parallel lines.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # Create a copy for the output grid\n    output_grid = np.copy(grid)\n\n    # Find the background color (most frequent color, usually 0)\n    pixels = grid.flatten()\n    background_color = Counter(pixels).most_common(1)[0][0]\n\n    # Find non-background pixels and their coordinates\n    non_background_pixels = {}\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in non_background_pixels:\n                    non_background_pixels[color] = []\n                non_background_pixels[color].append((r, c))\n\n    # Identify the mover pixel (color with only one occurrence) and line color\n    mover_color = -1\n    mover_pos = None\n    line_color = -1\n    line_coords = []\n\n    if len(non_background_pixels) != 2:\n         # Handle edge case or unexpected input: if not exactly two non-bg colors\n         # This logic might need adjustment based on more complex scenarios,\n         # but for the given examples, we expect two distinct non-bg elements.\n         # For now, assume the single pixel is the one with count 1.\n         for color, coords in non_background_pixels.items():\n             if len(coords) == 1:\n                 mover_color = color\n                 mover_pos = coords[0]\n                 break\n         # If mover found, assume the other color is the line color\n         if mover_color != -1:\n            for color, coords in non_background_pixels.items():\n                if color != mover_color:\n                    line_color = color\n                    line_coords = coords\n                    break\n         else:\n             # If no single pixel found, cannot proceed with the logic\n             # Return the original grid or handle error appropriately\n             return input_grid # Or raise ValueError(\"Could not identify mover pixel\")\n\n    else: # Exactly two non-background colors found\n        for color, coords in non_background_pixels.items():\n            if len(coords) == 1:\n                mover_color = color\n                mover_pos = coords[0]\n            else:\n                line_color = color\n                line_coords = coords\n\n    if mover_pos is None or line_color == -1:\n         # If identification failed after checks\n         return input_grid # Or raise ValueError(\"Could not identify lines or mover pixel\")\n\n\n    # Determine line orientation and indices\n    rows = sorted(list(set(r for r, c in line_coords)))\n    cols = sorted(list(set(c for r, c in line_coords)))\n\n    line1_idx = -1\n    line2_idx = -1\n    is_horizontal = False\n\n    if len(rows) == 2 and len(cols) == width : # Horizontal lines\n        is_horizontal = True\n        line1_idx = rows[0]\n        line2_idx = rows[1]\n    elif len(cols) == 2 and len(rows) == height: # Vertical lines\n        is_horizontal = False\n        line1_idx = cols[0]\n        line2_idx = cols[1]\n    else:\n        # If lines are not perfectly horizontal/vertical or don't span the grid\n        # This might indicate an unexpected input format\n        return input_grid # Or raise ValueError(\"Lines are not clearly horizontal or vertical\")\n\n    # Get mover pixel coordinates\n    r, c = mover_pos\n\n    # Erase the mover pixel from its original position in the output\n    output_grid[r, c] = background_color\n\n    # Calculate new position\n    new_r, new_c = r, c\n\n    if is_horizontal:\n        # Lines are horizontal (at rows line1_idx and line2_idx)\n        dist1 = abs(r - line1_idx)\n        dist2 = abs(r - line2_idx)\n        \n        if dist1 < dist2: # Closer to line1\n            d_close = dist1\n            d_far = dist2\n            move_direction = 1 # Move away from line1 (increase row index)\n        elif dist2 < dist1: # Closer to line2\n            d_close = dist2\n            d_far = dist1\n            move_direction = -1 # Move away from line2 (decrease row index)\n        else: # Equidistant\n             d_close = dist1\n             d_far = dist2\n             move_direction = 0 # Don't move\n\n        if d_far > d_close:\n             # Calculate move distance using integer division\n             d_move = (d_far - d_close) // 2\n             new_r = r + (move_direction * d_move)\n        # else: new_r remains r (already handled by move_direction=0)\n\n    else:\n        # Lines are vertical (at columns line1_idx and line2_idx)\n        dist1 = abs(c - line1_idx)\n        dist2 = abs(c - line2_idx)\n\n        if dist1 < dist2: # Closer to line1\n            d_close = dist1\n            d_far = dist2\n            move_direction = 1 # Move away from line1 (increase column index)\n        elif dist2 < dist1: # Closer to line2\n            d_close = dist2\n            d_far = dist1\n            move_direction = -1 # Move away from line2 (decrease column index)\n        else: # Equidistant\n            d_close = dist1\n            d_far = dist2\n            move_direction = 0 # Don't move\n\n        if d_far > d_close:\n             # Calculate move distance using integer division\n             d_move = (d_far - d_close) // 2\n             new_c = c + (move_direction * d_move)\n        # else: new_c remains c (already handled by move_direction=0)\n\n    # Ensure new coordinates are within bounds (shouldn't be necessary if logic is correct)\n    new_r = max(0, min(new_r, height - 1))\n    new_c = max(0, min(new_c, width - 1))\n\n    # Place the mover pixel at the new position\n    output_grid[new_r, new_c] = mover_color\n\n    # Convert output back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3436,
    "candidates_token_count": 1734,
    "total_token_count": 5170,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.470561,
  "retries": 1
}