{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by:\n1. Identifying a separator line (horizontal or vertical) composed of a single repeating digit. This line divides other non-zero regions.\n2. Determining the orientation (vertical/horizontal) and position of the separator. Separators can be one or more cells thick.\n3. Splitting the grid into two parts along the separator line (left/right for vertical, top/bottom for horizontal). The separator itself is removed in the split.\n4. Filtering out the background digit (0) and the separator digit from each part.\n5. Cropping each filtered part to its minimal bounding box containing the remaining non-zero digits.\n6. Combining the two cropped parts: side-by-side (horizontally) if the separator was vertical, or one above the other (vertically) if the separator was horizontal.\n7. Returning the resulting combined grid.\n\"\"\"\n\ndef _find_regions(grid):\n    \"\"\"\n    Finds connected regions of the same non-zero digit using Breadth-First Search (BFS).\n    \n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are region IDs (int) and values are \n              dictionaries containing 'digit' (int) and 'coords' (set of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = {}\n    region_id_counter = 1\n\n    for r in range(rows):\n        for c in range(cols):\n            digit = grid[r, c]\n            # Start BFS if cell is non-zero and not visited\n            if digit != 0 and not visited[r, c]:\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_region_id = region_id_counter\n                \n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, visited status, and if neighbor has the same digit\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == digit:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Store the found region\n                if coords: # Ensure region is not empty\n                   regions[current_region_id] = {'digit': digit, 'coords': coords}\n                   region_id_counter += 1\n                \n    return regions\n\ndef _find_separator(regions, grid_shape):\n    \"\"\"\n    Identifies the separator line region among all found regions.\n    It looks for straight lines (horizontal or vertical) and handles multi-thickness separators.\n    \n    Args:\n        regions (dict): The dictionary of regions found by _find_regions.\n        grid_shape (tuple): The (rows, cols) of the grid.\n\n    Returns:\n        dict or None: A dictionary describing the separator \n                      ('digit', 'coords', 'orientation', 'line_index', 'thickness') \n                      or None if no clear separator is found.\n    \"\"\"\n    rows, cols = grid_shape\n    potential_lines = []\n\n    # 1. Identify all single-pixel-thick straight lines\n    for region_id, data in regions.items():\n        coords = data['coords']\n        digit = data['digit']\n        \n        if not coords: continue\n\n        min_r = min(r for r, c in coords)\n        max_r = max(r for r, c in coords)\n        min_c = min(c for r, c in coords)\n        max_c = max(c for r, c in coords)\n\n        # Check for perfect vertical line\n        is_vertical = len(coords) > 1 and all(c == min_c for r, c in coords) and len(coords) == (max_r - min_r + 1)\n        if is_vertical:\n             potential_lines.append({\n                 'id': region_id, 'digit': digit, 'coords': coords, \n                 'orientation': 'vertical', 'line_index': min_c,\n                 'span': max_r - min_r + 1\n             })\n\n        # Check for perfect horizontal line\n        is_horizontal = len(coords) > 1 and all(r == min_r for r, c in coords) and len(coords) == (max_c - min_c + 1)\n        if is_horizontal:\n             potential_lines.append({\n                 'id': region_id, 'digit': digit, 'coords': coords, \n                 'orientation': 'horizontal', 'line_index': min_r,\n                 'span': max_c - min_c + 1\n             })\n             \n    if not potential_lines:\n        return None\n\n    # 2. Group lines by orientation and digit to find thick separators\n    grouped_lines = {} # key: (orientation, digit), value: list of line_indices\n    line_details = {} # key: (orientation, digit, line_index), value: coords set\n\n    for line in potential_lines:\n        key = (line['orientation'], line['digit'])\n        index = line['line_index']\n        if key not in grouped_lines:\n            grouped_lines[key] = []\n        if index not in grouped_lines[key]: # Avoid duplicate indices if region spans multiple lines somehow?\n             grouped_lines[key].append(index)\n        \n        detail_key = (line['orientation'], line['digit'], index)\n        line_details[detail_key] = line['coords']\n\n    # 3. Find the thickest contiguous block of lines\n    best_sep = None\n    max_thickness = 0\n\n    for (orientation, digit), indices in grouped_lines.items():\n        indices.sort()\n        if not indices: continue\n\n        current_start_index = indices[0]\n        current_thickness = 1\n        current_coords = set(line_details.get((orientation, digit, current_start_index), set()))\n\n        for i in range(1, len(indices)):\n            # Check if the next line index is consecutive\n            if indices[i] == indices[i-1] + 1:\n                current_thickness += 1\n                current_coords.update(line_details.get((orientation, digit, indices[i]), set()))\n            else:\n                # End of a contiguous block, check if it's the best so far\n                if current_thickness >= max_thickness: # Prioritize thicker, or later ones if same thickness\n                    max_thickness = current_thickness\n                    best_sep = {\n                        'digit': digit, 'coords': current_coords.copy(), 'orientation': orientation,\n                        'line_index': current_start_index, 'thickness': current_thickness\n                    }\n                # Reset for the new block\n                current_start_index = indices[i]\n                current_thickness = 1\n                current_coords = set(line_details.get((orientation, digit, current_start_index), set()))\n\n        # Check the last block after the loop\n        if current_thickness >= max_thickness:\n             max_thickness = current_thickness\n             best_sep = {\n                'digit': digit, 'coords': current_coords.copy(), 'orientation': orientation,\n                'line_index': current_start_index, 'thickness': current_thickness\n             }\n\n    # 4. Fallback if no thick separator found (e.g., only single lines)\n    # Choose the longest single line among potentials if no multi-line separator found\n    if max_thickness <= 1 and potential_lines:\n         potential_lines.sort(key=lambda x: x['span'], reverse=True)\n         first_sep = potential_lines[0]\n         best_sep = {\n            'digit': first_sep['digit'], 'coords': first_sep['coords'], 'orientation': first_sep['orientation'],\n            'line_index': first_sep['line_index'], 'thickness': 1\n        }\n        \n    # Add a final check: The separator should ideally span a large part of the grid or be central\n    # This heuristic is complex to implement robustly, relying on thickness for now.\n\n    return best_sep\n\n\ndef _crop_non_value(grid, value_to_ignore):\n    \"\"\"\n    Crops the grid to the minimal bounding box containing cells \n    that are not equal to value_to_ignore.\n    \n    Args:\n        grid (np.array): The grid part to crop.\n        value_to_ignore (int): The value to ignore when determining bounds.\n\n    Returns:\n        np.array: The cropped grid. Returns an empty array if no relevant cells found.\n    \"\"\"\n    rows, cols = grid.shape\n    if rows == 0 or cols == 0:\n        return np.array([[]], dtype=grid.dtype) if grid.ndim > 1 else np.array([], dtype=grid.dtype)\n\n    # Find coordinates of cells not matching the ignore value\n    non_value_indices = np.argwhere(grid != value_to_ignore)\n    \n    if non_value_indices.size == 0:\n        # Return empty array correctly shaped (0 rows or 0 cols or both)\n        return np.empty((0, cols) if rows > 0 else (0,0), dtype=grid.dtype)\n\n\n    min_r, min_c = non_value_indices.min(axis=0)\n    max_r, max_c = non_value_indices.max(axis=0)\n    \n    # Slice the grid"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 9452,
            "end_index": 9623,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          },
          {
            "start_index": 25487,
            "end_index": 25658,
            "uri": "https://github.com/Rijgersberg/advent-of-code-2020",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2110,
    "candidates_token_count": 2296,
    "total_token_count": 4406,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 76.173078,
  "retries": 1
}