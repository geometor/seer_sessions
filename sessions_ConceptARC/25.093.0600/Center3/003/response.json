{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies all connected regions of the same non-zero color in the input grid using 4-way connectivity.\nFor each region, calculates its bounding box, solidity (ratio of region cells to bounding box area), \nand the squared Euclidean distance from the bounding box center to the grid center.\nSelects the region based on the following prioritized criteria:\n1. Maximum solidity.\n2. Minimum squared distance to the grid center.\n3. Minimum top row index of the bounding box.\n4. Minimum left column index of the bounding box.\nThe output is the content of the bounding box of the selected region.\n\"\"\"\n\ndef _is_valid(r, c, H, W):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < H and 0 <= c < W\n\ndef _find_connected_regions(grid, H, W):\n    \"\"\"\n    Finds all connected components (regions) of the same non-zero color using 4-way connectivity.\n    Returns a list of dictionaries, each describing a region and its initial bounding box.\n    \"\"\"\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n    \n    for r in range(H):\n        for c in range(W):\n            # If cell is non-zero and not yet visited, start a new region search (BFS)\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                # Initialize bounding box coordinates for this component\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    component_coords.add((curr_r, curr_c))\n                    # Update bounding box based on the current cell\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore 4-way neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        # Check if neighbor is valid, has the same color, and hasn't been visited\n                        if _is_valid(nr, nc, H, W) and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Store the found region's details\n                regions.append({\n                    'color': color,\n                    'coords': component_coords,\n                    'min_r': min_r,\n                    'max_r': max_r,\n                    'min_c': min_c,\n                    'max_c': max_c\n                })\n                \n    return regions\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding the most 'solid' region closest to the center\n    and returning its bounding box content.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    \n    # Handle empty input grid\n    if H == 0 or W == 0:\n        return []\n\n    # 1. Find all connected regions and their basic properties\n    regions = _find_connected_regions(grid, H, W)\n\n    # Handle case where no non-zero regions are found\n    if not regions:\n        return [] \n\n    # 2. Calculate derived properties for selection criteria\n    grid_center_r = (H - 1) / 2.0\n    grid_center_c = (W - 1) / 2.0\n    \n    region_properties = []\n    for region in regions:\n        # Calculate region size (number of cells)\n        size = len(region['coords'])\n        # Calculate bounding box dimensions and area\n        bbox_h = region['max_r'] - region['min_r'] + 1\n        bbox_w = region['max_c'] - region['min_c'] + 1\n        bbox_area = bbox_h * bbox_w\n        \n        # Calculate solidity (handle division by zero for empty regions, though unlikely here)\n        solidity = float(size) / bbox_area if bbox_area > 0 else 0.0\n        \n        # Calculate bounding box center coordinates\n        bbox_center_r = region['min_r'] + (bbox_h - 1) / 2.0\n        bbox_center_c = region['min_c'] + (bbox_w - 1) / 2.0\n        \n        # Calculate squared Euclidean distance from bbox center to grid center\n        # Using squared distance avoids sqrt and is sufficient for comparison\n        dist_sq = (bbox_center_r - grid_center_r)**2 + (bbox_center_c - grid_center_c)**2\n        \n        # Store calculated properties along with bounding box info\n        region_properties.append({\n            'solidity': solidity,\n            'dist_sq': dist_sq,\n            'min_r': region['min_r'],\n            'min_c': region['min_c'],\n            'max_r': region['max_r'],\n            'max_c': region['max_c']\n        })\n\n    # 3. Select the best region based on the prioritized criteria\n    # Sort using a tuple key: (-solidity) for descending solidity, \n    # (dist_sq) for ascending distance, (min_r) for top-most tiebreak, \n    # (min_c) for left-most tiebreak.\n    region_properties.sort(key=lambda x: (-x['solidity'], x['dist_sq'], x['min_r'], x['min_c']))\n    \n    # The best region is the first element after sorting\n    best_region = region_properties[0]\n\n    # 4. Extract the content of the winning region's bounding box from the original grid\n    output_np = grid[best_region['min_r'] : best_region['max_r'] + 1, \n                     best_region['min_c'] : best_region['max_c'] + 1]\n\n    # Convert the numpy slice back to a standard Python list of lists for the output\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11605,
    "candidates_token_count": 1553,
    "total_token_count": 13158,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.201229,
  "retries": 1
}