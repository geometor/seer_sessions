{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies the outermost continuous non-zero border region of the input grid. \nIt then finds all solid, rectangular blocks of non-zero color within the grid. \nRectangles that are part of the border region or are adjacent (including diagonally) to any cell of the border region are filtered out.\nFrom the remaining valid rectangles, the one with the largest area is selected. \nIf there's a tie in area, the rectangle with the top-most row index is chosen. \nIf there's still a tie, the one with the left-most column index is chosen.\nThe selected rectangular block is then extracted and returned as the output grid.\n\"\"\"\n\ndef _is_valid(r, c, H, W):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < H and 0 <= c < W\n\ndef _bfs_find_region(grid, start_r, start_c, H, W):\n    \"\"\"\n    Performs Breadth-First Search to find all connected cells \n    of the same color starting from (start_r, start_c).\n    Returns a set of (r, c) coordinates for the connected region.\n    \"\"\"\n    target_color = grid[start_r, start_c]\n    if target_color == 0:\n        return set()\n        \n    q = deque([(start_r, start_c)])\n    visited = set([(start_r, start_c)])\n    region_coords = set([(start_r, start_c)])\n    \n    while q:\n        r, c = q.popleft()\n        \n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                \n                if _is_valid(nr, nc, H, W) and (nr, nc) not in visited and grid[nr, nc] == target_color:\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n                    region_coords.add((nr, nc))\n                    \n    return region_coords\n\ndef _find_border_region(grid, H, W):\n    \"\"\"\n    Identifies the coordinates of the outermost connected non-zero region (border).\n    Starts BFS from the first non-zero cell found on the grid edges.\n    \"\"\"\n    border_coords = set()\n    start_node = None\n    \n    # Find the first non-zero cell on the edges\n    for r in range(H):\n        if grid[r, 0] != 0:\n            start_node = (r, 0)\n            break\n        if grid[r, W-1] != 0:\n             start_node = (r, W-1)\n             break\n    if start_node is None:\n        for c in range(W):\n            if grid[0, c] != 0:\n                start_node = (0, c)\n                break\n            if grid[H-1, c] != 0:\n                start_node = (H-1, c)\n                break\n                \n    # If a non-zero edge cell is found, perform BFS\n    if start_node:\n        border_coords = _bfs_find_region(grid, start_node[0], start_node[1], H, W)\n        \n    return border_coords\n\ndef _find_solid_rectangles(grid, H, W):\n    \"\"\"\n    Finds all maximal solid rectangles of non-zero colors in the grid.\n    Returns a list of dictionaries, each describing a rectangle.\n    \"\"\"\n    rectangles = []\n    visited = np.zeros_like(grid, dtype=bool)\n\n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                \n                # Find max width for the starting row\n                current_w = 0\n                while c + current_w < W and grid[r, c + current_w] == color:\n                    current_w += 1\n                \n                # Find max height for this width\n                current_h = 1\n                possible = True\n                while r + current_h < H and possible:\n                    for k in range(current_w):\n                        if c + k >= W or grid[r + current_h, c + k] != color:\n                            possible = False\n                            break\n                    if possible:\n                        current_h += 1\n                        \n                # Now we have a potential rectangle (r, c, current_w, current_h)\n                # Check if it's maximal (cannot be extended further up/left while maintaining rect shape)\n                # This simple approach finds rectangles starting from top-left corners.\n                # We need to mark all cells within the found rectangle as visited.\n                \n                rectangles.append({\n                    'r': r, \n                    'c': c, \n                    'w': current_w, \n                    'h': current_h, \n                    'color': color, \n                    'area': current_w * current_h\n                })\n                \n                # Mark cells as visited\n                for rr in range(r, r + current_h):\n                    for cc in range(c, c + current_w):\n                        if _is_valid(rr, cc, H, W):\n                             visited[rr, cc] = True\n                             \n    return rectangles\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies and extracts the largest solid non-zero rectangle within the input grid \n    that does not touch the outermost border region. Ties are broken by top-most, \n    then left-most position.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    H, W = grid.shape\n    \n    if H == 0 or W == 0:\n        return []\n\n    # 1. Find the coordinates of the border region\n    border_coords = _find_border_region(grid, H, W)\n\n    # 2. Find all solid non-zero rectangles\n    all_rects = _find_solid_rectangles(grid, H, W)\n\n    # 3. Filter rectangles that touch the border\n    valid_rects = []\n    for rect in all_rects:\n        touches_border = False\n        # Check every cell within the rectangle\n        for rr in range(rect['r'], rect['r'] + rect['h']):\n            for cc in range(rect['c'], rect['c'] + rect['w']):\n                # Check if the cell itself is part of the border\n                if (rr, cc) in border_coords:\n                    touches_border = True\n                    break\n                # Check if any neighbor of the cell is part of the border\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = rr + dr, cc + dc\n                        if _is_valid(nr, nc, H, W) and (nr, nc) in border_coords:\n                             touches_border = True\n                             break\n                    if touches_border: break # optimization\n            if touches_border: break # optimization\n        \n        # Add to valid list if it doesn't touch the border\n        if not touches_border:\n            valid_rects.append(rect)\n\n    # Handle cases where no valid rectangles are found (shouldn't happen based on examples)\n    if not valid_rects:\n        # As a fallback maybe return the largest rect overall? Or empty?\n        # Based on task, assuming a valid one always exists. If not:\n         if all_rects: # If no border or border filtering failed, pick largest overall\n             all_rects.sort(key=lambda x: (-x['area'], x['r'], x['c']))\n             target_rect = all_rects[0]\n             output_np = grid[target_rect['r']:target_rect['r']+target_rect['h'], target_rect['c']:target_rect['c']+target_rect['w']]\n             return output_np.tolist()\n         else:\n             return [] # Return empty if no rectangles found at all\n\n\n    # 4. Select the largest valid rectangle (with tie-breaking)\n    # Sort by area (desc), then row (asc), then col (asc)\n    valid_rects.sort(key=lambda x: (-x['area'], x['r'], x['c']))\n    \n    target_rect = valid_rects[0]\n\n    # 5. Extract the output subgrid\n    output_np = grid[target_rect['r']:target_rect['r']+target_rect['h'], \n                     target_rect['c']:target_rect['c']+target_rect['w']]\n\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3104,
    "candidates_token_count": 2090,
    "total_token_count": 5194,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 139.304136,
  "retries": 2
}