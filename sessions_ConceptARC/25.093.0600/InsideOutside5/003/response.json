{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all connected non-zero objects using 8-way connectivity.\nKeep an object if and only if none of its adjacent cells (8-way connectivity) \nare background cells (0) that are connected (via an 8-way path of 0s) \nto the border of the grid. Remove all other objects, replacing their \ncells with 0 in the output grid.\n\"\"\"\n\ndef _find_neighbors(grid_shape, object_coords):\n    \"\"\"\n    Finds all unique neighboring cells (8-way adjacency) adjacent to any cell\n    of the object, excluding cells that are part of the object itself.\n\n    Args:\n        grid_shape (tuple): The (rows, cols) shape of the grid.\n        object_coords (set): A set of (row, col) tuples representing the object's cells.\n\n    Returns:\n        set: A set of (row, col) tuples representing unique neighbor cells.\n    \"\"\"\n    rows, cols = grid_shape\n    neighbors = set()\n    # Define 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  ( 0, -1),          ( 0, 1),\n                  ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    for r, c in object_coords:\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            # Check grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_coord = (nr, nc)\n                # Add if it's not part of the object itself\n                if neighbor_coord not in object_coords:\n                    neighbors.add(neighbor_coord)\n    return neighbors\n\ndef _find_objects(grid, visited_mask):\n    \"\"\"\n    Finds all distinct connected non-zero objects in the grid using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        visited_mask (np.array): A boolean array to track visited cells across calls.\n\n    Yields:\n        tuple: A tuple containing (object_color, object_coords_set) for each object found.\n    \"\"\"\n    rows, cols = grid.shape\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited_mask[r, c]:\n                object_color = grid[r, c]\n                object_coords = set()\n                q = deque([(r, c)])\n                visited_mask[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    object_coords.add((curr_r, curr_c))\n\n                    for dr, dc in directions:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if (0 <= nr < rows and 0 <= nc < cols and\n                                grid[nr, nc] == object_color and\n                                not visited_mask[nr, nc]):\n                            visited_mask[nr, nc] = True\n                            q.append((nr, nc))\n                \n                yield (object_color, object_coords)\n\n\ndef _flood_fill_exterior_background(grid):\n    \"\"\"\n    Performs flood fill from border zeros to mark exterior background.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        np.array: A boolean array where True indicates an exterior background cell.\n    \"\"\"\n    rows, cols = grid.shape\n    exterior_bg = np.zeros_like(grid, dtype=bool)\n    q = deque()\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    # Add all border zeros to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == 0 and not exterior_bg[r, c]:\n                exterior_bg[r, c] = True\n                q.append((r, c))\n    for c in range(cols): # Avoid double-adding corners\n        for r in [0, rows - 1]:\n             if grid[r, c] == 0 and not exterior_bg[r, c]:\n                exterior_bg[r, c] = True\n                q.append((r, c))\n\n    # Perform BFS for background connected to border\n    while q:\n        curr_r, curr_c = q.popleft()\n        for dr, dc in directions:\n            nr, nc = curr_r + dr, curr_c + dc\n            if (0 <= nr < rows and 0 <= nc < cols and\n                    grid[nr, nc] == 0 and not exterior_bg[nr, nc]):\n                exterior_bg[nr, nc] = True\n                q.append((nr, nc))\n\n    return exterior_bg\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters the grid to keep only objects not adjacent to exterior background.\n\n    Args:\n        input_grid (list of lists): The input 2D grid.\n\n    Returns:\n        list of lists: The transformed 2D grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    output_grid = np.zeros_like(grid)\n    \n    # 1. Mark exterior background cells\n    exterior_bg_mask = _flood_fill_exterior_background(grid)\n\n    # 2. Find all objects and check their neighbors\n    visited_obj_mask = np.zeros_like(grid, dtype=bool) # Track visited cells for object finding\n    \n    for obj_color, obj_coords in _find_objects(grid, visited_obj_mask):\n        # 3a. Find neighbors of the current object\n        neighbor_coords = _find_neighbors(grid.shape, obj_coords)\n\n        # 3b. Check if any neighbor is an exterior background cell\n        is_adjacent_"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 25648,
    "candidates_token_count": 1487,
    "total_token_count": 27135,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 69.603515,
  "retries": 1
}