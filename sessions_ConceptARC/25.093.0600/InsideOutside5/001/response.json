{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected objects of the same non-zero color in the input grid.\nDetermines if an object is completely enclosed by cells of exactly one other *single* non-zero color (using 8-way adjacency).\nOutputs a grid containing only the cells of such enclosed objects, with all other cells set to the background color (0).\n\"\"\"\n\ndef _find_neighbors(grid_shape, object_coords):\n    \"\"\"\n    Finds all unique neighboring cells (8-way adjacency) adjacent to any cell\n    of the object, excluding cells that are part of the object itself.\n\n    Args:\n        grid_shape (tuple): The (rows, cols) shape of the grid.\n        object_coords (set): A set of (row, col) tuples representing the object's cells.\n\n    Returns:\n        set: A set of (row, col) tuples representing unique neighbor cells.\n    \"\"\"\n    rows, cols = grid_shape\n    neighbors = set()\n    # Define 8 directions (including diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  ( 0, -1),          ( 0, 1),\n                  ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    for r, c in object_coords:\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            # Check grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_coord = (nr, nc)\n                # Add if it's not part of the object itself\n                if neighbor_coord not in object_coords:\n                    neighbors.add(neighbor_coord)\n    return neighbors\n\ndef _is_enclosed(grid, neighbor_coords):\n    \"\"\"\n    Checks if all neighbor cells belong to exactly one other single non-zero object.\n\n    Args:\n        grid (np.array): The input grid.\n        neighbor_coords (set): A set of (row, col) tuples for neighbor cells.\n\n    Returns:\n        bool: True if the object is enclosed according to the rules, False otherwise.\n    \"\"\"\n    if not neighbor_coords:\n        return False  # Object is isolated or fills the grid, cannot be enclosed\n\n    first_neighbor_val = -1 # Initialize with an invalid value\n\n    for r, c in neighbor_coords:\n        val = grid[r, c]\n        # Condition 1: No neighbor can be background (0)\n        if val == 0:\n            return False\n        # Condition 2: All neighbors must have the same non-zero color\n        if first_neighbor_val == -1:\n             first_neighbor_val = val # Record the color of the first neighbor\n        elif val != first_neighbor_val:\n             return False # Found a neighbor with a different color\n\n    # If loop completes, all neighbors have the same non-zero color\n    return True\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters the input grid to keep only objects enclosed by exactly one other object.\n\n    Args:\n        input_grid (list of lists): The input 2D grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed 2D grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(grid)\n    # Keep track of visited cells to avoid processing the same object multiple times\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Iterate through each cell in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell is part of a non-zero object and hasn't been visited yet\n            if grid[r, c] != 0 and not visited[r, c]:\n                object_color = grid[r, c]\n                object_coords = set()\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n\n                # Perform BFS to find all connected cells of the same color (the object)\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    object_coords.add((curr_r, curr_c))\n\n                    # Explore 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            nr, nc = curr_r + dr, curr_c + dc\n\n                            # Check boundaries, color match, and visited status\n                            if (0 <= nr < rows and 0 <= nc < cols and\n                                    not visited[nr, nc] and\n                                    grid[nr, nc] == object_color):\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n\n                # Find the neighbors of the identified object\n                neighbor_coords = _find_neighbors(grid.shape, object_coords)\n\n                # Check if the object is enclosed according to the rules\n                if _is_enclosed(grid, neighbor_coords):\n                    # If enclosed, copy the object's cells to the output grid\n                    for obj_r, obj_c in object_coords:\n                        output_grid[obj_r, obj_c] = object_color\n\n    # Convert the output numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4125,
    "candidates_token_count": 1291,
    "total_token_count": 5416,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.376463,
  "retries": 1
}