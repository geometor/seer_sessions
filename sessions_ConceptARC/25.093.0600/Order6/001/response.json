{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThis transformation rearranges rectangular blocks of non-zero digits within a 2D grid.\nThe process involves:\n1. Identifying all distinct, contiguous, rectangular blocks of non-zero digits in the input grid.\n2. Determining the height, width, digit value, and original leftmost column for each block.\n3. Finding the maximum row index occupied by any non-zero cell in the original grid (anchor bottom row).\n4. Sorting the identified blocks primarily by ascending height, and secondarily by ascending width.\n5. Reconstructing the output grid by stacking the sorted blocks vertically. The stack starts from the bottom, with the lowest block's bottom edge aligned with the anchor bottom row found in step 3. Each subsequent block is placed directly above the previous one, maintaining its original leftmost column and width. The rest of the grid is filled with the background digit (0).\n\"\"\"\n\ndef _find_blocks(grid):\n    \"\"\"\n    Identifies contiguous rectangular blocks of non-zero numbers in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of dictionaries, where each dictionary represents a block\n                    and contains 'value', 'height', 'width', 'left_col', \n                    'top_row_orig', 'bottom_row_orig'.\n            - int: The maximum row index occupied by any non-zero cell (anchor_bottom_row).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    max_bottom_row = -1\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the cell is non-zero and not yet visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                value = grid[r, c]\n                # Find the boundaries of this block using BFS/Flood Fill logic implicitly\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                block_cells = set([(r,c)])\n\n                while q:\n                    row, col = q.pop(0)\n\n                    # Update boundaries\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors (only checking direct right and down is sufficient for rectangles)\n                    # More robust: check all 4 neighbors if shapes aren't guaranteed rectangular\n                    for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: \n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == value:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            block_cells.add((nr,nc))\n\n                # For strictly rectangular blocks, max/min r/c are enough.\n                # If complex shapes were allowed, we'd need to track all cells.\n                # Let's assume rectangles based on examples.\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                # Correctness check: Ensure all cells within bounds actually belong to the block\n                is_rectangular = True\n                count = 0\n                for br in range(min_r, max_r + 1):\n                    for bc in range(min_c, max_c + 1):\n                        if grid[br, bc] == value:\n                            count += 1\n                            visited[br, bc] = True # Ensure all inner cells are marked visited\n                        else:\n                            # This handles L-shapes etc. - might need adjustment based on definition\n                            # For the given examples, this check might not be strictly necessary\n                            # if we assume perfect rectangular input blocks.\n                            pass \n                #if count != height * width: # Check if it's a solid rectangle\n                #    is_rectangular = False\n                    # This part is tricky, the definition of block might need refinement.\n                    # Sticking to the simple boundary box based on BFS extent for now.\n\n\n                blocks.append({\n                    'value': value,\n                    'height': height,\n                    'width': width,\n                    'left_col': min_c,\n                    'top_row_orig': min_r,\n                    'bottom_row_orig': max_r\n                })\n                # Update the overall maximum bottom row\n                max_bottom_row = max(max_bottom_row, max_r)\n\n    return blocks, max_bottom_row\n\n\ndef transform(input_grid):\n    \"\"\"\n    Rearranges blocks in the grid based on height and then width.\n\n    Args:\n        input_grid (list[list[int]]): The input grid.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # Initialize output grid with background color (0)\n    output_array = np.zeros_like(input_array)\n\n    # 1. Identify all non-zero blocks and their properties\n    # 3. Find the overall bottom-most row occupied by any block\n    blocks, anchor_bottom_row = _find_blocks(input_array)\n\n    # If no blocks found or anchor invalid, return the empty grid\n    if not blocks or anchor_bottom_row == -1:\n        return output_array.tolist()\n\n    # 4. Sort blocks: primary key = height (ascending), secondary key = width (ascending)\n    sorted_blocks = sorted(blocks, key=lambda b: (b['height'], b['width']))\n\n    # 5. Reconstruct the grid by placing sorted blocks\n    # Iterate from bottom-up placement, so process sorted list in reverse\n    current_bottom_row = anchor_bottom_row\n    for block in reversed(sorted_blocks):\n        # Calculate the top row for placing this block in the output grid\n        height = block['height']\n        width = block['width']\n        value = block['value']\n        left_col = block['left_col']\n        \n        # Ensure placement doesn't go out of bounds (especially top row < 0)\n        if current_bottom_row < 0:\n              # This case shouldn't happen with valid inputs and logic, but good practice\n              print(f\"Warning: Trying to place block {value} above grid boundary.\")\n              continue # Skip block if it can't fit logically\n\n        top_row_place = current_bottom_row - height + 1\n        \n        # Ensure top_row is not negative\n        if top_row_place < 0:\n             print(f\"Warning: Block {value} starting at original row {block['top_row_orig']} adjusted to start at row 0.\")\n             # Adjust height if it would go off the top. This might not be the desired behavior.\n             # Alternative: stop placing? Or does anchor guarantee space? \n             # Based on examples, anchor seems to guarantee space downwards.\n             # Let's assume it fits within the grid height based on the anchor logic.\n             # If top_row_place is negative, it implies the stack is taller than the grid allows starting from anchor_bottom_row.\n             # The prompt logic implies stacking *upwards*, so we might clip or error.\n             # Clipping might be safer:\n             clipped_height = height + top_row_place # height - abs(top_row_place)\n             actual_top_row = 0\n             if clipped_height <= 0: continue # Skip if fully clipped\n             print(f\"Block {value} height {height} clipped to {clipped_height} due to grid boundary.\")\n             height = clipped_height # Use clipped height\n             top_row_place = actual_top_row\n\n        # Calculate right column for placement\n        right_col_place = left_col + width -1\n        \n        # Ensure placement is within grid bounds horizontally\n        if left_col < 0 or right_col_place >= cols:\n            print(f\"Warning: Block {value} placement horizontal bounds invalid [{left_col}:{right_col_place+1}]. Skipping.\")\n            continue # Skip block if horizontal placement is invalid\n\n        # Place the block onto the output grid\n        output_array[top_row_place : current_bottom_row + 1, left_col : right_col_place + 1] = value\n\n        # Update the bottom row for the *next* block to be placed *above* this one\n        current_bottom_row = top_row_place - 1\n\n    # Convert the result back to list of lists\n    return output_array.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2298,
    "candidates_token_count": 2093,
    "total_token_count": 4391,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.467119,
  "retries": 1
}