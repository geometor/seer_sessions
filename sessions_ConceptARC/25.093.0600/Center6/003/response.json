{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the shape formed by the least frequent non-zero digit(s) in the input \ngrid. Finds the largest contiguous group of other non-zero digits. Moves the \nmarker shape to be centered within the bounding box of this largest group, \noverwriting existing digits. Sets the original locations of the marker shape to zero.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\nimport math\nfrom scipy.ndimage import label, find_objects, center_of_mass\n\ndef find_marker_info(grid):\n    \"\"\"\n    Finds the least frequent non-zero digit, its locations, and its bounding box shape.\n    \n    Args:\n        grid (np.array): The input grid.\n        \n    Returns:\n        tuple: (marker_value, marker_locations, marker_shape, marker_origin) or (None, None, None, None)\n               - marker_value: The integer value of the marker.\n               - marker_locations: List of (row, col) tuples for the marker.\n               - marker_shape: np.array representing the marker shape within its bounding box.\n               - marker_origin: (row, col) of the top-left corner of the marker's bounding box in the original grid.\n    \"\"\"\n    non_zeros = grid[grid != 0]\n    if non_zeros.size == 0:\n        return None, None, None, None\n\n    counts = Counter(non_zeros)\n    min_freq = min(counts.values())\n    candidates = [digit for digit, freq in counts.items() if freq == min_freq]\n    \n    # Assuming the first candidate is the marker if there's a tie\n    marker_value = candidates[0] \n    \n    locations = np.argwhere(grid == marker_value)\n    if locations.size == 0:\n        return None, None, None, None\n        \n    marker_locations = [tuple(loc) for loc in locations]\n    \n    # Determine bounding box and shape\n    if not marker_locations:\n         return marker_value, [], None, None\n\n    min_r = min(r for r, c in marker_locations)\n    max_r = max(r for r, c in marker_locations)\n    min_c = min(c for r, c in marker_locations)\n    max_c = max(c for r, c in marker_locations)\n    \n    marker_origin = (min_r, min_c)\n    shape_height = max_r - min_r + 1\n    shape_width = max_c - min_c + 1\n    \n    marker_shape = np.zeros((shape_height, shape_width), dtype=int)\n    for r, c in marker_locations:\n        marker_shape[r - min_r, c - min_c] = marker_value\n        \n    return marker_value, marker_locations, marker_shape, marker_origin\n\n\ndef find_largest_component_center(grid, marker_value):\n    \"\"\"\n    Finds the center of the bounding box of the largest connected component \n    of non-zero, non-marker digits. Uses 8-way connectivity.\n    \n    Args:\n        grid (np.array): The input grid.\n        marker_value (int): The value of the marker digit to exclude.\n        \n    Returns:\n        tuple: (center_row, center_col) or (None, None) if no components found.\n    \"\"\"\n    # Create a mask: 1 for target components, 0 for background and marker\n    mask = (grid != 0) & (grid != marker_value)\n    if not np.any(mask):\n        return None, None\n\n    # Label connected components (8-way connectivity default with structure=np.ones((3,3)))\n    labeled_array, num_features = label(mask, structure=np.ones((3,3), dtype=bool))\n    \n    if num_features == 0:\n        return None, None\n        \n    # Find the largest component\n    component_sizes = np.bincount(labeled_array.ravel())\n    # component_sizes[0] is the background size, ignore it\n    if len(component_sizes) <= 1: # Only background label exists\n         return None, None\n\n    largest_component_label = np.argmax(component_sizes[1:]) + 1 # +1 because we ignored index 0\n    \n    # Find the bounding box (slice) of the largest component\n    component_slice = find_objects(labeled_array == largest_component_label)[0]\n\n    # Calculate the center of the bounding box\n    # slice objects store (start, stop) for each dimension\n    row_slice, col_slice = component_slice\n    center_row = (row_slice.start + row_slice.stop - 1) // 2\n    center_col = (col_slice.start + col_slice.stop - 1) // 2\n\n    # Alternative: Center of mass (might be float)\n    # center_row_f, center_col_f = center_of_mass(mask, labels=labeled_array, index=largest_component_label)\n    # center_row = int(round(center_row_f))\n    # center_col = int(round(center_col_f))\n    \n    return center_row, center_col\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies the shape formed by the least frequent non-zero digit(s), finds the \n    largest contiguous group of other non-zero digits, moves the marker shape to be \n    centered within the bounding box of this largest group, overwriting existing digits,\n    and sets the original locations of the marker shape to zero.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    \n    # --- Step 1, 2, 3: Find marker info ---\n    marker_value, marker_locations, marker_shape, _ = find_marker_info(input_np)\n    \n    if marker_value is None or marker_shape is None:\n        # No marker found or marker is empty, return original grid\n        return input_grid \n        \n    # --- Step 4, 5: Find target center ---\n    target_center_row, target_center_col = find_largest_component_center(input_np, marker_value)\n    \n    if target_center_row is None:\n        # If no other components, maybe place at grid center? \n        # Based on example 3, it seems we need the target component.\n        # Let's stick to the logic derived from examples. If no target, maybe no change?\n        # Re-evaluating test case 3: the marker (4s) moves to the center of the 1s.\n        # Re-evaluating train case 1: marker (4) moves to center of the X of 2s.\n        # Re-evaluating train case 2: marker (7) moves to center of the border of 3s.\n        # The logic holds. If no target component, the behavior is undefined by examples.\n        # Returning original grid might be safest if no target is found.\n         # Check if the only non-zeros ARE the marker\n        non_zeros = input_np[input_np != 0]\n        if len(np.unique(non_zeros)) == 1 and np.unique(non_zeros)[0] == marker_value:\n             # Grid only contains the marker, no target component. Return original.\n             # Or perhaps center it on the grid? Examples don't cover this. Let's return original.\n             return input_grid\n        # Fallback: if target component logic failed but there ARE other numbers, place at grid center?\n        # Let's stick to requiring a target component for now based on strict interpretation of examples.\n        # If this fails tests, we might need a fallback. For now, if no target component, return unchanged.\n        print(f\"Warning: No target component found for marker {marker_value}. Returning original grid.\") # Added for debugging\n        return input_grid # Or handle error appropriately\n\n\n    # --- Step 7a: Clear original marker locations ---\n    for r, c in marker_locations:\n        output_np[r, c] = 0\n        \n    # --- Step 7b: Place marker shape centered at target ---\n    shape_h, shape_w = marker_shape.shape\n    \n    # Calculate top-left corner for pasting the marker shape\n    paste_r_start = target_center_row - (shape_h - 1) // 2\n    paste_c_start = target_center_col - (shape_w - 1) // 2\n    \n    # Paste the shape, element by element, respecting shape's zeros (if any)\n    for r_offset in range(shape_h):\n        for c_offset in range(shape_w):\n            paste_r = paste_r_start + r_offset\n            paste_c = paste_c_start + c_offset\n            \n            # Check grid bounds\n            if 0 <= paste_r < output_np.shape[0] and 0 <= paste_c < output_np.shape[1]:\n                # Only overwrite if the marker shape has a non-zero value at this offset\n                if marker_shape[r_offset, c_offset] != 0:\n                     output_np[paste_r, paste_c] = marker_shape[r_offset, c_offset]\n\n    # Convert back to list of lists\n    output_grid = output_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12722,
    "candidates_token_count": 2229,
    "total_token_count": 14951,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.269787,
  "retries": 1
}