{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by rearranging connected components (objects) of non-zero cells.\n\n1.  **Identify Objects:** Finds all distinct connected components (objects) of \n    non-zero cells with the same value. Records each object's color, \n    coordinates, and bounding box.\n2.  **Determine Axis:** Calculates the overall bounding box of all objects. If \n    its width > height, the primary axis is 'horizontal'; otherwise, it's \n    'vertical'.\n3.  **Identify Gaps:** Determines the spacing (rows/columns of zeros) between \n    objects along the primary axis in their original input order. Records the \n    initial gap before the first object and gaps between subsequent objects.\n4.  **Sort Objects:** Reorders the objects based on the primary axis:\n    *   Vertical Axis: Sorts objects by their top row index (min_row) in \n        descending order (bottom-most object first).\n    *   Horizontal Axis: Identifies the object starting furthest to the right \n        (max of min_col). Sorts the *remaining* objects by color descending. \n        Appends the rightmost object to the end of the sorted list.\n5.  **Reconstruct Grid:** Creates a new grid. Places the objects in their new \n    sorted order, maintaining the original gaps between them along the primary \n    axis, starting from the top/left edge.\n\"\"\"\n\nclass GridObject:\n    \"\"\"Represents a connected component of non-zero cells.\"\"\"\n    def __init__(self, color, coords):\n        if not coords:\n            raise ValueError(\"Cannot create an object with no coordinates.\")\n        self.color = color\n        # Store coords as a list of tuples for iteration during reconstruction\n        self.coords = list(coords) \n        rows = [r for r, c in coords]\n        cols = [c for r, c in coords]\n        self.min_row = min(rows)\n        self.max_row = max(rows)\n        self.min_col = min(cols)\n        self.max_col = max(cols)\n        self.height = self.max_row - self.min_row + 1\n        self.width = self.max_col - self.min_col + 1\n\n    def __repr__(self):\n         return (f\"Obj(color={self.color}, \"\n                 f\"bbox=({self.min_row},{self.min_col})-({self.max_row},{self.max_col}), \"\n                 f\"size=({self.height}x{self.width}))\")\n\ndef find_objects(grid):\n    \"\"\"Finds all connected components (objects) in the grid.\"\"\"\n    objects = []\n    rows, cols = grid.shape\n    visited = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                color = grid[r, c]\n                component_coords = set()\n                q = deque([(r, c)])\n                visited.add((r,c))\n                \n                while q:\n                    row, col = q.popleft()\n                    component_coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and \\\n                           grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if component_coords:\n                    objects.append(GridObject(color, component_coords))\n    return objects\n\ndef get_overall_bbox(objects):\n    \"\"\"Calculates the bounding box encompassing all objects.\"\"\"\n    if not objects:\n        return None, 0, 0 # No bbox, height=0, width=0\n        \n    min_r = min(obj.min_row for obj in objects)\n    max_r = max(obj.max_row for obj in objects)\n    min_c = min(obj.min_col for obj in objects)\n    max_c = max(obj.max_col for obj in objects)\n    \n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    bbox = (min_r, max_r, min_c, max_c)\n    return bbox, height, width\n\ndef identify_gaps(objects, primary_axis):\n    \"\"\"Identifies gaps between objects along the primary axis in input order.\"\"\"\n    if not objects:\n        return [], [] # No gaps if no objects\n\n    # Sort objects by their initial position along the axis\n    if primary_axis == 'vertical':\n        # Sort by top-most row\n        sorted_objects_input_order = sorted(objects, key=lambda obj: obj.min_row)\n        # Calculate initial gap (space above the first object)\n        initial_gap = sorted_objects_input_order[0].min_row\n        # Calculate gaps between consecutive objects\n        gaps = []\n        for i in range(len(sorted_objects_input_order) - 1):\n            gap = sorted_objects_input_order[i+1].min_row - (sorted_objects_input_order[i].max_row + 1)\n            gaps.append(max(0, gap)) # Ensure gap is not negative\n            \n    else: # primary_axis == 'horizontal'\n        # Sort by left-most column\n        sorted_objects_input_order = sorted(objects, key=lambda obj: obj.min_col)\n        # Calculate initial gap (space left of the first object)\n        initial_gap = sorted_objects_input_order[0].min_col\n        # Calculate gaps between consecutive objects\n        gaps = []\n        for i in range(len(sorted_objects_input_order) - 1):\n            gap = sorted_objects_input_order[i+1].min_col - (sorted_objects_input_order[i].max_col + 1)\n            gaps.append(max(0, gap)) # Ensure gap is not negative\n\n    return [initial_gap] + gaps, sorted_objects_input_order # Return gaps and the input order list\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object rearrangement transformation to the input grid.\n    \"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    output_grid = np.zeros_like(grid)\n\n    # 1. Identify Objects\n    objects = find_objects(grid)\n    if not objects:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # 2. Determine Axis\n    _, overall_height, overall_width = get_overall_bbox(objects)\n    primary_axis = 'horizontal' if overall_width > overall_height else 'vertical'\n\n    # 3. Identify Gaps (using original object order along the axis)\n    gaps, objects_input_order = identify_gaps(objects, primary_axis)\n    # We need the gaps list to correspond to the *final* sorted order later.\n    # Create a mapping from object (by reference/id) to its preceding gap size in the input order.\n    gap_map = {}\n    gap_map['initial'] = gaps[0] # Gap before the first object in input order\n    for i in range(len(objects_input_order) - 1):\n         # The gap *after* objects_input_order[i] is gaps[i+1]\n         # So, the gap *before* objects_input_order[i+1] is gaps[i+1]\n        gap_map[id(objects_input_order[i+1])] = gaps[i+1]\n\n\n    # 4. Sort Objects based on the determined rule\n    if primary_axis == 'vertical':\n        # Sort by min_row descending (bottom-most object first in the list)\n        sorted_objects = sorted(objects, key=lambda obj: obj.min_row, reverse=True)\n    else: # primary_axis == 'horizontal'\n        # Find the rightmost object (max of min_col)\n        if len(objects) <= 1:\n             sorted_objects = objects # No sorting needed for 0 or 1 object\n        else:\n            rightmost_obj = max(objects, key=lambda obj: obj.min_col)\n            other_objects = [obj for obj in objects if obj is not rightmost_obj]\n            # Sort remaining objects by color descending\n            other_objects_sorted = sorted(other_objects, key=lambda obj: obj.color, reverse=True)\n            # Append the rightmost object\n            sorted_objects = other_objects_sorted + [rightmost_obj]\n\n    # 5. Reconstruct Grid\n    current_pos = 0 # Tracks current row (for vertical) or col (for horizontal)\n\n    # Add the initial gap (the gap before the *first object in the sorted list*)\n    first_obj_id = id(sorted_objects[0])\n    initial_gap_for_sorted = gap_map.get(first_obj_id, gap_map.get('initial', 0)) # Use initial overall gap if the first sorted obj was also first in input\n    current_pos += initial_gap_for_sorted\n\n\n    for i, obj in enumerate(sorted_objects):\n        # Calculate the offset needed to place this object at current_pos\n        if primary_axis == 'vertical':\n            row_offset = current_pos - obj.min_row\n            col_offset = 0\n            # Add object's height to current_pos for the next iteration\n            current_pos += obj.height\n        else: # primary_axis == 'horizontal'\n            row_offset = 0\n            col_offset = current_pos - obj.min_col\n            # Add object's width to current_pos for the next iteration\n            current_pos += obj.width\n\n        # Place the object's cells onto the output grid\n        for r, c in obj.coords:\n            nr, nc = r + row_offset, c + col_offset\n            # Check bounds just in case offsets cause issues (shouldn't if logic is right)\n            if 0 <= nr < rows and 0 <= nc < cols:\n                output_grid[nr, nc] = obj.color\n            else:\n                 # This case indicates an error in gap/offset calculation or object placement logic\n                 print(f\"Warning: Coordinate ({nr}, {nc}) out of bounds for object {obj}\")\n\n\n        # Add the gap that should follow this object\n        # This is the gap that preceded the *next* object in the sorted list,\n        # which corresponds to the gap that *preceded* that next object in the *input* order.\n        if i < len(sorted_objects) - 1:\n             next_obj_id = id(sorted_objects[i+1])\n             # Find the gap associated with the *start* of the next object in the input order\n             gap_size = gap_map.get(next_obj_id, 0) # Default to 0 if not found (shouldn't happen)\n             current_pos += gap_size\n\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3662,
    "candidates_token_count": 2666,
    "total_token_count": 6328,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.362604,
  "retries": 1
}