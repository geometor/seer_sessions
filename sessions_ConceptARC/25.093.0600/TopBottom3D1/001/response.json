{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the unique non-zero color (C_frame) that acts as a boundary separating the background (0) from at least one other non-zero color region.\nPerform a flood fill starting from all background cells (0), treating C_frame cells as impassable walls. Mark all reachable cells as 'external'.\nCreate the output grid:\n- Cells with color C_frame remain C_frame.\n- Cells marked 'external' retain their original color.\n- All other cells (internal, non-C_frame cells) are changed to C_frame.\n\"\"\"\n\ndef _flood_fill(grid, start_coords, walls_color):\n    \"\"\"\n    Performs a flood fill (BFS) starting from start_coords.\n    Returns a set of reachable coordinates, avoiding cells with walls_color.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque(start_coords)\n    reachable = set(start_coords)\n    \n    while q:\n        r, c = q.popleft()\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_coord = (nr, nc)\n                # Check if neighbor is reachable: not already visited and not a wall\n                if neighbor_coord not in reachable and grid[nr, nc] != walls_color:\n                    reachable.add(neighbor_coord)\n                    q.append(neighbor_coord)\n                    \n    return reachable\n\ndef _find_frame_color(grid):\n    \"\"\"\n    Identifies the frame color C_frame.\n    C_frame is the non-zero color that partitions the grid such that\n    some non-zero cells are not reachable from the background (0)\n    when C_frame cells are treated as walls.\n    \"\"\"\n    rows, cols = grid.shape\n    non_zero_colors = np.unique(grid[grid != 0])\n    \n    if len(non_zero_colors) < 2:\n        # Not enough distinct colors to form a frame and an inside\n        return None \n\n    background_coords = list(zip(*np.where(grid == 0)))\n    all_non_zero_coords = list(zip(*np.where(grid != 0)))\n\n    for potential_frame_color in non_zero_colors:\n        # Perform flood fill from background, treating potential_frame_color as walls\n        reachable_from_bg = _flood_fill(grid, background_coords, potential_frame_color)\n        \n        # Check if *any* non-zero cell (that isn't the potential frame color) is *not* reachable\n        unreachable_found = False\n        for r_nz, c_nz in all_non_zero_coords:\n            if grid[r_nz, c_nz] != potential_frame_color:\n                if (r_nz, c_nz) not in reachable_from_bg:\n                    unreachable_found = True\n                    break # Found an unreachable internal cell for this potential frame color\n        \n        if unreachable_found:\n            return potential_frame_color # This is the frame color\n\n    # Should ideally find a frame color based on problem constraints\n    # If not, maybe return the most frequent non-zero, or handle error\n    # Based on examples, a frame color always exists if there are >= 2 non-zero colors.\n    print(\"Warning: Could not definitively identify a frame color.\")\n    return None # Or raise an error\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by filling the area enclosed by a specific frame color\n    with that frame color.\n\n    Args:\n        input_grid (numpy.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n    output_grid = np.copy(input_grid_np)\n\n    # 1. Identify the frame color (C_frame)\n    frame_color = _find_frame_color(input_grid_np)\n    \n    # Handle cases where no clear frame is identified (e.g., single color, only background)\n    if frame_color is None:\n         # If only one non-zero color exists or just background, no transformation needed\n         unique_colors = np.unique(input_grid_np)\n         if len(unique_colors) <= 2: # Background + at most one other color\n              return output_grid\n         else:\n              # Fallback or error if frame identification failed unexpectedly\n              print(\"Error: Frame color identification failed unexpectedly.\")\n              return output_grid # Return original grid as fallback\n\n\n    # 2. Perform flood fill from background to find external cells\n    background_coords = list(zip(*np.where(input_grid_np == 0)))\n    # The fill should treat frame_color cells as walls\n    external_cells = _flood_fill(input_grid_np, background_coords, frame_color)\n\n    # 3. Generate the output grid\n    for r in range(rows):\n        for c in range(cols):\n            # Rule a: If the cell has the frame color, keep it.\n            if input_grid_np[r, c] == frame_color:\n                output_grid[r, c] = frame_color\n            # Rule b: If the cell is external (reachable from background without crossing frame), keep its original color.\n            elif (r, c) in external_cells:\n                output_grid[r, c] = input_grid_np[r, c]\n            # Rule c: Otherwise (it's internal and not the frame color), change it to the frame color.\n            else:\n                output_grid[r, c] = frame_color\n                \n    return output_grid.tolist() # Convert back to list of lists if needed by the environment\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2534,
    "candidates_token_count": 1406,
    "total_token_count": 3940,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.552251,
  "retries": 1
}