{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by identifying 'frame' colors and 'inner' colors. \nAn inner color cell is changed to the adjacent frame color if it's not reachable \nfrom the background (color 0) when the specific frame color is treated as a wall, \nand if it is directly adjacent to a cell of that frame color in the input grid. This process is \nrepeated for every unique non-zero color acting as a potential frame, updating a copy of the grid.\n\"\"\"\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get valid 4-connectivity neighbors coordinates. \"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef _flood_fill(grid, start_coords, wall_colors_set):\n    \"\"\"\n    Performs a flood fill (BFS) starting from start_coords.\n    Returns a set of reachable coordinates, avoiding cells with colors in wall_colors_set.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque()\n    reachable = set()\n    visited = set() # Keep track of visited to avoid cycles and redundant checks\n\n    # Initialize queue and visited set with valid starting points (non-wall background cells)\n    for r, c in start_coords:\n        # Check if the start coordinate itself is a wall or already visited\n        if grid[r, c] not in wall_colors_set and (r, c) not in visited:\n            q.append((r, c))\n            visited.add((r,c))\n            reachable.add((r,c)) # Start coords are reachable if not walls\n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n        # Current cell (r,c) is already added to reachable when added to queue/visited\n\n        for nr, nc in _get_neighbors(r, c, rows, cols):\n            neighbor_coord = (nr, nc)\n            # Check if neighbor is reachable: not already visited and not a wall color\n            if neighbor_coord not in visited and grid[nr, nc] not in wall_colors_set:\n                visited.add(neighbor_coord)\n                reachable.add(neighbor_coord) # Mark as reachable\n                q.append(neighbor_coord)\n\n    return reachable\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the frame-fill transformation to the input grid.\n\n    Args:\n        input_grid (list[list[int]]): A 2D list representing the input grid.\n\n    Returns:\n        list[list[int]]: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n\n    # 1. Initialize an output_grid as an identical copy of the input_grid.\n    output_grid = np.copy(input_grid_np)\n\n    # 2. Identify the set of all unique non-zero colors present in the input_grid.\n    potential_frame_colors = np.unique(input_grid_np[input_grid_np != 0])\n    if len(potential_frame_colors) == 0: # Handle empty or all-zero grids\n        return input_grid # No transformation needed, return original list of lists\n\n    # 3. Identify the coordinates of all cells in the input_grid with color 0.\n    background_coords = list(zip(*np.where(input_grid_np == 0)))\n    # Handle edge case where there is no background (grid fully filled with non-zeros)\n    # In this case, flood fill won't start, external_cells will be empty,\n    # and all non-frame cells adjacent to a frame cell will be considered internal.\n    if not background_coords and np.all(input_grid_np != 0):\n         pass # Allow processing to continue, external_cells will be empty\n\n    # 4. For each potential_frame_color:\n    for frame_color in potential_frame_colors:\n        # a. Perform flood fill from background, treating frame_color as wall.\n        wall_set = {frame_color}\n        # Only perform fill if background exists\n        external_cells_relative_to_frame = set()\n        if background_coords:\n             external_cells_relative_to_frame = _flood_fill(input_grid_np, background_coords, wall_set)\n\n        # b. Iterate through every cell coordinate (r, c).\n        for r in range(rows):\n            for c in range(cols):\n                coord = (r, c)\n                # Read the color from the *original* input grid for checks\n                current_color = input_grid_np[r, c]\n\n                # c.i. Check if current_color is 0 or the frame_color itself. Skip if true.\n                if current_color == 0 or current_color == frame_color:\n                    continue\n\n                # c.ii. Check if the cell is external relative to this frame_color. Skip if true.\n                # A cell is external if it was reached by the flood fill.\n                if coord in external_cells_relative_to_frame:\n                    continue\n\n                # At this point, the cell (r,c) has color C_inner != 0, C_inner != frame_color,\n                # and is internal relative to this frame_color (not reachable from bg).\n\n                # c.iii. Check if any neighbor has the frame_color (in the *input* grid).\n                has_frame_neighbor = False\n                for nr, nc in _get_neighbors(r, c, rows, cols):\n                    # Check neighbor color in the original input grid\n                    if input_grid_np[nr, nc] == frame_color:\n                        has_frame_neighbor = True\n                        break\n\n                # c.iv. If it's internal and has a frame neighbor, update the output_grid cell.\n                # Important: update the output_grid, not the input_grid_np being read.\n                if has_frame_neighbor:\n                    output_grid[r, c] = frame_color\n\n    # 5. Return the final output_grid, converted back to list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24810,
    "candidates_token_count": 1517,
    "total_token_count": 26327,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.89753,
  "retries": 1
}