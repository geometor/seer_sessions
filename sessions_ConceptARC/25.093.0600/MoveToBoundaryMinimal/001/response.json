{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nTransforms a 10x10 grid by moving a single, isolated non-zero digit ('Moving Digit') \nadjacent to a line (row or column) of identical non-zero digits ('Blocking Pattern').\n\nThe transformation involves:\n1. Identifying the Blocking Pattern (a full row or column of identical non-zero digits).\n2. Identifying the Moving Digit (an isolated non-zero digit different from the background '0' and the pattern).\n3. Determining the target position adjacent to the Blocking Pattern, in the direction perpendicular to the pattern's orientation.\n4. Moving the Moving Digit to the target position in the output grid.\n5. Replacing the Moving Digit's original position with the background value '0'.\n\"\"\"\n\ndef find_blocking_pattern(grid):\n    \"\"\"\n    Finds the blocking pattern (a line of identical non-zero digits).\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: (value, orientation, index) or None if not found.\n               orientation is 'horizontal' or 'vertical'.\n               index is the row or column index.\n    \"\"\"\n    rows, cols = grid.shape\n\n    # Check for horizontal pattern\n    for r in range(rows):\n        first_val = grid[r, 0]\n        if first_val != 0 and np.all(grid[r, :] == first_val):\n            return first_val, 'horizontal', r\n\n    # Check for vertical pattern\n    for c in range(cols):\n        first_val = grid[0, c]\n        if first_val != 0 and np.all(grid[:, c] == first_val):\n             return first_val, 'vertical', c\n             \n    # Fallback/Refined check (in case moving digit is initially *in* the line)\n    # This is slightly more robust if the line isn't perfectly uniform initially\n    # Check rows again, looking for a dominant non-zero value\n    for r in range(rows):\n        unique_vals, counts = np.unique(grid[r, :], return_counts=True)\n        non_zero_indices = np.where(unique_vals != 0)[0]\n        if len(non_zero_indices) == 1: # Exactly one non-zero value in the row\n            val_index = non_zero_indices[0]\n            pattern_val = unique_vals[val_index]\n            # Check if this value dominates the row (e.g., appears >= cols-1 times)\n            # This handles the case where the moving digit might initially be in the pattern row/col\n            if counts[val_index] >= cols -1: \n                 return pattern_val, 'horizontal', r\n                 \n    # Check columns again, looking for a dominant non-zero value\n    for c in range(cols):\n        unique_vals, counts = np.unique(grid[:, c], return_counts=True)\n        non_zero_indices = np.where(unique_vals != 0)[0]\n        if len(non_zero_indices) == 1: # Exactly one non-zero value in the column\n            val_index = non_zero_indices[0]\n            pattern_val = unique_vals[val_index]\n            if counts[val_index] >= rows -1: \n                 return pattern_val, 'vertical', c\n\n\n    return None, None, -1 # Should not happen based on examples\n\n\ndef find_moving_digit(grid, pattern_value):\n    \"\"\"\n    Finds the single, isolated non-zero digit that is not the background or pattern.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        pattern_value (int): The value of the blocking pattern digit.\n\n    Returns:\n        tuple: (value, row, col) or None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            val = grid[r, c]\n            if val != 0 and val != pattern_value:\n                # Check if it's truly isolated (or part of the pattern temporarily)\n                # A simple check: is it the only non-zero, non-pattern value?\n                # (More sophisticated checks could look at neighbors)\n                # For this problem, assuming only one such digit exists simplifies this.\n                return val, r, c\n    return None, -1, -1 # Should not happen based on examples\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid_np = copy.deepcopy(grid_np)\n    rows, cols = grid_np.shape\n\n    # --- Identify Grid Components ---\n    \n    # Find the blocking pattern\n    pattern_value, orientation, pattern_index = find_blocking_pattern(grid_np)\n    if orientation is None:\n        # Handle cases where pattern is not found (though examples suggest it always exists)\n        return input_grid # Return original if no pattern identifiable\n\n    # Find the moving digit\n    moving_value, initial_r, initial_c = find_moving_digit(grid_np, pattern_value)\n    if moving_value is None:\n         # Handle cases where moving digit is not found\n         return input_grid # Return original if no moving digit\n\n    # --- Determine Target Position ---\n    target_r, target_c = -1, -1\n    if orientation == 'vertical':\n        # Pattern is a column at pattern_index\n        # Based on Example 1 (pattern col 9, digit moves from col 2 to col 8)\n        # Move horizontally towards the column, stopping adjacent to it.\n        target_r = initial_r\n        # Check if digit is left or right (though example only shows left)\n        if initial_c < pattern_index:\n            target_c = pattern_index - 1\n        else: # initial_c > pattern_index\n             target_c = pattern_index + 1 # Assuming symmetry, though not shown\n             \n    elif orientation == 'horizontal':\n        # Pattern is a row at pattern_index\n        # Based on Example 2 (pattern row 0, digit moves from row 7 to row 1)\n        # Move vertically towards the row, stopping adjacent to it.\n        target_c = initial_c\n        # Check if digit is above or below (example shows below)\n        if initial_r > pattern_index:\n             target_r = pattern_index + 1\n        else: # initial_r < pattern_index\n            target_r = pattern_index - 1 # Assuming symmetry, though not shown\n\n    # --- Update the Output Grid ---\n    if target_r != -1 and target_c != -1: # Check if target was determined\n        # Set the initial position of the moving digit to 0 (background)\n        output_grid_np[initial_r, initial_c] = 0\n        # Place the moving digit at the target position\n        output_grid_np[target_r, target_c] = moving_value\n\n    # Convert back to list of lists for the expected output format\n    output_grid = output_grid_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2129,
    "candidates_token_count": 1717,
    "total_token_count": 3846,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.682759,
  "retries": 1
}