{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nThis transformation identifies two distinct non-zero patterns in the input grid. \nOne pattern, composed of the digit '8', forms a hollow rectangular \"frame\". \nThe other pattern, composed of different non-zero digits, is the \"content\".\nThe transformation copies the \"content\" pattern into the hollow interior of the \"frame\" pattern.\n\n1. Identify the coordinates of all cells belonging to the \"frame\" (value 8).\n2. Identify the coordinates of all cells belonging to the \"content\" pattern (non-zero, non-8 values).\n3. Calculate the bounding box of the \"frame\" pattern.\n4. Calculate the bounding box of the \"content\" pattern.\n5. Determine the top-left corner of the area *inside* the frame (assumed to be one cell inwards from the frame's top-left bounding box corner).\n6. Create a copy of the input grid to serve as the output grid.\n7. Iterate through the cells within the \"content\" pattern's bounding box in the input grid.\n8. For each cell that belongs to the \"content\" pattern (non-zero, non-8 value):\n    a. Calculate its relative position within the \"content\" pattern's bounding box.\n    b. Determine the corresponding target position in the output grid by adding the relative position to the top-left corner of the frame's interior.\n    c. Place the \"content\" cell's value at the calculated target position in the output grid, overwriting the existing value.\n9. Return the modified output grid.\n\"\"\"\n\ndef find_pattern_coords(grid, value=None, exclude_values=None):\n    \"\"\"Finds coordinates of cells matching specific criteria.\"\"\"\n    coords = []\n    rows, cols = grid.shape\n    if exclude_values is None:\n        exclude_values = []\n\n    for r in range(rows):\n        for c in range(cols):\n            cell_value = grid[r, c]\n            if value is not None:\n                if cell_value == value:\n                    coords.append((r, c))\n            elif cell_value != 0 and cell_value not in exclude_values:\n                 coords.append((r, c))\n    return coords\n\ndef get_bounding_box(coords):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a list of coordinates.\"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies a frame (value 8) and a content pattern (other non-zeros) in the\n    input grid, and copies the content pattern into the frame's interior.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and manipulation\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find coordinates of the frame (value 8)\n    frame_coords = find_pattern_coords(grid, value=8)\n\n    # Find coordinates of the content pattern (non-zero, non-8)\n    content_coords = find_pattern_coords(grid, exclude_values=[0, 8])\n\n    # Proceed only if both patterns are found\n    if not frame_coords or not content_coords:\n        # If either pattern is missing, return the original grid\n        return output_grid.tolist()\n\n    # Calculate bounding boxes\n    frame_bbox = get_bounding_box(frame_coords)\n    content_bbox = get_bounding_box(content_coords)\n\n    if not frame_bbox or not content_bbox:\n         # Should not happen if coords lists are not empty, but good practice\n         return output_grid.tolist()\n\n    frame_r_min, frame_c_min, _, _ = frame_bbox\n    content_r_min, content_c_min, content_r_max, content_c_max = content_bbox\n\n    # Determine the top-left corner of the frame's interior\n    # Assumption: Interior starts one cell inside the frame's bounding box\n    interior_r0 = frame_r_min + 1\n    interior_c0 = frame_c_min + 1\n\n    # Iterate through the bounding box of the content pattern in the input grid\n    for r in range(content_r_min, content_r_max + 1):\n        for c in range(content_c_min, content_c_max + 1):\n            # Get the value from the original grid\n            value = grid[r, c]\n\n            # Check if this cell is part of the content pattern (non-zero and not 8)\n            if value != 0 and value != 8:\n                # Calculate relative position within the content pattern's bounding box\n                rel_r = r - content_r_min\n                rel_c = c - content_c_min\n\n                # Calculate target position in the output grid within the frame's interior\n                target_r = interior_r0 + rel_r\n                target_c = interior_c0 + rel_c\n\n                # Check if target position is within the grid bounds before writing\n                if 0 <= target_r < rows and 0 <= target_c < cols:\n                    # Place the content value into the output grid\n                    output_grid[target_r, target_c] = value\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2426,
    "candidates_token_count": 1320,
    "total_token_count": 3746,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.51837,
  "retries": 1
}