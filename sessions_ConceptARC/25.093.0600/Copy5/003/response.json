{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Union\n\n\"\"\"\nTransforms an input grid based on the location and pattern of the number '1'.\n\nThe transformation follows one of two rules:\n\n1.  **Horizontal Expansion ('column' pattern):** If all '1's are located within a single column:\n    a.  The grid is partitioned into `Matrix_A` (columns left), `Column_B` (marker column), and `Matrix_C` (columns right).\n    b.  `Column_0` is created by replacing '1's in `Column_B` with '0'.\n    c.  A horizontal block `Block_H` is formed: `[Matrix_A | Column_0]` (or just `Column_0` if `Matrix_A` is empty).\n    d.  The number of repetitions `Repetitions_H` is `Matrix_C.shape[1] + 1`.\n    e.  The output is constructed by horizontally concatenating `Block_H` repeated `Repetitions_H` times, followed by `Matrix_A` (if it exists).\n\n2.  **Vertical Expansion ('rows' pattern):** If all '1's are located within a contiguous block of rows:\n    a.  The grid is partitioned into `Subgrid_A` (rows above the marker block).\n    b.  `Row_0` (a row of zeros) is created with the same width as the grid.\n    c.  A vertical block `Block_V` is formed: `[Subgrid_A / Row_0]` (or just `Row_0` if `Subgrid_A` is empty).\n    d.  The number of repetitions `Repetitions_V` is the number of rows in the marker block.\n    e.  The output is constructed by vertically stacking `Block_V` repeated `Repetitions_V` times, followed by `Subgrid_A` (if it exists).\n\nIf the '1' pattern doesn't match either case, or if no '1' is found, the original input grid is returned.\n\"\"\"\n\ndef find_marker_positions(grid: np.ndarray, marker: int = 1) -> List[Tuple[int, int]]:\n    \"\"\"Finds all occurrences of the marker value in the grid.\"\"\"\n    rows, cols = np.where(grid == marker)\n    return list(zip(rows.tolist(), cols.tolist())) # Convert numpy indices to standard ints\n\ndef determine_pattern(marker_positions: List[Tuple[int, int]], grid_shape: Tuple[int, int]) -> Tuple[str, Optional[Union[int, Tuple[int, int]]]]:\n    \"\"\"\n    Determines the pattern of marker positions ('column' or 'rows').\n\n    Returns:\n        A tuple: (pattern_type, relevant_indices)\n        - If 'column': ('column', column_index)\n        - If 'rows': ('rows', (start_row_index, end_row_index))\n        - If pattern is indeterminate or no markers: ('unknown', None)\n    \"\"\"\n    if not marker_positions:\n        return 'unknown', None # No marker found\n\n    rows, cols = zip(*marker_positions)\n    unique_cols = set(cols)\n    unique_rows = set(rows)\n\n    # Check for single column pattern\n    if len(unique_cols) == 1:\n        return 'column', unique_cols.pop()\n\n    # Check for contiguous block of rows pattern\n    min_row, max_row = min(unique_rows), max(unique_rows)\n    # Check if the number of unique rows matches the span (contiguity check)\n    if len(unique_rows) == (max_row - min_row + 1):\n        # This check is sufficient if the 'column' check failed\n        return 'rows', (min_row, max_row)\n\n    return 'unknown', None # Pattern doesn't match column or contiguous rows\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid based on '1' marker patterns.\n    \"\"\"\n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    grid_shape = grid.shape\n    num_rows, num_cols = grid_shape\n\n    # 1. Analyze Marker: Find '1's and determine the pattern\n    marker_positions = find_marker_positions(grid, 1)\n    pattern_type, indices = determine_pattern(marker_positions, grid_shape)\n\n    # Initialize output grid variable\n    output_grid_np = None\n\n    # 2. Process by Pattern\n    if pattern_type == 'column':\n        # --- Horizontal Expansion Logic ---\n        marker_col = indices\n\n        # a. Partition Grid: Slice into Matrix_A, Column_B, Matrix_C\n        matrix_a = grid[:, :marker_col]\n        column_b = grid[:, marker_col:marker_col+1] # Keep as 2D column\n        matrix_c = grid[:, marker_col+1:]\n\n        # b. Modify Marker Region: Create Column_0\n        column_0 = np.where(column_b == 1, 0, column_b)\n\n        # c. Calculate Repetitions: Based on Matrix_C's width\n        repetitions_h = matrix_c.shape[1] + 1\n\n        # d. Assemble Repeating Block (Block_H)\n        if matrix_a.size > 0: # Check if Matrix_A is not empty\n            block_h = np.hstack((matrix_a, column_0))\n        else: # Marker was in the first column\n            block_h = column_0\n\n        # e. Assemble Output Grid\n        output_parts = []\n        for _ in range(repetitions_h):\n            output_parts.append(block_h)\n\n        # Append final Matrix_A if it exists\n        if matrix_a.size > 0:\n            output_parts.append(matrix_a)\n\n        # Concatenate all parts horizontally if list is not empty\n        if output_parts:\n            output_grid_np = np.hstack(output_parts)\n        else: # Should not happen with valid inputs where marker exists\n             output_grid_np = np.array([[]] * num_rows) # Empty grid with correct rows\n\n\n    elif pattern_type == 'rows':\n        # --- Vertical Expansion Logic ---\n        start_row, end_row = indices\n\n        # a. Partition Grid: Slice into Subgrid_A\n        subgrid_a = grid[:start_row, :]\n        # We only need the count of rows in Subgrid B for repetitions\n\n        # b. Modify Marker Region: Create Row_0\n        row_0 = np.zeros((1, num_cols), dtype=int)\n\n        # c. Calculate Repetitions: Based on number of marker rows\n        repetitions_v = end_row - start_row + 1\n\n        # d. Assemble Repeating Block (Block_V)\n        if subgrid_a.size > 0: # Check if Subgrid_A is not empty\n            block_v = np.vstack((subgrid_a, row_0))\n        else: # Marker rows started at the first row\n            block_v = row_0\n\n        # e. Assemble Output Grid\n        output_parts = []\n        for _ in range(repetitions_v):\n            output_parts.append(block_v)\n\n        # Append final Subgrid_A if it exists\n        if subgrid_a.size > 0:\n            output_parts.append(subgrid_a)\n\n        # Stack all parts vertically if list is not empty\n        if output_parts:\n            output_grid_np = np.vstack(output_parts)\n        else: # Should not happen if repetitions > 0\n             output_grid_np = np.array([[]]) # Empty grid\n\n    else: # pattern_type == 'unknown' or no markers found\n        # Return the original input grid if pattern is not recognized\n        return input_grid\n\n    # Convert the final NumPy array back to a list of lists\n    # Handle the case where output might be empty (e.g., 0 repetitions somehow)\n    if output_grid_np is not None and output_grid_np.size > 0:\n        return output_grid_np.tolist()\n    elif output_grid_np is not None and output_grid_np.shape[0] > 0 and output_grid_np.shape[1] == 0:\n         # Handle case of empty columns but multiple rows e.g. hstack([])\n         return [[] for _ in range(output_grid_np.shape[0])]\n    else:\n         # Handle case of truly empty grid e.g. vstack([]) or hstack of empty\n         return []\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9473,
    "candidates_token_count": 2052,
    "total_token_count": 11525,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.485194,
  "retries": 1
}