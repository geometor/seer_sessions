{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Union\n\n\"\"\"\nTransforms an input grid based on the location and pattern of the number '1'.\n\nThe transformation follows one of two primary rules determined by the pattern of '1's:\n\n1.  **Vertical Expansion ('rows' pattern):** If all '1's are located within a single, contiguous block of rows (potentially spanning multiple columns).\n    a.  The grid is partitioned into `Subgrid_A` (rows above the marker block).\n    b.  A `Row_0` (a row of zeros) is created with the same width as the grid.\n    c.  A vertical block `Block_V` is formed: `[Subgrid_A / Row_0]` if `Subgrid_A` exists, otherwise just `Row_0`.\n    d.  The number of repetitions `Repetitions_V` is the number of rows in the marker block.\n    e.  The output is constructed by vertically stacking `Block_V` repeated `Repetitions_V` times, followed by `Subgrid_A` (if it exists).\n\n2.  **Horizontal Expansion ('column' pattern):** This pattern applies if:\n    - All '1's are located within a single column.\n    - OR All '1's are located within a single row (spanning multiple columns). In this case, the *leftmost* column containing a '1' is treated as the marker column.\n    a.  The grid is partitioned into `Matrix_A` (columns left of the marker column), `Column_B` (the marker column), and `Matrix_C` (columns right of the marker column).\n    b.  `Column_0` is created by replacing '1's in `Column_B` with '0'.\n    c.  A horizontal block `Block_H` is formed: `[Matrix_A | Column_0]` if `Matrix_A` exists, otherwise just `Column_0`.\n    d.  The number of repetitions `Repetitions_H` is `Matrix_C.shape[1] + 1`.\n    e.  The output is constructed by horizontally concatenating `Block_H` repeated `Repetitions_H` times, followed by `Matrix_A` (if it exists).\n\nIf the '1' pattern doesn't match either case, or if no '1' is found, the original input grid is returned.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_marker_positions(grid: np.ndarray, marker: int = 1) -> List[Tuple[int, int]]:\n    \"\"\"Finds all (row, col) occurrences of the marker value in the grid.\"\"\"\n    rows, cols = np.where(grid == marker)\n    # Convert numpy indices to standard ints for consistency\n    return list(zip(rows.tolist(), cols.tolist()))\n\ndef determine_pattern_refined(marker_positions: List[Tuple[int, int]], grid_shape: Tuple[int, int]) -> Tuple[str, Optional[Union[int, Tuple[int, int]]]]:\n    \"\"\"\n    Determines the pattern ('rows', 'column', 'unknown') based on revised logic.\n\n    Returns:\n        A tuple: (pattern_type, relevant_indices)\n        - If 'rows': ('rows', (start_row_index, end_row_index))\n        - If 'column': ('column', column_index)\n        - If pattern is indeterminate or no markers: ('unknown', None)\n    \"\"\"\n    if not marker_positions:\n        return 'unknown', None # No marker found\n\n    rows, cols = zip(*marker_positions)\n    unique_rows = set(rows)\n    unique_cols = set(cols)\n    num_unique_rows = len(unique_rows)\n    num_unique_cols = len(unique_cols)\n\n    # 1. Check Rows Pattern First (Contiguous block of rows)\n    min_row, max_row = min(unique_rows), max(unique_rows)\n    # Check if the number of unique rows matches the span (contiguity check)\n    if num_unique_rows == (max_row - min_row + 1):\n        # This pattern takes precedence even if markers are also in a single column\n        return 'rows', (min_row, max_row)\n\n    # 2. Check Column Pattern Second (Single column)\n    if num_unique_cols == 1:\n        return 'column', unique_cols.pop()\n\n    # 3. Check Single Row/Multi-Column Case (Treat as 'column' using min col)\n    if num_unique_rows == 1 and num_unique_cols > 1:\n        return 'column', min(unique_cols)\n\n    # 4. Otherwise, pattern is unknown\n    return 'unknown', None\n\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid based on '1' marker patterns.\n    \"\"\"\n    # Handle empty input grid\n    if not input_grid or not input_grid[0]:\n        return []\n\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    grid_shape = grid.shape\n    num_rows, num_cols = grid_shape\n\n    # --- Workflow Steps ---\n    # 1. Locate Markers: Find all '1's\n    marker_positions = find_marker_positions(grid, 1)\n\n    # 2. Determine Pattern: Use the refined logic\n    pattern_type, indices = determine_pattern_refined(marker_positions, grid_shape)\n\n    # Initialize output grid variable\n    output_grid_np = None\n\n    # 3. Process by Pattern\n    if pattern_type == 'rows':\n        # --- Vertical Expansion Logic ---\n        start_row, end_row = indices\n\n        # 3a. Partition Grid: Identify Subgrid_A (rows above marker block)\n        subgrid_a = grid[:start_row, :]\n        subgrid_a_exists = subgrid_a.size > 0\n\n        # 3b. Create Zero Region: Row_0\n        row_0 = np.zeros((1, num_cols), dtype=int)\n\n        # 3c. Calculate Repetitions: Based on marker block height\n        repetitions_v = end_row - start_row + 1\n\n        # 3d. Assemble Repeating Block (Block_V)\n        if subgrid_a_exists:\n            block_v = np.vstack((subgrid_a, row_0))\n        else: # Marker rows started at the first row\n            block_v = row_0\n\n        # 3e. Assemble Output Grid: Stack Block_V repeatedly, add final Subgrid_A\n        output_parts = []\n        for _ in range(repetitions_v):\n            output_parts.append(block_v)\n        if subgrid_a_exists:\n            output_parts.append(subgrid_a)\n\n        # Perform the vertical stack if parts exist\n        if output_parts:\n            output_grid_np = np.vstack(output_parts)\n        else: # Should not happen if repetitions > 0\n             output_grid_np = np.array([[]]) # Empty grid\n\n    elif pattern_type == 'column':\n        # --- Horizontal Expansion Logic ---\n        marker_col = indices\n\n        # 3a. Partition Grid: Slice into Matrix_A, Column_B, Matrix_C\n        matrix_a = grid[:, :marker_col]\n        column_b = grid[:, marker_col:marker_col+1] # Keep as 2D column\n        matrix_c = grid[:, marker_col+1:]\n        matrix_a_exists = matrix_a.size > 0\n        matrix_c_exists = matrix_c.size > 0\n\n        # 3b. Create Zero Region: Column_0 (replacing 1s in Column_B)\n        column_0 = np.where(column_b == 1, 0, column_b)\n\n        # 3c. Calculate Repetitions: Based on Matrix_C's width\n        repetitions_h = (matrix_c.shape[1] if matrix_c_exists else 0) + 1\n\n        # 3d. Assemble Repeating Block (Block_H)\n        if matrix_a_exists:\n            block_h = np.hstack((matrix_a, column_0))\n        else: # Marker was in the first column\n            block_h = column_0\n\n        # 3e. Assemble Output Grid: Concatenate Block_H repeatedly, add final Matrix_A\n        output_parts = []\n        for _ in range(repetitions_h):\n            output_parts.append(block_h)\n        if matrix_a_exists:\n            output_parts.append(matrix_a)\n\n        # Perform the horizontal concatenation if parts exist\n        if output_parts:\n            output_grid_np = np.hstack(output_parts)\n        else: # Should not happen with valid inputs where marker exists\n             output_grid_np = np.array([[]] * num_rows) # Empty grid with correct rows\n\n    else: # pattern_type == 'unknown' or no markers found initially\n        # 4. Handle Unknown Pattern: Return the original input grid\n        return input_grid\n\n    # 5. Final Output Conversion: Convert result back to list of lists\n    if output_grid_np is not None and output_grid_np.size > 0:\n        return output_grid_np.tolist()\n    elif output_grid_np is not None and output_grid_np.shape[0] > 0 and output_grid_np.shape[1] == 0:\n         # Handle case of empty columns but multiple rows (e.g., hstack result was empty)\n         return [[] for _ in range(output_grid_np.shape[0])]\n    elif output_grid_np is not None: # Handles empty grid np.array([[]]) from vstack\n        return []\n    else: # Should only be reached if pattern was unknown\n        return input_grid # Failsafe\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13160,
    "candidates_token_count": 2327,
    "total_token_count": 15487,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.341379,
  "retries": 1
}