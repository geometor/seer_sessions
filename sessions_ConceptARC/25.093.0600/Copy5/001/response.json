{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n\"\"\"\nTransforms an input grid based on the location and pattern of the number '1'.\n\nThe transformation follows one of two rules:\n\n1.  **Horizontal Expansion:** If all '1's are located within a single column:\n    a.  The grid is partitioned into three parts: `Matrix A` (columns left of the '1' column), `Column B` (the '1' column), and `Matrix C` (columns right of the '1' column).\n    b.  A new `Column 0` is created by replacing the '1'(s) in `Column B` with '0'.\n    c.  The output is constructed by repeating the concatenation `[Matrix A | Column 0]` horizontally `N+1` times (where `N` is the number of columns in `Matrix C`), followed by a final `Matrix A`.\n\n2.  **Vertical Expansion:** If all '1's are located within a contiguous block of rows:\n    a.  The grid is partitioned into two parts: `Subgrid A` (rows above the '1' block) and `Subgrid B` (the contiguous rows containing all the '1's).\n    b.  A new `Row 0` is created, consisting entirely of '0's with the same width as the input grid.\n    c.  The output is constructed by repeating the vertical stack `[Subgrid A / Row 0]` `M` times (where `M` is the number of rows in `Subgrid B`), followed by a final `Subgrid A`.\n\nIf the '1' pattern doesn't match either of these specific cases, the behavior is undefined by the examples.\n\"\"\"\n\ndef find_marker_positions(grid: np.ndarray, marker: int = 1) -> List[Tuple[int, int]]:\n    \"\"\"Finds all occurrences of the marker value in the grid.\"\"\"\n    rows, cols = np.where(grid == marker)\n    return list(zip(rows, cols))\n\ndef determine_pattern(marker_positions: List[Tuple[int, int]], grid_shape: Tuple[int, int]) -> Tuple[str, int | Tuple[int, int]]:\n    \"\"\"\n    Determines the pattern of marker positions ('column' or 'rows').\n\n    Returns:\n        A tuple: (pattern_type, relevant_indices)\n        - If 'column': ('column', column_index)\n        - If 'rows': ('rows', (start_row_index, end_row_index))\n        - If 'unknown': ('unknown', -1)\n    \"\"\"\n    if not marker_positions:\n        return 'unknown', -1 # No marker found\n\n    rows, cols = zip(*marker_positions)\n    unique_cols = set(cols)\n    unique_rows = set(rows)\n\n    # Check for single column pattern\n    if len(unique_cols) == 1:\n        return 'column', unique_cols.pop()\n\n    # Check for contiguous block of rows pattern\n    min_row, max_row = min(unique_rows), max(unique_rows)\n    if max_row - min_row + 1 == len(unique_rows):\n         # Check if ALL markers are within this contiguous block\n         # (This check is implicitly true if we reached here after failing the column check)\n        return 'rows', (min_row, max_row)\n\n    return 'unknown', -1\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid based on '1' marker patterns.\n    \"\"\"\n    if not input_grid or not input_grid[0]:\n        return [] # Handle empty input\n\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    grid_shape = grid.shape\n\n    # 1. Analyze Marker: Find '1's and determine the pattern\n    marker_positions = find_marker_positions(grid, 1)\n\n    if not marker_positions:\n        # If no '1' is found, maybe return the input unchanged or handle as error?\n        # Based on examples, '1' is always present. Assuming valid input.\n        # For robustness, let's return input as is if no marker.\n         return input_grid\n\n\n    pattern_type, indices = determine_pattern(marker_positions, grid_shape)\n\n    # 2. Branch by Pattern\n    output_grid_np = None\n\n    if pattern_type == 'column':\n        # Horizontal Expansion Logic\n        marker_col = indices\n        num_cols = grid_shape[1]\n\n        # a. Identify partitions\n        matrix_a = grid[:, :marker_col] if marker_col > 0 else None\n        column_b = grid[:, marker_col:marker_col+1] # Keep as 2D column\n        matrix_c = grid[:, marker_col+1:] if marker_col < num_cols - 1 else None\n\n        # b. Create Column 0\n        column_0 = np.where(column_b == 1, 0, column_b)\n\n        # c. Calculate Repetitions\n        n_right = matrix_c.shape[1] if matrix_c is not None else 0\n        repetitions = n_right + 1\n\n        # d. Define repeating block\n        # Handle cases where matrix_a is None (marker is in the first column)\n        if matrix_a is not None:\n             repeating_block = np.hstack((matrix_a, column_0))\n        else:\n             repeating_block = column_0 # If marker is col 0, block is just Column 0\n\n\n        # e. Assemble Output\n        output_parts = []\n        for _ in range(repetitions):\n             output_parts.append(repeating_block)\n\n        # Add the final Matrix A if it exists\n        if matrix_a is not None:\n            output_parts.append(matrix_a)\n\n        # Concatenate all parts horizontally\n        if output_parts:\n             output_grid_np = np.hstack(output_parts)\n        else: # Should not happen with valid inputs, but handle gracefully\n             output_grid_np = np.array([[]] * grid_shape[0]) # Empty grid with correct rows\n\n\n    elif pattern_type == 'rows':\n        # Vertical Expansion Logic\n        start_row, end_row = indices\n        num_rows, num_cols = grid_shape\n\n        # a. Identify partitions\n        subgrid_a = grid[:start_row, :] if start_row > 0 else None\n        # Subgrid B is defined by the rows containing '1's, its size is used for reps\n        subgrid_b_row_count = end_row - start_row + 1\n\n        # b. Create Row 0\n        row_0 = np.zeros((1, num_cols), dtype=int)\n\n        # c. Calculate Repetitions\n        repetitions = subgrid_b_row_count\n\n        # d. Define repeating block part (Subgrid A / Row 0)\n        # Handle cases where subgrid_a is None (marker rows start at row 0)\n        if subgrid_a is not None:\n            repeating_block_part = np.vstack((subgrid_a, row_0))\n        else:\n            repeating_block_part = row_0 # If marker rows start at 0, block is just Row 0\n\n\n        # e. Assemble Output\n        output_parts = []\n        for _ in range(repetitions):\n            output_parts.append(repeating_block_part)\n\n        # Add the final Subgrid A if it exists\n        if subgrid_a is not None:\n            output_parts.append(subgrid_a)\n\n        # Stack all parts vertically\n        if output_parts:\n            output_grid_np = np.vstack(output_parts)\n        else: # Should not happen if repetitions > 0\n            output_grid_np = np.array([[]]) # Empty grid\n\n\n    else: # pattern_type == 'unknown'\n        # Handle unknown patterns - perhaps return input or raise error\n        # For now, return input grid as per robustness comment earlier\n        return input_grid\n\n\n    # Convert numpy array back to list of lists for the final output\n    return output_grid_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2050,
    "candidates_token_count": 1910,
    "total_token_count": 3960,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 120.210906,
  "retries": 2
}