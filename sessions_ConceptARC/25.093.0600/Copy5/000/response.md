Okay, let's break down the transformation logic for these examples.

**Perception of Task Elements:**

1.  **Input/Output Format:** Both inputs and outputs are 2D grids (matrices) of single-digit integers.
2.  **Key Element:** The number '1' seems to play a crucial role as a marker or separator within the input grid. Its position and distribution dictate the transformation type.
3.  **Transformation Types:** Two distinct transformation patterns emerge based on the arrangement of '1's:
    *   **Horizontal Expansion (train\_1, train\_2):** When '1' appears in a single column, the grid is expanded horizontally. The process involves identifying parts of the grid relative to the '1' column, modifying the '1' column, and repeating/concatenating these parts.
    *   **Vertical Expansion (train\_3):** When '1' appears in a block of rows (specifically, these rows start with '1' and are grouped together in the example), the grid is expanded vertically. The process involves identifying blocks of rows relative to the '1'-containing rows, creating a zero-filled row, and repeating/stacking these parts.
4.  **Core Operations:** The transformations involve partitioning the input grid, replacing '1' with '0', repetition, and concatenation (horizontal or vertical stacking).

**Facts (YAML):**


```yaml
Task: Grid Transformation based on '1' marker

Input:
  Type: 2D Grid (List of Lists of Integers)
  Objects:
    - Grid: The entire input matrix.
    - Marker_Cell: Cell(s) containing the value '1'.
    - Partition_A: Subgrid identified based on Marker_Cell location.
    - Partition_B: Subgrid/Column/Row containing the Marker_Cell.
    - Partition_C: (Optional) Subgrid identified based on Marker_Cell location (relevant for horizontal case).
  Properties:
    - Dimensions: rows, columns
    - Marker_Location: Coordinates or defining axis (column index or row indices) of '1'.
    - Marker_Distribution: Pattern of '1's (single column vs. block of rows).

Output:
  Type: 2D Grid (List of Lists of Integers)
  Construction: Based on repeating and assembling parts derived from the input.

Actions:
  - Locate_Marker: Find the position(s) of '1'.
  - Determine_Axis: Identify if the transformation is primarily horizontal or vertical based on '1' distribution.
  - Partition_Grid: Divide the input grid into relevant parts (A, B, C or A, B) based on the marker and axis.
  - Modify_Marker_Region: Create a new element (Column 0 or Row 0) by replacing '1's with '0's in the marker's region (Partition B).
  - Calculate_Repetitions: Determine the number of repetitions based on the size of a specific partition (Partition C for horizontal, Partition B for vertical).
  - Assemble_Output: Construct the output grid by repeating and concatenating/stacking the derived parts according to the determined axis and repetition count.

Relationships:
  - Output grid's structure and content are derived from the input grid's partitions.
  - The location and pattern of '1's dictate the partitioning strategy and assembly method (horizontal vs. vertical).
  - The size of certain input partitions determines the number of repetitions in the output.
```


**Natural Language Program:**

1.  **Analyze Marker:** Examine the input grid to locate all cells containing the value '1'. Determine the distribution pattern of these '1's.
2.  **Branch by Pattern:**
    *   **If '1's are confined to a single column:**
        a.  Identify this column as `Column B`.
        b.  Identify the block of columns to the left of `Column B` as `Matrix A`.
        c.  Identify the block of columns to the right of `Column B` as `Matrix C`. If no columns are to the right, `Matrix C` is empty.
        d.  Create `Column 0` by copying `Column B` and changing the cell(s) containing '1' to '0'.
        e.  Count the number of columns in `Matrix C` (call this `N_right`).
        f.  Define a repeating block as the horizontal concatenation `[Matrix A | Column 0]`.
        g.  Construct the output by horizontally concatenating the repeating block `(N_right + 1)` times, followed by `Matrix A`.
    *   **If '1's are found in a contiguous block of rows (specifically, rows where '1' appears, potentially at the start):**
        a.  Identify these rows as `Subgrid B`.
        b.  Identify the contiguous block of rows above `Subgrid B` (which do not contain '1') as `Subgrid A`. Assume `Subgrid B` is below `Subgrid A`.
        c.  Create `Row 0`, a single row filled entirely with '0's, having the same width as the input grid.
        d.  Count the number of rows in `Subgrid B` (call this `N_rows_B`).
        e.  Define a repeating block as the vertical stacking `[Subgrid A / Row 0]` (where `/` denotes stacking rows).
        f.  Construct the output by vertically stacking the repeating block `N_rows_B` times, followed by `Subgrid A`.
3.  **Return:** Output the final constructed grid.