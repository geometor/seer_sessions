{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nThe transformation identifies 'source' cells (non-zero, non-5 values) and 'barrier' cells (value 5) in the input grid. \nFor each source cell, it checks for the nearest barrier cell in the same row or column. \nIf a barrier exists in the row, the source value 'fills' all zero cells horizontally between the source and the barrier.\nIf no barrier exists in the row, it checks the column. If a barrier exists in the column, the source value 'fills' all zero cells vertically between the source and the barrier.\nThe filling only occurs along the direct path towards the *closest* barrier in that dimension (row or column). If no barrier is found in either the row or the column, the source cell does not spread.\n\"\"\"\n\ndef find_cells_by_value(grid, values_to_find):\n    \"\"\"Finds all cells with specified values.\"\"\"\n    cells = []\n    rows, cols = grid.shape\n    if not isinstance(values_to_find, list):\n        values_to_find = [values_to_find]\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] in values_to_find:\n                cells.append(((r, c), grid[r, c]))\n    return cells\n\ndef find_closest_barrier_in_row(grid, source_pos):\n    \"\"\"Finds the closest barrier (value 5) in the same row.\"\"\"\n    sr, sc = source_pos\n    rows, cols = grid.shape\n    closest_barrier_col = -1\n    min_dist = float('inf')\n\n    # Check right\n    for c in range(sc + 1, cols):\n        if grid[sr, c] == 5:\n            dist = c - sc\n            if dist < min_dist:\n                min_dist = dist\n                closest_barrier_col = c\n            break # Found first barrier to the right\n\n    # Check left\n    for c in range(sc - 1, -1, -1):\n        if grid[sr, c] == 5:\n            dist = sc - c\n            if dist < min_dist:\n                min_dist = dist\n                closest_barrier_col = c\n            break # Found first barrier to the left\n\n    if closest_barrier_col != -1:\n        return (sr, closest_barrier_col)\n    else:\n        return None\n\ndef find_closest_barrier_in_col(grid, source_pos):\n    \"\"\"Finds the closest barrier (value 5) in the same column.\"\"\"\n    sr, sc = source_pos\n    rows, cols = grid.shape\n    closest_barrier_row = -1\n    min_dist = float('inf')\n\n    # Check down\n    for r in range(sr + 1, rows):\n        if grid[r, sc] == 5:\n            dist = r - sr\n            if dist < min_dist:\n                min_dist = dist\n                closest_barrier_row = r\n            break # Found first barrier below\n\n    # Check up\n    for r in range(sr - 1, -1, -1):\n        if grid[r, sc] == 5:\n            dist = sr - r\n            if dist < min_dist:\n                min_dist = dist\n                closest_barrier_row = r\n            break # Found first barrier above\n\n    if closest_barrier_row != -1:\n        return (closest_barrier_row, sc)\n    else:\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: source cells fill towards the nearest\n    barrier (5) in their row or column.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid)\n    # Initialize output_grid as a copy of the input\n    output_grid = copy.deepcopy(input_np)\n    rows, cols = input_np.shape\n\n    # Identify all source cells (not 0 and not 5)\n    source_cells = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_np[r, c] != 0 and input_np[r, c] != 5:\n                source_cells.append(((r, c), input_np[r, c]))\n\n    # Process each source cell\n    for source_pos, source_value in source_cells:\n        sr, sc = source_pos\n\n        # Try finding the closest horizontal barrier first\n        horizontal_barrier_pos = find_closest_barrier_in_row(input_np, source_pos)\n\n        if horizontal_barrier_pos:\n            # Fill horizontally towards the barrier\n            br, bc = horizontal_barrier_pos\n            if bc > sc: # Barrier is to the right\n                for c in range(sc + 1, bc):\n                    if output_grid[sr, c] == 0: # Only fill empty cells\n                        output_grid[sr, c] = source_value\n            else: # Barrier is to the left\n                for c in range(sc - 1, bc, -1):\n                     if output_grid[sr, c] == 0: # Only fill empty cells\n                        output_grid[sr, c] = source_value\n        else:\n            # If no horizontal barrier, try finding the closest vertical barrier\n            vertical_barrier_pos = find_closest_barrier_in_col(input_np, source_pos)\n            if vertical_barrier_pos:\n                # Fill vertically towards the barrier\n                br, bc = vertical_barrier_pos\n                if br > sr: # Barrier is below\n                    for r in range(sr + 1, br):\n                        if output_grid[r, sc] == 0: # Only fill empty cells\n                            output_grid[r, sc] = source_value\n                else: # Barrier is above\n                    for r in range(sr - 1, br, -1):\n                        if output_grid[r, sc] == 0: # Only fill empty cells\n                            output_grid[r, sc] = source_value\n\n    # Convert back to list of lists if necessary (or keep as numpy array)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2497,
    "candidates_token_count": 1442,
    "total_token_count": 3939,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.656695,
  "retries": 1
}