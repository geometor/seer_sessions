{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components (objects) of non-zero pixels in a 2D grid.\nClassifies objects as 'enclosed' (surrounded entirely by background '0') or 'static'.\nAssumes exactly one 'enclosed' object (the 'mover').\nFinds the 'static' object ('target') whose bounding box is closest to the 'mover's bounding box.\nCalculates the movement vector (dx, dy) required to shift the 'mover' so that its bounding box touches the 'target's bounding box along the axis (horizontal or vertical) where they were initially closest (smallest non-negative gap).\nCreates an output grid where the 'mover' object is shifted by the calculated vector, and all 'static' objects remain in their original positions.\n\"\"\"\n\ndef get_neighbors(r, c, H, W, include_diagonal=False):\n    \"\"\"Gets valid neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if not include_diagonal and abs(dr) + abs(dc) != 1:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box of a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return (min_r, max_r, min_c, max_c)\n\ndef find_objects(grid):\n    \"\"\"Finds all connected components of non-zero pixels.\"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    if grid[curr_r, curr_c] == color: # Check color match\n                        obj_pixels.add((curr_r, curr_c))\n                        # Check orthogonal neighbors for expansion\n                        for nr, nc in get_neighbors(curr_r, curr_c, H, W, include_diagonal=False):\n                            if not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    # Mark visited even if color doesn't match to avoid reprocessing\n                    # But only add to object if color matches\n                    # This handles cases where BFS starts on a cell adjacent but not part of the object color\n                    # Let's refine: only add matching color neighbors to queue\n                    # The initial check `grid[r, c] != 0 and not visited[r, c]` ensures we start a new object search correctly.\n                \n                # BFS refinement to ensure correct object extraction\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited_bfs = set([(r, c)]) # Visited for this specific BFS run\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.add((curr_r, curr_c))\n                    visited[curr_r, curr_c] = True # Mark globally visited\n\n                    for nr, nc in get_neighbors(curr_r, curr_c, H, W, include_diagonal=False):\n                        if grid[nr, nc] == color and (nr, nc) not in visited_bfs:\n                            visited_bfs.add((nr, nc))\n                            q.append((nr, nc))\n\n\n                if obj_pixels:\n                    bbox = get_bounding_box(obj_pixels)\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': bbox\n                    })\n    return objects\n\ndef is_enclosed(obj, grid):\n    \"\"\"Checks if an object is entirely surrounded by background (0).\"\"\"\n    H, W = grid.shape\n    obj_pixels = obj['pixels']\n    for r, c in obj_pixels:\n        # Check all 8 neighbors\n        for nr, nc in get_neighbors(r, c, H, W, include_diagonal=True):\n            if (nr, nc) not in obj_pixels and grid[nr, nc] != 0:\n                return False  # Found a non-background neighbor outside the object\n    return True\n\ndef calculate_bbox_gaps(bbox1, bbox2):\n    \"\"\"Calculates the horizontal and vertical gaps between two bounding boxes.\"\"\"\n    r_min1, r_max1, c_min1, c_max1 = bbox1\n    r_min2, r_max2, c_min2, c_max2 = bbox2\n\n    # Vertical Gap (gap_y)\n    if r_max1 < r_min2:  # bbox1 is strictly above bbox2\n        gap_y = r_min2 - r_max1 - 1\n    elif r_max2 < r_min1:  # bbox2 is strictly above bbox1\n        gap_y = r_min1 - r_max2 - 1\n    else:  # Bounding boxes overlap vertically\n        gap_y = -1\n\n    # Horizontal Gap (gap_x)\n    if c_max1 < c_min2:  # bbox1 is strictly left of bbox2\n        gap_x = c_min2 - c_max1 - 1\n    elif c_max2 < c_min1:  # bbox2 is strictly left of bbox1\n        gap_x = c_min1 - c_max2 - 1\n    else:  # Bounding boxes overlap horizontally\n        gap_x = -1\n\n    return gap_x, gap_y\n\ndef calculate_shift(mover_obj, target_obj):\n    \"\"\"Calculates the shift (dx, dy) to make mover bbox touch target bbox along the minimum gap axis.\"\"\"\n    mover_bbox = mover_obj['bbox']\n    target_bbox = target_obj['bbox']\n    gap_x, gap_y = calculate_bbox_gaps(mover_bbox, target_bbox)\n\n    r_min_m, r_max_m, c_min_m, c_max_m = mover_bbox\n    r_min_t, r_max_t, c_min_t, c_max_t = target_bbox\n\n    dx, dy = 0, 0\n\n    # Determine primary movement axis based on smallest non-negative gap\n    move_horizontally = False\n    move_vertically = False\n\n    if gap_x >= 0 and (gap_y < 0 or gap_x <= gap_y):\n        move_horizontally = True\n    elif gap_y >= 0 and (gap_x < 0 or gap_y < gap_x):\n        move_vertically = True\n    # If both gaps are negative or zero, no movement needed based on this logic\n\n    # Calculate shift based on axis and relative position\n    if move_horizontally:\n        if c_max_m < c_min_t:  # Mover is left of target\n            dx = gap_x\n        elif c_min_m > c_max_t:  # Mover is right of target\n            dx = -gap_x\n        dy = 0\n    elif move_vertically:\n        if r_max_m < r_min_t:  # Mover is above target\n            dy = gap_y\n        elif r_min_m > r_max_t:  # Mover is below target\n            dy = -gap_y\n        dx = 0\n\n    return dx, dy\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds the enclosed object, finds the closest static object,\n    and moves the enclosed object until its bounding box touches the static object's bounding box\n    along the axis of the smallest initial gap.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    H, W = input_grid_np.shape\n    \n    # 1. Find all objects\n    objects = find_objects(input_grid_np)\n    if not objects:\n        return input_grid # Return original if no objects found\n\n    # 2. Classify objects\n    mover_obj = None\n    static_objs = []\n    for obj in objects:\n        if is_enclosed(obj, input_grid_np):\n            if mover_obj is not None:\n                 # Assumption violated: more than one enclosed object\n                 # Handle error or default behavior (e.g., use the first one)\n                 print(\"Warning: Multiple enclosed objects found. Using the first one.\")\n            mover_obj = obj\n        else:\n            static_objs.append(obj)\n\n    # Check assumptions\n    if mover_obj is None:\n        # print(\"Warning: No enclosed object found.\")\n        return input_grid # No object to move\n    if not static_objs:\n        # print(\"Warning: No static object found.\")\n        return input_grid # No target to move towards\n\n    # 3. Find the target static object (closest to mover)\n    target_obj = None\n    min_dist_sq = float('inf') # Use squared distance to avoid sqrt\n\n    for static_obj in static_objs:\n        gap_x, gap_y = calculate_bbox_gaps(mover_obj['bbox'], static_obj['bbox'])\n        \n        dist_sq = 0\n        if gap_x >= 0 and gap_y >= 0:\n             # Treat gaps as distances along axes for comparison\n             # We want the minimum *gap*, not Euclidean distance here.\n             # Let's find the object with the minimum non-negative gap sum,\n             # prioritizing the smallest single gap.\n             # Simpler: choose the target based on smallest non-negative gap.\n             current_min_gap = float('inf')\n             if gap_x >=0: current_min_gap = min(current_min_gap, gap_x)\n             if gap_y >=0: current_min_gap = min(current_min_gap, gap_y)\n             \n             if current_min_gap < min_dist_sq: # Using min_dist_sq to store min_gap now\n                 min_dist_sq = current_min_gap\n                 target_obj = static_obj\n        elif gap_x >= 0: # Only horizontal gap is non-negative\n             if gap_x < min_dist_sq:\n                 min_dist_sq = gap_x\n                 target_obj = static_obj\n        elif gap_y >= 0: # Only vertical gap is non-negative\n             if gap_y < min_dist_sq:\n                 min_dist_sq = gap_y\n                 target_obj = static_obj\n        else: # Both gaps negative (overlap) - considered distance 0\n             if 0 < min_dist_sq: # Prioritize overlapping? Or closest non-overlapping?\n                 # Let's prioritize smallest positive gap first. Overlap means 0 gap.\n                 # If no positive gaps found yet, an overlapping one becomes the target.\n                 if min_dist_sq == float('inf'):\n                     min_dist_sq = 0 \n                     target_obj = static_obj\n\n\n    # If target_obj is still None (e.g., only overlapping objects found, and initial min_dist_sq was inf)\n    # Pick the first static object as default, though this case shouldn't happen based on examples.\n    if target_obj is None and static_objs:\n        target_obj = static_objs[0]\n        print(\"Warning: Could not determine closest static object based on gaps, defaulting.\")\n        \n    if target_obj is None: # Should not happen if static_objs is not empty\n        return input_grid\n\n    # 4. Calculate shift (dx, dy)\n    dx, dy = calculate_shift(mover_obj, target_obj)\n\n    # 5. Apply movement\n    output_grid = np.copy(input_grid_np)\n\n    # Erase mover from original position\n    for r, c in mover_obj['pixels']:\n        output_grid[r, c] = 0\n\n    # Draw mover in new position\n    mover_color = mover_obj['color']\n    for r, c in mover_obj['pixels']:\n        new_r, new_c = r + dy, c + dx\n        # Check bounds before drawing\n        if 0 <= new_r < H and 0 <= new_c < W:\n            output_grid[new_r, new_c] = mover_color\n        else:\n            # Part of the object moved out of bounds - handle as needed\n            # For this problem, seems unlikely based on examples, but good practice\n            print(f\"Warning: Pixel ({r},{c}) moved out of bounds to ({new_r},{new_c})\")\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3395,
    "candidates_token_count": 3130,
    "total_token_count": 6525,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 60.656756,
  "retries": 1
}