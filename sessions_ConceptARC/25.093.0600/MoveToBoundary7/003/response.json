{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by identifying the two distinct non-zero colored objects. \nThe object with the smaller number of pixels (the 'mover') is moved towards the \nother object (the 'target') along the axis (horizontal or vertical) where their \ninitial bounding box separation is smallest. The movement stops when the bounding \nboxes are adjacent, separated by exactly one pixel of background (0). The target \nobject remains stationary. Assumes exactly two objects exist.\n\"\"\"\n\n# === Helper Functions ===\n\ndef get_neighbors(r, c, H, W):\n    \"\"\"Gets valid orthogonal neighbor coordinates.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef get_bounding_box(pixels):\n    \"\"\"Calculates the bounding box (min_r, max_r, min_c, max_c) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_r = min(r for r, c in pixels)\n    max_r = max(r for r, c in pixels)\n    min_c = min(c for r, c in pixels)\n    max_c = max(c for r, c in pixels)\n    return (min_r, max_r, min_c, max_c)\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components (objects) of non-zero pixels using BFS.\n    Returns a list of objects, each with 'color', 'pixels', 'pixel_count', and 'bbox'.\n    \"\"\"\n    H, W = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(H):\n        for c in range(W):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_pixels.add((r,c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Find neighbors with the same color\n                    for nr, nc in get_neighbors(curr_r, curr_c, H, W):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            obj_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    bbox = get_bounding_box(obj_pixels)\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'pixel_count': len(obj_pixels),\n                        'bbox': bbox\n                    })\n    return objects\n\ndef calculate_bbox_gaps(bbox1, bbox2):\n    \"\"\"\n    Calculates the horizontal and vertical gaps between two bounding boxes.\n    Returns gap_x, gap_y. Gap is distance between closest edges.\n    Returns -1 for an axis if the boxes overlap on that axis.\n    \"\"\"\n    r_min1, r_max1, c_min1, c_max1 = bbox1\n    r_min2, r_max2, c_min2, c_max2 = bbox2\n\n    # Vertical Gap (gap_y)\n    if r_max1 < r_min2:  # bbox1 is strictly above bbox2\n        gap_y = r_min2 - r_max1 - 1\n    elif r_max2 < r_min1:  # bbox2 is strictly above bbox1\n        gap_y = r_min1 - r_max2 - 1\n    else:  # Bounding boxes overlap or touch vertically\n        gap_y = -1\n\n    # Horizontal Gap (gap_x)\n    if c_max1 < c_min2:  # bbox1 is strictly left of bbox2\n        gap_x = c_min2 - c_max1 - 1\n    elif c_max2 < c_min1:  # bbox2 is strictly left of bbox1\n        gap_x = c_min1 - c_max2 - 1\n    else:  # Bounding boxes overlap or touch horizontally\n        gap_x = -1\n\n    return gap_x, gap_y\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: finds the two objects, identifies the one \n    with fewer pixels as the mover, calculates the move needed to make it \n    adjacent to the target along the minimum gap axis, and returns the new grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    H, W = input_grid_np.shape\n    \n    # 1. Find the objects\n    objects = find_objects(input_grid_np)\n\n    # 2. Check assumption: exactly two objects must exist\n    if len(objects) != 2:\n        # print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning original grid.\")\n        return input_grid # Return original grid if assumption is violated\n\n    # 3. Classify objects: mover (min pixels) and target\n    obj1, obj2 = objects[0], objects[1]\n    if obj1['pixel_count'] <= obj2['pixel_count']:\n        mover_obj = obj1\n        target_obj = obj2\n    else:\n        mover_obj = obj2\n        target_obj = obj1\n\n    # 4. Calculate bounding box gaps\n    mover_bbox = mover_obj['bbox']\n    target_bbox = target_obj['bbox']\n    gap_x, gap_y = calculate_bbox_gaps(mover_bbox, target_bbox)\n\n    # 5. Determine movement axis and calculate shift (dx, dy)\n    dx, dy = 0, 0\n    move_horizontally = False\n    move_vertically = False\n\n    # Choose axis with the minimum non-negative gap\n    if gap_x >= 0 and (gap_y < 0 or gap_x <= gap_y):\n        move_horizontally = True\n    elif gap_y >= 0 and (gap_x < 0 or gap_y < gap_x):\n        move_vertically = True\n    # If both gaps are negative (overlap), no movement based on minimum gap rule.\n    # If both gaps are equal and non-negative, default to horizontal (based on first check).\n\n    # Calculate shift amount to close the gap to 1 pixel\n    if move_horizontally:\n        r_min_m, r_max_m, c_min_m, c_max_m = mover_bbox\n        r_min_t, r_max_t, c_min_t, c_max_t = target_bbox\n        if c_max_m < c_min_t:  # Mover is left of target\n            dx = gap_x\n        elif c_min_m > c_max_t:  # Mover is right of target\n            dx = -gap_x \n        dy = 0\n    elif move_vertically:\n        r_min_m, r_max_m, c_min_m, c_max_m = mover_bbox\n        r_min_t, r_max_t, c_min_t, c_max_t = target_bbox\n        if r_max_m < r_min_t:  # Mover is above target\n            dy = gap_y\n        elif r_min_m > r_max_t:  # Mover is below target\n            dy = -gap_y\n        dx = 0\n\n    # 6. Apply movement to create the output grid\n    output_grid = np.copy(input_grid_np)\n\n    # Erase mover from original position\n    for r, c in mover_obj['pixels']:\n        output_grid[r, c] = 0\n\n    # Draw mover in new position\n    mover_color = mover_obj['color']\n    for r, c in mover_obj['pixels']:\n        new_r, new_c = r + dy, c + dx\n        # Check bounds before drawing\n        if 0 <= new_r < H and 0 <= new_c < W:\n            # Ensure we don't overwrite the target object if movement is large/incorrect\n            # (This check might be overly cautious if logic is correct, but safe)\n            target_pixels_set = target_obj['pixels']\n            if (new_r, new_c) not in target_pixels_set:\n                 output_grid[new_r, new_c] = mover_color\n            # else:\n                # print(f\"Warning: Mover pixel ({r},{c}) moved to ({new_r},{new_c}) which is part of the target. Skipping draw.\")\n        # else:\n            # print(f\"Warning: Mover pixel ({r},{c}) moved out of bounds to ({new_r},{new_c}). Skipping draw.\")\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17510,
    "candidates_token_count": 2178,
    "total_token_count": 19688,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.30203,
  "retries": 1
}