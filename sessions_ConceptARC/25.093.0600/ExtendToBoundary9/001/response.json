{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies a closed boundary shape of one color and an 'inner' element of another color within the input grid.\nIt then performs a flood fill operation, changing the color of all background (0) cells enclosed by the boundary shape to the color of the inner element.\nThe boundary shape and the original inner element(s) retain their colors.\n\n1. Identify the two distinct non-zero colors present in the grid.\n2. Determine which color forms the boundary and which color is the 'fill' color (the one initially inside). This is done by tentatively assuming one color is the boundary, finding the enclosed '0' cells, and checking if the other color is adjacent to any of these enclosed cells.\n3. Identify all '0' cells reachable from the grid edges without crossing the determined boundary color. These are 'outside' cells.\n4. All '0' cells not reachable from the edges are considered 'inside'.\n5. Change the color of all 'inside' '0' cells to the determined fill color in the output grid.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n  \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n  return 0 <= r < rows and 0 <= c < cols\n\ndef _find_inside_zeros(grid, boundary_color):\n    \"\"\"\n    Finds the coordinates of all background (0) cells that are enclosed\n    by the boundary_color, meaning they cannot reach the edge of the grid\n    by moving only through 0-cells.\n\n    Args:\n        grid (np.array): The input grid.\n        boundary_color (int): The color value acting as the boundary.\n\n    Returns:\n        list: A list of (row, col) tuples for inside zero cells.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_from_edge = np.zeros_like(grid, dtype=bool)\n    q = collections.deque()\n\n    # Add all edge '0' cells to the queue and mark as reachable\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                reachable_from_edge[r, c] = True\n                q.append((r, c))\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                reachable_from_edge[r, c] = True\n                q.append((r, c))\n\n    # Perform BFS from edge zeros\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if _is_valid(nr, nc, rows, cols) and \\\n               not reachable_from_edge[nr, nc] and \\\n               grid[nr, nc] == 0:\n                reachable_from_edge[nr, nc] = True\n                q.append((nr, nc))\n\n    # Identify inside zeros (those not reachable from the edge)\n    inside_zeros = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                inside_zeros.append((r, c))\n\n    return inside_zeros\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by flood-filling the area enclosed by a\n    boundary color with the color of an element found inside that boundary.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find the unique non-zero colors\n    colors = [c for c in np.unique(grid) if c != 0]\n\n    # Handle cases with less than 2 distinct non-zero colors (no fill possible)\n    if len(colors) < 2:\n        return output_grid.tolist()\n\n    c1, c2 = colors[0], colors[1]\n    boundary_color = -1\n    fill_color = -1\n    found_config = False\n\n    # --- Determine Boundary and Fill Color ---\n    # Try c1 as boundary\n    inside_zeros_c1 = _find_inside_zeros(grid, c1)\n    for r, c in inside_zeros_c1:\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if _is_valid(nr, nc, rows, cols) and grid[nr, nc] == c2:\n                boundary_color = c1\n                fill_color = c2\n                found_config = True\n                break\n         if found_config:\n             break\n\n    # If not found, try c2 as boundary\n    if not found_config:\n        inside_zeros_c2 = _find_inside_zeros(grid, c2)\n        for r, c in inside_zeros_c2:\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if _is_valid(nr, nc, rows, cols) and grid[nr, nc] == c1:\n                    boundary_color = c2\n                    fill_color = c1\n                    found_config = True\n                    break\n             if found_config:\n                 break\n\n    # If configuration still not determined (e.g., nested shapes or errors)\n    # or if no fill is needed (no inside zeros found for the correct boundary), return original\n    if not found_config:\n         return output_grid.tolist() # Or handle potential edge cases differently\n\n    # --- Perform the Fill ---\n    # Find the inside zeros using the confirmed boundary color\n    # We might already have this list from the check above\n    if boundary_color == c1:\n        inside_zeros_coords = inside_zeros_c1\n    else: # boundary_color == c2\n        inside_zeros_coords = inside_zeros_c2\n\n    # Change the color of inside zeros in the output grid\n    for r, c in inside_zeros_coords:\n        output_grid[r, c] = fill_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4060,
    "candidates_token_count": 1512,
    "total_token_count": 5572,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.844609,
  "retries": 1
}