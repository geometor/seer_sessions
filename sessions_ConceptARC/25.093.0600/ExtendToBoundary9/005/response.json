{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation identifies a primary closed boundary shape of one color. \nInside this boundary, there exists a 'pattern' element (potentially multi-colored and including background 0s), defined by the content within the bounding box of specific non-boundary elements found inside.\nThe core operation involves tiling this inner 'pattern' onto all background (color 0) cells that are strictly enclosed by the boundary shape. The original boundary and pattern elements remain unchanged.\n\n1.  Initialize: Create a copy of the input grid.\n2.  Identify Boundary Color: Find the non-zero color that partitions the grid such that the largest connected component of '0' cells is not reachable from the grid edges without crossing this color.\n3.  Identify Enclosed Background Cells: Perform a flood fill (BFS) starting from all '0' cells on the grid's edges. Mark all reachable '0' cells, without crossing the boundary color. Any '0' cell *not* marked is considered enclosed.\n4.  Extract Inner Pattern:\n    a. Identify all non-zero cells located within the region enclosed by the boundary (i.e., not reachable from the edge without crossing the boundary).\n    b. Determine the minimal bounding box containing these enclosed non-zero cells.\n    c. Extract the rectangular subgrid defined by this bounding box from the *original input grid*. This is the `pattern_array`.\n    d. Record the top-left coordinate (`min_row`, `min_col`) of the bounding box as the `pattern_origin`.\n5.  Tile Pattern:\n    a. Iterate through each enclosed background cell coordinate `(r, c)`.\n    b. Calculate corresponding indices `(pattern_row, pattern_col)` within the `pattern_array` using modulo arithmetic relative to the `pattern_origin`.\n    c. Retrieve the `pattern_color` from `pattern_array[pattern_row, pattern_col]`.\n    d. If `pattern_color` is not '0', update the cell in the *output grid* at `(r, c)` to this `pattern_color`.\n6.  Return: The modified output grid.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n  \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n  return 0 <= r < rows and 0 <= c < cols\n\ndef _find_enclosed_background(grid, boundary_color):\n    \"\"\"\n    Finds coordinates of background (0) cells enclosed by the boundary_color.\n    Uses BFS starting from edge '0' cells. Cells not reached are enclosed.\n\n    Args:\n        grid (np.array): The input grid.\n        boundary_color (int): The color acting as the boundary.\n\n    Returns:\n        tuple: (list_of_enclosed_zeros, reachable_mask)\n               list_of_enclosed_zeros: List of (row, col) tuples for enclosed background cells.\n               reachable_mask: A boolean numpy array where True indicates a cell reachable from edge without crossing boundary.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    q = collections.deque()\n\n    # Add edge '0' cells to the queue and mark as reachable\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == 0 and not reachable_mask[r, c]:\n                reachable_mask[r, c] = True\n                q.append((r, c))\n            # Consider non-zero cells on edge as reachable for mask purpose\n            elif grid[r, c] != 0 and not reachable_mask[r, c]:\n                 reachable_mask[r,c] = True # Mark edge non-zeros as technically reachable\n\n    for c in range(cols):\n        for r in [0, rows - 1]:\n             if grid[r, c] == 0 and not reachable_mask[r, c]:\n                reachable_mask[r, c] = True\n                q.append((r, c))\n             elif grid[r, c] != 0 and not reachable_mask[r, c]:\n                 reachable_mask[r,c] = True\n\n    # BFS from edge zeros, cannot cross the boundary_color\n    while q:\n        r, c = q.popleft()\n        # Explore neighbors only if the current cell is 0\n        if grid[r, c] == 0:\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                # Check validity, reachability, and if it's not the boundary color\n                if _is_valid(nr, nc, rows, cols) and \\\n                   not reachable_mask[nr, nc] and \\\n                   grid[nr, nc] != boundary_color:\n                    reachable_mask[nr, nc] = True\n                    # Only add '0' cells to the queue to continue BFS within connected '0' regions\n                    if grid[nr, nc] == 0:\n                        q.append((nr, nc))\n\n    # Identify enclosed background cells (0s not reachable by the BFS)\n    enclosed_zeros = []\n    for r in range(rows):\n        for c in range(cols):\n            # A cell is enclosed if it's 0 AND not marked as reachable\n            if grid[r, c] == 0 and not reachable_mask[r, c]:\n                enclosed_zeros.append((r, c))\n\n    return enclosed_zeros, reachable_mask\n\ndef _find_boundary_color(grid, unique_colors):\n    \"\"\"\n    Determines the boundary color based on which color encloses the most '0' cells.\n    \"\"\"\n    rows, cols = grid.shape\n    best_boundary_color = -1\n    max_enclosed_count = -1\n    best_enclosed_zeros_for_boundary = []\n    best_reachable_mask_for_boundary = None\n\n    if not unique_colors:\n        return best_boundary_color, best_enclosed_zeros_for_boundary, best_reachable_mask_for_boundary\n\n    for color in unique_colors:\n        enclosed_coords, reachable_mask = _find_enclosed_background(grid, color)\n        count = len(enclosed_coords)\n\n        if count > max_enclosed_count:\n            max_enclosed_count = count\n            best_boundary_color = color\n            best_enclosed_zeros_for_boundary = enclosed_coords\n            best_reachable_mask_for_boundary = reachable_mask\n        # Tie-breaking: if counts are equal, prefer lower color index (arbitrary but consistent)\n        elif count == max_enclosed_count and best_boundary_color != -1 and color < best_boundary_color:\n            best_boundary_color = color\n            best_enclosed_zeros_for_boundary = enclosed_coords\n            best_reachable_mask_for_boundary = reachable_mask\n\n    # Handle cases where no color truly encloses '0's (e.g., fully filled shapes)\n    if best_boundary_color == -1 and len(unique_colors) > 0:\n       # Fallback heuristic: maybe the most frequent color? or the one with largest extent?\n       # For now, if no clear enclosure, pick the first color. This might need refinement.\n       best_boundary_color = unique_colors[0]\n       enclosed_coords, reachable_mask = _find_enclosed_background(grid, best_boundary_color)\n       best_enclosed_zeros_for_boundary = enclosed_coords\n       best_reachable_mask_for_boundary = reachable_mask\n\n\n    return best_boundary_color, best_enclosed_zeros_for_boundary, best_reachable_mask_for_boundary\n\n\ndef _extract_inner_pattern(grid, boundary_color, reachable_mask):\n    \"\"\"\n    Identifies and extracts the inner pattern based on non-reachable, non-zero cells.\n    Handles cases where the pattern color might be the same as the boundary color but internal.\n    \"\"\"\n    rows, cols = grid.shape\n    pattern_candidate_coords = []\n\n    # Identify all cells not reachable from the outside\n    for r in range(rows):\n        for c in range(cols):\n            if not reachable_mask[r, c] and grid[r, c] != 0: # Find non-zero cells inside the unreachable area\n                 # Check if it's truly internal (not part of the immediate boundary wall adjacent to reachable space)\n                 is_internal = True\n                 if grid[r,c] == boundary_color:\n                      is_internal = False # Assume boundary color is part of wall unless proven otherwise\n                      for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = r + dr, c + dc\n                         # If any neighbor is *not* reachable (and inside grid), it suggests this boundary cell is internal\n                         if _is_valid(nr, nc, rows, cols) and not reachable_mask[nr, nc]:\n                             is_internal = True\n                             break\n                 # Add if it's not the boundary color OR if it's an internal boundary color cell\n                 if grid[r,c] != boundary_color or is_internal:\n                    pattern_candidate_coords.append((r,c))\n\n\n    if not pattern_candidate_coords:\n        return None, -1, -1 # No pattern found\n\n    # Find bounding box of the identified pattern cells\n    min_row = min(r for r, c in pattern_candidate_coords)\n    max_row = max(r for r, c in pattern_candidate_coords)\n    min_col = min(c for r, c in pattern_candidate_coords)\n    max_col = max(c for r, c in pattern_candidate_coords)\n\n    # Extract the pattern from the original grid within the bounding box\n    pattern_array = grid[min_row : max_row + 1, min_col : max_col + 1].copy()\n\n    return pattern_array, min_row, min_col\n\n\ndef transform(input_grid):\n    # Initialize output grid as a copy of the input\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find unique non-zero colors\n    unique_colors = sorted([c for c in np.unique(grid) if c != 0])\n    if not unique_colors:\n        return output_grid.tolist() # No transformation if grid is all zeros\n\n    # Identify Boundary Color and Enclosed Cells\n    boundary_color, enclosed_zeros_coords, reachable_mask = _find_boundary_color(grid, unique_colors)\n\n    # If no boundary color found or no enclosed zeros, return original\n    if boundary_color == -1 or not enclosed_zeros_coords:\n        return output_grid.tolist()\n\n    # Extract Inner Pattern\n    pattern_array, min_row, min_col = _extract_inner_pattern(grid, boundary_color, reachable_mask)\n\n    # If no pattern identified, return original grid\n    if pattern_array is None:\n        return output_grid.tolist()\n\n    pattern_height, pattern_width = pattern_array.shape\n    if pattern_height == 0 or pattern_width == 0:\n         return output_grid.tolist() # Invalid pattern dimensions\n\n    # Tile the Pattern onto Enclosed Background Cells\n    for r, c in enclosed_zeros_coords:\n        # Calculate relative position within the pattern's tiling scheme\n        # Ensure non-negative relative indices before modulo\n        rel_row = r - min_row\n        rel_col = c - min_col\n\n        # Find corresponding pattern cell using modulo\n        # Add pattern dimension before modulo to handle negative relative indices correctly\n        pattern_row = (rel_row % pattern_height + pattern_height) % pattern_height\n        pattern_col = (rel_col % pattern_width + pattern_width) % pattern_width\n\n\n        # Get color from pattern\n        pattern_color = pattern_array[pattern_row, pattern_col]\n\n        # Update output grid ONLY if pattern color is not background (0)\n        if pattern_color != 0:\n            output_grid[r, c] = pattern_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 29246,
    "candidates_token_count": 2846,
    "total_token_count": 32092,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.801115,
  "retries": 1
}