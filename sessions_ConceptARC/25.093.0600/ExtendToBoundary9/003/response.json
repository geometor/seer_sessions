{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation identifies a primary closed boundary shape of one color. \nInside this boundary, there exists at least one 'pattern' element, potentially consisting of multiple cells of a different color (or sometimes the same color as the boundary).\nThe core operation involves tiling this inner 'pattern' onto all background (color 0) cells that are strictly enclosed by the boundary shape.\n\n1.  **Initialize:** Create a copy of the input grid.\n2.  **Identify Boundary Color:** Find the color forming the outermost closed loop. This is typically the color surrounding the largest contiguous area of '0's that cannot reach the grid edge.\n3.  **Identify Enclosed Background Cells:** Perform a flood fill (BFS) starting from all '0' cells on the grid's edges. Mark all reachable '0' cells. Any '0' cell *not* marked is considered enclosed by the boundary.\n4.  **Identify Inner Pattern:**\n    *   Find all non-zero cells adjacent to the enclosed background cells identified in step 3. These form the potential inner pattern elements. Filter out cells that have the boundary color if they are part of the main boundary structure itself (e.g., check if they are adjacent to outside '0's).\n    *   Determine the bounding box (min/max row/col) of these inner pattern cells.\n    *   Extract the pattern: create a small 2D array representing the content within the bounding box, relative to the top-left corner (min_row, min_col) of the box. This pattern includes the identified inner pattern cells and any original '0's within that bounding box.\n5.  **Tile Pattern:**\n    *   Iterate through each enclosed background cell (from step 3) in the `output_grid`.\n    *   Calculate the cell's position relative to the top-left corner of the pattern's bounding box: `rel_row = row - min_row`, `rel_col = col - min_col`.\n    *   Determine the corresponding cell in the pattern using the modulo operator: `pattern_row = rel_row % pattern_height`, `pattern_col = rel_col % pattern_width`.\n    *   Get the color from the `pattern[pattern_row, pattern_col]`.\n    *   If the pattern color is not the background color (0), update the `output_grid` at `(row, col)` with this pattern color.\n6.  **Return:** The modified `output_grid`.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n  \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n  return 0 <= r < rows and 0 <= c < cols\n\ndef _find_enclosed_background(grid, boundary_color):\n    \"\"\"\n    Finds coordinates of background (0) cells enclosed by the boundary_color.\n    Uses BFS starting from edge '0' cells. Cells not reached are enclosed.\n\n    Args:\n        grid (np.array): The input grid.\n        boundary_color (int): The color acting as the boundary.\n\n    Returns:\n        list: A list of (row, col) tuples for enclosed background cells.\n        np.array: A boolean mask where True indicates a cell reachable from edge.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable_from_edge = np.zeros_like(grid, dtype=bool)\n    q = collections.deque()\n\n    # Add edge '0' cells to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                reachable_from_edge[r, c] = True\n                q.append((r, c))\n            # Also consider boundary cells on the edge as potentially allowing escape for adjacent 0s\n            elif grid[r,c] == boundary_color:\n                 reachable_from_edge[r,c] = True # Mark boundary on edge as 'visited' in context of reachability\n    for c in range(cols):\n        for r in [0, rows - 1]:\n            if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                reachable_from_edge[r, c] = True\n                q.append((r, c))\n            elif grid[r,c] == boundary_color:\n                 reachable_from_edge[r,c] = True\n\n    # BFS from edge zeros, cannot cross the boundary_color\n    while q:\n        r, c = q.popleft()\n        # Check neighbors only if current cell is 0 (or was an edge boundary cell added initially)\n        # This prevents exploring from inside the boundary if the initial queue contained edge boundary cells\n        if grid[r,c] == 0:\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if _is_valid(nr, nc, rows, cols) and \\\n                   not reachable_from_edge[nr, nc] and \\\n                   grid[nr, nc] != boundary_color: # Cannot cross the boundary\n                    reachable_from_edge[nr, nc] = True\n                    q.append((nr, nc))\n\n    # Identify enclosed background cells (0s not reachable)\n    enclosed_zeros = []\n    for r in range(rows):\n        for c in range(cols):\n            # A cell is enclosed if it's 0 AND not reachable\n            if grid[r, c] == 0 and not reachable_from_edge[r, c]:\n                enclosed_zeros.append((r, c))\n\n    return enclosed_zeros, reachable_from_edge\n\n\ndef _get_inner_pattern_and_bbox(grid, enclosed_zeros_coords, boundary_color, reachable_mask):\n    \"\"\"\n    Identifies the pattern elements inside the boundary and determines its bounding box.\n\n    Args:\n        grid (np.array): The input grid.\n        enclosed_zeros_coords (list): Coords of enclosed '0' cells.\n        boundary_color (int): The boundary color.\n        reachable_mask (np.array): Boolean mask of cells reachable from the edge.\n\n    Returns:\n        tuple: (pattern_array, min_row, min_col) or (None, -1, -1) if no pattern found.\n               pattern_array is a numpy array.\n    \"\"\"\n    rows, cols = grid.shape\n    inner_pattern_cells = []\n\n    # Find non-zero, non-boundary cells adjacent to enclosed zeros\n    # These form the 'seed' of the inner pattern\n    potential_pattern_coords = set()\n    enclosed_zeros_set = set(enclosed_zeros_coords)\n\n    for r_zero, c_zero in enclosed_zeros_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_zero + dr, c_zero + dc\n            if _is_valid(nr, nc, rows, cols) and grid[nr, nc] != 0 and grid[nr, nc] != boundary_color:\n                 potential_pattern_coords.add((nr, nc))\n            # Also consider boundary-colored cells if they are NOT part of the outer boundary\n            elif _is_valid(nr, nc, rows, cols) and grid[nr, nc] == boundary_color:\n                 # Check if this boundary cell is truly 'inside' - i.e., not adjacent to an outside '0'\n                 is_outer_boundary = False\n                 for dr2, dc2 in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                     nnr, nnc = nr + dr2, nc + dc2\n                     # If adjacent to a reachable 0 or outside grid, it's part of outer boundary\n                     if not _is_valid(nnr, nnc, rows, cols) or (grid[nnr,nnc] == 0 and reachable_mask[nnr,nnc]):\n                          is_outer_boundary = True\n                          break\n                 if not is_outer_boundary:\n                     potential_pattern_coords.add((nr, nc))\n\n\n    if not potential_pattern_coords:\n        # Check if there are *any* non-zero, non-boundary cells within the enclosed area at all\n        # This handles cases where the pattern might be disconnected from the enclosed 0s initially\n        for r in range(rows):\n             for c in range(cols):\n                 is_enclosed_non_boundary_non_zero = (\n                     grid[r, c] != 0 and\n                     grid[r, c] != boundary_color and\n                     not reachable_mask[r, c] and # Must not be reachable from outside\n                     (r,c) not in enclosed_zeros_set # Must not be a background cell\n                 )\n                 # Check also for potentially enclosed boundary-colored cells\n                 is_enclosed_boundary = (\n                     grid[r, c] == boundary_color and\n                     not reachable_mask[r,c] # Initially assume boundary cells aren't reachable unless proven otherwise by BFS\n                 )\n                 if is_enclosed_boundary:\n                      # Double check it's not adjacent to an outside area\n                      is_outer_boundary = False\n                      for dr2, dc2 in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                           nnr, nnc = r + dr2, c + dc2\n                           if not _is_valid(nnr, nnc, rows, cols) or (grid[nnr,nnc] == 0 and reachable_mask[nnr,nnc]):\n                                is_outer_boundary = True\n                                break\n                      if not is_outer_boundary:\n                           potential_pattern_coords.add((r,c))\n\n                 elif is_enclosed_non_boundary_non_zero:\n                     potential_pattern_coords.add((r, c))\n\n    if not potential_pattern_coords:\n         # Special case check for test 3: inner pattern is same color as boundary\n         # Look for boundary-colored cells surrounded only by other boundary cells or enclosed zeros\n         for r_zero, c_zero in enclosed_zeros_coords:\n             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                 nr, nc = r_zero + dr, c_zero + dc\n                 if _is_valid(nr, nc, rows, cols) and grid[nr, nc] == boundary_color:\n                     # Check if this boundary cell is truly 'inside'\n                     is_outer_boundary = False\n                     for dr2, dc2 in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nnr, nnc = nr + dr2, nc + dc2\n                         if not _is_valid(nnr, nnc, rows, cols) or (grid[nnr, nnc] == 0 and reachable_mask[nnr, nnc]):\n                             is_outer_boundary = True\n                             break\n                     if not is_outer_boundary:\n                         potential_pattern_coords.add((nr, nc))\n\n    if not potential_pattern_coords:\n        return None, -1, -1 # No pattern found\n\n    # Find bounding box of the identified pattern cells\n    min_row = min(r for r, c in potential_pattern_coords)\n    max_row = max(r for r, c in potential_pattern_coords)\n    min_col = min(c for r, c in potential_pattern_coords)\n    max_col = max(c for r, c in potential_pattern_coords)\n\n    pattern_height = max_row - min_row + 1\n    pattern_width = max_col - min_col + 1\n\n    # Extract the pattern from the original grid within the bounding box\n    pattern_array = grid[min_row : max_row + 1, min_col : max_col + 1].copy()\n\n    # Important: Ensure that only originally non-zero cells or *internal* zeros\n    # within the pattern's bounding box contribute. Zeros that were part of the\n    # main \"enclosed background\" area should remain 0 in the pattern template\n    # unless they were explicitly part of the pattern structure.\n    # Let's refine the pattern: only keep original non-zero values from potential_pattern_coords\n    # or original zero values if they fall within the bbox.\n    # This seems complex, let's rethink. Simpler: just extract the bbox area.\n    # The tiling logic will handle replacing background 0s.\n    # Let's try the simple extraction first.\n\n    # Correction: The pattern should be defined by the non-boundary colors *within* the bbox.\n    # If a cell inside the bbox in the original grid was 0 AND was identified\n    # as an 'enclosed_zero', it should be treated as 0 in the pattern for tiling.\n    # If it was a non-zero color (pattern color or boundary color that's internal), keep it.\n    pattern_array = np.zeros((pattern_height, pattern_width), dtype=int)\n    for r in range(pattern_height):\n        for c in range(pattern_width):\n            orig_r, orig_c = min_row + r, min_col + c\n            # Check if this original coordinate was one of the identified pattern cells\n            if (orig_r, orig_c) in potential_pattern_coords:\n                 pattern_array[r, c] = grid[orig_r, orig_c]\n            # Check if it's a zero *inside* the pattern bbox but *not* part of the main fill area\n            elif grid[orig_r, orig_c] == 0 and (orig_r, orig_c) not in enclosed_zeros_set:\n                 pattern_array[r, c] = 0 # Keep internal zeros if they exist\n            elif grid[orig_r, orig_c] != 0 and grid[orig_r, orig_c] != boundary_color : # Keep other non-boundary colors if any exist\n                pattern_array[r, c] = grid[orig_r, orig_c]\n\n\n    # If the constructed pattern is all zeros (edge case?), return None\n    if np.all(pattern_array == 0):\n        return None, -1, -1\n\n\n    return pattern_array, min_row, min_col\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the grid by tiling an inner pattern onto the background\n    area enclosed by a boundary shape.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find unique non-zero colors\n    colors = [c for c in np.unique(grid) if c != 0]\n    if not colors:\n        return output_grid.tolist() # No non-zero colors\n\n    # --- Determine Boundary Color ---\n    # Heuristic: Boundary color is often the most frequent non-zero color,\n    # or the one enclosing the largest '0' area.\n    # Let's try each non-zero color as a potential boundary.\n    best_boundary_color = -1\n    max_enclosed_count = -1\n    enclosed_zeros_map = {}\n    reachable_mask_map = {}\n\n    # Find enclosed zeros for each potential boundary color\n    for color in colors:\n        enclosed_coords, reachable_mask = _find_enclosed_background(grid, color)\n        enclosed_zeros_map[color] = enclosed_coords\n        reachable_mask_map[color] = reachable_mask\n        if len(enclosed_coords) > max_enclosed_count:\n            max_enclosed_count = len(enclosed_coords)\n            best_boundary_color = color\n        # Tie-breaking: if counts are equal, maybe prefer lower color index? (simple heuristic)\n        elif len(enclosed_coords) == max_enclosed_count and best_boundary_color != -1 and color < best_boundary_color:\n             best_boundary_color = color\n\n\n    # If no enclosed zeros found for any color, return original grid\n    if best_boundary_color == -1 or max_enclosed_count == 0:\n        # One last check: maybe the boundary *is* the edge of the grid, and the pattern fills everything?\n        # This seems unlikely based on examples. Let's assume a boundary color is needed.\n        return output_grid.tolist()\n\n    boundary_color = best_boundary_color\n    enclosed_zeros_coords = enclosed_zeros_map[boundary_color]\n    reachable_mask = reachable_mask_map[boundary_color]\n\n\n    # --- Identify Inner Pattern ---\n    pattern_array, min_row, min_col = _get_inner_pattern_and_bbox(grid, enclosed_zeros_coords, boundary_color, reachable_mask)\n\n    # If no pattern identified, return original grid\n    if pattern_array is None:\n        return output_grid.tolist()\n\n    pattern_height, pattern_width = pattern_array.shape\n    if pattern_height == 0 or pattern_width == 0:\n         return output_grid.tolist() # Invalid pattern dimensions\n\n\n    # --- Tile the Pattern onto Enclosed Background Cells ---\n    for r, c in enclosed_zeros_coords:\n        # Calculate relative position within the pattern's tiling scheme\n        rel_row = r - min_row\n        rel_col = c - min_col\n\n        # Find corresponding pattern cell using modulo\n        pattern_row = rel_row % pattern_height\n        pattern_col = rel_col % pattern_width\n\n        # Get color from pattern\n        pattern_color = pattern_array[pattern_row, pattern_col]\n\n        # Update output grid ONLY if pattern color is not background\n        if pattern_color != 0:\n            output_grid[r, c] = pattern_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15033,
    "candidates_token_count": 4169,
    "total_token_count": 19202,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 134.503271,
  "retries": 2
}