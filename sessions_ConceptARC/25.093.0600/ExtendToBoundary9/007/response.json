{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nThe transformation identifies a primary closed boundary shape of one color. \nInside this boundary, there exists a 'pattern' element (potentially multi-colored and including background 0s), defined by the content within the bounding box of specific non-boundary and 'internal' boundary elements found inside.\nThe core operation involves tiling this inner 'pattern' onto all background (color 0) cells that are strictly enclosed by the boundary shape. The original boundary and pattern elements remain unchanged in the output.\n\nWorkflow:\n1.  Initialize: Create a copy of the input grid for the output.\n2.  Identify Unique Colors: Find all non-zero colors present.\n3.  Identify Boundary Color: For each unique non-zero color, tentatively assume it's the boundary. Calculate which color encloses the largest area of background ('0') cells using a reachability analysis (BFS from edges). The color maximizing this enclosed area is chosen as the `boundary_color`. Also obtain the coordinates of the `enclosed_zeros_coords` and the `reachable_mask` for this boundary color.\n4.  Extract Inner Pattern:\n    a. Identify candidate cells for the pattern: These are non-zero cells that are *not* reachable from the grid edge without crossing the `boundary_color`. This includes:\n        i. Cells with a color different from the `boundary_color`.\n        ii. Cells with the `boundary_color` that are determined to be 'internal' (i.e., not adjacent to any cell marked as reachable).\n    b. Find the minimal bounding box containing all candidate pattern cells.\n    c. Extract the rectangular subgrid defined by this bounding box from the *original input grid*. This is the `pattern_array`.\n    d. Record the top-left coordinate (`min_row`, `min_col`) of the bounding box.\n5.  Tile Pattern:\n    a. Iterate through each coordinate `(r, c)` in `enclosed_zeros_coords`.\n    b. Calculate corresponding indices `(pattern_row, pattern_col)` within the `pattern_array` using modulo arithmetic relative to the pattern's top-left corner (`min_row`, `min_col`).\n    c. Retrieve the `pattern_color` from `pattern_array[pattern_row, pattern_col]`.\n    d. If `pattern_color` is not '0', update the cell in the *output grid* at `(r, c)` to this `pattern_color`.\n6.  Return: The modified output grid.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n  \"\"\"Checks if coordinates are within grid bounds.\"\"\"\n  return 0 <= r < rows and 0 <= c < cols\n\ndef _find_enclosed_background(grid, boundary_color):\n    \"\"\"\n    Finds coordinates of background (0) cells enclosed by the boundary_color.\n    Uses BFS starting from edge '0' cells. Also computes a mask indicating\n    all cells reachable from the edge without crossing the boundary color.\n\n    Args:\n        grid (np.array): The input grid.\n        boundary_color (int): The color acting as the boundary.\n\n    Returns:\n        tuple: (list_of_enclosed_zeros, reachable_mask)\n               list_of_enclosed_zeros: List of (row, col) tuples for enclosed background cells.\n               reachable_mask: A boolean numpy array where True indicates a cell reachable\n                               from edge without crossing boundary.\n    \"\"\"\n    rows, cols = grid.shape\n    # reachable_mask tracks cells reachable from the edge *without* crossing boundary_color\n    reachable_mask = np.zeros_like(grid, dtype=bool)\n    q = collections.deque()\n\n    # Initialize queue ONLY with '0' cells on the edge\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == 0 and not reachable_mask[r, c]:\n                reachable_mask[r, c] = True\n                q.append((r, c))\n    for c in range(cols): # Check top/bottom edges (excluding corners already checked)\n        for r in [0, rows - 1]:\n             if grid[r, c] == 0 and not reachable_mask[r, c]:\n                reachable_mask[r, c] = True\n                q.append((r, c))\n\n    # BFS exploring reachable areas (non-boundary cells)\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check validity, reachability, and if it's not the boundary color\n            if _is_valid(nr, nc, rows, cols) and \\\n               not reachable_mask[nr, nc] and \\\n               grid[nr, nc] != boundary_color:\n                reachable_mask[nr, nc] = True\n                q.append((nr, nc)) # Add all non-boundary reachable neighbors\n\n    # Identify enclosed background cells (0s not reachable by the BFS)\n    enclosed_zeros = []\n    for r in range(rows):\n        for c in range(cols):\n            # A cell is enclosed if it's 0 AND not marked as reachable\n            if grid[r, c] == 0 and not reachable_mask[r, c]:\n                enclosed_zeros.append((r, c))\n\n    return enclosed_zeros, reachable_mask\n\ndef _find_boundary_color(grid, unique_colors):\n    \"\"\"\n    Determines the boundary color based on which color encloses the most '0' cells.\n    Returns the chosen color, the list of enclosed '0' coords, and the reachability mask.\n    \"\"\"\n    best_boundary_color = -1\n    max_enclosed_count = -1\n    best_enclosed_zeros_for_boundary = []\n    best_reachable_mask_for_boundary = None\n\n    if not unique_colors:\n        return best_boundary_color, best_enclosed_zeros_for_boundary, best_reachable_mask_for_boundary\n\n    for color in unique_colors:\n        enclosed_coords, reachable_mask = _find_enclosed_background(grid, color)\n        count = len(enclosed_coords)\n\n        # Primary criteria: maximize enclosed zeros\n        if count > max_enclosed_count:\n            max_enclosed_count = count\n            best_boundary_color = color\n            best_enclosed_zeros_for_boundary = enclosed_coords\n            best_reachable_mask_for_boundary = reachable_mask\n        # Tie-breaking: if counts are equal, prefer lower color index (consistent heuristic)\n        elif count == max_enclosed_count and best_boundary_color != -1 and color < best_boundary_color:\n            best_boundary_color = color\n            best_enclosed_zeros_for_boundary = enclosed_coords\n            best_reachable_mask_for_boundary = reachable_mask\n\n    # Handle case where no color encloses any '0's, but colors exist\n    # (e.g., solid shapes with no internal background)\n    if best_boundary_color == -1 and unique_colors:\n       # Fallback: Pick the lowest color index as boundary? Or most frequent?\n       # Let's stick to lowest index for simplicity if no enclosure found.\n       best_boundary_color = unique_colors[0]\n       enclosed_coords, reachable_mask = _find_enclosed_background(grid, best_boundary_color)\n       best_enclosed_zeros_for_boundary = enclosed_coords # Likely empty\n       best_reachable_mask_for_boundary = reachable_mask\n\n    return best_boundary_color, best_enclosed_zeros_for_boundary, best_reachable_mask_for_boundary\n\n\ndef _extract_inner_pattern(grid, boundary_color, reachable_mask):\n    \"\"\"\n    Identifies and extracts the inner pattern based on non-reachable, non-zero cells.\n    Includes non-boundary colors and 'internal' boundary-colored cells.\n    \"\"\"\n    rows, cols = grid.shape\n    pattern_candidate_coords = []\n\n    # Iterate through all grid cells to find candidates for the pattern\n    for r in range(rows):\n        for c in range(cols):\n            # Rule 1: Must be inside the unreachable area defined by the boundary\n            if not reachable_mask[r, c]:\n                # Rule 2: Must not be a background '0' cell (those are filled later)\n                if grid[r, c] != 0:\n                    # Rule 3: Identify if it's a potential pattern element\n                    is_pattern_element = False\n                    if grid[r, c] != boundary_color:\n                        # It's a non-boundary color inside the unreachable area -> part of pattern\n                        is_pattern_element = True\n                    else: # It's a boundary-colored cell inside the unreachable area\n                        # Check if it's truly 'internal' (not adjacent to any reachable cell)\n                        is_internal_boundary = True\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = r + dr, c + dc\n                            # If neighbor is valid AND reachable, this boundary cell is part of the 'wall'\n                            if _is_valid(nr, nc, rows, cols) and reachable_mask[nr, nc]:\n                                is_internal_boundary = False\n                                break\n                        if is_internal_boundary:\n                            # Boundary-colored cell surrounded by non-reachable area -> part of pattern\n                            is_pattern_element = True\n\n                    if is_pattern_element:\n                        pattern_candidate_coords.append((r,c))\n\n\n    # If no pattern cells found (e.g., empty interior), return None\n    if not pattern_candidate_coords:\n        return None, -1, -1\n\n    # Find the bounding box of the identified pattern candidate cells\n    min_row = min(r for r, c in pattern_candidate_coords)\n    max_row = max(r for r, c in pattern_candidate_coords)\n    min_col = min(c for r, c in pattern_candidate_coords)\n    max_col = max(c for r, c in pattern_candidate_coords)\n\n    # Extract the pattern subgrid from the original input grid using the bounding box\n    pattern_array = grid[min_row : max_row + 1, min_col : max_col + 1].copy()\n\n    # Return the extracted pattern array and its top-left corner coordinates\n    return pattern_array, min_row, min_col\n\n\ndef transform(input_grid):\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # Find unique non-zero colors present in the grid\n    unique_colors = sorted([c for c in np.unique(grid) if c != 0])\n\n    # If no non-zero colors, return the original grid\n    if not unique_colors:\n        return output_grid.tolist()\n\n    # Step 3: Identify Boundary Color and Enclosed Background Cells\n    boundary_color, enclosed_zeros_coords, reachable_mask = _find_boundary_color(grid, unique_colors)\n\n    # If no valid boundary color identified or no background cells are enclosed, return original\n    if boundary_color == -1 or not enclosed_zeros_coords:\n        return output_grid.tolist()\n\n    # Step 4: Extract Inner Pattern\n    pattern_array, min_row, min_col = _extract_inner_pattern(grid, boundary_color, reachable_mask)\n\n    # If no pattern could be extracted (e.g., empty interior), return original grid\n    if pattern_array is None:\n        return output_grid.tolist()\n\n    pattern_height, pattern_width = pattern_array.shape\n\n    # Check for invalid pattern dimensions (should not happen if candidates were found)\n    if pattern_height == 0 or pattern_width == 0:\n         return output_grid.tolist()\n\n    # Step 5: Tile the Pattern onto Enclosed Background Cells in the output grid\n    for r, c in enclosed_zeros_coords:\n        # Calculate the relative position of the cell (r, c) with respect to the pattern's origin\n        rel_row = r - min_row\n        rel_col = c - min_col\n\n        # Determine the corresponding row and column within the pattern_array using modulo arithmetic\n        # The addition of pattern dimension before modulo handles potential negative relative indices correctly\n        pattern_row = (rel_row % pattern_height + pattern_height) % pattern_height\n        pattern_col = (rel_col % pattern_width + pattern_width) % pattern_width\n\n        # Get the color from the determined position in the pattern array\n        pattern_color = pattern_array[pattern_row, pattern_col]\n\n        # Update the output grid at (r, c) ONLY if the pattern color is not background (0)\n        # This prevents overwriting existing non-zero elements with pattern's background\n        if pattern_color != 0:\n            output_grid[r, c] = pattern_color\n\n    # Step 6: Return the modified grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23313,
    "candidates_token_count": 3088,
    "total_token_count": 26401,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.294326,
  "retries": 1
}