{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport copy\n\n\"\"\"\nIdentifies maximal continuous horizontal or vertical line segments of identical non-zero numbers in the input grid.\nFor each segment, it checks the path extending outwards from both endpoints along the segment's axis.\nIf such a path consists of one or more zeros and terminates immediately before another non-zero number (before hitting the grid boundary), \nthen all the zeros along that path are filled with the segment's number in the output grid. \nThis process is applied cumulatively for all identified segments and their qualifying extensions.\n\"\"\"\n\ndef _identify_segments(grid):\n    \"\"\"\n    Identifies all maximal horizontal and vertical segments of identical non-zero numbers.\n    Returns a list of segments, where each segment is represented as:\n    (value, orientation, list_of_coordinates)\n    orientation is 'h' for horizontal, 'v' for vertical.\n    \"\"\"\n    height, width = grid.shape\n    segments = []\n    visited = np.zeros_like(grid, dtype=bool) # Keep track of cells already part of a found segment\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                val = grid[r, c]\n\n                # Check horizontal segment\n                h_coords = []\n                cc = c\n                while cc < width and grid[r, cc] == val:\n                    h_coords.append((r, cc))\n                    cc += 1\n                if len(h_coords) > 1: # Only consider segments of length 2 or more\n                    segments.append((val, 'h', h_coords))\n                    for rr, cc_seg in h_coords:\n                        visited[rr, cc_seg] = True\n                # Reset visited status if only length 1 horizontal segment found here,\n                # so it can potentially be part of a vertical segment.\n                elif len(h_coords) == 1 and not visited[r,c]: \n                    pass # Keep visited[r,c] False for now\n\n                # Check vertical segment only if not part of a horizontal segment found *starting* here\n                # or if it's a single cell (which could start a vertical segment)\n                # We also need to re-check visited status in case it was part of a horizontal segment\n                # that started earlier on the same row.\n                if not visited[r,c]:\n                    v_coords = []\n                    rr = r\n                    while rr < height and grid[rr, c] == val:\n                        v_coords.append((rr, c))\n                        rr += 1\n                    if len(v_coords) > 1: # Only consider segments of length 2 or more\n                         # Check if any part of this overlaps with an already added horizontal segment cell\n                         is_new_vertical = True\n                         for rr_seg, cc_seg in v_coords:\n                             if visited[rr_seg, cc_seg]: # If any cell was visited (part of horizontal)\n                                 is_new_vertical = False\n                                 break\n                         if is_new_vertical:\n                            segments.append((val, 'v', v_coords))\n                            for rr_seg, cc_seg in v_coords:\n                                visited[rr_seg, cc_seg] = True # Mark as visited\n                    # If only a single cell was found vertically (and horizontally), mark it visited\n                    # to prevent re-processing\n                    elif len(h_coords) <=1 and len(v_coords) == 1:\n                         visited[r,c] = True\n                         \n    # Correction: The above logic might miss segments if a cell is part of both H and V segments.\n    # A better approach: find all H segments, then all V segments independently, mark visited separately?\n    # Let's refine: find H first, mark visited. Then find V, only adding if *not* fully contained in visited H. No, simpler: find all possible starts.\n    \n    # Re-try identification logic: Simpler, find all H segments, then all V segments.\n    segments = []\n    visited_h = np.zeros_like(grid, dtype=bool)\n    visited_v = np.zeros_like(grid, dtype=bool)\n\n    # Find horizontal segments\n    for r in range(height):\n        c = 0\n        while c < width:\n            if grid[r, c] != 0:\n                val = grid[r, c]\n                start_c = c\n                while c < width and grid[r, c] == val:\n                    c += 1\n                end_c = c - 1\n                if end_c > start_c: # Length >= 2\n                    coords = [(r, cc) for cc in range(start_c, end_c + 1)]\n                    segments.append({'value': val, 'orientation': 'h', 'coords': coords})\n            else:\n                c += 1\n\n    # Find vertical segments\n    for c in range(width):\n        r = 0\n        while r < height:\n            if grid[r, c] != 0:\n                val = grid[r, c]\n                start_r = r\n                while r < height and grid[r, c] == val:\n                    r += 1\n                end_r = r - 1\n                if end_r > start_r: # Length >= 2\n                    coords = [(rr, c) for rr in range(start_r, end_r + 1)]\n                    segments.append({'value': val, 'orientation': 'v', 'coords': coords})\n            else:\n                r += 1\n                \n    # Handle single non-zero cells - they can also extend if conditions met\n    # No, the examples show extension only from segments of length > 1. train_4: 8 is length 3, 9 is length 3. train_1: 1 is length 5, 2 is length 3. train_2: 6 is length 2, 3 is length 5. train_3: 4 is length 3, 7 is length 2.\n    # So, the length >= 2 logic seems correct based on examples.\n\n    return segments\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on extending line segments.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n    output_grid = copy.deepcopy(grid_np)\n    height, width = grid_np.shape\n\n    # Identify all maximal horizontal and vertical segments of length >= 2\n    segments = _identify_segments(grid_np)\n\n    # Iterate through each segment and check for extensions from its endpoints\n    for segment in segments:\n        value = segment['value']\n        orientation = segment['orientation']\n        coords = segment['coords']\n        \n        # Sort coordinates to easily find endpoints\n        coords.sort()\n        start_coord = coords[0]\n        end_coord = coords[-1]\n\n        # Check extension from the 'start' endpoint (left for 'h', top for 'v')\n        zeros_path_start = []\n        blocked_start = False\n        if orientation == 'h':\n            r, c = start_coord\n            next_c = c - 1\n            while next_c >= 0 and output_grid[r, next_c] == 0: # Check output grid for zeros\n                zeros_path_start.append((r, next_c))\n                next_c -= 1\n            if next_c >= 0 and output_grid[r, next_c] != 0: # Check for blocking non-zero in output grid\n                blocked_start = True\n        else: # orientation == 'v'\n            r, c = start_coord\n            next_r = r - 1\n            while next_r >= 0 and output_grid[next_r, c] == 0:\n                zeros_path_start.append((next_r, c))\n                next_r -= 1\n            if next_r >= 0 and output_grid[next_r, c] != 0:\n                blocked_start = True\n\n        # Fill path if blocked\n        if blocked_start and zeros_path_start:\n             # Fill in reverse order of finding to apply correctly if segments cross paths\n            for rz, cz in reversed(zeros_path_start):\n                 output_grid[rz, cz] = value\n\n        # Check extension from the 'end' endpoint (right for 'h', bottom for 'v')\n        zeros_path_end = []\n        blocked_end = False\n        if orientation == 'h':\n            r, c = end_coord\n            next_c = c + 1\n            while next_c < width and output_grid[r, next_c] == 0:\n                zeros_path_end.append((r, next_c))\n                next_c += 1\n            if next_c < width and output_grid[r, next_c] != 0:\n                blocked_end = True\n        else: # orientation == 'v'\n            r, c = end_coord\n            next_r = r + 1\n            while next_r < height and output_grid[next_r, c] == 0:\n                zeros_path_end.append((next_r, c))\n                next_r += 1\n            if next_r < height and output_grid[next_r, c] != 0:\n                blocked_end = True\n                \n        # Fill path if blocked\n        if blocked_end and zeros_path_end:\n            for rz, cz in zeros_path_end: # Fill in order found\n                 output_grid[rz, cz] = value\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2151,
    "candidates_token_count": 2263,
    "total_token_count": 4414,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.621151,
  "retries": 1
}