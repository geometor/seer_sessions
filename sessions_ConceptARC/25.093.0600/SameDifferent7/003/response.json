{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the properties of connected components (blobs) of non-zero digits.\n\n1. Identifies connected components (blobs) of non-zero digits using 8-directional connectivity.\n2. For each blob, determines the unique non-zero digits (colors) it contains.\n3. Filters for blobs containing exactly two distinct non-zero colors.\n4. For these two-color blobs, identifies the 'outer color' (adjacent to background '0' cells) and the 'inner color'. A blob is ignored if both or neither of its colors are adjacent to the background.\n5. Identifies cells within the blob that contain the 'inner color'.\n6. Filters these 'inner color' cells, keeping only those whose 8 neighbors are all within the grid and contain either the 'inner color' or the 'outer color' (i.e., belong to the same blob).\n7. Constructs the output grid containing only the surviving 'inner color' cells, with all other cells set to '0'.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists or numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    H, W = input_array.shape\n    \n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_array)\n\n    # Define the connectivity structure for 8 directions (Moore neighborhood)\n    structure = np.ones((3, 3), dtype=bool)\n\n    # Find connected components (blobs) of non-zero cells\n    # labeled_array contains the blob ID for each cell, num_features is the count of blobs\n    labeled_array, num_features = label(input_array > 0, structure=structure)\n\n    # Iterate through each found blob (labels are 1-based)\n    for i in range(1, num_features + 1):\n        # Create a mask for the current blob\n        blob_mask = (labeled_array == i)\n        \n        # Get the coordinates of the cells in the current blob\n        blob_coords = np.argwhere(blob_mask)\n        \n        # Get the values (colors) of the cells in the current blob\n        blob_values = input_array[blob_mask]\n        \n        # Find the unique non-zero colors in the blob\n        unique_colors = np.unique(blob_values[blob_values > 0])\n\n        # --- Filter for blobs with exactly two colors ---\n        if len(unique_colors) != 2:\n            continue # Ignore blobs that don't have exactly two colors\n\n        color1, color2 = unique_colors\n\n        # --- Identify Inner and Outer Colors based on adjacency to background (0) ---\n        c1_adj_0 = False\n        c2_adj_0 = False\n        \n        # Check adjacency to background (0) or grid edge for each color\n        for r, c in blob_coords:\n            val = input_array[r, c]\n            is_c1 = (val == color1)\n            is_c2 = (val == color2)\n            \n            # If we already found both adjacent, no need to check more coords for this blob\n            if c1_adj_0 and c2_adj_0:\n                break\n\n            # Check 8 neighbors\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0: continue\n                    nr, nc = r + dr, c + dc\n                    \n                    neighbor_is_0_or_edge = False\n                    # If neighbor is out of bounds, it's adjacent to 'outside' (like 0)\n                    if not (0 <= nr < H and 0 <= nc < W):\n                         neighbor_is_0_or_edge = True\n                    # If neighbor is inside bounds and is 0\n                    elif input_array[nr, nc] == 0:\n                         neighbor_is_0_or_edge = True\n\n                    if neighbor_is_0_or_edge:\n                         if is_c1: c1_adj_0 = True\n                         if is_c2: c2_adj_0 = True\n                         # Optimization: if both found adjacent to 0 while checking neighbors of a single cell, break neighbor loop\n                         if c1_adj_0 and c2_adj_0:\n                             break \n            # Optimization: if both found adjacent to 0, break coordinate loop\n            if c1_adj_0 and c2_adj_0:\n                break \n\n\n        # Determine outer and inner based on adjacency to 0\n        # If both or neither touch 0, the blob structure is ambiguous or doesn't fit the rule\n        # So, discard the blob (skip to next blob).\n        if c1_adj_0 == c2_adj_0: \n            continue \n\n        C_outer = color1 if c1_adj_0 else color2\n        C_inner = color2 if c1_adj_0 else color1\n\n        # --- Filter Inner Color Cells based on Neighborhood ---\n        # Iterate through the cells of the current blob again\n        for r, c in blob_coords:\n            # Consider only cells with the inner color\n            if input_array[r, c] == C_inner:\n                is_fully_surrounded_by_blob = True\n                # Check all 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0: continue\n                        nr, nc = r + dr, c + dc\n\n                        # Check if neighbor is within grid bounds\n                        if not (0 <= nr < H and 0 <= nc < W):\n                            is_fully_surrounded_by_blob = False\n                            break # Neighbor is outside grid, so not surrounded\n\n                        # Check if neighbor belongs to the same blob (has C_inner or C_outer color)\n                        # Use labeled_array for robust check of blob membership\n                        if labeled_array[nr, nc] != i: \n                            # We only need to check the value if the neighbor is not part of the *current* blob\n                            # If it's part of the current blob (labeled_array[nr, nc] == i), it must have C_inner or C_outer by definition.\n                            # However, checking the value directly is also fine and potentially clearer.\n                            neighbor_val = input_array[nr, nc]\n                            if neighbor_val != C_inner and neighbor_val != C_outer:\n                                # Actually, the check should be if the neighbour belongs to the same blob *label*\n                                # Because a neighbour might be 0, which is neither C_inner nor C_outer\n                                is_fully_surrounded_by_blob = False\n                                break # Neighbor is not part of the blob colors\n\n\n                # If all neighbors passed the checks, keep this inner cell in the output\n                if is_fully_surrounded_by_blob:\n                    output_grid[r, c] = C_inner\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13331,
    "candidates_token_count": 1683,
    "total_token_count": 15014,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.352888,
  "retries": 1
}