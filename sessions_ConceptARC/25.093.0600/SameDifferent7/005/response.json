{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on identifying local color interfaces and checking neighborhood conditions.\n\n1.  Identifies \"interface pairs\" (Inner Color, Outer Color) by examining adjacent cells with different non-zero colors.\n2.  An interface pair is valid only if exactly one of the two colors is locally adjacent (within its own 8 neighbors) to a background cell (0) or the grid edge. The color adjacent to 0/edge is the Outer Color, the other is the Inner Color.\n3.  A map stores all potential Outer Colors associated with each Inner Color found.\n4.  Iterates through the grid again. For each cell containing a potential Inner Color:\n5.  Checks against each associated Outer Color if the cell is \"fully surrounded\".\n6.  \"Fully surrounded\" means all 8 neighbors are within the grid bounds and have a color equal to either the specific Inner Color or the specific Outer Color being checked.\n7.  If a cell is found to be fully surrounded by any of its valid (Inner, Outer) pairs, its Inner Color is placed in the output grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\n\ndef is_adjacent_to_zero(r, c, H, W, input_array):\n    \"\"\"Checks if cell (r, c) has a neighbor that is 0 or is on the grid edge.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is out of bounds (adjacent to edge)\n            if not (0 <= nr < H and 0 <= nc < W):\n                return True\n            # Check if neighbor is background color 0\n            if input_array[nr, nc] == 0:\n                return True\n    return False\n\ndef is_fully_surrounded(r, c, C_inner, C_outer, H, W, input_array):\n    \"\"\"Checks if cell (r, c) is fully surrounded by C_inner or C_outer colors.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is out of bounds\n            if not (0 <= nr < H and 0 <= nc < W):\n                return False # Cannot be fully surrounded if a neighbor is outside\n            \n            neighbor_val = input_array[nr, nc]\n            # Check if neighbor color is valid (must be C_inner or C_outer)\n            if neighbor_val != C_inner and neighbor_val != C_outer:\n                return False\n    return True\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described interface-based transformation rule.\n    \n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    H, W = input_array.shape\n    \n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_array)\n\n    # Map to store potential outer colors for each inner color\n    # Key: inner_color, Value: set of potential outer_colors\n    inner_to_outer_map = defaultdict(set)\n\n    # --- First Pass: Identify potential (Inner, Outer) pairs from interfaces ---\n    for r in range(H):\n        for c in range(W):\n            v1 = input_array[r, c]\n            if v1 == 0:\n                continue # Skip background cells\n\n            # Check adjacency of v1 to zero/edge once per cell v1\n            v1_adj_0 = is_adjacent_to_zero(r, c, H, W, input_array)\n\n            # Check neighbors of v1\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n\n                    # Ensure neighbor is within bounds\n                    if not (0 <= nr < H and 0 <= nc < W):\n                        continue\n                        \n                    v2 = input_array[nr, nc]\n                    # Consider only adjacent pairs of different non-zero colors\n                    if v2 == 0 or v1 == v2:\n                        continue\n\n                    # Check adjacency of v2 to zero/edge\n                    # Note: This check is somewhat redundant as we iterate through all cells,\n                    # but doing it here clarifies the local interface condition.\n                    v2_adj_0 = is_adjacent_to_zero(nr, nc, H, W, input_array)\n\n                    # Determine if this pair forms a valid interface\n                    if v1_adj_0 and not v2_adj_0:\n                        # v1 is outer, v2 is inner\n                        inner_to_outer_map[v2].add(v1)\n                    elif v2_adj_0 and not v1_adj_0:\n                        # v2 is outer, v1 is inner\n                        inner_to_outer_map[v1].add(v2)\n                    # If both or neither are adjacent to zero, it's not a valid interface pair for this rule\n\n    # --- Second Pass: Filter cells based on the surrounding condition ---\n    for r in range(H):\n        for c in range(W):\n            C_inner = input_array[r, c]\n            \n            # Skip background or cells never identified as potential inner colors\n            if C_inner == 0 or C_inner not in inner_to_outer_map:\n                continue\n\n            possible_outers = inner_to_outer_map[C_inner]\n            \n            # Check against each potential outer color if the cell is surrounded\n            for C_outer in possible_outers:\n                if is_fully_surrounded(r, c, C_inner, C_outer, H, W, input_array):\n                    # If surrounded by this pair, keep the inner color and stop checking other pairs\n                    output_grid[r, c] = C_inner\n                    break \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24559,
    "candidates_token_count": 1460,
    "total_token_count": 26019,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.092882,
  "retries": 1
}