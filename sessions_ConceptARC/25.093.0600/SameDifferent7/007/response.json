{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the properties of connected components (blobs) of non-zero digits.\n\n1. Identifies connected components (blobs) of non-zero digits using 8-directional connectivity.\n2. For each blob, determines the unique non-zero digits (colors) it contains.\n3. Filters for blobs containing exactly two distinct non-zero colors.\n4. For these two-color blobs, identifies the 'outer color' (at least one cell of this color is adjacent to a background '0' cell or the grid edge) and the 'inner color' (no cell of this color is adjacent to '0' or edge). Blobs where both or neither color touch the border/background are ignored.\n5. Identifies cells within the blob that contain the 'inner color'.\n6. Filters these 'inner color' cells, keeping only those whose 8 neighbors are all within the grid and contain either the 'inner color' or the 'outer color' (i.e., belong to the same blob).\n7. Constructs the output grid containing only the surviving 'inner color' cells, with all other cells set to '0'.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef _touches_border_or_zero(r, c, H, W, input_array):\n    \"\"\"Checks if cell (r, c) has an 8-neighbor that is 0 or is outside the grid.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is out of bounds (adjacent to edge)\n            if not (0 <= nr < H and 0 <= nc < W):\n                return True\n            # Check if neighbor is background color 0\n            if input_array[nr, nc] == 0:\n                return True\n    return False\n\ndef _is_fully_surrounded_by_blob(r, c, C_inner, C_outer, H, W, input_array):\n    \"\"\"Checks if cell (r, c) with C_inner is fully surrounded by C_inner or C_outer colors.\"\"\"\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            # Check if neighbor is out of bounds - if so, not fully surrounded\n            if not (0 <= nr < H and 0 <= nc < W):\n                return False \n            \n            neighbor_val = input_array[nr, nc]\n            # Check if neighbor color is valid (must be C_inner or C_outer)\n            if neighbor_val != C_inner and neighbor_val != C_outer:\n                return False\n    # If all neighbors were checked and were valid (in bounds and C_inner/C_outer)\n    return True\n\ndef transform(input_grid):\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    H, W = input_array.shape\n    \n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_array)\n\n    # Define the connectivity structure for 8 directions (Moore neighborhood)\n    structure = np.ones((3, 3), dtype=bool)\n\n    # Find connected components (blobs) of non-zero cells\n    # labeled_array assigns a unique integer ID to each blob\n    # num_features is the total count of blobs found (including background if not excluded)\n    labeled_array, num_features = label(input_array > 0, structure=structure)\n\n    # Iterate through each found blob (labels are 1-based)\n    for blob_idx in range(1, num_features + 1):\n        # Create a boolean mask for the cells belonging to the current blob\n        blob_mask = (labeled_array == blob_idx)\n        \n        # Get the coordinates of the cells in the current blob\n        blob_coords = np.argwhere(blob_mask)\n        \n        # Get the values (colors) of the cells in the current blob\n        blob_values = input_array[blob_mask]\n        \n        # Find the unique non-zero colors present within the blob\n        unique_colors = np.unique(blob_values[blob_values > 0])\n\n        # --- Filter for blobs containing exactly two distinct non-zero colors ---\n        if len(unique_colors) != 2:\n            continue # Skip blobs that don't meet this criterion\n\n        c1, c2 = unique_colors\n        c1_touches_border = False\n        c2_touches_border = False\n\n        # --- Determine if c1 or c2 touches border/zero anywhere in the blob ---\n        for r, c in blob_coords:\n            val = input_array[r, c]\n            # Check if this specific cell touches border/zero\n            if _touches_border_or_zero(r, c, H, W, input_array):\n                if val == c1:\n                    c1_touches_border = True\n                elif val == c2:\n                    c2_touches_border = True\n            \n            # Optimization: If we've found both touch, no need to check further cells in this blob\n            if c1_touches_border and c2_touches_border:\n                break\n        \n        # --- Determine Outer and Inner colors ---\n        # The rule requires exactly one color touching the border/zero\n        if c1_touches_border == c2_touches_border: \n            # If both touch OR neither touches, ignore this blob\n            continue \n\n        # Assign Outer and Inner based on the border-touching check\n        C_outer = c1 if c1_touches_border else c2\n        C_inner = c2 if c1_touches_border else c1\n\n        # --- Filter Inner Color Cells based on Full Surrounding ---\n        # Iterate through the blob cells again\n        for r, c in blob_coords:\n            # Focus only on cells that have the Inner color\n            if input_array[r, c] == C_inner:\n                # Check if this inner cell is fully surrounded by blob colors (Inner or Outer)\n                if _is_fully_surrounded_by_blob(r, c, C_inner, C_outer, H, W, input_array):\n                    # If it is, place its color in the corresponding output grid cell\n                    output_grid[r, c] = C_inner\n\n    return output_grid.tolist() # Return as list of lists as per standard format\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16675,
    "candidates_token_count": 1538,
    "total_token_count": 18213,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.021702,
  "retries": 1
}