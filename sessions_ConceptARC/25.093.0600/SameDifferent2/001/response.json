{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule operates on a 2D grid of integers (colors). It identifies connected components (objects) of the same non-zero color and selectively removes some objects based on their color, their neighbors, and whether the grid contains single or multiple distinct colors.\n\n1.  **Object Identification:** Find all connected components (objects) of the same non-zero color using 4-connectivity (up, down, left, right).\n2.  **Color Analysis:** Determine the set of unique non-zero colors present in the grid.\n3.  **Conditional Logic:**\n    *   **Single-Color Case:** If only one non-zero color exists in the grid:\n        *   An object is REMOVED if it does NOT touch any of the grid boundaries (top, bottom, left, or right edge).\n        *   Objects touching the boundary are KEPT.\n    *   **Multi-Color Case:** If more than one non-zero color exists:\n        *   **Neighbor Identification:** For each object, identify all neighboring objects (objects of different colors that share at least one edge).\n        *   **Interaction Rules:** Apply specific removal rules based on pairs of interacting colors:\n            *   If an object of color 7 touches an object of color 1, the color 7 object is marked for removal.\n            *   If an object of color 1 touches an object of color 8, the color 1 object is marked for removal.\n            *   If an object of color 3 touches an object of color 2, the color 3 object is marked for removal.\n            *   (Note: These interactions are checked for all pairs. An object might be marked multiple times but is removed only once).\n        *   **Special Rule for Color 1:** After applying interaction rules, check every object of color 1:\n            *   If a color 1 object has NO neighbors OR only neighbors of color 1, it is marked for removal. This rule applies even if it wasn't marked by the interaction rules.\n4.  **Output Generation:** Create a copy of the input grid. For every object marked for removal, set all its corresponding pixels in the output grid to 0.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"Finds all connected components (objects) in the grid.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_map = np.zeros_like(grid, dtype=int) # Map pixel to object index + 1\n    \n    object_index = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    coords.append((row, col))\n                    object_id_map[row, col] = object_index + 1 # Store object index + 1\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'id': object_index, 'color': color, 'coords': coords})\n                object_index += 1\n                \n    return objects, object_id_map\n\ndef get_neighbors(grid, objects, object_id_map):\n    \"\"\"Finds neighbors for each object.\"\"\"\n    rows, cols = grid.shape\n    neighbors = {obj['id']: set() for obj in objects} # Stores neighbor object ids\n    neighbor_colors = {obj['id']: set() for obj in objects} # Stores neighbor colors\n\n    for obj in objects:\n        obj_id = obj['id']\n        obj_color = obj['color']\n        \n        for r, c in obj['coords']:\n            # Check adjacent cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_val = grid[nr, nc]\n                    if neighbor_val != 0 and neighbor_val != obj_color:\n                        neighbor_obj_id = object_id_map[nr, nc] - 1 # Get neighbor object index\n                        if neighbor_obj_id != obj_id and neighbor_obj_id >= 0 : # Ensure it's a valid, different object\n                           neighbors[obj_id].add(neighbor_obj_id)\n                           neighbor_colors[obj_id].add(grid[nr,nc]) # store color of neighbour\n\n    # Add neighbor colors info to the objects list\n    for obj in objects:\n        obj['neighbor_ids'] = neighbors[obj['id']]\n        obj['neighbor_colors'] = neighbor_colors[obj['id']]\n        # Get the actual colors of the neighbor objects\n        #obj['neighbor_colors'] = {objects[nid]['color'] for nid in neighbors[obj['id']]}\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    \n    # 1. Find Objects\n    objects, object_id_map = find_objects(grid)\n    if not objects:\n        return grid.tolist() # Return original if no objects\n\n    # 2. Color Analysis\n    unique_colors = set(obj['color'] for obj in objects)\n    num_unique_colors = len(unique_colors)\n\n    # 3. Initialize Removal Set\n    objects_to_remove = set() # Store ids of objects to remove\n\n    # Add neighbor information to objects\n    objects = get_neighbors(grid, objects, object_id_map)\n\n    # 4. Conditional Logic\n    if num_unique_colors == 1:\n        # Single-Color Case\n        for obj in objects:\n            touches_boundary = False\n            for r, c in obj['coords']:\n                if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                    touches_boundary = True\n                    break\n            if not touches_boundary:\n                objects_to_remove.add(obj['id'])\n    else:\n        # Multi-Color Case\n        \n        # Apply Interaction Rules\n        processed_interactions = set() # To avoid processing A-B and B-A separately for removal logic\n        for obj_A in objects:\n            obj_A_id = obj_A['id']\n            obj_A_color = obj_A['color']\n            \n            for neighbor_id in obj_A['neighbor_ids']:\n                obj_B = objects[neighbor_id] # Find the neighbor object\n                obj_B_color = obj_B['color']\n                \n                # Ensure we process each pair once and colors are different\n                interaction_pair = tuple(sorted((obj_A_id, neighbor_id)))\n                if interaction_pair in processed_interactions:\n                    continue\n                processed_interactions.add(interaction_pair)\n\n                colors_involved = {obj_A_color, obj_B_color}\n\n                # Rule: 7 touches 1 -> remove 7\n                if colors_involved == {1, 7}:\n                    if obj_A_color == 7: objects_to_remove.add(obj_A_id)\n                    if obj_B_color == 7: objects_to_remove.add(neighbor_id)\n                        \n                # Rule: 1 touches 8 -> remove 1\n                if colors_involved == {1, 8}:\n                    if obj_A_color == 1: objects_to_remove.add(obj_A_id)\n                    if obj_B_color == 1: objects_to_remove.add(neighbor_id)\n\n                # Rule: 3 touches 2 -> remove 3\n                if colors_involved == {2, 3}:\n                    if obj_A_color == 3: objects_to_remove.add(obj_A_id)\n                    if obj_B_color == 3: objects_to_remove.add(neighbor_id)\n\n        # Apply Special Rule for Color 1\n        for obj in objects:\n            if obj['color'] == 1:\n                # Check if it touches any non-1 color\n                touches_non_1 = any(nc != 1 for nc in obj['neighbor_colors'])\n                # Remove if it does NOT touch any non-1 color (i.e., isolated or only touches other 1s)\n                if not touches_non_1:\n                     objects_to_remove.add(obj['id'])\n\n\n    # 5. Construct Output\n    output_grid = np.copy(grid)\n    for obj_id in objects_to_remove:\n        # Find the object with this id (could optimize with a dict lookup)\n        obj_to_remove = next((obj for obj in objects if obj['id'] == obj_id), None)\n        if obj_to_remove:\n            for r, c in obj_to_remove['coords']:\n                output_grid[r, c] = 0\n                \n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2501,
    "candidates_token_count": 2242,
    "total_token_count": 4743,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 130.78904,
  "retries": 2
}