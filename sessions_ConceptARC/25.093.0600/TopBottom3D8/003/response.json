{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying a single vertical line and one or more\nhorizontal lines based on the most frequent non-zero digit in their respective\ncolumns/rows. At each intersection point between the vertical line and a\nhorizontal line, the value at that point in the input grid is swapped:\nif the intersection point initially holds the dominant value of the horizontal line,\nit's replaced with the dominant value of the vertical line in the output grid, and\nvice-versa. All other grid points remain unchanged.\n\"\"\"\n\nimport numpy as np\nimport copy\nfrom collections import Counter\n\ndef _find_dominant_line(data, axis, min_count=3):\n    \"\"\"\n    Finds the index and dominant non-zero value of the 'best' line along a given axis.\n\n    Args:\n        data (np.ndarray): The input grid.\n        axis (int): 0 for columns (vertical lines), 1 for rows (horizontal lines).\n        min_count (int): Minimum occurrences for the dominant non-zero value\n                         to be considered a line.\n\n    Returns:\n        tuple: (index, dominant_value) for the best line found, or (None, None)\n               if no line meets the criteria.\n               For axis=0 (vertical), index is column index.\n               For axis=1 (horizontal), index is row index.\n    \"\"\"\n    num_lines = data.shape[1] if axis == 0 else data.shape[0]\n    best_line_index = None\n    best_line_value = None\n    max_freq = -1\n\n    for i in range(num_lines):\n        line_data = data[:, i] if axis == 0 else data[i, :]\n        non_zeros = line_data[line_data != 0]\n\n        if len(non_zeros) >= min_count: # Only consider lines with enough non-zeros\n            count = Counter(non_zeros)\n            if count: # Check if there are any non-zero elements counted\n                dominant_value, freq = count.most_common(1)[0]\n                # Check if this line is better than the current best\n                # Criteria: Higher frequency of dominant value.\n                # We only need the *single* best vertical line.\n                if freq >= min_count and freq > max_freq:\n                    max_freq = freq\n                    best_line_index = i\n                    best_line_value = dominant_value\n\n    return best_line_index, best_line_value\n\ndef _find_all_lines(data, axis, min_count=3):\n    \"\"\"\n    Finds all lines along a given axis that meet the criteria.\n\n    Args:\n        data (np.ndarray): The input grid.\n        axis (int): 0 for columns (vertical lines), 1 for rows (horizontal lines).\n        min_count (int): Minimum occurrences for the dominant non-zero value\n                         to be considered a line.\n\n    Returns:\n        list: A list of tuples (index, dominant_value) for all lines found.\n              For axis=0 (vertical), index is column index.\n              For axis=1 (horizontal), index is row index.\n    \"\"\"\n    num_lines = data.shape[1] if axis == 0 else data.shape[0]\n    lines_found = []\n\n    for i in range(num_lines):\n        line_data = data[:, i] if axis == 0 else data[i, :]\n        non_zeros = line_data[line_data != 0]\n\n        if len(non_zeros) >= min_count: # Basic check for sufficient non-zeros\n            count = Counter(non_zeros)\n            if count: # Check if there are any non-zero elements counted\n                dominant_value, freq = count.most_common(1)[0]\n                if freq >= min_count:\n                    lines_found.append((i, dominant_value))\n\n    return lines_found\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the intersection swap transformation to the input grid based on\n    dominant line values.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n\n    Returns:\n        list of lists: A new 2D list with the transformation applied.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n\n    # Determine minimum count threshold (e.g., half the dimension size)\n    min_line_elements = max(3, rows // 2) # Heuristic threshold\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid_np)\n\n    # Find the single vertical line properties (column index, dominant value)\n    # Assume exactly one based on problem description\n    col_v, val_v = _find_dominant_line(input_grid_np, axis=0, min_count=min_line_elements)\n\n    # Find all horizontal lines properties (list of (row index, dominant value))\n    horizontal_lines = _find_all_lines(input_grid_np, axis=1, min_count=min_line_elements)\n\n    # If no vertical line found, return the original grid\n    if col_v is None:\n        return output_grid.tolist()\n\n    # Iterate through each identified horizontal line\n    for row_h, val_h in horizontal_lines:\n        # Determine the intersection point coordinates\n        intersection_row = row_h\n        intersection_col = col_v\n\n        # Get the value at the intersection point in the *input* grid\n        input_val = input_grid_np[intersection_row, intersection_col]\n\n        # Apply the swap logic only if the intersection point is non-zero\n        if input_val != 0:\n            if input_val == val_h:\n                # If input is horizontal dominant value, output becomes vertical dominant value\n                output_grid[intersection_row, intersection_col] = val_v\n            elif input_val == val_v:\n                # If input is vertical dominant value, output becomes horizontal dominant value\n                output_grid[intersection_row, intersection_col] = val_h\n            # If input_val is non-zero but matches neither dominant value,\n            # it remains unchanged (due to the initial deep copy).\n\n    # Convert back to list of lists before returning\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8151,
    "candidates_token_count": 1476,
    "total_token_count": 9627,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.733286,
  "retries": 1
}