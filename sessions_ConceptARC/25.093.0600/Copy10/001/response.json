{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a composite object (an outer shape enclosing an inner shape of a different color) in the input grid.\nDuplicates this object and places the copy adjacent to the original.\nThe gap between the original and the copy is determined by the color of the inner shape.\nThe placement direction (right or below) depends on the object's aspect ratio (width vs. height).\nAll other objects in the input are discarded. The output grid size is adjusted to fit the original and the copy.\n\nWorkflow:\n1. Find all connected components (objects) of non-zero cells in the input grid.\n2. Identify the 'target' object: the one whose bounding box contains exactly two distinct non-zero colors.\n3. Determine the properties of the target object: bounding box, width, height, and the two colors.\n4. Identify the 'inner' color (the minimum of the two non-zero colors).\n5. Calculate the gap size between the original and copy (gap = inner_color).\n6. Determine the placement direction: 'right' if width >= height, 'below' otherwise.\n7. Calculate the top-left coordinates for the copied object based on direction and gap.\n8. Extract the pattern (subgrid) of the target object from the input.\n9. Determine the required dimensions for the output grid to hold the original and the copy.\n10. Create the output grid, initialized with zeros.\n11. Place the original object pattern into the output grid.\n12. Place the copied object pattern into the output grid at the calculated position.\n13. Return the output grid.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components of non-zero cells.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                component_cells = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_cells.add((nr, nc))\n                components.append(component_cells)\n    return components\n\ndef get_bounding_box(component_cells):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a component.\"\"\"\n    if not component_cells:\n        return None\n    min_r = min(r for r, c in component_cells)\n    min_c = min(c for r, c in component_cells)\n    max_r = max(r for r, c in component_cells)\n    max_c = max(c for r, c in component_cells)\n    return min_r, min_c, max_r, max_c\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid according to the specified object duplication rule.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n\n    # 1. Find all connected components\n    components = find_connected_components(input_grid)\n\n    target_object_info = None\n\n    # 2. Identify the 'target' object\n    for component in components:\n        if not component: continue\n        bbox = get_bounding_box(component)\n        if bbox is None: continue\n        r1, c1, r2, c2 = bbox\n        \n        # Extract subgrid based on bounding box\n        subgrid = input_grid[r1:r2+1, c1:c2+1]\n        \n        # Find unique non-zero colors within the *bounding box*\n        unique_colors_in_bbox = set(subgrid[subgrid != 0].flatten())\n\n        # Target object has exactly two distinct non-zero colors in its bounding box\n        if len(unique_colors_in_bbox) == 2:\n             width = c2 - c1 + 1\n             height = r2 - r1 + 1\n             target_object_info = {\n                 'bbox': bbox,\n                 'colors': list(unique_colors_in_bbox),\n                 'width': width,\n                 'height': height\n             }\n             break # Assume only one such object\n\n    if target_object_info is None:\n        # Handle cases where no target object is found (e.g., return original or empty)\n        # For this problem, examples suggest a target always exists.\n        # If not, returning the original grid might be a safe default.\n        print(\"Warning: No target object found.\")\n        return input_grid_list \n\n    # 3. Determine properties of the target object\n    bbox = target_object_info['bbox']\n    colors = target_object_info['colors']\n    width = target_object_info['width']\n    height = target_object_info['height']\n    r1, c1, r2, c2 = bbox\n\n    # 4. Identify the 'inner' color (minimum of the two non-zero colors)\n    inner_color = min(colors)\n\n    # 5. Calculate the gap size\n    gap = inner_color\n\n    # 6. Determine placement direction\n    if height > width:\n        placement_direction = 'below'\n    else: # width >= height\n        placement_direction = 'right'\n\n    # 7. Calculate the top-left coordinates for the copy\n    if placement_direction == 'below':\n        r_copy = r2 + 1 + gap\n        c_copy = c1\n        # 9. Determine the required dimensions for the output grid\n        out_rows = r_copy + height\n        out_cols = max(cols, c1 + width) # Ensure width accommodates original\n    else: # placement_direction == 'right'\n        r_copy = r1\n        c_copy = c2 + 1 + gap\n        # 9. Determine the required dimensions for the output grid\n        out_rows = max(rows, r1 + height) # Ensure height accommodates original\n        out_cols = c_copy + width\n\n    # 8. Extract the pattern (subgrid) of the target object\n    object_pattern = input_grid[r1:r2+1, c1:c2+1]\n\n    # 10. Create the output grid, initialized with zeros\n    output_grid = np.zeros((out_rows, out_cols), dtype=int)\n\n    # 11. Place the original object pattern into the output grid\n    output_grid[r1:r1+height, c1:c1+width] = object_pattern\n\n    # 12. Place the copied object pattern into the output grid\n    output_grid[r_copy:r_copy+height, c_copy:c_copy+width] = object_pattern\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3413,
    "candidates_token_count": 1733,
    "total_token_count": 5146,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.802732,
  "retries": 1
}