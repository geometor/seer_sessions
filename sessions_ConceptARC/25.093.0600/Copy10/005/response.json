{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport copy\n\n\"\"\"\nIdentifies a unique composite object in the input grid, characterized by an outer shape of one color (Co) enclosing an inner shape of a different color (Ci).\nAll other objects in the input are discarded.\nThis target object is duplicated, and the copy is placed adjacent to the original.\nThe placement direction (below or right) and the gap size between the original and the copy depend on the object's dimensions (Height H, Width W) and the values of the inner (Ci) and outer (Co) colors according to the following rules:\n\n1.  **Placement Direction:**\n    *   Place BELOW if Height (H) > Width (W) OR if the Outer Color (Co) is exactly twice the Inner Color (Ci) (Co == 2 * Ci).\n    *   Otherwise, place RIGHT.\n\n2.  **Gap Size:**\n    *   If Inner Color (Ci) > Outer Color (Co), Gap = abs(Ci - Co).\n    *   Else if Outer Color (Co) == 2 * Inner Color (Ci), Gap = Height (H).\n    *   Otherwise (Ci <= Co and Co != 2 * Ci), Gap = Inner Color (Ci).\n\nThe output grid size is determined dynamically to accommodate both the original object in its input position and the placed copy.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components of non-zero cells using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                component_cells = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_cells.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_cells.add((nr, nc))\n                \n                if component_cells:\n                    components.append(component_cells)\n    return components\n\ndef get_bounding_box(component_cells):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of cells.\"\"\"\n    if not component_cells:\n        return None\n    min_r = min(r for r, c in component_cells)\n    min_c = min(c for r, c in component_cells)\n    max_r = max(r for r, c in component_cells)\n    max_c = max(c for r, c in component_cells)\n    return min_r, min_c, max_r, max_c\n\ndef identify_inner_outer_colors(subgrid):\n    \"\"\"Identifies the inner (Ci) and outer (Co) colors within a subgrid.\"\"\"\n    height, width = subgrid.shape\n    colors = set(np.unique(subgrid[subgrid != 0]))\n    if len(colors) != 2:\n        return None, None # Should not happen for target object\n\n    outer_color = None\n    # Check boundary pixels of the subgrid\n    boundary_pixels = []\n    if height > 0:\n        boundary_pixels.extend(subgrid[0, :].tolist()) # Top row\n        boundary_pixels.extend(subgrid[height-1, :].tolist()) # Bottom row\n    if width > 0:\n        boundary_pixels.extend(subgrid[:, 0].tolist()) # Left col\n        boundary_pixels.extend(subgrid[:, width-1].tolist()) # Right col\n        \n    for pixel_color in boundary_pixels:\n        if pixel_color in colors:\n            outer_color = pixel_color\n            break\n\n    if outer_color is None:\n         # Fallback or error: If no boundary pixel has one of the two colors,\n         # this indicates an issue or a very thin object.\n         # Let's make an assumption or raise error. Assume the larger color is outer?\n         # Or maybe the color covering more area? Let's stick to boundary for now.\n         # If boundary doesn't work, maybe check corners?\n         # A simpler assumption might be needed if boundary fails.\n         # Let's assume the numerically larger color is outer if boundary fails.\n         # print(\"Warning: Could not determine outer color from boundary pixels. Assuming numerically larger.\")\n         outer_color = max(colors)\n\n\n    inner_color = (colors - {outer_color}).pop()\n    return inner_color, outer_color\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n\n    # 1. Find all connected components\n    components = find_connected_components(input_grid)\n\n    target_object_info = None\n\n    # 2. Identify the 'target' object (composite object with 2 colors)\n    for component in components:\n        if not component: continue\n        \n        bbox = get_bounding_box(component)\n        if bbox is None: continue\n        r1, c1, r2, c2 = bbox\n\n        # Extract subgrid based on the component's bounding box\n        subgrid = input_grid[r1:r2+1, c1:c2+1]\n\n        # Find unique non-zero colors *within the component's bounding box*\n        unique_colors_in_bbox = set(np.unique(subgrid[subgrid != 0]))\n\n        # Target object has exactly two distinct non-zero colors in its bounding box\n        if len(unique_colors_in_bbox) == 2:\n            height = r2 - r1 + 1\n            width = c2 - c1 + 1\n            \n            # 3. Identify Inner (Ci) and Outer (Co) colors\n            Ci, Co = identify_inner_outer_colors(subgrid)\n            if Ci is None or Co is None:\n                continue # Skip if colors couldn't be determined\n\n            target_object_info = {\n                 'bbox': bbox,\n                 'inner_color': Ci,\n                 'outer_color': Co,\n                 'width': width,\n                 'height': height,\n                 'pattern': subgrid\n             }\n            break # Assume only one such object per input\n\n    if target_object_info is None:\n        # If no target object found, return the input unchanged (as per some ARC tasks)\n        # Or handle as an error, depending on expected behavior.\n        # print(\"Warning: No target object found matching criteria.\")\n        return input_grid_list \n\n    # Extract properties for calculation\n    bbox = target_object_info['bbox']\n    Ci = target_object_info['inner_color']\n    Co = target_object_info['outer_color']\n    W = target_object_info['width']\n    H = target_object_info['height']\n    r1, c1, r2, c2 = bbox\n    object_pattern = target_object_info['pattern']\n\n    # 4. Determine Placement Direction\n    place_below = (H > W) or (Co == 2 * Ci)\n\n    # 5. Calculate Gap Size\n    if Ci > Co:\n        gap = abs(Ci - Co)\n    elif Co == 2 * Ci:\n        gap = H\n    else: # Ci <= Co and Co != 2 * Ci\n        gap = Ci\n\n    # 6. Calculate Copy Position\n    if place_below:\n        placement_direction = 'below'\n        copy_r = r2 + 1 + gap\n        copy_c = c1\n    else:\n        placement_direction = 'right'\n        copy_r = r1\n        copy_c = c2 + 1 + gap\n\n    # 7. Calculate Output Grid Size\n    # Max row needed considers original position and copy position\n    required_rows = max(r1 + H, copy_r + H)\n    # Max col needed considers original position and copy position\n    required_cols = max(c1 + W, copy_c + W)\n    \n    # Output grid should be at least as large as input, and large enough for content\n    out_rows = max(rows, required_rows)\n    out_cols = max(cols, required_cols)\n\n    # 8. Construct Output Grid\n    # Initialize with zeros (background color)\n    output_grid = np.zeros((out_rows, out_cols), dtype=int)\n\n    # Place the original target object pattern\n    # Ensure slicing does not go out of bounds of the output grid\n    orig_end_r = min(r1 + H, out_rows)\n    orig_end_c = min(c1 + W, out_cols)\n    output_grid[r1:orig_end_r, c1:orig_end_c] = object_pattern[:orig_end_r-r1, :orig_end_c-c1]\n\n    # Place the copied target object pattern\n    # Ensure slicing does not go out of bounds of the output grid\n    copy_end_r = min(copy_r + H, out_rows)\n    copy_end_c = min(copy_c + W, out_cols)\n    output_grid[copy_r:copy_end_r, copy_c:copy_end_c] = object_pattern[:copy_end_r-copy_r, :copy_end_c-copy_c]\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15896,
    "candidates_token_count": 2333,
    "total_token_count": 18229,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.499396,
  "retries": 1
}