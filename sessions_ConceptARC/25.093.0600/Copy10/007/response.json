{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport copy\n\n\"\"\"\nIdentifies a unique composite object in the input grid, characterized by an outer shape of one color (Co) \nenclosing an inner shape of a different color (Ci). All other objects in the input are discarded.\nThis target object is duplicated, and the copy is placed adjacent to the original.\n\nThe placement direction (below or right) and the gap size between the original and the copy depend \non the object's dimensions (Height H, Width W) and the values of the inner (Ci) and outer (Co) colors \naccording to the following rules:\n\n1.  **Placement Direction:**\n    *   Place BELOW if the Inner Color (Ci) is less than the Outer Color (Co) AND the Outer Color (Co) is an integer multiple of the Inner Color (Ci) (i.e., Co % Ci == 0).\n    *   Otherwise, place RIGHT.\n\n2.  **Gap Size:**\n    *   If Inner Color (Ci) > Outer Color (Co), Gap = abs(Ci - Co).\n    *   Else if Outer Color (Co) == 2 * Inner Color (Ci), Gap = Height (H).\n    *   Otherwise (i.e., Ci <= Co AND (Co != 2*Ci or Co % Ci != 0)), Gap = Inner Color (Ci).\n\nThe output grid size is determined dynamically to accommodate both the original object in its \ninput position and the placed copy, ensuring it's at least as large as the input grid.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components of non-zero cells using BFS.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-zero cell\n            if grid[r, c] != 0 and not visited[r, c]:\n                component_cells = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                component_cells.add((r, c))\n\n                # Perform BFS to find all connected cells of the same object\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds and if the neighbor is non-zero and unvisited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            component_cells.add((nr, nc))\n                \n                # Add the found component (set of cell coordinates) to the list\n                if component_cells:\n                    components.append(component_cells)\n    return components\n\ndef get_bounding_box(component_cells):\n    \"\"\"Calculates the bounding box (min_r, min_c, max_r, max_c) for a set of cells.\"\"\"\n    if not component_cells:\n        return None\n    # Find min/max row and column indices from the component's cells\n    min_r = min(r for r, c in component_cells)\n    min_c = min(c for r, c in component_cells)\n    max_r = max(r for r, c in component_cells)\n    max_c = max(c for r, c in component_cells)\n    return min_r, min_c, max_r, max_c\n\ndef identify_inner_outer_colors(subgrid):\n    \"\"\"\n    Identifies the inner (Ci) and outer (Co) colors within a subgrid representing a composite object.\n    Assumes the subgrid contains exactly two non-zero colors.\n    The outer color is determined by checking the pixels on the boundary of the subgrid.\n    \"\"\"\n    height, width = subgrid.shape\n    # Find the two distinct non-zero colors present\n    colors = set(np.unique(subgrid[subgrid != 0]))\n    if len(colors) != 2:\n        # This function should only be called for subgrids known to have 2 colors\n        return None, None \n\n    outer_color = None\n    # Collect pixels from the boundary of the subgrid\n    boundary_pixels = []\n    if height > 0:\n        boundary_pixels.extend(subgrid[0, :].tolist()) # Top row\n        boundary_pixels.extend(subgrid[height-1, :].tolist()) # Bottom row\n    if width > 0:\n        boundary_pixels.extend(subgrid[:, 0].tolist()) # Left col\n        boundary_pixels.extend(subgrid[:, width-1].tolist()) # Right col\n        \n    # Iterate through boundary pixels to find which of the two colors is the outer one\n    for pixel_color in boundary_pixels:\n        if pixel_color in colors:\n            outer_color = pixel_color\n            break # Found the outer color\n\n    if outer_color is None:\n         # Fallback: if no boundary pixel matches the object colors (e.g., very thin object \n         # or error in logic), assume the numerically larger color is outer. This is a heuristic.\n         outer_color = max(colors)\n\n    # The inner color is the one that's not the outer color\n    inner_color = (colors - {outer_color}).pop()\n    return inner_color, outer_color\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rule to the input grid list.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n\n    # Workflow Step 1: Find all connected components (objects)\n    components = find_connected_components(input_grid)\n\n    target_object_info = None\n\n    # Workflow Step 2: Identify the target composite object\n    for component in components:\n        if not component: continue\n        \n        # Get the bounding box of the current component\n        bbox = get_bounding_box(component)\n        if bbox is None: continue\n        r1, c1, r2, c2 = bbox\n\n        # Extract the subgrid corresponding to the bounding box\n        subgrid = input_grid[r1:r2+1, c1:c2+1]\n\n        # Find unique non-zero colors within this bounding box\n        unique_colors_in_bbox = set(np.unique(subgrid[subgrid != 0]))\n\n        # Check if this is the target object (exactly two non-zero colors)\n        if len(unique_colors_in_bbox) == 2:\n            height = r2 - r1 + 1\n            width = c2 - c1 + 1\n            \n            # Workflow Step 3: Identify Inner (Ci) and Outer (Co) colors\n            Ci, Co = identify_inner_outer_colors(subgrid)\n            if Ci is None or Co is None:\n                 # Skip if colors couldn't be reliably determined\n                continue \n\n            # Store information about the target object\n            target_object_info = {\n                 'bbox': bbox,\n                 'inner_color': Ci,\n                 'outer_color': Co,\n                 'width': width,\n                 'height': height,\n                 'pattern': subgrid\n             }\n            # Assume there's only one target object per input grid\n            break \n\n    # If no target object was found, return the input grid unchanged\n    if target_object_info is None:\n        return input_grid_list \n\n    # Extract properties for calculating placement and gap\n    bbox = target_object_info['bbox']\n    Ci = target_object_info['inner_color']\n    Co = target_object_info['outer_color']\n    W = target_object_info['width']\n    H = target_object_info['height']\n    r1, c1, r2, c2 = bbox\n    object_pattern = target_object_info['pattern']\n\n    # Workflow Step 4: Determine Placement Direction\n    # Place BELOW if Ci < Co AND Co is a multiple of Ci. Otherwise RIGHT.\n    place_below = (Ci < Co) and (Co % Ci == 0)\n\n    # Workflow Step 5: Calculate Gap Size based on the rules\n    if Ci > Co:\n        gap = abs(Ci - Co)\n    elif Co == 2 * Ci: # Check this specific condition before the general Ci <= Co case\n        gap = H\n    else: # Handles the remaining cases where Ci <= Co\n        gap = Ci\n\n    # Workflow Step 6: Calculate Copy Position\n    if place_below:\n        copy_r = r2 + 1 + gap  # Below original, add gap\n        copy_c = c1            # Align horizontally\n    else: # Place Right\n        copy_r = r1            # Align vertically\n        copy_c = c2 + 1 + gap  # Right of original, add gap\n\n    # Workflow Step 7: Calculate Output Grid Size\n    # Determine the maximum row and column needed to fit both original and copy\n    required_rows = max(r1 + H, copy_r + H)\n    required_cols = max(c1 + W, copy_c + W)\n    \n    # Ensure the output grid is at least as large as the input grid dimensions\n    out_rows = max(rows, required_rows)\n    out_cols = max(cols, required_cols)\n\n    # Workflow Step 8: Construct Output Grid\n    # Initialize the output grid with background color (0)\n    output_grid = np.zeros((out_rows, out_cols), dtype=int)\n\n    # Place the original target object pattern into the output grid\n    # Use slicing that respects the calculated output grid boundaries\n    orig_end_r = r1 + H\n    orig_end_c = c1 + W\n    output_grid[r1:orig_end_r, c1:orig_end_c] = object_pattern\n\n    # Place the copied target object pattern into the output grid\n    # Use slicing that respects the calculated output grid boundaries\n    copy_end_r = copy_r + H\n    copy_end_c = copy_c + W\n    output_grid[copy_r:copy_end_r, copy_c:copy_end_c] = object_pattern\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18740,
    "candidates_token_count": 2458,
    "total_token_count": 21198,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.230574,
  "retries": 1
}