{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies connected components (objects) of non-zero cells in the input grid.\nCalculates the area and number of distinct neighboring objects for each object.\nFilters the objects based on two criteria:\n1. Keep objects whose area is equal to the maximum area found among all objects.\n2. Keep objects that touch more than one other distinct object (neighbor count > 1).\nAll other objects are removed (replaced by the background color 0).\nAdjacency for connectivity within an object is horizontal/vertical.\nAdjacency for determining neighbors between objects includes diagonals.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components (objects) of the same non-zero color in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A tuple containing:\n        - objects: A list of dictionaries, where each dictionary represents an object\n                   with keys 'id', 'color', 'area', and 'coords' (a set of (r, c) tuples).\n        - object_map: A dictionary mapping cell coordinates (r, c) to the object ID they belong to.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    object_map = {}\n    object_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the cell is non-zero and hasn't been visited yet\n            if grid[r, c] != 0 and (r, c) not in visited:\n                current_color = grid[r, c]\n                current_object_coords = set()\n                q = deque([(r, c)])\n                \n                # Start Breadth-First Search (BFS) for connected cells of the same color\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Check bounds, color match, and visited status\n                    if (0 <= row < rows and 0 <= col < cols and\n                            grid[row, col] == current_color and\n                            (row, col) not in visited):\n                        \n                        visited.add((row, col))\n                        current_object_coords.add((row, col))\n                        \n                        # Add neighbors (horizontal/vertical) to the queue\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = row + dr, col + dc\n                            if (nr, nc) not in visited:\n                                q.append((nr, nc))\n\n                # If an object was found, store its details\n                if current_object_coords:\n                    obj = {\n                        'id': object_id_counter,\n                        'color': current_color,\n                        'area': len(current_object_coords),\n                        'coords': current_object_coords\n                    }\n                    objects.append(obj)\n                    # Map each coordinate in the object to its ID\n                    for coord in current_object_coords:\n                        object_map[coord] = object_id_counter\n                    object_id_counter += 1\n                    \n    return objects, object_map\n\ndef calculate_neighbors(grid, objects, object_map):\n    \"\"\"\n    Calculates the number of distinct neighboring objects for each object.\n    Neighbors are defined by adjacent cells (including diagonals).\n\n    Args:\n        grid: A numpy array representing the input grid.\n        objects: A list of object dictionaries from find_objects.\n        object_map: A dictionary mapping coordinates to object IDs.\n\n    Returns:\n        None. Modifies the objects list in place by adding a 'neighbor_count' key.\n    \"\"\"\n    rows, cols = grid.shape\n    # Define 8 directions for diagonal and cardinal neighbors\n    deltas = [(dr, dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if not (dr == 0 and dc == 0)]\n    \n    neighbors_dict = {obj['id']: set() for obj in objects}\n\n    for obj in objects:\n        obj_id = obj['id']\n        # Iterate through each cell belonging to the current object\n        for r, c in obj['coords']:\n            # Check all 8 neighboring cells\n            for dr, dc in deltas:\n                nr, nc = r + dr, c + dc\n                # Check if the neighbor is within grid bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    # Check if the neighbor cell belongs to any object\n                    if (nr, nc) in object_map:\n                        neighbor_obj_id = object_map[(nr, nc)]\n                        # If the neighbor belongs to a *different* object, add its ID to the set\n                        if neighbor_obj_id != obj_id:\n                            neighbors_dict[obj_id].add(neighbor_obj_id)\n\n    # Add the count of unique neighbors to each object dictionary\n    for obj in objects:\n        obj['neighbor_count'] = len(neighbors_dict[obj['id']])\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters objects in a grid based on their area and number of neighbors.\n\n    Keeps objects if their area is the maximum area found in the grid OR\n    if they have more than one distinct neighboring object.\n    Removes all other objects by setting their cells to 0.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid_np = np.array(input_grid, dtype=int)\n    \n    # Find all objects and their coordinates\n    objects, object_map = find_objects(grid_np)\n\n    # If there are no objects, return the original grid\n    if not objects:\n        return input_grid # Or grid_np.tolist() if input must be list\n\n    # Calculate the maximum area among all objects\n    max_area = 0\n    if objects: # Avoid error if objects list is empty\n        max_area = max(obj['area'] for obj in objects)\n\n    # Calculate the number of neighbors for each object\n    calculate_neighbors(grid_np, objects, object_map)\n\n    # Initialize the output grid as a copy of the input\n    output_grid_np = grid_np.copy()\n\n    # Iterate through each found object\n    for obj in objects:\n        # Check the filtering criteria\n        is_max_area = (obj['area'] == max_area)\n        has_multiple_neighbors = (obj['neighbor_count'] > 1)\n\n        # If the object should NOT be kept (neither max area nor multiple neighbors)\n        if not (is_max_area or has_multiple_neighbors):\n            # Remove the object by setting its cells to 0 in the output grid\n            for r, c in obj['coords']:\n                output_grid_np[r, c] = 0\n\n    # Convert the result back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2937,
    "candidates_token_count": 1631,
    "total_token_count": 4568,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.767646,
  "retries": 1
}