{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify non-zero 'target' cells within an input grid based on their spatial \nposition: target cells are non-zero cells that are not directly adjacent \n(4-way connectivity) to the outermost layer of background (0-valued) cells \nconnected to the grid edges. Count these target cells. Generate an output list \ncontaining the digit '4' for each target cell found. Pad this list with '0's \nat the end until it reaches a fixed length of 7.\n\"\"\"\n\nimport numpy as np\nimport collections\n\ndef _find_outer_background_coords(grid: np.ndarray) -> set:\n    \"\"\"\n    Identifies the coordinates of all background (0) cells connected to the \n    grid edges using Breadth-First Search (BFS).\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A set containing tuples (row, col) of the outer background cells.\n    \"\"\"\n    rows, cols = grid.shape\n    outer_background = set()\n    q = collections.deque()\n    visited = set() # Keep track of visited 0s to avoid cycles and redundant checks\n\n    # Seed the queue with all 0-valued cells on the border\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right edges\n            if grid[r, c] == 0 and (r, c) not in visited:\n                q.append((r, c))\n                visited.add((r, c))\n                outer_background.add((r, c))\n    for c in range(1, cols - 1): # Top and bottom edges (avoid corners)\n        for r in [0, rows - 1]:\n             if grid[r, c] == 0 and (r, c) not in visited:\n                q.append((r, c))\n                visited.add((r, c))\n                outer_background.add((r, c))\n\n    # Perform BFS to find all connected 0s\n    while q:\n        r, c = q.popleft()\n        # Check 4 neighbours (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbour is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbour is a 0 and not visited yet\n                if grid[nr, nc] == 0 and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    outer_background.add((nr, nc))\n                    q.append((nr, nc)) # Add neighbour to the queue\n\n    return outer_background\n\ndef _find_boundary_coords(grid: np.ndarray, outer_background_coords: set) -> set:\n    \"\"\"\n    Identifies the coordinates of all non-zero cells adjacent to the outer \n    background.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        outer_background_coords: A set of coordinates for the outer background cells.\n\n    Returns:\n        A set containing tuples (row, col) of the boundary cells.\n    \"\"\"\n    rows, cols = grid.shape\n    boundary_coords = set()\n\n    # Iterate through all cells in the grid\n    for r in range(rows):\n        for c in range(cols):\n            # Consider only non-zero cells\n            if grid[r, c] != 0:\n                is_boundary = False\n                # Check 4 neighbours\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check if the neighbour is within bounds and is part of the outer background\n                    if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in outer_background_coords:\n                        is_boundary = True\n                        break # Found an outer background neighbor, no need to check further\n                # If it's adjacent to the outer background, add it to the boundary set\n                if is_boundary:\n                    boundary_coords.add((r, c))\n    \n    return boundary_coords\n\ndef _count_target_cells(grid: np.ndarray, boundary_coords: set) -> int:\n    \"\"\"\n    Counts the number of non-zero cells that are not boundary cells.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        boundary_coords: A set of coordinates for the boundary cells.\n\n    Returns:\n        The integer count of target cells.\n    \"\"\"\n    rows, cols = grid.shape\n    target_count = 0\n    # Iterate through all cells\n    for r in range(rows):\n        for c in range(cols):\n            # A cell is a target if it's non-zero AND not in the boundary set\n            if grid[r, c] != 0 and (r, c) not in boundary_coords:\n                target_count += 1\n    return target_count\n\ndef transform(input_grid) -> list:\n    \"\"\"\n    Transforms the input grid into a fixed-length list representing the count \n    of spatially defined 'target' cells.\n    \n    Args:\n        input_grid: A list of lists or numpy array representing the grid.\n\n    Returns:\n        A list of integers (length 7) representing the count of target cells.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid)\n    \n    # Define the fixed length for the output list\n    fixed_output_length = 7\n    output_list = []\n\n    # Step 1: Find coordinates of the outer background (0s connected to edges)\n    outer_background_coords = _find_outer_background_coords(grid)\n\n    # Step 2: Find coordinates of boundary cells (non-zero cells adjacent to outer background)\n    boundary_coords = _find_boundary_coords(grid, outer_background_coords)\n\n    # Step 3: Count target cells (non-zero cells that are not boundary cells)\n    target_cell_count = _count_target_cells(grid, boundary_coords)\n\n    # Step 4: Construct the output list\n    # Add a '4' for each target cell found\n    for _ in range(target_cell_count):\n        if len(output_list) < fixed_output_length: # Avoid exceeding fixed length\n             output_list.append(4)\n        else:\n            break # Stop if max length reached (handles target_count > 7)\n\n    # Pad with '0's until the list reaches the fixed length\n    while len(output_list) < fixed_output_length:\n        output_list.append(0)\n\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14499,
    "candidates_token_count": 1585,
    "total_token_count": 16084,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.065061,
  "retries": 1
}