{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify specific non-zero 'target' cells within a 2D input grid based on their \nspatial relationship to the background and boundary. Target cells are defined as \nnon-zero cells that are not directly adjacent (4-way connectivity) to the \noutermost layer of background (0-valued) cells connected to the grid edges.\nCount these target cells. Produce a fixed-size output sequence (list, length 7) \ncontaining the digit '4' for each identified target cell, followed by padding \n'0's to reach the fixed length. Each digit in the sequence corresponds to a \ndistinct item/line in the final output representation expected by the evaluator.\n\"\"\"\n\nimport numpy as np\nimport collections\n\ndef _find_outer_background_coords(grid: np.ndarray) -> set:\n    \"\"\"\n    Identifies the coordinates of all background (0) cells connected to the \n    grid edges using Breadth-First Search (BFS).\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A set containing tuples (row, col) of the outer background cells.\n    \"\"\"\n    rows, cols = grid.shape\n    outer_background = set()\n    q = collections.deque()\n    visited = set() # Keep track of visited 0s to avoid cycles and redundant checks\n\n    # Seed the queue with all 0-valued cells on the border\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right edges\n            if grid[r, c] == 0 and (r, c) not in visited:\n                q.append((r, c))\n                visited.add((r, c))\n                outer_background.add((r, c))\n    # Use range(cols) instead of range(1, cols-1) to include corners if they are 0\n    for c in range(cols): \n        for r in [0, rows - 1]: # Top and bottom edges\n             if grid[r, c] == 0 and (r, c) not in visited:\n                q.append((r, c))\n                visited.add((r, c))\n                outer_background.add((r, c))\n\n    # Perform BFS to find all connected 0s from the border\n    while q:\n        r, c = q.popleft()\n        # Check 4 neighbours (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check if the neighbour is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if the neighbour is a 0 and not visited yet\n                if grid[nr, nc] == 0 and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    outer_background.add((nr, nc))\n                    q.append((nr, nc)) # Add neighbour to the queue\n\n    return outer_background\n\ndef _find_boundary_coords(grid: np.ndarray, outer_background_coords: set) -> set:\n    \"\"\"\n    Identifies the coordinates of all non-zero cells adjacent (4-way) to the \n    outer background cells.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        outer_background_coords: A set of coordinates for the outer background cells.\n\n    Returns:\n        A set containing tuples (row, col) of the boundary cells.\n    \"\"\"\n    rows, cols = grid.shape\n    boundary_coords = set()\n\n    # Iterate through all cells identified as outer background\n    for r_bg, c_bg in outer_background_coords:\n        # Check 4 neighbours of each outer background cell\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r_bg + dr, c_bg + dc\n            # Check if the neighbour is within bounds and is non-zero\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr, nc] != 0:\n                # If it's a non-zero neighbor of the outer background, it's a boundary cell\n                boundary_coords.add((nr, nc))\n    \n    # Alternative implementation: Iterate through all non-zero cells and check neighbours\n    # for r in range(rows):\n    #     for c in range(cols):\n    #         # Consider only non-zero cells\n    #         if grid[r, c] != 0:\n    #             is_boundary = False\n    #             # Check 4 neighbours\n    #             for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n    #                 nr, nc = r + dr, c + dc\n    #                 # Check if the neighbour is within bounds and is part of the outer background\n    #                 if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in outer_background_coords:\n    #                     is_boundary = True\n    #                     break # Found an outer background neighbor, no need to check further\n    #             # If it's adjacent to the outer background, add it to the boundary set\n    #             if is_boundary:\n    #                 boundary_coords.add((r, c))\n\n    return boundary_coords\n\ndef _count_target_cells(grid: np.ndarray, boundary_coords: set) -> int:\n    \"\"\"\n    Counts the number of non-zero cells that are not boundary cells.\n\n    Args:\n        grid: A numpy array representing the input grid.\n        boundary_coords: A set of coordinates for the boundary cells.\n\n    Returns:\n        The integer count of target cells.\n    \"\"\"\n    rows, cols = grid.shape\n    target_count = 0\n    # Iterate through all cells\n    for r in range(rows):\n        for c in range(cols):\n            # A cell is a target if it's non-zero AND its coordinate is not in the boundary set\n            if grid[r, c] != 0 and (r, c) not in boundary_coords:\n                target_count += 1\n    return target_count\n\ndef transform(input_grid) -> list:\n    \"\"\"\n    Transforms the input grid into a fixed-length list representing the count \n    of spatially defined 'target' cells.\n    \n    Args:\n        input_grid: A list of lists or numpy array representing the grid.\n\n    Returns:\n        A list of integers (length 7) representing the count of target cells, \n        with each target cell represented by a 4, padded with 0s.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid)\n    \n    # Define the fixed length for the output list\n    fixed_output_length = 7\n    \n    # --- Workflow ---\n    \n    # 1. Find coordinates of the outer background (0s connected to edges)\n    outer_background_coords = _find_outer_background_coords(grid)\n\n    # 2. Find coordinates of boundary cells (non-zero cells adjacent to outer background)\n    boundary_coords = _find_boundary_coords(grid, outer_background_coords)\n\n    # 3. Count target cells (non-zero cells that are not boundary cells)\n    target_cell_count = _count_target_cells(grid, boundary_coords)\n\n    # 4. Construct the output list\n    output_list = []\n    \n    # Add a '4' for each target cell found, up to the fixed length\n    num_fours = min(target_cell_count, fixed_output_length)\n    for _ in range(num_fours):\n        output_list.append(4)\n\n    # Pad with '0's until the list reaches the fixed length\n    num_zeros = fixed_output_length - len(output_list)\n    for _ in range(num_zeros):\n        output_list.append(0)\n\n    # Return the final list of 7 integers\n    return output_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12863,
    "candidates_token_count": 1888,
    "total_token_count": 14751,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.864734,
  "retries": 1
}