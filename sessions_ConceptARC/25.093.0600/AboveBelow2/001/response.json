{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentify all distinct connected components (objects) of non-zero cells in the input grid using orthogonal adjacency.\nDetermine which objects touch the top border (row 0).\nIteratively identify objects that are orthogonally adjacent to any object already marked for removal (starting with the top-border objects).\nCreate the output grid by copying the input grid.\nSet the color of all cells belonging to the identified objects (top-touching and their adjacent chains) to 0 in the output grid.\nReturn the modified output grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components of non-zero cells in the grid.\n\n    Args:\n        grid: A numpy array representing the grid.\n\n    Returns:\n        A list of objects, where each object is a list of (row, col) tuples.\n        A dictionary mapping each cell (row, col) to its object index.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    object_map = {} # Maps (r, c) -> object_index\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                current_object_index = len(objects)\n                current_object_cells = []\n                q = collections.deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_cells.append((row, col))\n                    object_map[(row, col)] = current_object_index\n\n                    # Check orthogonal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_object_cells:\n                    objects.append(current_object_cells)\n                    \n    return objects, object_map\n\ndef get_object_adjacency(objects, object_map, grid_shape):\n    \"\"\"\n    Determines which objects are orthogonally adjacent to each other.\n\n    Args:\n        objects: A list of objects (lists of cell coordinates).\n        object_map: A dictionary mapping cell coordinates to object index.\n        grid_shape: Tuple (rows, cols) of the grid.\n\n    Returns:\n        A dictionary where keys are object indices and values are sets of\n        indices of adjacent objects.\n    \"\"\"\n    rows, cols = grid_shape\n    adjacency = collections.defaultdict(set)\n\n    for obj_idx, cells in enumerate(objects):\n        for r, c in cells:\n            # Check orthogonal neighbors\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_coord = (nr, nc)\n                    if neighbor_coord in object_map:\n                        neighbor_obj_idx = object_map[neighbor_coord]\n                        if neighbor_obj_idx != obj_idx:\n                            adjacency[obj_idx].add(neighbor_obj_idx)\n                            # Adjacency is symmetric, but defaultdict handles this\n                            # adjacency[neighbor_obj_idx].add(obj_idx) \n    return adjacency\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by removing objects touching the top border\n    and any objects connected to them via orthogonal adjacency.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_arr = np.array(input_grid, dtype=int)\n    rows, cols = input_arr.shape\n    \n    # Initialize output grid as a copy of the input\n    output_arr = np.copy(input_arr)\n\n    # 1. Identify all distinct connected components (objects)\n    objects, object_map = find_objects(input_arr)\n    if not objects: # Handle empty grid or grid with only 0s\n        return output_arr.tolist()\n\n    # 2. & 3. Identify objects touching the top border\n    objects_to_remove_indices = set()\n    initial_remove_queue = collections.deque()\n\n    for i, obj_cells in enumerate(objects):\n        for r, c in obj_cells:\n            if r == 0:\n                objects_to_remove_indices.add(i)\n                initial_remove_queue.append(i)\n                break # Once one cell touches the top, the whole object is marked\n\n    # 4. Build adjacency map between objects\n    adjacency = get_object_adjacency(objects, object_map, (rows, cols))\n\n    # 5. Iteratively find adjacent objects to remove\n    queue = initial_remove_queue\n    processed_for_neighbors = set(initial_remove_queue) # Keep track of objects whose neighbors we've checked\n\n    while queue:\n        current_obj_idx = queue.popleft()\n        \n        # Find neighbors of the current object\n        for neighbor_idx in adjacency.get(current_obj_idx, set()):\n            # If the neighbor hasn't been marked for removal yet\n            if neighbor_idx not in objects_to_remove_indices:\n                objects_to_remove_indices.add(neighbor_idx)\n                # Add to queue to process its neighbors later\n                if neighbor_idx not in processed_for_neighbors:\n                     queue.append(neighbor_idx)\n                     processed_for_neighbors.add(neighbor_idx)\n\n    # 6. & 7. Modify the output grid: Set cells of removed objects to 0\n    for obj_idx in objects_to_remove_indices:\n        for r, c in objects[obj_idx]:\n            output_arr[r, c] = 0\n\n    # 8. Return the modified grid as a list of lists\n    return output_arr.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4451,
    "candidates_token_count": 1467,
    "total_token_count": 5918,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.045085,
  "retries": 1
}