
## train_1

**input:**
```
0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1
0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1
0 2 2 2 0 0 2 2 2 0 0 0 0 2 2 2 0 0 0 0
0 2 2 2 0 0 2 2 2 0 0 0 0 2 2 2 0 0 0 0
0 2 2 2 0 0 2 2 2 0 0 0 0 2 2 2 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 2 2 2 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
0 0 0 4 4 4 0 0 0 4 4 4 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 2 2 2 0 0
0 0 0 4 4 4 0 0 0 0 0 2 2 2 0 0
0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
0 0 0 0 0 0 2 2 2 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 2 2 2 2
2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 8 8 8 0
0 0 0 8 8 8 0
0 0 0 8 8 8 0
0 0 0 0 0 0 0
0 0 7 7 7 0 0
0 0 7 7 7 0 0
0 0 7 7 7 0 0
0 0 0 0 0 0 0
7 7 7 7 0 8 8
7 7 7 7 0 8 8
0 0 0 0 0 0 0
0 0 0 0 3 3 3
0 0 0 0 3 3 3
0 0 0 0 3 3 3
0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 3 3 3
0 0 0 0 3 3 3
0 0 0 0 3 3 3
0 0 0 0 0 0 0
```

*   **Perception of Task Elements:**
    *   The input and output are grids of numbers (colors), where 0 represents the background.
    *   The input grid contains multiple distinct connected regions (objects) of non-zero numbers.
    *   Objects are defined by connected cells (sharing an edge, i.e., orthogonal connectivity) having non-zero values. An object can sometimes contain cells of different non-zero colors (e.g., train\_3, bottom object).
    *   The transformation involves removing some of these objects, replacing their cells with the background color 0.
    *   The decision to remove an object seems related to its position, specifically its proximity to the top border of the grid. Objects touching the top border are removed. Furthermore, objects directly adjacent (orthogonally) to those touching the top border are also removed. This removal seems contagious; if object A touches the top, it's removed. If object B touches A, B is removed. If object C touches B, C is removed, and so on. Objects that do not touch the top border and are not connected via a chain of adjacency to a top-border-touching object are kept.

*   **YAML Facts:**
    
```yaml
    Grid:
      Type: 2D array of integers
      Background_Color: 0
      Objects:
        Definition: Connected components of non-zero cells (orthogonal connectivity)
        Properties:
          - Cells: List of (row, col) coordinates
          - Colors: Set of non-zero integers present in the object's cells
          - Touches_Top_Border: Boolean (True if any cell has row index 0)
          - Adjacent_Objects: List of other objects sharing an orthogonal edge with this object
    Transformation:
      Action: Conditional Removal of Objects
      Rule:
        1. Identify all objects.
        2. Determine which objects touch the top border.
        3. Iteratively identify objects orthogonally adjacent to objects identified in step 2 or subsequently identified objects.
        4. All objects identified in steps 2 and 3 are marked for removal.
        5. Objects not marked for removal are kept.
      Output: A new grid where cells belonging to removed objects are set to 0, and cells belonging to kept objects retain their original color.
    ```


*   **Natural Language Program:**
    1.  Identify all distinct connected components (objects) of non-zero cells in the input grid using orthogonal adjacency (cells sharing an edge are connected). Treat adjacent non-zero cells as part of the same object, regardless of their specific color.
    2.  Initialize a set of "objects to remove".
    3.  Add all objects that contain at least one cell in the top row (row 0) to the "objects to remove" set.
    4.  Initialize a set of "newly added objects" with the objects identified in step 3.
    5.  While the "newly added objects" set is not empty:
        a.  Create an empty temporary set called "adjacent objects found in this iteration".
        b.  For each object `O1` in the "newly added objects" set:
            i.  Find all other objects `O2` in the grid that are orthogonally adjacent to `O1`.
            ii. For each such adjacent object `O2`, if `O2` is not already in the "objects to remove" set, add `O2` to both the "objects to remove" set and the "adjacent objects found in this iteration" set.
        c.  Update the "newly added objects" set to be the "adjacent objects found in this iteration" set for the next loop.
    6.  Create the output grid, initially identical to the input grid.
    7.  For each object in the final "objects to remove" set, set the color of all cells belonging to that object in the output grid to 0.
    8.  Return the modified output grid.
```python
import numpy as np
import collections

"""
Identify all distinct connected components (objects) of non-zero cells in the input grid using orthogonal adjacency.
Determine which objects touch the top border (row 0).
Iteratively identify objects that are orthogonally adjacent to any object already marked for removal (starting with the top-border objects).
Create the output grid by copying the input grid.
Set the color of all cells belonging to the identified objects (top-touching and their adjacent chains) to 0 in the output grid.
Return the modified output grid.
"""

def find_objects(grid):
    """
    Finds all connected components of non-zero cells in the grid.

    Args:
        grid: A numpy array representing the grid.

    Returns:
        A list of objects, where each object is a list of (row, col) tuples.
        A dictionary mapping each cell (row, col) to its object index.
    """
    rows, cols = grid.shape
    visited = set()
    objects = []
    object_map = {} # Maps (r, c) -> object_index

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != 0 and (r, c) not in visited:
                current_object_index = len(objects)
                current_object_cells = []
                q = collections.deque([(r, c)])
                visited.add((r, c))

                while q:
                    row, col = q.popleft()
                    current_object_cells.append((row, col))
                    object_map[(row, col)] = current_object_index

                    # Check orthogonal neighbors
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           grid[nr, nc] != 0 and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            q.append((nr, nc))
                
                if current_object_cells:
                    objects.append(current_object_cells)
                    
    return objects, object_map

def get_object_adjacency(objects, object_map, grid_shape):
    """
    Determines which objects are orthogonally adjacent to each other.

    Args:
        objects: A list of objects (lists of cell coordinates).
        object_map: A dictionary mapping cell coordinates to object index.
        grid_shape: Tuple (rows, cols) of the grid.

    Returns:
        A dictionary where keys are object indices and values are sets of
        indices of adjacent objects.
    """
    rows, cols = grid_shape
    adjacency = collections.defaultdict(set)

    for obj_idx, cells in enumerate(objects):
        for r, c in cells:
            # Check orthogonal neighbors
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    neighbor_coord = (nr, nc)
                    if neighbor_coord in object_map:
                        neighbor_obj_idx = object_map[neighbor_coord]
                        if neighbor_obj_idx != obj_idx:
                            adjacency[obj_idx].add(neighbor_obj_idx)
                            # Adjacency is symmetric, but defaultdict handles this
                            # adjacency[neighbor_obj_idx].add(obj_idx) 
    return adjacency


def transform(input_grid):
    """
    Transforms the input grid by removing objects touching the top border
    and any objects connected to them via orthogonal adjacency.

    Args:
        input_grid: A list of lists representing the input grid.

    Returns:
        A list of lists representing the transformed grid.
    """
    # Convert input to numpy array for easier processing
    input_arr = np.array(input_grid, dtype=int)
    rows, cols = input_arr.shape
    
    # Initialize output grid as a copy of the input
    output_arr = np.copy(input_arr)

    # 1. Identify all distinct connected components (objects)
    objects, object_map = find_objects(input_arr)
    if not objects: # Handle empty grid or grid with only 0s
        return output_arr.tolist()

    # 2. & 3. Identify objects touching the top border
    objects_to_remove_indices = set()
    initial_remove_queue = collections.deque()

    for i, obj_cells in enumerate(objects):
        for r, c in obj_cells:
            if r == 0:
                objects_to_remove_indices.add(i)
                initial_remove_queue.append(i)
                break # Once one cell touches the top, the whole object is marked

    # 4. Build adjacency map between objects
    adjacency = get_object_adjacency(objects, object_map, (rows, cols))

    # 5. Iteratively find adjacent objects to remove
    queue = initial_remove_queue
    processed_for_neighbors = set(initial_remove_queue) # Keep track of objects whose neighbors we've checked

    while queue:
        current_obj_idx = queue.popleft()
        
        # Find neighbors of the current object
        for neighbor_idx in adjacency.get(current_obj_idx, set()):
            # If the neighbor hasn't been marked for removal yet
            if neighbor_idx not in objects_to_remove_indices:
                objects_to_remove_indices.add(neighbor_idx)
                # Add to queue to process its neighbors later
                if neighbor_idx not in processed_for_neighbors:
                     queue.append(neighbor_idx)
                     processed_for_neighbors.add(neighbor_idx)

    # 6. & 7. Modify the output grid: Set cells of removed objects to 0
    for obj_idx in objects_to_remove_indices:
        for r, c in objects[obj_idx]:
            output_arr[r, c] = 0

    # 8. Return the modified grid as a list of lists
    return output_arr.tolist()
```
