{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThe transformation identifies the dominant color (C) based on the largest contiguous block (S) of a single non-zero color in the input grid. \nThe final output grid is constructed as follows:\n1. Initialize an output grid with the same dimensions as the input, filled with the background color (0).\n2. Identify the largest contiguous block (S) of a single non-zero color and determine its color (C).\n3. Identify all cells in the input grid that have the dominant color C. This includes the primary block (S) and any other disconnected cells with color C (D). Let the set of coordinates for all these cells be `dominant_locations`.\n4. Identify 'noise' cells (N): Iterate through the input grid. A cell (r, c) is considered a noise cell to be assimilated if:\n    a. Its color is non-zero and *not* equal to the dominant color C.\n    b. It is orthogonally adjacent to at least two cells whose coordinates are in `dominant_locations`.\n5. Populate the output grid: For every coordinate (r_out, c_out) belonging to either `dominant_locations` or the set of assimilated noise cells (N), set the corresponding cell in the output grid to the dominant color C.\n6. Return the final output grid.\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _find_contiguous_blocks(grid):\n    \"\"\"\n    Finds all contiguous blocks of non-zero colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a block\n              and contains (color, size, list_of_coordinates).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start BFS if cell is non-zero and not visited\n            if color != 0 and not visited[r, c]:\n                block_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                current_color = color # Should be the same as grid[r,c]\n\n                while q:\n                    row, col = q.popleft()\n                    block_coords.append((row, col))\n\n                    # Explore neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, if not visited, and if it has the same color\n                        if _is_valid(nr, nc, rows, cols) and \\\n                           not visited[nr, nc] and \\\n                           grid[nr, nc] == current_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                blocks.append({'color': current_color, 'size': len(block_coords), 'coords': block_coords})\n\n    return blocks\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying the largest block, \n    collecting all cells of that dominant color, and assimilating adjacent \n    noise cells based on neighbor count.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    output_grid = np.zeros_like(grid, dtype=int)\n\n    # 1. Find all contiguous blocks and identify the largest one\n    all_blocks = _find_contiguous_blocks(grid)\n\n    if not all_blocks: # Handle empty or all-zero grids\n        return output_grid.tolist() # Or return output_grid based on expected type\n\n    largest_block = max(all_blocks, key=lambda b: b['size'])\n    dominant_color = largest_block['color']\n    \n    # 2. Identify all locations (coordinates) with the dominant color\n    dominant_locations = set()\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == dominant_color:\n                dominant_locations.add((r, c))\n\n    # 3. Identify noise cells to assimilate\n    assimilated_noise_locations = set()\n    for r in range(rows):\n        for c in range(cols):\n            cell_color = grid[r, c]\n            # Check if it's a non-zero noise cell\n            if cell_color != 0 and cell_color != dominant_color:\n                # Count neighbors with the dominant color\n                dominant_neighbor_count = 0\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if _is_valid(nr, nc, rows, cols) and (nr, nc) in dominant_locations:\n                        dominant_neighbor_count += 1\n                \n                # Assimilate if neighbor count is 2 or more\n                if dominant_neighbor_count >= 2:\n                    assimilated_noise_locations.add((r, c))\n\n    # 4. Generate Output Grid\n    # Combine all locations that should have the dominant color in the output\n    output_locations = dominant_locations.union(assimilated_noise_locations)\n\n    # Populate the output grid\n    for r_out, c_out in output_locations:\n        output_grid[r_out, c_out] = dominant_color\n\n    # 5. Return Output Grid (converted to list of lists if required by framework)\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8108,
    "candidates_token_count": 1361,
    "total_token_count": 9469,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.728622,
  "retries": 1
}