{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Scan the input grid to identify all distinct connected components (objects) formed by non-zero numbers.\n2. For each identified object, determine its primary constituent number (the 'main number').\n3. Check if the object encloses one or more cells containing a single, different non-zero number (the 'internal number'). Only consider objects that have such an internal number.\n4. From the set of objects identified in step 3, find the minimum 'main number'.\n5. Identify all objects from step 3 whose 'main number' is equal to this minimum value.\n6. Collect the 'internal number'(s) from these specific objects found in step 5.\n7. The final output is the maximum value among the collected 'internal number'(s).\n\"\"\"\n\ndef _find_connected_component(grid, start_r, start_c, visited):\n    \"\"\"Finds a single connected component using BFS.\"\"\"\n    rows, cols = grid.shape\n    main_number = grid[start_r, start_c]\n    if main_number == 0:\n        return None, set()\n\n    q = deque([(start_r, start_c)])\n    component_coords = set()\n    \n    while q:\n        r, c = q.popleft()\n        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited or grid[r, c] != main_number:\n            continue\n            \n        visited.add((r, c))\n        component_coords.add((r, c))\n        \n        # Explore 4-directional neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            q.append((nr, nc))\n            \n    return main_number, component_coords\n\ndef _get_internal_number(grid, component_coords, main_number):\n    \"\"\"\n    Identifies the internal number enclosed by a component, if any.\n    An internal number cell must be non-zero, different from main_number,\n    and all its neighbors must belong to the component or be other cells\n    of the same internal number.\n    \"\"\"\n    rows, cols = grid.shape\n    potential_internal_coords = set()\n    \n    # 1. Find candidate internal cells adjacent to the component\n    for r, c in component_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_val = grid[nr, nc]\n                neighbor_coord = (nr, nc)\n                # Check if neighbor is potential internal cell\n                if neighbor_val != 0 and neighbor_val != main_number and neighbor_coord not in component_coords:\n                     potential_internal_coords.add(neighbor_coord)\n\n    if not potential_internal_coords:\n        return None # No candidates found\n\n    # 2. Validate candidates: Check if they form a single-valued, fully enclosed group\n    internal_number = grid[next(iter(potential_internal_coords))] # Get value from first candidate\n    \n    visited_internal = set()\n    q = deque([next(iter(potential_internal_coords))]) # Start BFS/DFS from one candidate\n    actual_internal_coords = set()\n\n    while q:\n        r, c = q.popleft()\n\n        if not (0 <= r < rows and 0 <= c < cols) or (r, c) in visited_internal:\n            continue\n        \n        current_val = grid[r,c]\n\n        # Check if this cell is valid:\n        # - Must be in the potential list initially found\n        # - Must have the determined internal_number value\n        if (r, c) not in potential_internal_coords or current_val != internal_number:\n             # If we find a cell during BFS that wasn't adjacent or has wrong number, it's not validly enclosed\n             # Or if the potential candidates had different numbers initially\n             return None \n\n        visited_internal.add((r, c))\n        actual_internal_coords.add((r, c))\n        \n        # Check neighbors: must be main_number or internal_number\n        is_enclosed = True\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_val = grid[nr, nc]\n                neighbor_coord = (nr, nc)\n                # Neighbor must be part of the component or another potential internal cell\n                if neighbor_coord not in component_coords and neighbor_coord not in potential_internal_coords:\n                    is_enclosed = False\n                    break \n                # If it's another potential internal cell, add to queue\n                if neighbor_coord in potential_internal_coords and neighbor_coord not in visited_internal:\n                     q.append(neighbor_coord)\n            else:\n                # Touches boundary - cannot be fully enclosed\n                is_enclosed = False\n                break\n        \n        if not is_enclosed:\n            return None\n\n    # Final check: ensure all potential candidates were visited and part of this single group\n    if actual_internal_coords != potential_internal_coords:\n         return None\n\n    return internal_number\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies objects in the grid, finds those enclosing a different non-zero number,\n    determines the minimum main number among these objects, and returns the maximum\n    internal number associated with objects having that minimum main number.\n    \"\"\"\n    grid = np.array(input_grid)\n    rows, cols = grid.shape\n    visited = set()\n    objects_with_internals = []\n\n    # 1. & 2. Find all objects (connected components)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                main_number, component_coords = _find_connected_component(grid, r, c, visited)\n                if main_number is not None:\n                    # 3. Check for internal number\n                    internal_number = _get_internal_number(grid, component_coords, main_number)\n                    if internal_number is not None:\n                        objects_with_internals.append({\n                            'main': main_number,\n                            'internal': internal_number\n                        })\n\n    if not objects_with_internals:\n        # Handle cases where no objects with internal numbers are found, though examples suggest this won't happen.\n        # Returning 0 or raising an error might be options. Based on examples, seems we always find one.\n        return 0 # Or raise ValueError(\"No objects with internal numbers found\")\n\n    # 4. Find the minimum 'main number' among qualifying objects\n    min_main_number = min(obj['main'] for obj in objects_with_internals)\n\n    # 5. Identify objects with this minimum main number\n    relevant_objects = [obj for obj in objects_with_internals if obj['main'] == min_main_number]\n\n    # 6. Collect internal numbers from relevant objects\n    internal_numbers = [obj['internal'] for obj in relevant_objects]\n\n    # 7. Find the maximum internal number\n    output = max(internal_numbers)\n\n    return output\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2070,
    "candidates_token_count": 1765,
    "total_token_count": 3835,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.627709,
  "retries": 1
}