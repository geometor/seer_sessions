{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the unique integer value (including 0) in the input grid whose\noccurrences have the highest density within their minimal bounding box.\nDensity is calculated as (number of occurrences) / (bounding box area).\nTie-breaking rules: highest density, then highest count, then smallest\nbounding box area, then smallest integer value.\nExtracts the subgrid corresponding to the bounding box of the selected value.\nFilters the extracted subgrid, keeping only the cells that contained the\nselected value in the original input and setting others to 0.\n\"\"\"\n\nimport numpy as np\nimport collections # Although not strictly needed with numpy, kept for potential future use if logic changes\n\ndef _get_bounding_box(coords_indices):\n    \"\"\"\n    Calculates the min/max row/col for a list/array of coordinates.\n\n    Args:\n        coords_indices (tuple of np.array): Output from np.where, containing arrays\n                                          for row indices and column indices.\n\n    Returns:\n        tuple: (min_r, max_r, min_c, max_c) or None if coords_indices is empty.\n    \"\"\"\n    if not coords_indices or len(coords_indices[0]) == 0:\n        return None\n\n    rows = coords_indices[0]\n    cols = coords_indices[1]\n\n    min_r = np.min(rows)\n    max_r = np.max(rows)\n    min_c = np.min(cols)\n    max_c = np.max(cols)\n    return min_r, max_r, min_c, max_c\n\ndef transform(input_grid_arg):\n    \"\"\"\n    Finds the integer value with the highest density of occurrences within its\n    bounding box, extracts that bounding box, and filters it to keep only\n    the selected integer value.\n\n    Args:\n        input_grid_arg: The input 2D grid (list of lists or numpy array).\n\n    Returns:\n        list of list of int: The filtered subgrid based on the highest density value.\n                             Returns an empty list if the input is empty or no suitable\n                             value is found (e.g., only zeros and 0 isn't highest density).\n    \"\"\"\n    # Ensure input is a NumPy array\n    input_grid = np.array(input_grid_arg, dtype=int)\n\n    # Handle empty input grid\n    if input_grid.size == 0:\n        return []\n\n    rows, cols = input_grid.shape\n\n    # Find unique values in the grid\n    unique_values = np.unique(input_grid)\n\n    # Initialize variables to track the best candidate\n    best_value = None\n    max_density = -1.0\n    max_count = -1\n    min_bbox_area = float('inf')\n    best_bbox = None\n\n    # Iterate through each unique value to find the one with the highest density\n    for candidate_value in unique_values:\n        # Find coordinates of all occurrences of the candidate value\n        indices = np.where(input_grid == candidate_value)\n\n        # Skip if the value doesn't exist (shouldn't happen with np.unique unless grid is empty)\n        if len(indices[0]) == 0:\n            continue\n\n        # Calculate count\n        current_count = len(indices[0])\n\n        # Determine bounding box\n        bbox = _get_bounding_box(indices)\n        if bbox is None: # Should not happen if count > 0\n             continue\n        min_r, max_r, min_c, max_c = bbox\n\n        # Calculate bounding box area\n        current_bbox_area = (max_r - min_r + 1) * (max_c - min_c + 1)\n        if current_bbox_area <= 0: # Avoid division by zero for single point/line cases\n            current_density = float('inf') if current_count > 0 else 0 # Assign high density if area is minimal\n        else:\n            current_density = current_count / current_bbox_area\n\n        # --- Apply selection criteria and tie-breaking ---\n        is_better = False\n        if current_density > max_density:\n            is_better = True\n        elif current_density == max_density:\n            if current_count > max_count:\n                is_better = True\n            elif current_count == max_count:\n                if current_bbox_area < min_bbox_area:\n                    is_better = True\n                elif current_bbox_area == min_bbox_area:\n                    # Final tie-breaker: smaller integer value wins\n                    if best_value is None or candidate_value < best_value:\n                        is_better = True\n\n        # Update best candidate if current one is better\n        if is_better:\n            max_density = current_density\n            max_count = current_count\n            min_bbox_area = current_bbox_area\n            best_value = candidate_value\n            best_bbox = bbox\n\n    # If no suitable candidate was found (e.g., empty grid processed), return empty list\n    if best_bbox is None:\n        return []\n\n    # Extract the subgrid corresponding to the best bounding box\n    min_r, max_r, min_c, max_c = best_bbox\n    extracted_subgrid = input_grid[min_r : max_r + 1, min_c : max_c + 1]\n\n    # Filter the extracted subgrid: keep only the 'best_value', replace others with 0\n    output_grid_np = np.where(extracted_subgrid == best_value, best_value, 0)\n\n    # Convert the resulting NumPy array to a standard Python list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 24681,
    "candidates_token_count": 1323,
    "total_token_count": 26004,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.713902,
  "retries": 1
}