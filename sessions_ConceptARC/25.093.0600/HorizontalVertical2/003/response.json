{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the properties of connected non-zero blocks.\n\nRule:\n1. Identify all connected blocks of non-zero numbers. Calculate their sum, size (number of cells), and maximum row index (bottom extent).\n2. **Special Case:** If exactly two blocks exist and they have the same size, return an all-zero grid.\n3. Otherwise, find the maximum sum and maximum size among all blocks.\n4. Identify candidate blocks: A block is a candidate if its sum equals the maximum sum OR its size equals the maximum size.\n5. Find the maximum bottom extent (maximum row index) among all candidate blocks.\n6. Select the final blocks: These are the candidate blocks whose bottom extent equals the maximum bottom extent found in step 5.\n7. Create an output grid filled with zeros. Copy the cells from the finally selected blocks (from step 6) into the output grid at their original positions.\n\"\"\"\n\ndef find_blocks_with_properties(grid):\n    \"\"\"\n    Identifies connected blocks of non-zero cells and calculates their properties.\n\n    Args:\n        grid: A NumPy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents a block\n        and contains: 'coords' (list of (r, c) tuples), 'sum', 'size', 'max_r'.\n        Returns an empty list if no non-zero cells are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks_data = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS if a non-zero cell is found that hasn't been visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_block_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                block_sum = 0\n                max_r_in_block = -1\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_block_coords.append((curr_r, curr_c))\n                    block_sum += grid[curr_r, curr_c]\n                    max_r_in_block = max(max_r_in_block, curr_r)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        # Check bounds, non-zero value, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store properties of the found block\n                if current_block_coords:\n                    blocks_data.append({\n                        'coords': current_block_coords,\n                        'sum': block_sum,\n                        'size': len(current_block_coords),\n                        'max_r': max_r_in_block\n                    })\n    return blocks_data\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # Initialize output grid with zeros\n    output_grid = np.zeros_like(input_array)\n\n    # Find all blocks and their properties\n    blocks = find_blocks_with_properties(input_array)\n\n    # Handle the case of no blocks\n    if not blocks:\n        return output_grid.tolist()\n\n    # Special Case: Exactly two blocks of identical size\n    if len(blocks) == 2 and blocks[0]['size'] == blocks[1]['size']:\n        return output_grid.tolist() # Return the all-zero grid\n\n    # Determine maximum sum and maximum size among all blocks\n    max_sum = 0\n    max_size = 0\n    for block in blocks:\n        max_sum = max(max_sum, block['sum'])\n        max_size = max(max_size, block['size'])\n\n    # Identify candidate blocks (max sum OR max size)\n    candidate_blocks = []\n    for block in blocks:\n        if block['sum'] == max_sum or block['size'] == max_size:\n            candidate_blocks.append(block)\n\n    # Handle the case where no candidates are found (shouldn't happen if blocks exist)\n    if not candidate_blocks:\n         return output_grid.tolist()\n\n    # Find the maximum bottom extent among candidate blocks\n    max_bottom_extent = -1\n    for block in candidate_blocks:\n        max_bottom_extent = max(max_bottom_extent, block['max_r'])\n\n    # Select final blocks (candidates with the maximum bottom extent)\n    final_blocks = []\n    for block in candidate_blocks:\n        if block['max_r'] == max_bottom_extent:\n            final_blocks.append(block)\n\n    # Copy the cells of the final selected blocks to the output grid\n    for block in final_blocks:\n        for r, c in block['coords']:\n            output_grid[r, c] = input_array[r, c]\n\n    # Convert the output NumPy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11141,
    "candidates_token_count": 1331,
    "total_token_count": 12472,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.189611,
  "retries": 1
}