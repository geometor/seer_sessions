{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies a primary diagonal or anti-diagonal line segment composed of a single, \nrepeated non-zero integer in the input grid. This segment is then projected \nhorizontally by a fixed offset (observed as 7 columns to the right in examples). \nThe cells at the projected coordinates in the output grid are overwritten with \nthe number composing the source line segment.\n\"\"\"\n\ndef _find_source_line(grid):\n    \"\"\"\n    Finds the primary diagonal or anti-diagonal line segment.\n\n    Identifies connected components of identical non-zero numbers using Breadth-First Search (BFS).\n    Checks if a component forms a true diagonal (row - col = constant) or \n    anti-diagonal (row + col = constant) line segment.\n    Filters out components that are purely horizontal or vertical lines.\n    Ensures the identified segment is contiguous along its diagonal/anti-diagonal path.\n    If multiple valid diagonal/anti-diagonal line segments are found, it selects the one\n    whose coordinates include the minimum row index (topmost). If rows are tied, it chooses \n    the one starting at the minimum column index (leftmost).\n\n    Args:\n        grid (np.array): The input grid as a NumPy array.\n\n    Returns:\n        tuple: (source_number, source_coords) or (None, []) if no suitable line is found.\n            source_number (int or None): The integer value composing the line, or None.\n            source_coords (list): A list of (row, col) tuples for the segment, or empty list.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    potential_segments = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-zero cell\n            if grid[r, c] > 0 and not visited[r, c]:\n                num = grid[r, c]\n                component_coords = set()\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                component_coords.add((r, c))\n\n                # Find all connected cells (8-connectivity) with the same number\n                while q:\n                    row, col = q.popleft()\n                    # Check 8 neighbors\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0: continue # Skip self\n                            nr, nc = row + dr, col + dc\n                            # Check bounds and if neighbor matches number and is unvisited\n                            if 0 <= nr < rows and 0 <= nc < cols and \\\n                               grid[nr, nc] == num and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                component_coords.add((nr, nc))\n                                q.append((nr, nc))\n\n                # Analyze the found component\n                if len(component_coords) >= 2:\n                    # Sort coordinates primarily by row, then column for consistent checks\n                    coords_list = sorted(list(component_coords), key=lambda x: (x[0], x[1]))\n\n                    # Check if it's a pure row (all rows same) or column (all cols same)\n                    is_row = all(cr == coords_list[0][0] for cr, cc in coords_list)\n                    is_col = all(cc == coords_list[0][1] for cr, cc in coords_list)\n\n                    # Filter out pure rows and columns\n                    if not is_row and not is_col:\n                        # Check if it forms a diagonal (r-c = const) or anti-diagonal (r+c = const)\n                        is_diag = len(set(cr - cc for cr, cc in coords_list)) == 1\n                        is_anti = len(set(cr + cc for cr, cc in coords_list)) == 1\n\n                        # Check for contiguity along the diagonal/anti-diagonal path\n                        is_contiguous = True\n                        if len(coords_list) > 1:\n                           diffs = set()\n                           # Check the step between consecutive sorted points\n                           for i in range(len(coords_list) - 1):\n                               dr = coords_list[i+1][0] - coords_list[i][0]\n                               dc = coords_list[i+1][1] - coords_list[i][1]\n                               diffs.add((dr, dc))\n                           # A contiguous diagonal/anti-diagonal should only have one type of step:\n                           # (1, 1) for anti-diagonal down-right\n                           # (1, -1) for diagonal down-left\n                           # (-1,-1) for anti-diagonal up-left (covered by sorting/starting point)\n                           # (-1, 1) for diagonal up-right (covered by sorting/starting point)\n                           # We expect only one step type like (1,1) or (1,-1) etc.\n                           # And the magnitude of row/col step must be 1 for diagonal adjacency\n                           if len(diffs) != 1 or abs(list(diffs)[0][0]) != 1 or abs(list(diffs)[0][1]) != 1:\n                               is_contiguous = False\n\n                        # If it's a valid, contiguous diagonal or anti-diagonal segment\n                        if (is_diag or is_anti) and is_contiguous:\n                            potential_segments.append((num, coords_list))\n\n\n    # --- Selection of the primary segment ---\n    if not potential_segments:\n        # No segments found matching the criteria\n        # print(\"Debug: No suitable source line segment found.\") # Optional debug message\n        return None, []\n    elif len(potential_segments) == 1:\n        # Exactly one segment found\n        return potential_segments[0]\n    else:\n        # Multiple segments found, apply tie-breaking rules\n        # Sort by the minimum row index in the segment's coordinates\n        # If rows are tied, sort by the minimum column index among points with the minimum row index\n        potential_segments.sort(key=lambda s: (\n            min(r for r, c in s[1]), \n            min(c for r, c in s[1] if r == min(r_ for r_, c_ in s[1]))\n        ))\n        # print(f\"Debug: Found {len(potential_segments)} potential source lines. Choosing the topmost/leftmost one.\") # Optional debug message\n        return potential_segments[0]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # --- Initialization ---\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    if input_array.size == 0: # Handle empty input\n        return []\n    rows, cols = input_array.shape\n    # Create a copy of the input array to modify, this will become the output\n    output_grid = np.copy(input_array)\n\n    # --- Parameters ---\n    # Define the fixed horizontal offset used for projection\n    offset = 7\n\n    # --- Core Logic ---\n    # 1. Find the specific source diagonal/anti-diagonal line segment\n    source_number, source_coords = _find_source_line(input_array)\n\n    # If no valid source line was found, return the unmodified grid copy\n    if source_number is None:\n        # print(\"Warning: No source line identified, returning copy of input.\") # Optional warning\n        return output_grid.tolist() # Convert back to list of lists format\n\n    # 2. Apply the projection and overwrite values\n    # Iterate through each coordinate (row, col) of the identified source line\n    for r, c_source in source_coords:\n        # Calculate the target column by adding the offset\n        c_target = c_source + offset\n\n        # Check if the calculated target column is within the grid's column bounds\n        if 0 <= c_target < cols:\n            # If within bounds, overwrite the value in the output grid\n            # at the target coordinate (same row, shifted column)\n            # with the number from the source line segment.\n            output_grid[r, c_target] = source_number\n\n    # --- Output ---\n    # Convert the final NumPy array back to a list of lists format for the return value\n    return output_grid.tolist"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "citation_metadata": {
        "citation_sources": [
          {
            "start_index": 10055,
            "end_index": 10378,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          },
          {
            "start_index": 14608,
            "end_index": 14911,
            "uri": "https://github.com/abhisheksol/competivity-programming",
            "license_": ""
          }
        ]
      },
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1847,
    "candidates_token_count": 1984,
    "total_token_count": 3831,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 73.95941,
  "retries": 1
}