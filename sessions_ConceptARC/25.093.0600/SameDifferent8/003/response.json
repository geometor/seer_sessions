{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nThe transformation rule operates on a grid divided into two subgrids (Sub1, Sub2) by a single separator row or column composed entirely of zeros. \n\n1.  Identify the zero separator (row or column) and split the grid.\n2.  Analyze each subgrid:\n    a.  Determine the background color (bg), which is the most frequent color in that subgrid.\n    b.  Identify all cells that are *not* the background color; these form the pattern.\n    c.  If a pattern exists, calculate its minimal bounding box (bbox) and the relative coordinates of the pattern cells within that bbox (the shape).\n3.  Compare the shapes (relative patterns) of Sub1 (Shape1) and Sub2 (Shape2).\n4.  If Shape1 exists and is identical to Shape2:\n    a.  Extract the portion of Sub1 corresponding to its bounding box (bbox1).\n    b.  Create the output grid by taking this extracted portion and replacing all occurrences of Sub1's background color (bg1) with 0, keeping other pattern colors as they are.\n5.  Otherwise (if Shape1 doesn't exist, or if Shape1 is different from Shape2):\n    a.  The output is a 1x1 grid containing 0, represented as [[0]].\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef _find_separator(grid_np):\n    \"\"\"\n    Finds the single separator row or column of zeros.\n\n    Args:\n        grid_np: The input grid as a NumPy array.\n\n    Returns:\n        A tuple (separator_type, index) where separator_type is 'row' or 'col',\n        and index is the row/column index.\n        Returns (None, -1) if no unique separator is found.\n    \"\"\"\n    rows, cols = grid_np.shape\n    zero_rows = [r for r in range(rows) if np.all(grid_np[r, :] == 0)]\n    zero_cols = [c for c in range(cols) if np.all(grid_np[:, c] == 0)]\n\n    # Check for block of zero rows (treat as single row separator)\n    if len(zero_rows) > 0:\n        first_zero_row = zero_rows[0]\n        last_zero_row = first_zero_row\n        while last_zero_row + 1 < rows and np.all(grid_np[last_zero_row + 1, :] == 0):\n            last_zero_row += 1\n        # Check if this block covers *all* zero rows found\n        is_contiguous_block = list(range(first_zero_row, last_zero_row + 1)) == zero_rows\n        if is_contiguous_block and len(zero_cols) == 0:\n             # Return the start and end index of the row block\n            return 'row_block', (first_zero_row, last_zero_row)\n\n    # Check for single zero row\n    if len(zero_rows) == 1 and len(zero_cols) == 0:\n        return 'row', zero_rows[0]\n\n    # Check for single zero col\n    if len(zero_cols) == 1 and len(zero_rows) == 0:\n        return 'col', zero_cols[0]\n\n    return None, -1 # No unique single separator found\n\ndef _analyze_subgrid(grid_np):\n    \"\"\"\n    Analyzes a subgrid to find background color, pattern shape, and bounding box.\n\n    Args:\n        grid_np: The subgrid as a NumPy array.\n\n    Returns:\n        A tuple (bg, shape, bbox, bbox_subgrid):\n        - bg: The background color (most frequent). None if grid is empty/uniform.\n        - shape: A set of relative (row, col) coordinates of non-background\n                 pixels within the bbox. None if no pattern.\n        - bbox: Tuple (min_row, min_col, max_row, max_col) of the pattern. None if no pattern.\n        - bbox_subgrid: The actual grid data within the bbox. None if no pattern.\n    \"\"\"\n    if grid_np.size == 0:\n        return None, None, None, None\n\n    counts = Counter(grid_np.flatten())\n    # If only one color exists, there's no distinct pattern.\n    if len(counts) <= 1:\n        bg = list(counts.keys())[0] if len(counts) == 1 else 0 # Assign a default bg if grid was empty?\n        return bg, None, None, None\n\n    # Background color is the most frequent\n    bg = counts.most_common(1)[0][0]\n\n    # Find coordinates of non-background (pattern) cells\n    pattern_coords = np.argwhere(grid_np != bg)\n\n    if pattern_coords.shape[0] == 0:\n        # Only background color was present\n        return bg, None, None, None\n\n    # Calculate bounding box\n    min_row, min_col = pattern_coords.min(axis=0)\n    max_row, max_col = pattern_coords.max(axis=0)\n    bbox = (min_row, min_col, max_row, max_col)\n\n    # Extract relative pattern shape\n    shape = set()\n    for r, c in pattern_coords:\n        shape.add((r - min_row, c - min_col))\n\n    # Extract the subgrid corresponding to the bounding box\n    bbox_subgrid = grid_np[min_row : max_row + 1, min_col : max_col + 1]\n\n    return bg, shape, bbox, bbox_subgrid\n\ndef _create_output_grid(bg, bbox_subgrid):\n    \"\"\"\n    Creates the output grid by filtering the bounding box subgrid.\n    Background pixels become 0, others remain.\n\n    Args:\n        bg: The background color of the source subgrid.\n        bbox_subgrid: The NumPy array of the source subgrid's bounding box.\n\n    Returns:\n        The filtered output grid as a NumPy array.\n    \"\"\"\n    # Create a copy to modify\n    output_np = bbox_subgrid.copy()\n    # Replace background color with 0\n    output_np[output_np == bg] = 0\n    return output_np\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on comparing shapes in the upper/lower or left/right parts,\n    separated by a zero line. Outputs the filtered shape from the first part if shapes match,\n    otherwise outputs [[0]].\n    \"\"\"\n    # Convert input to NumPy array\n    input_np = np.array(input_grid, dtype=int)\n\n    # Find the separator\n    sep_type, sep_idx = _find_separator(input_np)\n\n    if sep_type is None:\n        # If no valid separator, return default [[0]] (or handle error appropriately)\n        # Based on problem constraints, a separator should always exist.\n        # However, adding a fallback for robustness.\n        return [[0]]\n\n    # Split into two subgrids based on separator type\n    if sep_type == 'row':\n        sub1_np = input_np[:sep_idx, :]\n        sub2_np = input_np[sep_idx + 1:, :]\n    elif sep_type == 'row_block':\n         first_sep_row, last_sep_row = sep_idx\n         sub1_np = input_np[:first_sep_row, :]\n         sub2_np = input_np[last_sep_row + 1:, :]\n    elif sep_type == 'col':\n        sub1_np = input_np[:, :sep_idx]\n        sub2_np = input_np[:, sep_idx + 1:]\n    else:\n         # Should not happen with current _find_separator logic\n         return [[0]]\n\n\n    # Analyze the first subgrid\n    bg1, shape1, bbox1, bbox_subgrid1 = _analyze_subgrid(sub1_np)\n\n    # Analyze the second subgrid\n    bg2, shape2, bbox2, bbox_subgrid2 = _analyze_subgrid(sub2_np)\n\n    # Check the condition: Shape1 must exist and match Shape2\n    if shape1 is not None and shape1 == shape2:\n        # Create the output grid by filtering Sub1's bounding box\n        output_np = _create_output_grid(bg1, bbox_subgrid1)\n        # Convert to list of lists for the required output format\n        output_grid = output_np.tolist()\n    else:\n        # Shapes don't match or Shape1 doesn't exist\n        output_grid = [[0]]\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16729,
    "candidates_token_count": 2028,
    "total_token_count": 18757,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.941816,
  "retries": 1
}