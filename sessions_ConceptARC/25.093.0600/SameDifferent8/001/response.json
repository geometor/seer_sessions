{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nimport copy  # Although numpy copy methods are usually preferred\n\n\"\"\"\nThe transformation rule involves comparing patterns in two subgrids separated by a zero row.\n\n1.  **Parse Input:** Split the input grid into an upper subgrid (`grid1`) and a lower subgrid (`grid2`) using the row(s) of all zeros as a separator.\n2.  **Analyze Subgrids:** For each subgrid (`grid1` and `grid2`):\n    a.  Identify the background color (`bg`), the most frequent non-zero digit.\n    b.  Identify the foreground color (`fg`), the other non-zero digit.\n    c.  Find all coordinates of the `fg` cells. If no `fg` cells exist, mark the shape as non-existent.\n    d.  Calculate the minimal bounding box (`bbox`) enclosing the `fg` cells.\n    e.  Extract the relative pattern (`shape`) of `fg` cells within the `bbox` (coordinates relative to the top-left of the `bbox`).\n    f.  Extract the subgrid corresponding to the `bbox` from the original subgrid.\n3.  **Compare Shapes:** Compare the relative pattern `shape1` from `grid1` with `shape2` from `grid2`.\n4.  **Determine Output:**\n    a.  **If** `shape1` exists **and** (`shape1` is identical to `shape2` **or** `shape1`'s bounding box in `grid1` contains any cells with `grid1`'s background color `bg1`):\n        i.  Create an output grid with the dimensions of `bbox1`.\n        ii. Place `fg1` at the locations corresponding to `shape1` within this output grid.\n        iii. Fill all other cells in the output grid with `0`.\n        iv. Return this output grid.\n    b.  **Else** (either `shape1` doesn't exist, or `shape1` is different from `shape2` **and** `shape1`'s bounding box in `grid1` contains *only* `fg1` cells):\n        i.  Return a grid containing a single `0`.\n\"\"\"\n\ndef _find_separator(grid_np):\n    \"\"\"Finds the index of the first row containing only zeros.\"\"\"\n    for r in range(grid_np.shape[0]):\n        if np.all(grid_np[r, :] == 0):\n            return r\n    return -1 # Should not happen based on problem description\n\ndef _analyze_subgrid(grid_np):\n    \"\"\"Analyzes a subgrid to find background, foreground, shape, and bounding box.\"\"\"\n    if grid_np.size == 0:\n        return None, None, None, None, None, None\n\n    non_zeros = grid_np[grid_np != 0]\n    if non_zeros.size == 0:\n        # Grid contains only zeros or is empty after filtering\n        return 0, None, None, None, None, None # Assign bg=0 arbitrarily, no fg\n\n    counts = Counter(non_zeros)\n    \n    # Determine background color (most frequent non-zero)\n    bg = counts.most_common(1)[0][0]\n    \n    # Determine foreground color (the other non-zero, if it exists)\n    fg = None\n    for color in counts:\n        if color != bg:\n            fg = color\n            break\n            \n    if fg is None:\n        # Only one non-zero color found, treat it as background, no foreground shape\n        return bg, None, None, None, None, None\n\n    # Find coordinates of foreground cells\n    fg_coords = np.argwhere(grid_np == fg)\n    if fg_coords.shape[0] == 0:\n         # This case should technically be covered by fg is None, but added for safety\n        return bg, fg, None, None, None, None \n\n    # Calculate bounding box [min_row, min_col, max_row, max_col]\n    min_row, min_col = fg_coords.min(axis=0)\n    max_row, max_col = fg_coords.max(axis=0)\n    bbox = (min_row, min_col, max_row, max_col)\n\n    # Extract relative pattern (set of (r, c) tuples relative to bbox top-left)\n    relative_pattern = set()\n    for r, c in fg_coords:\n        relative_pattern.add((r - min_row, c - min_col))\n\n    # Extract the subgrid corresponding to the bounding box\n    bbox_subgrid = grid_np[min_row : max_row + 1, min_col : max_col + 1]\n\n    return bg, fg, fg_coords, bbox, relative_pattern, bbox_subgrid\n\n\ndef _create_output_grid(bbox, fg_color, relative_pattern):\n    \"\"\"Creates the output grid based on shape1's properties.\"\"\"\n    min_row, min_col, max_row, max_col = bbox\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    output_np = np.zeros((height, width), dtype=int)\n    \n    for r_rel, c_rel in relative_pattern:\n        output_np[r_rel, c_rel] = fg_color\n        \n    return output_np\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on comparing shapes in the upper and lower parts.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n\n    # Find the separator row\n    separator_row_index = _find_separator(input_np)\n    if separator_row_index == -1:\n        # Handle error: No separator found (though problem implies one exists)\n        return [[0]] # Default or error output\n\n    # Split into two subgrids\n    # Skip the separator row itself when creating subgrids\n    grid1_np = input_np[:separator_row_index, :]\n    # Find the end of the separator block if there are multiple zero rows\n    first_non_zero_row_after_sep = separator_row_index\n    while first_non_zero_row_after_sep < input_np.shape[0] and np.all(input_np[first_non_zero_row_after_sep, :] == 0):\n        first_non_zero_row_after_sep += 1\n        \n    grid2_np = input_np[first_non_zero_row_after_sep:, :]\n\n    # Analyze Grid1\n    bg1, fg1, coords1, bbox1, pattern1, bbox_subgrid1 = _analyze_subgrid(grid1_np)\n\n    # Analyze Grid2\n    bg2, fg2, coords2, bbox2, pattern2, bbox_subgrid2 = _analyze_subgrid(grid2_np)\n\n    # Check if shape1 exists\n    if pattern1 is None:\n        # If grid1 has no foreground shape, output is 0\n        return [[0]]\n\n    # Determine if the bounding box of shape1 contains any background pixels from grid1\n    contains_bg1_in_bbox1 = False\n    if bbox_subgrid1 is not None and bg1 is not None:\n         contains_bg1_in_bbox1 = np.any(bbox_subgrid1 == bg1)\n\n    # Apply the core logic\n    if pattern1 == pattern2 or contains_bg1_in_bbox1:\n        # Condition met: shapes match OR shape1's bbox contains background\n        # Create output grid from shape1\n        output_np = _create_output_grid(bbox1, fg1, pattern1)\n        # Convert numpy array back to list of lists for the required output format\n        return output_np.tolist()\n    else:\n        # Condition not met: shapes differ AND shape1's bbox does NOT contain background\n        return [[0]]\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3294,
    "candidates_token_count": 1858,
    "total_token_count": 5152,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.677053,
  "retries": 1
}