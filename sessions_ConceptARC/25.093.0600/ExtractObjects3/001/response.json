{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the first rectangular frame object in the input grid composed of a single non-zero color. \nExtracts the bounding box of this frame. \nCreates an output grid corresponding to this bounding box. \nPopulates the output grid: cells corresponding to the frame's color retain that color, while all other cells within the bounding box become 0 (background).\n\"\"\"\n\ndef _is_valid(r, c, rows, cols):\n    \"\"\"Check if coordinates are within grid bounds.\"\"\"\n    return 0 <= r < rows and 0 <= c < cols\n\ndef _find_first_frame(grid):\n    \"\"\"\n    Finds the first rectangular frame in the grid.\n\n    A frame is defined as a rectangle where the border cells all have the \n    same non-zero color, and at least one interior cell has a different color \n    or is the background color (0).\n\n    Returns:\n        tuple: ((min_row, min_col, max_row, max_col), frame_color) if found, \n               else (None, None).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited_for_frame_check = set() # Store (r, c) of starting points checked\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] != 0 and (r, c) not in visited_for_frame_check:\n                color = grid[r][c]\n                \n                # Find connected component and its bounding box\n                q = deque([(r, c)])\n                component_cells = set([(r, c)])\n                visited_in_component = set([(r, c)])\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    visited_for_frame_check.add((curr_r, curr_c)) # Mark as checked globally\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if _is_valid(nr, nc, rows, cols) and \\\n                           grid[nr][nc] == color and \\\n                           (nr, nc) not in visited_in_component:\n                            visited_in_component.add((nr, nc))\n                            component_cells.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Check if this component forms a valid frame within its bounding box\n                is_frame = True\n                has_different_interior = False\n                \n                # Frame requires width and height > 1 to have an interior\n                if max_r - min_r < 1 or max_c - min_c < 1:\n                     is_frame = False\n                     continue # Not large enough to be a frame\n\n                for i in range(min_r, max_r + 1):\n                    for j in range(min_c, max_c + 1):\n                        # Check border cells\n                        if i == min_r or i == max_r or j == min_c or j == max_c:\n                            # Check if the cell is part of the component (handles non-rectangular components within the box)\n                            # OR more simply for this problem, check if the grid color matches the frame color\n                            if grid[i][j] != color:\n                                is_frame = False\n                                break\n                        # Check interior cells\n                        else:\n                            if grid[i][j] != color:\n                                has_different_interior = True\n                    if not is_frame:\n                        break\n                \n                # Must be a valid frame border and have a non-uniform interior\n                if is_frame and has_different_interior:\n                    return (min_r, min_c, max_r, max_c), color\n\n    return None, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by extracting the first identified rectangular frame\n    and replacing its interior with the background color (0).\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Find the bounding box and color of the first frame\n    bounding_box, frame_color = _find_first_frame(input_np.tolist()) # Helper works better with lists\n\n    if bounding_box is None:\n        # Handle case where no frame is found (optional, based on problem constraints)\n        # Returning an empty grid or original might be options.\n        # Based on examples, assume a frame always exists.\n        # For robustness, maybe return a small default grid or raise error.\n        return np.array([[]], dtype=int) \n\n    min_r, min_c, max_r, max_c = bounding_box\n\n    # 2. Calculate output grid dimensions\n    out_height = max_r - min_r + 1\n    out_width = max_c - min_c + 1\n\n    # 3. Create the output grid, initialized to 0 (background color)\n    output_grid = np.zeros((out_height, out_width), dtype=int)\n\n    # 4. Iterate through the bounding box in the input grid\n    for r_idx in range(out_height):\n        for c_idx in range(out_width):\n            # Corresponding coordinates in the input grid\n            input_r = min_r + r_idx\n            input_c = min_c + c_idx\n            \n            # 5. Check if the input cell has the frame color\n            if input_np[input_r, input_c] == frame_color:\n                 # 6. If it's the frame color, copy it to the output grid\n                 output_grid[r_idx, c_idx] = frame_color\n            # 7. Otherwise, leave the output cell as 0 (already initialized)\n\n    return output_grid.tolist() # Return as list of lists per specification\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1946,
    "candidates_token_count": 1476,
    "total_token_count": 3422,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.643911,
  "retries": 1
}