{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by filling specific internal white regions (holes) \nbased on boundary color, where the fill rule depends on the set of boundary \ncolors present globally across all filled holes.\n\nA white region is considered a 'fillable hole' if:\n1. It is a connected component (8-way) of white pixels.\n2. It is not connected to the grid border via 4-way adjacent white pixels \n   (i.e., it's not part of the outer background).\n3. All non-white pixels adjacent (8-way) to any pixel within the hole have \n   the same single color (the boundary color C).\n4. No pixel within the hole is adjacent (8-way) to any background white pixel. \n   (This is implicitly covered by checking neighbors during hole identification).\n\nThe color used to fill these holes depends on the set S of unique boundary \ncolors found across *all* fillable holes in the grid:\n- If S = {Red(2), Yellow(4)}, the mapping is Red(2)->Green(3), Yellow(4)->Orange(7).\n- If S = {Red(2), Yellow(4), Orange(7)}, the mapping is Red(2)->Orange(7), \n  Yellow(4)->Green(3), Orange(7)->Green(3).\nThe original boundary shapes remain unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\" Gets 8-way (default) or 4-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    steps = [(-1, 0), (1, 0), (0, -1), (0, 1)] # 4-way\n    if connectivity == 8:\n        steps.extend([(-1, -1), (-1, 1), (1, -1), (1, 1)]) # Add diagonals\n\n    for dr, dc in steps:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid):\n    # Initialize NumPy arrays\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = input_grid_np.copy()\n    height, width = input_grid_np.shape\n\n    # --- Step 2: Identify background white pixels (connected to border, 4-way) ---\n    is_background = np.zeros_like(input_grid_np, dtype=bool)\n    q_background = deque()\n\n    # Seed queue with border white pixels\n    for r in range(height):\n        for c in [0, width - 1]:\n            if input_grid_np[r, c] == 0 and not is_background[r, c]:\n                is_background[r, c] = True\n                q_background.append((r, c))\n    for c in range(1, width - 1): # Avoid corners checked twice\n         for r in [0, height - 1]:\n            if input_grid_np[r, c] == 0 and not is_background[r, c]:\n                is_background[r, c] = True\n                q_background.append((r, c))\n\n    # Perform BFS for background\n    while q_background:\n        r, c = q_background.popleft()\n        for nr, nc in get_neighbors(r, c, height, width, connectivity=4):\n            if input_grid_np[nr, nc] == 0 and not is_background[nr, nc]:\n                is_background[nr, nc] = True\n                q_background.append((nr, nc))\n\n    # --- Steps 3-6: Identify and filter fillable holes, collect boundary colors ---\n    visited = is_background.copy() # Start visited mask including background\n    fillable_holes = [] # List to store (list_of_pixels, boundary_color)\n    global_boundary_colors = set() # Set of unique boundary colors found\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS for potential hole if white, not background, and not visited\n            if input_grid_np[r, c] == 0 and not visited[r, c]:\n                q_hole = deque([(r, c)])\n                visited[r, c] = True\n                current_hole_pixels = []\n                boundary_colors_found = set() # Colors bordering this specific hole\n                hole_visited_local = set([(r,c)]) # Track pixels in this specific hole BFS\n                is_valid_hole = True # Assume valid initially\n\n                while q_hole:\n                    hr, hc = q_hole.popleft()\n                    current_hole_pixels.append((hr, hc))\n                    visited[hr, hc] = True # Mark as globally visited\n\n                    # Check 8-way neighbors for boundary conditions\n                    for nr, nc in get_neighbors(hr, hc, height, width, connectivity=8):\n                        neighbor_coord = (nr, nc)\n                        neighbor_color = input_grid_np[nr, nc]\n\n                        if neighbor_color == 0: # White neighbor\n                            if neighbor_coord not in hole_visited_local:\n                                # Check if it touches background white\n                                if is_background[nr, nc]:\n                                    is_valid_hole = False # Touches background -> invalid hole\n                                    # No need to break here, let BFS finish finding all pixels\n                                else:\n                                    # Add to queue if it's part of the same hole component\n                                    hole_visited_local.add(neighbor_coord)\n                                    q_hole.append(neighbor_coord)\n                        else: # Non-white neighbor (part of the boundary)\n                            boundary_colors_found.add(neighbor_color)\n\n                # Validate the hole after exploring the whole component\n                # Condition 3: Single boundary color\n                is_single_boundary = len(boundary_colors_found) == 1\n                # Condition 4 implicitly checked by is_valid_hole flag (touching background)\n\n                if is_valid_hole and is_single_boundary:\n                    # This component is a fillable hole\n                    boundary_color = boundary_colors_found.pop() # Get the single boundary color\n                    fillable_holes.append((current_hole_pixels, boundary_color))\n                    global_boundary_colors.add(boundary_color) # Add to global set\n\n    # --- Step 7: Determine the fill color mapping ---\n    fill_map = {}\n    global_boundary_colors_set = frozenset(global_boundary_colors)\n\n    # Define known mappings based on training examples\n    mapping_rules = {\n        frozenset({2, 4}): {2: 3, 4: 7}, # Red(2), Yellow(4) -> Red:Green(3), Yellow:Orange(7)\n        frozenset({2, 4, 7}): {2: 7, 4: 3, 7: 3} # Red(2), Yellow(4), Orange(7) -> Red:Orange(7), Yellow:Green(3), Orange:Green(3)\n    }\n\n    # Select the appropriate map\n    if global_boundary_colors_set in mapping_rules:\n        fill_map = mapping_rules[global_boundary_colors_set]\n\n    # --- Step 8: Fill the identified holes in the output grid ---\n    if fill_map: # Proceed only if a valid mapping was found\n        for hole_pixels, boundary_color in fillable_holes:\n            # Check if this specific hole's boundary color has a mapping\n            if boundary_color in fill_map:\n                fill_color = fill_map[boundary_color]\n                # Color the pixels belonging to this hole\n                for r_fill, c_fill in hole_pixels:\n                    output_grid[r_fill, c_fill] = fill_color\n\n    # --- Step 9: Return the modified grid ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16847,
    "candidates_token_count": 1863,
    "total_token_count": 18710,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.475167,
  "retries": 1
}