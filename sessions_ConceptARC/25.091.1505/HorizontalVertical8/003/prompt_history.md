
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 6 6 6 6 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception of task elements:**
    *   The input grids contain a background of white pixels (0) and several distinct objects composed of contiguous pixels of the same color (non-white).
    *   In each example, there is one prominent green object (color 3) which appears to be the largest or most central object.
    *   Other objects of various colors are scattered around the grid.
    *   The output grids retain the central green object and some of the other objects, while the remaining objects are removed (replaced with white pixels).
    *   The key transformation seems to involve identifying the central green object and then selectively removing other objects based on their spatial relationship to it. Specifically, objects that are *not* adjacent (including diagonally) to the central green object are removed.

*   **YAML Facts:**
    
```yaml
    task_description: Retain the largest green object and any other object directly adjacent (including diagonals) to it, removing all other objects.

    elements:
      - role: background
        color: white (0)
      - role: objects
        description: Contiguous blocks of non-white pixels.
        properties:
          - color: (1-9)
          - pixels: list of (row, col) tuples
          - size: count of pixels
          - is_green: boolean (color == 3)
          - is_largest_green: boolean (largest size among green objects)
          - adjacent_to_largest_green: boolean (shares a side or corner with any pixel of the largest green object)

    transformation:
      - step: 1
        action: Identify all distinct objects (contiguous non-white areas).
      - step: 2
        action: Find the green object with the maximum number of pixels. Designate this as the 'central_object'.
      - step: 3
        action: Create an output grid initialized as a copy of the input grid.
      - step: 4
        action: Iterate through all identified objects.
        condition: For each object that is NOT the 'central_object'.
        sub_step: a
          action: Check if any pixel of the current object is adjacent (8-connectivity: horizontal, vertical, or diagonal) to any pixel of the 'central_object'.
        sub_step: b
          action: If the object is NOT adjacent to the 'central_object'.
          effect: Change all pixels belonging to this object in the output grid to white (0).
      - step: 5
        action: Return the modified output grid.

    relationships:
      - type: adjacency
        definition: Two pixels are adjacent if they share a side or a corner (8-connectivity).
      - type: selection_criterion
        description: Objects are kept if they are the largest green object OR if they are adjacent to the largest green object. Objects not meeting this criterion are removed.
    ```


*   **Natural Language Program:**
    1.  Identify all connected components (objects) formed by contiguous pixels of the same non-white color in the input grid.
    2.  Among the objects identified in step 1, find all objects whose color is green (3).
    3.  Determine the green object that has the largest number of pixels. This is the 'central green object'.
    4.  Initialize the output grid as a copy of the input grid.
    5.  For every object identified in step 1:
        a.  If the object is the 'central green object', proceed to the next object.
        b.  If the object is not the 'central green object', check if any pixel within this object is adjacent (horizontally, vertically, or diagonally) to any pixel within the 'central green object'.
        c.  If no pixel of the current object is adjacent to the 'central green object', then update the output grid by changing all pixels corresponding to this object's location to white (0).
    6.  The final state of the output grid represents the result.
```python
import numpy as np
from collections import deque

"""
Identify the largest green object (color 3). 
Retain this object and any other object that is directly adjacent (including diagonals) to it.
Remove all other objects by changing their pixels to white (0).
"""

def find_objects(grid):
    """
    Identifies all connected objects of the same non-white color in the grid.

    Args:
        grid: A numpy array representing the input grid.

    Returns:
        A list of dictionaries, where each dictionary represents an object
        with keys 'color' (int) and 'pixels' (list of (row, col) tuples).
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(height):
        for c in range(width):
            # If the pixel is not white (0), hasn't been visited, start BFS
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    obj_pixels.append((row, col))
                    
                    # Check 8 neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue # Skip self
                            
                            nr, nc = row + dr, col + dc
                            
                            # Check boundaries
                            if 0 <= nr < height and 0 <= nc < width:
                                # Check if neighbor is same color and not visited
                                if grid[nr, nc] == color and not visited[nr, nc]:
                                    visited[nr, nc] = True
                                    q.append((nr, nc))
                                    
                objects.append({'color': color, 'pixels': obj_pixels})
                
    return objects

def get_adjacent_pixels(pixels, grid_shape):
    """
    Finds all unique pixels adjacent (including diagonals) to a given set of pixels.

    Args:
        pixels: A list or set of (row, col) tuples representing the object's pixels.
        grid_shape: A tuple (height, width) of the grid.

    Returns:
        A set of (row, col) tuples representing adjacent pixel coordinates.
    """
    height, width = grid_shape
    adjacent_coords = set()
    pixel_set = set(pixels) # For efficient checking if a neighbor belongs to the object itself

    for r, c in pixels:
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue # Skip self
                
                nr, nc = r + dr, c + dc
                
                # Check boundaries and ensure it's not part of the object itself
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in pixel_set:
                    adjacent_coords.add((nr, nc))
                    
    return adjacent_coords


def transform(input_grid):
    """
    Transforms the input grid by keeping the largest green object and its adjacent objects.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # 1. Identify all distinct objects
    all_objects = find_objects(input_grid)
    
    # 2. Find all green objects
    green_objects = [obj for obj in all_objects if obj['color'] == 3]
    
    # Handle case where there are no green objects
    if not green_objects:
        # If no green object, maybe clear everything or return input?
        # Examples suggest a green object exists. Let's assume it does.
        # If strict adherence to rule needed for no green object, could return all white.
        # For now, let's proceed assuming one exists as per examples.
        # Alternative: return np.zeros_like(input_grid)
         return input_grid # Or maybe raise an error? Or return all white grid?

    # 3. Find the largest green object
    largest_green_object = max(green_objects, key=lambda obj: len(obj['pixels']))
    largest_green_pixels_set = set(largest_green_object['pixels'])

    # 4. Determine the adjacency zone around the largest green object
    adjacency_zone = get_adjacent_pixels(largest_green_pixels_set, (height, width))
    
    # 5. Iterate through all objects and remove non-adjacent ones (excluding the largest green)
    objects_to_remove = []
    for obj in all_objects:
        current_obj_pixels_set = set(obj['pixels'])
        
        # Skip the largest green object itself
        if current_obj_pixels_set == largest_green_pixels_set:
            continue
            
        # Check if any pixel of the current object is in the adjacency zone
        is_adjacent = False
        for pixel in current_obj_pixels_set:
            if pixel in adjacency_zone:
                is_adjacent = True
                break
        
        # If the object is not adjacent, mark it for removal
        if not is_adjacent:
            objects_to_remove.append(obj)

    # 6. Modify the output grid by removing marked objects
    for obj in objects_to_remove:
        for r, c in obj['pixels']:
            output_grid[r, c] = 0 # Change to white background color

    return output_grid
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Identify the largest green object (color 3). 
Retain this object and any other object that is directly adjacent (including diagonals) to it.
Remove all other objects by changing their pixels to white (0).
"""

def find_objects(grid):
    """
    Identifies all connected objects of the same non-white color in the grid.

    Args:
        grid: A numpy array representing the input grid.

    Returns:
        A list of dictionaries, where each dictionary represents an object
        with keys 'color' (int) and 'pixels' (list of (row, col) tuples).
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(height):
        for c in range(width):
            # If the pixel is not white (0), hasn't been visited, start BFS
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    obj_pixels.append((row, col))
                    
                    # Check 8 neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue # Skip self
                            
                            nr, nc = row + dr, col + dc
                            
                            # Check boundaries
                            if 0 <= nr < height and 0 <= nc < width:
                                # Check if neighbor is same color and not visited
                                if grid[nr, nc] == color and not visited[nr, nc]:
                                    visited[nr, nc] = True
                                    q.append((nr, nc))
                                    
                objects.append({'color': color, 'pixels': obj_pixels})
                
    return objects

def get_adjacent_pixels(pixels, grid_shape):
    """
    Finds all unique pixels adjacent (including diagonals) to a given set of pixels.

    Args:
        pixels: A list or set of (row, col) tuples representing the object's pixels.
        grid_shape: A tuple (height, width) of the grid.

    Returns:
        A set of (row, col) tuples representing adjacent pixel coordinates.
    """
    height, width = grid_shape
    adjacent_coords = set()
    pixel_set = set(pixels) # For efficient checking if a neighbor belongs to the object itself

    for r, c in pixels:
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue # Skip self
                
                nr, nc = r + dr, c + dc
                
                # Check boundaries and ensure it's not part of the object itself
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in pixel_set:
                    adjacent_coords.add((nr, nc))
                    
    return adjacent_coords


def transform(input_grid):
    """
    Transforms the input grid by keeping the largest green object and its adjacent objects.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # 1. Identify all distinct objects
    all_objects = find_objects(input_grid)
    
    # 2. Find all green objects
    green_objects = [obj for obj in all_objects if obj['color'] == 3]
    
    # Handle case where there are no green objects
    if not green_objects:
        # If no green object, maybe clear everything or return input?
        # Examples suggest a green object exists. Let's assume it does.
        # If strict adherence to rule needed for no green object, could return all white.
        # For now, let's proceed assuming one exists as per examples.
        # Alternative: return np.zeros_like(input_grid)
         return input_grid # Or maybe raise an error? Or return all white grid?

    # 3. Find the largest green object
    largest_green_object = max(green_objects, key=lambda obj: len(obj['pixels']))
    largest_green_pixels_set = set(largest_green_object['pixels'])

    # 4. Determine the adjacency zone around the largest green object
    adjacency_zone = get_adjacent_pixels(largest_green_pixels_set, (height, width))
    
    # 5. Iterate through all objects and remove non-adjacent ones (excluding the largest green)
    objects_to_remove = []
    for obj in all_objects:
        current_obj_pixels_set = set(obj['pixels'])
        
        # Skip the largest green object itself
        if current_obj_pixels_set == largest_green_pixels_set:
            continue
            
        # Check if any pixel of the current object is in the adjacency zone
        is_adjacent = False
        for pixel in current_obj_pixels_set:
            if pixel in adjacency_zone:
                is_adjacent = True
                break
        
        # If the object is not adjacent, mark it for removal
        if not is_adjacent:
            objects_to_remove.append(obj)

    # 6. Modify the output grid by removing marked objects
    for obj in objects_to_remove:
        for r, c in obj['pixels']:
            output_grid[r, c] = 0 # Change to white background color

    return output_grid
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 6 6 6 6 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 6 6 6 6 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 16
Size Correct: True
Color Palette Correct: False
Color Count Correct: False
Score: 32.65306122448976

## Example 2:
Input:
```
0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 10
Size Correct: True
Color Palette Correct: False
Color Count Correct: False
Score: 14.035087719298247

## Example 3:
Input:
```
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 10
Size Correct: True
Color Palette Correct: False
Color Count Correct: False
Score: 20.408163265306086
*   **General Assessment:**
    *   The previous attempt failed because the underlying logic was incorrect. The code successfully implemented the "keep adjacent objects" rule, but the examples showed this rule was wrong.
    *   The failure analysis revealed that objects adjacent to the top and bottom of the largest green object were removed, while objects adjacent to the sides (within the same row span) were kept.
    *   A new hypothesis was formulated: Keep the largest green object, and keep any other object *only if* its entire vertical extent (min\_row to max\_row) falls within the vertical extent of the largest green object.

*   **Strategy:**
    *   Refine the object identification process to calculate the min/max row for each object.
    *   Identify the largest green object and its min/max rows (`min_ref_row`, `max_ref_row`).
    *   Create a new blank output grid.
    *   Iterate through all identified objects. If an object is the largest green object OR if its `min_row >= min_ref_row` and `max_row <= max_ref_row`, draw it onto the output grid.

*   **Metrics Calculation & Verification:**
    *   The provided code execution (`code_execution` block) was used to analyze the input/output pairs based on the *new* hypothesis (vertical containment).
    *   It confirmed the largest green object's row ranges for each example: Ex1 (4, 9), Ex2 (1, 13), Ex3 (3, 9).
    *   It verified that the objects kept in the expected output either *are* the largest green object or have row ranges strictly within the corresponding green object's range.
    *   It verified that the objects removed from the input either have rows entirely outside the range or span rows both inside and outside the range.
    *   The new hypothesis correctly explains the transformation for all three training examples.


*code_execution:*
```python
import numpy as np
from collections import deque

# Helper function to find objects, now including min/max row calculation
def find_objects(grid):
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    for r in range(height):
        for c in range(width):
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                min_r, max_r = r, r
                while q:
                    row, col = q.popleft()
                    obj_pixels.append((row, col))
                    min_r = min(min_r, row)
                    max_r = max(max_r, row)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0: continue
                            nr, nc = row + dr, col + dc
                            if 0 <= nr < height and 0 <= nc < width:
                                if grid[nr, nc] == color and not visited[nr, nc]:
                                    visited[nr, nc] = True
                                    q.append((nr, nc))
                objects.append({
                    'color': color, 
                    'pixels': obj_pixels, 
                    'size': len(obj_pixels),
                    'min_row': min_r,
                    'max_row': max_r
                })
    return objects

# Example 1 Data
input_1 = np.array([
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,3,3,3,3,3,3,0,0,0,0],
    [0,0,0,5,3,3,3,3,3,3,4,0,0,0],
    [0,5,5,5,3,3,3,3,3,3,4,4,4,0],
    [0,5,5,5,3,3,3,3,3,3,4,4,4,0],
    [0,0,0,5,3,3,3,3,3,3,4,0,0,0],
    [0,0,0,0,3,3,3,3,3,3,0,0,0,0],
    [0,0,0,0,0,6,6,6,6,0,0,0,0,0],
    [0,0,0,0,0,0,6,6,0,0,0,0,0,0],
    [0,0,0,0,0,0,6,6,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])

# Example 2 Data
input_2 = np.array([
    [0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,3,0,0,0,0,0,3,0,0,0,0,0,0],
    [0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0],
    [0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0],
    [0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0],
    [0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0],
    [0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0],
    [0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0],
    [0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,3,1,0,0],
    [0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0],
    [0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0],
    [0,0,0,0,0,0,3,0,0,0,0,0,3,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,0,0,0]
])

# Example 3 Data
input_3 = np.array([
    [0,0,0,0,2,0,0,0,2,0,0,0,0,0],
    [0,0,0,0,0,2,0,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,3,0,0,0,0,0,0,0],
    [8,0,0,0,0,3,3,3,0,0,0,0,1,0],
    [0,8,0,0,3,3,3,3,3,0,0,1,0,0],
    [0,0,8,3,3,3,3,3,3,3,1,0,0,0],
    [0,8,0,0,3,3,3,3,3,0,0,1,0,0],
    [8,0,0,0,0,3,3,3,0,0,0,0,1,0],
    [0,0,0,0,0,0,3,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,6,0,0,0,0,0,0,0],
    [0,0,0,0,0,6,0,6,0,0,0,0,0,0],
    [0,0,0,0,6,0,0,0,6,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
])

# Analyze each example
results = {}
for i, input_grid in enumerate([input_1, input_2, input_3], 1):
    example_results = {}
    all_objects = find_objects(input_grid)
    example_results['num_objects'] = len(all_objects)
    
    green_objects = [obj for obj in all_objects if obj['color'] == 3]
    if not green_objects:
        example_results['largest_green_object'] = None
        example_results['green_row_range'] = None
        example_results['objects_summary'] = [{'color': obj['color'], 'min_row': obj['min_row'], 'max_row': obj['max_row']} for obj in all_objects]
    else:
        # Handle potential ties deterministically (e.g., by lowest min_row, then lowest min_col of first pixel)
        largest_green_object = max(green_objects, key=lambda obj: obj['size']) 
        example_results['largest_green_object_size'] = largest_green_object['size']
        
        min_ref_row, max_ref_row = largest_green_object['min_row'], largest_green_object['max_row']
        example_results['green_row_range'] = (min_ref_row, max_ref_row)
        
        summary = []
        for obj in all_objects:
            is_largest_green = obj['pixels'] == largest_green_object['pixels'] # Compare pixels lists/sets
            within_range = (obj['min_row'] >= min_ref_row and obj['max_row'] <= max_ref_row)
            kept = is_largest_green or within_range
            summary.append({
                'color': obj['color'], 
                'obj_row_range': (obj['min_row'], obj['max_row']),
                'is_largest_green': is_largest_green,
                'is_within_range': within_range,
                'kept': kept
            })
        example_results['objects_summary'] = summary
        
    results[f'example_{i}'] = example_results

import json
print(json.dumps(results, indent=2, default=str)) # Use json for cleaner printing of numpy types if any remain
```

*code_execution_result:*
outcome: OUTCOME_OK
```
{
  "example_1": {
    "num_objects": 5,
    "largest_green_object_size": 36,
    "green_row_range": [
      4,
      9
    ],
    "objects_summary": [
      {
        "color": "1",
        "obj_row_range": [
          1,
          3
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      },
      {
        "color": "3",
        "obj_row_range": [
          4,
          9
        ],
        "is_largest_green": true,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "5",
        "obj_row_range": [
          5,
          8
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "4",
        "obj_row_range": [
          5,
          8
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "6",
        "obj_row_range": [
          10,
          12
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      }
    ]
  },
  "example_2": {
    "num_objects": 5,
    "largest_green_object_size": 32,
    "green_row_range": [
      1,
      13
    ],
    "objects_summary": [
      {
        "color": "2",
        "obj_row_range": [
          0,
          0
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      },
      {
        "color": "3",
        "obj_row_range": [
          1,
          13
        ],
        "is_largest_green": true,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "7",
        "obj_row_range": [
          5,
          9
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "1",
        "obj_row_range": [
          5,
          9
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "4",
        "obj_row_range": [
          14,
          14
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      }
    ]
  },
  "example_3": {
    "num_objects": 5,
    "largest_green_object_size": 25,
    "green_row_range": [
      3,
      9
    ],
    "objects_summary": [
      {
        "color": "2",
        "obj_row_range": [
          0,
          2
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      },
      {
        "color": "3",
        "obj_row_range": [
          3,
          9
        ],
        "is_largest_green": true,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "8",
        "obj_row_range": [
          4,
          8
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "1",
        "obj_row_range": [
          4,
          8
        ],
        "is_largest_green": false,
        "is_within_range": true,
        "kept": true
      },
      {
        "color": "6",
        "obj_row_range": [
          10,
          12
        ],
        "is_largest_green": false,
        "is_within_range": false,
        "kept": false
      }
    ]
  }
}

```
*   **YAML Facts:**


```yaml
task_description: Retain the largest green object and any other object whose vertical extent (all rows it occupies) is fully contained within the vertical extent of the largest green object.

elements:
  - role: background
    color: white (0)
  - role: objects
    description: Contiguous blocks of non-white pixels.
    properties:
      - color: integer (1-9)
      - pixels: list of (row, col) tuples
      - size: count of pixels
      - is_green: boolean (color == 3)
      - is_largest_green: boolean (largest size among green objects, determined during transformation)
      - min_row: minimum row index occupied by the object's pixels
      - max_row: maximum row index occupied by the object's pixels

transformation:
  - step: 1
    action: Identify all distinct objects in the input grid. For each object, determine its color, pixels, size, min_row, and max_row.
  - step: 2
    action: Filter the identified objects to find all green objects (color == 3).
  - step: 3
    condition: If no green objects exist.
    action: Return an output grid of the same dimensions as the input, filled entirely with the background color (white, 0).
  - step: 4
    condition: If green objects exist.
    action: Identify the green object with the maximum size ('largest_green_object'). Handle ties deterministically (e.g., select the first one encountered during the object finding process).
  - step: 5
    action: Determine the minimum row ('min_ref_row') and maximum row ('max_ref_row') occupied by the 'largest_green_object'.
  - step: 6
    action: Create a new output grid of the same dimensions as the input, initialized entirely with the background color (white, 0).
  - step: 7
    action: Iterate through all objects identified in Step 1.
    condition: Check if the current object meets the keep criteria: (is the 'largest_green_object') OR (its 'min_row' >= 'min_ref_row' AND its 'max_row' <= 'max_ref_row').
    effect: If the condition is true, iterate through the object's 'pixels' and set the corresponding (row, col) in the output grid to the object's 'color'.
  - step: 8
    action: Return the final output grid.

relationships:
  - type: vertical_containment
    description: An object 'A' is vertically contained by object 'B' if A.min_row >= B.min_row and A.max_row <= B.max_row.
  - type: selection_criterion
    description: Objects are kept (drawn onto the output grid) if they are the largest green object OR if they are vertically contained within the largest green object's row range. Objects not meeting this criterion are implicitly removed because the output grid starts blank.
```


*   **Natural Language Program:**

1.  Identify all separate objects in the input grid, where an object is a connected group of pixels of the same non-white color. For each object, note its color, its size (number of pixels), and the lowest and highest row numbers it occupies.
2.  Find all the objects that are green (color 3).
3.  If there are no green objects, create a new grid the same size as the input, fill it with white (color 0), and this is the final output.
4.  If there are green objects, select the one with the largest size. Call this the 'primary green object'. (If there's a tie for largest size, pick one consistently, like the first one found).
5.  Note the lowest row number (`min_ref_row`) and the highest row number (`max_ref_row`) occupied by the 'primary green object'.
6.  Create a new grid the same size as the input and fill it entirely with white (color 0). This will become the output grid.
7.  Examine every object identified in step 1:
    a.  Check if the current object is the 'primary green object'.
    b.  If not, check if its lowest row number is equal to or greater than `min_ref_row` AND its highest row number is equal to or less than `max_ref_row`.
    c.  If the object is the 'primary green object' OR if it satisfies the row condition in step 7b, then for each pixel belonging to this object, set the pixel at the same coordinate in the output grid to this object's color.
8.  The final output is the grid constructed in steps 6 and 7.
