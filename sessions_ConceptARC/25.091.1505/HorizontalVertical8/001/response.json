{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the largest green object (color 3). \nRetain this object and any other object that is directly adjacent (including diagonals) to it.\nRemove all other objects by changing their pixels to white (0).\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies all connected objects of the same non-white color in the grid.\n\n    Args:\n        grid: A numpy array representing the input grid.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys 'color' (int) and 'pixels' (list of (row, col) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            # If the pixel is not white (0), hasn't been visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue # Skip self\n                            \n                            nr, nc = row + dr, col + dc\n                            \n                            # Check boundaries\n                            if 0 <= nr < height and 0 <= nc < width:\n                                # Check if neighbor is same color and not visited\n                                if grid[nr, nc] == color and not visited[nr, nc]:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                                    \n                objects.append({'color': color, 'pixels': obj_pixels})\n                \n    return objects\n\ndef get_adjacent_pixels(pixels, grid_shape):\n    \"\"\"\n    Finds all unique pixels adjacent (including diagonals) to a given set of pixels.\n\n    Args:\n        pixels: A list or set of (row, col) tuples representing the object's pixels.\n        grid_shape: A tuple (height, width) of the grid.\n\n    Returns:\n        A set of (row, col) tuples representing adjacent pixel coordinates.\n    \"\"\"\n    height, width = grid_shape\n    adjacent_coords = set()\n    pixel_set = set(pixels) # For efficient checking if a neighbor belongs to the object itself\n\n    for r, c in pixels:\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue # Skip self\n                \n                nr, nc = r + dr, c + dc\n                \n                # Check boundaries and ensure it's not part of the object itself\n                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in pixel_set:\n                    adjacent_coords.add((nr, nc))\n                    \n    return adjacent_coords\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by keeping the largest green object and its adjacent objects.\n\n    Args:\n        input_grid: A numpy array representing the input grid.\n\n    Returns:\n        A numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # 1. Identify all distinct objects\n    all_objects = find_objects(input_grid)\n    \n    # 2. Find all green objects\n    green_objects = [obj for obj in all_objects if obj['color'] == 3]\n    \n    # Handle case where there are no green objects\n    if not green_objects:\n        # If no green object, maybe clear everything or return input?\n        # Examples suggest a green object exists. Let's assume it does.\n        # If strict adherence to rule needed for no green object, could return all white.\n        # For now, let's proceed assuming one exists as per examples.\n        # Alternative: return np.zeros_like(input_grid)\n         return input_grid # Or maybe raise an error? Or return all white grid?\n\n    # 3. Find the largest green object\n    largest_green_object = max(green_objects, key=lambda obj: len(obj['pixels']))\n    largest_green_pixels_set = set(largest_green_object['pixels'])\n\n    # 4. Determine the adjacency zone around the largest green object\n    adjacency_zone = get_adjacent_pixels(largest_green_pixels_set, (height, width))\n    \n    # 5. Iterate through all objects and remove non-adjacent ones (excluding the largest green)\n    objects_to_remove = []\n    for obj in all_objects:\n        current_obj_pixels_set = set(obj['pixels'])\n        \n        # Skip the largest green object itself\n        if current_obj_pixels_set == largest_green_pixels_set:\n            continue\n            \n        # Check if any pixel of the current object is in the adjacency zone\n        is_adjacent = False\n        for pixel in current_obj_pixels_set:\n            if pixel in adjacency_zone:\n                is_adjacent = True\n                break\n        \n        # If the object is not adjacent, mark it for removal\n        if not is_adjacent:\n            objects_to_remove.append(obj)\n\n    # 6. Modify the output grid by removing marked objects\n    for obj in objects_to_remove:\n        for r, c in obj['pixels']:\n            output_grid[r, c] = 0 # Change to white background color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4693,
    "candidates_token_count": 1394,
    "total_token_count": 6087,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.421794,
  "retries": 1
}