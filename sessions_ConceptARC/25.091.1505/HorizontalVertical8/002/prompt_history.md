
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 0 0 0 0 0
0 0 0 0 0 1 1 1 1 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 6 6 6 6 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 6 6 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 5 5 5 3 3 3 3 3 3 4 4 4 0
0 0 0 5 3 3 3 3 3 3 4 0 0 0
0 0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 4 4 4 4 4 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 7 3 0 0 0 0 0 0 0 0 0 0 0 3 1 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 0 3 0 0 0 0 0 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0
0 0 0 0 0 0 0 3 3 3 3 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
0 0 8 3 3 3 3 3 3 3 1 0 0 0
0 8 0 0 3 3 3 3 3 0 0 1 0 0
8 0 0 0 0 3 3 3 0 0 0 0 1 0
0 0 0 0 0 0 3 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

*   **Perception of task elements:**
    *   The input grids contain a background of white pixels (0) and several distinct objects composed of contiguous pixels of the same color (non-white).
    *   In each example, there is one prominent green object (color 3) which appears to be the largest or most central object.
    *   Other objects of various colors are scattered around the grid.
    *   The output grids retain the central green object and some of the other objects, while the remaining objects are removed (replaced with white pixels).
    *   The key transformation seems to involve identifying the central green object and then selectively removing other objects based on their spatial relationship to it. Specifically, objects that are *not* adjacent (including diagonally) to the central green object are removed.

*   **YAML Facts:**
    
```yaml
    task_description: Retain the largest green object and any other object directly adjacent (including diagonals) to it, removing all other objects.

    elements:
      - role: background
        color: white (0)
      - role: objects
        description: Contiguous blocks of non-white pixels.
        properties:
          - color: (1-9)
          - pixels: list of (row, col) tuples
          - size: count of pixels
          - is_green: boolean (color == 3)
          - is_largest_green: boolean (largest size among green objects)
          - adjacent_to_largest_green: boolean (shares a side or corner with any pixel of the largest green object)

    transformation:
      - step: 1
        action: Identify all distinct objects (contiguous non-white areas).
      - step: 2
        action: Find the green object with the maximum number of pixels. Designate this as the 'central_object'.
      - step: 3
        action: Create an output grid initialized as a copy of the input grid.
      - step: 4
        action: Iterate through all identified objects.
        condition: For each object that is NOT the 'central_object'.
        sub_step: a
          action: Check if any pixel of the current object is adjacent (8-connectivity: horizontal, vertical, or diagonal) to any pixel of the 'central_object'.
        sub_step: b
          action: If the object is NOT adjacent to the 'central_object'.
          effect: Change all pixels belonging to this object in the output grid to white (0).
      - step: 5
        action: Return the modified output grid.

    relationships:
      - type: adjacency
        definition: Two pixels are adjacent if they share a side or a corner (8-connectivity).
      - type: selection_criterion
        description: Objects are kept if they are the largest green object OR if they are adjacent to the largest green object. Objects not meeting this criterion are removed.
    ```


*   **Natural Language Program:**
    1.  Identify all connected components (objects) formed by contiguous pixels of the same non-white color in the input grid.
    2.  Among the objects identified in step 1, find all objects whose color is green (3).
    3.  Determine the green object that has the largest number of pixels. This is the 'central green object'.
    4.  Initialize the output grid as a copy of the input grid.
    5.  For every object identified in step 1:
        a.  If the object is the 'central green object', proceed to the next object.
        b.  If the object is not the 'central green object', check if any pixel within this object is adjacent (horizontally, vertically, or diagonally) to any pixel within the 'central green object'.
        c.  If no pixel of the current object is adjacent to the 'central green object', then update the output grid by changing all pixels corresponding to this object's location to white (0).
    6.  The final state of the output grid represents the result.
```python
import numpy as np
from collections import deque

"""
Identify the largest green object (color 3). 
Retain this object and any other object that is directly adjacent (including diagonals) to it.
Remove all other objects by changing their pixels to white (0).
"""

def find_objects(grid):
    """
    Identifies all connected objects of the same non-white color in the grid.

    Args:
        grid: A numpy array representing the input grid.

    Returns:
        A list of dictionaries, where each dictionary represents an object
        with keys 'color' (int) and 'pixels' (list of (row, col) tuples).
    """
    height, width = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []
    
    for r in range(height):
        for c in range(width):
            # If the pixel is not white (0), hasn't been visited, start BFS
            if grid[r, c] != 0 and not visited[r, c]:
                color = grid[r, c]
                obj_pixels = []
                q = deque([(r, c)])
                visited[r, c] = True
                
                while q:
                    row, col = q.popleft()
                    obj_pixels.append((row, col))
                    
                    # Check 8 neighbors (including diagonals)
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue # Skip self
                            
                            nr, nc = row + dr, col + dc
                            
                            # Check boundaries
                            if 0 <= nr < height and 0 <= nc < width:
                                # Check if neighbor is same color and not visited
                                if grid[nr, nc] == color and not visited[nr, nc]:
                                    visited[nr, nc] = True
                                    q.append((nr, nc))
                                    
                objects.append({'color': color, 'pixels': obj_pixels})
                
    return objects

def get_adjacent_pixels(pixels, grid_shape):
    """
    Finds all unique pixels adjacent (including diagonals) to a given set of pixels.

    Args:
        pixels: A list or set of (row, col) tuples representing the object's pixels.
        grid_shape: A tuple (height, width) of the grid.

    Returns:
        A set of (row, col) tuples representing adjacent pixel coordinates.
    """
    height, width = grid_shape
    adjacent_coords = set()
    pixel_set = set(pixels) # For efficient checking if a neighbor belongs to the object itself

    for r, c in pixels:
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue # Skip self
                
                nr, nc = r + dr, c + dc
                
                # Check boundaries and ensure it's not part of the object itself
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in pixel_set:
                    adjacent_coords.add((nr, nc))
                    
    return adjacent_coords


def transform(input_grid):
    """
    Transforms the input grid by keeping the largest green object and its adjacent objects.

    Args:
        input_grid: A numpy array representing the input grid.

    Returns:
        A numpy array representing the transformed output grid.
    """
    # Initialize output_grid as a copy of the input
    output_grid = np.copy(input_grid)
    height, width = input_grid.shape
    
    # 1. Identify all distinct objects
    all_objects = find_objects(input_grid)
    
    # 2. Find all green objects
    green_objects = [obj for obj in all_objects if obj['color'] == 3]
    
    # Handle case where there are no green objects
    if not green_objects:
        # If no green object, maybe clear everything or return input?
        # Examples suggest a green object exists. Let's assume it does.
        # If strict adherence to rule needed for no green object, could return all white.
        # For now, let's proceed assuming one exists as per examples.
        # Alternative: return np.zeros_like(input_grid)
         return input_grid # Or maybe raise an error? Or return all white grid?

    # 3. Find the largest green object
    largest_green_object = max(green_objects, key=lambda obj: len(obj['pixels']))
    largest_green_pixels_set = set(largest_green_object['pixels'])

    # 4. Determine the adjacency zone around the largest green object
    adjacency_zone = get_adjacent_pixels(largest_green_pixels_set, (height, width))
    
    # 5. Iterate through all objects and remove non-adjacent ones (excluding the largest green)
    objects_to_remove = []
    for obj in all_objects:
        current_obj_pixels_set = set(obj['pixels'])
        
        # Skip the largest green object itself
        if current_obj_pixels_set == largest_green_pixels_set:
            continue
            
        # Check if any pixel of the current object is in the adjacency zone
        is_adjacent = False
        for pixel in current_obj_pixels_set:
            if pixel in adjacency_zone:
                is_adjacent = True
                break
        
        # If the object is not adjacent, mark it for removal
        if not is_adjacent:
            objects_to_remove.append(obj)

    # 6. Modify the output grid by removing marked objects
    for obj in objects_to_remove:
        for r, c in obj['pixels']:
            output_grid[r, c] = 0 # Change to white background color

    return output_grid
```
