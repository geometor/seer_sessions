{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify all separate contiguous regions (objects) of non-white pixels in the input grid, considering orthogonal and diagonal adjacency.\nFor each region, calculate the frequency of each color within it and determine the maximum frequency of any single color.\nSelect the region(s) with the highest maximum color frequency across all regions.\nIf there is a tie (multiple regions share the same highest maximum color frequency), select the region among the tied ones that extends furthest to the right (has the largest maximum column index).\nCreate an output grid of the same dimensions as the input, filled with the background color (white, 0).\nCopy the pixels of the finally selected region onto the output grid at their original positions.\n\"\"\"\n\ndef find_regions(grid, background_color=0):\n    \"\"\"\n    Finds all contiguous regions of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list: A list of regions, where each region is a list of\n              (row, col, color) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    regions = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel is not background and not visited yet\n            if grid[r, c] != background_color and not visited[r, c]:\n                current_region = []\n                q = [(r, c)]  # Queue for BFS\n                visited[r, c] = True\n\n                while q:\n                    row, col = q.pop(0)\n                    color = grid[row, col]\n                    current_region.append((row, col, color))\n\n                    # Check all 8 neighbors (orthogonal and diagonal)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue  # Skip self\n\n                            nr, nc = row + dr, col + dc\n\n                            # Check bounds\n                            if 0 <= nr < rows and 0 <= nc < cols:\n                                # Check if neighbor is part of the object and not visited\n                                if grid[nr, nc] != background_color and not visited[nr, nc]:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n                \n                if current_region:\n                    regions.append(current_region)\n    return regions\n\ndef calculate_region_properties(region):\n    \"\"\"\n    Calculates properties for a single region.\n\n    Args:\n        region (list): A list of (row, col, color) tuples for the region.\n\n    Returns:\n        dict: A dictionary containing properties:\n              'pixels': the input region list,\n              'max_color_frequency': highest frequency of a single color,\n              'rightmost_column': the maximum column index.\n              Returns None if region is empty.\n    \"\"\"\n    if not region:\n        return None\n\n    colors = [pixel[2] for pixel in region]\n    cols = [pixel[1] for pixel in region]\n\n    if not colors: # Should not happen if region is not empty, but safety check\n         return {'pixels': region, 'max_color_frequency': 0, 'rightmost_column': -1}\n\n\n    color_counts = Counter(colors)\n    max_color_frequency = 0\n    if color_counts:\n        max_color_frequency = max(color_counts.values())\n\n    rightmost_column = -1\n    if cols:\n        rightmost_column = max(cols)\n\n    return {\n        'pixels': region,\n        'max_color_frequency': max_color_frequency,\n        'rightmost_column': rightmost_column\n    }\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    background_color = 0\n\n    # Initialize output grid with background color\n    output_array = np.full_like(input_array, background_color)\n\n    # 1. Identify all non-background regions\n    regions = find_regions(input_array, background_color)\n\n    # If no regions found, return the empty grid\n    if not regions:\n        return output_array.tolist()\n\n    # 2. Calculate properties for each region\n    region_properties = [calculate_region_properties(r) for r in regions]\n    \n    # Handle potential None values if empty regions were somehow generated\n    region_properties = [prop for prop in region_properties if prop is not None]\n    \n    if not region_properties:\n        return output_array.tolist()\n\n\n    # 3. Find the overall highest maximum color frequency\n    overall_max_freq = 0\n    if region_properties:\n      overall_max_freq = max(prop['max_color_frequency'] for prop in region_properties)\n\n\n    # 4. Identify primary candidates (those with the overall highest frequency)\n    primary_candidates = [prop for prop in region_properties if prop['max_color_frequency'] == overall_max_freq]\n\n    # 5. Select the final region\n    selected_region_prop = None\n    if len(primary_candidates) == 1:\n        # a. If only one region has the max frequency, select it\n        selected_region_prop = primary_candidates[0]\n    elif len(primary_candidates) > 1:\n        # b. If multiple regions tie, use the tie-breaker (rightmost column)\n        max_rightmost_col = -1\n        # Find the maximum rightmost column among the tied candidates\n        max_rightmost_col = max(prop['rightmost_column'] for prop in primary_candidates)\n        \n        # Select the candidate(s) that match this max rightmost column\n        # Although the prompt implies a single winner, we'll handle potential further ties by picking the first one.\n        # In practice, based on examples, it seems a unique winner is expected after the tiebreaker.\n        final_candidates = [prop for prop in primary_candidates if prop['rightmost_column'] == max_rightmost_col]\n        selected_region_prop = final_candidates[0] # Pick the first one if there's still a tie\n\n    # 6. Create the output grid\n    if selected_region_prop:\n        selected_region_pixels = selected_region_prop['pixels']\n        # 7. Copy selected region pixels to the output grid\n        for r, c, color in selected_region_pixels:\n            output_array[r, c] = color\n\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3773,
    "candidates_token_count": 1618,
    "total_token_count": 5391,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.420844,
  "retries": 1
}