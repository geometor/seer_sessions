{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, center_of_mass\n\n\"\"\"\nIdentifies two distinct non-background objects in the input grid: a 'frame' object \n(a hollow shape enclosing a background area) and a 'content' object. \nCopies the 'content' object and places the copy centered within the background \narea enclosed by the 'frame' object, leaving the original objects unchanged.\n\"\"\"\n\ndef find_connected_components(grid, background_color=0):\n    \"\"\"\n    Finds connected components of non-background pixels.\n    Returns a list of objects, where each object is a tuple: \n    (mask, bounding_box_slice, unique_colors).\n    \"\"\"\n    binary_grid = grid != background_color\n    labeled_array, num_features = label(binary_grid)\n    \n    objects = []\n    if num_features > 0:\n        # find_objects returns a list of slice tuples\n        slices = find_objects(labeled_array) \n        for i in range(num_features):\n            component_label = i + 1\n            component_slice = slices[i]\n            # Create a mask for the current component within its bounding box\n            component_mask_full = labeled_array == component_label\n            component_mask_cropped = component_mask_full[component_slice]\n            # Get the actual grid values for this component\n            component_values = grid[component_mask_full]\n            unique_colors = np.unique(component_values)\n            \n            # Store mask relative to full grid, the slice, and colors\n            objects.append({\n                \"mask\": component_mask_full, \n                \"slice\": component_slice,\n                \"colors\": unique_colors,\n                \"label\": component_label\n                })\n            \n    # Sometimes adjacent objects of different colors might be desired as one.\n    # For this task, distinct components seem correct. Let's refine if needed.\n    return objects\n\ndef get_bounding_box(obj_slice):\n    \"\"\"Extracts min/max row/col from a slice tuple.\"\"\"\n    min_row, max_row = obj_slice[0].start, obj_slice[0].stop\n    min_col, max_col = obj_slice[1].start, obj_slice[1].stop\n    return min_row, min_col, max_row, max_col # Note: max is exclusive in slices\n\ndef is_frame(grid, obj):\n    \"\"\"\n    Determines if an object is a frame enclosing a background area.\n    Returns (is_frame_flag, inner_bounding_box_slice)\n    \"\"\"\n    mask = obj[\"mask\"]\n    obj_slice = obj[\"slice\"]\n    min_r, min_c, max_r, max_c = get_bounding_box(obj_slice)\n    \n    # Frame must have dimensions > 2 to enclose anything\n    if max_r - min_r <= 2 or max_c - min_c <= 2:\n        return False, None\n\n    # Define potential inner area (exclusive of border)\n    inner_slice = (slice(min_r + 1, max_r - 1), slice(min_c + 1, max_c - 1))\n    \n    # Check if inner slice is valid (non-empty)\n    if inner_slice[0].start >= inner_slice[0].stop or inner_slice[1].start >= inner_slice[1].stop:\n         return False, None\n\n    inner_area = grid[inner_slice]\n    inner_mask_part = mask[inner_slice] # Part of the object's mask within the inner area\n\n    # Check 1: All pixels within the inner area in the original grid must be background\n    if not np.all(inner_area == 0):\n        return False, None\n        \n    # Check 2: The object's mask should not cover any part of the *strict* inner area\n    # (This seems redundant with check 1 for single-color frames but good practice)\n    if np.any(inner_mask_part):\n         # This could happen if the \"frame\" filled itself in.\n         return False, None\n\n    # Check 3: The object pixels should form the border around this inner area\n    # Check pixels just outside the inner area are part of the object mask\n    frame_pixels_present = True\n    # Top border check (row = min_r)\n    if not np.all(mask[min_r, min_c:max_c]): frame_pixels_present = False\n    # Bottom border check (row = max_r - 1)\n    if not np.all(mask[max_r-1, min_c:max_c]): frame_pixels_present = False\n    # Left border check (col = min_c)\n    if not np.all(mask[min_r:max_r, min_c]): frame_pixels_present = False\n    # Right border check (col = max_c - 1)\n    if not np.all(mask[min_r:max_r, max_c-1]): frame_pixels_present = False\n    \n    # Simplified check: Check if the object touches all 4 sides of its bounding box\n    touches_top = np.any(mask[min_r, :])\n    touches_bottom = np.any(mask[max_r - 1, :])\n    touches_left = np.any(mask[:, min_c])\n    touches_right = np.any(mask[:, max_c - 1])\n\n    if not (touches_top and touches_bottom and touches_left and touches_right):\n         # A simple check, might fail for complex frames but ok for rectangles\n         # Let's rely on check 1 being the primary indicator for this task\n         pass # Allowing this to proceed based on check 1 for simplicity\n\n    # If all checks pass, it's a frame enclosing background\n    return True, inner_slice\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying the 'content' object into the center\n    of the 'frame' object's enclosed background area.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find all distinct non-background objects\n    objects = find_connected_components(output_grid)\n    \n    # Expecting exactly two primary components based on examples\n    if len(objects) != 2:\n        # Handle unexpected cases or return input? For ARC, often means simple copy if pattern fails.\n        # However, let's assume the structure holds based on training.\n        # A more robust solution might group adjacent components first.\n        print(f\"Warning: Expected 2 objects, found {len(objects)}. Proceeding may fail.\")\n        if len(objects) < 2: return output_grid # Cannot proceed\n\n    # 2. Identify the frame and content objects\n    frame_obj = None\n    content_obj = None\n    inner_frame_slice = None\n\n    for obj in objects:\n        is_obj_frame, inner_slice = is_frame(output_grid, obj)\n        if is_obj_frame:\n            if frame_obj is not None: \n                 # Found more than one frame? Ambiguous.\n                 print(\"Warning: Found multiple potential frame objects.\")\n                 return output_grid # Or handle ambiguity\n            frame_obj = obj\n            inner_frame_slice = inner_slice\n        else:\n            # Assume the non-frame is the content for now\n             if content_obj is not None:\n                 # Found more than one content? Ambiguous.\n                 print(\"Warning: Found multiple potential content objects.\")\n                 # Let's pick the first non-frame encountered. Might need refinement.\n             elif content_obj is None:\n                 content_obj = obj\n\n    # Check if we found one frame and one content object\n    if frame_obj is None or content_obj is None or inner_frame_slice is None:\n        print(\"Error: Could not definitively identify frame and content objects.\")\n        return output_grid # Return original if identification failed\n\n    # 3. Extract the content object's pattern\n    content_slice = content_obj[\"slice\"]\n    content_mask_full = content_obj[\"mask\"]\n    # Get the content data only where the mask is true, within its bounding box\n    content_pattern_full = np.where(content_mask_full, output_grid, 0) # Get colors on grid\n    content_pattern_cropped = content_pattern_full[content_slice] # Crop to bounding box\n    # We also need a mask relative to the cropped pattern\n    content_mask_cropped = content_mask_full[content_slice]\n\n    # 4. Calculate dimensions\n    content_height, content_width = content_pattern_cropped.shape\n    inner_frame_height = inner_frame_slice[0].stop - inner_frame_slice[0].start\n    inner_frame_width = inner_frame_slice[1].stop - inner_frame_slice[1].start\n\n    # 5. Calculate centered top-left placement coordinates\n    start_row = inner_frame_slice[0].start + (inner_frame_height - content_height) // 2\n    start_col = inner_frame_slice[1].start + (inner_frame_width - content_width) // 2\n\n    # 6. Copy the content pattern into the output grid\n    for r in range(content_height):\n        for c in range(content_width):\n            # Only copy if the pixel is part of the content object (using cropped mask)\n            if content_mask_cropped[r, c]:\n                output_grid[start_row + r, start_col + c] = content_pattern_cropped[r, c]\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3564,
    "candidates_token_count": 2261,
    "total_token_count": 5825,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.406767,
  "retries": 1
}