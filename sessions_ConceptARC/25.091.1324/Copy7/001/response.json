{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport copy\n\n# COLOR_MAP is not used in the logic but helpful for visualization/debugging\nCOLOR_MAP = {\n    0: (238, 238, 238),  # white / background\n    1: (30, 147, 255),  # blue\n    2: (220, 50, 40),  # red\n    3: (79, 204, 48),  # green\n    4: (230, 200, 0),  # yellow\n    5: (85, 85, 85),  # gray\n    6: (229, 58, 163),  # magenta\n    7: (230, 120, 20),  # orange\n    8: (135, 216, 241),  # azure\n    9: (146, 18, 49),  # maroon\n}\n\ndef find_objects_by_color(grid, exclude_color=0):\n    \"\"\"\n    Finds connected components (objects) of non-excluded colors in the grid.\n    Returns a list of objects, each represented as a list of (row, col) coordinates.\n    \"\"\"\n    objects = []\n    mask = grid != exclude_color\n    labeled_array, num_features = label(mask) # Uses 8-connectivity by default\n\n    if num_features == 0:\n        return objects\n\n    # Extract coordinates for each labeled object\n    object_slices = find_objects(labeled_array)\n    for i in range(num_features):\n        obj_label = i + 1\n        obj_coords = np.argwhere(labeled_array == obj_label)\n        objects.append(obj_coords.tolist()) # Store as list of [row, col] pairs\n\n    return objects\n\ndef get_object_properties(grid, obj_coords):\n    \"\"\"\n    Calculates properties for a given object (list of coordinates).\n    Returns min_row, min_col, max_row, max_col, and set of colors.\n    \"\"\"\n    if not obj_coords:\n        return None\n\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    colors = set(grid[r, c] for r, c in obj_coords)\n\n    return {\n        'min_row': min_row, 'max_row': max_row,\n        'min_col': min_col, 'max_col': max_col,\n        'colors': colors,\n        'coords': obj_coords # Keep coordinates for easy access\n    }\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies two primary objects (source and target) separated horizontally by the background color (0).\n    Finds a 'pattern' within the source object, defined as the pixels matching the numerically lowest non-background color present in the source object.\n    Copies this pattern to the target location by translating each pattern pixel horizontally.\n    The horizontal shift is determined by the difference in the minimum column index between the source and target objects.\n    The copied pattern pixels overwrite the existing pixels in the output grid at the translated coordinates, provided they are within the grid bounds.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n\n    # Find all distinct non-background objects\n    # We use scipy.ndimage.label for connected components\n    mask = input_np != background_color\n    labeled_array, num_features = label(mask)\n\n    if num_features < 2:\n        # Need at least two objects for source and target\n        return output_grid.tolist() # Return the original grid if condition not met\n\n    # Get properties for each object and determine their horizontal order\n    object_properties = []\n    object_slices = find_objects(labeled_array)\n    for i in range(num_features):\n        obj_label = i + 1\n        obj_slice = object_slices[i]\n        # Extract coordinates ONLY for this object's label within its slice\n        obj_coords_relative = np.argwhere(labeled_array[obj_slice] == obj_label)\n        # Convert relative coordinates back to absolute grid coordinates\n        obj_coords_absolute = [(r + obj_slice[0].start, c + obj_slice[1].start) for r, c in obj_coords_relative]\n\n        if not obj_coords_absolute: continue # Should not happen if find_objects worked correctly\n\n        props = get_object_properties(input_np, obj_coords_absolute)\n        if props:\n            object_properties.append(props)\n\n    if len(object_properties) < 2:\n         # Check again after potential filtering\n        return output_grid.tolist()\n\n    # Sort objects based on their minimum column index (left-to-right)\n    object_properties.sort(key=lambda x: x['min_col'])\n\n    # Assume the first is the source, the second is the target\n    source_obj = object_properties[0]\n    target_obj = object_properties[1]\n\n    # Identify the pattern color in the source object\n    # Rule: The pattern color is the numerically lowest color within the source object, excluding the background color.\n    source_colors = source_obj['colors']\n    if background_color in source_colors:\n         source_colors = source_colors - {background_color} # Use set difference\n\n    if not source_colors:\n        # Source object has no non-background colors? (Shouldn't happen with current finding logic)\n        return output_grid.tolist()\n\n    pattern_color = min(source_colors)\n\n    # Find all pixels in the source object that have the pattern color\n    pattern_pixels = []\n    for r, c in source_obj['coords']:\n        if input_np[r, c] == pattern_color:\n            pattern_pixels.append((r, c))\n\n    # Calculate the horizontal shift required to move pattern from source to target\n    # Based on the difference in the minimum column index of the two objects\n    min_col_source = source_obj['min_col']\n    min_col_target = target_obj['min_col']\n    delta_col = min_col_target - min_col_source\n\n    # Apply the transformation: copy pattern pixels to the target location\n    for r, c in pattern_pixels:\n        # Calculate the target coordinates\n        target_r = r\n        target_c = c + delta_col\n\n        # Check if the target coordinates are within the grid bounds\n        if 0 <= target_r < height and 0 <= target_c < width:\n            # Overwrite the pixel in the output grid with the pattern color\n            output_grid[target_r, target_c] = pattern_color\n\n    # Convert back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2071,
    "candidates_token_count": 1698,
    "total_token_count": 3769,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 138.034946,
  "retries": 2
}