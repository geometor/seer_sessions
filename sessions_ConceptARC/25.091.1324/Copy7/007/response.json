{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\nimport copy\n\n\"\"\"\nTransforms the input grid by copying a pattern from a source object to a target location.\n\nThe transformation follows these steps:\n1. Identify all connected groups of non-background (0) pixels (objects) using 8-way connectivity.\n2. If there are fewer than two objects, return the original grid unchanged.\n3. Identify the leftmost object (minimum starting column) as the 'source' and the rightmost object (maximum starting column) as the 'target'.\n4. Analyze the source object:\n    a. Count the occurrences of each non-background color within the source object.\n    b. Determine the most frequent non-background color ('frame_color').\n    c. Determine the numerically smallest non-background color that is *not* the frame_color ('pattern_color'). If no such color exists (e.g., the source only has one non-background color), return the original grid.\n5. Find all pixel coordinates within the source object that contain the 'pattern_color'. These are the 'pattern_pixels'.\n6. Calculate the horizontal translation required to move the pattern from the source's starting column to the target's starting column: `delta_col = target.min_col - source.min_col`.\n7. Create a copy of the input grid to serve as the output grid.\n8. For each pattern pixel coordinate (r_s, c_s):\n    a. Calculate the corresponding target coordinate: (target_r, target_c) = (r_s, c_s + delta_col).\n    b. Check if the target coordinate (target_r, target_c) is within the bounds of the grid.\n    c. If it is within bounds, update the *output grid* at (target_r, target_c) with the 'pattern_color', overwriting any existing value at that location.\n9. Return the modified output grid.\n\"\"\"\n\ndef find_regions(grid_np, background_color=0):\n    \"\"\"\n    Finds connected regions (objects) of non-background pixels using 8-way connectivity.\n\n    Args:\n        grid_np (np.array): The input grid as a NumPy array.\n        background_color (int): The color value considered background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a region\n              and contains 'coords' (set of (row, col) tuples), 'min_col',\n              'max_col', 'min_row', 'max_row'. Returns an empty list if no\n              non-background regions are found.\n    \"\"\"\n    mask = grid_np != background_color\n    # Use 8-way connectivity (default for label)\n    labeled_array, num_features = label(mask)\n\n    regions = []\n    if num_features == 0:\n        return regions\n\n    # Use find_objects to get bounding slices, then extract exact coordinates\n    object_slices = find_objects(labeled_array)\n\n    for i in range(num_features): # Labels are 1-based, index is 0-based\n        obj_label = i + 1\n        # Handle case where find_objects returns None for a label (shouldn't happen here)\n        if object_slices[i] is None: continue \n        obj_slice = object_slices[i]\n\n        # Extract coordinates ONLY for this object's label within its slice\n        coords_relative = np.argwhere(labeled_array[obj_slice] == obj_label)\n\n        # Convert relative coordinates back to absolute grid coordinates\n        coords_absolute = [(r + obj_slice[0].start, c + obj_slice[1].start) for r, c in coords_relative]\n\n        if not coords_absolute:\n            continue # Should not happen if find_objects worked correctly but good practice\n\n        coords_set = set(coords_absolute)\n        rows = [r for r, c in coords_absolute]\n        cols = [c for r, c in coords_absolute]\n\n        regions.append({\n            'coords': coords_set,\n            'min_row': np.min(rows),\n            'max_row': np.max(rows),\n            'min_col': np.min(cols),\n            'max_col': np.max(cols),\n            'label': obj_label # Keep track of the label if needed later\n        })\n\n    return regions\n\ndef get_region_colors_and_counts(grid_np, region_coords, background_color=0):\n    \"\"\"\n    Counts the occurrences of non-background colors within a region's coordinates.\n\n    Args:\n        grid_np (np.array): The grid.\n        region_coords (set): A set of (row, col) tuples for the region.\n        background_color (int): The background color to ignore.\n\n    Returns:\n        collections.Counter: A Counter object mapping non-background colors\n                             to their counts within the region.\n    \"\"\"\n    color_counts = Counter()\n    for r, c in region_coords:\n        # Ensure coordinates are within bounds (should be, but defensive check)\n        if 0 <= r < grid_np.shape[0] and 0 <= c < grid_np.shape[1]:\n            color = grid_np[r, c]\n            if color != background_color:\n                color_counts[color] += 1\n    return color_counts\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n\n    # 1. Identify all connected non-background regions (objects)\n    regions = find_regions(input_np, background_color)\n\n    # 2. Check if there are at least two objects (source and target)\n    if len(regions) < 2:\n        # Not enough objects to define source and target\n        return output_grid.tolist() \n\n    # 3. Identify Source (leftmost) and Target (rightmost) regions\n    # Sort regions based on their minimum column index (left-to-right)\n    regions.sort(key=lambda r: r['min_col'])\n    source_region = regions[0]\n    # Use the region with the largest min_col as target, robust to >2 regions\n    target_region = max(regions, key=lambda r: r['min_col']) \n    # Alternative: target_region = regions[-1] if sorting is guaranteed stable\n\n    # 4. Get colors and counts in the source region\n    source_colors_counts = get_region_colors_and_counts(input_np, source_region['coords'], background_color)\n\n    # Check if the source region actually contains non-background colors\n    if not source_colors_counts:\n        # Source region is empty or only background? Should not happen with find_regions logic\n         return output_grid.tolist() \n\n    # 5. Determine Source Frame Color (most frequent non-background color)\n    # Handle cases with only one color or ties (take the first one from most_common)\n    most_common = source_colors_counts.most_common(1)\n    if not most_common: # Should be covered by check above, but defensive\n         return output_grid.tolist()\n    source_frame_color = most_common[0][0] # color value\n\n    # 6. Determine Pattern Color (smallest non-background color != frame color)\n    pattern_color = None\n    # Get unique non-background colors present and sort them numerically\n    sorted_unique_colors = sorted(source_colors_counts.keys())\n\n    # Iterate through sorted colors to find the smallest one that isn't the frame color\n    for color in sorted_unique_colors:\n        if color != source_frame_color:\n            pattern_color = color\n            break # Found the smallest different color\n\n    # If no pattern color found (e.g., only one non-bg color exists in source)\n    if pattern_color is None:\n        # No distinct pattern color to copy\n         return output_grid.tolist() \n\n    # 7. Find Pattern Pixels in the source region\n    pattern_pixels = []\n    for r, c in source_region['coords']:\n        # Check the color at the coordinate in the original input grid\n        if input_np[r, c] == pattern_color:\n            pattern_pixels.append((r, c))\n\n    # If no pixels of the pattern color were found (shouldn't happen if pattern_color was set)\n    if not pattern_pixels:\n        return output_grid.tolist() \n\n    # 8. Calculate the horizontal translation vector (difference in starting columns)\n    delta_col = target_region['min_col'] - source_region['min_col']\n\n    # 9. Copy pattern pixels to the target location, overwriting existing pixels\n    for r_s, c_s in pattern_pixels:\n        # Calculate potential target coordinates\n        target_r = r_s\n        target_c = c_s + delta_col\n\n        # 10. Check if target coordinate is within the overall grid bounds\n        if 0 <= target_r < height and 0 <= target_c < width:\n            # Update the output grid with the pattern color, overwriting whatever was there\n            output_grid[target_r, target_c] = pattern_color\n\n    # Return the modified grid as a standard Python list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14819,
    "candidates_token_count": 2235,
    "total_token_count": 17054,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.006348,
  "retries": 1
}