{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on the following rules:\n1. Identify all connected groups of non-background (0) pixels (objects).\n2. If there are fewer than two objects, return the original grid.\n3. Identify the leftmost object as the source and the rightmost object as the target (based on minimum column index).\n4. Determine the most frequent non-background color in the source object (frame color).\n5. Determine the numerically smallest non-background color in the source object that is different from the frame color (pattern color). If none exists, return the original grid.\n6. Find all pixels in the source object matching the pattern color (pattern pixels).\n7. Calculate the horizontal shift required to align the start of the source object with the start of the target object.\n8. Create a copy of the input grid.\n9. For each pattern pixel, calculate its potential target position by applying the horizontal shift.\n10. If the target position is within the grid bounds AND within the bounding box of the target object, update the copied grid at that position with the pattern color.\n11. Return the modified grid.\n\"\"\"\n\ndef find_regions(grid_np, background_color=0):\n    \"\"\"\n    Finds connected regions (objects) of non-background pixels.\n\n    Args:\n        grid_np (np.array): The input grid as a NumPy array.\n        background_color (int): The color value considered background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a region\n              and contains 'coords' (set of (row, col) tuples), 'min_col',\n              'max_col', 'min_row', 'max_row'. Returns an empty list if no\n              non-background regions are found.\n    \"\"\"\n    mask = grid_np != background_color\n    # Use 8-way connectivity (default for label)\n    labeled_array, num_features = label(mask) \n\n    regions = []\n    if num_features == 0:\n        return regions\n\n    # Use find_objects to get bounding slices, then extract exact coordinates\n    object_slices = find_objects(labeled_array) \n    \n    for i in range(num_features): # Labels are 1-based, index is 0-based\n        obj_label = i + 1\n        obj_slice = object_slices[i]\n        \n        # Extract coordinates ONLY for this object's label within its slice\n        coords_relative = np.argwhere(labeled_array[obj_slice] == obj_label)\n        \n        # Convert relative coordinates back to absolute grid coordinates\n        coords_absolute = [(r + obj_slice[0].start, c + obj_slice[1].start) for r, c in coords_relative]\n        \n        if not coords_absolute: \n            continue # Should not happen if find_objects worked correctly but good practice\n\n        coords_set = set(coords_absolute)\n        rows = [r for r, c in coords_absolute]\n        cols = [c for r, c in coords_absolute]\n\n        regions.append({\n            'coords': coords_set,\n            'min_row': np.min(rows),\n            'max_row': np.max(rows),\n            'min_col': np.min(cols),\n            'max_col': np.max(cols),\n            'label': obj_label # Keep track of the label if needed later\n        })\n\n    return regions\n\ndef get_region_colors_and_counts(grid_np, region_coords, background_color=0):\n    \"\"\"\n    Counts the occurrences of non-background colors within a region's coordinates.\n\n    Args:\n        grid_np (np.array): The grid.\n        region_coords (set): A set of (row, col) tuples for the region.\n        background_color (int): The background color to ignore.\n\n    Returns:\n        collections.Counter: A Counter object mapping non-background colors\n                             to their counts within the region.\n    \"\"\"\n    color_counts = Counter()\n    for r, c in region_coords:\n        # Ensure coordinates are within bounds (should be, but defensive check)\n        if 0 <= r < grid_np.shape[0] and 0 <= c < grid_np.shape[1]:\n            color = grid_np[r, c]\n            if color != background_color:\n                color_counts[color] += 1\n    return color_counts\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_np = np.array(input_grid, dtype=int)\n    # Create a copy to modify, preserving the original input\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n\n    # 1. Identify all connected non-background regions (objects)\n    regions = find_regions(input_np, background_color)\n\n    # 2. Check if there are at least two objects (source and target)\n    if len(regions) < 2:\n        return output_grid.tolist() # Return original if not enough regions\n\n    # 3. Identify Source (leftmost) and Target (rightmost) regions\n    # Sort regions based on their minimum column index (left-to-right)\n    regions.sort(key=lambda r: r['min_col'])\n    source_region = regions[0]\n    # Assume the one with the largest min_col is the target, even if there are > 2 objects\n    target_region = regions[-1] \n\n    # 4. Get colors and counts in the source region\n    source_colors_counts = get_region_colors_and_counts(input_np, source_region['coords'], background_color)\n\n    # Check if the source region actually contains non-background colors\n    if not source_colors_counts:\n         return output_grid.tolist() \n\n    # 5. Determine Source Frame Color (most frequent non-background color)\n    # Handle cases with only one color or ties (take the first one from most_common)\n    most_common = source_colors_counts.most_common(1)\n    source_frame_color = most_common[0][0] if most_common else None # color value\n\n    # Check if a frame color was identified\n    if source_frame_color is None:\n         return output_grid.tolist() # Should not happen if source_colors_counts is not empty\n\n    # 6. Determine Pattern Color (smallest non-background color != frame color)\n    pattern_color = None\n    # Get unique non-background colors present and sort them numerically\n    sorted_unique_colors = sorted(source_colors_counts.keys())\n\n    # Iterate through sorted colors to find the smallest one that isn't the frame color\n    for color in sorted_unique_colors:\n        if color != source_frame_color:\n            pattern_color = color\n            break # Found the smallest different color\n\n    # If no pattern color found (e.g., only one non-bg color exists in source)\n    if pattern_color is None:\n         return output_grid.tolist() \n\n    # 7. Find Pattern Pixels in the source region\n    pattern_pixels = []\n    for r, c in source_region['coords']:\n        # Check the color at the coordinate in the original input grid\n        if input_np[r, c] == pattern_color:\n            pattern_pixels.append((r, c))\n\n    # If no pixels of the pattern color were found\n    if not pattern_pixels:\n        return output_grid.tolist() \n\n    # 8. Calculate the horizontal translation vector (difference in starting columns)\n    delta_col = target_region['min_col'] - source_region['min_col']\n\n    # 9. Get target region bounding box for efficient checking\n    target_min_r, target_max_r = target_region['min_row'], target_region['max_row']\n    target_min_c, target_max_c = target_region['min_col'], target_region['max_col']\n\n    # 10. Copy pattern pixels to the target area if applicable\n    for r_s, c_s in pattern_pixels:\n        # Calculate potential target coordinates\n        target_r = r_s\n        target_c = c_s + delta_col\n\n        # Check if target coordinate is within the overall grid bounds\n        if 0 <= target_r < height and 0 <= target_c < width:\n            # Check if the target coordinate falls within the target region's BOUNDING BOX\n            if target_min_r <= target_r <= target_max_r and \\\n               target_min_c <= target_c <= target_max_c:\n                # Update the output grid with the pattern color, overwriting original\n                output_grid[target_r, target_c] = pattern_color\n\n    # Return the modified grid as a standard Python list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13711,
    "candidates_token_count": 2106,
    "total_token_count": 15817,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.37134,
  "retries": 1
}