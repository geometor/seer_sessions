{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by identifying a source region (leftmost non-background object) and a target region (rightmost non-background object). It then identifies a \"pattern color\" within the source region, which is the numerically smallest color different from the most frequent color (frame color) in that region. This pattern (pixels of the pattern color) is then copied/translated horizontally from the source to the target region. The horizontal shift is determined by the difference in the minimum column indices of the two regions. The pattern pixels only overwrite pixels within the boundaries of the target region's identified coordinates.\n\"\"\"\n\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nfrom collections import Counter\nimport copy\n\ndef find_regions(grid_np, background_color=0):\n    \"\"\"\n    Finds connected regions of non-background pixels.\n\n    Args:\n        grid_np (np.array): The input grid as a NumPy array.\n        background_color (int): The color value considered background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a region\n              and contains 'coords' (set of (row, col) tuples), 'min_col',\n              'max_col', 'min_row', 'max_row'. Returns an empty list if no\n              non-background regions are found.\n    \"\"\"\n    mask = grid_np != background_color\n    labeled_array, num_features = label(mask) # Default 8-connectivity\n\n    regions = []\n    if num_features == 0:\n        return regions\n\n    # Use find_objects to quickly get bounding boxes, but extract exact coords\n    # object_slices = find_objects(labeled_array) # Less efficient for exact coords\n\n    for i in range(1, num_features + 1): # Labels are 1-based\n        coords_array = np.argwhere(labeled_array == i)\n        if coords_array.size == 0:\n            continue\n\n        coords_set = set(tuple(coord) for coord in coords_array)\n        rows = coords_array[:, 0]\n        cols = coords_array[:, 1]\n\n        regions.append({\n            'coords': coords_set,\n            'min_row': np.min(rows),\n            'max_row': np.max(rows),\n            'min_col': np.min(cols),\n            'max_col': np.max(cols),\n            'label': i # Keep track of the label if needed later\n        })\n\n    return regions\n\ndef get_region_colors_and_counts(grid_np, region_coords, background_color=0):\n    \"\"\"\n    Counts the occurrences of non-background colors within a region.\n\n    Args:\n        grid_np (np.array): The grid.\n        region_coords (set): A set of (row, col) tuples for the region.\n        background_color (int): The background color to ignore.\n\n    Returns:\n        collections.Counter: A Counter object mapping non-background colors\n                             to their counts within the region.\n    \"\"\"\n    color_counts = Counter()\n    for r, c in region_coords:\n        color = grid_np[r, c]\n        if color != background_color:\n            color_counts[color] += 1\n    return color_counts\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    height, width = input_np.shape\n    background_color = 0\n\n    # 1. Find all connected non-background regions\n    regions = find_regions(input_np, background_color)\n\n    # 2. Need at least two regions (source and target)\n    if len(regions) < 2:\n        return output_grid.tolist() # Return original if not enough regions\n\n    # 3. Identify Source (leftmost) and Target (rightmost) regions\n    # Sort regions by their minimum column index\n    regions.sort(key=lambda r: r['min_col'])\n    source_region = regions[0]\n    target_region = regions[-1] # Assume rightmost is target\n\n    # 4. Get colors and counts in the source region\n    source_colors_counts = get_region_colors_and_counts(input_np, source_region['coords'], background_color)\n\n    if not source_colors_counts:\n         return output_grid.tolist() # Source region only has background? unlikely but safe\n\n    # 5. Determine Source Frame Color (most frequent non-background color)\n    # Handle cases with only one color or ties (take the first one from most_common)\n    most_common = source_colors_counts.most_common(1)\n    source_frame_color = most_common[0][0] if most_common else None # color value\n\n    # 6. Determine Pattern Color (smallest non-background color != frame color)\n    pattern_color = None\n    sorted_unique_colors = sorted(source_colors_counts.keys())\n\n    # Check if there's more than one unique non-bg color first\n    if len(sorted_unique_colors) > 1:\n        for color in sorted_unique_colors:\n            if color != source_frame_color:\n                pattern_color = color\n                break\n    # If only one color, or if loop didn't find a different one (e.g., tie logic resulted in smallest being frame), no pattern\n    # OR if source_frame_color is None (only background found)\n    if pattern_color is None:\n         return output_grid.tolist() # No pattern color found to copy\n\n    # 7. Find Pattern Pixels in the source region\n    pattern_pixels = []\n    for r, c in source_region['coords']:\n        if input_np[r, c] == pattern_color:\n            pattern_pixels.append((r, c))\n\n    if not pattern_pixels:\n        return output_grid.tolist() # No pixels of pattern color found\n\n    # 8. Calculate the horizontal translation vector\n    delta_col = target_region['min_col'] - source_region['min_col']\n\n    # 9. Get target region coordinates as a set for efficient checking\n    target_coords_set = target_region['coords']\n\n    # 10. Copy pattern pixels to the target region if applicable\n    for r_s, c_s in pattern_pixels:\n        # Calculate potential target coordinates\n        target_r = r_s\n        target_c = c_s + delta_col\n\n        # Check if target coordinate is within grid bounds\n        if 0 <= target_r < height and 0 <= target_c < width:\n            # Check if the target coordinate falls within the target region's pixels\n            if (target_r, target_c) in target_coords_set:\n                # Update the output grid\n                output_grid[target_r, target_c] = pattern_color\n\n    # Return the modified grid as a list of lists\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11742,
    "candidates_token_count": 1649,
    "total_token_count": 13391,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.002385,
  "retries": 1
}