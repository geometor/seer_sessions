{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid by identifying a 'composite object' (a primary object, often the largest by bounding box, plus any objects fully enclosed within its bounding box) and a 'secondary object' (an object outside the primary's bounding box).\n\nThe transformation duplicates the composite object. The placement of the duplicate depends on the relative position of the secondary object to the composite object:\n1. If the secondary object is primarily horizontally displaced from the composite object, the composite object is duplicated horizontally with a 2-column gap of background color (0) in between.\n2. If the secondary object is primarily vertically displaced, the composite object is duplicated vertically with a 1-row gap of background color (0) in between.\n\nThe final output grid contains only the original composite object and its duplicate placed according to the determined direction and gap, on a background of color 0. All other elements from the input grid (like the secondary object) are removed.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color using BFS.\n    Uses 4-connectivity (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to treat as background.\n\n    Returns:\n        list: A list of objects. Each object is a tuple: (color, set_of_coords).\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    rows, cols = grid.shape\n    visited = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if coords: # Should always be true if we start one\n                     objects.append((color, coords))\n\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    if not bbox:\n        return 0\n    return (bbox[2] - bbox[0] + 1) * (bbox[3] - bbox[1] + 1)\n\ndef get_object_center(bbox):\n    \"\"\"Calculates the approximate center of a bounding box.\"\"\"\n    if not bbox:\n        return None\n    center_r = (bbox[0] + bbox[2]) / 2\n    center_c = (bbox[1] + bbox[3]) / 2\n    return (center_r, center_c)\n\ndef extract_pattern(grid, coords, bbox):\n    \"\"\"\n    Extracts the pixel pattern of an object within its bounding box.\n\n    Args:\n        grid (np.array): The original grid.\n        coords (set): The coordinates belonging to the object(s).\n        bbox (tuple): The bounding box (min_r, min_c, max_r, max_c).\n\n    Returns:\n        np.array: A grid containing the object's pattern, padded with 0s.\n    \"\"\"\n    if not bbox:\n        return np.array([[]])\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    pattern = np.zeros((height, width), dtype=grid.dtype)\n    \n    for r, c in coords:\n        if min_r <= r <= max_r and min_c <= c <= max_c:\n            pattern[r - min_r, c - min_c] = grid[r, c]\n            \n    return pattern\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the described transformation rule to the input grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color\n\n    # 1. Analyze the input grid: Identify all distinct, contiguous non-white objects.\n    all_objects = find_objects(input_grid, ignore_color=0)\n    if not all_objects:\n        return output_grid # Return empty grid if no objects\n\n    # Calculate bounding boxes and areas for all objects\n    object_details = []\n    for color, coords in all_objects:\n        bbox = get_bounding_box(coords)\n        area = get_bounding_box_area(bbox)\n        object_details.append({'color': color, 'coords': coords, 'bbox': bbox, 'area': area})\n\n    # 2. Identify the Primary Object (largest bounding box area).\n    # If there's a tie, the exact tie-breaking rule isn't specified,\n    # but examples suggest one is clearly larger. Let's take the first max.\n    primary_obj_detail = max(object_details, key=lambda x: x['area'])\n    primary_bb = primary_obj_detail['bbox']\n    \n    # 3. Identify Enclosed Objects\n    enclosed_objects_coords = set()\n    for obj in object_details:\n        if obj is primary_obj_detail: continue # Skip primary object itself\n        obj_bb = obj['bbox']\n        # Check if obj_bb is strictly inside or equal to primary_bb\n        if (primary_bb[0] <= obj_bb[0] and primary_bb[1] <= obj_bb[1] and\n            primary_bb[2] >= obj_bb[2] and primary_bb[3] >= obj_bb[3]):\n            enclosed_objects_coords.update(obj['coords'])\n\n    # 4. Define the Composite Object\n    composite_coords = primary_obj_detail['coords'].union(enclosed_objects_coords)\n    composite_bb = get_bounding_box(composite_coords)\n    composite_pattern = extract_pattern(input_grid, composite_coords, composite_bb)\n    composite_origin_r, composite_origin_c = composite_bb[0], composite_bb[1]\n    composite_h, composite_w = composite_pattern.shape\n\n    # 5. Identify the Secondary Object(s)\n    secondary_objects = []\n    for obj in object_details:\n        obj_bb = obj['bbox']\n        # Check if obj_bb is completely outside primary_bb (no overlap)\n        if (obj_bb[2] < primary_bb[0] or obj_bb[0] > primary_bb[2] or\n            obj_bb[3] < primary_bb[1] or obj_bb[1] > primary_bb[3]):\n            secondary_objects.append(obj)\n\n    if not secondary_objects:\n         # Fallback: if no secondary object, maybe just copy next to it horizontally?\n         # Or return original? The examples always have one. Let's assume one exists.\n         # If this fails on a test case, we need to reconsider.\n         # For now, let's default to horizontal duplication if no secondary is found.\n         direction = 'horizontal'\n         gap = 2\n    else:\n        # Select the 'determining' secondary object (e.g., largest area)\n        secondary_obj_detail = max(secondary_objects, key=lambda x: x['area'])\n        secondary_bb = secondary_obj_detail['bbox']\n\n        # 6. Determine Duplication Direction\n        composite_center = get_object_center(composite_bb)\n        secondary_center = get_object_center(secondary_bb)\n        \n        delta_r = abs(secondary_center[0] - composite_center[0])\n        delta_c = abs(secondary_center[1] - composite_center[1])\n\n        # Use bounding box dimensions as tie-breaker if centers align closely\n        comp_height = composite_bb[2] - composite_bb[0] + 1\n        comp_width = composite_bb[3] - composite_bb[1] + 1\n        sec_height = secondary_bb[2] - secondary_bb[0] + 1\n        sec_width = secondary_bb[3] - secondary_bb[1] + 1\n\n        # Heuristic: Check if bounding boxes are further apart horizontally or vertically\n        horizontal_separation = max(0, secondary_bb[1] - composite_bb[3] -1) + max(0, composite_bb[1] - secondary_bb[3] - 1)\n        vertical_separation = max(0, secondary_bb[0] - composite_bb[2] -1) + max(0, composite_bb[0] - secondary_bb[2] - 1)\n\n\n        # Prefer axis with larger center difference, use box separation as secondary check\n        if delta_c > delta_r + 1e-6: # Clearly more horizontal separation by center\n             direction = 'horizontal'\n        elif delta_r > delta_c + 1e-6: # Clearly more vertical separation by center\n             direction = 'vertical'\n        elif horizontal_separation > vertical_separation : # Centers close, but boxes separated more horizontally\n             direction = 'horizontal'\n        else: # Centers close, boxes separated more vertically or equally\n             direction = 'vertical'\n\n\n        # 7. Determine Gap Size\n        if direction == 'horizontal':\n            gap = 2\n        else: # direction == 'vertical'\n            gap = 1\n\n    # 8. Construct the Output Grid (already initialized with background)\n\n    # 9. Place the Original Composite Object\n    output_grid[composite_origin_r : composite_origin_r + composite_h, \n                composite_origin_c : composite_origin_c + composite_w] = np.where(\n                    composite_pattern != 0, composite_pattern, \n                    output_grid[composite_origin_r : composite_origin_r + composite_h, \n                                composite_origin_c : composite_origin_c + composite_w]\n                )\n\n    # 10. Calculate Placement for the Copy\n    if direction == 'horizontal':\n        copy_origin_r = composite_origin_r\n        copy_origin_c = composite_origin_c + composite_w + gap\n    else: # direction == 'vertical'\n        copy_origin_r = composite_origin_r + composite_h + gap\n        copy_origin_c = composite_origin_c\n\n    # 11. Place the Copied Composite Object, checking boundaries\n    copy_h, copy_w = composite_pattern.shape\n    if (0 <= copy_origin_r < rows and 0 <= copy_origin_c < cols and\n        copy_origin_r + copy_h <= rows and copy_origin_c + copy_w <= cols):\n        \n        # Ensure we only overwrite with non-background pixels from the pattern\n        target_slice = output_grid[copy_origin_r : copy_origin_r + copy_h, \n                                   copy_origin_c : copy_origin_c + copy_w]\n        mask = composite_pattern != 0\n        target_slice[mask] = composite_pattern[mask]\n\n\n    # 12. Finalize\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4287,
    "candidates_token_count": 2915,
    "total_token_count": 7202,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.208535,
  "retries": 1
}