{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on identifying a 'frame' component (largest bounding box), \nany 'enclosed' components within the frame's box, and a 'trigger' component \n(largest bounding box among those outside the frame's box).\n\nThe composite object (frame + enclosed components) is duplicated. The duplication \naxis (horizontal or vertical) and gap size are determined by the relative position \nof the trigger component to the composite object.\n- Horizontal separation -> Horizontal duplication, gap = 2 columns.\n- Vertical separation -> Vertical duplication, gap = 1 row.\n\nThe output grid contains only the original composite object and its duplicate on a \nbackground of color 0.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color using BFS.\n    Calculates bounding box and area for each object.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to treat as background.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'color' (int), 'coords' (set of tuples), 'bbox' (tuple), 'area' (int).\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    rows, cols = grid.shape\n    visited = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if coords:\n                     bbox = get_bounding_box(coords)\n                     area = get_bounding_box_area(bbox)\n                     objects.append({'color': color, 'coords': coords, 'bbox': bbox, 'area': area})\n\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    if not bbox:\n        return 0\n    # Ensure non-negative dimensions even for single points/lines\n    height = max(0, bbox[2] - bbox[0]) + 1\n    width = max(0, bbox[3] - bbox[1]) + 1\n    return height * width\n\ndef get_object_center(bbox):\n    \"\"\"Calculates the approximate center of a bounding box.\"\"\"\n    if not bbox:\n        return None\n    center_r = (bbox[0] + bbox[2]) / 2.0\n    center_c = (bbox[1] + bbox[3]) / 2.0\n    return (center_r, center_c)\n\ndef extract_pattern(grid, coords, bbox):\n    \"\"\"\n    Extracts the pixel pattern of combined objects within a bounding box.\n    \"\"\"\n    if not bbox or not coords:\n        # Return empty array if no coordinates or bounding box\n        return np.array([[]], dtype=grid.dtype)\n        \n    min_r, min_c, max_r, max_c = bbox\n    # Ensure height and width are at least 1 if coords exist\n    height = max(1, max_r - min_r + 1)\n    width = max(1, max_c - min_c + 1)\n    \n    pattern = np.zeros((height, width), dtype=grid.dtype)\n    \n    for r, c in coords:\n        # Check if coordinate falls within the calculated bbox\n        if min_r <= r <= max_r and min_c <= c <= max_c:\n             # Place pixel relative to the top-left corner of the pattern grid\n            pattern[r - min_r, c - min_c] = grid[r, c]\n            \n    return pattern\n\ndef is_bbox_inside(inner_bbox, outer_bbox):\n    \"\"\"Checks if inner_bbox is strictly inside or equal to outer_bbox.\"\"\"\n    if not inner_bbox or not outer_bbox:\n        return False\n    return (outer_bbox[0] <= inner_bbox[0] and \n            outer_bbox[1] <= inner_bbox[1] and\n            outer_bbox[2] >= inner_bbox[2] and \n            outer_bbox[3] >= inner_bbox[3])\n\ndef is_bbox_outside(bbox1, bbox2):\n    \"\"\"Checks if bbox1 is completely outside bbox2 (no overlap).\"\"\"\n    if not bbox1 or not bbox2:\n        return True # Treat None as outside everything\n    # Check for non-overlap condition\n    return (bbox1[2] < bbox2[0] or  # bbox1 is entirely above bbox2\n            bbox1[0] > bbox2[2] or  # bbox1 is entirely below bbox2\n            bbox1[3] < bbox2[1] or  # bbox1 is entirely left of bbox2\n            bbox1[1] > bbox2[3])    # bbox1 is entirely right of bbox2\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color\n\n    # 1. Find Components\n    all_components = find_objects(input_grid, ignore_color=0)\n    if not all_components:\n        return output_grid # Return empty grid if no objects\n\n    # 2. Identify Frame Component (largest BB area)\n    if not all_components: # Should be caught above, but defensive check\n        return output_grid\n    frame_component = max(all_components, key=lambda x: x['area'])\n    composite_region = frame_component['bbox'] # The BB of the largest component\n\n    # 3. Find Enclosed Components\n    enclosed_components_coords = set()\n    for comp in all_components:\n        if comp is frame_component: continue # Skip the frame itself\n        # Check if component's BB is entirely within the frame's BB\n        if is_bbox_inside(comp['bbox'], composite_region):\n            enclosed_components_coords.update(comp['coords'])\n\n    # 4. Define Composite Object\n    # Combine coords from frame and all enclosed components\n    composite_object_pixels = frame_component['coords'].union(enclosed_components_coords)\n    # Calculate the minimal BB containing all these pixels\n    composite_object_bbox = get_bounding_box(composite_object_pixels)\n    # Extract the pattern within this combined BB\n    composite_pattern = extract_pattern(input_grid, composite_object_pixels, composite_object_bbox)\n    \n    # Check if pattern extraction was successful\n    if composite_pattern.size == 0 or not composite_object_bbox:\n         # This might happen if frame_component had no coords - fallback or error\n         print(\"Warning: Composite pattern extraction failed.\")\n         # Maybe return original or blank grid depending on desired error handling\n         return output_grid \n\n    composite_origin_r, composite_origin_c = composite_object_bbox[0], composite_object_bbox[1]\n    composite_h, composite_w = composite_pattern.shape\n\n    # 5. Find Secondary Components (outside the composite_region defined by frame component)\n    secondary_components = []\n    for comp in all_components:\n        # Check if component's BB is entirely outside the frame's BB\n        if is_bbox_outside(comp['bbox'], composite_region):\n            secondary_components.append(comp)\n\n    # 6. Select Secondary Trigger (largest BB area among secondaries)\n    if not secondary_components:\n         # Fallback if no secondary component is found (as per previous logic)\n         direction = 'horizontal'\n         gap = 2\n         # print(\"Warning: No secondary component found, defaulting to horizontal duplication.\")\n    else:\n        trigger_object = max(secondary_components, key=lambda x: x['area'])\n        secondary_bb = trigger_object['bbox']\n\n        # 7. Determine Duplication Direction\n        composite_center = get_object_center(composite_object_bbox)\n        secondary_center = get_object_center(secondary_bb)\n        \n        # Basic check: primary axis of separation between centers\n        delta_r = abs(secondary_center[0] - composite_center[0])\n        delta_c = abs(secondary_center[1] - composite_center[1])\n\n        # More robust check: distance between closest edges\n        horizontal_gap = 0\n        if composite_object_bbox[3] < secondary_bb[1]: # Secondary is to the right\n            horizontal_gap = secondary_bb[1] - composite_object_bbox[3] - 1\n        elif secondary_bb[3] < composite_object_bbox[1]: # Secondary is to the left\n            horizontal_gap = composite_object_bbox[1] - secondary_bb[3] - 1\n            \n        vertical_gap = 0\n        if composite_object_bbox[2] < secondary_bb[0]: # Secondary is below\n            vertical_gap = secondary_bb[0] - composite_object_bbox[2] - 1\n        elif secondary_bb[2] < composite_object_bbox[0]: # Secondary is above\n            vertical_gap = composite_object_bbox[0] - secondary_bb[2] - 1\n            \n        # Determine direction based on largest separation gap between bounding boxes\n        # This seems more reliable than centers for irregular shapes\n        if horizontal_gap >= vertical_gap : \n            direction = 'horizontal'\n        else:\n            direction = 'vertical'\n\n        # Example-specific gaps\n        if direction == 'horizontal':\n            gap = 2\n        else: # direction == 'vertical'\n            gap = 1\n\n    # 9. Create Output Grid (already done)\n\n    # 10. Place Original Composite Object\n    # Ensure slice dimensions match pattern dimensions\n    target_slice_orig = output_grid[composite_origin_r : composite_origin_r + composite_h, \n                                   composite_origin_c : composite_origin_c + composite_w]\n    \n    if target_slice_orig.shape == composite_pattern.shape:\n        mask_orig = composite_pattern != 0\n        target_slice_orig[mask_orig] = composite_pattern[mask_orig]\n    else:\n        print(f\"Warning: Shape mismatch for original placement. Target: {target_slice_orig.shape}, Pattern: {composite_pattern.shape}\")\n\n\n    # 11. Calculate Placement for the Copy\n    if direction == 'horizontal':\n        copy_origin_r = composite_origin_r\n        copy_origin_c = composite_origin_c + composite_w + gap\n    else: # direction == 'vertical'\n        copy_origin_r = composite_origin_r + composite_h + gap\n        copy_origin_c = composite_origin_c\n\n    # 12. Place the Copied Composite Object, checking boundaries\n    copy_h, copy_w = composite_pattern.shape # Use pattern's actual shape\n    \n    # Calculate end coordinates, ensure they are within grid limits\n    end_r = copy_origin_r + copy_h\n    end_c = copy_origin_c + copy_w\n    \n    if (0 <= copy_origin_r < rows and 0 <= copy_origin_c < cols and\n        end_r <= rows and end_c <= cols): # Check if the whole pattern fits\n        \n        target_slice_copy = output_grid[copy_origin_r : end_r, \n                                        copy_origin_c : end_c]\n\n        # Double check shape match before assignment (can happen with edge cases)\n        if target_slice_copy.shape == composite_pattern.shape:\n            mask_copy = composite_pattern != 0\n            target_slice_copy[mask_copy] = composite_pattern[mask_copy]\n        else:\n             print(f\"Warning: Shape mismatch for copy placement. Target: {target_slice_copy.shape}, Pattern: {composite_pattern.shape}\")\n\n    # Return the final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14990,
    "candidates_token_count": 3108,
    "total_token_count": 18098,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.739606,
  "retries": 1
}