{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n# --- Helper Functions ---\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color using BFS.\n    Calculates bounding box and area for each object.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to treat as background.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'color' (int), 'coords' (set of tuples), 'bbox' (tuple), 'area' (int).\n              Returns an empty list if no objects are found.\n    \"\"\"\n    objects = []\n    rows, cols = grid.shape\n    visited = set()\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != ignore_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                coords.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            coords.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if coords:\n                     bbox = get_bounding_box(coords)\n                     # Area calculation should handle None bbox case, although coords existing implies bbox exists\n                     area = get_bounding_box_area(bbox) if bbox else 0 \n                     objects.append({'color': color, 'coords': coords, 'bbox': bbox, 'area': area})\n\n    return objects\n\ndef get_bounding_box(coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if coords is empty.\n    \"\"\"\n    if not coords:\n        return None\n    min_r = min(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_r = max(r for r, c in coords)\n    max_c = max(c for r, c in coords)\n    return (min_r, min_c, max_r, max_c)\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    if not bbox:\n        return 0\n    # Ensure non-negative dimensions even for single points/lines\n    height = max(0, bbox[2] - bbox[0]) + 1\n    width = max(0, bbox[3] - bbox[1]) + 1\n    return height * width\n\ndef is_bbox_inside(inner_bbox, outer_bbox):\n    \"\"\"Checks if inner_bbox is strictly inside or equal to outer_bbox.\"\"\"\n    if not inner_bbox or not outer_bbox:\n        return False\n    return (outer_bbox[0] <= inner_bbox[0] and \n            outer_bbox[1] <= inner_bbox[1] and\n            outer_bbox[2] >= inner_bbox[2] and \n            outer_bbox[3] >= inner_bbox[3])\n\ndef is_bbox_outside(bbox1, bbox2):\n    \"\"\"Checks if bbox1 is completely outside bbox2 (no overlap).\"\"\"\n    if not bbox1 or not bbox2:\n        return True # Treat None as outside everything\n    # Check for non-overlap condition\n    return (bbox1[2] < bbox2[0] or  # bbox1 is entirely above bbox2\n            bbox1[0] > bbox2[2] or  # bbox1 is entirely below bbox2\n            bbox1[3] < bbox2[1] or  # bbox1 is entirely left of bbox2\n            bbox1[1] > bbox2[3])    # bbox1 is entirely right of bbox2\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms an input grid by identifying a 'composite object' and a 'trigger object'.\n    The composite object consists of the object with the largest bounding box ('primary') \n    and any other objects fully enclosed within the primary object's bounding box.\n    The trigger object is the object with the largest bounding box among those completely \n    outside the primary object's bounding box.\n\n    The transformation duplicates the rectangular region defined by the minimal bounding \n    box of the composite object. The placement of the duplicate depends on the relative \n    position of the trigger object to the composite object's bounding box:\n    1. If the trigger object is primarily horizontally separated (larger horizontal gap \n       between bounding boxes), the composite region is duplicated horizontally with a \n       2-column gap of background color (0) in between.\n    2. If the trigger object is primarily vertically separated (larger vertical gap), \n       the composite region is duplicated vertically with a 1-row gap of background \n       color (0) in between. If gaps are equal, horizontal duplication is preferred.\n    3. If no trigger object exists, horizontal duplication with a 2-column gap is used.\n\n    The final output grid contains only the original composite region and its duplicate \n    placed according to the determined direction and gap, on a background of color 0. \n    All other elements from the input grid (like the trigger object) are removed.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.zeros_like(input_grid) # Initialize with background color 0\n\n    # 1. Find all distinct objects (components)\n    all_components = find_objects(input_grid, ignore_color=0)\n    if not all_components:\n        return output_grid # Return empty grid if no objects\n\n    # 2. Identify the Primary component (largest bounding box area)\n    # Using max with a default key ensures it works even if areas are 0 or equal\n    primary_component = max(all_components, key=lambda x: x['area'])\n    primary_bbox = primary_component['bbox'] \n    \n    # Handle case where primary object itself might be invalid (e.g., empty coords)\n    if not primary_bbox: \n        print(\"Warning: Primary component has no valid bounding box.\")\n        return output_grid # Cannot proceed without a primary region\n\n    # 3. Identify Enclosed components (inside the primary component's BBox)\n    enclosed_components_coords = set()\n    for comp in all_components:\n        if comp is primary_component: continue # Skip the primary itself\n        if is_bbox_inside(comp['bbox'], primary_bbox):\n            enclosed_components_coords.update(comp['coords'])\n\n    # 4. Define the Composite Object's pixels and its minimal bounding box\n    composite_object_pixels = primary_component['coords'].union(enclosed_components_coords)\n    composite_object_bbox = get_bounding_box(composite_object_pixels)\n\n    # Check if a valid composite object could be defined\n    if not composite_object_bbox:\n        print(\"Warning: Composite object could not be defined (no pixels).\")\n        return output_grid # Cannot proceed without a composite object\n\n    # 5. Extract the Composite Pattern (rectangular slice from input)\n    comp_min_r, comp_min_c, comp_max_r, comp_max_c = composite_object_bbox\n    composite_pattern = input_grid[comp_min_r : comp_max_r + 1, comp_min_c : comp_max_c + 1]\n    \n    # Store pattern dimensions and origin for placement\n    composite_h, composite_w = composite_pattern.shape\n    composite_origin_r, composite_origin_c = comp_min_r, comp_min_c\n\n    # 6. Identify Secondary components (outside the primary component's BBox)\n    secondary_components = []\n    for comp in all_components:\n        if is_bbox_outside(comp['bbox'], primary_bbox):\n            secondary_components.append(comp)\n\n    # 7. Select Secondary Trigger (largest BB area among secondaries) and determine direction/gap\n    if not secondary_components:\n         # Default behavior if no secondary component is found\n         direction = 'horizontal'\n         gap = 2\n         # print(\"Warning: No secondary component found, defaulting to horizontal duplication.\")\n    else:\n        trigger_object = max(secondary_components, key=lambda x: x['area'])\n        secondary_bb = trigger_object['bbox']\n\n        # Calculate separation gaps between the composite object's BB and the trigger's BB\n        horizontal_gap = 0\n        if composite_object_bbox[3] < secondary_bb[1]: # Trigger is to the right\n            horizontal_gap = secondary_bb[1] - composite_object_bbox[3] - 1\n        elif secondary_bb[3] < composite_object_bbox[1]: # Trigger is to the left\n            horizontal_gap = composite_object_bbox[1] - secondary_bb[3] - 1\n            \n        vertical_gap = 0\n        if composite_object_bbox[2] < secondary_bb[0]: # Trigger is below\n            vertical_gap = secondary_bb[0] - composite_object_bbox[2] - 1\n        elif secondary_bb[2] < composite_object_bbox[0]: # Trigger is above\n            vertical_gap = composite_object_bbox[0] - secondary_bb[2] - 1\n        \n        # Determine direction: prefer horizontal if gaps are equal or horizontal is larger\n        if horizontal_gap >= vertical_gap : \n            direction = 'horizontal'\n            gap = 2\n        else:\n            direction = 'vertical'\n            gap = 1\n\n    # 8. Place the Original Composite Pattern onto the output grid\n    # Check boundaries before placing\n    if (0 <= composite_origin_r < rows and 0 <= composite_origin_c < cols and\n        composite_origin_r + composite_h <= rows and composite_origin_c + composite_w <= cols):\n        output_grid[composite_origin_r : composite_origin_r + composite_h, \n                    composite_origin_c : composite_origin_c + composite_w] = composite_pattern\n    else:\n         print(f\"Warning: Original pattern placement out of bounds.\")\n\n\n    # 9. Calculate Placement coordinates for the Copy\n    if direction == 'horizontal':\n        copy_origin_r = composite_origin_r\n        copy_origin_c = composite_origin_c + composite_w + gap\n    else: # direction == 'vertical'\n        copy_origin_r = composite_origin_r + composite_h + gap\n        copy_origin_c = composite_origin_c\n\n    # 10. Place the Copied Composite Pattern onto the output grid, checking boundaries\n    # Calculate required end coordinates\n    end_r = copy_origin_r + composite_h\n    end_c = copy_origin_c + composite_w\n    \n    # Check if the entire pattern fits within the grid\n    if (0 <= copy_origin_r < rows and 0 <= copy_origin_c < cols and\n        end_r <= rows and end_c <= cols): \n        \n        output_grid[copy_origin_r : end_r, \n                    copy_origin_c : end_c] = composite_pattern\n    else:\n        print(f\"Warning: Copy pattern placement out of bounds.\")\n\n\n    # 11. Return the final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16182,
    "candidates_token_count": 2786,
    "total_token_count": 18968,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.707117,
  "retries": 1
}