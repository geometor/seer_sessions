{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies a pair of identical contiguous anchor objects and a potentially non-contiguous mobile object (defined by all pixels of a third distinct color). Calculates the positional offset between the top-left corner of the mobile object's overall bounding box and the top-left corner of the first anchor object's bounding box. Applies this offset to the top-left corner of the second anchor object's bounding box to determine a target origin. Copies all pixels of the mobile object, maintaining their positions relative to the mobile object's bounding box top-left, placing them relative to the calculated target origin in the output grid. The original grid elements (background, anchors, original mobile object) remain in place.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\n\ndef find_contiguous_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid using 4-connectivity.\n    \n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing a contiguous object with keys:\n              'color' (int): The color of the object.\n              'pixels' (set): A set of (row, col) tuples for the object's pixels.\n              'bbox' (tuple): The bounding box (min_row, min_col, max_row, max_col).\n              'top_left' (tuple): The top-left corner (min_row, min_col).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if not visited[r, c] and grid[r, c] != 0: # 0 is background\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if obj_pixels: # Only add if pixels were found (should always be true here)\n                    objects.append({\n                        'color': color,\n                        'pixels': obj_pixels,\n                        'bbox': (min_r, min_c, max_r, max_c),\n                        'top_left': (min_r, min_c) \n                    })\n    return objects\n\ndef get_color_pixel_groups(grid):\n    \"\"\"\n    Groups all non-background pixels by color, finds their overall bounding box, \n    and top-left corner for each color group.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are colors and values are dictionaries\n              containing 'color', 'pixels' (set of all pixels of that color),\n              'bbox', and 'top_left' of the overall bounding box for that color.\n              Returns an empty dictionary if no non-background pixels are found.\n    \"\"\"\n    pixels_by_color = defaultdict(set)\n    rows, cols = grid.shape\n    has_pixels = False\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r,c]\n            if color != 0:\n                pixels_by_color[color].add((r,c))\n                has_pixels = True\n\n    if not has_pixels:\n        return {}\n\n    groups = {}\n    for color, pixels in pixels_by_color.items():\n        if not pixels: continue # Should not happen if color is in keys, but safety check\n        min_r = min(r for r, c in pixels)\n        min_c = min(c for r, c in pixels)\n        max_r = max(r for r, c in pixels)\n        max_c = max(c for r, c in pixels)\n        groups[color] = {\n            'color': color,\n            'pixels': pixels,\n            'bbox': (min_r, min_c, max_r, max_c),\n            'top_left': (min_r, min_c)\n        }\n    return groups\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on anchor and mobile objects.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify Contiguous Objects\n    contiguous_objects = find_contiguous_objects(input_grid)\n\n    # 2. Find Anchor Color and Objects\n    objects_by_color = defaultdict(list)\n    for obj in contiguous_objects:\n        objects_by_color[obj['color']].append(obj)\n\n    anchor_color = None\n    anchor_objects = []\n    for color, obj_list in objects_by_color.items():\n        if len(obj_list) == 2:\n            anchor_color = color\n            # Sort anchors by top-left: Anchor1 is top-leftmost\n            anchor_objects = sorted(obj_list, key=lambda o: o['top_left']) \n            break\n    \n    if anchor_color is None:\n        return output_grid # No anchor pair found\n\n    anchor1 = anchor_objects[0]\n    anchor2 = anchor_objects[1]\n    anchor1_top_left = anchor1['top_left']\n    anchor2_top_left = anchor2['top_left']\n\n    # 3. Find Mobile Color and Pixels\n    all_color_groups = get_color_pixel_groups(input_grid)\n    mobile_color = None\n    mobile_group = None\n    \n    # Iterate through all colors found in the grid\n    for color, group_data in all_color_groups.items():\n        if color != anchor_color:\n             # Check if this color corresponds to a group that wasn't one of the contiguous anchors found earlier\n             # This handles cases where the mobile object might *also* be contiguous\n             is_anchor = False\n             for anchor_obj in anchor_objects:\n                 if anchor_obj['color'] == color and anchor_obj['pixels'] == group_data['pixels']:\n                     is_anchor = True\n                     break\n             if not is_anchor:\n                 mobile_color = color\n                 mobile_group = group_data\n                 break # Assume only one mobile color\n\n    if mobile_color is None or mobile_group is None:\n        return output_grid # No distinct mobile color/group found\n\n    mobile_pixels = mobile_group['pixels']\n    mobile_bbox_top_left = mobile_group['top_left']\n\n    # 4. Calculate Offset\n    delta_row = mobile_bbox_top_left[0] - anchor1_top_left[0]\n    delta_col = mobile_bbox_top_left[1] - anchor1_top_left[1]\n\n    # 5. Determine Copy Target Origin\n    copy_target_origin_r = anchor2_top_left[0] + delta_row\n    copy_target_origin_c = anchor2_top_left[1] + delta_col\n\n    # 6. Copy Mobile Pixels to Target Location\n    mob_origin_r, mob_origin_c = mobile_bbox_top_left\n    \n    for r_mob, c_mob in mobile_pixels:\n        # Calculate pixel position relative to the mobile object's bounding box top-left\n        relative_r = r_mob - mob_origin_r\n        relative_c = c_mob - mob_origin_c\n        \n        # Calculate the target pixel position in the output grid\n        target_r = copy_target_origin_r + relative_r\n        target_c = copy_target_origin_c + relative_c\n\n        # Ensure the target position is within bounds before drawing\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n            output_grid[target_r, target_c] = mobile_color\n            \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13131,
    "candidates_token_count": 2042,
    "total_token_count": 15173,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.17181,
  "retries": 1
}