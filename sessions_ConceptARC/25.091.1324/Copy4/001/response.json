{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct objects (contiguous regions of the same color) for each non-background color.\nFor each color, if there are multiple objects, find the largest one (by pixel count, breaking ties with top-left position) as the prototype.\nExtract the pattern within the bounding box of the prototype.\nFind all other objects (seeds) of the same color whose top-left corner comes *after* the prototype's top-left corner in reading order (row-major).\nReplace each such seed object by pasting the prototype's pattern, aligning the top-left corner of the pattern with the top-left corner of the seed.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'pixels' (set of (r, c) tuples), 'min_r', 'min_c',\n              'max_r', 'max_c', 'size', and 'top_left' (tuple (min_r, min_c)).\n              Returns an empty list if no objects of the color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start BFS to find a connected component\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component_pixels:\n                    objects.append({\n                        'pixels': component_pixels,\n                        'min_r': min_r,\n                        'min_c': min_c,\n                        'max_r': max_r,\n                        'max_c': max_c,\n                        'size': len(component_pixels),\n                        'top_left': (min_r, min_c)\n                    })\n                    \n    return objects\n\ndef get_pattern(grid, bbox):\n    \"\"\"\n    Extracts a rectangular pattern from the grid based on the bounding box.\n\n    Args:\n        grid (np.array): The grid to extract from.\n        bbox (dict): Dictionary containing 'min_r', 'min_c', 'max_r', 'max_c'.\n\n    Returns:\n        np.array: The extracted pattern.\n    \"\"\"\n    return grid[bbox['min_r']:bbox['max_r']+1, bbox['min_c']:bbox['max_c']+1]\n\ndef paste_pattern(grid, pattern, top_left):\n    \"\"\"\n    Pastes a pattern onto the grid at the specified top-left position.\n    Handles boundary conditions.\n\n    Args:\n        grid (np.array): The target grid (mutable).\n        pattern (np.array): The pattern to paste.\n        top_left (tuple): The (row, column) to start pasting at.\n    \"\"\"\n    start_r, start_c = top_left\n    pattern_h, pattern_w = pattern.shape\n    grid_h, grid_w = grid.shape\n\n    # Calculate the actual region to paste onto, clipping to grid boundaries\n    end_r = min(start_r + pattern_h, grid_h)\n    end_c = min(start_c + pattern_w, grid_w)\n\n    # Calculate the portion of the pattern to use\n    paste_h = end_r - start_r\n    paste_w = end_c - start_c\n\n    # Ensure we don't try to paste negative dimensions\n    if paste_h <= 0 or paste_w <= 0:\n        return\n\n    # Paste the valid portion of the pattern\n    grid[start_r:end_r, start_c:end_c] = pattern[0:paste_h, 0:paste_w]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding prototype objects for each color,\n    extracting their patterns, and copying these patterns onto specific\n    'seed' objects of the same color based on their relative positions.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Find unique colors present, excluding background (0)\n    unique_colors = np.unique(input_np)\n    unique_colors = unique_colors[unique_colors != 0]\n\n    # Process each color\n    for color in unique_colors:\n        # Find all objects of the current color\n        objects = find_objects(input_np, color)\n\n        # Skip if only one or zero objects of this color exist\n        if len(objects) < 2:\n            continue\n\n        # Find the prototype object\n        # Sort by size (descending), then by top-left row (ascending), then by top-left col (ascending)\n        objects.sort(key=lambda obj: (-obj['size'], obj['top_left'][0], obj['top_left'][1]))\n        prototype = objects[0]\n        proto_r, proto_c = prototype['top_left']\n\n        # Extract the pattern from the prototype's bounding box in the *original* input grid\n        pattern_to_copy = get_pattern(input_np, prototype)\n        \n        # Identify and replace seed objects\n        for i in range(1, len(objects)):\n            seed = objects[i]\n            seed_r, seed_c = seed['top_left']\n\n            # Check the replacement condition: seed is after prototype in reading order\n            if seed_r > proto_r or (seed_r == proto_r and seed_c > proto_c):\n                # Replace the seed area with the prototype pattern in the output grid\n                paste_pattern(output_np, pattern_to_copy, seed['top_left'])\n\n    # Convert the result back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4629,
    "candidates_token_count": 1698,
    "total_token_count": 6327,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.318413,
  "retries": 1
}