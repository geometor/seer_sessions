{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid by the following process:\n1. Identify all distinct connected objects for each non-background color.\n2. For each color with multiple objects, designate the largest object (by pixel count, tie-breaking with top-left reading order) as the 'prototype'.\n3. Extract the rectangular pattern within the bounding box of the prototype from the original input grid.\n4. Identify 'seed' objects: these are any objects of the same color as the prototype, but not the prototype itself.\n5. Check each seed object: if it is exactly 1x1 pixel in size AND its top-left corner is positioned *after* the prototype's top-left corner in reading order (row-major), then replace it.\n6. Replacement involves pasting the extracted prototype pattern onto the grid, aligning the pattern's top-left corner with the seed object's (which is just the single pixel).\n7. Objects that are unique for their color, prototypes themselves, or seeds that do not meet the replacement criteria (not 1x1 or not positioned after the prototype) are left unchanged.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all connected components of a given color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to search for.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'pixels' (set of (r, c) tuples), 'min_r', 'min_c',\n              'max_r', 'max_c', 'size', 'top_left' (tuple (min_r, min_c)),\n              and 'is_1x1' (boolean). Returns an empty list if no objects of the\n              color are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] == color and not visited[r, c]:\n                # Start BFS to find a connected component\n                component_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                \n                while q:\n                    row, col = q.popleft()\n                    component_pixels.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n                    \n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if component_pixels:\n                    obj_size = len(component_pixels)\n                    objects.append({\n                        'pixels': component_pixels,\n                        'min_r': min_r,\n                        'min_c': min_c,\n                        'max_r': max_r,\n                        'max_c': max_c,\n                        'size': obj_size,\n                        'top_left': (min_r, min_c),\n                        'is_1x1': obj_size == 1\n                    })\n                    \n    return objects\n\ndef get_pattern(grid, bbox):\n    \"\"\"\n    Extracts a rectangular pattern from the grid based on the bounding box.\n\n    Args:\n        grid (np.array): The grid to extract from.\n        bbox (dict): Dictionary containing 'min_r', 'min_c', 'max_r', 'max_c'.\n\n    Returns:\n        np.array: The extracted pattern.\n    \"\"\"\n    # Ensure indices are valid before slicing\n    min_r, max_r = max(0, bbox['min_r']), min(grid.shape[0], bbox['max_r'] + 1)\n    min_c, max_c = max(0, bbox['min_c']), min(grid.shape[1], bbox['max_c'] + 1)\n    if min_r >= max_r or min_c >= max_c: # Check for empty slice\n        return np.array([[]], dtype=grid.dtype)\n    return grid[min_r:max_r, min_c:max_c]\n\n\ndef paste_pattern(grid, pattern, top_left):\n    \"\"\"\n    Pastes a pattern onto the grid at the specified top-left position.\n    Handles boundary conditions by clipping.\n\n    Args:\n        grid (np.array): The target grid (mutable).\n        pattern (np.array): The pattern to paste.\n        top_left (tuple): The (row, column) to start pasting at.\n    \"\"\"\n    start_r, start_c = top_left\n    if pattern.size == 0: # Handle empty pattern\n        return\n        \n    pattern_h, pattern_w = pattern.shape\n    grid_h, grid_w = grid.shape\n\n    # Calculate the actual region to paste onto, clipping to grid boundaries\n    end_r = min(start_r + pattern_h, grid_h)\n    end_c = min(start_c + pattern_w, grid_w)\n\n    # Calculate the portion of the pattern to use based on clipping\n    # Adjust pattern slice end indices based on how much was clipped\n    paste_h = end_r - start_r\n    paste_w = end_c - start_c\n\n    # Ensure we don't try to paste negative or zero dimensions after clipping\n    if paste_h <= 0 or paste_w <= 0:\n        return\n\n    # Paste the valid (potentially clipped) portion of the pattern\n    grid[start_r:end_r, start_c:end_c] = pattern[0:paste_h, 0:paste_w]\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n    height, width = input_np.shape\n\n    # Find unique colors present, excluding background (0)\n    unique_colors = np.unique(input_np)\n    unique_colors = unique_colors[unique_colors != 0]\n\n    # Process each color\n    for color in unique_colors:\n        # Find all distinct connected components (objects) of the current color\n        objects = find_objects(input_np, color)\n\n        # Skip if only one or zero objects of this color exist (no prototype/seed distinction needed)\n        if len(objects) < 2:\n            continue\n\n        # Determine the prototype object\n        # Sort by size (descending), then by top-left row (ascending), then by top-left col (ascending)\n        objects.sort(key=lambda obj: (-obj['size'], obj['top_left'][0], obj['top_left'][1]))\n        prototype = objects[0]\n        proto_r, proto_c = prototype['top_left']\n\n        # Extract the pattern from the prototype's bounding box in the *original* input grid\n        pattern_to_copy = get_pattern(input_np, prototype)\n        \n        # Iterate through all other components (seeds) of the same color\n        for i in range(1, len(objects)):\n            seed = objects[i]\n            seed_r, seed_c = seed['top_left']\n\n            # Check the replacement conditions:\n            # 1. Is the seed object exactly 1x1 pixel?\n            is_1x1 = seed['is_1x1']\n            # 2. Is the seed positioned after the prototype in reading order?\n            is_after_prototype = seed_r > proto_r or (seed_r == proto_r and seed_c > proto_c)\n\n            # If both conditions are met, replace the seed\n            if is_1x1 and is_after_prototype:\n                # Paste the prototype's pattern onto the output grid, starting at the seed's top-left corner\n                paste_pattern(output_np, pattern_to_copy, seed['top_left'])\n\n    # Convert the result back to a list of lists for the expected output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18577,
    "candidates_token_count": 2050,
    "total_token_count": 20627,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.11245,
  "retries": 1
}