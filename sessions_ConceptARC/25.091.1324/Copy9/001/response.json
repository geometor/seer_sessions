{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport math\n\n# --- Helper Functions ---\n\ndef find_all_objects_by_color(grid):\n    \"\"\"\n    Finds all contiguous objects (connected components including diagonals) \n    of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are colors (int > 0) and values are lists\n              of objects. Each object is represented as a set of coordinates\n              {(r1, c1), (r2, c2), ...}. Returns an empty dict if no \n              non-background objects are found.\n    \"\"\"\n    objects_by_color = {}\n    # Find unique non-background colors present in the grid\n    unique_colors = np.unique(grid[grid > 0])\n    if unique_colors.size == 0:\n        return {} # Return empty if only background color exists\n\n    for color in unique_colors:\n        # Create a binary mask for the current color\n        mask = (grid == color)\n        \n        # Label connected components in the mask. \n        # structure=np.ones((3,3)) ensures diagonal connectivity is considered.\n        labeled_array, num_features = label(mask, structure=np.ones((3,3)))\n\n        if num_features > 0:\n            # find_objects returns a list of slices corresponding to the bounding box of each feature\n            coords_slices = find_objects(labeled_array)\n            color_objects = []\n            \n            for i in range(num_features):\n                # Get the slice for the current feature (object)\n                loc = coords_slices[i]\n                \n                # Basic validation for the slice object\n                if loc is None or not isinstance(loc, tuple) or len(loc) != 2:\n                    continue \n                \n                # Extract the portion of the labeled array corresponding to this object's bounding box\n                object_slice = labeled_array[loc]\n                \n                # Find the coordinates within the slice where the label matches the current feature index + 1\n                obj_mask_in_slice = (object_slice == (i + 1))\n                obj_coords_in_slice = np.argwhere(obj_mask_in_slice)\n\n                # If no coordinates were found (e.g., issues with labeling), skip\n                if obj_coords_in_slice.size == 0:\n                    continue\n\n                # Convert slice-relative coordinates (r, c) to absolute grid coordinates\n                # by adding the starting row and column of the slice.\n                obj_coords_global = set(\n                    (r + loc[0].start, c + loc[1].start)\n                    for r, c in obj_coords_in_slice\n                )\n                \n                # Add the set of global coordinates for this object to the list\n                if obj_coords_global: # Ensure we don't add empty sets\n                    color_objects.append(obj_coords_global)\n            \n            # If any objects were found for this color, add them to the main dictionary\n            if color_objects: \n                 objects_by_color[color] = color_objects\n                 \n    return objects_by_color\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) \n    for a set of object coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    # Return the min/max row and column values\n    return (min(rows), min(cols), max(rows), max(cols))\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies all distinct objects (contiguous blocks of the same color) in the input grid.\n    For each color:\n      - Finds objects that are single pixels (\"markers\").\n      - Finds objects that are larger than one pixel (\"potential sources\").\n      - If there is exactly one marker and at least one potential source of the same color:\n        - Identifies the potential source object with the largest number of pixels (the \"largest source object\").\n        - Determines the coordinates of the single marker pixel.\n        - Calculates the bounding box of the largest source object.\n        - Calculates the placement position for a copy of the largest source object so that its \n          calculated center (using floor division on bounding box dimensions) aligns with the marker pixel's position.\n        - Places the copied object's pixels onto an output grid at the calculated positions, \n          overwriting existing pixels (including the original marker).\n    Repeats this process for all applicable colors. Pixels not involved in any copy/placement \n    operation retain their original values.\n\n    Args:\n        input_grid (np.ndarray): The input grid as a 2D NumPy array.\n\n    Returns:\n        np.ndarray: The transformed grid.\n    \"\"\"\n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Step 1: Find all objects in the input grid, grouped by their color\n    objects_by_color = find_all_objects_by_color(input_grid)\n\n    # Step 2: Iterate through each color found\n    for color, objects in objects_by_color.items():\n        markers = []\n        potential_sources = []\n        \n        # Step 3a: Classify objects into markers (size 1) and potential sources (size > 1)\n        for obj_coords in objects:\n            if len(obj_coords) == 1:\n                markers.append(obj_coords)\n            elif len(obj_coords) > 1:\n                potential_sources.append(obj_coords)\n\n        # Step 3b: Check if the condition is met: exactly one marker and at least one source\n        if len(markers) == 1 and len(potential_sources) >= 1:\n            \n            # Step 3c.i: Identify the single marker pixel coordinate\n            # markers[0] is a set containing one tuple, e.g., {(r, c)}\n            marker_coord = list(markers[0])[0] \n            marker_r, marker_c = marker_coord\n\n            # Step 3c.i: Find the source object with the largest number of pixels\n            largest_source_obj = max(potential_sources, key=len)\n\n            # Step 3c.iii: Get the bounding box of the largest source object\n            source_bbox = get_bounding_box(largest_source_obj)\n            if source_bbox is None:\n                continue # Should not happen if largest_source_obj is valid\n            src_min_r, src_min_c, src_max_r, src_max_c = source_bbox\n\n            # Step 3c.v & 3c.vi: Calculate placement coordinates\n            # Calculate the dimensions (height, width) of the source object's bounding box\n            src_height = src_max_r - src_min_r + 1\n            src_width = src_max_c - src_min_c + 1\n\n            # Calculate the offset from the top-left of the bounding box to its conceptual center.\n            # Using floor ensures integer coordinates and consistent alignment.\n            # This offset represents the relative coordinate (dr, dc) within the bounding box shape \n            # that should align with the marker pixel.\n            center_offset_r = math.floor((src_height - 1) / 2)\n            center_offset_c = math.floor((src_width - 1) / 2)\n\n            # Calculate the target top-left corner (target_min_r, target_min_c) for placing \n            # the *bounding box* of the source object copy. This ensures that the pixel at \n            # (center_offset_r, center_offset_c) relative to this top-left corner lands \n            # exactly on the marker position (marker_r, marker_c).\n            target_min_r = marker_r - center_offset_r\n            target_min_c = marker_c - center_offset_c\n\n            # Step 3c.vii & 3c.viii: Place the copied object onto the output grid\n            # Iterate through each pixel coordinate (src_r, src_c) of the actual largest source object\n            for src_r, src_c in largest_source_obj:\n                # Calculate the pixel's relative position within its original bounding box\n                relative_r = src_r - src_min_r\n                relative_c = src_c - src_min_c\n\n                # Calculate the absolute target position in the output grid by adding the\n                # relative position to the calculated target top-left corner.\n                target_r = target_min_r + relative_r\n                target_c = target_min_c + relative_c\n\n                # Check if the calculated target position is within the grid boundaries\n                if 0 <= target_r < height and 0 <= target_c < width:\n                    # If within bounds, update the output grid with the object's color\n                    output_grid[target_r, target_c] = color\n\n    # Step 4: Return the modified output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3500,
    "candidates_token_count": 2229,
    "total_token_count": 5729,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 62.136143,
  "retries": 1
}