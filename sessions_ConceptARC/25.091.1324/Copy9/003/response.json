{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects\nimport math\n\n\"\"\"\nIdentifies all distinct objects (contiguous blocks of the same color, including diagonals) in the input grid.\nFor each color:\n  - Finds objects that are single pixels (\"markers\").\n  - Finds objects that are larger than one pixel (\"potential sources\").\n  - If there is exactly one marker and at least one potential source of the same color:\n    - Identifies the potential source object with the largest number of pixels (the \"largest source object\").\n    - Determines the coordinates of the single marker pixel.\n    - Calculates the bounding box of the largest source object.\n    - Calculates the conceptual center of the bounding box (using floor division on dimensions).\n    - Calculates the placement position for a copy of the largest source object so that its conceptual center aligns with the marker pixel's position.\n    - Iterates through ONLY the actual pixel coordinates of the largest source object. For each source pixel, calculates its corresponding target position on the output grid based on the alignment.\n    - Places the source object's color at these calculated target coordinates on an output grid, overwriting existing pixels (including the original marker). Pixels within the calculated placement area but NOT part of the original source object's shape are NOT drawn.\nRepeats this process for all applicable colors. Pixels not involved in any copy/placement operation retain their original values from the input grid.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_all_objects_by_color(grid):\n    \"\"\"\n    Finds all contiguous objects (connected components including diagonals) \n    of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are colors (int > 0) and values are lists\n              of objects. Each object is represented as a set of coordinates\n              {(r1, c1), (r2, c2), ...}. Returns an empty dict if no \n              non-background objects are found.\n    \"\"\"\n    objects_by_color = {}\n    # Find unique non-background colors present in the grid\n    unique_colors = np.unique(grid[grid > 0])\n    if unique_colors.size == 0:\n        return {} # Return empty if only background color exists\n\n    for color in unique_colors:\n        # Create a binary mask for the current color\n        mask = (grid == color)\n        \n        # Label connected components in the mask. \n        # structure=np.ones((3,3)) ensures diagonal connectivity is considered.\n        labeled_array, num_features = label(mask, structure=np.ones((3,3)))\n\n        if num_features > 0:\n            # find_objects returns a list of slices corresponding to the bounding box of each feature\n            coords_slices = find_objects(labeled_array)\n            color_objects = []\n            \n            # Iterate through each found feature (object) for this color\n            for i in range(num_features):\n                # Get the slice defining the bounding box for the current feature\n                loc = coords_slices[i]\n                \n                # Basic validation for the slice object\n                if loc is None or not isinstance(loc, tuple) or len(loc) != 2:\n                    continue \n                \n                # Extract the portion of the labeled array corresponding to this object's bounding box\n                object_slice = labeled_array[loc]\n                \n                # Find the coordinates *within the slice* where the label matches the current feature index + 1\n                # This identifies the pixels belonging to this specific object within its bounding box\n                obj_mask_in_slice = (object_slice == (i + 1))\n                obj_coords_in_slice = np.argwhere(obj_mask_in_slice)\n\n                # If no coordinates were found (e.g., issues with labeling), skip\n                if obj_coords_in_slice.size == 0:\n                    continue\n\n                # Convert slice-relative coordinates (r, c) to absolute grid coordinates\n                # by adding the starting row and column of the slice.\n                obj_coords_global = set(\n                    (r + loc[0].start, c + loc[1].start)\n                    for r, c in obj_coords_in_slice\n                )\n                \n                # Add the set of global coordinates for this object to the list\n                if obj_coords_global: # Ensure we don't add empty sets\n                    color_objects.append(obj_coords_global)\n            \n            # If any objects were found for this color, add them to the main dictionary\n            if color_objects: \n                 objects_by_color[color] = color_objects\n                 \n    return objects_by_color\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box (min_row, min_col, max_row, max_col) \n    for a set of object coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    # Return the min/max row and column values\n    return (min(rows), min(cols), max(rows), max(cols))\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # 2. Identify all distinct contiguous objects for each non-white color.\n    objects_by_color = find_all_objects_by_color(input_grid)\n\n    # 3. Iterate through each color found.\n    for color, objects in objects_by_color.items():\n        markers = []\n        potential_sources = []\n        \n        # 3a. Separate objects into markers (size 1) and potential sources (size > 1).\n        for obj_coords in objects:\n            if len(obj_coords) == 1:\n                markers.append(obj_coords)\n            elif len(obj_coords) > 1:\n                potential_sources.append(obj_coords)\n\n        # 3b. Check if the condition is met: exactly one marker and at least one source.\n        if len(markers) == 1 and len(potential_sources) >= 1:\n            \n            # 3c.i. Get the coordinate of the single marker pixel.\n            marker_coord = list(markers[0])[0] # markers[0] is a set like {(r, c)}\n            marker_r, marker_c = marker_coord\n\n            # 3c.ii. Find the largest source object by pixel count.\n            largest_source_obj_coords = max(potential_sources, key=len)\n\n            # 3c.iii. Determine the bounding box of the largest source object.\n            source_bbox = get_bounding_box(largest_source_obj_coords)\n            if source_bbox is None:\n                continue # Should not happen if largest_source_obj_coords is valid\n            src_min_r, src_min_c, src_max_r, src_max_c = source_bbox\n\n            # 3c.iv. Calculate the dimensions of the source bounding box.\n            src_height = src_max_r - src_min_r + 1\n            src_width = src_max_c - src_min_c + 1\n\n            # 3c.v. Calculate the center offset relative to the source bounding box's top-left.\n            center_offset_r = math.floor((src_height - 1) / 2)\n            center_offset_c = math.floor((src_width - 1) / 2)\n\n            # 3c.vi. Calculate the top-left anchor coordinate for placing the object.\n            # This is the coordinate where the source object's bounding box's top-left\n            # would be placed so that its center aligns with the marker.\n            anchor_r = marker_r - center_offset_r\n            anchor_c = marker_c - center_offset_c\n\n            # 3c.vii. Iterate through each coordinate *actually belonging* to the largest source object.\n            for src_r, src_c in largest_source_obj_coords:\n                # 1. Calculate the pixel's relative offset from the source bounding box's top-left.\n                relative_r = src_r - src_min_r\n                relative_c = src_c - src_min_c\n\n                # 2. Calculate the final target coordinate on the output grid.\n                target_r = anchor_r + relative_r\n                target_c = anchor_c + relative_c\n\n                # 3. If the target coordinate is within the grid bounds, place the color.\n                if 0 <= target_r < height and 0 <= target_c < width:\n                    output_grid[target_r, target_c] = color\n\n    # 4. Return the modified output grid.\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15529,
    "candidates_token_count": 2164,
    "total_token_count": 17693,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.175524,
  "retries": 1
}