{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a static line object (horizontal or vertical) and multiple point objects of a single color.\nMoves the point objects relative to the static line.\nIf the line is horizontal (at row line_r, spanning columns min_c to max_c):\n  - Each point (r, c) moves 5 steps up (new_r = r - 5).\n  - If the point's original column 'c' is strictly between min_c and max_c, it moves 3 steps right (new_c = c + 3).\n  - Otherwise (if c <= min_c or c >= max_c), it moves 5 steps right (new_c = c + 5).\nIf the line is vertical (at column line_c):\n  - Each point (r, c) moves 4 steps right (new_c = c + 4).\n  - The vertical position remains unchanged (new_r = r).\nThe output grid contains the static line in its original position and the points in their new calculated positions, against a background of color 0.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"Finds connected components of non-background colors.\"\"\"\n    objects = {}\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and not visited[r, c]:\n                obj_coords = []\n                q = [(r, c)]\n                visited[r, c] = True\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.append((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(obj_coords)\n    return objects\n\ndef analyze_line(coords):\n    \"\"\"Checks if a list of coordinates forms a straight line and returns its properties.\"\"\"\n    if not coords:\n        return None\n\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n\n    # Check if all points share the same row (horizontal)\n    if min_r == max_r:\n        # Verify it's continuous\n        if len(coords) == (max_c - min_c + 1):\n             return {\n                \"orientation\": \"horizontal\",\n                \"position\": min_r,\n                \"span\": [min_c, max_c]\n            }\n    # Check if all points share the same column (vertical)\n    elif min_c == max_c:\n        # Verify it's continuous\n        if len(coords) == (max_r - min_r + 1):\n            return {\n                \"orientation\": \"vertical\",\n                \"position\": min_c,\n                \"span\": [min_r, max_r]\n            }\n            \n    return None # Not a straight line\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on a static line and moving points.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n    output_grid = np.zeros_like(input_grid_np) # Initialize with background color 0\n\n    # Find all colored objects\n    objects_by_color = find_objects(input_grid_np)\n    \n    if not objects_by_color:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    static_line_coords = None\n    static_line_color = -1\n    line_props = None\n    moving_points_coords = []\n    moving_points_color = -1\n\n    # Identify the line (assume it's the largest object, or test each object)\n    # Let's refine: iterate through objects, try analyze_line, pick the first match\n    possible_line_colors = list(objects_by_color.keys())\n    \n    for color in possible_line_colors:\n        # Assume only one component per color for simplicity in line finding\n        if len(objects_by_color[color]) == 1: \n            coords = objects_by_color[color][0]\n            props = analyze_line(coords)\n            if props:\n                static_line_coords = coords\n                static_line_color = color\n                line_props = props\n                break # Found the line\n\n    if static_line_coords is None:\n         # Fallback: assume largest object is the line if analyze_line fails initially\n         # (This might happen if find_objects splits a thick line) \n         # Or, perhaps the largest object is always the line regardless of shape check.\n         # Let's stick to the strict line check for now. If it fails, error or default.\n         # For now, let's assume the line check succeeds and we found it.\n         # Consider edge cases later if needed.\n         # If no line is identified, we cannot proceed with the logic.\n         # Maybe return input or empty grid? Let's return input for now.\n         # print(\"Warning: Could not definitively identify a static line object.\")\n         return input_grid # Return input if no line found\n\n    # Identify the moving points (the other color)\n    for color, components in objects_by_color.items():\n        if color != static_line_color:\n            moving_points_color = color\n            # Collect all coordinates for this color, assuming they are all points\n            for component in components:\n                 moving_points_coords.extend(component)\n            break # Assume only one color for moving points\n\n    # Draw the static line onto the output grid\n    for r, c in static_line_coords:\n        output_grid[r, c] = static_line_color\n\n    # Calculate new positions for moving points and draw them\n    if moving_points_color != -1:\n        for r_orig, c_orig in moving_points_coords:\n            new_r, new_c = r_orig, c_orig # Initialize with original position\n\n            if line_props[\"orientation\"] == \"horizontal\":\n                line_r = line_props[\"position\"]\n                min_c, max_c = line_props[\"span\"]\n                \n                # Move 5 steps up (assuming points start below the line)\n                new_r = r_orig - 5 \n                \n                # Move horizontally based on position relative to span\n                if min_c < c_orig < max_c: # Strictly within span\n                    new_c = c_orig + 3\n                else: # Outside or at ends of span\n                    new_c = c_orig + 5\n\n            elif line_props[\"orientation\"] == \"vertical\":\n                line_c = line_props[\"position\"]\n                # min_r, max_r = line_props[\"span\"] # Span not used in vertical movement rule\n                \n                # Move 4 steps right (assuming points start left of the line)\n                new_c = c_orig + 4\n                \n                # Vertical position remains the same\n                new_r = r_orig\n\n            # Draw the point at the new position if it's within grid bounds\n            if 0 <= new_r < rows and 0 <= new_c < cols:\n                output_grid[new_r, new_c] = moving_points_color\n            # else: Point moved off-grid, do nothing\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4236,
    "candidates_token_count": 1878,
    "total_token_count": 6114,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.927983,
  "retries": 1
}