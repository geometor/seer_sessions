{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nIdentifies a single static line object (horizontal or vertical) and multiple \nsingle-pixel point objects of a different color. \nMoves each point object by a fixed vector determined by the line's orientation.\nIf the line is horizontal, the movement vector is (-5, +5) (5 steps up, 5 steps right).\nIf the line is vertical, the movement vector is (0, +4) (0 steps vertically, 4 steps right).\nThe output grid contains the static line in its original position and the points \nin their new calculated positions, against a background of color 0. Points moved \noutside the grid boundaries are omitted.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components (objects) of non-background colors in the grid.\n    Uses 4-way connectivity (up, down, left, right).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict: A dictionary where keys are colors (int > 0) and values are lists \n              of lists of coordinates [(r, c), ...], representing each distinct \n              object of that color. \n              Example: {2: [[(1,1), (1,2)], [(3,3)]], 4: [[(5,5)]]}\n    \"\"\"\n    objects = {}\n    visited = np.zeros_like(grid, dtype=bool)\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # If it's a non-background pixel and not visited yet\n            if color != 0 and not visited[r, c]:\n                obj_coords = []\n                q = [(r, c)] # Queue for BFS\n                visited[r, c] = True\n                \n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    row, col = q.pop(0)\n                    obj_coords.append((row, col))\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds, has the same color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Store the found object coordinates, grouped by color\n                if color not in objects:\n                    objects[color] = []\n                objects[color].append(obj_coords)\n    return objects\n\ndef analyze_line(coords):\n    \"\"\"\n    Checks if a list of coordinates forms a continuous straight line (horizontal or vertical).\n\n    Args:\n        coords (list): A list of (row, col) tuples representing an object's pixels.\n\n    Returns:\n        dict or None: A dictionary with line properties {'orientation': 'horizontal'/'vertical', \n                      'position': row/col index, 'span': [min_col/row, max_col/row]} \n                      if it's a valid line, otherwise None.\n    \"\"\"\n    if not coords:\n        return None\n\n    rows = [r for r, c in coords]\n    cols = [c for r, c in coords]\n\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    num_pixels = len(coords)\n\n    # Check if all points share the same row (horizontal)\n    if min_r == max_r:\n        # Verify it's continuous (number of pixels matches width)\n        if num_pixels == (max_c - min_c + 1):\n             return {\n                \"orientation\": \"horizontal\",\n                \"position\": min_r, # The row index\n                \"span\": [min_c, max_c] # The column range\n            }\n            \n    # Check if all points share the same column (vertical)\n    elif min_c == max_c:\n        # Verify it's continuous (number of pixels matches height)\n        if num_pixels == (max_r - min_r + 1):\n            return {\n                \"orientation\": \"vertical\",\n                \"position\": min_c, # The column index\n                \"span\": [min_r, max_r] # The row range\n            }\n            \n    # If neither horizontal nor vertical and continuous\n    return None \n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on a static line and moving points.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    # Initialize output grid with background color 0\n    output_grid = np.zeros_like(input_grid_np) \n\n    # 1. Find all colored objects\n    objects_by_color = find_objects(input_grid_np)\n    \n    # Handle empty input grid\n    if not objects_by_color:\n        return output_grid.tolist() \n\n    static_line_coords = None\n    static_line_color = -1\n    line_props = None\n    moving_points_coords = []\n    moving_points_color = -1\n\n    # 2. Identify the line object\n    # Iterate through each color and its objects\n    for color, components in objects_by_color.items():\n        for component_coords in components:\n            # Check if this component is a valid line\n            props = analyze_line(component_coords)\n            if props:\n                # Found the line\n                static_line_coords = component_coords\n                static_line_color = color\n                line_props = props\n                break # Stop searching for lines within this color\n        if line_props:\n            break # Stop searching through other colors\n\n    # Handle case where no line is found\n    if static_line_coords is None:\n        # If no line found, maybe return original grid or empty? \n        # Based on examples, transformation always happens if objects exist.\n        # This case might indicate an unexpected input format. Let's return input.\n        # print(\"Warning: Could not identify a static line object.\")\n        return input_grid # Or potentially raise an error or return empty grid\n\n    # 3. Identify the moving points (all pixels of the *other* color)\n    for color, components in objects_by_color.items():\n        if color != static_line_color:\n            moving_points_color = color\n            # Collect all coordinates for this color\n            for component_coords in components:\n                 # Assume all components of the non-line color are individual points\n                 moving_points_coords.extend(component_coords) \n            break # Assume only one color for moving points\n\n    # 4. Determine movement vector based on line orientation\n    delta_r, delta_c = 0, 0\n    if line_props[\"orientation\"] == \"horizontal\":\n        delta_r = -5 # Move up\n        delta_c = +5 # Move right\n    elif line_props[\"orientation\"] == \"vertical\":\n        delta_r = 0  # No vertical move\n        delta_c = +4 # Move right\n\n    # 5. Construct the output grid\n    # 5a. Draw the static line\n    for r, c in static_line_coords:\n        # Check bounds just in case, though line should be within original grid\n        if 0 <= r < rows and 0 <= c < cols:\n             output_grid[r, c] = static_line_color\n\n    # 5b. Calculate new positions for moving points and draw them\n    if moving_points_color != -1:\n        for r_orig, c_orig in moving_points_coords:\n            # Calculate new position\n            new_r = r_orig + delta_r\n            new_c = c_orig + delta_c\n\n            # Draw the point at the new position ONLY if it's within grid bounds\n            if 0 <= new_r < rows and 0 <= new_c < cols:\n                output_grid[new_r, new_c] = moving_points_color\n            # else: Point moved off-grid, it's omitted from the output.\n\n    # 6. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12184,
    "candidates_token_count": 1983,
    "total_token_count": 14167,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.934566,
  "retries": 1
}