{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Optional\n\n\"\"\"\nMoves a blue (1) object away from a red (2) line based on the line's orientation\nand the gap between them.\nThe distance moved is equal to the number of background (0) cells strictly\nbetween the blue object's bounding box and the red line.\nThe movement is perpendicular to the line, increasing the distance between\nthe object and the line.\nThe red line and background remain unchanged.\n\"\"\"\n\n# Helper function to find all coordinates of pixels with a specific color\ndef find_object_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates (row, col) of pixels with the specified color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\n# Helper function to calculate the bounding box of a set of pixels\ndef get_bounding_box(pixels: List[Tuple[int, int]]) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"Calculates the bounding box (min_row, min_col, max_row, max_col) for a set of pixels.\"\"\"\n    if not pixels:\n        return None\n    min_row = min(r for r, c in pixels)\n    min_col = min(c for r, c in pixels)\n    max_row = max(r for r, c in pixels)\n    max_col = max(c for r, c in pixels)\n    return min_row, min_col, max_row, max_col\n\n# Helper function to determine if a set of pixels forms a straight line and its orientation/position\ndef determine_line_orientation_and_position(pixels: List[Tuple[int, int]]) -> Optional[Tuple[str, int]]:\n    \"\"\"\n    Determines if the pixels form a vertical or horizontal line.\n    Returns the orientation ('vertical' or 'horizontal') and the fixed coordinate (column or row index).\n    Returns None if the pixels don't form a straight line or are empty.\n    \"\"\"\n    if not pixels:\n        return None\n\n    rows = {r for r, c in pixels}\n    cols = {c for r, c in pixels}\n\n    if len(cols) == 1:\n        # All pixels share the same column -> vertical line\n        return 'vertical', list(cols)[0]\n    elif len(rows) == 1:\n        # All pixels share the same row -> horizontal line\n        return 'horizontal', list(rows)[0]\n    else:\n        # Not a straight line\n        return None\n\n# Helper function to calculate the shift vector based on object/line relationship\ndef calculate_shift_vector(blue_pixels: List[Tuple[int, int]], red_pixels: List[Tuple[int, int]]) -> Tuple[int, int]:\n    \"\"\"\n    Calculates the shift vector (dx, dy) for the blue object based on the gap\n    between its bounding box and the red line. Movement is away from the line.\n    Returns (0, 0) if no shift is needed or possible (e.g., objects not found,\n    line invalid, object touches line, or zero gap).\n    \"\"\"\n    blue_bbox = get_bounding_box(blue_pixels)\n    line_info = determine_line_orientation_and_position(red_pixels)\n\n    # Default shift is none\n    dx, dy = 0, 0\n\n    # Return no shift if objects/line aren't found correctly\n    if not blue_bbox or not line_info:\n        return dx, dy\n\n    min_r, min_c, max_r, max_c = blue_bbox\n    orientation, line_pos = line_info\n    gap = -1 # Initialize gap to indicate not yet calculated or invalid\n\n    # Calculate gap and determine shift direction (away from line)\n    if orientation == 'vertical':\n        red_col = line_pos\n        if max_c < red_col: # Blue is left of line\n            gap = red_col - max_c - 1\n            if gap >= 0: dx = gap # Move right (increase col index)\n        elif min_c > red_col: # Blue is right of line\n            gap = min_c - red_col - 1\n            if gap >= 0: dx = -gap # Move left (decrease col index)\n        # dy remains 0 for vertical lines\n    elif orientation == 'horizontal':\n        red_row = line_pos\n        if max_r < red_row: # Blue is above line\n            gap = red_row - max_r - 1\n            if gap >= 0: dy = gap # Move down (increase row index)\n        elif min_r > red_row: # Blue is below line\n            gap = min_r - red_row - 1\n            if gap >= 0: dy = -gap # Move up (decrease row index)\n        # dx remains 0 for horizontal lines\n\n    # Only return calculated shift if a valid, positive gap was found (gap > 0)\n    # If gap is 0 or negative (touching/overlapping/error), return (0, 0)\n    if gap <= 0:\n        return 0, 0\n    else:\n        # Ensure results are standard integers\n        return int(dx), int(dy)\n\n# Main transformation function\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Transforms the input grid by moving the blue object away from the red line\n    by a distance equal to the gap between them.\n    \"\"\"\n    # Find coordinates of blue (1) and red (2) pixels\n    blue_pixels = find_object_pixels(input_grid, 1)\n    red_pixels = find_object_pixels(input_grid, 2)\n\n    # Handle edge cases: If no blue object or no red line exists, return the grid unchanged.\n    if not blue_pixels or not red_pixels:\n        return input_grid.copy() # Return a copy to prevent modifying the original input\n\n    # Calculate the required shift vector (dx, dy)\n    dx, dy = calculate_shift_vector(blue_pixels, red_pixels)\n\n    # If no shift is required (dx=0 and dy=0), return the original grid.\n    # This covers cases where the line is invalid, objects touch, or the calculated gap is zero.\n    if dx == 0 and dy == 0:\n         return input_grid.copy()\n\n    # Initialize the output grid with the same shape as the input, filled with background color (0)\n    output_grid = np.zeros_like(input_grid)\n\n    # Copy the red line from the input to the output grid at its original position.\n    # This ensures the red line remains static.\n    for r, c in red_pixels:\n        # Basic boundary check, although red pixels should always be within bounds.\n        if 0 <= r < output_grid.shape[0] and 0 <= c < output_grid.shape[1]:\n             output_grid[r, c] = 2\n\n    # Apply the calculated shift to each blue pixel and draw it on the output grid.\n    for r, c in blue_pixels:\n        new_r, new_c = r + dy, c + dx\n        # Check if the new coordinates are within the grid boundaries.\n        if 0 <= new_r < output_grid.shape[0] and 0 <= new_c < output_grid.shape[1]:\n            # Place the blue pixel at the new location.\n            # The order ensures that if blue moves onto red, red persists (copied last).\n            # However, the gap calculation should prevent overlap if initially separated.\n             if output_grid[new_r, new_c] == 0: # Only draw if cell is background\n                 output_grid[new_r, new_c] = 1\n        # Pixels moved outside the grid boundaries are effectively removed.\n\n    # Return the newly constructed output grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11175,
    "candidates_token_count": 1837,
    "total_token_count": 13012,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 64.865056,
  "retries": 1
}