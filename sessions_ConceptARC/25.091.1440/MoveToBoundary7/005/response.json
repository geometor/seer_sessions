{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rule:\n1. Identifies exactly two distinct non-background objects. If not two, returns the input unchanged.\n2. Determines the primary axis of separation (horizontal or vertical) between the objects based on the largest gap between their bounding boxes.\n3. Designates one object as \"moving\" and the other as \"static\". The object that is further out along the axis of separation moves towards the other object (e.g., the left object moves right, the top object moves down).\n4. Simulates the moving object translating one pixel at a time towards the static object along the determined axis.\n5. The movement stops when the moving object becomes edge-adjacent (shares a side) to the static object. The step that causes adjacency is the final step. Movement also stops if the next step would cause a direct collision (overlap) with the static object or move the object out of the grid boundaries.\n6. Returns the final grid state with the moving object in its final position and the static object unchanged.\n\"\"\"\n\n# Helper Class for representing objects\nclass ArcObject:\n    \"\"\"Represents a contiguous object in the grid.\"\"\"\n    def __init__(self, color, coords):\n        # Raise error if no coordinates are provided\n        if not coords:\n             raise ValueError(\"Cannot create ArcObject with empty coordinates.\")\n        self.color = color\n        # Store coords as a frozenset for immutability and potential hashing\n        self.coords = frozenset(coords) \n        # Pre-calculate bounding box for efficiency\n        self.min_r = min(r for r, c in coords)\n        self.max_r = max(r for r, c in coords)\n        self.min_c = min(c for r, c in coords)\n        self.max_c = max(c for r, c in coords)\n        # Calculate centroid (geometric center)\n        self.centroid = self._calculate_centroid()\n\n    def _calculate_centroid(self):\n        \"\"\"Calculates the geometric center (average row, average col) of the object.\"\"\"\n        sum_r = sum(r for r, c in self.coords)\n        sum_c = sum(c for r, c in self.coords)\n        count = len(self.coords)\n        # Return as float tuple\n        return (sum_r / count, sum_c / count)\n\n# Helper function to find objects using BFS\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all distinct connected components (objects) of non-background colors\n    in the grid using Breadth-First Search (BFS). Connects pixels sharing an edge.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list[ArcObject]: A list of ArcObject instances found in the grid. Returns empty list if no objects found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = set() # Keep track of visited cells ((row, col) tuples)\n\n    for r in range(height):\n        for c in range(width):\n            # Check if the cell contains a non-background color and hasn't been visited\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set() # Use a set to store coords for this object during BFS\n                q = deque([(r, c)]) # Initialize queue for BFS with the starting cell\n                visited.add((r, c))\n                coords.add((r, c))\n\n                # Perform BFS to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Check 4 cardinal neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if the neighbor is within grid boundaries\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor has the same color and has not been visited\n                            if (nr, nc) not in visited and grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                coords.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # Once BFS for this component is done, create an ArcObject\n                if coords: \n                    objects.append(ArcObject(color, coords))\n    return objects\n\n# Helper function to check for edge-adjacency\ndef check_adjacency(coords1, coords2):\n    \"\"\" \n    Checks if any coordinate in coords1 is edge-adjacent (shares a side) \n    to any coordinate in coords2.\n\n    Args:\n        coords1 (set or frozenset): Set of (row, col) tuples for the first object/position.\n        coords2 (set or frozenset): Set of (row, col) tuples for the second object.\n        \n    Returns:\n        bool: True if any part of coords1 is adjacent to coords2, False otherwise.\n    \"\"\"\n    # Iterate through each pixel in the first set of coordinates\n    for r1, c1 in coords1:\n        # Check its 4 cardinal neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (r1 + dr, c1 + dc)\n            # If the neighbor exists in the second set of coordinates, they are adjacent\n            if neighbor in coords2:\n                return True\n    # If no adjacent neighbors were found after checking all pixels, return False\n    return False\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the object movement transformation to the input grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient operations\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    background_color = 0 # Assuming standard ARC background color\n\n    # --- 1. Find all non-background objects in the grid ---\n    objects = find_objects(input_grid, background_color)\n\n    # --- 2. Check Assumption: Rule applies only if exactly two objects are found ---\n    if len(objects) != 2:\n        # If not exactly two objects, return the input grid unchanged.\n        return input_grid_list\n\n    # Assign the two found objects\n    obj_a, obj_b = objects[0], objects[1]\n\n    # --- 3. Determine Movement Axis, Moving/Static Objects, and Direction ---\n    \n    # Calculate separation distances between bounding boxes along horizontal and vertical axes\n    # Horizontal distance (positive if separated, negative/zero if overlapping/touching horizontally)\n    h_dist = -1 # Default: no clear horizontal separation\n    if obj_a.max_c < obj_b.min_c: # A is strictly left of B\n         h_dist = obj_b.min_c - obj_a.max_c - 1\n    elif obj_b.max_c < obj_a.min_c: # B is strictly left of A\n         h_dist = obj_a.min_c - obj_b.max_c - 1\n         \n    # Vertical distance (positive if separated, negative/zero if overlapping/touching vertically)\n    v_dist = -1 # Default: no clear vertical separation\n    if obj_a.max_r < obj_b.min_r: # A is strictly above B\n        v_dist = obj_b.min_r - obj_a.max_r - 1\n    elif obj_b.max_r < obj_a.min_r: # B is strictly above A\n        v_dist = obj_a.min_r - obj_b.max_r - 1\n\n    # Initialize variables for the moving object, static object, and movement direction\n    moving_obj, static_obj = None, None\n    direction = (0, 0) # (delta_row, delta_col) per step\n\n    # Determine the primary axis of movement based on the larger separation distance.\n    # If distances are equal and positive, prioritize horizontal (arbitrary choice, could be refined if needed).\n    if h_dist >= 0 and (h_dist >= v_dist or v_dist < 0) : # Horizontal separation is primary\n        # Use centroids to determine which object is \"further out\" (left or right)\n        if"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14596,
    "candidates_token_count": 1966,
    "total_token_count": 16562,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 71.343667,
  "retries": 1
}