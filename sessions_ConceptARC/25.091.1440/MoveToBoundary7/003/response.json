{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the following rule:\n1. Identifies two distinct non-background objects in the input grid. Assumes exactly two objects exist.\n2. Determines the primary axis of separation (horizontal or vertical) between the two objects based on the distance between their bounding boxes or centroids.\n3. Identifies one object as the \"moving\" object and the other as \"static\". The object that is \"further out\" along the separation axis (e.g., left object if separated horizontally, top object if separated vertically) is designated as the moving object.\n4. The moving object is translated pixel by pixel along the separation axis towards the static object.\n5. The movement stops when the moving object becomes edge-adjacent (shares a side, not just a corner) to the static object.\n6. The final output grid shows the static object in its original position and the moving object in its final, adjacent position. If the objects have the same color, they may appear merged in the output.\n\"\"\"\n\n# Helper Class for representing objects\nclass ArcObject:\n    \"\"\"Represents a contiguous object in the grid.\"\"\"\n    def __init__(self, color, coords):\n        if not coords:\n             raise ValueError(\"Cannot create ArcObject with empty coordinates.\")\n        self.color = color\n        self.coords = frozenset(coords) # Use frozenset for hashability if needed elsewhere\n        # Calculate bounding box immediately\n        self.min_r = min(r for r, c in coords)\n        self.max_r = max(r for r, c in coords)\n        self.min_c = min(c for r, c in coords)\n        self.max_c = max(c for r, c in coords)\n        self.centroid = self._calculate_centroid()\n\n    def _calculate_centroid(self):\n        \"\"\"Calculates the geometric center of the object.\"\"\"\n        sum_r = sum(r for r, c in self.coords)\n        sum_c = sum(c for r, c in self.coords)\n        count = len(self.coords)\n        return (sum_r / count, sum_c / count)\n\n    def get_shifted_coords(self, dr, dc):\n        \"\"\" Returns the set of coordinates if the object were shifted. \"\"\"\n        return frozenset((r + dr, c + dc) for r, c in self.coords)\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all distinct connected components (objects) of non-background colors\n    in the grid using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list[ArcObject]: A list of ArcObject instances found in the grid. Returns empty list if no objects found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = set() # Keep track of visited cells to avoid redundant searches\n\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not background and hasn't been visited yet\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set() # Coordinates belonging to this object\n                q = deque([(r, c)]) # Queue for BFS\n                visited.add((r, c))\n                coords.add((r, c))\n\n                # Start BFS from this cell\n                while q:\n                    row, col = q.popleft()\n                    # Explore 4 cardinal neighbors (North, South, East, West)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor is part of the object (same color) and not visited\n                            if (nr, nc) not in visited and grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                coords.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # Create an ArcObject if coordinates were found\n                if coords: \n                    objects.append(ArcObject(color, coords))\n    return objects\n\ndef check_adjacency(coords1, coords2):\n    \"\"\" Checks if any coordinate in coords1 is edge-adjacent to any coordinate in coords2. \"\"\"\n    for r1, c1 in coords1:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor = (r1 + dr, c1 + dc)\n            if neighbor in coords2:\n                return True\n    return False\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid by moving one object towards another until they touch.\n\n    Args:\n        input_grid_list (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    background_color = 0\n\n    # --- 1. Find Objects ---\n    objects = find_objects(input_grid, background_color)\n\n    # --- Assumption Check ---\n    # This rule specifically applies when there are exactly two objects.\n    if len(objects) != 2:\n        # Return the input unchanged if the assumption isn't met.\n        return input_grid_list\n\n    obj_a, obj_b = objects[0], objects[1]\n\n    # --- 2. Determine Axis, Moving/Static Objects, and Direction ---\n    # Use bounding boxes for separation calculation.\n    # Horizontal gap: max(0, obj_b.min_c - obj_a.max_c - 1) or max(0, obj_a.min_c - obj_b.max_c - 1)\n    # Vertical gap:   max(0, obj_b.min_r - obj_a.max_r - 1) or max(0, obj_a.min_r - obj_b.max_r - 1)\n\n    # Check horizontal separation first\n    h_sep = -1\n    if obj_a.max_c < obj_b.min_c: # A is strictly left of B\n         h_sep = obj_b.min_c - obj_a.max_c - 1\n    elif obj_b.max_c < obj_a.min_c: # B is strictly left of A\n         h_sep = obj_a.min_c - obj_b.max_c - 1\n         \n    # Check vertical separation\n    v_sep = -1\n    if obj_a.max_r < obj_b.min_r: # A is strictly above B\n        v_sep = obj_b.min_r - obj_a.max_r - 1\n    elif obj_b.max_r < obj_a.min_r: # B is strictly above A\n        v_sep = obj_a.min_r - obj_b.max_r - 1\n\n    moving_obj, static_obj = None, None\n    direction = (0, 0) # (dr, dc)\n\n    # Determine primary axis and roles based on larger separation\n    # Handle edge case where separations might be equal but non-zero - prioritize horizontal? Let's check examples.\n    # Ex1: h_sep=6, v_sep=-1 -> Horizontal. Ex2: h_sep=-1, v_sep=2 -> Vertical. Larger separation dominates.\n    if h_sep >= 0 and (h_sep >= v_sep or v_sep < 0) : # Horizontal separation is primary\n        if obj_a.max_c < obj_b.min_c: # A is left of B\n            moving_obj = obj_a\n            static_obj = obj_b\n            direction = (0, 1) # Move right\n        else: # B is left of A (obj_b.max_c < obj_a.min_c)\n            moving_obj = obj_b\n            static_obj = obj_a\n            direction = (0, 1) # Move right (B moves right towards A)\n            # Correction: If B is left of A, B should move right. If A is left of B, A should move right.\n            # Let's simplify: The leftmost object moves right.\n            if obj_a.min_c < obj_b.min_c:\n                moving_obj, static_obj = obj_a, obj_b\n                direction = (0, 1)\n            else:\n                moving_obj, static_obj = obj_b, obj_a\n                direction = (0, 1) # Error in reasoning. If B is further left, B moves right.\n            # Third attempt at logic: If A is left of B, A moves right. If B is left of A, B moves right. NO.\n            # If A is left of B, A moves right. If A is right of B, A moves left. YES. Use centroids? No, BB is fine.\n            if obj_a.centroid[1] < obj_b.centroid[1]: # A is left of B\n                moving_obj, static_obj = obj_a, obj_b\n                direction = (0, 1) # Move A right\n            else: # A is right of B\n                moving_obj, static_obj = obj_a, obj_b\n                direction = (0, -1) # Move A left\n    elif v_sep >= 0: # Vertical separation is primary\n        if obj_a.centroid[0] < obj_b.centroid[0]: # A is above B\n            moving_obj = obj_a\n            static_obj = obj_b\n            direction = (1, 0) # Move A down\n        else: # A is below B\n            moving_obj = obj_a\n            static_obj = obj_b\n            direction = (-1, 0) # Move A up\n    else:\n        # Objects are already touching or overlapping? Or separation only diagonal?\n        # Rule likely doesn't apply, return original grid.\n        return input_grid_list\n\n    # --- 3. Simulate Movement ---\n    output_grid = np.copy(input_grid)\n    current_coords = set(moving_obj.coords) # Use a mutable set for current position\n    static_coords_set = static_obj.coords # Keep as frozenset for efficiency\n\n    while True:\n        # Check if already adjacent before attempting to move\n        if check_adjacency(current_coords, static_coords_set):\n             break # Already touching, no move needed (or previous move was the last one)\n\n        # Calculate potential next position\n        dr, dc = direction\n        next_coords = set((r + dr, c + dc) for r, c in current_coords)\n\n        # Check bounds and direct collision with static object\n        possible_move = True\n        for nr, nc in next_coords:\n            if not (0 <= nr < height and 0 <= nc < width):\n                possible_move = False; break # Out of bounds\n            if (nr, nc) in static_coords_set:\n                possible_move = False; break # Direct collision\n        \n        if not possible_move:\n            break # Cannot make the next move\n\n        # Check if this move results in adjacency\n        adjacent_after_move = check_adjacency(next_coords, static_coords_set)\n\n        # Perform the move: Erase old, Draw new\n        for r, c in current_coords:\n             # Only erase if not part of the static object (needed if colors are the same)\n             # Safter: just erase the moving object's color at the old coords.\n             if output_grid[r,c] == moving_obj.color: # Check color to be safe\n                 output_grid[r, c] = background_color\n\n        for nr, nc in next_coords:\n            output_grid[nr, nc] = moving_obj.color # Draw moving object in new position\n\n        # Update current coordinates\n        current_coords = next_coords\n\n        # If the move we just made resulted in adjacency, stop\n        if adjacent_after_move:\n            break\n\n    # --- 4. Return final grid state ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18702,
    "candidates_token_count": 2910,
    "total_token_count": 21612,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.360796,
  "retries": 1
}