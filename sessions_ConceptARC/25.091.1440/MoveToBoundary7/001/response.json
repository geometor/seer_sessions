{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies two distinct non-background objects in the input grid. \nDetermines which object is 'moving' and which is 'static' based on their relative \npositions (calculated using centroids). The object positioned further out along \nthe primary axis of separation (horizontal or vertical) is considered the \nmoving object. The moving object is then translated pixel by pixel along that axis \ntowards the static object. The movement stops just before the moving object would \ncollide with (become edge-adjacent to) the static object or move out of the \ngrid boundaries. The static object remains in its original position. The final \ngrid reflects the new position of the moving object and the original position \nof the static object. Assumes exactly two non-background objects exist.\n\"\"\"\n\n# Helper Class for representing objects\nclass ArcObject:\n    \"\"\"Represents a contiguous object in the grid.\"\"\"\n    def __init__(self, color, coords):\n        self.color = color\n        self.coords = coords # set of (r, c) tuples\n        self.centroid = self._calculate_centroid()\n\n    def _calculate_centroid(self):\n        \"\"\"Calculates the geometric center of the object.\"\"\"\n        if not self.coords:\n            return (0.0, 0.0)\n        sum_r = sum(r for r, c in self.coords)\n        sum_c = sum(c for r, c in self.coords)\n        count = len(self.coords)\n        # Using float division for potentially non-integer centroid\n        return (sum_r / count, sum_c / count)\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all distinct connected components (objects) of non-background colors\n    in the grid using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The value representing the background.\n\n    Returns:\n        list[ArcObject]: A list of ArcObject instances found in the grid.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = set() # Keep track of visited cells to avoid redundant searches\n\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not background and hasn't been visited yet\n            if grid[r, c] != background_color and (r, c) not in visited:\n                color = grid[r, c]\n                coords = set() # Coordinates belonging to this object\n                q = deque([(r, c)]) # Queue for BFS\n                visited.add((r, c))\n                coords.add((r, c))\n\n                # Start BFS from this cell\n                while q:\n                    row, col = q.popleft()\n                    # Explore 4 cardinal neighbors (North, South, East, West)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor is part of the object (same color) and not visited\n                            if (nr, nc) not in visited and grid[nr, nc] == color:\n                                visited.add((nr, nc))\n                                coords.add((nr, nc))\n                                q.append((nr, nc))\n                \n                # If coordinates were found, create an ArcObject\n                if coords: \n                    objects.append(ArcObject(color, coords))\n    return objects\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the object movement rule.\n\n    Args:\n        input_grid_list (list[list[int]]): The input grid as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid as a list of lists.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    height, width = input_grid.shape\n    background_color = 0 # Standard ARC background\n\n    # --- 1. Find Objects ---\n    objects = find_objects(input_grid, background_color)\n\n    # --- Basic Assumption Check ---\n    # The observed rule applies specifically to two objects.\n    if len(objects) != 2:\n        # If the assumption isn't met, return the input unchanged as the rule doesn't apply.\n        # print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning input.\")\n        return input_grid_list \n        \n    obj1, obj2 = objects[0], objects[1]\n\n    # --- 2. Determine Moving/Static Objects and Direction ---\n    # Calculate centroids to determine relative positions\n    c1_r, c1_c = obj1.centroid\n    c2_r, c2_c = obj2.centroid\n\n    # Calculate difference in row and column coordinates\n    delta_r = abs(c1_r - c2_r)\n    delta_c = abs(c1_c - c2_c)\n\n    moving_obj, static_obj = None, None\n    direction = (0, 0) # Represents (dr, dc) for movement step\n\n    # Determine primary axis of separation and assign roles/direction\n    if delta_c > delta_r: # Primarily horizontal separation\n        if c1_c < c2_c: # obj1 is left of obj2\n            moving_obj = obj1\n            static_obj = obj2\n            direction = (0, 1) # Move right\n        else: # obj1 is right of obj2 (c1_c >= c2_c)\n            # Need to swap roles if obj1 is right\n            moving_obj = obj2 \n            static_obj = obj1\n            direction = (0, -1) # Move left (obj2 moves left towards obj1)\n            # Correction: Original logic assumed obj1 always moves if left/top.\n            # Corrected logic: The object 'further out' moves towards the other.\n            # If obj1 right of obj2, obj1 moves left towards obj2.\n            moving_obj = obj1\n            static_obj = obj2\n            direction = (0, -1) # Move left\n            \n    else: # Primarily vertical separation (or equal distance)\n        if c1_r < c2_r: # obj1 is above obj2\n            moving_obj = obj1\n            static_obj = obj2\n            direction = (1, 0) # Move down\n        else: # obj1 is below obj2 (c1_r >= c2_r)\n            # If obj1 below obj2, obj1 moves up towards obj2.\n            moving_obj = obj1\n            static_obj = obj2\n            direction = (-1, 0) # Move up\n\n\n    # --- 3. Simulate Movement ---\n    output_grid = np.copy(input_grid)\n    # Use a mutable set for the moving object's coordinates\n    current_coords = set(moving_obj.coords) \n    # Use an immutable set for the static object's coordinates (faster lookups)\n    static_coords_set = frozenset(static_obj.coords) \n\n    while True:\n        # Calculate the potential next position for the entire object\n        next_coords = set()\n        possible_move = True\n        for r, c in current_coords:\n            nr, nc = r + direction[0], c + direction[1]\n            \n            # Check if the next position of this pixel is within grid bounds\n            if not (0 <= nr < height and 0 <= nc < width):\n                possible_move = False # Entire object cannot make this move\n                break \n            next_coords.add((nr, nc))\n        \n        # If any part of the object would move out of bounds, stop\n        if not possible_move:\n            break \n\n        # Check if the potential next position is adjacent to the static object\n        adjacent = False\n        for nr, nc in next_coords:\n            # Check N, S, E, W neighbors of the potential next pixel position\n            for dr_adj, dc_adj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                neighbor_r, neighbor_c = nr + dr_adj, nc + dc_adj\n                # Check if this neighbor belongs to the static object\n                if (neighbor_r, neighbor_c) in static_coords_set:\n                    adjacent = True\n                    break # Found adjacency, no need to check further neighbors\n            if adjacent:\n                break # Found adjacency, no need to check other pixels in next_coords\n        \n        # If the next move would result in adjacency, stop *before* making the move\n        if adjacent:\n            break \n\n        # --- If move is valid (in bounds and not adjacent) ---\n        # Erase the object from its old position on the output grid\n        for r, c in current_coords:\n            output_grid[r, c] = background_color\n        \n        # Draw the object in its new position on the output grid\n        for nr, nc in next_coords:\n            # Check if the target cell is background (prevent overwriting static obj if colors are same)\n            # This check might be redundant if initial separation is guaranteed, but safe to include.\n             if output_grid[nr,nc] == background_color:\n                 output_grid[nr, nc] = moving_obj.color\n            # else: # This case shouldn't happen if objects start separate and static obj isn't background\n            #    pass # potentially overlapping non-background? ignore for now.\n            \n        # Update the current coordinates for the next iteration\n        current_coords = next_coords\n\n    # --- 4. Return final grid state ---\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3817,
    "candidates_token_count": 2275,
    "total_token_count": 6092,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 142.944793,
  "retries": 2
}