{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct orange (7) objects (4-connected components) in the input grid.\nCalculate the total height and total width spanned by all orange objects.\nIf total height >= total width, apply vertical gravity:\n  For each column, find the lowest orange pixel. Calculate the shift needed to move this pixel to the bottom row.\n  Shift all orange pixels in that column down by this amount.\nIf total height < total width, apply horizontal gravity:\n  For each row, find the rightmost orange pixel. Calculate the shift needed to move this pixel to the rightmost column.\n  Shift all orange pixels in that row right by this amount.\nThe output grid contains only the shifted orange pixels on a white background.\n\"\"\"\n\ndef find_objects(grid, color_to_find=7):\n    \"\"\"\n    Finds all connected components of a specific color in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        color_to_find (int): The color of the objects to find.\n\n    Returns:\n        list: A list of objects. Each object is a dictionary containing:\n              'pixels': set of (row, col) tuples for the object's pixels.\n              'min_r', 'max_r', 'min_c', 'max_c': Bounding box coordinates.\n              'height': Height of the bounding box.\n              'width': Width of the bounding box.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color_to_find and (r, c) not in visited:\n                # Start BFS to find a new object\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                obj_pixels.add((r, c))\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Update bounding box\n                    min_r = min(min_r, curr_r)\n                    max_r = max(max_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color_to_find and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            obj_pixels.add((nr, nc))\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    height = max_r - min_r + 1\n                    width = max_c - min_c + 1\n                    objects.append({\n                        'pixels': obj_pixels,\n                        'min_r': min_r, 'max_r': max_r,\n                        'min_c': min_c, 'max_c': max_c,\n                        'height': height, 'width': width\n                    })\n    return objects\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies conditional gravity (vertical or horizontal) to orange objects in the grid.\n\n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    orange_color = 7\n    background_color = 0\n\n    # Find all orange objects and their properties\n    objects = find_objects(input_grid, orange_color)\n\n    # Calculate total height and width\n    total_height = sum(obj['height'] for obj in objects)\n    total_width = sum(obj['width'] for obj in objects)\n\n    # Initialize output grid with background color\n    output_grid = np.full_like(input_grid, background_color)\n\n    # Get all orange pixel coordinates from the input grid\n    orange_pixels_input = np.argwhere(input_grid == orange_color) # list of [row, col]\n\n    if not orange_pixels_input.size > 0: # Handle empty input grid case\n        return output_grid\n\n    # Determine gravity direction\n    if total_height >= total_width:\n        # Apply Vertical Gravity (column-wise)\n        for c in range(cols):\n            # Find orange pixels in this column\n            col_pixels = orange_pixels_input[orange_pixels_input[:, 1] == c]\n            if col_pixels.size > 0:\n                # Find the lowest orange pixel in this column\n                max_r = np.max(col_pixels[:, 0])\n                # Calculate shift amount\n                shift = rows - 1 - max_r\n                # Apply shift to all orange pixels in this column\n                for r, _ in col_pixels:\n                    output_grid[r + shift, c] = orange_color\n    else:\n        # Apply Horizontal Gravity (row-wise)\n        for r in range(rows):\n            # Find orange pixels in this row\n            row_pixels = orange_pixels_input[orange_pixels_input[:, 0] == r]\n            if row_pixels.size > 0:\n                # Find the rightmost orange pixel in this row\n                max_c = np.max(row_pixels[:, 1])\n                # Calculate shift amount\n                shift = cols - 1 - max_c\n                # Apply shift to all orange pixels in this row\n                for _, c in row_pixels:\n                    output_grid[r, c + shift] = orange_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3463,
    "candidates_token_count": 1398,
    "total_token_count": 4861,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.939343,
  "retries": 1
}