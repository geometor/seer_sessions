{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTask Description:\nIdentify pairs of identical objects (P1, P2) that occupy the same rows but are horizontally separated.\nFind an object (A1) vertically adjacent (above or below) to one object of the pair (e.g., P1).\nIf the other object (P2) does not have a corresponding identical object (A2) in the same relative position,\ncopy object A1 and place the copy (A2_new) in the corresponding position relative to P2.\nThe relative horizontal alignment between A1 and P1 should be preserved between A2_new and P2.\nAll other elements in the grid remain unchanged.\n\"\"\"\n\n# Helper function to get 4-way neighbors\ndef get_neighbors(r, c, height, width):\n    \"\"\"Gets valid 4-way neighbors for a cell.\"\"\"\n    neighbors = []\n    if r > 0: neighbors.append((r - 1, c))\n    if r < height - 1: neighbors.append((r + 1, c))\n    if c > 0: neighbors.append((r, c - 1))\n    if c < width - 1: neighbors.append((r, c + 1))\n    return neighbors\n\n# Helper function to calculate a unique key for an object's shape relative to its top-left corner\ndef get_shape_key(coords, min_r, min_c):\n    \"\"\"Creates a tuple representation of an object's shape relative to its top-left corner.\"\"\"\n    relative_coords = tuple(sorted([(r - min_r, c - min_c) for r, c in coords]))\n    return relative_coords\n\n# Helper function to find all distinct objects (connected components) in the grid\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components of non-background pixels in the grid.\n    Returns a list of object dictionaries, each containing:\n    'color': pixel color value\n    'coords': set of (row, col) tuples belonging to the object\n    'bbox': tuple (min_row, max_row, min_col, max_col)\n    'shape_key': tuple representing the relative shape\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 0\n\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not background and not visited yet, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(row, col, height, width):\n                        if grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Calculate shape key and store object details\n                shape_key = get_shape_key(coords, min_r, min_c)\n                objects.append({\n                    'id': object_id_counter, # Add a unique ID for easier tracking\n                    'color': color,\n                    'coords': coords,\n                    'bbox': (min_r, max_r, min_c, max_c),\n                    'shape_key': shape_key\n                })\n                object_id_counter += 1\n                \n    return objects\n\n# Helper function to check if two objects are identical in color, shape, and size\ndef are_objects_identical(obj1, obj2):\n    \"\"\"Checks if two objects have the same color, relative shape, and dimensions.\"\"\"\n    # Check color\n    if obj1['color'] != obj2['color']:\n        return False\n    # Check shape key (relative coordinates)\n    if obj1['shape_key'] != obj2['shape_key']:\n        return False\n    # Check dimensions (redundant if shape_key matches, but good sanity check)\n    bbox1 = obj1['bbox']\n    bbox2 = obj2['bbox']\n    height1 = bbox1[1] - bbox1[0]\n    width1 = bbox1[3] - bbox1[2]\n    height2 = bbox2[1] - bbox2[0]\n    width2 = bbox2[3] - bbox2[2]\n    if height1 != height2 or width1 != width2:\n        return False\n        \n    return True\n\n# Helper function to determine the vertical relative position of obj_assoc to obj_base\ndef get_relative_position(obj_assoc, obj_base):\n    \"\"\"Determines if obj_assoc is 'above' or 'below' obj_base based on row bounds.\"\"\"\n    assoc_min_r, assoc_max_r, _, _ = obj_assoc['bbox']\n    base_min_r, base_max_r, _, _ = obj_base['bbox']\n    \n    # Check if associated object is strictly above the base object\n    if assoc_max_r < base_min_r:\n        return 'above'\n    # Check if associated object is strictly below the base object\n    if assoc_min_r > base_max_r:\n        return 'below'\n        \n    return None # Objects overlap vertically or are side-by-side\n\n# Main transformation function\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the identified pattern:\n    Copies an associated object from one member of a horizontal pair to the other if it's missing.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Create a copy to modify and return\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find all non-background objects in the input grid\n    objects = find_objects(input_grid)\n    num_objects = len(objects)\n    # Keep track of processed base pairs (by their unique IDs) to avoid redundant checks or copies\n    processed_pair_ids = set() \n\n    # Iterate through all unique pairs of objects to find potential base pairs (P1, P2)\n    for i in range(num_objects):\n        for j in range(i + 1, num_objects):\n            obj1 = objects[i]\n            obj2 = objects[j]\n\n            # Determine which object is left (P1) and which is right (P2) based on column start\n            if obj1['bbox'][2] < obj2['bbox'][2]:\n                P1, P2 = obj1, obj2\n            elif obj2['bbox'][2] < obj1['bbox'][2]:\n                P1, P2 = obj2, obj1\n            else:\n                continue # Objects start in the same column, cannot be the horizontal pair we seek\n\n            pair_key = tuple(sorted((P1['id'], P2['id'])))\n            if pair_key in processed_pair_ids:\n                continue # This pair has already been processed\n\n            # Check criteria for a valid base pair:\n            # 1. Identical shape, color, size\n            is_identical = are_objects_identical(P1, P2)\n            # 2. Occupy the exact same row range\n            same_rows = (P1['bbox'][0] == P2['bbox'][0] and P1['bbox'][1] == P2['bbox'][1])\n            # 3. P1 is strictly to the left of P2\n            horizontally_separated = P1['bbox'][3] < P2['bbox'][2]\n\n            if is_identical and same_rows and horizontally_separated:\n                # Found a valid pair (P1, P2). Now search for an associated object A1 for P1.\n                for k in range(num_objects):\n                    # Skip if the object is P1 or P2\n                    if objects[k]['id'] == P1['id'] or objects[k]['id'] == P2['id']: \n                        continue\n\n                    A1 = objects[k]\n                    # Check if A1 is vertically associated (above or below) P1\n                    rel_pos_A1_P1 = get_relative_position(A1, P1)\n\n                    if rel_pos_A1_P1 in ['above', 'below']:\n                        # Found potential associated object A1. \n                        # Check if P2 already has a corresponding counterpart A2.\n                        found_A2 = False\n                        for l in range(num_objects):\n                            # Skip if the object is P1, P2, or A1\n                            if objects[l]['id'] in (P1['id'], P2['id'], A1['id']): \n                                continue\n\n                            A2_candidate = objects[l]\n                            \n                            # Check if A2_candidate matches A1 criteria:\n                            # 1. Identical to A1\n                            is_cand_identical = are_objects_identical(A1, A2_candidate)\n                            # 2. Occupies the same row range as A1\n                            same_cand_rows = (A1['bbox'][0] == A2_candidate['bbox'][0] and A1['bbox'][1] == A2_candidate['bbox'][1])\n                            # 3. Has the same relative vertical position to P2 as A1 has to P1\n                            same_cand_rel_pos = (get_relative_position(A2_candidate, P2) == rel_pos_A1_P1)\n                            \n                            if is_cand_identical and same_cand_rows and same_cand_rel_pos:\n                                found_A2 = True\n                                break # Counterpart exists, no copy needed for this A1\n\n                        # If no counterpart A2 was found for this A1, we need to copy A1\n                        if not found_A2:\n                            # Mark this base pair (P1, P2) as processed so we don't try to copy again\n                            processed_pair_ids.add(pair_key) \n\n                            # Calculate the top-left starting position for the copied object (A2_new)\n                            A1_min_r, _, A1_min_c, _ = A1['bbox']\n                            P1_min_c = P1['bbox'][2] # Leftmost column of P1\n                            P2_min_c = P2['bbox'][2] # Leftmost column of P2\n\n                            # Calculate column offset of A1 relative to P1\n                            offset_col = A1_min_c - P1_min_c\n                            # Calculate target start column for A2_new relative to"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4340,
    "candidates_token_count": 2580,
    "total_token_count": 6920,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 68.957786,
  "retries": 1
}