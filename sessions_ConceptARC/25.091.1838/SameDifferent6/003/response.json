{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct contiguous objects of non-black colors (Outer Colors) in the input grid.\nDetermines a 'Special Color': the unique color present in the grid that is neither black (0) nor one of the Outer Colors. If no such unique color exists, the Special Color is 0.\nSelects an Outer Color for removal based on the Special Color:\n- If the Special Color is 0, remove the second smallest Outer Color (if it exists).\n- If the Special Color is non-zero, remove the smallest Outer Color (if it exists).\nConstructs the output grid by copying only the pixels belonging to the objects whose Outer Color was *not* selected for removal.\n\"\"\"\n\ndef _find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-black color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int) and 'pixels' (set of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # If it's a non-black pixel and hasn't been visited yet, start BFS\n            if color != 0 and not visited[r, c]:\n                obj_pixels = set()\n                obj_color = color\n                q = deque([(r, c)])\n                visited[r, c] = True\n                is_primary_object = True # Assume primary initially\n\n                # We perform BFS to find all pixels of this object first\n                current_object_pixels = set()\n                bfs_q = deque([(r, c)])\n                bfs_visited_local = set([(r,c)]) # Keep track for this specific BFS\n\n                while bfs_q:\n                    row, col = bfs_q.popleft()\n                    current_object_pixels.add((row, col))\n                    \n                    # Check 4 neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds, same color, and not visited in this BFS\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == obj_color and (nr, nc) not in bfs_visited_local:\n                            bfs_visited_local.add((nr, nc))\n                            bfs_q.append((nr, nc))\n\n                # Now mark all pixels of this object as visited globally\n                for R, C in current_object_pixels:\n                   visited[R, C] = True\n\n                # Store the object found\n                objects.append({'color': obj_color, 'pixels': current_object_pixels})\n\n    return objects\n\n\ndef _get_special_color(grid, outer_colors_set):\n    \"\"\"\n    Determines the unique color in the grid that is not black (0) and not\n    one of the specified outer colors.\n\n    Args:\n        grid (np.array): The input grid.\n        outer_colors_set (set): A set of the unique outer colors of the objects.\n\n    Returns:\n        int: The identified special color, or 0 if none or multiple exist.\n    \"\"\"\n    unique_grid_colors = set(grid.flatten())\n    \n    # Find colors in the grid that are not black and not outer colors\n    potential_special_colors = unique_grid_colors - outer_colors_set - {0}\n    \n    if len(potential_special_colors) == 1:\n        # If exactly one such color exists, it's the special color\n        return potential_special_colors.pop()\n    else:\n        # If zero or more than one such color exists, the special color is black\n        return 0\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on object colors and the special color.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n\n    # 1. Identify Primary Objects and Outer Colors\n    objects = _find_objects(input_array)\n    if not objects: # Handle empty grid or grid with only black pixels\n        return input_grid # Return original grid if no objects found\n\n    outer_colors_set = set(obj['color'] for obj in objects)\n    sorted_outer_colors = sorted(list(outer_colors_set))\n\n    # 2. Identify the Special Color\n    special_color = _get_special_color(input_array, outer_colors_set)\n\n    # 3. Determine the Color To Remove\n    color_to_remove = -1 # Initialize with an invalid color, meaning nothing removed by default\n\n    if special_color == 0:\n        # If special color is black, remove the second smallest outer color\n        if len(sorted_outer_colors) >= 2:\n            color_to_remove = sorted_outer_colors[1]\n    else:\n        # If special color is non-black, remove the smallest outer color\n        if len(sorted_outer_colors) >= 1:\n            color_to_remove = sorted_outer_colors[0]\n\n    # 4. Construct the Output Grid\n    # Initialize output grid with background color (black)\n    output_array = np.zeros_like(input_array, dtype=int)\n\n    # Iterate through the found objects\n    for obj in objects:\n        # If the object's color is NOT the one to be removed, copy its pixels\n        if obj['color'] != color_to_remove:\n            for r, c in obj['pixels']:\n                # Ensure coordinates are valid just in case (should always be)\n                if 0 <= r < rows and 0 <= c < cols:\n                     # Directly use the object's color\n                     output_array[r, c] = obj['color']\n\n    # Convert the output numpy array back to a list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14121,
    "candidates_token_count": 1464,
    "total_token_count": 15585,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.292411,
  "retries": 1
}