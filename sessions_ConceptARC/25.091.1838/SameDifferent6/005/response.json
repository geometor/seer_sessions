{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct contiguous objects of non-black colors (Outer Colors) in the input grid.\nDetermines a 'Special Color': the unique color present in the grid that is neither black (0) nor one of the Outer Colors. If no such unique color exists, the Special Color is defined as Black (0).\nSelects an Outer Color for removal based on the Special Color:\n- If the Special Color is 0, remove the second smallest Outer Color (if it exists).\n- If the Special Color is non-zero, remove the smallest Outer Color (if it exists).\nConstructs the output grid by starting with a copy of the input and changing the pixels of the objects selected for removal to black (0).\n\"\"\"\n\ndef _find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-black color in the grid using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color' (int) and 'pixels' (set of (r, c) tuples).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # If it's a non-black pixel and hasn't been visited yet, start BFS\n            if color != 0 and not visited[r, c]:\n                obj_color = color\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check bounds, same color, and not visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == obj_color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'color': obj_color, 'pixels': current_object_pixels})\n                \n    return objects\n\n\ndef _get_special_color(grid, outer_colors_set):\n    \"\"\"\n    Determines the unique color in the grid that is not black (0) and not\n    one of the specified outer colors.\n\n    Args:\n        grid (np.array): The input grid.\n        outer_colors_set (set): A set of the unique outer colors of the objects.\n\n    Returns:\n        int: The identified special color, or 0 if none or multiple exist.\n    \"\"\"\n    unique_grid_colors = set(grid.flatten())\n    \n    # Find colors in the grid that are not black and not outer colors\n    potential_special_colors = unique_grid_colors - outer_colors_set - {0}\n    \n    if len(potential_special_colors) == 1:\n        # If exactly one such color exists, it's the special color\n        return potential_special_colors.pop()\n    else:\n        # If zero or more than one such color exists, the special color is black (0)\n        return 0\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on object colors and the special color.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier processing\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # 1. Create a copy of the input grid to modify\n    output_array = np.copy(input_array)\n\n    # 2. Identify Objects and their Outer Colors\n    objects = _find_objects(input_array)\n    if not objects: # Handle empty grid or grid with only black pixels\n        return input_grid # Return original grid if no objects found\n\n    outer_colors_set = set(obj['color'] for obj in objects)\n    sorted_outer_colors = sorted(list(outer_colors_set))\n\n    # 3. Identify the Special Color\n    special_color = _get_special_color(input_array, outer_colors_set)\n\n    # 4. Determine the Color To Remove\n    color_to_remove = -1 # Initialize with an invalid color, meaning nothing removed by default\n\n    if special_color == 0:\n        # If special color is black, target the second smallest outer color\n        if len(sorted_outer_colors) >= 2:\n            color_to_remove = sorted_outer_colors[1]\n    else:\n        # If special color is non-black, target the smallest outer color\n        if len(sorted_outer_colors) >= 1:\n            color_to_remove = sorted_outer_colors[0]\n\n    # 5. Modify the Output Grid by removing targeted objects\n    if color_to_remove != -1: # Check if a color was actually selected for removal\n        # Iterate through the found objects\n        for obj in objects:\n            # If the object's color is the one to be removed\n            if obj['color'] == color_to_remove:\n                # Iterate through the pixels of this object\n                for r, c in obj['pixels']:\n                    # Set the corresponding pixel in the output grid to black (0)\n                    if 0 <= r < rows and 0 <= c < cols: # Boundary check (mostly for safety)\n                         output_array[r, c] = 0\n\n    # Convert the output numpy array back to a list of lists\n    output_grid = output_array.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13043,
    "candidates_token_count": 1391,
    "total_token_count": 14434,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.387824,
  "retries": 1
}