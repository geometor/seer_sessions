{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\nimport math\n\n\"\"\"\nIdentifies the two largest non-white objects in the input grid.\nOne object (source) contains an internal pattern composed of pixels of a single color different from the object's primary color and the background (white).\nThis pattern is then transferred to the second largest object (target).\nThe transfer is based on aligning the centers of the bounding boxes of the source and target objects.\nThe translation vector calculated from the center alignment is applied to the absolute coordinates of the source pattern pixels to determine their new locations in the output grid.\nThe pattern color replaces the existing color at these new target locations. All other pixels remain unchanged.\n\"\"\"\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get valid 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects_bfs(grid):\n    \"\"\" Finds connected components of non-white pixels using BFS. \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-white pixel and not yet visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_pixels = []\n                obj_colors = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n                current_color = grid[r,c] # Color of the starting pixel of the component\n\n                component_queue = deque([(r,c)]) # Use a separate queue for BFS within the same color component\n                component_visited = set([(r,c)])\n\n                while component_queue:\n                    curr_r, curr_c = component_queue.popleft()\n\n                    obj_pixels.append((curr_r, curr_c))\n                    obj_colors.append(grid[curr_r, curr_c])\n\n                    # Update bounding box coordinates\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, rows, cols):\n                        # Add to component queue only if it has the same color and not visited for this component\n                        if grid[nr, nc] == current_color and (nr, nc) not in component_visited:\n                            visited[nr, nc] = True # Mark globally visited\n                            component_visited.add((nr, nc))\n                            component_queue.append((nr, nc))\n                        # Also mark neighbors of different non-zero colors as visited to prevent starting BFS from them later\n                        elif grid[nr,nc] != 0 and not visited[nr,nc]:\n                             visited[nr, nc] = True # Mark globally visited so we don't start BFS from here\n\n                if obj_pixels:\n                    # Determine primary color (most frequent non-white, should be the component color here)\n                    color_counts = Counter(obj_colors)\n                    primary_color = color_counts.most_common(1)[0][0]\n\n                    # Bounding box (inclusive max for coords, +1 for range/slicing)\n                    bbox = (min_r, min_c, max_r + 1, max_c + 1)\n\n                    objects.append({\n                        'pixels': obj_pixels,\n                        'bbox': bbox,\n                        'primary_color': primary_color,\n                        'size': len(obj_pixels)\n                    })\n\n    # Sort objects by size (descending)\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef _calculate_bbox_center(bbox):\n    \"\"\" Calculates the center of a bounding box. \"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    center_r = min_r + (max_r - min_r) / 2.0\n    center_c = min_c + (max_c - min_c) / 2.0\n    return center_r, center_c\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying an internal pattern from a source\n    object to a target object, aligning by bounding box centers.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify all non-white objects\n    # Using skimage.measure.label for potentially better handling of complex shapes\n    # Revert to BFS if skimage is not allowed or fails\n    try:\n        from skimage.measure import label, regionprops\n        labeled_grid = label(input_grid > 0, connectivity=2) # 8-way connectivity\n        regions = regionprops(labeled_grid, intensity_image=input_grid)\n        objects = []\n        for region in regions:\n             pixels = tuple(map(tuple, region.coords.T))\n             if not pixels: continue\n             non_white_colors = [c for c in region.intensity_image[region.image].flatten() if c != 0]\n             if not non_white_colors: continue\n             primary_color = Counter(non_white_colors).most_common(1)[0][0]\n             objects.append({\n                 'pixels': list(pixels),\n                 'bbox': region.bbox, # (min_r, min_c, max_r, max_c) - exclusive max\n                 'primary_color': primary_color,\n                 'size': region.area # region.area should be count of non-zero pixels\n             })\n        objects.sort(key=lambda o: o['size'], reverse=True)\n\n    except ImportError:\n        # Fallback to BFS if skimage is not available\n        print(\"Warning: skimage not found, using BFS for object detection.\")\n        objects = _find_objects_bfs(input_grid)\n\n\n    # 2. Need at least two objects for the transformation\n    if len(objects) < 2:\n        return output_grid # No transformation possible\n\n    # 3. Assume the two largest objects are the source/target pair\n    obj_a = objects[0]\n    obj_b = objects[1]\n\n    # 4. Try to find the source, target, pattern color, and pattern absolute coordinates\n    source_object = None\n    target_object = None\n    pattern_color = None\n    pattern_coords_absolute = [] # Store absolute coordinates\n\n    # Function to check an object for a pattern and return absolute coords\n    def check_for_pattern(potential_source):\n        bbox = potential_source['bbox']\n        min_r, min_c, max_r, max_c = bbox # Exclusive max convention from regionprops/BFS bbox format\n        primary_color = potential_source['primary_color']\n\n        found_pattern = False\n        potential_pattern_color = -1\n        abs_coords = []\n\n        # Iterate through the bounding box of the potential source\n        for r in range(min_r, max_r):\n            for c in range(min_c, max_c):\n                 # Check grid bounds rigorously\n                if 0 <= r < rows and 0 <= c < cols:\n                    color = input_grid[r, c]\n                    # Look for a color that is not background (0) and not the object's primary color\n                    if color != 0 and color != primary_color:\n                        # If this is the first pattern pixel found, store its color\n                        if not found_pattern:\n                            potential_pattern_color = color\n                            found_pattern = True\n\n                        # Ensure all pattern pixels have the same color (task assumption)\n                        if color == potential_pattern_color:\n                            # Store absolute coordinates\n                            abs_coords.append((r, c))\n                        else:\n                            # Found a different internal color - this object doesn't fit the simple pattern model\n                            return False, -1, []\n\n        return found_pattern, potential_pattern_color, abs_coords\n\n    # Check Object A as potential source\n    found_in_a, color_a, coords_a = check_for_pattern(obj_a)\n    if found_in_a:\n        source_object = obj_a\n        target_object = obj_b\n        pattern_color = color_a\n        pattern_coords_absolute = coords_a\n    else:\n        # Check Object B as potential source\n        found_in_b, color_b, coords_b = check_for_pattern(obj_b)\n        if found_in_b:\n            source_object = obj_b\n            target_object = obj_a\n            pattern_color = color_b\n            pattern_coords_absolute = coords_b\n\n    # 5. If no source/pattern was identified, return the original grid\n    if source_object is None or pattern_color is None or not pattern_coords_absolute:\n        return output_grid\n\n    # 6. Calculate centers and translation vector\n    source_bbox = source_object['bbox']\n    target_bbox = target_object['bbox']\n\n    source_center_r, source_center_c = _calculate_bbox_center(source_bbox)\n    target_center_r, target_center_c = _calculate_bbox_center(target_bbox)\n\n    delta_r = target_center_r - source_center_r\n    delta_c = target_center_c - source_center_c\n\n    # 7. Apply the translated pattern to the target object locations in the output grid\n    for src_r, src_c in pattern_coords_absolute:\n        # Calculate target coordinates by applying the translation vector\n        # Round to nearest integer for pixel coordinates\n        target_r = round(src_r + delta_r)\n        target_c = round(src_c + delta_c)\n\n        # Check if the calculated coordinates are within the grid bounds\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n            # Update the output grid with the pattern color at the target location\n            output_grid[target_r, target_c] = pattern_color\n\n    # 8. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10318,
    "candidates_token_count": 2512,
    "total_token_count": 12830,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.978625,
  "retries": 1
}