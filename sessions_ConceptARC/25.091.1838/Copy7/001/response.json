{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\nfrom skimage.measure import label, regionprops\n\n\"\"\"\nCopies an internal color pattern from a source object to a target object based on relative positions within their bounding boxes.\n\n1.  Identify all connected components (objects) of non-white pixels.\n2.  Select the two largest objects based on pixel count.\n3.  Determine which of these two is the 'source' (contains an internal pattern of a different color) and which is the 'target'. The pattern color is the color found inside the source's bounding box that differs from the source's primary color and isn't white.\n4.  Calculate the relative coordinates of the pattern pixels within the source object's bounding box.\n5.  Apply these relative coordinates to the target object's bounding box to determine the locations to imprint the pattern color onto the output grid.\n6.  Pixels not part of the imprinted pattern retain their original colors.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-white pixels using 8-way connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, each representing an object with keys:\n              'pixels': list of (row, col) tuples.\n              'bbox': (min_row, min_col, max_row, max_col).\n              'primary_color': The most frequent non-white color in the object.\n              'size': Number of pixels in the object.\n    \"\"\"\n    labeled_grid = label(grid > 0, connectivity=2) # connectivity=2 means 8-way\n    objects = []\n    for region in regionprops(labeled_grid):\n        pixels = tuple(map(tuple, region.coords.T)) # Convert coords to list of (r, c) tuples\n        if not pixels:\n            continue\n\n        # Extract colors of the object pixels from the original grid\n        obj_colors = [grid[r, c] for r, c in pixels]\n\n        # Filter out potential background pixels if necessary (though label should handle this)\n        non_white_colors = [c for c in obj_colors if c != 0]\n        if not non_white_colors:\n            continue # Skip if only white pixels somehow got included\n\n        # Determine primary color (most frequent non-white)\n        color_counts = Counter(non_white_colors)\n        primary_color = color_counts.most_common(1)[0][0]\n\n        objects.append({\n            'pixels': list(pixels),\n            'bbox': region.bbox, # (min_row, min_col, max_row, max_col)\n            'primary_color': primary_color,\n            'size': len(pixels)\n        })\n    # Sort objects by size (descending)\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef get_pixels_in_bbox(grid, bbox):\n    \"\"\"Gets all pixels within a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    pixels = {}\n    for r in range(min_r, max_r):\n        for c in range(min_c, max_c):\n            pixels[(r, c)] = grid[r, c]\n    return pixels\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying an internal pattern from a source\n    object to a target object.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify Objects\n    objects = find_objects(input_grid)\n\n    # 2. Select Main Objects (need at least two)\n    if len(objects) < 2:\n        return output_grid # Not enough objects to perform the transformation\n\n    # For simplicity, assume the two largest objects are the source/target pair\n    obj_a = objects[0]\n    obj_b = objects[1]\n\n    # 3. Find Source, Target, and Pattern\n    source_object = None\n    target_object = None\n    pattern_color = None\n    pattern_coords_relative = []\n\n    # Check Object A as potential source\n    bbox_a = obj_a['bbox']\n    min_ra, min_ca, max_ra, max_ca = bbox_a\n    primary_color_a = obj_a['primary_color']\n    found_pattern_in_a = False\n    temp_pattern_coords_a = []\n    temp_pattern_color_a = -1 # Invalid color init\n\n    for r in range(min_ra, max_ra):\n        for c in range(min_ca, max_ca):\n            color = input_grid[r, c]\n            if color != 0 and color != primary_color_a:\n                if not found_pattern_in_a: # First pattern pixel found\n                    temp_pattern_color_a = color\n                    found_pattern_in_a = True\n                # Ensure all pattern pixels have the same color (assumption)\n                if color == temp_pattern_color_a:\n                    temp_pattern_coords_a.append((r - min_ra, c - min_ca))\n\n    if found_pattern_in_a:\n        source_object = obj_a\n        target_object = obj_b\n        pattern_color = temp_pattern_color_a\n        pattern_coords_relative = temp_pattern_coords_a\n    else:\n        # Check Object B as potential source\n        bbox_b = obj_b['bbox']\n        min_rb, min_cb, max_rb, max_cb = bbox_b\n        primary_color_b = obj_b['primary_color']\n        found_pattern_in_b = False\n        temp_pattern_coords_b = []\n        temp_pattern_color_b = -1\n\n        for r in range(min_rb, max_rb):\n            for c in range(min_cb, max_cb):\n                color = input_grid[r, c]\n                if color != 0 and color != primary_color_b:\n                    if not found_pattern_in_b:\n                        temp_pattern_color_b = color\n                        found_pattern_in_b = True\n                    if color == temp_pattern_color_b:\n                       temp_pattern_coords_b.append((r - min_rb, c - min_cb))\n\n        if found_pattern_in_b:\n            source_object = obj_b\n            target_object = obj_a\n            pattern_color = temp_pattern_color_b\n            pattern_coords_relative = temp_pattern_coords_b\n\n    # If no source/pattern found after checking both, return original\n    if source_object is None or pattern_color is None:\n        return output_grid\n\n    # 4. Apply Pattern to Target\n    target_bbox = target_object['bbox']\n    min_rt, min_ct, _, _ = target_bbox # Only need top-left corner\n\n    for dr, dc in pattern_coords_relative:\n        target_r = min_rt + dr\n        target_c = min_ct + dc\n\n        # Check bounds before applying\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n            output_grid[target_r, target_c] = pattern_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3620,
    "candidates_token_count": 1713,
    "total_token_count": 5333,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.118755,
  "retries": 1
}