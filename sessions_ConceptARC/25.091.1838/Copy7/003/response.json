{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\n\n\"\"\"\nIdentifies the two largest non-white objects in the input grid.\nOne object (source) contains an internal pattern composed of pixels of a single color different from the object's primary color and the background (white).\nThis pattern's relative position within the source object's bounding box is determined.\nThe pattern is then copied (imprinted) onto the second largest object (target) by applying the same relative coordinates to the target object's bounding box.\nThe pattern color replaces the existing color at the target locations. All other pixels remain unchanged.\n\"\"\"\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get valid 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects_bfs(grid):\n    \"\"\" Finds connected components of non-white pixels using BFS. \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-white pixel and not yet visited, start BFS\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_pixels = []\n                obj_colors = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    obj_pixels.append((curr_r, curr_c))\n                    obj_colors.append(grid[curr_r, curr_c])\n\n                    # Update bounding box coordinates\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, rows, cols):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    # Determine primary color (most frequent non-white)\n                    color_counts = Counter(obj_colors)\n                    primary_color = color_counts.most_common(1)[0][0]\n                    \n                    # Bounding box (inclusive max)\n                    bbox = (min_r, min_c, max_r + 1, max_c + 1) # Use +1 for max to align with slicing/range\n\n                    objects.append({\n                        'pixels': obj_pixels,\n                        'bbox': bbox,\n                        'primary_color': primary_color,\n                        'size': len(obj_pixels)\n                    })\n\n    # Sort objects by size (descending)\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by copying an internal pattern from a source\n    object to a target object.\n    \"\"\"\n    # Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 1. Identify all non-white objects\n    objects = _find_objects_bfs(input_grid)\n\n    # 2. Need at least two objects for the transformation\n    if len(objects) < 2:\n        return output_grid # No transformation possible\n\n    # 3. Assume the two largest objects are the source/target pair\n    obj_a = objects[0]\n    obj_b = objects[1]\n\n    # 4. Try to find the source, target, pattern color, and pattern relative coordinates\n    source_object = None\n    target_object = None\n    pattern_color = None\n    pattern_coords_relative = []\n\n    # Function to check an object for a pattern\n    def check_for_pattern(potential_source):\n        bbox = potential_source['bbox']\n        min_r, min_c, max_r, max_c = bbox\n        primary_color = potential_source['primary_color']\n        \n        found_pattern = False\n        potential_pattern_color = -1\n        coords = []\n\n        # Iterate through the bounding box of the potential source\n        for r in range(min_r, max_r):\n            for c in range(min_c, max_c):\n                # Check bounds just in case bbox goes slightly out (shouldn't with BFS approach)\n                if 0 <= r < rows and 0 <= c < cols:\n                    color = input_grid[r, c]\n                    # Look for a color that is not background (0) and not the object's primary color\n                    if color != 0 and color != primary_color:\n                        # If this is the first pattern pixel found, store its color\n                        if not found_pattern:\n                            potential_pattern_color = color\n                            found_pattern = True\n                        \n                        # Ensure all pattern pixels have the same color (task assumption)\n                        if color == potential_pattern_color:\n                            # Store relative coordinates (relative to bbox top-left)\n                            coords.append((r - min_r, c - min_c))\n                        else:\n                            # Found a different internal color - this object doesn't fit the simple pattern model\n                            return False, -1, [] \n                            \n        return found_pattern, potential_pattern_color, coords\n\n    # Check Object A as potential source\n    found_in_a, color_a, coords_a = check_for_pattern(obj_a)\n    if found_in_a:\n        source_object = obj_a\n        target_object = obj_b\n        pattern_color = color_a\n        pattern_coords_relative = coords_a\n    else:\n        # Check Object B as potential source\n        found_in_b, color_b, coords_b = check_for_pattern(obj_b)\n        if found_in_b:\n            source_object = obj_b\n            target_object = obj_a\n            pattern_color = color_b\n            pattern_coords_relative = coords_b\n\n    # 5. If no source/pattern was identified, return the original grid\n    if source_object is None or pattern_color is None or not pattern_coords_relative:\n        return output_grid\n\n    # 6. Apply the pattern to the target object\n    target_bbox = target_object['bbox']\n    min_rt, min_ct, _, _ = target_bbox # Target top-left corner\n\n    for dr, dc in pattern_coords_relative:\n        # Calculate absolute coordinates in the target area\n        target_r = min_rt + dr\n        target_c = min_ct + dc\n\n        # Check if the calculated coordinates are within the grid bounds\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n            # Update the output grid with the pattern color at the target location\n            output_grid[target_r, target_c] = pattern_color\n\n    # 7. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7126,
    "candidates_token_count": 1792,
    "total_token_count": 8918,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.343819,
  "retries": 1
}