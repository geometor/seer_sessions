{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque, Counter\nimport math\n\n\"\"\"\nIdentifies the two largest non-white objects in the input grid.\nOne object (source) contains an internal pattern composed of pixels of a single color \ndifferent from the object's primary color and the background (white).\nThis pattern is then transferred to the second largest object (target).\nThe transfer is based on aligning the centers of the bounding boxes of the source \nand target objects. The translation vector calculated from this center alignment \nis applied to the absolute coordinates of the source pattern pixels to determine \ntheir new locations. The pattern color replaces the existing color at these new \ntarget locations only if the new location falls within the target object's \noriginal bounding box. All other pixels remain unchanged.\n\"\"\"\n\n# === Helper Functions ===\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\" Helper function to get valid 8-way neighbors within grid bounds. \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef _find_objects_bfs(grid):\n    \"\"\" Finds connected components of non-white pixels using BFS. \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 1\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS from an unvisited non-white pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                obj_pixels = []\n                obj_colors = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Perform BFS to find all connected non-white pixels for this object\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    obj_pixels.append((curr_r, curr_c))\n                    obj_colors.append(grid[curr_r, curr_c])\n\n                    # Update bounding box coordinates (inclusive)\n                    min_r = min(min_r, curr_r)\n                    min_c = min(min_c, curr_c)\n                    max_r = max(max_r, curr_r)\n                    max_c = max(max_c, curr_c)\n\n                    # Explore neighbors\n                    for nr, nc in _get_neighbors(curr_r, curr_c, rows, cols):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    # Determine primary color (most frequent non-white color in the object)\n                    non_white_colors = [col for col in obj_colors if col != 0]\n                    if not non_white_colors: continue # Skip if only background somehow included\n                    primary_color = Counter(non_white_colors).most_common(1)[0][0]\n                    \n                    # Bounding box (exclusive max: min_row, min_col, max_row + 1, max_col + 1)\n                    bbox = (min_r, min_c, max_r + 1, max_c + 1) \n\n                    objects.append({\n                        'id': object_id_counter,\n                        'pixels': obj_pixels,\n                        'bbox': bbox,\n                        'primary_color': primary_color,\n                        'size': len(obj_pixels) # Use actual pixel count\n                    })\n                    object_id_counter += 1\n\n    # Sort objects by size (descending) to easily find the largest ones\n    objects.sort(key=lambda o: o['size'], reverse=True)\n    return objects\n\ndef _calculate_bbox_center(bbox):\n    \"\"\" Calculates the geometric center of a bounding box. \"\"\"\n    min_r, min_c, max_r, max_c = bbox # bbox uses exclusive max\n    center_r = min_r + (max_r - min_r) / 2.0\n    center_c = min_c + (max_c - min_c) / 2.0\n    return center_r, center_c\n\ndef _find_pattern_in_bbox(grid, obj):\n    \"\"\" \n    Checks an object's bounding box for an internal pattern.\n    Returns (found_pattern, pattern_color, pattern_absolute_coords)\n    \"\"\"\n    rows, cols = grid.shape\n    bbox = obj['bbox']\n    min_r, min_c, max_r, max_c = bbox # Exclusive max convention\n    primary_color = obj['primary_color']\n    \n    found_pattern = False\n    potential_pattern_color = -1 # Initialize with invalid color\n    abs_coords = []\n\n    # Iterate through the bounding box of the potential source\n    for r in range(min_r, max_r):\n        for c in range(min_c, max_c):\n             # Check grid bounds just in case (should be redundant if bbox is correct)\n            if 0 <= r < rows and 0 <= c < cols:\n                color = grid[r, c]\n                # Look for a color that is not background (0) and not the object's primary color\n                if color != 0 and color != primary_color:\n                    # If this is the first pattern pixel found, store its color\n                    if not found_pattern:\n                        potential_pattern_color = color\n                        found_pattern = True\n                    \n                    # Ensure all pattern pixels have the same color (task assumption)\n                    if color == potential_pattern_color:\n                        # Store absolute coordinates\n                        abs_coords.append((r, c))\n                    else:\n                        # Found a different internal color - this doesn't fit the pattern model\n                        return False, -1, [] \n                        \n    return found_pattern, potential_pattern_color, abs_coords\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    # 1. Initialize output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    # 2. Identify all non-white objects using BFS\n    objects = _find_objects_bfs(input_grid)\n\n    # 3. Need at least two objects for the transformation\n    if len(objects) < 2:\n        return output_grid # No transformation possible\n\n    # 4. Assume the two largest objects are the source/target pair\n    obj_a = objects[0]\n    obj_b = objects[1]\n\n    # 5. Try to find the source, target, pattern color, and pattern absolute coordinates\n    source_object = None\n    target_object = None\n    pattern_color = None\n    pattern_coords_absolute = [] # Store absolute coordinates\n\n    # Check Object A as potential source\n    found_in_a, color_a, coords_a = _find_pattern_in_bbox(input_grid, obj_a)\n    if found_in_a:\n        source_object = obj_a\n        target_object = obj_b\n        pattern_color = color_a\n        pattern_coords_absolute = coords_a\n    else:\n        # Check Object B as potential source\n        found_in_b, color_b, coords_b = _find_pattern_in_bbox(input_grid, obj_b)\n        if found_in_b:\n            source_object = obj_b\n            target_object = obj_a\n            pattern_color = color_b\n            pattern_coords_absolute = coords_b\n\n    # 6. If no source/pattern was identified, return the original grid\n    if source_object is None or pattern_color is None or not pattern_coords_absolute:\n        return output_grid\n\n    # 7. Calculate centers and translation vector\n    source_bbox = source_object['bbox']\n    target_bbox = target_object['bbox']\n\n    source_center_r, source_center_c = _calculate_bbox_center(source_bbox)\n    target_center_r, target_center_c = _calculate_bbox_center(target_bbox)\n\n    # Translation = Target Center - Source Center\n    delta_r = target_center_r - source_center_r\n    delta_c = target_center_c - source_center_c\n\n    # 8. Apply the translated pattern, clipping to the target object's bounding box\n    min_rt, min_ct, max_rt, max_ct = target_bbox # Target bbox for clipping\n\n    for src_r, src_c in pattern_coords_absolute:\n        # Calculate potential target coordinates by applying the translation vector\n        # Round to nearest integer for pixel coordinates\n        target_r = round(src_r + delta_r)\n        target_c = round(src_c + delta_c)\n\n        # Validate: Check if the calculated coordinate is within grid bounds\n        is_within_grid = (0 <= target_r < rows and 0 <= target_c < cols)\n        \n        # Validate: Check if the calculated coordinate is within the target's bounding box\n        is_within_target_bbox = (min_rt <= target_r < max_rt and min_ct <= target_c < max_ct)\n\n        # Apply the pattern color only if BOTH conditions are met\n        if is_within_grid and is_within_target_bbox:\n            output_grid[target_r, target_c] = pattern_color\n\n    # 9. Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23257,
    "candidates_token_count": 2303,
    "total_token_count": 25560,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.61122,
  "retries": 1
}