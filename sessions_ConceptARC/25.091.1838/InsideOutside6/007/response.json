{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the background color (0), the container color (most frequent non-background color), and the target color (other non-background color). \nDetermines an 'outside' region consisting of background cells reachable from the grid boundary by traversing only adjacent background cells. \nCreates an output grid initialized with the background color. \nCopies the target color to the output grid only for those target cells in the input that are adjacent (8-way) to at least one cell belonging to the identified 'outside' background region. All other cells, including the container color and 'inside' target cells, are replaced with the background color.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _identify_colors(grid):\n    \"\"\"\n    Identifies background, container, and target colors based on frequency.\n    Assumes background is 0.\n    Container is the most frequent non-background color.\n    Target is the other non-background color.\n    Handles cases with 0, 1, or 2 non-background colors.\n    Returns: background_color, container_color, target_color\n             container_color is None if only background exists.\n             container_color is -1 if only background and one other color exist (no effective container).\n             target_color is None if only background exists or if only background and container exist (though this case seems unlikely based on examples).\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    # Assume background is 0\n    background_color = 0\n    if background_color in color_counts:\n        del color_counts[background_color]\n\n    if not color_counts: # Only background color present\n        return background_color, None, None\n\n    # Sort by count descending, then by color value ascending as tie-breaker\n    sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n\n    container_color = None\n    target_color = None\n\n    if len(sorted_colors) >= 2:\n        container_color = sorted_colors[0][0]\n        # Assume the second most frequent (or first if counts are equal but color is higher)\n        # is the target. This simple heuristic works for the examples.\n        target_color = sorted_colors[1][0]\n    elif len(sorted_colors) == 1:\n         # If only one non-background color, it acts as the target, no container blocking\n         target_color = sorted_colors[0][0]\n         container_color = -1 # Use -1 to signify no effective container barrier\n\n    # If container_color was identified but target_color remains None (only 2 colors total: bg and container)\n    # Re-evaluate based on the task logic: the single non-bg color should be the target if no container logic applies.\n    # However, the problem implies the most frequent non-bg IS the container. If target_color is None\n    # after the sort, it means there isn't a second non-bg color to be the target.\n    # The logic seems robust for the cases seen (bg+container+target or bg+target).\n\n    return background_color, container_color, target_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the key colors\n    background_color, container_color, target_color = _identify_colors(input_np)\n\n    # 2. Initialize output grid with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # 3. Handle edge case: no target color\n    if target_color is None:\n        return output_grid.tolist()\n\n    # 4. Handle edge case: no container color (or only background and target)\n    # In this case, all target pixels are effectively 'outside'.\n    if container_color is None or container_color == -1:\n        output_grid[input_np == target_color] = target_color\n        return output_grid.tolist()\n\n    # 5. Perform BFS to find the 'outside' background region\n    # This region includes background cells reachable from the boundary\n    # by moving only through other background cells.\n    q = deque()\n    visited_background = np.zeros_like(input_np, dtype=bool)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] # 8-way\n\n    # Add boundary background cells to queue and mark as visited\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right edges\n            if input_np[r, c] == background_color and not visited_background[r, c]:\n                q.append((r, c))\n                visited_background[r, c] = True\n    for c in range(1, cols - 1): # Top and bottom edges (excluding corners)\n         for r in [0, rows - 1]:\n             if input_np[r, c] == background_color and not visited_background[r, c]:\n                q.append((r, c))\n                visited_background[r, c] = True\n\n    # Start BFS, exploring only through background cells\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds and if the neighbor is background and not visited\n            if (0 <= nr < rows and 0 <= nc < cols and\n                    input_np[nr, nc] == background_color and\n                    not visited_background[nr, nc]):\n                visited_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # 6. Populate the output grid\n    # Iterate through all input cells\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell contains the target color\n            if input_np[r, c] == target_color:\n                # Check if any 8-way neighbor is part of the 'outside' background region\n                keep_target = False\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    # Check bounds and if the neighbor is an 'outside' background cell\n                    if (0 <= nr < rows and 0 <= nc < cols and\n                            input_np[nr, nc] == background_color and\n                            visited_background[nr, nc]):\n                        keep_target = True\n                        break # Found a connection to the outside background\n\n                # If connected to the outside background, copy target color to output\n                if keep_target:\n                    output_grid[r, c] = target_color\n\n    # 7. Return the modified output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12982,
    "candidates_token_count": 1643,
    "total_token_count": 14625,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.344557,
  "retries": 1
}