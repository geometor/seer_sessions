{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentifies the background color (0), the container color (most frequent non-background color), and the target color (other non-background color). \nPerforms a Breadth-First Search (BFS) starting from all grid boundary cells that do not contain the container color. \nThe BFS explores adjacent cells (8-way connectivity), but cannot pass through cells containing the container color. \nThis BFS identifies all cells reachable from the outside ('outside_region').\nCreates an output grid initialized with the background color. \nCopies the target color to the output grid only for cells that originally contained the target color AND were marked as reachable ('outside_region') during the BFS.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _identify_colors(grid):\n    \"\"\"\n    Identifies background, container, and target colors based on frequency.\n    Assumes background is 0.\n    Container is the most frequent non-background color.\n    Target is the other non-background color.\n    Handles cases with 0, 1, or 2 non-background colors.\n    Returns: background_color, container_color, target_color\n             container_color is None if only background exists.\n             container_color is -1 if only background and one other color exist (no effective container).\n             target_color is None if only background exists.\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    # Assume background is 0\n    background_color = 0\n    if background_color in color_counts:\n        del color_counts[background_color]\n\n    if not color_counts: # Only background color present\n        return background_color, None, None\n\n    # Sort by count descending, then by color value ascending as tie-breaker\n    sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n\n    container_color = None\n    target_color = None\n\n    if len(sorted_colors) >= 2:\n        container_color = sorted_colors[0][0]\n        # Assume the second most frequent (or first if counts are equal but color is higher)\n        # is the target. This simple heuristic works for the examples.\n        target_color = sorted_colors[1][0]\n    elif len(sorted_colors) == 1:\n         # If only one non-background color, it acts as the target, no container blocking\n         target_color = sorted_colors[0][0]\n         container_color = -1 # Use -1 to signify no effective container barrier\n\n    return background_color, container_color, target_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters the input grid keeping only target pixels reachable from the boundary\n    without crossing the container color.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the key colors\n    background_color, container_color, target_color = _identify_colors(input_np)\n\n    # 2. Initialize output grid with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # 3. Handle edge case: no target color\n    if target_color is None:\n        return output_grid.tolist()\n\n    # 4. Handle edge case: no container color (or only background and target)\n    # In this case, all target pixels are effectively 'outside'.\n    if container_color is None or container_color == -1:\n        output_grid[input_np == target_color] = target_color\n        return output_grid.tolist()\n\n    # 5. Perform BFS from boundaries to find 'outside' cells\n    q = deque()\n    visited = np.zeros_like(input_np, dtype=bool)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] # 8-way\n\n    # Add boundary cells to queue if they are not the container color and not visited\n    for r in range(rows):\n        for c in [0, cols - 1]: # Left and right edges\n            if input_np[r, c] != container_color and not visited[r, c]:\n                q.append((r, c))\n                visited[r, c] = True\n    for c in range(1, cols - 1): # Top and bottom edges (excluding corners already added)\n         for r in [0, rows - 1]:\n             if input_np[r, c] != container_color and not visited[r, c]:\n                q.append((r, c))\n                visited[r, c] = True\n\n    # Start BFS to mark all reachable 'outside' cells\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is not visited AND not the container color\n                if not visited[nr, nc] and input_np[nr, nc] != container_color:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n\n    # 6. Populate the output grid\n    # Iterate through all input cells\n    for r in range(rows):\n        for c in range(cols):\n            # If the input cell contains the target color AND it was visited (is outside)\n            if input_np[r, c] == target_color and visited[r, c]:\n                # Set the corresponding cell in the output grid to the target color\n                output_grid[r, c] = target_color\n\n    # 7. Return the modified output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10979,
    "candidates_token_count": 1383,
    "total_token_count": 12362,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.947757,
  "retries": 1
}