{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies the background color (0), the container color (most frequent non-background color), and the target color (other non-background color).\nPerforms a Breadth-First Search (BFS) starting only from background-colored cells on the grid boundary, exploring only through adjacent background cells, to identify the 'outside' background region.\nCreates an output grid initialized with the background color.\nCopies the target color to the output grid only for cells that originally contained the target color AND are adjacent (8-way) to at least one cell marked as belonging to the 'outside' background region.\n\"\"\"\n\ndef _identify_colors(grid):\n    \"\"\"\n    Identifies background, container, and target colors based on frequency.\n    Assumes background is 0.\n    Container is the most frequent non-background color.\n    Target is the other non-background color.\n    Handles cases with 0, 1, or 2 non-background colors.\n    \"\"\"\n    unique_colors, counts = np.unique(grid, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n\n    # Assume background is 0\n    background_color = 0\n    if background_color in color_counts:\n        del color_counts[background_color]\n\n    if not color_counts: # Only background color present\n        return background_color, None, None\n\n    # Sort by count descending, then by color value ascending as tie-breaker\n    sorted_colors = sorted(color_counts.items(), key=lambda item: (-item[1], item[0]))\n\n    container_color = None\n    target_color = None\n\n    if len(sorted_colors) >= 2:\n        container_color = sorted_colors[0][0]\n        target_color = sorted_colors[1][0] # The next most frequent is assumed target\n        # If there are more than 2 non-bg colors, this heuristic might fail.\n        # For this specific task, it seems there are only ever 2 non-bg colors.\n    elif len(sorted_colors) == 1:\n         # If only one non-background color, it acts as the target, no container blocking\n         target_color = sorted_colors[0][0]\n         container_color = -1 # Use -1 to signify no effective container barrier\n\n    return background_color, container_color, target_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Filters the input grid based on reachability from the outer background.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify the key colors\n    background_color, container_color, target_color = _identify_colors(input_np)\n\n    # 2. Initialize output grid with background color\n    output_grid = np.full_like(input_np, background_color)\n\n    # 3. Handle edge cases: no target color\n    if target_color is None:\n        return output_grid.tolist()\n\n    # 4. Handle edge case: no container color (only background and target)\n    # In this case, all target pixels are effectively 'outside'.\n    if container_color == -1:\n        output_grid[input_np == target_color] = target_color\n        return output_grid.tolist()\n\n    # 5. Perform flood fill (BFS) from boundary *background* cells\n    # This identifies the 'outside' background region.\n    q = deque()\n    visited_background = np.zeros_like(input_np, dtype=bool)\n\n    # Add boundary background cells to queue and mark as visited\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if input_np[r, c] == background_color and not visited_background[r, c]:\n                q.append((r, c))\n                visited_background[r, c] = True\n    for c in range(cols): # Cover top/bottom rows, including corners again (fine)\n        for r in [0, rows - 1]:\n            if input_np[r, c] == background_color and not visited_background[r, c]:\n                q.append((r, c))\n                visited_background[r, c] = True\n\n    # Define 8 directions for neighbors (including diagonals)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    # Start BFS, exploring only through background cells\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds and if the neighbor is background and not visited\n            if (0 <= nr < rows and 0 <= nc < cols and\n                    input_np[nr, nc] == background_color and\n                    not visited_background[nr, nc]):\n                visited_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # 6. Populate the output grid\n    # Iterate through all input cells\n    for r in range(rows):\n        for c in range(cols):\n            # If the cell contains the target color\n            if input_np[r, c] == target_color:\n                # Check its 8 neighbors\n                keep_target = False\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    # Check bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # Check if the neighbor is background AND part of the 'outside' region\n                        if input_np[nr, nc] == background_color and visited_background[nr, nc]:\n                            keep_target = True\n                            break # Found a connection to the outside, no need to check further neighbors\n\n                # If connected to the outside background, copy target color to output\n                if keep_target:\n                    output_grid[r, c] = target_color\n\n    # 7. Return the modified output grid as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12388,
    "candidates_token_count": 1438,
    "total_token_count": 13826,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.52827,
  "retries": 1
}