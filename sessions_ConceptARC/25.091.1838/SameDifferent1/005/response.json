{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by removing non-background objects that touch the absolute border of the grid. \nAn object is defined as a contiguous group of pixels of the same non-zero color (non-white), using 4-way connectivity.\nA pixel touches the border if its row index is 0 or the maximum row index (height - 1), or its column index is 0 or the maximum column index (width - 1). \nIf any pixel of an object touches the border, the entire object is removed (replaced with the background color 0 - white) in the output grid. \nObjects that do not touch any border remain unchanged. The output grid has the same dimensions as the input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_object(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds a connected object of the same color starting from (start_row, start_col) \n    using Breadth-First Search (BFS). Marks visited pixels for the found object \n    within the provided visited array.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n        visited (np.array): A boolean grid indicating visited pixels (modified in place).\n\n    Returns:\n        tuple: (list of pixel coordinates [(r, c), ...], boolean indicating if it touches border)\n               Returns (None, False) if the starting pixel is background (color 0) or \n               has already been visited as part of another object search.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check if the starting point is out of bounds\n    if not (0 <= start_row < rows and 0 <= start_col < cols):\n        return None, False\n        \n    # Check if already visited or is background color (color 0)\n    if visited[start_row, start_col] or grid[start_row, start_col] == 0:\n        # Mark as visited if not already (e.g., if it's background) \n        # to avoid redundant checks by the caller.\n        visited[start_row, start_col] = True \n        return None, False\n\n    # Start BFS to find the connected component (object)\n    color = grid[start_row, start_col]\n    q = deque([(start_row, start_col)])\n    object_pixels = []\n    touches_border = False\n    visited[start_row, start_col] = True # Mark the starting pixel as visited\n\n    while q:\n        r, c = q.popleft()\n        object_pixels.append((r, c))\n\n        # Check if this pixel touches the absolute border (top, bottom, left, or right edge)\n        if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n            touches_border = True # Set the flag; it stays true if any part touches\n\n        # Explore neighbors using 4-connectivity (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 # Check if neighbor has the same color as the object and hasn't been visited yet\n                if not visited[nr, nc] and grid[nr, nc] == color:\n                    visited[nr, nc] = True # Mark visited when adding to queue to prevent cycles/revisits\n                    q.append((nr, nc))\n\n    # Return the list of pixels in the object and whether it touched the border\n    return object_pixels, touches_border\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid according to the rule described in the module docstring.\n    \n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid. \n    # Objects that are not removed will implicitly remain.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # Keep track of visited pixels during object finding to ensure each pixel\n    # is processed only once as part of exactly one object search.\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate through each pixel of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel hasn't been visited yet (this check implicitly skips background\n            # pixels after they are visited once by find_object, and prevents starting \n            # multiple searches for the same object)\n            if not visited[r, c]:\n                # Attempt to find an object starting from this pixel.\n                # find_object handles checking if it's background (color 0), returning None.\n                # It updates the 'visited' array for all pixels it processes (object or background).\n                object_pixels, touches_border = find_object(input_grid, r, c, visited)\n                \n                # Check if a valid object was found (object_pixels is not None) \n                # AND this object touches the border\n                if object_pixels is not None and touches_border:\n                    # If the object touches the border, erase it from the output grid \n                    # by setting all its pixels to the background color (white, 0).\n                    for pr, pc in object_pixels:\n                        output_grid[pr, pc] = 0\n                # No explicit 'else' is needed:\n                # - If object_pixels is None, it was background or already visited; find_object marked it visited.\n                # - If object_pixels is not None but touches_border is False, the object should\n                #   remain unchanged, which it does because output_grid started as a copy.\n\n    # Return the final modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12626,
    "candidates_token_count": 1415,
    "total_token_count": 14041,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.218693,
  "retries": 1
}