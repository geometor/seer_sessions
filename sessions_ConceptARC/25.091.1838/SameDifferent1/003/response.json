{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by removing non-background objects that touch the border.\nAn object is defined as a contiguous group of pixels of the same non-zero color (non-white).\nA pixel touches the border if its row index is 0 or the maximum row index, or its column \nindex is 0 or the maximum column index. If any pixel of an object touches the border, the \nentire object is removed (replaced with the background color 0 - white). Objects that\ndo not touch any border remain unchanged.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_object(grid, start_row, start_col, visited):\n    \"\"\"\n    Finds a connected object of the same color starting from (start_row, start_col) \n    using Breadth-First Search (BFS). Marks visited pixels for the found object \n    within the provided visited array.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n        visited (np.array): A boolean grid indicating visited pixels (modified in place).\n\n    Returns:\n        tuple: (list of pixel coordinates [(r, c), ...], boolean indicating if it touches border)\n               Returns (None, False) if the starting pixel is background (color 0) or \n               has already been visited as part of another object search.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check if the starting point is out of bounds\n    if not (0 <= start_row < rows and 0 <= start_col < cols):\n        return None, False\n        \n    # Check if already visited or is background color\n    if visited[start_row, start_col] or grid[start_row, start_col] == 0:\n        # Mark as visited if not already (e.g., if it's background) \n        # to avoid redundant checks by the caller.\n        visited[start_row, start_col] = True \n        return None, False\n\n    # Start BFS\n    color = grid[start_row, start_col]\n    q = deque([(start_row, start_col)])\n    object_pixels = []\n    touches_border = False\n    visited[start_row, start_col] = True # Mark the starting pixel as visited\n\n    while q:\n        r, c = q.popleft()\n        object_pixels.append((r, c))\n\n        # Check if this pixel touches the border (top, bottom, left, or right edge)\n        if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n            touches_border = True # Set the flag; it stays true if any part touches\n\n        # Explore neighbors (4-connectivity: up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 # Check if neighbor has the same color and hasn't been visited yet\n                if not visited[nr, nc] and grid[nr, nc] == color:\n                    visited[nr, nc] = True # Mark visited when adding to queue\n                    q.append((nr, nc))\n\n    return object_pixels, touches_border\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by removing non-background objects that touch the border.\n\n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid. Objects that are not\n    # removed will implicitly remain.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # Keep track of visited pixels during object finding to ensure each pixel\n    # is processed only once as part of an object.\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate through each pixel of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel hasn't been visited yet (means it's either unvisited non-background\n            # or unvisited background)\n            if not visited[r, c]:\n                # Attempt to find an object starting from this pixel.\n                # find_object will handle checking if it's background (color 0)\n                # or already visited, returning None in those cases.\n                # It will also update the 'visited' array for all pixels it processes.\n                object_pixels, touches_border = find_object(input_grid, r, c, visited)\n                \n                # If a valid object was found (object_pixels is not None) \n                # AND this object touches the border\n                if object_pixels is not None and touches_border:\n                    # Erase the object from the output grid by setting all its pixels\n                    # to the background color (white, 0).\n                    for pr, pc in object_pixels:\n                        output_grid[pr, pc] = 0\n                # No 'else' block is needed:\n                # - If object_pixels is None, it was background or already visited; handled by 'visited'.\n                # - If object_pixels is not None but touches_border is False, the object should\n                #   remain, which it does because output_grid started as a copy.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7424,
    "candidates_token_count": 1307,
    "total_token_count": 8731,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 45.55053,
  "retries": 1
}