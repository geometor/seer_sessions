{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms the input grid by removing non-background objects that touch the absolute border of the grid. \nAn object is defined as a contiguous group of pixels of the same non-zero color (non-white), using 4-way connectivity.\nA pixel touches the border if its row index is 0 or the maximum row index (height - 1), or its column index is 0 or the maximum column index (width - 1). \nIf any pixel of an object touches the border, the entire object is removed (replaced with the background color 0 - white) in the output grid. \nObjects that do not touch any border remain unchanged. The output grid has the same dimensions as the input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef _find_object(grid, start_row, start_col, visited):\n    \"\"\"\n    Helper function to find a single connected object using BFS.\n\n    Finds a connected object of the same color starting from (start_row, start_col) \n    using Breadth-First Search (BFS). Marks visited pixels for the found object \n    within the provided visited array.\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n        visited (np.array): A boolean grid indicating visited pixels (modified in place).\n\n    Returns:\n        tuple: (list of pixel coordinates [(r, c), ...], boolean indicating if it touches border)\n               Returns (None, False) if the starting pixel is background (color 0) or \n               has already been visited as part of another object search.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check if the starting point is out of bounds\n    if not (0 <= start_row < rows and 0 <= start_col < cols):\n        return None, False\n        \n    # Check if already visited or is background color (color 0)\n    if visited[start_row, start_col] or grid[start_row, start_col] == 0:\n        # Mark background as visited here to avoid re-checking later\n        visited[start_row, start_col] = True \n        return None, False\n\n    # Start BFS to find the connected component (object)\n    color = grid[start_row, start_col]\n    q = deque([(start_row, start_col)])\n    object_pixels = []\n    touches_border = False\n    visited[start_row, start_col] = True # Mark the starting pixel as visited\n\n    while q:\n        r, c = q.popleft()\n        object_pixels.append((r, c))\n\n        # Check if this pixel touches the absolute border (top, bottom, left, or right edge)\n        if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n            touches_border = True # Set the flag; it stays true if any part touches\n\n        # Explore neighbors using 4-connectivity (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                 # Check if neighbor has the same color as the object and hasn't been visited yet\n                if not visited[nr, nc] and grid[nr, nc] == color:\n                    visited[nr, nc] = True # Mark visited when adding to queue to prevent cycles/revisits\n                    q.append((nr, nc))\n\n    # Return the list of pixels in the object and whether it touched the border\n    return object_pixels, touches_border\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid (np.array): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.array: A 2D numpy array representing the transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input grid. \n    # Objects that are not removed will implicitly remain.\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    \n    # Keep track of visited pixels during object finding to ensure each pixel\n    # (background or object part) is processed only once.\n    visited = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate through each pixel of the input grid to find starting points for objects\n    for r in range(rows):\n        for c in range(cols):\n            # If the pixel hasn't been visited yet, attempt to find an object starting here.\n            # This check efficiently skips pixels already part of a found object or visited background.\n            if not visited[r, c]:\n                # _find_object handles checks for background color and returns None if it is.\n                # It also updates the 'visited' array for all pixels it processes.\n                object_pixels, touches_border = _find_object(input_grid, r, c, visited)\n                \n                # If a valid object was found (object_pixels is not None) \n                # AND this object touches the border\n                if object_pixels is not None and touches_border:\n                    # Erase the object from the output grid by setting all its pixels \n                    # to the background color (white, 0).\n                    for pr, pc in object_pixels:\n                        output_grid[pr, pc] = 0\n                # Else: If no object found (background/visited) or object found but doesn't touch border,\n                # do nothing, as the output_grid already contains the correct pixel values from the initial copy.\n\n    # Return the final modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11456,
    "candidates_token_count": 1351,
    "total_token_count": 12807,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.167782,
  "retries": 1
}