{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1. Determine the background color by finding the most frequent color in the input grid.\n2. Identify the 'main shape' by finding all pixels belonging to the most frequent color that is *not* the background color.\n3. Locate the unique 'marker pixel' by finding the single pixel whose color differs from both the background color and the main shape's color. Note its color ('marker color') and original coordinates ('source location').\n4. Calculate the bounding box of the main shape by finding the minimum and maximum row and column indices occupied by its pixels.\n5. Calculate the 'target location' coordinates, which are the geometric center of the bounding box (using integer division: `row = (min_row + max_row) // 2`, `col = (min_col + max_col) // 2`).\n6. Generate the output grid by first copying the input grid.\n7. Modify the copied grid: set the pixel at the 'source location' to the background color.\n8. Modify the copied grid: set the pixel at the 'target location' to the 'marker color'.\n\"\"\"\n\ndef get_bounding_box(object_coords):\n    \"\"\"\n    Calculates the bounding box (min/max row/col) for a set of coordinates.\n\n    Args:\n        object_coords (set or list): A collection of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.\n    \"\"\"\n    if not object_coords:\n        return None\n        \n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n    \n    return (min(rows), min(cols), max(rows), max(cols))\n\ndef get_center(bounding_box):\n    \"\"\"\n    Calculates the geometric center (floor of average) of a bounding box.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (center_row, center_col).\n    \"\"\"\n    if not bounding_box:\n        return None\n    min_r, min_c, max_r, max_c = bounding_box\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    return (center_r, center_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: moves a unique marker pixel to the \n    center of the bounding box of the largest object in the grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # 1. Determine the background color (most frequent)\n    color_counts = Counter(output_grid.flatten())\n    background_color = color_counts.most_common(1)[0][0]\n\n    # 2. Identify the 'main shape' color (most frequent non-background)\n    main_shape_color = None\n    main_shape_coords = []\n    non_bg_counts = [(color, count) for color, count in color_counts.items() if color != background_color]\n    if non_bg_counts:\n        main_shape_color = max(non_bg_counts, key=lambda item: item[1])[0]\n        # Collect coordinates of the main shape\n        for r in range(rows):\n            for c in range(cols):\n                if output_grid[r, c] == main_shape_color:\n                    main_shape_coords.append((r, c))\n    \n    # Handle edge case: No non-background colors found\n    if main_shape_color is None:\n        return output_grid # Return original grid if only background exists\n\n    # 3. Locate the unique 'marker pixel'\n    marker_color = None\n    marker_location = None\n    unique_colors = [color for color, count in non_bg_counts if count == 1]\n    \n    # The marker should be the unique color that isn't the main shape (if main shape itself is unique, marker doesn't exist)\n    potential_markers = [uc for uc in unique_colors if uc != main_shape_color]\n\n    if len(potential_markers) == 1:\n        marker_color = potential_markers[0]\n        # Find the location of this unique color\n        for r in range(rows):\n            for c in range(cols):\n                if output_grid[r, c] == marker_color:\n                    marker_location = (r, c)\n                    break\n            if marker_location:\n                break\n    elif len(non_bg_counts) == 1 and len(main_shape_coords) > 1: \n        # Only one non-background object, which is the main shape, no marker exists\n        pass # No marker to move\n    elif len(non_bg_counts) > 1 and not potential_markers:\n         # This case implies multiple non-background shapes, none of which are single pixels.\n         # Trying a simpler identification: any pixel not background and not main shape.\n         # This assumes there's only *one* such pixel based on task examples.\n         for r in range(rows):\n            for c in range(cols):\n                pixel_color = output_grid[r, c]\n                if pixel_color != background_color and pixel_color != main_shape_color:\n                    marker_color = pixel_color\n                    marker_location = (r, c)\n                    break\n            if marker_location:\n                break\n                \n    # If no marker found or main shape doesn't exist, return original\n    if marker_location is None or not main_shape_coords:\n        print(f\"Warning: Could not identify marker pixel or main shape. Marker Loc: {marker_location}, Main Shape Coords Count: {len(main_shape_coords)}\")\n        return output_grid\n\n    # 4. Calculate the bounding box of the main shape\n    bounding_box = get_bounding_box(main_shape_coords)\n\n    # 5. Calculate the 'target location' (center of bounding box)\n    target_location = get_center(bounding_box)\n    \n    if target_location is None:\n         print(\"Warning: Could not calculate target location.\")\n         return output_grid # Should not happen if main_shape_coords has elements\n\n    # 6. Output grid is already a copy\n\n    # 7. Modify the output grid: set source location to background color\n    output_grid[marker_location] = background_color\n    \n    # 8. Modify the output grid: set target location to marker color\n    output_grid[target_location] = marker_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12677,
    "candidates_token_count": 1595,
    "total_token_count": 14272,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.281292,
  "retries": 1
}