{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransformation Rule:\n1. Identify the background color (white, 0).\n2. Find all contiguous objects not matching the background color.\n3. Identify the largest object (the \"main shape\").\n4. Find the single pixel whose color is different from both the background and the main shape's color (the \"marker pixel\").\n5. Determine the bounding box of the main shape.\n6. Calculate the geometric center coordinates of the bounding box (floor of the average row/col).\n7. Create the output grid by copying the input grid.\n8. Set the original location of the marker pixel to the background color in the output grid.\n9. Set the calculated center location in the output grid to the color of the marker pixel.\n\"\"\"\n\ndef find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color to ignore.\n\n    Returns:\n        list: A list of tuples, where each tuple contains (color, set_of_coords).\n              Returns an empty list if no objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                stack = [(r, c)]\n                visited[r, c] = True\n                \n                while stack:\n                    row, col = stack.pop()\n                    coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            stack.append((nr, nc))\n                            \n                if coords:\n                    objects.append((color, coords))\n                    \n    return objects\n\ndef get_bounding_box(object_coords):\n    \"\"\"\n    Calculates the bounding box (min/max row/col) for a set of coordinates.\n\n    Args:\n        object_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.\n    \"\"\"\n    if not object_coords:\n        return None\n        \n    rows = [r for r, c in object_coords]\n    cols = [c for r, c in object_coords]\n    \n    return (min(rows), min(cols), max(rows), max(cols))\n\ndef get_center(bounding_box):\n    \"\"\"\n    Calculates the geometric center (floor of average) of a bounding box.\n\n    Args:\n        bounding_box (tuple): (min_row, min_col, max_row, max_col).\n\n    Returns:\n        tuple: (center_row, center_col).\n    \"\"\"\n    min_r, min_c, max_r, max_c = bounding_box\n    center_r = (min_r + max_r) // 2\n    center_c = (min_c + max_c) // 2\n    return (center_r, center_c)\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: moves a unique marker pixel to the \n    center of the largest object in the grid.\n\n    Args:\n        input_grid (np.array): The input 2D numpy array.\n\n    Returns:\n        np.array: The transformed 2D numpy array.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n    \n    # 1. Identify background color (assuming 0 based on examples)\n    background_color = 0\n    \n    # 2. Find all non-background objects\n    objects = find_objects(output_grid, background_color)\n    if not objects:\n        return output_grid # No objects to process\n\n    # 3. Identify the largest object (main shape)\n    largest_object = max(objects, key=lambda item: len(item[1]))\n    main_shape_color, main_shape_coords = largest_object\n    \n    # 4. Find the unique marker pixel\n    marker_color = None\n    marker_location = None\n    for r in range(rows):\n        for c in range(cols):\n            pixel_color = output_grid[r, c]\n            if pixel_color != background_color and pixel_color != main_shape_color:\n                # Check if this color exists elsewhere - it should be unique\n                is_unique = True\n                for obj_color, obj_coords in objects:\n                    if obj_color == pixel_color and len(obj_coords) > 1:\n                         is_unique = False\n                         break\n                    if obj_color == pixel_color and (r, c) not in obj_coords: # Should not happen with find_objects\n                         is_unique = False\n                         break\n                if is_unique:\n                    # Found the single pixel with a unique color\n                    marker_color = pixel_color\n                    marker_location = (r, c)\n                    break # Assumes only one such pixel based on examples\n        if marker_location:\n            break\n\n    if marker_location is None or marker_color is None:\n         # Fallback or error: No unique marker pixel found, maybe logic needs adjustment for edge cases\n         # Let's try finding any pixel not part of the main shape or background\n         all_pixels = [(r,c) for r in range(rows) for c in range(cols)]\n         non_bg_non_main_pixels = [\n             (r, c) for r, c in all_pixels \n             if output_grid[r, c] != background_color and (r, c) not in main_shape_coords\n         ]\n         if len(non_bg_non_main_pixels) == 1:\n             marker_location = non_bg_non_main_pixels[0]\n             marker_color = output_grid[marker_location]\n         else:\n             # Still couldn't find a unique marker, return original grid or handle error\n             print(\"Warning: Could not uniquely identify marker pixel.\")\n             return output_grid # Return unchanged grid if marker is ambiguous/missing\n\n\n    # 5. Determine the bounding box of the main shape\n    bounding_box = get_bounding_box(main_shape_coords)\n    \n    # 6. Calculate the geometric center of the bounding box\n    target_location = get_center(bounding_box)\n    \n    # 8. Set the original location of the marker pixel to the background color\n    output_grid[marker_location] = background_color\n    \n    # 9. Set the calculated center location to the color of the marker pixel\n    output_grid[target_location] = marker_color\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4226,
    "candidates_token_count": 1711,
    "total_token_count": 5937,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.024095,
  "retries": 1
}