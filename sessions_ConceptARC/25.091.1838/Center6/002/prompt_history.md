
## train_1

**input:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 4 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 2 0 0 0 0 0 0 0 0 0 2 0
2 0 0 0 0 0 0 0 0 0 0 0 2
0 2 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 2 0 0 0 0 0 0 0 0 0 2 0
2 0 0 0 0 0 4 0 0 0 0 0 2
0 2 0 0 0 0 0 0 0 0 0 2 0
0 0 2 0 0 0 0 0 0 0 2 0 0
0 0 0 2 0 0 0 0 0 2 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0
0 0 0 0 0 2 0 2 0 0 0 0 0
0 0 0 0 0 0 2 0 0 0 0 0 0
```


## train_2

**input:**
```
3 3 3 3 3 3 3 3 3 3 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 7
```


**output:**
```
3 3 3 3 3 3 3 3 3 3 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 7 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 0 0 0 0 0 0 0 0 0 3 0
3 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 8 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 8 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, I will analyze the provided examples and derive the transformation logic.

**Perception of the Elements:**

1.  **Background:** All examples use white (0) as the primary background color.
2.  **Main Shape:** Each input grid features a prominent, large geometric shape composed of a single color (red 'X' in train_1, green hollow rectangle in train_2, yellow solid rectangle in train_3). This shape remains static between input and output.
3.  **Unique Pixel:** Each input grid contains exactly one pixel whose color is distinct from both the background and the main shape's color (yellow in train_1, orange in train_2, azure in train_3). I'll refer to this as the "marker pixel".
4.  **Transformation:** The core transformation involves relocating the "marker pixel". In the output grid, the marker pixel appears at the geometric center of the main shape (or the grid itself, which coincides with the shape's center in train_1). The original location of the marker pixel is changed to the background color (white). The pixel color originally at the center location is overwritten by the marker pixel's color.

**Facts (YAML):**


```yaml
task_context:
  grid_properties:
    - background_color: 0 (white)
    - grid_size_varies: true
  main_object:
    - description: A large, contiguous shape of a single color, distinct from the background.
    - properties:
        - color: Varies (red, green, yellow in examples)
        - structure: Can be solid, hollow, or complex (X-shape)
    - role: Defines the target location for the transformation. Remains static otherwise.
    - identification: Typically the largest non-background object.
  secondary_object:
    - description: A single, unique pixel with a color different from the background and the main object.
    - properties:
        - color: Varies (yellow, orange, azure in examples)
        - count: Exactly one per grid.
    - role: The object to be moved.
    - identification: The pixel whose color is unique compared to the background and the main object.
transformation:
  action: move_pixel
  source_pixel:
    - description: The unique secondary object (marker pixel).
    - location: Its original coordinates in the input grid.
    - color: Its original color.
  target_location:
    - description: The geometric center of the bounding box of the main object.
    - calculation:
        - Find the minimum and maximum row and column indices of the main object (bounding box).
        - Target row = floor((min_row + max_row) / 2)
        - Target column = floor((min_col + max_col) / 2)
  output_grid_changes:
    - The pixel at the source_pixel's original location is set to the background color (white, 0).
    - The pixel at the target_location is set to the source_pixel's color.
    - All other pixels retain their original color from the input grid.
```


**Natural Language Program:**

1.  Identify the background color (which is consistently white, 0).
2.  Identify all contiguous objects (pixels of the same color connected horizontally or vertically) that are not the background color.
3.  Determine the largest object among these; this is the "main shape".
4.  Find the single pixel in the grid whose color is neither the background color nor the color of the "main shape". Record this pixel's color (the "marker color") and its original coordinates (the "source location").
5.  Determine the bounding box of the "main shape" by finding its minimum and maximum row and column indices.
6.  Calculate the geometric center coordinates (the "target location") of this bounding box:
    *   `target_row = floor((min_row + max_row) / 2)`
    *   `target_col = floor((min_col + max_col) / 2)`
7.  Create the output grid as a copy of the input grid.
8.  Modify the output grid:
    *   Set the pixel at the "source location" to the background color (white, 0).
    *   Set the pixel at the "target location" to the "marker color".
```python
import numpy as np
from collections import Counter

"""
Transformation Rule:
1. Identify the background color (white, 0).
2. Find all contiguous objects not matching the background color.
3. Identify the largest object (the "main shape").
4. Find the single pixel whose color is different from both the background and the main shape's color (the "marker pixel").
5. Determine the bounding box of the main shape.
6. Calculate the geometric center coordinates of the bounding box (floor of the average row/col).
7. Create the output grid by copying the input grid.
8. Set the original location of the marker pixel to the background color in the output grid.
9. Set the calculated center location in the output grid to the color of the marker pixel.
"""

def find_objects(grid, background_color):
    """
    Finds all contiguous objects of non-background colors in the grid.

    Args:
        grid (np.array): The input grid.
        background_color (int): The color to ignore.

    Returns:
        list: A list of tuples, where each tuple contains (color, set_of_coords).
              Returns an empty list if no objects are found.
    """
    rows, cols = grid.shape
    visited = np.zeros_like(grid, dtype=bool)
    objects = []

    for r in range(rows):
        for c in range(cols):
            if grid[r, c] != background_color and not visited[r, c]:
                color = grid[r, c]
                coords = set()
                stack = [(r, c)]
                visited[r, c] = True
                
                while stack:
                    row, col = stack.pop()
                    coords.add((row, col))
                    
                    # Check neighbors (up, down, left, right)
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        if 0 <= nr < rows and 0 <= nc < cols and \
                           not visited[nr, nc] and grid[nr, nc] == color:
                            visited[nr, nc] = True
                            stack.append((nr, nc))
                            
                if coords:
                    objects.append((color, coords))
                    
    return objects

def get_bounding_box(object_coords):
    """
    Calculates the bounding box (min/max row/col) for a set of coordinates.

    Args:
        object_coords (set): A set of (row, col) tuples.

    Returns:
        tuple: (min_row, min_col, max_row, max_col) or None if coords is empty.
    """
    if not object_coords:
        return None
        
    rows = [r for r, c in object_coords]
    cols = [c for r, c in object_coords]
    
    return (min(rows), min(cols), max(rows), max(cols))

def get_center(bounding_box):
    """
    Calculates the geometric center (floor of average) of a bounding box.

    Args:
        bounding_box (tuple): (min_row, min_col, max_row, max_col).

    Returns:
        tuple: (center_row, center_col).
    """
    min_r, min_c, max_r, max_c = bounding_box
    center_r = (min_r + max_r) // 2
    center_c = (min_c + max_c) // 2
    return (center_r, center_c)

def transform(input_grid):
    """
    Applies the transformation rule: moves a unique marker pixel to the 
    center of the largest object in the grid.

    Args:
        input_grid (np.array): The input 2D numpy array.

    Returns:
        np.array: The transformed 2D numpy array.
    """
    output_grid = np.copy(input_grid)
    rows, cols = output_grid.shape
    
    # 1. Identify background color (assuming 0 based on examples)
    background_color = 0
    
    # 2. Find all non-background objects
    objects = find_objects(output_grid, background_color)
    if not objects:
        return output_grid # No objects to process

    # 3. Identify the largest object (main shape)
    largest_object = max(objects, key=lambda item: len(item[1]))
    main_shape_color, main_shape_coords = largest_object
    
    # 4. Find the unique marker pixel
    marker_color = None
    marker_location = None
    for r in range(rows):
        for c in range(cols):
            pixel_color = output_grid[r, c]
            if pixel_color != background_color and pixel_color != main_shape_color:
                # Check if this color exists elsewhere - it should be unique
                is_unique = True
                for obj_color, obj_coords in objects:
                    if obj_color == pixel_color and len(obj_coords) > 1:
                         is_unique = False
                         break
                    if obj_color == pixel_color and (r, c) not in obj_coords: # Should not happen with find_objects
                         is_unique = False
                         break
                if is_unique:
                    # Found the single pixel with a unique color
                    marker_color = pixel_color
                    marker_location = (r, c)
                    break # Assumes only one such pixel based on examples
        if marker_location:
            break

    if marker_location is None or marker_color is None:
         # Fallback or error: No unique marker pixel found, maybe logic needs adjustment for edge cases
         # Let's try finding any pixel not part of the main shape or background
         all_pixels = [(r,c) for r in range(rows) for c in range(cols)]
         non_bg_non_main_pixels = [
             (r, c) for r, c in all_pixels 
             if output_grid[r, c] != background_color and (r, c) not in main_shape_coords
         ]
         if len(non_bg_non_main_pixels) == 1:
             marker_location = non_bg_non_main_pixels[0]
             marker_color = output_grid[marker_location]
         else:
             # Still couldn't find a unique marker, return original grid or handle error
             print("Warning: Could not uniquely identify marker pixel.")
             return output_grid # Return unchanged grid if marker is ambiguous/missing


    # 5. Determine the bounding box of the main shape
    bounding_box = get_bounding_box(main_shape_coords)
    
    # 6. Calculate the geometric center of the bounding box
    target_location = get_center(bounding_box)
    
    # 8. Set the original location of the marker pixel to the background color
    output_grid[marker_location] = background_color
    
    # 9. Set the calculated center location to the color of the marker pixel
    output_grid[target_location] = marker_color
    
    return output_grid
```
