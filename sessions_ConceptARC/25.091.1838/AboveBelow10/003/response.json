{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on a diagonal line of a single non-white color.\n1. Identifies the non-white color (fill_color) and the coordinates of the pixels forming a diagonal line.\n2. Determines if the line is a 'main' diagonal (top-left to bottom-right) or an 'anti' diagonal (top-right to bottom-left).\n3. Creates an output grid filled with white (0).\n4. Fills pixels (r_out, c_out) in the output grid with fill_color based on the diagonal type:\n    - If 'main' diagonal: Fill if there exists an input pixel (r_in, c_in) such that r_out >= r_in AND c_out <= c_in.\n    - If 'anti' diagonal: Fill if there exists an input pixel (r_in, c_in) such that r_out >= r_in AND c_out >= c_in.\n\"\"\"\n\nimport numpy as np\n\ndef find_color_and_coords(grid_np):\n    \"\"\"\n    Finds the single non-white color and its coordinates in the grid.\n    Assumes there is exactly one non-white color forming a line.\n    \"\"\"\n    # Find unique non-zero colors\n    non_white_colors = np.unique(grid_np[grid_np != 0])\n\n    if len(non_white_colors) == 0:\n        # No non-white color found\n        return 0, []\n    elif len(non_white_colors) > 1:\n        # Warning if multiple colors found, proceed with the lowest value > 0\n        # print(f\"Warning: Multiple non-white colors found: {non_white_colors}. Using {non_white_colors[0]}.\")\n        fill_color = non_white_colors[0]\n    else:\n        # Exactly one non-white color found\n        fill_color = non_white_colors[0]\n\n    # Find coordinates of the fill color\n    coords = list(zip(*np.where(grid_np == fill_color))) # Returns list of (row, col) tuples\n    \n    # Ensure coords are sorted primarily by row, then by column for consistent diagonal detection\n    coords.sort()\n    \n    return int(fill_color), coords\n\ndef determine_diagonal_type(coords):\n    \"\"\"\n    Determines the type of diagonal based on the coordinates.\n    Assumes coords are sorted by row, then column.\n    \"\"\"\n    if len(coords) <= 1:\n        # Cannot determine diagonal type from a single point or no points\n        # Defaulting to 'main' might work for single points if the rule applies,\n        # but 'unknown' is safer. Based on examples, we expect lines.\n        return \"unknown\" \n\n    first_pixel = coords[0]\n    last_pixel = coords[-1]\n\n    delta_r = last_pixel[0] - first_pixel[0]\n    delta_c = last_pixel[1] - first_pixel[1]\n\n    if delta_r > 0 and delta_c > 0:\n        return \"main\"  # Row increases, Col increases\n    elif delta_r > 0 and delta_c < 0:\n        return \"anti\"  # Row increases, Col decreases\n    elif delta_r == 0 and delta_c != 0 :\n        return \"horizontal\" # Not expected based on examples\n    elif delta_r !=0 and delta_c == 0:\n        return \"vertical\" # Not expected based on examples\n    else: # delta_r == 0 and delta_c == 0 (should only happen if len(coords)==1)\n         return \"unknown\"\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the fill transformation based on the identified diagonal line.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n\n    # 1. Identify the fill color and the coordinates of the input line pixels\n    fill_color, input_coords = find_color_and_coords(input_np)\n\n    # Handle edge case: no fill color found or no coordinates\n    if fill_color == 0 or not input_coords:\n        return np.zeros_like(input_np).tolist() # Return all white grid\n\n    # 2. Determine the type of diagonal\n    diagonal_type = determine_diagonal_type(input_coords)\n\n    # If diagonal type is unknown (e.g., single point, horizontal, vertical),\n    # the behavior is undefined by the examples. Returning the original grid\n    # or a white grid might be options. Let's return a white grid for now.\n    if diagonal_type not in [\"main\", \"anti\"]:\n         # Maybe handle single point as a special case if needed later\n         # For now, assume valid diagonals based on training data.\n         # print(f\"Warning: Unknown or non-diagonal line type '{diagonal_type}'. Returning white grid.\")\n         return np.zeros_like(input_np).tolist()\n\n\n    # 3. Initialize output grid with white (0)\n    output_grid = np.zeros_like(input_np, dtype=int)\n\n    # 4. Iterate through each pixel position in the potential output grid\n    for r_out in range(height):\n        for c_out in range(width):\n            # 5. Check the condition based on diagonal type against all input coordinates\n            fill_pixel = False\n            for r_in, c_in in input_coords:\n                if diagonal_type == \"main\":\n                    if r_out >= r_in and c_out <= c_in:\n                        fill_pixel = True\n                        break # Found a condition match for this output pixel\n                elif diagonal_type == \"anti\":\n                     if r_out >= r_in and c_out >= c_in:\n                        fill_pixel = True\n                        break # Found a condition match for this output pixel\n            \n            # 6. If the condition was met, fill the output pixel\n            if fill_pixel:\n                output_grid[r_out, c_out] = fill_color\n            # Otherwise, it remains white (0) as initialized\n\n    # Convert back to list of lists for the required output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11283,
    "candidates_token_count": 1485,
    "total_token_count": 12768,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.818212,
  "retries": 1
}