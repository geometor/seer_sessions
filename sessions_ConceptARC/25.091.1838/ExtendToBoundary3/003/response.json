{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms an input grid by drawing a line or path based on the relationship between two identified non-background elements: a 'marker pixel' and a 'reference structure'.\n\n1.  **Identify Background:** Determine the background color (most frequent).\n2.  **Identify Objects:**\n    *   Find all non-background pixels.\n    *   Identify the 'Marker Pixel':\n        *   If one color appears exactly once, its pixel is the marker.\n        *   If all non-background pixels share the same color, the marker is the one with the maximum row index, and among those, the maximum column index.\n    *   Identify the 'Reference Structure': All non-background pixels that are not the marker pixel.\n    *   Determine the orientation of the Reference Structure (Vertical, Horizontal, or Diagonal) and collect the set of unique rows and columns it occupies.\n3.  **Prepare Output:** Create a copy of the input grid.\n4.  **Execute Drawing Rule based on Reference Structure Orientation:**\n    *   **Vertical Reference:** Draw a horizontal line using the marker's color, in the marker's row, extending between the column immediately after the reference structure's column and the marker's column (inclusive).\n    *   **Horizontal Reference:** Draw a vertical line using the marker's color, in the marker's column, extending between the row immediately after the reference structure's row and the marker's row (inclusive).\n    *   **Diagonal Reference:** Draw a diagonal path using the marker's color.\n        *   Determine the diagonal step direction (dr, dc) from the marker towards the reference structure's center.\n        *   Start the path one step (dr, dc) away from the marker.\n        *   Continue stepping in the (dr, dc) direction, drawing pixels, until a point (r, c) is reached where either r is a row occupied by the reference structure OR c is a column occupied by the reference structure. Draw this final point and stop.\n5.  **Return Output:** Return the modified grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Identifies the background color, marker pixel, reference structure pixels,\n    reference structure orientation, and occupied rows/columns in the grid.\n    \"\"\"\n    rows, cols = grid.shape\n    flat_grid = grid.flatten()\n    \n    # Handle edge case of empty or single-color grid\n    if len(np.unique(flat_grid)) <= 1:\n        # If all same color, consider it background, no objects\n        return grid[0,0] if grid.size > 0 else 0, None, [], None, set(), set()\n\n    background_color = Counter(flat_grid).most_common(1)[0][0]\n\n    non_background_pixels = {} # {(r, c): color}\n    pixel_counts_by_color = Counter()\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color:\n                non_background_pixels[(r, c)] = color\n                pixel_counts_by_color[color] += 1\n\n    if not non_background_pixels:\n         return background_color, None, [], None, set(), set()\n\n    marker_pixel = None # ((r, c), color)\n    marker_pos = None\n    marker_color = -1\n\n    # Strategy 1: Find a color with count 1\n    unique_color = -1\n    for color, count in pixel_counts_by_color.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    if unique_color != -1:\n        for pos, c in non_background_pixels.items():\n            if c == unique_color:\n                marker_pos = pos\n                marker_color = c\n                marker_pixel = (pos, c)\n                break\n    # Strategy 2: All non-background pixels have the same color\n    elif len(pixel_counts_by_color) == 1:\n        # Find the pixel with the max row, then max col\n        marker_pos = max(non_background_pixels.keys(), key=lambda p: (p[0], p[1]))\n        marker_color = non_background_pixels[marker_pos]\n        marker_pixel = (marker_pos, marker_color)\n    else:\n         # Ambiguous case - more than one color, none unique.\n         # This case is not covered by the examples provided.\n         # Defaulting to max row/col strategy for now.\n         print(\"Warning: Ambiguous marker identification. Defaulting to max row/col.\")\n         marker_pos = max(non_background_pixels.keys(), key=lambda p: (p[0], p[1]))\n         marker_color = non_background_pixels[marker_pos]\n         marker_pixel = (marker_pos, marker_color)\n\n\n    # Identify reference pixels\n    reference_pixels = [] # list of (r, c, color)\n    ref_rows_set = set()\n    ref_cols_set = set()\n    for pos, color in non_background_pixels.items():\n        if pos != marker_pos:\n            r, c = pos\n            reference_pixels.append((r, c, color))\n            ref_rows_set.add(r)\n            ref_cols_set.add(c)\n\n    # Determine reference structure orientation\n    orientation = None\n    if reference_pixels:\n        # Use the sets collected earlier\n        ref_rows = ref_rows_set\n        ref_cols = ref_cols_set\n\n        if len(ref_cols) == 1 and len(ref_rows) > 0: # Need > 0 check in case ref is empty somehow\n            orientation = \"Vertical\"\n        elif len(ref_rows) == 1 and len(ref_cols) > 0:\n            orientation = \"Horizontal\"\n        elif len(ref_rows) > 1 and len(ref_cols) > 1:\n            # Check for diagonal - assumes pure diagonal based on examples\n            is_diag = True\n            sorted_ref = sorted(reference_pixels, key=lambda x: (x[0], x[1]))\n            if len(sorted_ref) > 1:\n                 dr = sorted_ref[1][0] - sorted_ref[0][0]\n                 dc = sorted_ref[1][1] - sorted_ref[0][1]\n                 # Check if step is diagonal (abs(dr)==abs(dc) and both non-zero)\n                 if not (abs(dr) == abs(dc) and dr != 0):\n                     is_diag = False\n                 else:\n                    # Verify consistent step for all segments\n                    for i in range(len(sorted_ref) -1):\n                        if (sorted_ref[i+1][0] - sorted_ref[i][0] != dr or\n                            sorted_ref[i+1][1] - sorted_ref[i][1] != dc):\n                            is_diag = False\n                            break\n            else: # Single reference pixel - cannot determine line orientation\n                is_diag = False\n\n            if is_diag:\n                 orientation = \"Diagonal\"\n            else:\n                 orientation = \"Other\" # Fallback if not clear line type\n        else: # Only one reference pixel, or empty reference pixels\n            orientation = \"Other\"\n\n\n    return background_color, marker_pixel, reference_pixels, orientation, ref_rows_set, ref_cols_set\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = output_grid.shape\n\n    # Find background, marker, reference structure, orientation, and ref rows/cols\n    bg_color, marker_pixel, ref_pixels, orientation, ref_rows, ref_cols = find_objects(input_np)\n\n    # If marker or reference not found, or orientation unclear, return original grid\n    if not marker_pixel or not ref_pixels or orientation == \"Other\" or orientation is None:\n        # Check if marker_pixel exists but ref_pixels is empty (only marker exists)\n        if marker_pixel and not ref_pixels:\n             # No reference, no transformation defined by examples\n             return input_grid\n        # Otherwise, return input for unclear cases\n        print(f\"Warning: No clear transformation possible. Marker: {marker_pixel}, Ref Pixels: {len(ref_pixels)}, Orientation: {orientation}\")\n        return input_grid\n\n    marker_pos, marker_color = marker_pixel\n    marker_r, marker_c = marker_pos\n\n    # Execute drawing based on orientation\n    if orientation == \"Vertical\":\n        # Reference structure is vertical\n        ref_c = list(ref_cols)[0] # Should only be one column in ref_cols\n\n        # Define drawing range for columns\n        draw_start_col = ref_c + 1\n        draw_end_col = marker_c\n        col_step = 1 if draw_end_col >= draw_start_col else -1\n\n        # Draw horizontal line in marker's row\n        for c in range(draw_start_col, draw_end_col + col_step, col_step):\n             if 0 <= marker_r < rows and 0 <= c < cols:\n                 output_grid[marker_r, c] = marker_color\n\n    elif orientation == \"Horizontal\":\n        # Reference structure is horizontal\n        ref_r = list(ref_rows)[0] # Should only be one row in ref_rows\n\n        # Define drawing range for rows\n        draw_start_row = ref_r + 1\n        draw_end_row = marker_r\n        row_step = 1 if draw_end_row >= draw_start_row else -1\n\n        # Draw vertical line in marker's column\n        for r in range(draw_start_row, draw_end_row + row_step, row_step):\n             if 0 <= r < rows and 0 <= marker_c < cols:\n                 output_grid[r, marker_c] = marker_color\n\n    elif orientation == \"Diagonal\":\n        # Reference structure is diagonal\n\n        # Determine the direction from marker towards the reference structure center (approximate)\n        if not ref_pixels: # Should not happen due to earlier check, but safety first\n             return output_grid.tolist()\n             \n        ref_center_r = sum(r for r, c, clr in ref_pixels) / len(ref_pixels)\n        ref_center_c = sum(c for r, c, clr in ref_pixels) / len(ref_pixels)\n\n        # Determine primary direction vector (dr, dc)\n        dr = 0\n        if ref_center_r < marker_r: dr = -1  # Target is above marker\n        elif ref_center_r > marker_r: dr = 1 # Target is below marker\n\n        dc = 0\n        if ref_center_c < marker_c: dc = -1  # Target is left of marker\n        elif ref_center_c > marker_c: dc = 1 # Target is right of marker\n        \n        # Ensure step is purely diagonal (abs(dr)=1 and abs(dc)=1)\n        # If marker is directly aligned horizontally or vertically with the center,\n        # infer diagonal direction based on relative quadrant (like in example 3)\n        if dr == 0 or dc == 0:\n            if marker_r > ref_center_r and marker_c < ref_center_c: dr, dc = -1, 1  # Lower Left -> Up Right\n            elif marker_r < ref_center_r and marker_c < ref_center_c: dr, dc = 1, 1 # Upper Left -> Down Right\n            elif marker_r < ref_center_r and marker_c > ref_center_c: dr, dc = 1, -1 # Upper Right -> Down Left\n            elif marker_r > ref_center_r and marker_c > ref_center_c: dr, dc = -1, -1 # Lower Right -> Up Left\n            else: # On axis or center? Need a default or better rule. Example 3 was LL.\n                  # Defaulting based on example 3 if needed.\n                  if dr == 0 and dc == 0: # Marker is exactly at center? Unlikely.\n                       print(\"Warning: Cannot determine diagonal direction reliably.\")\n                       # Guessing based on Example 3's marker being lower-left of structure\n                       dr, dc = -1, 1 \n                  elif dr == 0: # Vertically aligned\n                       dc = 1 if marker_c < ref_center_c else -1 # Move towards center col\n                       dr = 1 if marker_r < ref_center_r else -1 # Also move towards center row\n                  elif dc == 0: # Horizontally aligned\n                       dr = 1 if marker_r < ref_center_r else -1 # Move towards center row\n                       dc = 1 if marker_c < ref_center_c else -1 # Also move towards center col\n\n        # Start drawing path one step away from marker\n        curr_r, curr_c = marker_r + dr, marker_c + dc\n\n        while 0 <= curr_r < rows and 0 <= curr_c < cols:\n            # Check stop condition: current row OR current col is in reference sets\n            stop_condition_met = (curr_r in ref_rows) or (curr_c in ref_cols)\n\n            # Draw pixel\n            output_grid[curr_r, curr_c] = marker_color\n\n            # If stop condition met, break after drawing\n            if stop_condition_met:\n                break\n\n            # Move to next step\n            curr_r += dr\n            curr_c += dc\n\n    # Convert back to list of lists for the ARC standard format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16249,
    "candidates_token_count": 3221,
    "total_token_count": 19470,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 33.584761,
  "retries": 1
}