{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nThis program transforms an input grid based on the relationship between two non-background elements: a 'marker pixel' (a single isolated pixel) and a 'reference structure' (a line-like pattern).\n\n1.  **Identify Background:** Determine the background color (most frequent).\n2.  **Identify Elements:**\n    *   Find all non-background pixels.\n    *   Identify the 'marker pixel' (the single pixel of a unique color or location). Record its color and position.\n    *   Identify the 'reference structure' (the remaining non-background pixels). Record their coordinates and determine their orientation (Vertical, Horizontal, or Diagonal).\n3.  **Prepare Output:** Create a copy of the input grid.\n4.  **Execute Drawing Rule:**\n    *   **If Vertical Reference:** Draw a horizontal line using the marker's color. The line is in the marker's row, extending from the column immediately after the reference structure's column(s) up to the marker's column.\n    *   **If Horizontal Reference:** Draw a vertical line using the marker's color. The line is in the marker's column, extending from the row immediately after the reference structure's row(s) down to the marker's row.\n    *   **If Diagonal Reference:** Draw a diagonal path using the marker's color, starting one step away from the marker pixel and moving towards the reference structure. The path stops just before entering a column that contains any part of the reference structure.\n5.  **Return Output:** Return the modified grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds distinct objects (groups of same-colored pixels) in the grid.\n    For this specific task, simplifies by finding all non-background pixels\n    and identifying the marker (single pixel) vs reference structure.\n    \"\"\"\n    non_background_pixels = {} # {(r, c): color}\n    pixel_counts_by_color = Counter()\n    background_color = Counter(grid.flatten()).most_common(1)[0][0]\n    \n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != background_color:\n                non_background_pixels[(r, c)] = color\n                pixel_counts_by_color[color] += 1\n\n    marker_pixel = None\n    marker_color = -1\n    marker_pos = (-1, -1)\n    reference_pixels = [] # list of (r, c, color)\n\n    # Strategy 1: Find a color with count 1 - this is likely the marker\n    marker_found_by_count = False\n    for color, count in pixel_counts_by_color.items():\n        if count == 1:\n            for pos, c in non_background_pixels.items():\n                if c == color:\n                    marker_pos = pos\n                    marker_color = color\n                    marker_pixel = (pos, color)\n                    marker_found_by_count = True\n                    break\n            if marker_found_by_count:\n                break\n\n    # Strategy 2 (Fallback if no unique color count): Find the most isolated pixel\n    # For this task, the examples suggest the single pixel is always distinct\n    # either by color or clear separation, so Strategy 1 should suffice.\n    # If Ex2 generalizes differently, this needs refinement.\n    # Currently, we assume Strategy 1 worked or the problem setup guarantees it.\n    # Example 2 has marker and reference same color, but marker is single pixel.\n    # Let's refine: if multiple colors, find the one with count 1.\n    # If only one color, find the pixel that is most isolated or assume the first one found?\n    # Let's stick to the count=1 rule first.\n\n    if not marker_found_by_count and len(pixel_counts_by_color) == 1:\n         # Handle case like example 2 where marker and ref have same color.\n         # Assume the 'marker' is one of the pixels, and the rest are reference.\n         # The rule seems to be based on spatial structure. The single point vs the line.\n         # For now, let's find the first non-background pixel and assume it *could* be the marker.\n         # We'll rely on the orientation check later to distinguish.\n         # A better approach might be needed if ambiguity arises.\n         # For Ex2, any of the single orange points could be the 'marker' conceptually,\n         # but the one at (7, 8) dictates the drawing action. Let's assume the most 'extreme'\n         # or isolated point is the marker in such cases. Let's find the lowest, rightmost point.\n         potential_marker_pos = max(non_background_pixels.keys())\n         marker_pos = potential_marker_pos\n         marker_color = non_background_pixels[marker_pos]\n         marker_pixel = (marker_pos, marker_color)\n\n\n    # Assign remaining non-background pixels to the reference structure\n    for pos, color in non_background_pixels.items():\n        if pos != marker_pos:\n            reference_pixels.append((*pos, color))\n\n    if not marker_pixel:\n         # Fallback if marker wasn't identified (e.g., only one object type found)\n         # This shouldn't happen based on examples, but good practice.\n         print(\"Warning: Could not definitively identify marker pixel.\")\n         # Defaulting marker to first found non-background if necessary\n         if non_background_pixels:\n             first_pos = list(non_background_pixels.keys())[0]\n             marker_pixel = (first_pos, non_background_pixels[first_pos])\n             marker_pos = first_pos\n             marker_color = non_background_pixels[first_pos]\n             # Re-calculate reference pixels\n             reference_pixels = []\n             for pos, color in non_background_pixels.items():\n                 if pos != marker_pos:\n                     reference_pixels.append((*pos, color))\n         else: # No non-background pixels at all\n             return None, [], None # marker_pixel, reference_pixels, orientation\n\n    # Determine reference structure orientation\n    orientation = None\n    if reference_pixels:\n        ref_rows = {r for r, c, clr in reference_pixels}\n        ref_cols = {c for r, c, clr in reference_pixels}\n        \n        if len(ref_cols) == 1:\n            orientation = \"Vertical\"\n        elif len(ref_rows) == 1:\n            orientation = \"Horizontal\"\n        else:\n            # Check for diagonal - simplified check: not horizontal or vertical\n            is_diag = True\n            # More robust check: sort by row, then col, check difference\n            sorted_ref = sorted(reference_pixels, key=lambda x: (x[0], x[1]))\n            if len(sorted_ref) > 1:\n                 dr = sorted_ref[1][0] - sorted_ref[0][0]\n                 dc = sorted_ref[1][1] - sorted_ref[0][1]\n                 if abs(dr) != abs(dc): # Needs consistent step for pure diagonal\n                     is_diag = False # Or could be noisy diagonal? Assume pure based on examples.\n                 else:\n                     for i in range(len(sorted_ref) -1):\n                         if (sorted_ref[i+1][0] - sorted_ref[i][0] != dr or\n                             sorted_ref[i+1][1] - sorted_ref[i][1] != dc):\n                             is_diag = False\n                             break\n            else: # single reference pixel? Unlikely given examples.\n                 is_diag = False\n\n            if is_diag:\n                 orientation = \"Diagonal\"\n            else:\n                 orientation = \"Other\" # Fallback if not clear line type\n\n\n    return marker_pixel, reference_pixels, orientation\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by drawing a line/path from the reference\n    structure towards the marker pixel based on the structure's orientation.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_np)\n    rows, cols = output_grid.shape\n\n    # Find the marker pixel and reference structure\n    marker_pixel, reference_pixels, orientation = find_objects(input_np)\n\n    if not marker_pixel or not reference_pixels or not orientation:\n        # If elements not found or orientation unclear, return original grid\n        return input_grid\n\n    marker_pos, marker_color = marker_pixel\n    marker_r, marker_c = marker_pos\n\n    # Execute drawing based on orientation\n    if orientation == \"Vertical\":\n        # Find the column of the vertical reference line\n        ref_c = reference_pixels[0][1] # All have the same column\n\n        # Determine start and end columns for drawing\n        start_c = ref_c + 1\n        end_c = marker_c\n        step = 1 if end_c >= start_c else -1\n\n        # Draw horizontal line in marker's row\n        if 0 <= marker_r < rows:\n            # Ensure columns are within bounds\n            c_range_start = max(0, min(start_c, end_c))\n            c_range_end = min(cols, max(start_c, end_c) + 1)\n             # The examples show filling from ref+1 up *to* marker_c\n            if start_c <= end_c:\n                for c in range(start_c, end_c + 1):\n                     if 0 <= c < cols:\n                         output_grid[marker_r, c] = marker_color\n            else: # Draw backwards if marker is left of ref+1\n                 for c in range(start_c, end_c - 1, -1):\n                     if 0 <= c < cols:\n                         output_grid[marker_r, c] = marker_color\n            # Example 1 specifically draws from ref_col+1 TO marker_col\n            # Let's refine the range exactly for Example 1 logic\n            draw_start_col = ref_c + 1\n            draw_end_col = marker_c\n            col_step = 1 if draw_end_col >= draw_start_col else -1\n            for c in range(draw_start_col, draw_end_col + col_step, col_step):\n                 if 0 <= marker_r < rows and 0 <= c < cols:\n                     output_grid[marker_r, c] = marker_color\n\n\n    elif orientation == \"Horizontal\":\n        # Find the row of the horizontal reference line\n        ref_r = reference_pixels[0][0] # All have the same row\n\n        # Determine start and end rows for drawing\n        start_r = ref_r + 1\n        end_r = marker_r\n        step = 1 if end_r >= start_r else -1\n\n        # Draw vertical line in marker's column\n        if 0 <= marker_c < cols:\n            # Ensure rows are within bounds\n            r_range_start = max(0, min(start_r, end_r))\n            r_range_end = min(rows, max(start_r, end_r) + 1)\n            # The examples show filling from ref+1 down *to* marker_r\n            if start_r <= end_r:\n                 for r in range(start_r, end_r + 1):\n                    if 0 <= r < rows:\n                        output_grid[r, marker_c] = marker_color\n            else: # Draw upwards if marker is above ref+1\n                 for r in range(start_r, end_r - 1, -1):\n                     if 0 <= r < rows:\n                         output_grid[r, marker_c] = marker_color\n            # Example 2 specifically draws from ref_row+1 TO marker_row\n            # Let's refine the range exactly for Example 2 logic\n            draw_start_row = ref_r + 1\n            draw_end_row = marker_r\n            row_step = 1 if draw_end_row >= draw_start_row else -1\n            for r in range(draw_start_row, draw_end_row + row_step, row_step):\n                 if 0 <= r < rows and 0 <= marker_c < cols:\n                     output_grid[r, marker_c] = marker_color\n\n\n    elif orientation == \"Diagonal\":\n        # Get the set of columns occupied by the reference structure\n        ref_cols = {c for r, c, clr in reference_pixels}\n\n        # Determine the direction from marker towards the reference structure center (approximate)\n        ref_center_r = sum(r for r, c, clr in reference_pixels) / len(reference_pixels)\n        ref_center_c = sum(c for r, c, clr in reference_pixels) / len(reference_pixels)\n\n        dr = 0\n        if ref_center_r < marker_r: dr = -1\n        elif ref_center_r > marker_r: dr = 1\n\n        dc = 0\n        if ref_center_c < marker_c: dc = -1\n        elif ref_center_c > marker_c: dc = 1\n\n        # Handle case where marker aligns vertically/horizontally with center\n        if dr == 0 and dc == 0:\n             # If marker is ON the reference line (unlikely based on examples) or\n             # if reference is single point. Need a clearer direction rule.\n             # Let's use the direction from example 3: marker(6,0) ref(diagonal) -> path is (-1, 1)\n             # Marker lower-left of structure -> path goes up-right.\n             # Infer direction based on relative quadrant.\n             if marker_r > ref_center_r and marker_c < ref_center_c: # Marker Lower Left -> Up Right\n                 dr, dc = -1, 1\n             elif marker_r < ref_center_r and marker_c < ref_center_c: # Marker Upper Left -> Down Right\n                 dr, dc = 1, 1\n             elif marker_r < ref_center_r and marker_c > ref_center_c: # Marker Upper Right -> Down Left\n                 dr, dc = 1, -1\n             elif marker_r > ref_center_r and marker_c > ref_center_c: # Marker Lower Right -> Up Left\n                 dr, dc = -1, -1\n             # Add defaults if still zero (e.g., aligned) - check example 3\n             # Ex3: (6,0) vs center ~ (3,3) -> dr=-1, dc=1 seems correct.\n             if dr == 0 and dc == 0 : # Still zero? Default or error. Let's assume (-1, 1) based on Ex3 if needed.\n                  # This case needs more examples to be robust. For Ex3, this works:\n                  dr = -1 # move up\n                  dc = 1  # move right\n\n\n        # Start drawing path one step away from marker\n        curr_r, curr_c = marker_r + dr, marker_c + dc\n\n        while 0 <= curr_r < rows and 0 <= curr_c < cols:\n            # Check collision: stop if the current column contains a reference pixel\n            if curr_c in ref_cols:\n                break\n\n            # Draw pixel\n            output_grid[curr_r, curr_c] = marker_color\n\n            # Move to next step\n            curr_r += dr\n            curr_c += dc\n\n    # Convert back to list of lists for the ARC standard\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4357,
    "candidates_token_count": 3656,
    "total_token_count": 8013,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 122.95519,
  "retries": 2
}