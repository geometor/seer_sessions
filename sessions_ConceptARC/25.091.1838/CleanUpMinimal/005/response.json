{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify all separate, contiguous groups of pixels in the input grid that are not the background color (white, 0). Record the color, size (pixel count), and coordinates of each group (object). Find the object(s) with the largest size. Determine the color of this largest object(s) - call this the \"target color\". Create a new output grid of the same dimensions as the input, initially filled completely with the background color (white, 0). Go through each object identified. If the object's color is the same as the \"target color\", copy all pixels belonging to this object to the corresponding positions in the output grid, keeping their \"target color\". If the object's color is *different* from the \"target color\", check if *any* pixel in this object is directly adjacent (up, down, left, or right) to *any* pixel that belongs to *any* object having the \"target color\". If such adjacency is found for the non-target-color object, then color *all* pixels corresponding to this object's original positions with the \"target color\" in the output grid. If no such adjacency is found for the non-target-color object, leave its corresponding pixels as the background color (white, 0) in the output grid. The final output grid is the result of applying these rules to all identified objects.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains keys 'coords' (a set of (row, col) tuples),\n              'color' (int), and 'size' (int).\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Check if the pixel is non-background and not yet visited\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                # Breadth-First Search (BFS) to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n\n                    # Check cardinal neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds, has the same color, and hasn't been visited\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                # Store the found object with its coordinates, color, and size\n                objects.append({'coords': obj_coords, 'color': int(color), 'size': len(obj_coords)})\n\n    return objects\n\ndef check_adjacency(obj_coords, target_coords, grid_shape):\n    \"\"\"\n    Checks if any pixel in obj_coords is cardinally adjacent to any pixel in target_coords.\n\n    Args:\n        obj_coords (set): Set of coordinates for the object to check.\n        target_coords (set): Set of coordinates for the target color objects.\n        grid_shape (tuple): Shape (rows, cols) of the grid.\n\n    Returns:\n        bool: True if any pixel in obj_coords is adjacent to target_coords, False otherwise.\n    \"\"\"\n    rows, cols = grid_shape\n    for r, c in obj_coords:\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in target_coords:\n                return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the refined rule involving the largest object's color\n    and adjacency for other colored objects.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    background_color = 0\n\n    # Initialize the output grid with the background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Find all non-background objects in the input grid\n    objects = find_objects(input_grid_np, background_color)\n\n    # If no non-background objects are found, return the initialized background grid\n    if not objects:\n        return output_grid.tolist()\n\n    # Find the maximum size among all objects\n    max_size = 0\n    for obj in objects:\n        if obj['size'] > max_size:\n            max_size = obj['size']\n\n    # Determine the target color (color of any object with max_size)\n    target_color = -1 # Should be overwritten\n    for obj in objects:\n        if obj['size'] == max_size:\n            target_color = obj['color']\n            break\n\n    # Collect all coordinates of objects with the target color\n    target_color_coords = set()\n    for obj in objects:\n        if obj['color'] == target_color:\n            target_color_coords.update(obj['coords'])\n\n    # Iterate through all objects to populate the output grid\n    for obj in objects:\n        # If the object's color is the target color, copy it directly\n        if obj['color'] == target_color:\n            for r, c in obj['coords']:\n                output_grid[r, c] = target_color\n        # If the object's color is not the target color, check for adjacency\n        else:\n            # Check if this object is adjacent to any target color pixel\n            is_adjacent = check_adjacency(obj['coords'], target_color_coords, input_grid_np.shape)\n            # If adjacent, color this object's pixels with the target color\n            if is_adjacent:\n                for r, c in obj['coords']:\n                    output_grid[r, c] = target_color\n            # If not adjacent, leave as background (already initialized)\n\n    # Convert the final numpy grid back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15864,
    "candidates_token_count": 1592,
    "total_token_count": 17456,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.970416,
  "retries": 1
}