{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nIdentify all distinct contiguous objects composed of non-white pixels in the input grid. Determine the largest object by pixel count (the \"main object\") and note its color (\"main color\"). Create an output grid initialized with the white background color (0). Copy the main object to the output grid using its main color. Iterate through all other non-white pixels in the input grid (\"secondary pixels\"). If a secondary pixel is cardinally adjacent (shares an edge) to any pixel of the main object, color the corresponding pixel in the output grid with the main color. Leave all other output grid pixels as white.\n\"\"\"\n\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid, background_color=0):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n        background_color (int): The color considered as background.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object\n              and contains (set of coordinates, color).\n              Returns an empty list if no non-background objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    \n                    # Check neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append((obj_coords, color))\n                \n    return objects\n\ndef get_largest_object(objects):\n    \"\"\"\n    Finds the object with the largest number of pixels.\n\n    Args:\n        objects (list): A list of objects, where each object is (coords_set, color).\n\n    Returns:\n        tuple: The largest object (coords_set, color), or (set(), -1) if no objects.\n               Assumes unique largest object based on examples.\n    \"\"\"\n    if not objects:\n        return (set(), -1) # Indicate no object found\n        \n    largest_obj = max(objects, key=lambda obj: len(obj[0]))\n    return largest_obj\n\ndef is_cardinally_adjacent(r, c, main_object_coords, grid_shape):\n    \"\"\"\n    Checks if a pixel at (r, c) is cardinally adjacent to any pixel\n    in the main_object_coords.\n\n    Args:\n        r (int): Row of the pixel to check.\n        c (int): Column of the pixel to check.\n        main_object_coords (set): Set of coordinates {(row, col), ...} for the main object.\n        grid_shape (tuple): The shape (rows, cols) of the grid.\n\n    Returns:\n        bool: True if cardinally adjacent, False otherwise.\n    \"\"\"\n    rows, cols = grid_shape\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in main_object_coords:\n            return True\n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the identified rule:\n    Keep the largest non-background object. Recolor any non-background pixel\n    cardinally adjacent to this main object with the main object's color.\n    All other pixels become background (white, 0).\n\n    Args:\n        input_grid (np.ndarray): The 2D input grid.\n\n    Returns:\n        np.ndarray: The transformed 2D output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    rows, cols = input_grid_np.shape\n    background_color = 0\n    \n    # Initialize output grid with background color\n    output_grid = np.full((rows, cols), background_color, dtype=int)\n\n    # Find all non-background objects\n    objects = find_objects(input_grid_np, background_color)\n    \n    # If no non-background objects, return the empty grid\n    if not objects:\n        return output_grid\n\n    # Identify the largest object (main object)\n    main_object_coords, main_object_color = get_largest_object(objects)\n\n    # If somehow no largest object is found (e.g., only background), return empty grid\n    if main_object_color == -1:\n         return output_grid\n         \n    # Copy the main object to the output grid\n    for r, c in main_object_coords:\n        output_grid[r, c] = main_object_color\n\n    # Iterate through all pixels in the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Consider only non-background pixels that are NOT part of the main object\n            if input_grid_np[r, c] != background_color and (r, c) not in main_object_coords:\n                # Check if this pixel is cardinally adjacent to the main object\n                if is_cardinally_adjacent(r, c, main_object_coords, input_grid_np.shape):\n                    # If adjacent, color it with the main object's color in the output\n                    output_grid[r, c] = main_object_color\n                    \n    return output_grid.tolist() # Convert back to list of lists if necessary for ARC format\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2773,
    "candidates_token_count": 1439,
    "total_token_count": 4212,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.964677,
  "retries": 1
}