{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by rearranging objects based on their spatial arrangement.\n\n1.  Identifies distinct non-white objects in the input grid.\n2.  Determines if the objects are primarily arranged horizontally or vertically.\n3.  If arranged horizontally, performs a cyclic left shift on the positions of all objects except the rightmost one.\n4.  If arranged vertically, reverses the vertical order of the object positions.\n5.  Reconstructs the output grid by drawing the original objects in their new calculated positions.\n\"\"\"\n\n# Helper function to find contiguous objects of the same color\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (relative coordinates), and 'bbox'.\n              Returns empty list if no objects are found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    background_color = 0\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                object_pixels_abs = set([(r, c)])\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            object_pixels_abs.add((nr, nc))\n\n                # Convert absolute pixel coordinates to relative coordinates\n                object_pixels_rel = set((px_r - min_r, px_c - min_c) for px_r, px_c in object_pixels_abs)\n                bbox = (min_r, min_c, max_r, max_c)\n                objects.append({\n                    'color': color,\n                    'pixels': object_pixels_rel,\n                    'bbox': bbox\n                })\n\n    return objects\n\n# Helper function to determine arrangement axis\ndef determine_arrangement(objects):\n    \"\"\"\n    Determines if objects are primarily arranged horizontally or vertically.\n\n    Args:\n        objects (list): List of object dictionaries.\n\n    Returns:\n        str: 'horizontal', 'vertical', or 'none'.\n    \"\"\"\n    if len(objects) <= 1:\n        return 'none' # Not enough objects to determine arrangement\n\n    # Sort by min_c (left edge)\n    objects_sorted_c = sorted(objects, key=lambda o: o['bbox'][1])\n    # Sort by min_r (top edge)\n    objects_sorted_r = sorted(objects, key=lambda o: o['bbox'][0])\n\n    # Check for horizontal separation (non-overlapping columns)\n    is_horizontally_separated = True\n    for i in range(len(objects_sorted_c) - 1):\n        # bbox = (min_r, min_c, max_r, max_c)\n        max_c_prev = objects_sorted_c[i]['bbox'][3]\n        min_c_next = objects_sorted_c[i+1]['bbox'][1]\n        if max_c_prev >= min_c_next:\n             # Check if vertical ranges overlap significantly\n             min_r_prev, max_r_prev = objects_sorted_c[i]['bbox'][0], objects_sorted_c[i]['bbox'][2]\n             min_r_next, max_r_next = objects_sorted_c[i+1]['bbox'][0], objects_sorted_c[i+1]['bbox'][2]\n             # Simple overlap check: if they touch or cross vertically, it might break horizontal assumption\n             if max(min_r_prev, min_r_next) <= min(max_r_prev, max_r_next):\n                 is_horizontally_separated = False\n                 # break # Keep checking? Example 1 has some vertical overlap but is horizontal.\n                 # Let's assume simple bounding box separation is enough for now. If max_c >= min_c_next, it fails.\n                 is_horizontally_separated = False\n                 break\n\n    # Check for vertical separation (non-overlapping rows)\n    is_vertically_separated = True\n    for i in range(len(objects_sorted_r) - 1):\n        max_r_prev = objects_sorted_r[i]['bbox'][2]\n        min_r_next = objects_sorted_r[i+1]['bbox'][0]\n        if max_r_prev >= min_r_next:\n             # Check if horizontal ranges overlap significantly\n             min_c_prev, max_c_prev = objects_sorted_r[i]['bbox'][1], objects_sorted_r[i]['bbox'][3]\n             min_c_next, max_c_next = objects_sorted_r[i+1]['bbox'][1], objects_sorted_r[i+1]['bbox'][3]\n             if max(min_c_prev, min_c_next) <= min(max_c_prev, max_c_next):\n                 is_vertically_separated = False\n                 # break\n                 is_vertically_separated = False\n                 break\n\n\n    # Determine primary arrangement\n    if is_horizontally_separated and not is_vertically_separated:\n        return 'horizontal'\n    elif is_vertically_separated and not is_horizontally_separated:\n        return 'vertical'\n    elif is_horizontally_separated and is_vertically_separated:\n         # Tie-breaker: Check total separation distance? Or assume horizontal preference?\n         # Let's assume horizontal if both are separated, as seen in train_1 with small objects.\n         # Or perhaps compare total gap sizes\n         h_gap = sum(objects_sorted_c[i+1]['bbox'][1] - objects_sorted_c[i]['bbox'][3] -1 for i in range(len(objects_sorted_c)-1) if objects_sorted_c[i+1]['bbox'][1] > objects_sorted_c[i]['bbox'][3] + 1)\n         v_gap = sum(objects_sorted_r[i+1]['bbox'][0] - objects_sorted_r[i]['bbox'][2] -1 for i in range(len(objects_sorted_r)-1) if objects_sorted_r[i+1]['bbox'][0] > objects_sorted_r[i]['bbox'][2] + 1)\n         return 'horizontal' if h_gap >= v_gap else 'vertical' # Favor horizontal if equal\n    else:\n        # If neither strictly separated by bbox, maybe default or error?\n        # Let's try a relaxed check: majority horizontal or vertical?\n        # Count overlaps\n        h_overlaps = 0\n        for i in range(len(objects_sorted_c) - 1):\n             if objects_sorted_c[i]['bbox'][3] >= objects_sorted_c[i+1]['bbox'][1]: h_overlaps += 1\n        v_overlaps = 0\n        for i in range(len(objects_sorted_r) - 1):\n             if objects_sorted_r[i]['bbox'][2] >= objects_sorted_r[i+1]['bbox'][0]: v_overlaps += 1\n\n        if h_overlaps < v_overlaps: return 'horizontal'\n        if v_overlaps < h_overlaps: return 'vertical'\n        # Default if still ambiguous (e.g., single object, complex overlap)\n        return 'horizontal' # Default guess\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object rearrangement transformation to the input grid.\n    \"\"\"\n    # Initialize output_grid with the same dimensions and background color\n    output_grid = np.zeros_like(input_grid)\n    background_color = 0\n    output_grid.fill(background_color)\n\n    # Find all distinct objects in the input grid\n    objects = find_objects(input_grid)\n\n    if not objects:\n        return output_grid # Return empty grid if no objects found\n\n    # Determine the primary arrangement axis (horizontal or vertical)\n    arrangement_axis = determine_arrangement(objects)\n\n    num_objects = len(objects)\n    if num_objects <= 1: # No rearrangement needed for 0 or 1 object\n        arrangement_axis = 'none'\n\n\n    # Sort objects based on the arrangement axis and get original positions\n    original_positions = [] # List to store original bounding boxes\n    if arrangement_axis == 'horizontal':\n        objects.sort(key=lambda o: o['bbox'][1]) # Sort by min_c (left edge)\n        original_positions = [o['bbox'] for o in objects]\n    elif arrangement_axis == 'vertical':\n        objects.sort(key=lambda o: o['bbox'][0]) # Sort by min_r (top edge)\n        original_positions = [o['bbox'] for o in objects]\n    else: # 'none' or ambiguous\n        original_positions = [o['bbox'] for o in objects] # Keep original order/positions\n\n\n    # Determine the new positions based on the permutation rule\n    new_positions = list(original_positions) # Start with a copy\n    if arrangement_axis == 'horizontal' and num_objects > 1:\n        # Cyclic shift left N-1: pos[0]->pos[1], pos[1]->pos[2], ..., pos[N-2]->pos[0]. pos[N-1] stays.\n        first_pos = original_positions[0]\n        for i in range(num_objects - 2):\n            new_positions[i] = original_positions[i+1]\n        new_positions[num_objects - 2] = first_pos\n        # The last object's position (index N-1) remains unchanged (already copied)\n    elif arrangement_axis == 'vertical' and num_objects > 1:\n        # Reverse the order of positions\n        new_positions.reverse()\n\n    # Reconstruct the output grid by drawing objects in their new positions\n    for i, obj in enumerate(objects):\n        target_bbox = new_positions[i]\n        target_min_r, target_min_c = target_bbox[0], target_bbox[1]\n        color = obj['color']\n        # Draw the object's pixels relative to the new top-left corner\n        for rel_r, rel_c in obj['pixels']:\n            draw_r, draw_c = target_min_r + rel_r, target_min_c + rel_c\n            # Ensure drawing stays within grid bounds (shouldn't be necessary if logic is correct)\n            if 0 <= draw_r < output_grid.shape[0] and 0 <= draw_c < output_grid.shape[1]:\n                output_grid[draw_r, draw_c] = color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4225,
    "candidates_token_count": 2736,
    "total_token_count": 6961,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.739557,
  "retries": 1
}