{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by rearranging objects based on their spatial arrangement.\n\n1.  Identifies distinct non-white objects in the input grid, recording their color, \n    relative pixel coordinates (to bounding box top-left), and bounding box.\n2.  Determines if the objects are primarily arranged horizontally or vertically by \n    checking bounding box separation. Sorts objects along this primary axis.\n3.  Calculates the gaps (number of background cells) between adjacent objects along \n    the arrangement axis in their original sorted order.\n4.  Determines a permutation of the object indices based on the arrangement axis:\n    - If Horizontal: Performs a left cyclic shift on the indices of the first N-1 \n      objects (0->1, 1->2, ..., N-2 -> 0), leaving the last object's index in place.\n    - If Vertical: Reverses the order of the object indices.\n5.  Calculates the new top-left drawing coordinates for each object based on the \n    permuted sequence, original object dimensions, and original gaps between them. \n    Objects are aligned along the non-arrangement axis based on the minimum \n    coordinate observed across all objects along that axis.\n6.  Reconstructs the output grid by drawing the original objects (using their \n    relative pixels) at their newly calculated top-left positions on a background grid.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'color', 'pixels' (relative coordinates), and 'bbox'.\n              Returns empty list if no objects are found.\n    \"\"\"\n    objects = []\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    background_color = 0 # Assuming 0 is always background\n\n    for r in range(height):\n        for c in range(width):\n            # Check if pixel is part of an object and not visited yet\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n                object_pixels_abs = set([(r, c)]) # Store absolute coordinates\n                # Initialize bounding box coordinates\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and if visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            object_pixels_abs.add((nr, nc))\n\n                # Convert absolute pixel coordinates to relative coordinates (to bbox top-left)\n                object_pixels_rel = set((px_r - min_r, px_c - min_c) for px_r, px_c in object_pixels_abs)\n                bbox = (min_r, min_c, max_r, max_c)\n                objects.append({\n                    'color': color,\n                    'pixels': object_pixels_rel,\n                    'bbox': bbox\n                    # 'orig_index' will be added later after sorting\n                })\n    return objects\n\ndef determine_arrangement_and_sort(objects):\n    \"\"\"\n    Determines arrangement axis, sorts objects, calculates gaps, and adds original index.\n\n    Args:\n        objects (list): List of object dictionaries from find_objects.\n\n    Returns:\n        tuple: (arrangement_axis, sorted_objects, gaps)\n               arrangement_axis (str): 'horizontal', 'vertical', or 'none'.\n               sorted_objects (list): Objects sorted by arrangement axis, each dict\n                                      now includes 'orig_index'.\n               gaps (list): Gaps (>=0) between adjacent sorted objects along the axis.\n                            len(gaps) == len(sorted_objects) - 1.\n    \"\"\"\n    num_objects = len(objects)\n    # Base case: 0 or 1 object, no arrangement or gaps\n    if num_objects <= 1:\n        for i, obj in enumerate(objects):\n             obj['orig_index'] = i\n        return 'none', objects, []\n\n    # Calculate potential overlaps/separations for both axes\n    # Sort by min_c (left edge) for horizontal analysis\n    objects_sorted_c = sorted(objects, key=lambda o: o['bbox'][1])\n    # Sort by min_r (top edge) for vertical analysis\n    objects_sorted_r = sorted(objects, key=lambda o: o['bbox'][0])\n\n    h_overlaps = 0\n    h_gaps = []\n    for i in range(num_objects - 1):\n        # bbox = (min_r, min_c, max_r, max_c)\n        max_c_prev = objects_sorted_c[i]['bbox'][3]\n        min_c_next = objects_sorted_c[i+1]['bbox'][1]\n        # Check for horizontal overlap or touching\n        if max_c_prev >= min_c_next -1 : # Treat touching as overlap for simplicity? Check examples. Example 1 has gaps. Let's require a gap > 0.\n             if max_c_prev >= min_c_next: # Bboxes overlap horizontally\n                 h_overlaps += 1\n                 h_gaps.append(0) # Represent overlap as 0 gap for calculation? Or maybe 1? Let's stick to 0 for now. Or better, use 1 as minimum gap even if they overlapped.\n             else: # Touching exactly\n                 h_gaps.append(0)\n        else: # Clear gap exists\n            h_gaps.append(min_c_next - max_c_prev - 1)\n\n    v_overlaps = 0\n    v_gaps = []\n    for i in range(num_objects - 1):\n        max_r_prev = objects_sorted_r[i]['bbox'][2]\n        min_r_next = objects_sorted_r[i+1]['bbox'][0]\n        # Check for vertical overlap or touching\n        if max_r_prev >= min_r_next -1:\n            if max_r_prev >= min_r_next: # Bboxes overlap vertically\n                v_overlaps += 1\n                v_gaps.append(0) # Treat overlap as 0 gap\n            else: # Touching exactly\n                 v_gaps.append(0)\n        else: # Clear gap exists\n            v_gaps.append(min_r_next - max_r_prev - 1)\n\n    # Determine primary arrangement axis\n    # Prioritize the axis with zero overlaps if the other has overlaps\n    if h_overlaps == 0 and v_overlaps > 0:\n        arrangement = 'horizontal'\n    elif v_overlaps == 0 and h_overlaps > 0:\n        arrangement = 'vertical'\n    # If both have overlaps or both have no overlaps, decide based on which has fewer overlaps\n    # (or default to horizontal if equal)\n    elif h_overlaps <= v_overlaps:\n         arrangement = 'horizontal'\n    else: # v_overlaps < h_overlaps\n         arrangement = 'vertical'\n\n    # Assign the final sorted list and corresponding gaps based on the chosen axis\n    if arrangement == 'horizontal':\n        sorted_objects = objects_sorted_c\n        gaps = h_gaps\n    elif arrangement == 'vertical':\n        sorted_objects = objects_sorted_r\n        gaps = v_gaps\n    else: # Should not be reached if num_objects > 1, defensive fallback\n        # Sort by top-then-left as a default order\n        sorted_objects = sorted(objects, key=lambda o: (o['bbox'][0], o['bbox'][1]))\n        gaps = []\n        arrangement = 'none'\n\n    # Add original index to each object based on the chosen sorted order\n    # This index refers to its position (0 to N-1) in the sorted list\n    for i, obj in enumerate(sorted_objects):\n        obj['orig_index'] = i\n\n    # Ensure gaps are non-negative for calculation (treat overlaps/touching as gap=0 or 1?)\n    # Example 1 has gaps > 0. Let's assume minimum gap of 1 if original was <= 0.\n    final_gaps = [max(1, g) if g <= 0 else g for g in gaps] # Use original gap if > 0, else use 1\n\n    # Recalculate gaps just based on bbox distance, ensuring positive.\n    final_gaps = []\n    if arrangement == 'horizontal':\n        for i in range(num_objects - 1):\n            gap = sorted_objects[i+1]['bbox'][1] - sorted_objects[i]['bbox'][3] - 1\n            final_gaps.append(max(0, gap)) # Ensure gap is never negative\n    elif arrangement == 'vertical':\n        for i in range(num_objects - 1):\n            gap = sorted_objects[i+1]['bbox'][0] - sorted_objects[i]['bbox'][2] - 1\n            final_gaps.append(max(0, gap))\n\n\n    return arrangement, sorted_objects, final_gaps\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the object rearrangement transformation to the input grid.\n    \"\"\"\n    # Initialize output_grid with the same dimensions and background color\n    output_grid = np.zeros_like(input_grid)\n    background_color = 0\n    output_grid.fill(background_color)\n\n    # 1. Find all distinct objects\n    objects_found = find_objects(input_grid)\n    num_objects = len(objects_found)\n\n    # If no objects, return the empty grid\n    if num_objects == 0:\n        return output_grid\n\n    # 2. Determine arrangement axis, sort objects, calculate gaps, add original index\n    arrangement_axis, objects, gaps = determine_arrangement_and_sort(objects_found)\n\n    # Handle base case: 0 or 1 object, or no clear arrangement determined\n    # Just redraw the object(s) in their original positions\n    if num_objects <= 1 or arrangement_axis == 'none':\n        for obj in objects: # 'objects' is the sorted list, but order doesn't matter here\n            min_r, min_c, _, _ = obj['bbox'] # Get original top-left corner\n            color = obj['color']\n            # Draw the object using its relative pixels from its original position\n            for rel_r, rel_c in obj['pixels']:\n                draw_r, draw_c = min_r + rel_r, min_c + rel_c\n                # Check grid bounds before drawing\n                if 0 <= draw_r < output_grid.shape[0] and 0 <= draw_c < output_grid.shape[1]:\n                    output_grid[draw_r, draw_c] = color\n        return output_grid\n\n    # 4. Determine the permutation of original indices based on the arrangement axis\n    original_indices = list(range(num_objects)) # Indices [0, 1, ..., N-1] based on sorted order\n    permuted_indices = list(original_indices) # Start with identity, will be modified\n\n    if arrangement_axis == 'horizontal':\n        # Apply Left cyclic shift to the first N-1 indices:\n        # The object originally at index 0 moves to index 1's slot,\n        # object at 1 moves to 2's slot, ..., object at N-2 moves to 0's slot.\n        # The object originally at index N-1 stays in index N-1's slot.\n        # Result: permuted_indices[new_slot] = original_index\n        if num_objects > 1:\n            first_idx = original_indices[0] # Index of the first object in sorted list\n            # Shift indices 1 to N-1 one step to the left (into slots 0 to N-2)\n            for i in range(num_objects - 2): # Iterate through target slots 0 to N-3\n                permuted_indices[i] = original_indices[i+1]\n            # Place the first object's index into the second-to-"
          }
        ],
        "role": "model"
      },
      "finish_reason": 2,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12928,
    "candidates_token_count": 3056,
    "total_token_count": 15984,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 150.974189,
  "retries": 2
}