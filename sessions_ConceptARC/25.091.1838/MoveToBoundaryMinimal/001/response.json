{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify the background color (white, 0).\nIdentify all non-background pixels.\nFind the pixel color that appears exactly once; this is the 'mover' pixel. Record its color and initial coordinates (row_start, col_start).\nIdentify the remaining non-background pixels; these form the 'barrier' line. Determine if the barrier is horizontal or vertical. Record the barrier's row or column coordinate.\nDetermine the target coordinates (row_end, col_end) for the 'mover' pixel:\n  If the barrier is vertical at column `col_barrier`:\n    The target row is `row_start`.\n    The target column is `col_barrier - 1` if `col_start < col_barrier`, otherwise `col_barrier + 1`.\n  If the barrier is horizontal at row `row_barrier`:\n    The target column is `col_start`.\n    The target row is `row_barrier - 1` if `row_start < row_barrier`, otherwise `row_barrier + 1`.\nCreate the output grid as a copy of the input grid.\nSet the pixel at the 'mover' pixel's initial coordinates (row_start, col_start) in the output grid to the background color (white, 0).\nSet the pixel at the calculated target coordinates (row_end, col_end) in the output grid to the 'mover' pixel's color.\n\"\"\"\n\ndef find_colored_pixels(grid, background_color=0):\n    \"\"\"Finds coordinates of all non-background pixels, grouped by color.\"\"\"\n    color_coords = {}\n    height, width = grid.shape\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color != background_color:\n                if color not in color_coords:\n                    color_coords[color] = []\n                color_coords[color].append((r, c))\n    return color_coords\n\ndef analyze_barrier(coords):\n    \"\"\"Determines if a set of coordinates forms a horizontal or vertical line.\"\"\"\n    rows = {r for r, c in coords}\n    cols = {c for r, c in coords}\n    \n    is_horizontal = len(rows) == 1 and len(cols) > 1\n    is_vertical = len(cols) == 1 and len(rows) > 1\n    \n    orientation = None\n    coord_val = None\n    \n    if is_horizontal:\n        orientation = \"horizontal\"\n        coord_val = list(rows)[0] # The common row\n    elif is_vertical:\n        orientation = \"vertical\"\n        coord_val = list(cols)[0] # The common column\n        \n    return orientation, coord_val\n\ndef transform(input_grid):\n    \"\"\"\n    Moves a single uniquely colored pixel towards a line barrier of another color, \n    stopping one cell away from the barrier.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    background_color = 0\n    \n    # 1. & 2. Identify non-background pixels and group by color\n    color_coords = find_colored_pixels(input_grid, background_color)\n    \n    mover_color = -1\n    mover_coords = None\n    barrier_color = -1\n    barrier_coords = None\n    \n    # 3. & 4. Find mover (count=1) and potential barrier (count>1)\n    for color, coords in color_coords.items():\n        if len(coords) == 1:\n            mover_color = color\n            mover_coords = coords[0]\n        elif len(coords) > 1:\n            # Assuming only one barrier color exists besides the mover\n            barrier_color = color\n            barrier_coords = coords\n            \n    if mover_coords is None or barrier_coords is None:\n        # Handle error: Did not find a unique mover and/or a barrier candidate\n        print(\"Error: Could not identify mover pixel or barrier line.\")\n        return output_grid # Return original grid or handle error appropriately\n\n    # 4. Determine barrier orientation and coordinate\n    barrier_orientation, barrier_coord_val = analyze_barrier(barrier_coords)\n    \n    if barrier_orientation is None:\n        # Handle error: Barrier is not a simple horizontal or vertical line\n        print(\"Error: Barrier is not a horizontal or vertical line.\")\n        return output_grid\n\n    mover_row_start, mover_col_start = mover_coords\n    target_row_end, target_col_end = -1, -1\n\n    # 5. Determine target coordinates\n    if barrier_orientation == \"vertical\":\n        target_row_end = mover_row_start\n        barrier_col = barrier_coord_val\n        # Move right if mover is left, move left if mover is right\n        target_col_end = barrier_col - 1 if mover_col_start < barrier_col else barrier_col + 1\n    elif barrier_orientation == \"horizontal\":\n        target_col_end = mover_col_start\n        barrier_row = barrier_coord_val\n        # Move down if mover is above, move up if mover is below\n        target_row_end = barrier_row - 1 if mover_row_start < barrier_row else barrier_row + 1\n\n    if target_row_end == -1 or target_col_end == -1:\n         print(\"Error: Could not calculate target position.\")\n         return output_grid # Or handle more gracefully\n\n    # 6. Create output grid (already copied)\n    \n    # 7. Set mover's original position to background\n    output_grid[mover_row_start, mover_col_start] = background_color\n    \n    # 8. Set target position to mover's color\n    # Check bounds just in case, though logic should prevent out-of-bounds\n    height, width = output_grid.shape\n    if 0 <= target_row_end < height and 0 <= target_col_end < width:\n        output_grid[target_row_end, target_col_end] = mover_color\n    else:\n        print(f\"Warning: Calculated target position ({target_row_end}, {target_col_end}) is out of bounds.\")\n\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3001,
    "candidates_token_count": 1449,
    "total_token_count": 4450,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 24.675079,
  "retries": 1
}