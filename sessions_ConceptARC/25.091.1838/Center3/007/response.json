{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies all 'perfect rectangle' objects (both solid and hollow with a background interior) \nwithin the input grid. Selects one specific rectangle based on a two-stage median filtering process: \nfirst by bounding box area, then by color. Finally, crops the input grid to the bounding box \nof the selected rectangle to produce the output.\n\nSelection Logic:\n1. Find all perfect rectangle objects (solid or hollow) within the input grid, ignoring the background color (assumed 0).\n2. Calculate the bounding box area for each perfect rectangle.\n3. Determine the median area among all found perfect rectangles. Use the lower middle value if the count is even.\n4. Filter the rectangles, keeping only those whose area equals the median area.\n5. If only one rectangle remains, select it.\n6. If multiple rectangles remain (i.e., they share the median area):\n    a. Get the color index of each of these remaining rectangles.\n    b. Determine the median color index among them. Use the lower middle value if the count is even.\n    c. Select the first rectangle encountered in the filtered list that has the median color index.\n7. Crop the input grid to the bounding box of the finally selected rectangle.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of colors other than ignore_color.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples), and 'bbox'\n              (min_r, min_c, max_r, max_c). Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    # Iterate through each cell to find starting points of objects\n    for r in range(rows):\n        for c in range(cols):\n            # If cell is not visited and not the ignored color, start BFS\n            if (r, c) not in visited and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    # Update bounding box coordinates\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Ensure neighbor is within grid bounds, not visited, and matches object color\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                # Store found object properties if it has pixels\n                if obj_coords: \n                    objects.append({\n                        'color': color,\n                        'coords': obj_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef is_perfect_rectangle(obj, grid, background_color=0):\n    \"\"\"\n    Checks if an object forms a perfect solid or hollow rectangle.\n\n    Args:\n        obj (dict): The object dictionary from find_objects.\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        tuple: (bool, str or None) indicating (is_perfect, type), where type\n               is 'solid', 'hollow', or None.\n    \"\"\"\n    color = obj['color']\n    coords = obj['coords']\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # --- Solid Check ---\n    is_solid = True\n    # Quick check: number of pixels must match bounding box area\n    if len(coords) != height * width: \n        is_solid = False\n    else:\n        # Check every cell within the bounding box matches the object color\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if grid[r, c] != color:\n                    is_solid = False\n                    break\n            if not is_solid:\n                break      \n    if is_solid:\n        return (True, 'solid') # Found a solid rectangle\n\n    # --- Hollow Check (only if not solid) ---\n    # A hollow rectangle must have space for an interior (min 3x3 bbox)\n    if width <= 2 or height <= 2:\n        return (False, None) # Too small to be hollow\n\n    is_hollow = True\n    all_coords_on_border = True\n    # Check every cell within the bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_border_cell = (r == min_r or r == max_r or c == min_c or c == max_c)\n            \n            if is_border_cell:\n                # Border cells must:\n                # 1. Have the object's color\n                # 2. Be part of the object's coordinates (found by find_objects)\n                if grid[r, c] != color or (r,c) not in coords:\n                    is_hollow = False\n                    break\n            else: # Interior cells\n                # Interior cells must:\n                # 1. Have the background color\n                # 2. NOT be part of the object's coordinates\n                if grid[r, c] != background_color or (r,c) in coords:\n                    is_hollow = False\n                    break\n        if not is_hollow:\n            break # Exit outer loop if any check failed\n\n    # Final verification for hollow: ensure all pixels originally found for the object\n    # actually lie on the calculated border of the bounding box.\n    if is_hollow:\n        for r_obj, c_obj in coords:\n             if not (r_obj == min_r or r_obj == max_r or c_obj == min_c or c_obj == max_c):\n                 all_coords_on_border = False\n                 is_hollow = False # Downgrade if any object pixel is inside the border\n                 break\n                 \n    if is_hollow and all_coords_on_border:\n        return (True, 'hollow') # Found a perfect hollow rectangle\n\n    # If neither solid nor perfectly hollow criteria were met\n    return (False, None)\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area (width * height) of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height * width\n\ndef crop_grid(grid, bbox):\n    \"\"\"Extracts a subgrid defined by a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    # Slicing using NumPy array indexing\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef calculate_median_value(values):\n    \"\"\"\n    Calculates the median of a list of numbers. \n    For an even number of elements, returns the lower of the two middle elements.\n    \"\"\"\n    if not values: # Handle empty list case\n        return None\n    sorted_values = sorted(values)\n    n = len(sorted_values)\n    if n % 2 == 1:\n        # Odd number of elements: return the middle one\n        return sorted_values[n // 2]\n    else:\n        # Even number of elements: return the lower of the two middle elements (index n//2 - 1)\n        return sorted_values[n // 2 - 1]\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    # Convert input list of lists to NumPy array for efficient processing\n    grid = np.array(input_grid)\n    if grid.size == 0:\n        return [] # Handle empty input grid\n\n    # Assume background color is 0 (white)\n    background_color = 0 \n\n    # Step 1: Find all contiguous non-background objects\n    all_objects = find_objects(grid, ignore_color=background_color)\n    \n    # Step 2: Filter these objects to keep only 'perfect rectangles' (solid or hollow)\n    perfect_rectangles = []\n    for obj in all_objects:\n        is_perfect, rect_type = is_perfect_rectangle(obj, grid, background_color)\n        if is_perfect:\n            # Store rectangle type and calculate/store bounding box area\n            obj['type'] = rect_type \n            obj['area'] = get_bounding_box_area(obj['bbox']) \n            perfect_rectangles.append(obj)\n            \n    # Handle case where no perfect rectangles are found in the input\n    if not perfect_rectangles:\n        # Return an empty grid representation as per ARC format\n        return [[]] if grid.ndim > 1 else [] \n\n    # Step 3: Selection Logic - Stage 1: Filter by Median Area\n    \n    # Calculate median area using areas of all found perfect rectangles\n    areas = [rect['area'] for rect in perfect_rectangles]\n    median_area = calculate_median_value(areas) \n    \n    # Filter the list to keep only rectangles with the median area\n    median_area_rectangles = [rect for rect in perfect_rectangles if rect['area'] == median_area]\n        \n    selected_rectangle = None # Initialize variable to hold the final selection\n    \n    # Step 4: Selection Logic - Stage 2: Handle Count and Filter by Median Color\n    \n    # If exactly one rectangle has the median area, it's the selected one\n    if len(median_area_rectangles) == 1:\n         selected_rectangle = median_area_rectangles[0]\n    # If multiple rectangles share the median area, apply median color filter\n    elif len(median_area_rectangles) > 1:\n         # Get the colors of the rectangles remaining after the area filter\n         colors = [rect['color'] for rect in median_area_rectangles]\n         # Calculate the median color among them\n         median_color = calculate_median_value(colors)\n         \n         # Select the first rectangle encountered in the list that matches both median area and median color\n         for rect in median_area_rectangles:\n             if rect['color'] == median_color:\n                 selected_rectangle = rect\n                 break # Stop after finding the first match\n    \n    # Fallback mechanism: If the selection logic somehow fails to pick one\n    # (e.g., if median_area_rectangles becomes empty unexpectedly), \n    # default to the first perfect rectangle found as a safety measure.\n    # This should not happen with correct logic and typical ARC inputs.\n    if selected_rectangle is None and perfect_rectangles:\n         # This might indicate an edge case or logic error if reached\n         # print(\"Warning: Selection logic did not uniquely identify a rectangle, using first perfect rectangle found.\") # Optional debug print\n         selected_rectangle = perfect_rectangles[0]\n\n    # Step 5: Crop the input grid to the bounding box of the selected rectangle\n    if selected_rectangle:\n        output_grid_np = crop_grid(grid, selected_rectangle['bbox'])\n    else:\n        # This path should only be reachable if perfect_rectangles was empty initially\n         return [[]] if grid.ndim > 1 else []\n\n    # Convert the resulting NumPy array back to a list of lists for the final output format\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16160,
    "candidates_token_count": 2982,
    "total_token_count": 19142,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.434015,
  "retries": 1
}