{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentify all contiguous non-background objects within the input grid.\nFilter these objects to find only those that form 'perfect rectangles' (either solid rectangles or hollow rectangles with a background-colored interior).\nIf only one perfect rectangle is found, select it.\nIf multiple perfect rectangles are found:\n1. Calculate the bounding box area for each perfect rectangle.\n2. Find the median area among these rectangles.\n3. Filter the rectangles to keep only those with the median area.\n4. Get the color index of each remaining rectangle.\n5. Find the median color index among these.\n6. Select the rectangle with the median color index (if count is even, use the lower of the two middle indices).\nFinally, crop the input grid to the bounding box of the selected perfect rectangle to produce the output grid.\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of colors other than ignore_color.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples), and 'bbox'\n              (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                objects.append({\n                    'color': color,\n                    'coords': obj_coords,\n                    'bbox': (min_r, min_c, max_r, max_c)\n                })\n    return objects\n\ndef is_perfect_rectangle(obj, grid, background_color=0):\n    \"\"\"\n    Checks if an object forms a perfect solid or hollow rectangle.\n\n    Args:\n        obj (dict): The object dictionary from find_objects.\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        bool: True if it's a perfect rectangle, False otherwise.\n    \"\"\"\n    color = obj['color']\n    coords = obj['coords']\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    is_solid = True\n    is_hollow = True\n\n    # Check all cells within the bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            # Solid check\n            if grid[r, c] != color:\n                is_solid = False\n            \n            # Hollow check\n            is_border = (r == min_r or r == max_r or c == min_c or c == max_c)\n            if is_border:\n                if (r, c) not in coords or grid[r, c] != color:\n                    is_hollow = False\n            else: # Interior\n                if grid[r, c] != background_color:\n                     is_hollow = False\n                     \n    # A hollow rectangle must have an interior (width/height > 2)\n    if width <= 2 or height <= 2:\n        is_hollow = False\n        \n    # An object made of only the pixels in coords could be hollow *only if*\n    # the number of pixels matches the perimeter calculation.\n    # Perimeter = 2 * (width + height) - 4 (for corners counted once)\n    # But this doesn't account for thickness > 1.\n    # Let's rely on the pixel checks within the bounding box.\n    \n    # Ensure all coords are within the bbox (should be by definition)\n    # And ensure the checks covered all object pixels.\n    \n    # Must match either solid or hollow criteria\n    return is_solid or is_hollow\n\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height * width\n\ndef crop_grid(grid, bbox):\n    \"\"\"Extracts a subgrid defined by a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef calculate_median_index(values):\n    \"\"\"Calculates the median value, returns lower middle for even counts.\"\"\"\n    sorted_values = sorted(values)\n    n = len(sorted_values)\n    if n == 0:\n        return None\n    if n % 2 == 1:\n        return sorted_values[n // 2]\n    else:\n        # For even count, choose the lower of the two middle elements\n        return sorted_values[n // 2 - 1]\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying and selecting a specific\n    perfect rectangle object.\n    \"\"\"\n    grid = np.array(input_grid)\n    background_color = 0 # Assuming background is 0\n\n    # 1. Find all non-background objects\n    all_objects = find_objects(grid, ignore_color=background_color)\n    \n    # 2. Filter for perfect rectangles\n    perfect_rectangles = []\n    for obj in all_objects:\n        if is_perfect_rectangle(obj, grid, background_color):\n            perfect_rectangles.append(obj)\n            \n    # Handle case where no perfect rectangles are found\n    if not perfect_rectangles:\n        # Default or error behavior - returning empty for now\n        # Based on examples, this shouldn't happen for valid inputs.\n        return np.array([[]]) \n\n    selected_rectangle = None\n\n    # 3. Select the target rectangle\n    if len(perfect_rectangles) == 1:\n        # If only one, select it\n        selected_rectangle = perfect_rectangles[0]\n    else:\n        # If multiple, apply median logic\n        \n        # a. Calculate areas\n        for rect in perfect_rectangles:\n            rect['area'] = get_bounding_box_area(rect['bbox'])\n        \n        # b. Find median area\n        areas = [rect['area'] for rect in perfect_rectangles]\n        median_area = calculate_median_index(areas) \n        \n        # c. Filter by median area\n        median_area_rectangles = [rect for rect in perfect_rectangles if rect['area'] == median_area]\n        \n        # If filtering by area narrows it down to one, select it\n        if len(median_area_rectangles) == 1:\n             selected_rectangle = median_area_rectangles[0]\n        else:\n             # d. Get colors of remaining rectangles\n             colors = [rect['color'] for rect in median_area_rectangles]\n             \n             # e. Find median color index\n             median_color = calculate_median_index(colors)\n             \n             # f. Select the rectangle with the median color\n             # If multiple rectangles have the median color and median area, \n             # the problem description doesn't specify tie-breaking.\n             # We'll pick the first one found.\n             for rect in median_area_rectangles:\n                 if rect['color'] == median_color:\n                     selected_rectangle = rect\n                     break \n\n    # 4. Crop the grid to the selected rectangle's bounding box\n    if selected_rectangle:\n        output_grid = crop_grid(grid, selected_rectangle['bbox'])\n    else:\n        # Should not happen if logic is correct and input matches pattern\n        output_grid = np.array([[]]) \n\n    return output_grid.tolist() # Return as list of lists\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3753,
    "candidates_token_count": 2169,
    "total_token_count": 5922,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.431028,
  "retries": 1
}