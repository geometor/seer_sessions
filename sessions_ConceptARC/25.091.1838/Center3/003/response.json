{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nTransforms an input grid by identifying all 'perfect rectangle' objects (both solid and hollow), \nthen selecting one based on specific criteria, and finally cropping the grid to the bounding box \nof the selected rectangle.\n\nSelection Logic:\n1. Find all perfect rectangles (solid or hollow).\n2. If exactly one hollow perfect rectangle exists, select it.\n3. Otherwise (zero or multiple hollow rectangles):\n    a. Calculate the bounding box area of all perfect rectangles.\n    b. Find the median area.\n    c. Filter for rectangles with the median area.\n    d. If only one remains, select it.\n    e. If multiple remain, find the median color among them.\n    f. Select the rectangle with the median color (using the lower index for ties).\n\"\"\"\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of colors other than ignore_color.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples), and 'bbox'\n              (min_r, min_c, max_r, max_c). Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords: # Only add if pixels were found\n                    objects.append({\n                        'color': color,\n                        'coords': obj_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef is_perfect_rectangle_refined(obj, grid, background_color=0):\n    \"\"\"\n    Checks if an object forms a perfect solid or hollow rectangle.\n\n    Args:\n        obj (dict): The object dictionary from find_objects.\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        tuple: (bool, str or None) indicating (is_perfect, type), where type\n               is 'solid', 'hollow', or None.\n    \"\"\"\n    color = obj['color']\n    coords = obj['coords']\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # --- Solid Check ---\n    is_solid = True\n    if len(coords) != height * width: # Quick check: pixel count must match area\n        is_solid = False\n    else:\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if grid[r, c] != color:\n                    is_solid = False\n                    break\n            if not is_solid:\n                break\n                \n    if is_solid:\n        return (True, 'solid')\n\n    # --- Hollow Check (only if not solid) ---\n    # Basic requirement: must have space for an interior\n    if width <= 2 or height <= 2:\n        return (False, None)\n\n    is_hollow = True\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_border = (r == min_r or r == max_r or c == min_c or c == max_c)\n            \n            if is_border:\n                # Border pixels must have the object's color\n                if grid[r, c] != color:\n                    is_hollow = False\n                    break\n                # Border pixels must be part of the found object's coordinates\n                # This helps distinguish from adjacent noise.\n                if (r,c) not in coords:\n                     is_hollow = False\n                     break\n            else: # Interior pixels\n                # Interior pixels must have the background color\n                if grid[r, c] != background_color:\n                    is_hollow = False\n                    break\n                # Interior pixels must NOT be part of the found object's coordinates\n                # (Reinforces the background color check)\n                if (r,c) in coords:\n                    is_hollow = False\n                    break\n        if not is_hollow:\n            break # Break outer loop if inner check failed\n\n    if is_hollow:\n        # Final check: ensure all original coords were on the border\n        all_coords_on_border = True\n        for r_obj, c_obj in coords:\n             if not (r_obj == min_r or r_obj == max_r or c_obj == min_c or c_obj == max_c):\n                 all_coords_on_border = False\n                 break\n        if all_coords_on_border:\n             return (True, 'hollow')\n        else:\n             # If some object pixels were found inside, it's not a perfect hollow rect\n             return (False, None)\n\n\n    # If neither solid nor hollow criteria met\n    return (False, None)\n\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height * width\n\ndef crop_grid(grid, bbox):\n    \"\"\"Extracts a subgrid defined by a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef calculate_median_value(values):\n    \"\"\"Calculates the median value, returns lower middle for even counts.\"\"\"\n    if not values: # Handle empty list\n        return None\n    sorted_values = sorted(values)\n    n = len(sorted_values)\n    if n % 2 == 1:\n        # Odd number of elements: return the middle one\n        return sorted_values[n // 2]\n    else:\n        # Even number of elements: return the lower of the two middle elements\n        return sorted_values[n // 2 - 1]\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on identifying and selecting a specific\n    perfect rectangle object using the refined logic.\n    \"\"\"\n    grid = np.array(input_grid)\n    if grid.size == 0:\n        return [] # Handle empty input\n        \n    background_color = 0 # Assume background is 0\n\n    # 1. Find all non-background objects\n    all_objects = find_objects(grid, ignore_color=background_color)\n    \n    # 2. Filter for perfect rectangles and classify them\n    perfect_rectangles = []\n    hollow_rectangles = []\n    for obj in all_objects:\n        is_perfect, rect_type = is_perfect_rectangle_refined(obj, grid, background_color)\n        if is_perfect:\n            obj['type'] = rect_type\n            obj['area'] = get_bounding_box_area(obj['bbox'])\n            perfect_rectangles.append(obj)\n            if rect_type == 'hollow':\n                hollow_rectangles.append(obj)\n            \n    # Handle case where no perfect rectangles are found\n    if not perfect_rectangles:\n        # Based on examples, this shouldn't happen for valid inputs.\n        # Return empty list of lists as per ARC format for empty grid.\n        return [[]] if grid.ndim > 1 else [] \n\n    selected_rectangle = None\n\n    # 3. Selection Logic\n    # Rule 1: Prioritize unique hollow rectangle\n    if len(hollow_rectangles) == 1:\n        selected_rectangle = hollow_rectangles[0]\n    else:\n        # Rule 2: Apply median logic (area, then color) to *all* perfect rectangles\n        \n        # a. Calculate median area using all perfect rectangles\n        areas = [rect['area'] for rect in perfect_rectangles]\n        median_area = calculate_median_value(areas) \n        \n        # b. Filter by median area\n        median_area_rectangles = [rect for rect in perfect_rectangles if rect['area'] == median_area]\n        \n        # c. If only one matches median area, select it\n        if len(median_area_rectangles) == 1:\n             selected_rectangle = median_area_rectangles[0]\n        elif len(median_area_rectangles) > 1:\n             # d. Multiple match median area: Find median color among them\n             colors = [rect['color'] for rect in median_area_rectangles]\n             median_color = calculate_median_value(colors)\n             \n             # e. Select the first rectangle matching median area AND median color\n             for rect in median_area_rectangles:\n                 if rect['color'] == median_color:\n                     selected_rectangle = rect\n                     break \n        # If median_area_rectangles is empty somehow (shouldn't happen if median calculated correctly)\n        # or if no rectangle matches the median color (also shouldn't happen), \n        # selected_rectangle remains None initially. If perfect_rectangles was not empty,\n        # this implies an issue, but let's select the first perfect rectangle as a fallback.\n        if selected_rectangle is None and perfect_rectangles:\n             selected_rectangle = perfect_rectangles[0]\n\n\n    # 4. Crop the grid to the selected rectangle's bounding box\n    if selected_rectangle:\n        output_grid = crop_grid(grid, selected_rectangle['bbox'])\n    else:\n        # Fallback if no rectangle could be selected (e.g., only non-rect objects found)\n         return [[]] if grid.ndim > 1 else []\n\n    return output_grid.tolist() # Return as list of lists\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14550,
    "candidates_token_count": 2676,
    "total_token_count": 17226,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.971686,
  "retries": 1
}