{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport math\n\n\"\"\"\nIdentifies all 'perfect rectangle' objects (both solid and hollow with a background interior) \nwithin the input grid. Selects one specific rectangle based on a two-stage median filtering process: \nfirst by bounding box area, then by color. Finally, crops the input grid to the bounding box \nof the selected rectangle to produce the output.\n\nSelection Logic:\n1. Find all perfect rectangle objects (solid or hollow) within the input grid, ignoring the background color (assumed 0).\n2. Calculate the bounding box area for each perfect rectangle.\n3. Determine the median area among all found perfect rectangles. Use the lower middle value if the count is even.\n4. Filter the rectangles, keeping only those whose area equals the median area.\n5. If only one rectangle remains, select it.\n6. If multiple rectangles remain (i.e., they share the median area):\n    a. Get the color index of each of these remaining rectangles.\n    b. Determine the median color index among them. Use the lower middle value if the count is even.\n    c. Select the first rectangle encountered in the filtered list that has the median color index.\n7. Crop the input grid to the bounding box of the finally selected rectangle.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\"\n    Finds contiguous objects of colors other than ignore_color.\n\n    Args:\n        grid (np.array): The input grid.\n        ignore_color (int): The color to ignore (usually background).\n\n    Returns:\n        list: A list of dictionaries, each representing an object with\n              'color', 'coords' (set of (r, c) tuples), and 'bbox'\n              (min_r, min_c, max_r, max_c). Returns empty list if grid is empty.\n    \"\"\"\n    if grid.size == 0:\n        return []\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != ignore_color:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_coords: # Only add if pixels were found\n                    objects.append({\n                        'color': color,\n                        'coords': obj_coords,\n                        'bbox': (min_r, min_c, max_r, max_c)\n                    })\n    return objects\n\ndef is_perfect_rectangle(obj, grid, background_color=0):\n    \"\"\"\n    Checks if an object forms a perfect solid or hollow rectangle.\n\n    Args:\n        obj (dict): The object dictionary from find_objects.\n        grid (np.array): The input grid.\n        background_color (int): The background color.\n\n    Returns:\n        tuple: (bool, str or None) indicating (is_perfect, type), where type\n               is 'solid', 'hollow', or None.\n    \"\"\"\n    color = obj['color']\n    coords = obj['coords']\n    min_r, min_c, max_r, max_c = obj['bbox']\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # --- Solid Check ---\n    is_solid = True\n    if len(coords) != height * width: # Quick check: pixel count must match area\n        is_solid = False\n    else:\n        # Check every cell in bounding box matches object color\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                if grid[r, c] != color:\n                    is_solid = False\n                    break\n            if not is_solid:\n                break      \n    if is_solid:\n        return (True, 'solid')\n\n    # --- Hollow Check (only if not solid) ---\n    # Must have space for an interior (at least 3x3 bounding box)\n    if width <= 2 or height <= 2:\n        return (False, None)\n\n    is_hollow = True\n    all_coords_on_border = True\n    # Check every cell in bounding box\n    for r in range(min_r, max_r + 1):\n        for c in range(min_c, max_c + 1):\n            is_border_cell = (r == min_r or r == max_r or c == min_c or c == max_c)\n            \n            if is_border_cell:\n                # Border cells must have object's color and be part of the object's coords\n                if grid[r, c] != color or (r,c) not in coords:\n                    is_hollow = False\n                    break\n            else: # Interior cells\n                # Interior cells must have background color and NOT be part of object's coords\n                if grid[r, c] != background_color or (r,c) in coords:\n                    is_hollow = False\n                    break\n        if not is_hollow:\n            break # Break outer loop if inner check failed\n\n    # Final check: ensure all object pixels were actually on the border\n    if is_hollow:\n        for r_obj, c_obj in coords:\n             if not (r_obj == min_r or r_obj == max_r or c_obj == min_c or c_obj == max_c):\n                 all_coords_on_border = False\n                 is_hollow = False # Mark as not hollow if pixels found inside\n                 break\n                 \n    if is_hollow and all_coords_on_border:\n        return (True, 'hollow')\n\n    # If neither solid nor perfectly hollow criteria met\n    return (False, None)\n\ndef get_bounding_box_area(bbox):\n    \"\"\"Calculates the area of a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    return height * width\n\ndef crop_grid(grid, bbox):\n    \"\"\"Extracts a subgrid defined by a bounding box.\"\"\"\n    min_r, min_c, max_r, max_c = bbox\n    return grid[min_r:max_r+1, min_c:max_c+1]\n\ndef calculate_median_value(values):\n    \"\"\"Calculates the median value, returns lower middle for even counts.\"\"\"\n    if not values: # Handle empty list\n        return None\n    sorted_values = sorted(values)\n    n = len(sorted_values)\n    if n % 2 == 1:\n        # Odd number of elements: return the middle one\n        return sorted_values[n // 2]\n    else:\n        # Even number of elements: return the lower of the two middle elements\n        return sorted_values[n // 2 - 1]\n\n# === Main Transformation Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    grid = np.array(input_grid)\n    if grid.size == 0:\n        return [] # Handle empty input grid\n\n    background_color = 0 # Assume background is white (0)\n\n    # Step 1: Find all non-background objects\n    all_objects = find_objects(grid, ignore_color=background_color)\n    \n    # Step 2: Filter for perfect rectangles (solid or hollow)\n    perfect_rectangles = []\n    for obj in all_objects:\n        is_perfect, rect_type = is_perfect_rectangle(obj, grid, background_color)\n        if is_perfect:\n            obj['type'] = rect_type # Store type ('solid' or 'hollow')\n            obj['area'] = get_bounding_box_area(obj['bbox']) # Calculate and store area\n            perfect_rectangles.append(obj)\n            \n    # Handle case: no perfect rectangles found\n    if not perfect_rectangles:\n        # Return empty list of lists as per ARC format for empty grid output\n        # This case might indicate an issue or an unexpected input type.\n        return [[]] if grid.ndim > 1 else [] \n\n    # Step 3: Selection Logic - Stage 1: Median Area Filter\n    \n    # Calculate median area from all perfect rectangles\n    areas = [rect['area'] for rect in perfect_rectangles]\n    median_area = calculate_median_value(areas) \n    \n    # Filter by median area\n    median_area_rectangles = [rect for rect in perfect_rectangles if rect['area'] == median_area]\n        \n    selected_rectangle = None\n    \n    # Step 4: Selection Logic - Stage 2: Check Count & Median Color Filter\n    \n    # If only one rectangle has the median area, select it\n    if len(median_area_rectangles) == 1:\n         selected_rectangle = median_area_rectangles[0]\n    elif len(median_area_rectangles) > 1:\n         # Multiple rectangles share the median area, filter by median color\n         colors = [rect['color'] for rect in median_area_rectangles]\n         median_color = calculate_median_value(colors)\n         \n         # Select the first rectangle encountered that matches median area AND median color\n         for rect in median_area_rectangles:\n             if rect['color'] == median_color:\n                 selected_rectangle = rect\n                 break # Stop after finding the first match\n    \n    # Fallback: If selection logic fails (shouldn't happen with valid inputs/logic),\n    # or if median_area_rectangles was empty (error condition), select the first found perfect rectangle.\n    if selected_rectangle is None and perfect_rectangles:\n         print(\"Warning: Selection logic did not uniquely identify a rectangle, using first perfect rectangle found.\")\n         selected_rectangle = perfect_rectangles[0]\n\n    # Step 5: Crop the grid to the selected rectangle's bounding box\n    if selected_rectangle:\n        output_grid = crop_grid(grid, selected_rectangle['bbox'])\n    else:\n        # Should only happen if perfect_rectangles was empty initially\n         return [[]] if grid.ndim > 1 else []\n\n    # Convert NumPy array back to list of lists for the final output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13454,
    "candidates_token_count": 2676,
    "total_token_count": 16130,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.47051,
  "retries": 1
}