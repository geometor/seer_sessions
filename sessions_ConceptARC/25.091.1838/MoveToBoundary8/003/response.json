{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on identifying a large 'wall' object and smaller 'mover' objects, applying specific movement rules based on the wall's orientation and the movers' arrangement.\n\n1.  Find all connected components (objects) of non-background colors.\n2.  Identify the largest component as the 'Wall' and others as 'Movers'.\n3.  Place the Wall in the output grid at its original position.\n4.  Determine the Wall's orientation (Vertical: width=1, Horizontal: height=1).\n5.  Determine if all Movers are co-linear (occupy the same single row).\n6.  Apply movement rules:\n    *   **Vertical Wall & Co-linear Movers**: Movers shift horizontally as a group. The rightmost mover pixel aligns with the column left of the wall (`Wall_Cmin - 1`).\n    *   **Horizontal Wall**: Movers shift horizontally individually and stack vertically below the wall. The horizontal shift amount is constant for all movers (`Wall_Center_Col - Wall_Cmin`). Vertical stacking starts one row below the wall (`Wall_Rmax + 1`) with a one-row gap between movers. Movers maintain their original top-to-bottom order.\n    *   **Other Cases (e.g., Vertical Wall & Scattered Movers, Non-linear Wall)**: Movers remain in their original positions (based on lack of examples defining behavior).\n7.  Return the transformed grid.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"\n    Finds all connected components of non-background pixels using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents a component\n              and contains 'pixels' (list of (r, c) tuples), 'color' (int),\n              'size' (int), 'bounds' (tuple: min_r, max_r, min_c, max_c),\n              and 'height' (int). Returns an empty list if no components found.\n              The list is sorted by component size in descending order.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component_pixels = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                while q:\n                    row, col = q.popleft()\n                    component_pixels.append((row, col)) # Store pixel coordinates\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                height = max_r - min_r + 1\n                components.append({\n                    'pixels': component_pixels, \n                    'color': color, \n                    'size': len(component_pixels),\n                    'bounds': (min_r, max_r, min_c, max_c),\n                    'height': height\n                })\n    \n    # Sort by size descending to easily find the wall\n    components.sort(key=lambda x: x['size'], reverse=True)\n    return components\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n    \n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all connected components\n    components = find_connected_components(input_grid)\n\n    # Handle edge case: no objects found\n    if not components:\n        return output_grid.tolist() \n\n    # 2. Identify Wall and Movers\n    wall = components[0]\n    movers = components[1:]\n\n    # 3. Place Wall in the output grid\n    wall_color = wall['color']\n    for r, c in wall['pixels']:\n        output_grid[r, c] = wall_color\n\n    # Handle edge case: no movers found\n    if not movers:\n        return output_grid.tolist() \n\n    # 4. Calculate Wall Properties\n    wall_min_r, wall_max_r, wall_min_c, wall_max_c = wall['bounds']\n    wall_height = wall_max_r - wall_min_r + 1\n    wall_width = wall_max_c - wall_min_c + 1\n    is_vertical_wall = wall_width == 1\n    is_horizontal_wall = wall_height == 1\n\n    # 5. Determine if all Movers are co-linear on a single row\n    all_movers_colinear = False\n    if movers:\n        first_mover_min_r = movers[0]['bounds'][0]\n        first_mover_max_r = movers[0]['bounds'][1]\n        if first_mover_min_r == first_mover_max_r: # First mover is single row\n             all_movers_colinear = True\n             shared_row = first_mover_min_r\n             for mover in movers[1:]:\n                 mover_min_r, mover_max_r, _, _ = mover['bounds']\n                 # Check if subsequent movers are also single row and on the same shared row\n                 if mover_min_r != mover_max_r or mover_min_r != shared_row:\n                     all_movers_colinear = False\n                     break\n        else: # First mover spans multiple rows\n             all_movers_colinear = False\n\n\n    # 6. Apply Movement Strategy\n    if is_vertical_wall and all_movers_colinear:\n        # Strategy 1: Vertical Wall & Co-linear Movers\n        c_target = wall_min_c - 1\n        \n        max_mover_col = -1\n        all_mover_pixels = [] # Collect all pixels from all movers\n        for mover in movers:\n            all_mover_pixels.extend([(r, c, mover['color']) for r,c in mover['pixels']])\n            for _, c in mover['pixels']:\n                 max_mover_col = max(max_mover_col, c)\n        \n        if max_mover_col != -1 and c_target >= 0: # Ensure target is valid\n             shift = c_target - max_mover_col\n             for r, c, color in all_mover_pixels:\n                 new_c = c + shift\n                 # Place pixel if within bounds\n                 if 0 <= r < rows and 0 <= new_c < cols:\n                     # Check if overwriting the wall - avoid if necessary\n                     # (Current rules don't specify, assume movers can't overlap wall)\n                     if output_grid[r, new_c] == 0: \n                          output_grid[r, new_c] = color\n\n    elif is_horizontal_wall:\n        # Strategy 2: Horizontal Wall (handles both co-linear and scattered movers)\n        c_center = (wall_min_c + wall_max_c) // 2\n        shift = c_center - wall_min_c\n        \n        # Sort movers by their top row index (min_r)\n        movers.sort(key=lambda x: x['bounds'][0]) \n\n        current_row = wall_max_r + 1 # Start placing one row below the wall\n\n        for mover in movers:\n            mover_min_r, _, mover_min_c, _ = mover['bounds']\n            mover_height = mover['height']\n            mover_color = mover['color']\n            \n            # Calculate shift needed to move the mover's top-left corner\n            new_top_row = current_row\n            new_top_col = mover_min_c + shift \n            \n            # Calculate displacement for each pixel relative to top-left\n            dr = new_top_row - mover_min_r\n            dc = new_top_col - mover_min_c\n\n            # Apply shift to all pixels of the current mover\n            for r, c in mover['pixels']:\n                 new_r, new_c = r + dr, c + dc\n                 # Place pixel if within bounds\n                 if 0 <= new_r < rows and 0 <= new_c < cols:\n                     # Check if overwriting the wall or other placed movers\n                     if output_grid[new_r, new_c] == 0: \n                         output_grid[new_r, new_c] = mover_color\n            \n            # Update current_row for the next mover\n            current_row += mover_height + 1 # Add mover height + 1 row gap\n\n    else:\n        # Default Strategy: Other Cases (e.g., Vertical wall + scattered movers)\n        # Movers remain in their original positions as behavior isn't defined by examples.\n        for mover in movers:\n            color = mover['color']\n            for r, c in mover['pixels']:\n                 # Ensure not overwriting the wall\n                 if output_grid[r, c] == 0:\n                    output_grid[r, c] = color\n\n    # 7. Return the transformed grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18399,
    "candidates_token_count": 2338,
    "total_token_count": 20737,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.075994,
  "retries": 1
}