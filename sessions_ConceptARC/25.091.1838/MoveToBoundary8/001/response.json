{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis program transforms an input grid based on identifying a large 'wall' object and smaller 'mover' objects.\n\n1.  **Identify Objects**: Find all connected components of non-background (non-zero) pixels in the input grid.\n2.  **Distinguish Wall and Movers**: The component with the most pixels is designated the 'Wall'. All other components are 'Movers'.\n3.  **Determine Target Column**: Calculate a target column (`C_target`) based on the Wall's shape:\n    *   If the Wall is a vertical line (width 1), `C_target` is the column to the left of the Wall (`Wall_column - 1`).\n    *   If the Wall is a horizontal line (height 1), `C_target` is the horizontal center column of the Wall (`floor((Wall_min_col + Wall_max_col) / 2)`).\n4.  **Analyze Mover Positions**: Check if all Mover components are initially located on the same row.\n5.  **Apply Movement Strategy**:\n    *   **Co-linear Movers (Same Row)**: Find the rightmost column occupied by any Mover pixel on their shared row. Calculate a horizontal shift to move this rightmost pixel to the `C_target` column. Apply this shift to all Mover pixels.\n    *   **Scattered Movers (Different Rows)**: Sort the Movers based on their topmost row index (ascending). Place them vertically stacked in the `C_target` column, starting one row below the Wall's bottom edge. Maintain the original top-to-bottom order and leave one empty row between consecutive Movers.\n6.  **Construct Output**: Create an output grid initialized with the background color. Place the Wall at its original position and the Movers at their calculated new positions.\n\"\"\"\n\ndef find_connected_components(grid):\n    \"\"\"Finds all connected components of non-background pixels.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros((rows, cols), dtype=bool)\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                component = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, max_r, min_c, max_c = r, r, c, c\n\n                while q:\n                    row, col = q.popleft()\n                    component.append((row, col, color))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                components.append({\n                    'pixels': component, \n                    'color': color, \n                    'size': len(component),\n                    'bounds': (min_r, max_r, min_c, max_c)\n                })\n    return components\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid according to the rules derived from examples.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n    \n    # Initialize output grid with background color (0)\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all connected components\n    components = find_connected_components(input_grid)\n\n    if not components:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # 2. Identify Wall and Movers\n    components.sort(key=lambda x: x['size'], reverse=True)\n    wall = components[0]\n    movers = components[1:]\n\n    # 3. Place Wall in the output grid\n    for r, c, color in wall['pixels']:\n        output_grid[r, c] = color\n\n    if not movers:\n        return output_grid.tolist() # Return grid with only wall if no movers\n\n    # 4. Calculate Wall Properties and Target Column\n    wall_min_r, wall_max_r, wall_min_c, wall_max_c = wall['bounds']\n    wall_height = wall_max_r - wall_min_r + 1\n    wall_width = wall_max_c - wall_min_c + 1\n    \n    c_target = -1 # Initialize target column\n    if wall_width == 1: # Vertical wall\n        c_target = wall_min_c - 1\n    elif wall_height == 1: # Horizontal wall\n        c_target = (wall_min_c + wall_max_c) // 2 # Floor division for center\n    else:\n        # Fallback or error case if wall is not a line?\n        # Based on examples, assume it's always a line.\n        # If not a line, maybe use centroid or another rule?\n        # For now, let's stick to the observed patterns.\n        # If neither vertical nor horizontal, maybe default to one rule?\n        # Let's default to horizontal rule if ambiguous based on examples seen.\n         c_target = (wall_min_c + wall_max_c) // 2\n\n\n    # Ensure target column is valid\n    if c_target < 0:\n        # Handle cases where target might be off-grid left? \n        # Or is this expected? Example 1 target is valid.\n        pass # Assume valid for now based on examples.\n\n    # 5. Check if all Movers are on the same row\n    first_mover_row = movers[0]['bounds'][0] # min_r of the first mover\n    all_same_row = True\n    shared_row = -1\n    if movers:\n       shared_row = movers[0]['bounds'][0] # Get min_r of first mover\n       for mover in movers:\n           # Check if all pixels of the mover are on the same row and if that row is 'shared_row'\n           mover_min_r, mover_max_r, _, _ = mover['bounds']\n           if mover_min_r != shared_row or mover_max_r != shared_row:\n               all_same_row = False\n               break\n    else:\n        all_same_row = False # No movers means not \"all on the same row\"\n\n    # 6. Apply Movement Strategy\n    if all_same_row:\n        # Strategy 1: Co-linear Movers\n        max_mover_col = -1\n        all_mover_pixels = []\n        for mover in movers:\n            all_mover_pixels.extend(mover['pixels'])\n            for _, c, _ in mover['pixels']:\n                 max_mover_col = max(max_mover_col, c)\n        \n        if max_mover_col != -1 and c_target != -1 :\n             shift = c_target - max_mover_col\n             for r, c, color in all_mover_pixels:\n                 new_c = c + shift\n                 # Place pixel if within bounds\n                 if 0 <= r < rows and 0 <= new_c < cols:\n                     output_grid[r, new_c] = color\n\n    else:\n        # Strategy 2: Scattered Movers\n        # Sort movers by their top row index (min_r)\n        movers.sort(key=lambda x: x['bounds'][0]) \n\n        current_row = wall_max_r + 1 # Start placing one row below the wall\n\n        for mover in movers:\n            mover_min_r, _, mover_min_c, _ = mover['bounds']\n            color = mover['color']\n            \n            # Calculate shift needed to move the mover's top-left corner \n            # (defined by min_r, min_c) to (current_row, c_target)\n            dr = current_row - mover_min_r\n            dc = c_target - mover_min_c\n\n            # Apply shift to all pixels of the current mover\n            for r, c, _ in mover['pixels']:\n                 new_r, new_c = r + dr, c + dc\n                 # Place pixel if within bounds\n                 if 0 <= new_r < rows and 0 <= new_c < cols:\n                     output_grid[new_r, new_c] = color\n            \n            # Update current_row for the next mover, adding 1 for the mover height \n            # (assuming 1px height based on example 2) + 1 for spacing = +2\n            # If movers can have >1 height, need to use actual mover height.\n            mover_height = mover['bounds'][1] - mover['bounds'][0] + 1\n            current_row += mover_height + 1 # Add mover height + 1 row gap\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4225,
    "candidates_token_count": 2176,
    "total_token_count": 6401,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 30.409775,
  "retries": 1
}