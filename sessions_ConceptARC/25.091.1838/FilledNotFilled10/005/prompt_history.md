
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 3 4 0 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```

*   **Perception of Task Elements:**
    The task involves grids containing primarily white (0), green (3), and yellow (4) pixels. Green pixels often form boundaries or shapes that enclose areas within the grid. Some enclosed areas contain only white pixels, while others contain a mix of white and yellow pixels, often in a checkerboard pattern. The transformation specifically targets white pixels based on their relationship with the enclosing green pixels.

*   **Facts:**
    
```yaml
    Objects:
      - Type: Boundary
        Color: green (3)
        Role: Encloses other pixels. Forms contiguous shapes or frames.
      - Type: Region
        Color: white (0)
        Role: Potential target for transformation. Exists both inside and outside green boundaries.
      - Type: Pixel
        Color: yellow (4)
        Role: Exists initially within some green boundaries, or is the result color for transformed white pixels.

    Properties:
      - Enclosure: A region is considered enclosed if it is completely surrounded by green (3) pixels, meaning any path from a pixel in the region to the grid edge must cross a green pixel.
      - Content: Enclosed regions can contain only white (0) pixels or a mix of white (0) and yellow (4) pixels.

    Actions:
      - Identify: Locate contiguous regions of white (0) pixels.
      - Check Enclosure: Determine if a white region is fully enclosed by green (3) pixels.
      - Check Content: Verify if an enclosed region contains *only* white (0) pixels.
      - Fill/Recolor: Change the color of pixels within a specific region.

    Relationships:
      - Spatial: Green pixels surround or bound white/yellow regions.
      - Conditional Transformation: The transformation (white -> yellow) only applies to white pixels if they belong to a region that is 1) entirely composed of white pixels and 2) fully enclosed by green pixels.
    ```


*   **Natural Language Program:**
    1.  Identify all contiguous regions composed exclusively of white (0) pixels.
    2.  For each identified white region, determine if it is completely enclosed by green (3) pixels. (A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
    3.  If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
    4.  Leave all other pixels (green pixels, yellow pixels, and white pixels not part of a region fully enclosed by green) unchanged.
    5.  The output grid is the result of applying this conditional color change to the input grid.
```python
import numpy as np
from collections import deque

"""
Identify all contiguous regions composed exclusively of white (0) pixels.
For each identified white region, determine if it is completely enclosed by green (3) pixels. 
(A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
Leave all other pixels unchanged.
"""

def transform(input_grid):
    """
    Fills white (0) regions enclosed by green (3) pixels with yellow (4).

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # Visited array to keep track of pixels reachable from the border
    visited = np.zeros_like(grid, dtype=bool)
    
    # Queue for Breadth-First Search (BFS)
    q = deque()

    # Initialize BFS with all white pixels on the border
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
    for c in range(cols):
        for r in [0, rows - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True

    # Perform BFS to find all white pixels reachable from the border
    while q:
        r, c = q.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # If the neighbor is white and not visited, add it to the queue
                if grid[nr, nc] == 0 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid
    for r in range(rows):
        for c in range(cols):
            # If a pixel is white (0) and was not reached by the BFS (i.e., not visited)
            # it means it's part of an enclosed white region.
            if grid[r, c] == 0 and not visited[r, c]:
                # Change the color of this pixel to yellow (4) in the output grid
                output_grid[r, c] = 4

    # Convert back to list of lists before returning
    return output_grid.tolist()
```
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions enclosed by green (3) pixels. 
If an enclosed region consists *entirely* of white (0) pixels in the input grid, 
all pixels within that region are changed to yellow (4) in the output grid. 
If an enclosed region contains any non-white pixels (e.g., yellow 4), 
the entire region remains unchanged. 
Pixels outside enclosed regions (green pixels and pixels reachable from the border) 
also remain unchanged.
"""

def find_reachable_non_green(grid):
    """
    Performs a BFS starting from the border to find all non-green pixels 
    reachable without crossing green pixels.

    Args:
        grid (np.array): The input grid.

    Returns:
        np.array: A boolean array where True indicates a reachable non-green pixel.
    """
    rows, cols = grid.shape
    reachable = np.zeros_like(grid, dtype=bool)
    q = deque()

    # Add border non-green pixels to the queue
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True
    for c in range(1, cols - 1): # Avoid corners twice
        for r in [0, rows - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True

    # BFS
    while q:
        r, c = q.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr, nc] != 3 and not reachable[nr, nc]:
                    reachable[nr, nc] = True
                    q.append((nr, nc))
    return reachable

def find_enclosed_regions(grid, reachable):
    """
    Finds connected components of non-green pixels that were not reachable 
    from the border (i.e., enclosed regions).

    Args:
        grid (np.array): The input grid.
        reachable (np.array): Boolean array indicating reachable non-green pixels.

    Returns:
        list of lists of tuples: A list where each inner list contains the 
                                 (row, col) coordinates of pixels in one 
                                 enclosed region.
    """
    rows, cols = grid.shape
    visited_enclosed = np.zeros_like(grid, dtype=bool)
    enclosed_regions = []

    for r in range(rows):
        for c in range(cols):
            # Start BFS if we find an unvisited, non-green, non-reachable pixel
            if grid[r, c] != 3 and not reachable[r, c] and not visited_enclosed[r, c]:
                current_region = []
                q = deque([(r, c)])
                visited_enclosed[r, c] = True
                
                while q:
                    cr, cc = q.popleft()
                    current_region.append((cr, cc))
                    
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols:
                             # Add neighbor if it's part of the enclosed area 
                             # (non-green, not reachable, not yet visited for this region search)
                            if grid[nr, nc] != 3 and not reachable[nr, nc] and not visited_enclosed[nr, nc]:
                                visited_enclosed[nr, nc] = True
                                q.append((nr, nc))
                                
                if current_region:
                    enclosed_regions.append(current_region)
                    
    return enclosed_regions

def transform(input_grid):
    """
    Applies the transformation rule: Fills purely white enclosed regions with yellow.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # 1. Find all non-green pixels reachable from the border
    reachable = find_reachable_non_green(grid)

    # 2. Find connected components of enclosed (non-reachable, non-green) pixels
    enclosed_regions = find_enclosed_regions(grid, reachable)

    # 3. Analyze each enclosed region and modify output_grid if needed
    for region in enclosed_regions:
        is_purely_white = True
        # Check if all pixels in the current region are white (0) in the input grid
        for r, c in region:
            if grid[r, c] != 0:
                is_purely_white = False
                break # No need to check further for this region
        
        # If the region was purely white, change its pixels to yellow (4) in the output grid
        if is_purely_white:
            for r, c in region:
                output_grid[r, c] = 4
                
    # Convert back to list of lists
    return output_grid.tolist()
```

Previous Code:
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions enclosed by green (3) pixels. 
If an enclosed region consists *entirely* of white (0) pixels in the input grid, 
all pixels within that region are changed to yellow (4) in the output grid. 
If an enclosed region contains any non-white pixels (e.g., yellow 4), 
the entire region remains unchanged. 
Pixels outside enclosed regions (green pixels and pixels reachable from the border) 
also remain unchanged.
"""

def find_reachable_non_green(grid):
    """
    Performs a BFS starting from the border to find all non-green pixels 
    reachable without crossing green pixels.

    Args:
        grid (np.array): The input grid.

    Returns:
        np.array: A boolean array where True indicates a reachable non-green pixel.
    """
    rows, cols = grid.shape
    reachable = np.zeros_like(grid, dtype=bool)
    q = deque()

    # Add border non-green pixels to the queue
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True
    for c in range(1, cols - 1): # Avoid corners twice
        for r in [0, rows - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True

    # BFS
    while q:
        r, c = q.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr, nc] != 3 and not reachable[nr, nc]:
                    reachable[nr, nc] = True
                    q.append((nr, nc))
    return reachable

def find_enclosed_regions(grid, reachable):
    """
    Finds connected components of non-green pixels that were not reachable 
    from the border (i.e., enclosed regions).

    Args:
        grid (np.array): The input grid.
        reachable (np.array): Boolean array indicating reachable non-green pixels.

    Returns:
        list of lists of tuples: A list where each inner list contains the 
                                 (row, col) coordinates of pixels in one 
                                 enclosed region.
    """
    rows, cols = grid.shape
    visited_enclosed = np.zeros_like(grid, dtype=bool)
    enclosed_regions = []

    for r in range(rows):
        for c in range(cols):
            # Start BFS if we find an unvisited, non-green, non-reachable pixel
            if grid[r, c] != 3 and not reachable[r, c] and not visited_enclosed[r, c]:
                current_region = []
                q = deque([(r, c)])
                visited_enclosed[r, c] = True
                
                while q:
                    cr, cc = q.popleft()
                    current_region.append((cr, cc))
                    
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols:
                             # Add neighbor if it's part of the enclosed area 
                             # (non-green, not reachable, not yet visited for this region search)
                            if grid[nr, nc] != 3 and not reachable[nr, nc] and not visited_enclosed[nr, nc]:
                                visited_enclosed[nr, nc] = True
                                q.append((nr, nc))
                                
                if current_region:
                    enclosed_regions.append(current_region)
                    
    return enclosed_regions

def transform(input_grid):
    """
    Applies the transformation rule: Fills purely white enclosed regions with yellow.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # 1. Find all non-green pixels reachable from the border
    reachable = find_reachable_non_green(grid)

    # 2. Find connected components of enclosed (non-reachable, non-green) pixels
    enclosed_regions = find_enclosed_regions(grid, reachable)

    # 3. Analyze each enclosed region and modify output_grid if needed
    for region in enclosed_regions:
        is_purely_white = True
        # Check if all pixels in the current region are white (0) in the input grid
        for r, c in region:
            if grid[r, c] != 0:
                is_purely_white = False
                break # No need to check further for this region
        
        # If the region was purely white, change its pixels to yellow (4) in the output grid
        if is_purely_white:
            for r, c in region:
                output_grid[r, c] = 4
                
    # Convert back to list of lists
    return output_grid.tolist()
```
Results for code_00.py:

Train Set Results:

## Example 1:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0

## Example 2:
Input:
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 3 4 0 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 11
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 11.224489795918373

## Example 3:
Input:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```
Match: True
Pixels Off: 0
Size Correct: True
Color Palette Correct: True
Color Count Correct: True
Score: 0

## Example 4:
Input:
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```
Expected Output:
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```
Transformed Output:
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```
Match: False
Pixels Off: 3
Size Correct: True
Color Palette Correct: True
Color Count Correct: False
Score: 6.0
## General Assessment and Strategy

The initial code successfully solved Examples 1 and 3 but failed on Examples 2 and 4.
- Example 1 & 3: The enclosed areas contained a mix of white (0) and yellow (4) pixels. The code correctly left these areas unchanged.
- Example 2: The enclosed area was purely white (0). The code failed to change it to yellow (4) as required by the expected output.
- Example 4: The enclosed area had a mix of white (0) and yellow (4) in the upper part, and a purely white row at the bottom. The code failed to modify the white pixels in the bottom row to match the checkerboard pattern implied by the yellow pixels above, as required by the expected output.

The failures indicate the initial rule ("fill purely white enclosed regions") was incomplete. The transformation depends on the *content* of the enclosed region:
1.  If the enclosed region is *purely white*, it should be filled entirely with yellow (4). (This explains Example 2).
2.  If the enclosed region contains yellow (4) pixels, any white (0) pixels within that *same region* should be changed to yellow (4) *only if* they complete an established checkerboard pattern defined by the existing yellow pixels. (This explains Example 4's partial fill and why Examples 1 & 3 remain unchanged, as their white pixels already fit the pattern).

The strategy is to:
1.  Identify regions enclosed by green (3) pixels.
2.  For each region, analyze its initial pixel composition.
3.  Apply the transformation:
    *   Fill completely if initially pure white.
    *   Complete checkerboard pattern if initially contains yellow.

## Metrics

No specific code execution is needed for metrics at this stage. The key observations are qualitative:
- **Enclosure:** Green (3) pixels define boundaries.
- **Target Pixels:** Only white (0) pixels *inside* enclosed regions are potential candidates for change.
- **Conditions for Change:**
    - Condition A: The enclosed region consists *only* of white (0) pixels.
    - Condition B: The enclosed region contains *at least one* yellow (4) pixel.
- **Result of Change:**
    - If Condition A: All white (0) pixels change to yellow (4).
    - If Condition B: White (0) pixels change to yellow (4) based on a checkerboard pattern derived from existing yellow pixels within the region. Specifically, determine the parity `(row + col) % 2` for existing yellow pixels. Change white pixels to yellow only if their `(row + col) % 2` matches that parity.

## Facts


```yaml
Objects:
  - Type: Boundary
    Color: green (3)
    Role: Creates enclosed regions. Not modified.
  - Type: External Area
    Role: Pixels outside any green boundary, or reachable from the grid edge without crossing green.
    Colors: white (0), yellow (4), potentially others (though only 0 and 4 seen outside boundaries in examples).
    Transformation: Not modified.
  - Type: Enclosed Region
    Role: Area completely surrounded by green (3) pixels. Transformation target.
    Initial Content Variants:
      - Purely white (0) pixels (e.g., Example 2).
      - Mix of white (0) and yellow (4) pixels, often in a checkerboard pattern (e.g., Examples 1, 3, 4).
      - Potentially other compositions (not seen in examples).
    Transformation Rules: See Actions.
  - Type: Pixel
    Color: white (0)
    Location: Can be in External Area or Enclosed Region.
    Role: Subject to change *only if* inside an Enclosed Region and specific conditions are met.
  - Type: Pixel
    Color: yellow (4)
    Location: Can be in External Area or Enclosed Region.
    Role: Defines pattern within Enclosed Regions, or is the result color for transformed white pixels. Not modified itself.

Properties:
  - Enclosure: Defined by green (3) pixels.
  - Reachability: Pixels are reachable if a path exists to the grid edge without crossing green (3). Unreachable non-green pixels form enclosed regions.
  - Region Content: The set of pixel colors within an enclosed region (e.g., {0}, {0, 4}).
  - Checkerboard Parity: For regions containing yellow (4), the property `(row + col) % 2` associated with the yellow pixels determines the pattern.

Actions:
  - Identify Boundaries: Locate green (3) pixels.
  - Identify Reachable Pixels: Use BFS/Flood fill from the border, avoiding green (3) pixels.
  - Identify Enclosed Regions: Find connected components of non-green pixels that are not reachable.
  - Analyze Region Content: For each enclosed region, determine the set of colors present.
  - Conditional Fill/Pattern Completion:
    1. If an enclosed region contains *only* white (0): Change all pixels in the region to yellow (4).
    2. If an enclosed region contains *yellow (4)* (and possibly white(0)):
       a. Determine the parity `P = (row + col) % 2` of the existing yellow pixels. (Assume consistency within the region).
       b. Change any white (0) pixel `(r, c)` within that region to yellow (4) *if* `(r + c) % 2 == P`.
    3. Otherwise (region contains other colors, no white/yellow, etc.): Leave the region unchanged.

Relationships:
  - Spatial: Green pixels surround Enclosed Regions. White and yellow pixels exist within Enclosed Regions or External Areas.
  - Conditional Transformation: The change applied to a white pixel depends entirely on whether it's in an enclosed region and the overall content (pure white vs. containing yellow) of that specific region.
```


## Natural Language Program

1.  **Identify Enclosed Regions:**
    a.  Find all non-green (not 3) pixels that are reachable from the border of the grid without crossing any green (3) pixels. Mark these as "external".
    b.  Identify all connected components (groups of adjacent pixels) consisting of non-green pixels that were *not* marked as "external". These are the "enclosed regions".
2.  **Process Each Enclosed Region:**
    a.  For each identified enclosed region:
        i.  Examine all pixels within the region in the *input* grid.
        ii. **Check for Pure White:** Determine if *all* pixels within this region are white (0).
        iii. **Check for Existing Yellow:** Determine if *any* pixel within this region is yellow (4).
    b.  **Apply Transformation Rule based on content:**
        i.  **If the region was purely white (0):** Change the color of *all* pixels within this region to yellow (4) in the output grid.
        ii. **If the region contained yellow (4) pixels:**
            1.  Find the coordinates `(r, c)` of one of the yellow (4) pixels within this region. Calculate its checkerboard parity: `target_parity = (r + c) % 2`.
            2.  Iterate through all *white (0)* pixels located at `(wr, wc)` within this *same* region.
            3.  Calculate the white pixel's parity: `white_parity = (wr + wc) % 2`.
            4.  If `white_parity == target_parity`, change the color of the pixel at `(wr, wc)` to yellow (4) in the output grid. Otherwise, leave it as white (0).
        iii. **Otherwise (e.g., the region contains neither white nor yellow, or only colors other than white/yellow/green):** Make no changes to the pixels within this region in the output grid.
3.  **Finalize Output:** Ensure all pixels not part of a modified enclosed region (i.e., green pixels and external pixels) retain their original colors from the input grid. The resulting grid is the final output.
