{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify regions enclosed by green (3) pixels.\nIf an enclosed region consists entirely of white (0) pixels in the input grid, change all pixels within that region to yellow (4) in the output grid.\nIf an enclosed region contains at least one yellow (4) pixel in the input grid, determine the checkerboard parity ((row + col) % 2) of the yellow pixel(s). Then, change any white (0) pixel within that same region to yellow (4) if its coordinates share the same parity.\nLeave all other pixels (green boundary pixels, pixels in regions not matching the above criteria, and pixels outside any enclosed region) unchanged.\n\"\"\"\n\ndef find_reachable_non_green(grid):\n    \"\"\"\n    Performs a BFS starting from the border to find all non-green pixels \n    reachable without crossing green (3) pixels.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        np.array: A boolean array where True indicates a reachable non-green pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable = np.zeros_like(grid, dtype=bool)\n    q = deque()\n\n    # Add border non-green pixels to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] != 3 and not reachable[r, c]:\n                q.append((r, c))\n                reachable[r, c] = True\n    # Add other border pixels (avoiding corners twice)\n    for c in range(1, cols - 1): \n        for r in [0, rows - 1]:\n            if grid[r, c] != 3 and not reachable[r, c]:\n                q.append((r, c))\n                reachable[r, c] = True\n\n    # BFS from border inward, staying off green\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds and if the neighbor is non-green and not yet marked reachable\n            if 0 <= nr < rows and 0 <= nc < cols:\n                if grid[nr, nc] != 3 and not reachable[nr, nc]:\n                    reachable[nr, nc] = True\n                    q.append((nr, nc))\n    return reachable\n\ndef find_enclosed_regions(grid, reachable):\n    \"\"\"\n    Finds connected components of non-green pixels that were not reachable \n    from the border (i.e., enclosed regions).\n\n    Args:\n        grid (np.array): The input grid.\n        reachable (np.array): Boolean array indicating reachable non-green pixels.\n\n    Returns:\n        list of lists of tuples: A list where each inner list contains the \n                                 (row, col) coordinates of pixels in one \n                                 enclosed region.\n    \"\"\"\n    rows, cols = grid.shape\n    visited_enclosed = np.zeros_like(grid, dtype=bool)\n    enclosed_regions = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # Start BFS for a new region if we find an unvisited, non-green, non-reachable pixel\n            if grid[r, c] != 3 and not reachable[r, c] and not visited_enclosed[r, c]:\n                current_region = []\n                q_region = deque([(r, c)])\n                visited_enclosed[r, c] = True\n                \n                # BFS to find all connected pixels in this enclosed region\n                while q_region:\n                    cr, cc = q_region.popleft()\n                    current_region.append((cr, cc))\n                    \n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = cr + dr, cc + dc\n                        # Check bounds and if neighbor is part of the same enclosed blob\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            if grid[nr, nc] != 3 and not reachable[nr, nc] and not visited_enclosed[nr, nc]:\n                                visited_enclosed[nr, nc] = True\n                                q_region.append((nr, nc))\n                                \n                # Add the found region to the list if it's not empty\n                if current_region:\n                    enclosed_regions.append(current_region)\n                    \n    return enclosed_regions\n\ndef transform(input_grid):\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Create a copy to modify, leaving the original input untouched\n    output_grid = grid.copy()\n    rows, cols = grid.shape\n\n    # 1. Find all non-green pixels reachable from the border\n    # These pixels (and the green pixels) will not be modified.\n    reachable = find_reachable_non_green(grid)\n\n    # 2. Find connected components of enclosed pixels (non-green, non-reachable)\n    # These are the candidate regions for transformation.\n    enclosed_regions = find_enclosed_regions(grid, reachable)\n\n    # 3. Process each enclosed region based on its content\n    for region in enclosed_regions:\n        # Analyze the content of the current region using the original grid\n        region_pixels = [grid[r, c] for r, c in region]\n        contains_yellow = 4 in region_pixels\n        all_white = all(p == 0 for p in region_pixels)\n\n        # Rule A: If the region was purely white (0)\n        if all_white:\n            # Change all pixels in this region to yellow (4) in the output grid\n            for r, c in region:\n                output_grid[r, c] = 4\n        \n        # Rule B: If the region contained yellow (4) (and possibly white(0) or others)\n        elif contains_yellow:\n            target_parity = -1 # Initialize parity\n            # Find the parity of an existing yellow pixel\n            for r, c in region:\n                if grid[r, c] == 4:\n                    target_parity = (r + c) % 2\n                    break # Found the parity, no need to check other yellows\n\n            # If we found a valid parity (should always happen if contains_yellow is True)\n            if target_parity != -1:\n                # Iterate through all pixels in the region again\n                for r, c in region:\n                    # If the pixel is white (0) in the original grid\n                    if grid[r, c] == 0:\n                        # Check if its parity matches the target parity\n                        if (r + c) % 2 == target_parity:\n                            # Change it to yellow (4) in the output grid\n                            output_grid[r, c] = 4\n                            \n        # Otherwise (region doesn't fit Rule A or B), no changes are needed for this region\n        # as output_grid was initialized as a copy of grid.\n\n    # Convert the final numpy array back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12914,
    "candidates_token_count": 1684,
    "total_token_count": 14598,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.760525,
  "retries": 1
}