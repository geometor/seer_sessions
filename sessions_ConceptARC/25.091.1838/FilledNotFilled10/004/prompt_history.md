
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 3 4 0 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```

*   **Perception of Task Elements:**
    The task involves grids containing primarily white (0), green (3), and yellow (4) pixels. Green pixels often form boundaries or shapes that enclose areas within the grid. Some enclosed areas contain only white pixels, while others contain a mix of white and yellow pixels, often in a checkerboard pattern. The transformation specifically targets white pixels based on their relationship with the enclosing green pixels.

*   **Facts:**
    
```yaml
    Objects:
      - Type: Boundary
        Color: green (3)
        Role: Encloses other pixels. Forms contiguous shapes or frames.
      - Type: Region
        Color: white (0)
        Role: Potential target for transformation. Exists both inside and outside green boundaries.
      - Type: Pixel
        Color: yellow (4)
        Role: Exists initially within some green boundaries, or is the result color for transformed white pixels.

    Properties:
      - Enclosure: A region is considered enclosed if it is completely surrounded by green (3) pixels, meaning any path from a pixel in the region to the grid edge must cross a green pixel.
      - Content: Enclosed regions can contain only white (0) pixels or a mix of white (0) and yellow (4) pixels.

    Actions:
      - Identify: Locate contiguous regions of white (0) pixels.
      - Check Enclosure: Determine if a white region is fully enclosed by green (3) pixels.
      - Check Content: Verify if an enclosed region contains *only* white (0) pixels.
      - Fill/Recolor: Change the color of pixels within a specific region.

    Relationships:
      - Spatial: Green pixels surround or bound white/yellow regions.
      - Conditional Transformation: The transformation (white -> yellow) only applies to white pixels if they belong to a region that is 1) entirely composed of white pixels and 2) fully enclosed by green pixels.
    ```


*   **Natural Language Program:**
    1.  Identify all contiguous regions composed exclusively of white (0) pixels.
    2.  For each identified white region, determine if it is completely enclosed by green (3) pixels. (A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
    3.  If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
    4.  Leave all other pixels (green pixels, yellow pixels, and white pixels not part of a region fully enclosed by green) unchanged.
    5.  The output grid is the result of applying this conditional color change to the input grid.
```python
import numpy as np
from collections import deque

"""
Identify all contiguous regions composed exclusively of white (0) pixels.
For each identified white region, determine if it is completely enclosed by green (3) pixels. 
(A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
Leave all other pixels unchanged.
"""

def transform(input_grid):
    """
    Fills white (0) regions enclosed by green (3) pixels with yellow (4).

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # Visited array to keep track of pixels reachable from the border
    visited = np.zeros_like(grid, dtype=bool)
    
    # Queue for Breadth-First Search (BFS)
    q = deque()

    # Initialize BFS with all white pixels on the border
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
    for c in range(cols):
        for r in [0, rows - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True

    # Perform BFS to find all white pixels reachable from the border
    while q:
        r, c = q.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # If the neighbor is white and not visited, add it to the queue
                if grid[nr, nc] == 0 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid
    for r in range(rows):
        for c in range(cols):
            # If a pixel is white (0) and was not reached by the BFS (i.e., not visited)
            # it means it's part of an enclosed white region.
            if grid[r, c] == 0 and not visited[r, c]:
                # Change the color of this pixel to yellow (4) in the output grid
                output_grid[r, c] = 4

    # Convert back to list of lists before returning
    return output_grid.tolist()
```
```python
import numpy as np
from collections import deque

"""
Identifies contiguous regions enclosed by green (3) pixels. 
If an enclosed region consists *entirely* of white (0) pixels in the input grid, 
all pixels within that region are changed to yellow (4) in the output grid. 
If an enclosed region contains any non-white pixels (e.g., yellow 4), 
the entire region remains unchanged. 
Pixels outside enclosed regions (green pixels and pixels reachable from the border) 
also remain unchanged.
"""

def find_reachable_non_green(grid):
    """
    Performs a BFS starting from the border to find all non-green pixels 
    reachable without crossing green pixels.

    Args:
        grid (np.array): The input grid.

    Returns:
        np.array: A boolean array where True indicates a reachable non-green pixel.
    """
    rows, cols = grid.shape
    reachable = np.zeros_like(grid, dtype=bool)
    q = deque()

    # Add border non-green pixels to the queue
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True
    for c in range(1, cols - 1): # Avoid corners twice
        for r in [0, rows - 1]:
            if grid[r, c] != 3 and not reachable[r, c]:
                q.append((r, c))
                reachable[r, c] = True

    # BFS
    while q:
        r, c = q.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if grid[nr, nc] != 3 and not reachable[nr, nc]:
                    reachable[nr, nc] = True
                    q.append((nr, nc))
    return reachable

def find_enclosed_regions(grid, reachable):
    """
    Finds connected components of non-green pixels that were not reachable 
    from the border (i.e., enclosed regions).

    Args:
        grid (np.array): The input grid.
        reachable (np.array): Boolean array indicating reachable non-green pixels.

    Returns:
        list of lists of tuples: A list where each inner list contains the 
                                 (row, col) coordinates of pixels in one 
                                 enclosed region.
    """
    rows, cols = grid.shape
    visited_enclosed = np.zeros_like(grid, dtype=bool)
    enclosed_regions = []

    for r in range(rows):
        for c in range(cols):
            # Start BFS if we find an unvisited, non-green, non-reachable pixel
            if grid[r, c] != 3 and not reachable[r, c] and not visited_enclosed[r, c]:
                current_region = []
                q = deque([(r, c)])
                visited_enclosed[r, c] = True
                
                while q:
                    cr, cc = q.popleft()
                    current_region.append((cr, cc))
                    
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols:
                             # Add neighbor if it's part of the enclosed area 
                             # (non-green, not reachable, not yet visited for this region search)
                            if grid[nr, nc] != 3 and not reachable[nr, nc] and not visited_enclosed[nr, nc]:
                                visited_enclosed[nr, nc] = True
                                q.append((nr, nc))
                                
                if current_region:
                    enclosed_regions.append(current_region)
                    
    return enclosed_regions

def transform(input_grid):
    """
    Applies the transformation rule: Fills purely white enclosed regions with yellow.

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # 1. Find all non-green pixels reachable from the border
    reachable = find_reachable_non_green(grid)

    # 2. Find connected components of enclosed (non-reachable, non-green) pixels
    enclosed_regions = find_enclosed_regions(grid, reachable)

    # 3. Analyze each enclosed region and modify output_grid if needed
    for region in enclosed_regions:
        is_purely_white = True
        # Check if all pixels in the current region are white (0) in the input grid
        for r, c in region:
            if grid[r, c] != 0:
                is_purely_white = False
                break # No need to check further for this region
        
        # If the region was purely white, change its pixels to yellow (4) in the output grid
        if is_purely_white:
            for r, c in region:
                output_grid[r, c] = 4
                
    # Convert back to list of lists
    return output_grid.tolist()
```
