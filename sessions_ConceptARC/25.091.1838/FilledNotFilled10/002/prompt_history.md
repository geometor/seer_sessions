
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 3 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 4 0 3 0
0 3 3 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 3 4 0 4 0 0 0 3 0 0 0 0 0
0 0 3 4 0 4 0 0 3 0 0 0 0 0
0 0 0 3 4 0 0 0 3 0 0 0 0 0
0 0 0 0 3 4 0 0 3 0 0 0 0 0
0 0 0 0 0 3 0 0 3 0 0 0 0 0
0 0 0 0 0 0 3 0 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 3 4 0 4 0 4 0 3 0 0 0 0 0
0 0 3 4 0 4 0 4 3 0 0 0 0 0
0 0 0 3 4 0 4 0 3 0 0 0 0 0
0 0 0 0 3 4 0 4 3 0 0 0 0 0
0 0 0 0 0 3 4 0 3 0 0 0 0 0
0 0 0 0 0 0 3 4 3 0 0 0 0 0
0 0 0 0 0 0 0 3 3 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 3 4 0 4 0 4 0 4 0 3 0 0
3 4 0 4 0 4 0 4 0 4 0 3 0
0 3 4 0 4 0 4 0 4 0 3 0 0
0 0 3 4 0 4 0 4 0 3 0 0 0
0 0 0 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 0 0 0 0 0 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0
0 3 3 3 3 3 3 3 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 4 0 4 0 4 0 3 0
0 3 0 4 0 4 0 4 3 0
0 3 3 3 3 3 3 3 3 0
0 0 0 0 0 0 0 0 0 0
```

*   **Perception of Task Elements:**
    The task involves grids containing primarily white (0), green (3), and yellow (4) pixels. Green pixels often form boundaries or shapes that enclose areas within the grid. Some enclosed areas contain only white pixels, while others contain a mix of white and yellow pixels, often in a checkerboard pattern. The transformation specifically targets white pixels based on their relationship with the enclosing green pixels.

*   **Facts:**
    
```yaml
    Objects:
      - Type: Boundary
        Color: green (3)
        Role: Encloses other pixels. Forms contiguous shapes or frames.
      - Type: Region
        Color: white (0)
        Role: Potential target for transformation. Exists both inside and outside green boundaries.
      - Type: Pixel
        Color: yellow (4)
        Role: Exists initially within some green boundaries, or is the result color for transformed white pixels.

    Properties:
      - Enclosure: A region is considered enclosed if it is completely surrounded by green (3) pixels, meaning any path from a pixel in the region to the grid edge must cross a green pixel.
      - Content: Enclosed regions can contain only white (0) pixels or a mix of white (0) and yellow (4) pixels.

    Actions:
      - Identify: Locate contiguous regions of white (0) pixels.
      - Check Enclosure: Determine if a white region is fully enclosed by green (3) pixels.
      - Check Content: Verify if an enclosed region contains *only* white (0) pixels.
      - Fill/Recolor: Change the color of pixels within a specific region.

    Relationships:
      - Spatial: Green pixels surround or bound white/yellow regions.
      - Conditional Transformation: The transformation (white -> yellow) only applies to white pixels if they belong to a region that is 1) entirely composed of white pixels and 2) fully enclosed by green pixels.
    ```


*   **Natural Language Program:**
    1.  Identify all contiguous regions composed exclusively of white (0) pixels.
    2.  For each identified white region, determine if it is completely enclosed by green (3) pixels. (A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
    3.  If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
    4.  Leave all other pixels (green pixels, yellow pixels, and white pixels not part of a region fully enclosed by green) unchanged.
    5.  The output grid is the result of applying this conditional color change to the input grid.
```python
import numpy as np
from collections import deque

"""
Identify all contiguous regions composed exclusively of white (0) pixels.
For each identified white region, determine if it is completely enclosed by green (3) pixels. 
(A region is enclosed if every path from a pixel within the region to the edge of the grid passes through at least one green pixel).
If a white region is found to be completely enclosed by green pixels, change the color of all white (0) pixels within that specific enclosed region to yellow (4).
Leave all other pixels unchanged.
"""

def transform(input_grid):
    """
    Fills white (0) regions enclosed by green (3) pixels with yellow (4).

    Args:
        input_grid (list of lists): The input grid.

    Returns:
        list of lists: The transformed grid.
    """
    # Convert input to numpy array for easier manipulation
    grid = np.array(input_grid, dtype=int)
    output_grid = grid.copy()
    rows, cols = grid.shape

    # Visited array to keep track of pixels reachable from the border
    visited = np.zeros_like(grid, dtype=bool)
    
    # Queue for Breadth-First Search (BFS)
    q = deque()

    # Initialize BFS with all white pixels on the border
    for r in range(rows):
        for c in [0, cols - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True
    for c in range(cols):
        for r in [0, rows - 1]:
            if grid[r, c] == 0 and not visited[r, c]:
                q.append((r, c))
                visited[r, c] = True

    # Perform BFS to find all white pixels reachable from the border
    while q:
        r, c = q.popleft()

        # Check 4 neighbors (up, down, left, right)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is within bounds
            if 0 <= nr < rows and 0 <= nc < cols:
                # If the neighbor is white and not visited, add it to the queue
                if grid[nr, nc] == 0 and not visited[nr, nc]:
                    visited[nr, nc] = True
                    q.append((nr, nc))

    # Iterate through the grid
    for r in range(rows):
        for c in range(cols):
            # If a pixel is white (0) and was not reached by the BFS (i.e., not visited)
            # it means it's part of an enclosed white region.
            if grid[r, c] == 0 and not visited[r, c]:
                # Change the color of this pixel to yellow (4) in the output grid
                output_grid[r, c] = 4

    # Convert back to list of lists before returning
    return output_grid.tolist()
```
