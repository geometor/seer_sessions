{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis function transforms an input grid based on one of three conditional rules or returns the grid unchanged if no rule applies.\n\nRule 1: If the grid contains both azure (8) and green (3) pixels, and at least one azure pixel is adjacent (orthogonally or diagonally) to a green pixel, then change all azure pixels to white (0) and change all green pixels that were adjacent to an azure pixel to white (0).\n\nRule 2: If Rule 1 does not apply, find all contiguous non-white objects. If there are 4 or more distinct objects with a size (pixel count) of 10 or more, keep only the 4 largest objects (including ties for the 4th position) and set all other pixels to white (0).\n\nRule 3: If neither Rule 1 nor Rule 2 applies, and the grid contains yellow (4) pixels, change all yellow pixels to green (3).\n\nDefault: If none of the above conditions are met, return the input grid unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\" Gets valid neighbor coordinates for a given cell (r, c). \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            if connectivity == 4 and abs(dr) + abs(dc) != 1: # Skip diagonals for 4-connectivity\n                 continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects(grid, ignore_color=0):\n    \"\"\" Finds all contiguous objects of colors other than ignore_color. \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = [] # List to store (color, size, pixel_coords_set)\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_pixels.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Use 4-connectivity for object definition as per ARC standard\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=4):\n                        if grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            obj_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if obj_pixels:\n                    objects.append({'color': color, 'size': len(obj_pixels), 'pixels': obj_pixels})\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n    output_grid = grid.copy() # Start with a copy\n\n    # --- Check Rule 1 Condition ---\n    has_azure = np.any(grid == 8)\n    has_green = np.any(grid == 3)\n    adjacency_found = False\n    green_to_remove = set()\n\n    if has_azure and has_green:\n        azure_pixels = np.argwhere(grid == 8)\n        for r_az, c_az in azure_pixels:\n            # Check 8-connectivity neighbors\n            for nr, nc in get_neighbors(r_az, c_az, height, width, connectivity=8):\n                if grid[nr, nc] == 3:\n                    adjacency_found = True\n                    green_to_remove.add((nr, nc))\n            if adjacency_found: # Optimization: can stop checking neighbors for this azure pixel\n                 # but need to continue checking *all* azure pixels to find *all* adjacent greens\n                 pass\n\n    # --- Apply Rule 1 if condition met ---\n    if adjacency_found:\n        # Find all azure pixels again (or use azure_pixels list if kept)\n        azure_coords = np.where(grid == 8)\n        output_grid[azure_coords] = 0 # Set all azure to white\n\n        # Set adjacent green pixels to white\n        for r, c in green_to_remove:\n             output_grid[r, c] = 0\n        return output_grid.tolist() # Rule 1 applied\n\n    # --- Check Rule 2 Condition ---\n    all_objects = find_objects(grid, ignore_color=0)\n    large_objects = [obj for obj in all_objects if obj['size'] >= 10]\n\n    if len(large_objects) >= 4:\n        # --- Apply Rule 2 ---\n        # Sort all non-white objects by size descending\n        all_objects.sort(key=lambda x: x['size'], reverse=True)\n\n        # Determine the size threshold (size of the 4th largest object)\n        if len(all_objects) >= 4:\n             size_threshold = all_objects[3]['size']\n        else:\n             # Should not happen based on len(large_objects)>=4 check, but handle defensively\n             size_threshold = 0 \n\n        # Select objects >= threshold size\n        objects_to_keep = [obj for obj in all_objects if obj['size'] >= size_threshold]\n\n        # Create new grid and draw kept objects\n        output_grid = np.full_like(grid, 0) # Fill with white\n        for obj in objects_to_keep:\n            color = obj['color']\n            for r, c in obj['pixels']:\n                output_grid[r, c] = color\n        return output_grid.tolist() # Rule 2 applied\n\n    # --- Check Rule 3 Condition ---\n    has_yellow = np.any(grid == 4)\n\n    # --- Apply Rule 3 if condition met ---\n    if has_yellow:\n        yellow_coords = np.where(grid == 4)\n        output_grid[yellow_coords] = 3 # Change yellow to green\n        return output_grid.tolist() # Rule 3 applied\n\n    # --- Default Case ---\n    # If none of the rules applied, return the original grid (or the initial copy)\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4225,
    "candidates_token_count": 1534,
    "total_token_count": 5759,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.905865,
  "retries": 1
}