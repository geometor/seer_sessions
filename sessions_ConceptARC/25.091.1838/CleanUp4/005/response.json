{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on a sequence of conditional rules:\n\n1.  **Rule 1 (Azure/Green Adjacency):** If the grid contains both azure (8) and green (3) pixels, AND at least one azure (8) pixel is adjacent (orthogonally or diagonally, 8-connectivity) to a green (3) pixel, then change all azure (8) pixels to white (0) and also change all green (3) pixels that were adjacent (8-connectivity) to *any* azure(8) pixel in the original input grid to white (0). Stop.\n\n2.  **Rule 2 (Keep Large Objects):** If Rule 1 does not apply, find all distinct contiguous non-white objects (using 4-connectivity). If there are 4 or more objects with a size (pixel count) of 10 or more, then create a new grid containing only the pixels from these large objects (size >= 10). All other pixels become white (0). Stop.\n\n3.  **Rule 3 (Yellow to Green):** If neither Rule 1 nor Rule 2 applies, and the grid contains any yellow (4) pixels, change all yellow (4) pixels to green (3). Other pixels remain unchanged. Stop.\n\n4.  **Default:** If none of the above conditions are met, return the input grid unchanged.\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"\n    Gets valid neighbor coordinates for a given cell (r, c).\n\n    Args:\n        r: Row index of the cell.\n        c: Column index of the cell.\n        height: Grid height.\n        width: Grid width.\n        connectivity: 8 for orthogonal and diagonal, 4 for orthogonal only.\n\n    Returns:\n        A list of (row, col) tuples for valid neighbors.\n    \"\"\"\n    neighbors = []\n    for dr in range(-1, 2):\n        for dc in range(-1, 2):\n            if dr == 0 and dc == 0:\n                continue\n            # Skip diagonals if 4-connectivity is specified\n            if connectivity == 4 and abs(dr) + abs(dc) != 1:\n                 continue\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_objects(grid, ignore_color=0, connectivity=4):\n    \"\"\"\n    Finds all contiguous objects of colors other than ignore_color using BFS.\n\n    Args:\n        grid: The 2D numpy array representing the grid.\n        ignore_color: The color to ignore (usually background color 0).\n        connectivity: 4 or 8, for defining adjacency in object finding. Standard ARC uses 4.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        with keys: 'color', 'size', 'pixels' (a set of (r, c) tuples).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            # Check if pixel is not the ignored color and hasn't been visited\n            if grid[r, c] != ignore_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                obj_pixels.add((r, c))\n\n                # Breadth-First Search to find all connected pixels of the same color\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Check neighbors based on specified connectivity\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=connectivity):\n                        if grid[nr, nc] == color and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            obj_pixels.add((nr, nc))\n                            q.append((nr, nc))\n                \n                # Store the found object if it has any pixels\n                if obj_pixels:\n                    objects.append({'color': color, 'size': len(obj_pixels), 'pixels': obj_pixels})\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # --- Rule 1: Check Azure (8) / Green (3) Adjacency (8-connectivity) ---\n    has_azure = np.any(grid == 8)\n    has_green = np.any(grid == 3)\n    adjacency_found_rule1 = False\n    green_adjacent_to_azure = set() # Store coordinates of green pixels to remove\n\n    if has_azure and has_green:\n        azure_pixels = np.argwhere(grid == 8)\n        # Iterate through all azure pixels\n        for r_az, c_az in azure_pixels:\n            # Check 8-connectivity neighbors for green pixels\n            for nr, nc in get_neighbors(r_az, c_az, height, width, connectivity=8):\n                if grid[nr, nc] == 3:\n                    adjacency_found_rule1 = True\n                    # Add this green pixel's location to the set\n                    green_adjacent_to_azure.add((nr, nc))\n            # Optimization: If we only needed to know *if* adjacency exists, we could break early.\n            # But we need to find *all* adjacent green pixels, so we continue checking all azure pixels.\n\n    # --- Apply Rule 1 if condition met ---\n    if adjacency_found_rule1:\n        output_grid = grid.copy()\n        # Set all azure pixels to white\n        azure_coords = np.where(grid == 8)\n        output_grid[azure_coords] = 0 \n        # Set all identified adjacent green pixels to white\n        for r, c in green_adjacent_to_azure:\n            output_grid[r, c] = 0\n        return output_grid.tolist() # Rule 1 applied, return result\n\n    # --- Rule 2: Check for >= 4 Large Objects (size >= 10) (if Rule 1 didn't apply) ---\n    # Find objects using standard 4-connectivity for object definition\n    all_objects = find_objects(grid, ignore_color=0, connectivity=4) \n    # Filter objects to find only those with size 10 or greater\n    large_objects = [obj for obj in all_objects if obj['size'] >= 10]\n    # Check if the condition (4 or more large objects) is met\n    rule2_triggered = len(large_objects) >= 4\n\n    # --- Apply Rule 2 if condition met ---\n    if rule2_triggered:\n        # Create a new grid initialized to white (0)\n        output_grid = np.full_like(grid, 0) \n        # Iterate through only the large objects identified\n        for obj in large_objects:\n            color = obj['color']\n            # Draw the pixels of each large object onto the white grid\n            for r, c in obj['pixels']:\n                output_grid[r, c] = color\n        return output_grid.tolist() # Rule 2 applied, return result\n\n    # --- Rule 3: Check for Yellow (4) pixels (if Rules 1 and 2 didn't apply) ---\n    has_yellow = np.any(grid == 4)\n\n    # --- Apply Rule 3 if condition met ---\n    if has_yellow:\n        output_grid = grid.copy()\n        # Find coordinates of all yellow pixels\n        yellow_coords = np.where(grid == 4)\n        # Change yellow pixels to green (3)\n        output_grid[yellow_coords] = 3 \n        return output_grid.tolist() # Rule 3 applied, return result\n\n    # --- Default Case ---\n    # If none of the rules were triggered, return the original grid unmodified\n    return grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16079,
    "candidates_token_count": 1895,
    "total_token_count": 17974,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 19.489396,
  "retries": 1
}