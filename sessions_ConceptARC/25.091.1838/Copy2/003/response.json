{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set, Optional\n\n\"\"\"\nIdentify two distinct non-background objects in the input grid. An object is a contiguous group of non-background pixels (colors 1-9), connected cardinally, and can be composed of multiple colors.\nOne object acts as a 'frame': it must be monochromatic (all its pixels have the same single color) and enclose a rectangular area composed entirely of the background color (white, 0).\nThe other object acts as a 'pattern'.\nCopy the 'pattern' object (preserving its shape and colors relative to its bounding box) into the background area enclosed by the 'frame' object.\nThe alignment is such that the top-left corner of the pattern's bounding box corresponds to the top-left corner of the frame's enclosed background area.\nThe original pattern and frame objects remain in their initial positions in the output grid, with the copied pattern overwriting the background inside the frame.\n\"\"\"\n\ndef find_connected_components(grid: np.ndarray, background_color: int = 0) -> List[Set[Tuple[int, int]]]:\n    \"\"\"\n    Finds all distinct contiguous groups (objects) of non-background pixels.\n    Objects can be multi-colored. Connection is cardinal (4-way).\n\n    Args:\n        grid: The input numpy array representing the grid.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A list where each element is a set of (row, col) tuples representing an object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != background_color:\n                # Start BFS for a new object\n                obj_pixels = set()\n                q = [(r, c)]\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] != background_color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                if obj_pixels:\n                    objects.append(obj_pixels)\n\n    return objects\n\ndef get_bounding_box(pixels: Set[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box of a set of pixels.\n\n    Args:\n        pixels: A set of (row, col) tuples.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col). Returns (0,0,0,0) for empty set.\n    \"\"\"\n    if not pixels:\n        return (0, 0, 0, 0) # Or raise error, depending on expected usage\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef get_object_colors(grid: np.ndarray, pixels: Set[Tuple[int, int]]) -> Set[int]:\n    \"\"\"Gets the set of unique colors present in an object's pixels.\"\"\"\n    return set(grid[r, c] for r, c in pixels)\n\ndef find_frame_details(grid: np.ndarray, obj_pixels: Set[Tuple[int, int]], background_color: int = 0) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Checks if an object is a frame (encloses a pure background rectangle).\n\n    Args:\n        grid: The input numpy array.\n        obj_pixels: The set of pixels belonging to the potential frame object.\n        background_color: The background color value.\n\n    Returns:\n        The (row, col) of the top-left corner of the enclosed background area if it's a valid frame,\n        otherwise None.\n    \"\"\"\n    if not obj_pixels:\n        return None\n\n    min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n\n    # Frame needs space for an interior\n    if max_r <= min_r + 1 or max_c <= min_c + 1:\n        return None\n\n    inner_bg_pixels = set()\n    potential_inner_area_defined = False\n\n    # Iterate through the potential inner rectangle (excluding the bounding box edges)\n    for r in range(min_r + 1, max_r):\n        for c in range(min_c + 1, max_c):\n            if (r, c) not in obj_pixels:\n                potential_inner_area_defined = True # At least one non-object pixel inside BB\n                if grid[r, c] == background_color:\n                    inner_bg_pixels.add((r, c))\n                else:\n                    # Found a non-background color inside that doesn't belong to the object\n                    return None # Not a valid frame\n\n    # If we checked the inner area and found no non-object pixels, or only object pixels,\n    # it doesn't enclose a background area. Also requires at least one bg pixel inside.\n    if not potential_inner_area_defined or not inner_bg_pixels:\n         return None\n\n    # Verify the background pixels form a solid rectangle\n    inner_min_r, inner_min_c, inner_max_r, inner_max_c = get_bounding_box(inner_bg_pixels)\n    expected_bg_count = (inner_max_r - inner_min_r + 1) * (inner_max_c - inner_min_c + 1)\n    if len(inner_bg_pixels) != expected_bg_count:\n        # The background pixels found don't form a solid rectangle\n        return None\n    # Check if all pixels within this inner bounding box are indeed the found background pixels\n    for r in range(inner_min_r, inner_max_r + 1):\n        for c in range(inner_min_c, inner_max_c + 1):\n            if (r,c) not in inner_bg_pixels:\n                 # Hole in the background rectangle or includes non-bg pixels mistakenly identified\n                 return None # This check might be redundant due to previous checks but adds robustness\n\n    # All checks passed, it encloses a background rectangle\n    return (inner_min_r, inner_min_c)\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on the frame/pattern copy rule.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    background_color = 0\n    rows, cols = input_np.shape\n\n    # 1. Find all distinct connected non-background objects\n    objects_pixels = find_connected_components(input_np, background_color)\n\n    # 2. Expect exactly two objects\n    if len(objects_pixels) != 2:\n        # print(f\"Error: Expected 2 objects, found {len(objects_pixels)}. Returning original grid.\")\n        return input_grid # Task constraint not met\n\n    # 3. Identify frame and pattern\n    frame_obj_pixels: Optional[Set[Tuple[int, int]]] = None\n    pattern_obj_pixels: Optional[Set[Tuple[int, int]]] = None\n    frame_inner_tl: Optional[Tuple[int, int]] = None\n\n    for i, obj_pixels in enumerate(objects_pixels):\n        colors = get_object_colors(input_np, obj_pixels)\n        is_mono = len(colors) == 1\n        \n        # Check if it's potentially a frame (monochromatic and encloses background)\n        if is_mono:\n            inner_tl = find_frame_details(input_np, obj_pixels, background_color)\n            if inner_tl is not None:\n                # Found the frame\n                if frame_obj_pixels is not None:\n                     # Error: Found more than one object matching frame criteria\n                     # print(\"Error: Ambiguous frame identification. Returning original grid.\")\n                     return input_grid\n                frame_obj_pixels = obj_pixels\n                frame_inner_tl = inner_tl\n                # The other object must be the pattern\n                pattern_obj_pixels = objects_pixels[1 - i]\n                # break # Found frame, no need to check the other as a frame\n\n    # 4. Verify frame and pattern were identified\n    if frame_obj_pixels is None or pattern_obj_pixels is None or frame_inner_tl is None:\n        # print(\"Error: Could not identify frame and pattern objects uniquely. Returning original grid.\")\n        return input_grid # Identification failed\n\n    # 5. Get bounding box of the pattern\n    pat_min_r, pat_min_c, _, _ = get_bounding_box(pattern_obj_pixels)\n\n    # 6. Get top-left coordinate of the frame's inner area\n    target_r_start, target_c_start = frame_inner_tl\n\n    # 7. Copy pattern pixels into the frame's inner area in the output grid\n    for r, c in pattern_obj_pixels:\n        # Calculate relative position within the pattern's bounding box\n        relative_r = r - pat_min_r\n        relative_c = c - pat_min_c\n\n        # Calculate target position in the output grid\n        target_r = target_r_start + relative_r\n        target_c = target_c_start + relative_c\n\n        # Ensure the target position is within the grid bounds (safety check)\n        if 0 <= target_r < rows and 0 <= target_c < cols:\n            # Get the color of the pattern pixel from the input grid\n            pattern_color = input_np[r, c]\n            # Update the output grid at the target coordinate\n            # (This overwrites the background pixels inside the frame)\n            output_np[target_r, target_c] = pattern_color\n        # else: # Optional: handle cases where pattern might theoretically extend beyond frame's inner area/grid bounds\n            # print(f\"Warning: Pattern pixel at ({r},{c}) maps outside grid to ({target_r},{target_c}). Skipping.\")\n\n    # Convert back to list of lists for the required output format\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12393,
    "candidates_token_count": 2506,
    "total_token_count": 14899,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 28.899924,
  "retries": 1
}