{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Set\n\n\"\"\"\nIdentify two distinct non-background objects in the input grid.\nOne object acts as a 'frame', characterized by enclosing a rectangular area of the background color (0).\nThe other object acts as a 'pattern'.\nCopy the 'pattern' object (preserving its shape and colors, ignoring its background pixels) into the background area enclosed by the 'frame' object.\nThe top-left corner of the pattern's bounding box should align with the top-left corner of the frame's enclosed background area.\nThe original pattern and frame objects remain in their initial positions in the output.\n\"\"\"\n\ndef find_objects(grid: np.ndarray, background_color: int = 0) -> List[Dict]:\n    \"\"\"\n    Finds contiguous objects of non-background colors in the grid.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A list of dictionaries, where each dictionary represents an object\n        and contains 'color' (int) and 'pixels' (Set[Tuple[int, int]]).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if (r, c) not in visited and grid[r, c] != background_color:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = [(r, c)]\n                visited.add((r, c))\n                \n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.add((row, col))\n                    \n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           (nr, nc) not in visited and grid[nr, nc] == color:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                            \n                if obj_pixels:\n                    objects.append({'color': color, 'pixels': obj_pixels})\n                    \n    return objects\n\ndef get_bounding_box(pixels: Set[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Calculates the bounding box of a set of pixels.\n\n    Args:\n        pixels: A set of (row, col) tuples.\n\n    Returns:\n        A tuple (min_row, min_col, max_row, max_col).\n    \"\"\"\n    if not pixels:\n        return (0, 0, 0, 0)\n    rows = [r for r, c in pixels]\n    cols = [c for r, c in pixels]\n    return min(rows), min(cols), max(rows), max(cols)\n\ndef find_frame_and_pattern(grid: np.ndarray, objects: List[Dict], background_color: int = 0) -> Tuple[Dict, Dict, Tuple[int, int]]:\n    \"\"\"\n    Identifies the frame and pattern objects from a list of objects.\n    Determines the top-left corner of the background area inside the frame.\n\n    Args:\n        grid: The input numpy array representing the grid.\n        objects: A list of objects found by find_objects.\n        background_color: The integer value representing the background color.\n\n    Returns:\n        A tuple containing:\n        - The frame object dictionary.\n        - The pattern object dictionary.\n        - The (row, col) tuple for the top-left corner of the frame's inner area.\n        Returns None for any element if identification fails.\n    \"\"\"\n    if len(objects) != 2:\n        # print(f\"Error: Expected 2 objects, found {len(objects)}\")\n        return None, None, None\n\n    potential_frames = []\n\n    for i, obj in enumerate(objects):\n        obj_pixels = obj['pixels']\n        min_r, min_c, max_r, max_c = get_bounding_box(obj_pixels)\n        \n        is_potential_frame = True\n        inner_bg_pixels = set()\n        \n        # Check if the area strictly inside the bounding box contains only background\n        # or pixels belonging to the object itself. Must contain at least one background pixel.\n        found_inner_bg = False\n        if max_r > min_r + 1 and max_c > min_c + 1: # Potential for interior space\n             for r in range(min_r + 1, max_r):\n                 for c in range(min_c + 1, max_c):\n                     if (r, c) not in obj_pixels:\n                         if grid[r, c] == background_color:\n                             inner_bg_pixels.add((r,c))\n                             found_inner_bg = True\n                         else:\n                             # Found a non-background, non-object pixel inside BB\n                             is_potential_frame = False\n                             break\n                 if not is_potential_frame:\n                     break\n        else: # Too small to have an interior\n            is_potential_frame = False\n\n        # A frame must enclose at least one background pixel\n        if is_potential_frame and found_inner_bg:\n             # Find the top-left coordinate of the inner background area\n            inner_min_r = min(r for r, c in inner_bg_pixels)\n            inner_min_c = min(c for r, c in inner_bg_pixels)\n            potential_frames.append({'index': i, 'object': obj, 'inner_top_left': (inner_min_r, inner_min_c)})\n\n    if len(potential_frames) == 1:\n        frame_info = potential_frames[0]\n        frame_object = frame_info['object']\n        inner_top_left = frame_info['inner_top_left']\n        pattern_object = objects[1 - frame_info['index']] # The other object is the pattern\n        return frame_object, pattern_object, inner_top_left\n    else:\n        # print(f\"Error: Found {len(potential_frames)} potential frames, expected 1.\")\n        # Handle ambiguity or error - perhaps check connectivity of the frame border etc.\n        # For this specific task structure, assume exactly one object fits the frame criteria.\n         return None, None, None\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid by finding a 'frame' object and a 'pattern' object,\n    then copying the pattern into the hollow area inside the frame.\n\n    Args:\n        input_grid: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the transformed output grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    output_np = np.copy(input_np)\n    background_color = 0\n\n    # 1. Find all distinct objects\n    objects = find_objects(input_np, background_color)\n    \n    # Ensure exactly two objects are found as per task description\n    if len(objects) != 2:\n        # print(f\"Warning: Expected 2 objects, found {len(objects)}. Returning original grid.\")\n        return input_grid # Or raise an error, depending on desired behavior\n\n    # 2. Identify the frame and the pattern\n    frame_obj, pattern_obj, frame_inner_tl = find_frame_and_pattern(input_np, objects, background_color)\n\n    if frame_obj is None or pattern_obj is None or frame_inner_tl is None:\n        # print(\"Warning: Could not definitively identify frame and pattern. Returning original grid.\")\n        return input_grid # Identification failed\n\n    # 3. Get bounding box of the pattern\n    pattern_pixels = pattern_obj['pixels']\n    pat_min_r, pat_min_c, _, _ = get_bounding_box(pattern_pixels)\n    \n    # 4. Get top-left coordinate of the frame's inner area\n    target_r_start, target_c_start = frame_inner_tl\n\n    # 5. Copy pattern pixels into the frame's inner area in the output grid\n    for r, c in pattern_pixels:\n        # Calculate relative position within the pattern's bounding box\n        relative_r = r - pat_min_r\n        relative_c = c - pat_min_c\n        \n        # Calculate target position in the output grid\n        target_r = target_r_start + relative_r\n        target_c = target_c_start + relative_c\n        \n        # Get the color of the pattern pixel\n        pattern_color = input_np[r, c] # Color is stored in the object, but reading from input ensures consistency\n\n        # Ensure the target position is within the grid bounds (safety check)\n        if 0 <= target_r < output_np.shape[0] and 0 <= target_c < output_np.shape[1]:\n             # Only copy non-background pixels from the pattern source area\n             # Note: find_objects already filters for non-background, but this is explicit\n             if pattern_color != background_color:\n                 output_np[target_r, target_c] = pattern_color\n\n    # Convert back to list of lists for the required output format\n    return output_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4098,
    "candidates_token_count": 2226,
    "total_token_count": 6324,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.713256,
  "retries": 1
}