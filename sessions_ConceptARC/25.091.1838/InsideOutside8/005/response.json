{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nKeep only the target-colored pixels that belong to connected regions of \nnon-boundary-colored pixels which do not touch the grid border. All other \npixels, including the boundary color itself and target pixels in regions \nconnected to the border, become background color (0).\n\nThe boundary color is identified as the non-background color (non-0) with the highest \npixel count in the input grid. Target colors are all other non-background colors.\n\nA connected component search (e.g., Breadth-First Search) is performed starting \nfrom each unvisited, non-boundary pixel. For each component identified, it's checked \nif any pixel within the component touches the grid border (row 0, last row, \ncolumn 0, or last column). If a component does not touch the border, any \ntarget-colored pixels originally found within that component are placed onto \nthe output grid at their corresponding positions. The rest of the output grid \nremains the background color.\n\"\"\"\n\ndef find_colors(input_grid_np):\n    \"\"\"\n    Identifies background (0), boundary (most frequent non-0), and target \n    (other non-0) colors based on pixel counts.\n\n    Args:\n        input_grid_np (np.ndarray): The input grid as a NumPy array.\n\n    Returns:\n        tuple: (background_color, boundary_color, target_colors)\n               boundary_color is None if only background exists.\n               target_colors is an empty set if no targets exist.\n    \"\"\"\n    unique_colors, counts = np.unique(input_grid_np, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n    \n    background_color = 0\n    # Dictionary of non-background colors and their counts\n    non_background_colors = {c: count for c, count in color_counts.items() if c != background_color}\n    \n    boundary_color = None\n    target_colors = set()\n    \n    # If there are non-background colors present\n    if non_background_colors:\n        # Boundary color is the most frequent non-background color\n        boundary_color = max(non_background_colors, key=non_background_colors.get)\n        # Target colors are all other non-background colors\n        target_colors = set(non_background_colors.keys()) - {boundary_color}\n    \n    return background_color, boundary_color, target_colors\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by keeping only target pixels within \n    non-border-touching connected components of non-boundary pixels.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # --- 1. Identify Colors ---\n    background_color, boundary_color, target_colors = find_colors(input_grid_np)\n\n    # Initialize the output grid with the background color\n    output_grid_np = np.full_like(input_grid_np, background_color)\n\n    # --- Handle Edge Cases ---\n    # If no boundary is found (e.g., only background color) or no target colors exist,\n    # the output will be just the background grid.\n    if boundary_color is None or not target_colors:\n         return output_grid_np.tolist()\n\n    # --- 2. Find Connected Components and Filter ---\n    # Keep track of visited cells to avoid processing components multiple times\n    visited = np.zeros_like(input_grid_np, dtype=bool)\n\n    # Iterate through each cell of the input grid\n    for r in range(height):\n        for c in range(width):\n            # If the cell is not the boundary color and hasn't been visited yet,\n            # it's the start of a potential new component.\n            if not visited[r, c] and input_grid_np[r, c] != boundary_color:\n                \n                # Initialize component properties\n                q = deque([(r, c)]) # Queue for BFS\n                visited[r, c] = True\n                component_targets = [] # List to store target pixels in this component\n                touches_border = False # Flag to track if the component touches the border\n\n                # Start Breadth-First Search (BFS) for the current component\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    pixel_color = input_grid_np[curr_r, curr_c]\n\n                    # Check if this pixel is a target color\n                    if pixel_color in target_colors:\n                        # Store its location and color\n                        component_targets.append((curr_r, curr_c, pixel_color)) \n\n                    # Check if this pixel touches the border\n                    if not touches_border and (curr_r == 0 or curr_r == height - 1 or curr_c == 0 or curr_c == width - 1):\n                        touches_border = True\n                        \n                    # Explore valid neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n                        \n                        # Check if neighbor is within grid bounds\n                        if 0 <= nr < height and 0 <= nc < width:\n                            # Check if neighbor is not visited and not the boundary color\n                            if not visited[nr, nc] and input_grid_np[nr, nc] != boundary_color:\n                                visited[nr, nc] = True # Mark as visited\n                                q.append((nr, nc)) # Add to queue for exploration\n                                \n                # --- 3. Populate Output Grid ---\n                # After exploring the entire component, check if it touched the border.\n                if not touches_border:\n                    # If it did NOT touch the border, place its target pixels onto the output grid.\n                    for tr, tc, t_color in component_targets:\n                        output_grid_np[tr, tc] = t_color\n\n    # Convert the final NumPy array back to a list of lists and return\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12352,
    "candidates_token_count": 1467,
    "total_token_count": 13819,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.885723,
  "retries": 1
}