{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nKeep only the target-colored pixels that are located 'inside' the region \ndefined by the boundary-colored shape. Replace everything else, including \nthe boundary shape itself, with the background color (0).\n\nThe boundary color is identified as the non-background color (non-0) with the \nhighest pixel count. Target colors are all other non-background colors.\n\nThe 'outside' region is determined by performing a flood fill (BFS) starting \nfrom all border pixels that are *not* the boundary color. This fill propagates \nthrough adjacent cells (up, down, left, right) but cannot cross the boundary \ncolor. Pixels reached by this fill are marked as 'outside'. \n\nTarget-colored pixels in the input grid that were *not* marked as 'outside' \nare considered 'inside' and are placed onto the output grid at their \ncorresponding positions. The rest of the output grid remains the background color.\n\"\"\"\n\ndef find_colors(input_grid_np):\n    \"\"\"\n    Identifies background (0), boundary (most frequent non-0), and target \n    (other non-0) colors based on pixel counts.\n\n    Args:\n        input_grid_np (np.ndarray): The input grid as a NumPy array.\n\n    Returns:\n        tuple: (background_color, boundary_color, target_colors)\n               boundary_color is None if only background exists or only one non-bg color.\n               target_colors is an empty set if no targets exist.\n    \"\"\"\n    unique_colors, counts = np.unique(input_grid_np, return_counts=True)\n    color_counts = dict(zip(unique_colors, counts))\n    \n    background_color = 0\n    # Dictionary of non-background colors and their counts\n    non_background_colors = {c: count for c, count in color_counts.items() if c != background_color}\n    \n    boundary_color = None\n    target_colors = set()\n    \n    # If there are non-background colors present\n    if non_background_colors:\n        # Boundary color is the most frequent non-background color\n        boundary_color = max(non_background_colors, key=non_background_colors.get)\n        # Target colors are all other non-background colors\n        target_colors = set(non_background_colors.keys()) - {boundary_color}\n        # If only one non-background color exists, it's the boundary, and targets are empty\n        # No need for explicit check, the set difference handles this.\n        \n    return background_color, boundary_color, target_colors\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the containment rule using flood fill.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    \n    # --- 1. Identify Colors ---\n    background_color, boundary_color, target_colors = find_colors(input_grid_np)\n\n    # Initialize the output grid with the background color\n    output_grid_np = np.full_like(input_grid_np, background_color)\n\n    # --- Handle Edge Cases ---\n    # If no boundary is found (e.g., only background color) or no target colors exist,\n    # the output will be just the background grid.\n    if boundary_color is None or not target_colors:\n         return output_grid_np.tolist()\n\n    # --- 2. Determine the 'Outside' Region using Flood Fill (BFS) ---\n    # is_outside grid keeps track of pixels reachable from the border without crossing the boundary\n    is_outside = np.zeros_like(input_grid_np, dtype=bool)\n    q = deque()\n\n    # Initialize queue with border pixels that are NOT the boundary color\n    for r in range(height):\n        for c in [0, width - 1]: # First and last columns\n            if input_grid_np[r, c] != boundary_color and not is_outside[r, c]:\n                is_outside[r, c] = True\n                q.append((r, c))\n    for c in range(1, width - 1): # First and last rows (excluding corners already checked)\n        for r in [0, height - 1]:\n             if input_grid_np[r, c] != boundary_color and not is_outside[r, c]:\n                is_outside[r, c] = True\n                q.append((r, c))\n\n    # Perform flood fill (Breadth-First Search)\n    while q:\n        r, c = q.popleft()\n        \n        # Check neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                # Check if neighbor is NOT boundary color AND NOT already marked as outside\n                if input_grid_np[nr, nc] != boundary_color and not is_outside[nr, nc]:\n                    is_outside[nr, nc] = True # Mark as outside\n                    q.append((nr, nc)) # Add to queue for further exploration\n\n    # --- 3. Populate the Output Grid ---\n    # Iterate through each pixel of the input grid\n    for r in range(height):\n        for c in range(width):\n            pixel_color = input_grid_np[r, c]\n            # If the pixel has a target color AND it was NOT marked as outside (i.e., it's 'inside')\n            if pixel_color in target_colors and not is_outside[r, c]:\n                # Keep this pixel in the output grid\n                output_grid_np[r, c] = pixel_color\n                \n    # Convert the final NumPy array back to a list of lists and return\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13988,
    "candidates_token_count": 1438,
    "total_token_count": 15426,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.344633,
  "retries": 1
}