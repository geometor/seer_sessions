
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 0 0 0 0 0 0 3 0 0 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 2 2 2 2 2 2 2 2 3 0 0 0 0
0 0 0 0 3 2 2 2 2 2 2 2 2 3 0 0 0 0
0 0 0 0 3 2 2 2 2 2 2 2 2 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 0 0 2 2 2 0 0 0 3 0 0 0 0
0 0 0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 5 5 5 5 5 5 5 5 5 5 4 0 0
0 0 4 5 5 5 5 5 5 5 5 5 5 4 0 0
0 0 4 0 0 0 0 0 0 0 5 5 0 4 0 0
0 0 4 4 4 4 4 4 4 4 4 4 4 4 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 6 0 6 0 0 0 0 0
0 0 0 0 0 6 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 0 0 6 0 0 0
0 0 0 6 0 0 0 0 0 0 0 6 0 0
0 0 6 0 0 0 7 7 7 0 0 0 6 0
0 6 0 0 0 0 7 7 7 0 0 0 0 6
6 0 0 0 0 0 7 7 7 0 0 0 6 0
0 6 0 0 0 0 0 0 0 0 0 6 0 0
0 0 6 0 0 0 0 0 0 0 6 0 0 0
0 0 0 6 0 0 0 0 0 6 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 6 0 6 0 0 0 0 0
0 0 0 0 0 6 7 7 7 6 0 0 0 0
0 0 0 0 6 0 7 7 7 0 6 0 0 0
0 0 0 6 0 0 7 7 7 0 0 6 0 0
0 0 6 7 7 7 7 7 7 7 7 7 6 0
0 6 0 7 7 7 7 7 7 7 7 7 0 6
6 0 0 7 7 7 7 7 7 7 7 7 6 0
0 6 0 0 0 0 7 7 7 0 0 6 0 0
0 0 6 0 0 0 7 7 7 0 6 0 0 0
0 0 0 6 0 0 7 7 7 6 0 0 0 0
0 0 0 0 6 0 0 0 6 0 0 0 0 0
0 0 0 0 0 6 0 6 0 0 0 0 0 0
0 0 0 0 0 0 6 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Okay, let's analyze the provided examples.

**Perception**

In each example pair, the input grid contains an outer hollow shape (a container) of one color and one or more smaller solid shapes of a second color located inside the container. The background is white (color 0). The output grid retains the outer container shape and the original inner shape(s). The key transformation is that the empty space (white pixels) *inside* the container shape is filled with the color of the inner shape(s). The space outside the container remains unchanged (white).

*   **Example 1:** A green hollow rectangle contains a red solid rectangle. The white space inside the green rectangle is filled with red.
*   **Example 2:** A yellow hollow rectangle contains a gray solid rectangle. The white space inside the yellow rectangle is filled with gray.
*   **Example 3:** A magenta hollow diamond-like shape contains an orange solid rectangle. The white space inside the magenta shape is filled with orange.

The transformation behaves like a conditional flood fill: identify the region enclosed by the main outer shape and fill the background pixels within that region using the color of the object(s) initially present inside.

**Facts**


```yaml
task_description: Fill the empty space (white pixels) inside a container shape with the color of the object(s) found within it.

elements:
  - object: container_shape
    description: The largest, outermost, often hollow shape in the grid, defined by a single color. It encloses other elements.
    properties:
      - color: Varies per example (green, yellow, magenta).
      - structure: Typically hollow, forming a boundary.
  - object: inner_shape
    description: A smaller solid shape located spatially inside the container_shape.
    properties:
      - color: Varies per example (red, gray, orange). This color determines the fill color.
      - structure: Solid block of color.
      - location: Strictly inside the boundary formed by the container_shape.
  - object: background
    description: The empty space in the grid.
    properties:
      - color: white (0).

relationships:
  - type: containment
    from: container_shape
    to: inner_shape
    description: The container_shape fully encloses the inner_shape.
  - type: adjacency
    description: Pixels of the same color connected side-by-side form shapes.

actions:
  - action: identify_container
    input: input_grid
    output: container_shape object (pixels and color)
    description: Find the largest connected component that acts as a boundary.
  - action: identify_inner_object
    input: input_grid, container_shape
    output: inner_shape object (pixels and color)
    description: Find the object(s) located within the bounds of the container_shape. Extract the color for filling.
  - action: fill_region
    input: input_grid, container_shape, inner_shape color
    output: modified_grid
    description: Fill the white background pixels located inside the container_shape boundary with the color derived from the inner_shape. Pixels of the container_shape and the original inner_shape remain unchanged.

output_grid_composition:
  - Retain the container_shape pixels from the input.
  - Retain the inner_shape pixels from the input.
  - Replace white pixels inside the container_shape with the inner_shape's color.
  - Retain white pixels outside the container_shape.
```


**Natural Language Program**

1.  **Identify Objects:**
    *   Scan the input grid to find distinct connected objects (groups of non-white pixels).
    *   Identify the largest object that forms a closed boundary as the `container_shape`. Note its color (`container_color`) and the coordinates of its pixels.
    *   Identify the object(s) located entirely within the area enclosed by the `container_shape` as the `inner_shape(s)`. Note the color of one of these shapes (`fill_color`) and the coordinates of at least one of its pixels (`start_pixel`). (In all examples, there's only one inner shape).
2.  **Initialize Output:** Create a copy of the input grid to serve as the output grid.
3.  **Perform Conditional Flood Fill:**
    *   Start a flood fill process from the `start_pixel` (a pixel belonging to the `inner_shape`).
    *   Use a queue or stack to manage pixels to visit, initially containing `start_pixel`. Maintain a set of visited pixels to avoid cycles.
    *   While there are pixels to visit:
        *   Get the current pixel's coordinates (`r`, `c`).
        *   If (`r`, `c`) has already been visited, skip it.
        *   Mark (`r`, `c`) as visited.
        *   Check the color of the pixel at (`r`, `c`) in the *input* grid:
            *   If the color is white (0), change the color of the pixel at (`r`, `c`) in the *output* grid to `fill_color`.
        *   For each neighbor (up, down, left, right) of (`r`, `c`):
            *   Check if the neighbor is within the grid boundaries.
            *   Check if the neighbor's color in the *input* grid is *not* the `container_color`.
            *   If both conditions are true and the neighbor has not been visited, add the neighbor to the queue/stack.
4.  **Return Output:** The modified grid after the flood fill is complete is the final output.
