{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid by identifying a 'container' shape and an 'inner' shape based on specific rules, \nthen filling the empty space (white pixels, value 0) enclosed within the container shape \nwith the color of the inner shape using a conditional flood fill (BFS). \nThe original container and inner shapes retain their colors and positions.\n\nRole Identification Logic:\n1. Assumes exactly two non-white colors exist in the grid.\n2. Determines which color touches the grid boundary (edge).\n3. If only one color touches the edge, it's the container, the other is the inner/fill color.\n4. If neither touches the edge, the one with more pixels is the container, the other is the inner/fill color.\n5. If both touch the edge or the number of non-white colors is not two, roles cannot be determined, and the original grid is returned.\n\nConditional Flood Fill:\n1. Starts from a pixel of the inner shape.\n2. Expands through adjacent pixels (up, down, left, right).\n3. Fill propagation stops at pixels matching the container color.\n4. Only pixels that were originally white (0) are changed to the fill color.\n\"\"\"\n\ndef find_colors_and_roles(grid):\n    \"\"\"\n    Identifies the container color, inner/fill color, and inner shape pixels based on edge-touching and pixel counts.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (container_color, fill_color, inner_shape_pixels, error_message)\n               Returns None for colors/pixels and an error message if identification fails.\n               inner_shape_pixels is a set of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    unique_colors = np.unique(grid[grid != 0]) # Find all non-white colors\n\n    # Check if exactly two non-white colors are present\n    if len(unique_colors) != 2:\n        return None, None, None, f\"Requires exactly two non-background colors, found {len(unique_colors)}.\"\n\n    c1, c2 = unique_colors\n    all_non_white_pixels = {c1: set(), c2: set()}\n    colors_touching_edge = set()\n    pixel_counts = {c1: 0, c2: 0}\n\n    # Collect pixel coordinates, counts, and check edge touching\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color == c1 or color == c2:\n                all_non_white_pixels[color].add((r, c))\n                pixel_counts[color] += 1\n                if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                    colors_touching_edge.add(color)\n\n    # Determine roles based on rules\n    c1_touches_edge = c1 in colors_touching_edge\n    c2_touches_edge = c2 in colors_touching_edge\n    container_color = None\n    fill_color = None\n\n    if c1_touches_edge and not c2_touches_edge:\n        container_color = c1\n        fill_color = c2\n    elif not c1_touches_edge and c2_touches_edge:\n        container_color = c2\n        fill_color = c1\n    elif not c1_touches_edge and not c2_touches_edge:\n        # Neither touches edge, use pixel count\n        if pixel_counts[c1] > pixel_counts[c2]:\n             container_color = c1\n             fill_color = c2\n        else: # Assume c2 > c1 or equal (arbitrarily pick c2 as container in case of tie or equal counts)\n             container_color = c2\n             fill_color = c1\n    else: # Both touch edge or some other ambiguity\n        return None, None, None, f\"Ambiguous roles: Both colors ({c1}, {c2}) touch edge or other issue.\"\n\n    if fill_color not in all_non_white_pixels or not all_non_white_pixels[fill_color]:\n         return None, None, None, f\"Identified inner color {fill_color} has no pixels.\"\n\n    inner_shape_pixels = all_non_white_pixels[fill_color]\n    return container_color, fill_color, inner_shape_pixels, None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional flood fill transformation.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid, or the original if roles cannot be determined.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n    # Initialize output_grid as a copy of the input grid\n    output_grid = grid.copy()\n\n    # 1. Identify Container Color, Fill Color, and Inner Shape Pixels\n    container_color, fill_color, inner_shape_pixels, error = find_colors_and_roles(grid)\n\n    # If roles cannot be determined, return the original grid\n    if error:\n        # print(f\"Debug: Role identification error: {error}\") # Optional debug print\n        return output_grid.tolist()\n        \n    if not inner_shape_pixels:\n        # print(\"Debug: No inner shape pixels found.\") # Optional debug print\n        return output_grid.tolist()\n\n    # 2. Perform Conditional Flood Fill (BFS)\n    # Select an arbitrary starting pixel from the inner shape\n    start_pixel = next(iter(inner_shape_pixels)) \n    # Initialize queue for BFS with the start pixel\n    q = deque([start_pixel])\n    # Initialize visited set, starting with all pixels of the inner shape\n    # This prevents overwriting the original inner shape during the fill.\n    visited = set(inner_shape_pixels) \n\n    # Perform BFS\n    while q:\n        r, c = q.popleft()\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within grid bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor has already been visited\n                if (nr, nc) not in visited:\n                    # Get the neighbor's color from the *original* input grid\n                    original_neighbor_color = grid[nr, nc]\n\n                    # Check if the neighbor is NOT part of the container boundary\n                    if original_neighbor_color != container_color:\n                        # Mark neighbor as visited\n                        visited.add((nr, nc)) \n                        \n                        # If the neighbor was originally white (0), color it in the output grid\n                        if original_neighbor_color == 0:\n                            output_grid[nr, nc] = fill_color\n                        \n                        # Add neighbor to the queue to explore from it (regardless of its original color,\n                        # as long as it's not the container color)\n                        q.append((nr, nc))\n                    # Else: Neighbor is the container color, so we stop filling in this direction\n                    # We don't mark it as visited here, only when approached from non-container pixel.\n                    \n    # Convert the final numpy array back to list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 14584,
    "candidates_token_count": 1761,
    "total_token_count": 16345,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.753813,
  "retries": 1
}