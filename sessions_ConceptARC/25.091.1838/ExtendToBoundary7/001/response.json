{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nDraw lines from colored source pixels towards a central gray barrier line. \n\nThe transformation identifies a single horizontal or vertical gray line (color 5) \nwhich acts as a barrier. It then finds all 'source' pixels (any color other than \nwhite (0) or gray (5)). For each source pixel, a line of the same color is drawn \nfrom the source pixel's position towards the gray barrier, stopping one pixel \nshort of the barrier. If the barrier is horizontal, vertical lines are drawn. \nIf the barrier is vertical, horizontal lines are drawn.\n\"\"\"\n\ndef find_barrier(grid):\n    \"\"\"\n    Finds the gray barrier line (color 5) and returns its orientation and index.\n    Returns:\n        tuple: ('horizontal' or 'vertical', index) or (None, None) if no barrier found.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Check for horizontal barrier\n    for r in range(rows):\n        if np.all(grid[r, :] == 5):\n            return 'horizontal', r\n            \n    # Check for vertical barrier\n    for c in range(cols):\n        if np.all(grid[:, c] == 5):\n            return 'vertical', c\n            \n    # Check for partial horizontal barrier (might be needed if line doesn't span full width/height)\n    for r in range(rows):\n        gray_indices = np.where(grid[r, :] == 5)[0]\n        if len(gray_indices) > 1 and np.all(np.diff(gray_indices) == 1): # contiguous\n             # Check if *only* gray and background exist in the row/col\n             if np.all((grid[r, :] == 5) | (grid[r, :] == 0)):\n                 return 'horizontal', r\n\n    # Check for partial vertical barrier\n    for c in range(cols):\n        gray_indices = np.where(grid[:, c] == 5)[0]\n        if len(gray_indices) > 1 and np.all(np.diff(gray_indices) == 1): # contiguous\n            if np.all((grid[:, c] == 5) | (grid[:, c] == 0)):\n                return 'vertical', c\n\n    # If still not found, look for any line of gray\n    for r in range(rows):\n        if np.any(grid[r, :] == 5) and np.all(grid[r, grid[r, :] != 0] == 5):\n             # More robust check for rows containing only gray and background\n             unique_vals = np.unique(grid[r, :])\n             if np.array_equal(np.sort(unique_vals), [0, 5]) or np.array_equal(unique_vals, [5]):\n                 return 'horizontal', r\n\n    for c in range(cols):\n         if np.any(grid[:, c] == 5) and np.all(grid[grid[:, c] != 0, c] == 5):\n             # More robust check for columns containing only gray and background\n             unique_vals = np.unique(grid[:, c])\n             if np.array_equal(np.sort(unique_vals), [0, 5]) or np.array_equal(unique_vals, [5]):\n                 return 'vertical', c\n\n\n    return None, None # Should not happen based on examples, but good practice\n\ndef find_sources(grid):\n    \"\"\"\n    Finds all source pixels (not white 0 or gray 5).\n    Returns:\n        list: A list of tuples, where each tuple is (row, col, color).\n    \"\"\"\n    sources = []\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0 and color != 5:\n                sources.append((r, c, color))\n    return sources\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    \n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n    \n    # Find the gray barrier line\n    barrier_orientation, barrier_index = find_barrier(input_np)\n    \n    if barrier_orientation is None:\n        # If no barrier is found, return the original grid (or handle as error)\n        return input_grid \n        \n    # Find all source pixels\n    source_pixels = find_sources(input_np)\n    \n    # Process each source pixel\n    for r, c, color in source_pixels:\n        if barrier_orientation == 'horizontal':\n            # Draw vertical line towards the horizontal barrier\n            if r < barrier_index: # Source is above barrier\n                # Fill pixels from source row 'r' down to 'barrier_index - 1'\n                output_grid[r : barrier_index, c] = color\n            elif r > barrier_index: # Source is below barrier\n                # Fill pixels from 'barrier_index + 1' up to source row 'r'\n                # Note: range in numpy slicing is exclusive of the end, so r+1 includes r\n                output_grid[barrier_index + 1 : r + 1, c] = color\n                \n        elif barrier_orientation == 'vertical':\n            # Draw horizontal line towards the vertical barrier\n            if c < barrier_index: # Source is left of barrier\n                # Fill pixels from source col 'c' right to 'barrier_index - 1'\n                output_grid[r, c : barrier_index] = color\n            elif c > barrier_index: # Source is right of barrier\n                # Fill pixels from 'barrier_index + 1' left to source col 'c'\n                # Note: range in numpy slicing is exclusive of the end, so c+1 includes c\n                output_grid[r, barrier_index + 1 : c + 1] = color\n\n    # Convert the result back to a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3152,
    "candidates_token_count": 1436,
    "total_token_count": 4588,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.897686,
  "retries": 1
}