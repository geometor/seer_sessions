{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid containing distinct non-white objects into an output grid filled with white (0).\nThe dimensions of the output grid are determined by the properties of the objects in the input grid.\n\n1. Identify all contiguous blocks of non-white pixels (objects).\n2. Calculate the bounding box height (H) and width (W) for each object.\n3. Determine the overall maximum height (MaxH), maximum width (MaxW), and minimum width (MinW) across all objects.\n4. Compare MaxH and MaxW:\n   - If MaxH > MaxW: Output dimensions are MaxW x MaxW.\n   - If MaxH <= MaxW: Output dimensions are MaxH x MinW.\n5. Create an output grid with the calculated dimensions, filled entirely with white (0).\n\"\"\"\n\ndef find_objects(grid: np.ndarray) -> list[tuple[int, set[tuple[int, int]]]]:\n    \"\"\"\n    Finds all contiguous objects of the same non-background color using BFS.\n\n    Args:\n        grid: The input grid as a numpy array.\n\n    Returns:\n        A list of tuples, where each tuple contains (color, set_of_coordinates).\n        Returns an empty list if no non-background objects are found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0 # Define background color\n\n    for r in range(rows):\n        for c in range(cols):\n            # If this pixel is not background and hasn't been visited\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)]) # Use deque for efficient pop(0)\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft() # BFS uses popleft\n                    obj_coords.add((row, col))\n                    \n                    # Check 4 cardinal neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        \n                        # Check boundaries and if the neighbor is valid (same color, not visited)\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found object to the list\n                if obj_coords:\n                    objects.append((color, obj_coords))\n    return objects\n\ndef get_bounding_box_dims(obj_coords: set[tuple[int, int]]) -> tuple[int, int]:\n    \"\"\"\n    Calculates the height and width of the bounding box for a set of coordinates.\n\n    Args:\n        obj_coords: A set of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        A tuple (height, width) of the bounding box. Returns (0, 0) if input is empty.\n    \"\"\"\n    if not obj_coords:\n        return 0, 0\n        \n    # Extract row and column indices\n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    # Find min/max row and column to define the bounding box\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    \n    # Calculate height and width (inclusive of boundaries)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n    \n    return height, width\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \n    Args:\n        input_grid: The input grid represented as a list of lists.\n\n    Returns:\n        The transformed output grid as a list of lists.\n    \"\"\"\n    # Convert input to numpy array for easier processing\n    grid = np.array(input_grid, dtype=int)\n    \n    # Step 1: Identify all distinct non-white objects\n    objects = find_objects(grid)\n    \n    # Handle edge case: no objects found\n    if not objects:\n        # Return a default 1x1 white grid if no objects are present\n        return [[0]] \n        \n    # Step 2: Calculate bounding box dimensions for each object\n    object_dims = [get_bounding_box_dims(coords) for color, coords in objects]\n    \n    # Step 3: Aggregate properties - Max Height, Max Width, Min Width\n    heights = [h for h, w in object_dims if h > 0] # Ensure we don't include 0 if an object somehow had 0 height/width\n    widths = [w for h, w in object_dims if w > 0]\n    \n    # Handle edge case where heights/widths might be empty if filtering removed all\n    if not heights or not widths:\n         return [[0]] # Or another appropriate default/error handling\n\n    max_h = max(heights)\n    max_w = max(widths)\n    min_w = min(widths)\n    \n    # Step 4: Determine output grid dimensions based on the rule\n    out_h, out_w = 0, 0\n    if max_h > max_w:\n        # Rule 1: If MaxH > MaxW, output is MaxW x MaxW\n        out_h = max_w\n        out_w = max_w\n    else: # max_h <= max_w\n        # Rule 2: If MaxH <= MaxW, output is MaxH x MinW\n        out_h = max_h\n        out_w = min_w\n        \n    # Step 5: Create the output grid with calculated dimensions, filled with white (0)\n    # Ensure dimensions are at least 1x1\n    out_h = max(1, out_h)\n    out_w = max(1, out_w)\n    output_grid_np = np.zeros((out_h, out_w), dtype=int)\n    \n    # Convert back to list of lists for the required output format\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9341,
    "candidates_token_count": 1531,
    "total_token_count": 10872,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.991978,
  "retries": 1
}