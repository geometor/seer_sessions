{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Set\n\n\"\"\"\nIdentify a 'pattern block' and 'control pixels' (blue=1) in the input grid.\nThe pattern block is the part of the grid not occupied by the rows or columns containing only control pixels (and potentially white=0 pixels).\nCount the number of blue control pixels (N). The pattern block will be repeated R = N + 1 times.\nDetermine the orientation of repetition (horizontal or vertical) based on whether the control pixels define rows or columns to be excluded.\nIf control pixels occupy specific columns, the repetition is horizontal, separated by columns of white (0) pixels.\nIf control pixels occupy specific rows, the repetition is vertical, separated by rows of white (0) pixels.\nConstruct the output grid by concatenating the pattern block and white separators R times (pattern) and R-1 times (separator) according to the determined orientation.\n\"\"\"\n\ndef find_pixels(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transforms the input grid based on repeating a pattern block determined\n    by the position and count of blue control pixels.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    height, width = grid.shape\n\n    # 1. Identify Control Pixels (blue=1) and count them.\n    blue_coords = find_pixels(grid, 1)\n    \n    # Handle edge case where there are no blue pixels (though examples suggest there always are)\n    if not blue_coords:\n        return input_grid # Or potentially raise an error or return an empty grid\n\n    N = len(blue_coords)\n    repetition_count = N + 1\n\n    # 2. Determine rows and columns occupied by blue pixels.\n    blue_rows = set(r for r, c in blue_coords)\n    blue_cols = set(c for r, c in blue_coords)\n\n    # 3. Identify potential pattern rows/columns by excluding blue rows/columns.\n    potential_pattern_rows_idx = sorted(list(set(range(height)) - blue_rows))\n    potential_pattern_cols_idx = sorted(list(set(range(width)) - blue_cols))\n\n    # 4. Determine Orientation and identify the actual pattern block.\n    # We check if the grid area defined *only* by blue rows/cols contains any non-blue pixels.\n    # If the blue-pixel-exclusive columns contain non-blue pixels, separation must be row-wise (vertical).\n    # If the blue-pixel-exclusive rows contain non-blue pixels, separation must be column-wise (horizontal).\n\n    # Default assumption: separation by columns (horizontal repetition)\n    orientation = 'horizontal'\n    pattern_rows_idx = list(range(height)) # Assume pattern uses all rows initially\n    pattern_cols_idx = potential_pattern_cols_idx\n\n    # Check if blue pixels define rows instead of columns\n    # This happens if the columns *not* containing blue pixels are empty or only contain white\n    # Or, more robustly, if the rows *containing* blue pixels also contain non-blue, non-white elements elsewhere.\n    \n    # A simpler check based on the examples: if removing blue rows leaves all columns intact, it's vertical. If removing blue cols leaves all rows intact, it's horizontal.\n    if len(potential_pattern_rows_idx) < height and len(potential_pattern_cols_idx) == width:\n         orientation = 'vertical'\n         pattern_rows_idx = potential_pattern_rows_idx\n         pattern_cols_idx = list(range(width))\n    elif len(potential_pattern_cols_idx) < width and len(potential_pattern_rows_idx) == height:\n         orientation = 'horizontal'\n         pattern_rows_idx = list(range(height))\n         pattern_cols_idx = potential_pattern_cols_idx\n    else:\n        # Fallback or more complex logic might be needed for ambiguous cases,\n        # but the provided examples fit the above conditions.\n        # Let's refine the check slightly: If blue pixels occupy *entire* rows/columns\n        # that contain *only* blue or white pixels, those rows/columns define the separation.\n        \n        separating_rows = True\n        for r in blue_rows:\n            if np.any((grid[r, :] != 1) & (grid[r, :] != 0)):\n                separating_rows = False\n                break\n        \n        separating_cols = True\n        for c in blue_cols:\n             if np.any((grid[:, c] != 1) & (grid[:, c] != 0)):\n                separating_cols = False\n                break\n\n        if separating_rows and not separating_cols:\n             orientation = 'vertical'\n             pattern_rows_idx = potential_pattern_rows_idx\n             pattern_cols_idx = list(range(width))\n        elif separating_cols and not separating_rows:\n             orientation = 'horizontal'\n             pattern_rows_idx = list(range(height))\n             pattern_cols_idx = potential_pattern_cols_idx\n        # If both or neither are true, stick with the initial dimension-based check result (or previous default)\n        # The dimension check handles the provided examples correctly.\n\n\n    # Extract the pattern block using determined indices\n    # Need np.ix_ for advanced indexing with lists\n    ix_rows, ix_cols = np.ix_(pattern_rows_idx, pattern_cols_idx)\n    pattern_block = grid[ix_rows, ix_cols]\n\n    # Handle case where pattern block is empty (if logic failed)\n    if pattern_block.size == 0:\n        # This indicates an issue with identifying the pattern or orientation\n        # Returning input might be safest for now, or raise error\n        print(\"Warning: Pattern block identification failed.\")\n        return input_grid\n\n    # 5. Create Separator (white=0)\n    if orientation == 'horizontal':\n        separator = np.zeros((pattern_block.shape[0], 1), dtype=int)\n    else: # vertical\n        separator = np.zeros((1, pattern_block.shape[1]), dtype=int)\n\n    # 6. Construct Output Grid\n    output_parts = []\n    for i in range(repetition_count):\n        output_parts.append(pattern_block)\n        if i < repetition_count - 1:\n            output_parts.append(separator)\n\n    if orientation == 'horizontal':\n        output_grid_np = np.hstack(output_parts)\n    else: # vertical\n        output_grid_np = np.vstack(output_parts)\n\n    # Convert back to list of lists\n    return output_grid_np.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3120,
    "candidates_token_count": 1600,
    "total_token_count": 4720,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.1431,
  "retries": 1
}