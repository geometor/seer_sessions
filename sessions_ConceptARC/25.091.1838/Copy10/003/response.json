{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport itertools\n\n\"\"\"\nTransforms an input grid based on identifying container, contained, and orphan object groups.\nThe transformation involves:\n1. Identifying all distinct objects (contiguous blocks of non-white pixels).\n2. Grouping objects by color and determining the combined bounding box for each group.\n3. Identifying the 'container group' as the color group whose combined bounding box inclusively encloses the combined bounding box of at least one other color group.\n4. Identifying 'contained objects' as individual objects of different colors whose bounding boxes are inclusively enclosed within the container group's bounding box. (Implicitly done by finding enclosed groups).\n5. Identifying the 'orphan group' as the color group that is neither the container nor belongs to a group enclosed by the container.\n6. Calculating a target location for copying the container structure (the area defined by the container group's bounding box, including contained objects). This location is determined by the relative position of the orphan group's bounding box, leaving a 2-pixel gap between the orphan's original edge and the copy's corresponding edge.\n7. Creating an output grid by copying the input grid.\n8. Removing all objects belonging to the orphan group from the output grid.\n9. Extracting the rectangular region corresponding to the container group's bounding box from the original input grid.\n10. Pasting this extracted region onto the output grid at the calculated target location, overwriting existing pixels.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dicts, where each dict represents an object and contains:\n              - 'id': A unique integer identifier for the object.\n              - 'coords': set of (row, col) coordinates.\n              - 'bbox': tuple (min_r, min_c, max_r, max_c).\n              - 'color': int color value.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-directional: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    bounding_box = (min_r, min_c, max_r, max_c)\n                    objects.append({'id': object_id_counter, 'coords': obj_coords, 'bbox': bounding_box, 'color': color})\n                    object_id_counter += 1\n    return objects\n\ndef get_color_groups(objects):\n    \"\"\"\n    Groups objects by color and calculates the combined bounding box and coordinates for each group.\n\n    Args:\n        objects (list): A list of object dictionaries from find_objects.\n\n    Returns:\n        dict: A dictionary where keys are colors and values are dicts containing:\n              - 'objects': list of object dicts of that color.\n              - 'bbox': tuple (min_r, min_c, max_r, max_c) for the whole group.\n              - 'coords': set of all (row, col) coordinates for the group.\n    \"\"\"\n    groups = {}\n    # Sort colors to ensure deterministic behavior if multiple groups could be container/orphan\n    colors = sorted(list(set(obj['color'] for obj in objects)))\n\n    for color in colors:\n        color_objects = [obj for obj in objects if obj['color'] == color]\n        if not color_objects:\n            continue\n\n        # Combine coordinates from all objects of the same color\n        all_coords = set().union(*[obj['coords'] for obj in color_objects])\n        if not all_coords:\n             continue # Should not happen if color_objects is not empty\n\n        # Calculate the combined bounding box for the group\n        min_r = min(r for r, c in all_coords)\n        min_c = min(c for r, c in all_coords)\n        max_r = max(r for r, c in all_coords)\n        max_c = max(c for r, c in all_coords)\n        combined_bbox = (min_r, min_c, max_r, max_c)\n\n        groups[color] = {\n            'objects': color_objects,\n            'bbox': combined_bbox,\n            'coords': all_coords\n        }\n    return groups\n\ndef is_enclosed(inner_box, outer_box):\n    \"\"\"\n    Checks if inner_box is inclusively inside outer_box (edges can touch).\n    An object/group cannot enclose itself.\n\n    Args:\n        inner_box (tuple): Bbox (min_r, min_c, max_r, max_c).\n        outer_box (tuple): Bbox (min_r, min_c, max_r, max_c).\n\n    Returns:\n        bool: True if inner_box is enclosed by outer_box, False otherwise.\n    \"\"\"\n    min_r1, min_c1, max_r1, max_c1 = inner_box\n    min_r2, min_c2, max_r2, max_c2 = outer_box\n    # Prevent self-enclosure if boxes are identical\n    if inner_box == outer_box:\n        return False\n    return min_r1 >= min_r2 and min_c1 >= min_c2 and max_r1 <= max_r2 and max_c1 <= max_c2\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    output_np = np.copy(input_np) # Start with a copy of the input\n\n    # Step 1: Find all distinct objects\n    all_objects = find_objects(input_np)\n    if not all_objects:\n        return input_grid # Return original if no objects found\n\n    # Step 2: Group objects by color\n    color_groups = get_color_groups(all_objects)\n    group_colors = list(color_groups.keys())\n    if len(group_colors) < 2: # Need at least a container and something else\n        return input_grid\n\n    # Step 3: Identify the Container Group\n    container_group_color = -1\n    container_group_bbox = None\n    enclosed_group_colors = set() # Track colors of groups enclosed by the container\n\n    # Iterate through all pairs of distinct color groups\n    for color1, color2 in itertools.permutations(group_colors, 2):\n        group1 = color_groups[color1]\n        group2 = color_groups[color2]\n        # Check if group1's combined bounding box encloses group2's combined bounding box\n        if is_enclosed(group2['bbox'], group1['bbox']):\n            # Found a potential container (group1) and an enclosed group (group2)\n            # Simple strategy: assign the first group found that encloses another.\n            # More complex scenarios might need tie-breaking (e.g., largest area).\n            if container_group_color == -1:\n                 container_group_color = color1\n                 container_group_bbox = group1['bbox']\n            # Regardless if it's the chosen container, mark group2 as enclosed by *some* group\n            enclosed_group_colors.add(color2)\n\n    # If no group encloses another group, the task definition might not apply\n    if container_group_color == -1:\n         # print(\"Warning: Could not identify a container group based on enclosing other groups.\")\n         return input_grid\n\n    # Step 4: (Implicit) Contained objects are within the enclosed groups.\n\n    # Step 5: Identify the Orphan Group\n    orphan_group_color = -1\n    orphan_group_bbox = None\n    orphan_coords = set()\n\n    # An orphan group is one that is NOT the container AND is NOT enclosed by the container\n    for color in group_colors:\n        if color != container_group_color and color not in enclosed_group_colors:\n            # Found an orphan group. Assume the first one dictates placement.\n            if orphan_group_color == -1:\n                orphan_group_color = color\n                orphan_group = color_groups[color]\n                orphan_group_bbox = orphan_group['bbox']\n                orphan_coords = orphan_group['coords']\n                break # Use the first orphan group found\n\n    # If no orphan group is found, the task definition might not apply\n    if orphan_group_color == -1:\n        # print(\"Warning: Could not identify an orphan group.\")\n        return input_grid\n\n    # Step 6: Calculate copy location based on relative positions\n    c_min_r, c_min_c, c_max_r, c_max_c = container_group_bbox\n    o_min_r, o_min_c, o_max_r, o_max_c = orphan_group_bbox\n    target_row, target_col = -1, -1\n\n    # Calculate separation distance (positive if orphan is right/below)\n    # A gap of 1 means adjacent bounding boxes. Gap of 0 means touching.\n    vert_gap = o_min_r - c_max_r - 1\n    horz_gap = o_min_c - c_max_c - 1\n\n    # Determine primary direction based on which side the orphan is on\n    # Assume non-overlapping, non-diagonal placement for simplicity based on examples\n    is_below = vert_gap >= 0 and o_min_c <= c_max_c and o_max_c >= c_min_c # Check for vertical overlap\n    is_right = horz_gap >= 0 and o_min_r <= c_max_r and o_max_r >= c_min_r # Check for horizontal overlap\n\n    # Placement logic requires a 2-pixel gap between orphan edge and copy edge\n    if is_below: # Orphan is primarily below container\n         target_row = o_min_r - 2 # Place top edge 2 pixels above orphan's top edge\n         target_col = c_min_c     # Align left edge with container's left edge\n    elif is_right: # Orphan is primarily right of container\n         target_row = c_min_r     # Align top edge with container's top edge\n         target_col = o_min_c - 2 # Place left edge 2 pixels left of orphan's left edge\n    # Add cases for orphan above or left if needed by future examples\n    # elif is_above: target_row = o_max_r + 2; target_col = c_min_c\n    # elif is_left: target_row = c_min_r; target_col = o_max_c + 2\n    else:\n        # If relative position is ambiguous (diagonal, overlapping, etc.) or doesn't fit rules\n        # print(f\"Warning: Ambiguous relative position between container {container_group_bbox} and orphan {orphan_group_bbox}.\")\n        return input_grid # Cannot determine placement\n\n    # Step 7: Prepare output grid - Remove orphan objects\n    for r, c in orphan_coords:\n        if 0 <= r < rows and 0 <= c < cols:\n            output_np[r, c] = 0 # Set orphan pixels to background color\n\n    # Step 8: Extract pattern to copy from the ORIGINAL input grid\n    # The pattern is the rectangular area defined by the container group's bounding box\n    pattern = input_np[c_min_r : c_max_r + 1, c_min_c : c_max_c + 1]\n    pattern_h, pattern_w = pattern.shape\n\n    # Step 9: Place the copied pattern onto the output grid\n    if target_row >= 0 and target_col >= 0 and pattern_h > 0 and pattern_w > 0:\n        # Define the target slice in the output grid\n        end_row = target_row + pattern_h\n        end_col = target_col + pattern_w\n\n        # Calculate clipping boundaries\n        paste_start_row = max(0, target_row)\n        paste_start_col = max(0, target_col)\n        paste_end_row = min(rows, end_row)\n        paste_end_col = min(cols, end_col)\n\n        # Calculate corresponding slice from the pattern\n        pattern_start_row = max(0, -target_row)\n        pattern_start_col = max(0, -target_col)\n        pattern_end_row = pattern_start_row + (paste_end_row - paste_start_row)\n        pattern_end_col = pattern_start_col + (paste_end_col - paste_start_col)\n\n        # Paste if the calculated slices are valid\n        if paste_start_row < paste_end_row and paste_start_col < paste_end_col:\n            output_np[paste_start_row:paste_end_row, paste_start_col:paste_end_col] = \\\n                pattern[pattern_start_row:pattern_end_row, pattern_start_col:pattern_end_col]\n        # else:\n             # print(f\"Warning: Calculated placement ({target_row},{target_col}) resulted in no valid area to paste.\")\n\n    # else:\n        # print(\"Warning: Invalid target coordinates or pattern dimensions.\")\n\n\n    # Step 10: Return the modified grid as a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20249,
    "candidates_token_count": 3442,
    "total_token_count": 23691,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 56.588879,
  "retries": 1
}