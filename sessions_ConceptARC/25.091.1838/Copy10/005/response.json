{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\nimport itertools\n\n\"\"\"\nTransforms an input grid by duplicating a composite structure (a 'container' object \nand the 'contained' objects within its bounding box) to a new location. The new \nlocation is determined by the position of an 'orphan' object, typically one that \nshares characteristics (like color) with a contained object. The process involves:\n1. Identifying all distinct objects (contiguous non-white pixels).\n2. Identifying the 'container' object, defined as an object whose bounding box \n   inclusively encloses the bounding box of at least one other object of a \n   different color.\n3. Identifying 'contained' objects enclosed within the container's bounding box.\n4. Identifying 'orphan' objects (neither container nor contained).\n5. Selecting a 'primary orphan' (often matching a contained object's color) to \n   dictate placement.\n6. Calculating the target location for the copy, maintaining a 2-pixel gap from \n   the primary orphan's original position.\n7. Creating an output grid by copying the input.\n8. Removing all orphan objects from the output grid.\n9. Extracting the pattern (container's bounding box region) from the original input.\n10. Pasting the pattern onto the output grid at the target location.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same color in the grid using Breadth-First Search.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dicts, where each dict represents an object and contains:\n              - 'id': A unique integer identifier for the object.\n              - 'coords': set of (row, col) coordinates.\n              - 'bbox': tuple (min_r, min_c, max_r, max_c).\n              - 'color': int color value.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    object_id_counter = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r, min_c, max_r, max_c = min(min_r, row), min(min_c, col), max(max_r, row), max(max_c, col)\n\n                    # Check neighbors (4-directional: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                if obj_coords:\n                    bounding_box = (min_r, min_c, max_r, max_c)\n                    objects.append({'id': object_id_counter, 'coords': obj_coords, 'bbox': bounding_box, 'color': color})\n                    object_id_counter += 1\n    return objects\n\ndef is_inclusively_enclosed(inner_box, outer_box):\n    \"\"\"\n    Checks if inner_box is inclusively inside outer_box (edges can touch).\n    Requires the boxes to be distinct.\n\n    Args:\n        inner_box (tuple): Bbox (min_r, min_c, max_r, max_c).\n        outer_box (tuple): Bbox (min_r, min_c, max_r, max_c).\n\n    Returns:\n        bool: True if inner_box is enclosed by outer_box, False otherwise.\n    \"\"\"\n    if inner_box == outer_box: # An object cannot enclose itself\n        return False\n    min_r1, min_c1, max_r1, max_c1 = inner_box\n    min_r2, min_c2, max_r2, max_c2 = outer_box\n    return min_r1 >= min_r2 and min_c1 >= min_c2 and max_r1 <= max_r2 and max_c1 <= max_c2\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n\n    # 1. Identify all distinct objects\n    all_objects = find_objects(input_np)\n    if not all_objects:\n        return input_grid # Return original if no objects\n\n    # 2. & 3. Identify Container and Contained Objects\n    container = None\n    contained_objects_map = {} # Store {container_id: [contained_obj1, contained_obj2,...]}\n\n    for obj_i in all_objects:\n        current_contained = []\n        for obj_j in all_objects:\n            if obj_i['id'] == obj_j['id']:\n                continue\n            # Check for enclosure and different color\n            if obj_i['color'] != obj_j['color'] and is_inclusively_enclosed(obj_j['bbox'], obj_i['bbox']):\n                 current_contained.append(obj_j)\n\n        if current_contained: # If obj_i encloses at least one object of a different color\n             contained_objects_map[obj_i['id']] = current_contained\n             # Simple selection: Assume the first object found that meets the criteria is the container\n             # More robust logic might be needed for complex cases (e.g., largest area, most enclosed)\n             if container is None:\n                 container = obj_i\n\n    # If no container identified based on criteria, return original\n    if container is None:\n        # print(\"Warning: No container found meeting criteria.\")\n        return input_grid\n\n    container_id = container['id']\n    container_bbox = container['bbox']\n    contained_objects = contained_objects_map.get(container_id, [])\n    contained_ids = {obj['id'] for obj in contained_objects}\n    contained_colors = {obj['color'] for obj in contained_objects}\n\n    # 4. Identify Orphan Objects\n    orphan_objects = []\n    for obj in all_objects:\n        if obj['id'] != container_id and obj['id'] not in contained_ids:\n            orphan_objects.append(obj)\n\n    if not orphan_objects:\n        # print(\"Warning: Container and contained objects found, but no orphans.\")\n        return input_grid # Needs an orphan to determine placement\n\n    # 5. Select Primary Orphan\n    primary_orphan = None\n    # Look for an orphan whose color matches a contained object's color\n    for orphan in orphan_objects:\n        if orphan['color'] in contained_colors:\n            primary_orphan = orphan\n            break # Use the first one found\n\n    # Fallback: If no orphan matches contained color, use the first orphan found\n    if primary_orphan is None:\n        primary_orphan = orphan_objects[0]\n        \n    orphan_bbox = primary_orphan['bbox']\n\n    # 6. Calculate Target Location\n    c_min_r, c_min_c, c_max_r, c_max_c = container_bbox\n    o_min_r, o_min_c, o_max_r, o_max_c = orphan_bbox\n    target_row, target_col = -1, -1\n\n    # Determine relative position and calculate target coordinate with 2-pixel gap\n    # Check primary directions based on non-overlapping bounding boxes\n    is_below = o_min_r > c_max_r\n    is_right = o_min_c > c_max_c\n    is_above = o_max_r < c_min_r\n    is_left = o_max_c < c_min_c\n\n    if is_below:\n        target_row = o_min_r - 2\n        target_col = c_min_c\n    elif is_right:\n        target_row = c_min_r\n        target_col = o_min_c - 2\n    elif is_above: # Added for completeness, untested by examples\n        target_row = o_max_r + 2 # Place top edge 2 pixels below orphan's bottom edge\n        target_col = c_min_c\n    elif is_left: # Added for completeness, untested by examples\n        target_row = c_min_r\n        target_col = o_max_c + 2 # Place left edge 2 pixels right of orphan's right edge\n    else:\n        # Handle ambiguous cases if necessary (e.g., diagonal, overlapping)\n        # print(f\"Warning: Ambiguous relative position between container {container_bbox} and primary orphan {orphan_bbox}.\")\n        return input_grid # Cannot determine placement\n\n    # 7. Create Output Grid\n    output_np = np.copy(input_np)\n\n    # 8. Remove ALL Orphan Objects\n    for orphan in orphan_objects:\n        for r, c in orphan['coords']:\n            if 0 <= r < rows and 0 <= c < cols:\n                output_np[r, c] = 0 # Set orphan pixels to background color\n\n    # 9. Extract Pattern from ORIGINAL Input Grid\n    pattern = input_np[c_min_r : c_max_r + 1, c_min_c : c_max_c + 1]\n    pattern_h, pattern_w = pattern.shape\n\n    # 10. Place Pattern onto Output Grid (with clipping)\n    if target_row != -1 and target_col != -1 and pattern_h > 0 and pattern_w > 0:\n        # Define the target slice in the output grid\n        end_row = target_row + pattern_h\n        end_col = target_col + pattern_w\n\n        # Calculate clipping boundaries for pasting\n        paste_start_row = max(0, target_row)\n        paste_start_col = max(0, target_col)\n        paste_end_row = min(rows, end_row)\n        paste_end_col = min(cols, end_col)\n\n        # Calculate corresponding slice from the pattern to copy\n        pattern_start_row = max(0, -target_row)\n        pattern_start_col = max(0, -target_col)\n        pattern_end_row = pattern_start_row + (paste_end_row - paste_start_row)\n        pattern_end_col = pattern_start_col + (paste_end_col - paste_start_col)\n\n        # Paste if the calculated slices are valid (have positive dimensions)\n        if paste_start_row < paste_end_row and paste_start_col < paste_end_col:\n            output_np[paste_start_row:paste_end_row, paste_start_col:paste_end_col] = \\\n                pattern[pattern_start_row:pattern_end_row, pattern_start_col:pattern_end_col]\n        # else: # Debugging: uncomment if needed\n            # print(f\"Warning: Calculated placement ({target_row},{target_col}) resulted in no valid area to paste.\")\n            # print(f\"Paste Area: ({paste_start_row}:{paste_end_row}, {paste_start_col}:{paste_end_col})\")\n            # print(f\"Pattern Area: ({pattern_start_row}:{pattern_end_row}, {pattern_start_col}:{pattern_end_col})\")\n\n    # else: # Debugging: uncomment if needed\n        # print(\"Warning: Invalid target coordinates or pattern dimensions for pasting.\")\n        # print(f\"Target: ({target_row},{target_col}), Pattern Shape: ({pattern_h},{pattern_w})\")\n\n    # Convert back to list of lists for ARC standard\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 22516,
    "candidates_token_count": 2887,
    "total_token_count": 25403,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 31.937828,
  "retries": 1
}