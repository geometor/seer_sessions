{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify primary horizontal and vertical structures based on dominant colors in rows and columns, respectively. \nRemove specific vertical structures based on the count of horizontal structures.\n\n1. Identify the two non-background colors present (H_Color for horizontal, V_Color for vertical).\n2. Determine which color dominates which rows/columns.\n3. Count the number of rows dominated by H_Color (H_Count).\n4. Identify the columns dominated by V_Color (V_Indices).\n5. Select target column(s) based on H_Count:\n    - H_Count >= 3: Middle column index from V_Indices.\n    - H_Count == 2: Leftmost (minimum) column index from V_Indices.\n    - H_Count == 1: Rightmost (maximum) column index from V_Indices.\n6. Modify the grid: Change pixels with V_Color in the target column(s) to the background color (white, 0).\n\"\"\"\n\ndef _get_dominant_color_info(grid):\n    \"\"\"\n    Identifies dominant colors in rows/columns and determines H/V roles.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        dict: Information about colors, counts, and indices, or None if the pattern is not met.\n              Keys: \"H_Color\", \"H_Count\", \"V_Color\", \"V_Indices\"\n    \"\"\"\n    height, width = grid.shape\n    non_bg_colors = np.unique(grid[grid != 0])\n\n    # Expect exactly two non-background colors for this pattern\n    if len(non_bg_colors) != 2:\n        return None \n\n    color1, color2 = non_bg_colors\n\n    rows_dominated_by_c1 = []\n    rows_dominated_by_c2 = []\n    for r in range(height):\n        row = grid[r, :]\n        counts = Counter(c for c in row if c != 0)\n        if not counts: continue\n        # Find the most common non-zero color\n        mc = counts.most_common(1)\n        if mc:\n            dominant_color = mc[0][0]\n            if dominant_color == color1:\n                rows_dominated_by_c1.append(r)\n            elif dominant_color == color2:\n                rows_dominated_by_c2.append(r)\n\n    cols_dominated_by_c1 = []\n    cols_dominated_by_c2 = []\n    for c in range(width):\n        col = grid[:, c]\n        counts = Counter(p for p in col if p != 0)\n        if not counts: continue\n        # Find the most common non-zero color\n        mc = counts.most_common(1)\n        if mc:\n             dominant_color = mc[0][0]\n             if dominant_color == color1:\n                 cols_dominated_by_c1.append(c)\n             elif dominant_color == color2:\n                 cols_dominated_by_c2.append(c)\n\n    # Determine H_Color and V_Color. The color defining the structures to be removed (vertical)\n    # is likely the one dominating fewer columns in the observed examples.\n    # If counts are equal, use a fallback heuristic (fewer structures overall).\n    if len(cols_dominated_by_c1) < len(cols_dominated_by_c2):\n        v_color, h_color = color1, color2\n        v_indices = cols_dominated_by_c1\n        h_count = len(rows_dominated_by_c2)\n    elif len(cols_dominated_by_c2) < len(cols_dominated_by_c1):\n        v_color, h_color = color2, color1\n        v_indices = cols_dominated_by_c2\n        h_count = len(rows_dominated_by_c1)\n    # Fallback heuristic for ties or ambiguity\n    elif (len(cols_dominated_by_c1)+len(rows_dominated_by_c1)) < (len(cols_dominated_by_c2)+len(rows_dominated_by_c2)):\n            v_color, h_color = color1, color2\n            v_indices = cols_dominated_by_c1\n            h_count = len(rows_dominated_by_c2)\n    elif (len(cols_dominated_by_c1)+len(rows_dominated_by_c1)) > (len(cols_dominated_by_c2)+len(rows_dominated_by_c2)):\n            v_color, h_color = color2, color1\n            v_indices = cols_dominated_by_c2\n            h_count = len(rows_dominated_by_c1)\n    else:\n        # If still tied, perhaps default based on color index or return None\n        # Let's assume based on examples that vertical structures are 'less numerous'\n        # If column counts are equal, maybe check row counts?\n        if len(rows_dominated_by_c1) > len(rows_dominated_by_c2): # c1 is more horizontal\n             v_color, h_color = color2, color1\n             v_indices = cols_dominated_by_c2\n             h_count = len(rows_dominated_by_c1)\n        else: # c2 is more horizontal (or equal)\n             v_color, h_color = color1, color2\n             v_indices = cols_dominated_by_c1\n             h_count = len(rows_dominated_by_c2)\n\n\n    if not v_indices: # Need vertical structures to modify\n        return None\n\n    v_indices.sort() # Ensure consistent order for selection\n\n    return {\n        \"H_Color\": h_color,\n        \"H_Count\": h_count,\n        \"V_Color\": v_color,\n        \"V_Indices\": v_indices,\n    }\n\n\ndef _select_target_indices(v_indices, h_count):\n    \"\"\"\n    Selects the target column indices based on the horizontal count.\n\n    Args:\n        v_indices (list): Sorted list of vertical structure column indices.\n        h_count (int): Count of horizontal structures.\n\n    Returns:\n        list: The target column indices to modify.\n    \"\"\"\n    target_indices = []\n    num_v_lines = len(v_indices)\n\n    if num_v_lines == 0:\n        return []\n\n    if h_count >= 3:\n        # Select the middle index. Index at position N // 2\n        middle_idx_pos = num_v_lines // 2\n        target_indices.append(v_indices[middle_idx_pos])\n    elif h_count == 2:\n        # Select the minimum (leftmost) index\n        target_indices.append(min(v_indices))\n    elif h_count == 1:\n        # Select the maximum (rightmost) index\n        target_indices.append(max(v_indices))\n        \n    return target_indices\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_np = np.array(input_grid, dtype=int)\n    # Initialize output grid as a copy of the input\n    output_np = np.copy(input_np)\n\n    # 1. Identify dominant colors, structures, counts, and indices\n    color_info = _get_dominant_color_info(input_np)\n\n    # If the expected pattern (2 non-bg colors, distinct structures) isn't found, return the original grid\n    if color_info is None:\n        return input_grid\n\n    h_count = color_info[\"H_Count\"]\n    v_color = color_info[\"V_Color\"]\n    v_indices = color_info[\"V_Indices\"]\n\n    # 2. Determine the target column index/indices to modify based on H_Count\n    target_indices = _select_target_indices(v_indices, h_count)\n\n    # 3. Modify the output grid\n    if target_indices:\n        for col_index in target_indices:\n            # In the target column(s), find pixels with V_Color\n            mask = output_np[:, col_index] == v_color\n            # Change those pixels to background color (0)\n            output_np[mask, col_index] = 0\n\n    # Convert the result back to a list of lists\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11039,
    "candidates_token_count": 1996,
    "total_token_count": 13035,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.504247,
  "retries": 1
}