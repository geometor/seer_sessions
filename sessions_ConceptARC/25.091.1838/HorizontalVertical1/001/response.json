{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies contiguous regions of white pixels (0) that are not connected to the grid border (internal regions).\nFor each such internal region, it checks if it is bounded by a single, uniform non-white color.\nIf it is, it determines if the region is partially enclosed (connected to the border white region via adjacency, C-like) or fully enclosed (O-like).\nBased on the boundary color and enclosure type, it fills the internal region with a new color:\n- Partially enclosed (C-like): Fill with Green (3).\n- Fully enclosed (O-like):\n    - Boundary Red (2) or Yellow (4): Fill with Orange (7).\n    - Boundary Orange (7): Fill with Green (3).\nThe original non-white shapes and the background white region remain unchanged.\n\"\"\"\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the output grid.\n    \"\"\"\n    input_grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Keep track of visited pixels during flood fills\n    visited = np.zeros_like(input_grid, dtype=bool)\n    # Keep track of pixels belonging to the background white region\n    is_background = np.zeros_like(input_grid, dtype=bool)\n\n    q = deque()\n\n    # 1. Identify the background white region (connected to borders) using BFS\n    for r in range(height):\n        for c in [0, width - 1]: # Left and right borders\n            if input_grid[r, c] == 0 and not visited[r, c]:\n                visited[r, c] = True\n                is_background[r, c] = True\n                q.append((r, c))\n    for c in range(width):\n        for r in [0, height - 1]: # Top and bottom borders\n             if input_grid[r, c] == 0 and not visited[r, c]:\n                visited[r, c] = True\n                is_background[r, c] = True\n                q.append((r, c))\n\n    while q:\n        r, c = q.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # 4-directional neighbors\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width and \\\n               input_grid[nr, nc] == 0 and not visited[nr, nc]:\n                visited[nr, nc] = True\n                is_background[nr, nc] = True\n                q.append((nr, nc))\n\n    # 2. Iterate through the grid to find internal white regions\n    for r in range(height):\n        for c in range(width):\n            # If it's a white pixel and hasn't been visited (i.e., not background)\n            if input_grid[r, c] == 0 and not visited[r, c]:\n                \n                # Start a BFS for this potential internal region\n                internal_q = deque([(r, c)])\n                visited[r, c] = True\n                current_region_pixels = [(r, c)]\n                boundary_neighbors = set() # Store (nr, nc, color) tuples\n                is_partially_enclosed = False \n\n                while internal_q:\n                    curr_r, curr_c = internal_q.popleft()\n\n                    # Check neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < height and 0 <= nc < width:\n                            neighbor_color = input_grid[nr, nc]\n                            \n                            if neighbor_color == 0:\n                                # Check if adjacent to known background\n                                if is_background[nr, nc]:\n                                    is_partially_enclosed = True\n                                \n                                # If this white neighbor hasn't been visited, add to queue\n                                if not visited[nr, nc]:\n                                    visited[nr, nc] = True\n                                    internal_q.append((nr, nc))\n                                    current_region_pixels.append((nr, nc))\n                            else:\n                                # It's a non-white boundary neighbor\n                                boundary_neighbors.add((nr, nc, neighbor_color))\n                        # else: neighbor is out of bounds, implicitly connected to 'outside'\n                        # This doesn't directly make it partially enclosed by our definition,\n                        # which relies on connection to the *white* background region.\n                        \n                # 3. Analyze the found region\n                boundary_colors = set(color for _, _, color in boundary_neighbors)\n\n                # Check if bounded by a single color\n                if len(boundary_colors) == 1:\n                    boundary_color = list(boundary_colors)[0]\n                    fill_color = -1 # Use -1 to indicate no fill initially\n\n                    # Determine fill color based on rules\n                    if is_partially_enclosed:\n                        # C-like shape rule\n                        fill_color = 3 # Green\n                    else:\n                        # O-like shape rule\n                        if boundary_color == 2 or boundary_color == 4: # Red or Yellow\n                            fill_color = 7 # Orange\n                        elif boundary_color == 7: # Orange\n                            fill_color = 3 # Green\n                            \n                    # 4. Apply fill if a color was determined\n                    if fill_color != -1:\n                        for pr, pc in current_region_pixels:\n                            output_grid[pr, pc] = fill_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3690,
    "candidates_token_count": 1395,
    "total_token_count": 5085,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.766348,
  "retries": 1
}