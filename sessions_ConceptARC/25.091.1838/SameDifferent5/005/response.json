{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentify distinct contiguous non-white regions (blobs) in the input grid using \n8-way adjacency. For each blob, determine if it consists of exactly two \nnon-white colors where one color (the center color) is topologically enclosed \nby the other color (the frame color). A color is considered topologically \nenclosed if all its pixels within the blob only have neighbors (8-connectivity) \nthat are either the frame color or the center color itself; specifically, no \nneighbor of a center pixel can be the background color (0) or any other color \nnot belonging to the blob. Collect all identified center colors from all such \nvalid frame/center blobs. The final output is a 1x1 grid containing the center \ncolor that appears most frequently across all identified blobs. If there is a \ntie in frequency, the color with the highest numerical value is chosen. If no \nsuch frame/center blobs are found, the output is white (0).\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"\n    Gets valid neighbor coordinates for a given pixel.\n\n    Args:\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n        height (int): Grid height.\n        width (int): Grid width.\n        connectivity (int): 4 or 8 for neighbor connectivity.\n\n    Returns:\n        list: A list of (row, col) tuples for valid neighbors.\n    \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            # Skip self\n            if dr == 0 and dc == 0: \n                continue\n            # Skip diagonals for 4-connectivity if specified\n            if connectivity == 4 and abs(dr) + abs(dc) != 1: \n                continue\n            nr, nc = r + dr, c + dc\n            # Check grid boundaries\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_blobs(grid):\n    \"\"\"\n    Finds all distinct contiguous regions (blobs) of non-white pixels using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list where each element is a set of (row, col) tuples \n              representing the coordinates of a single blob's pixels.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    blobs = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS from a non-white, unvisited pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_blob_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_blob_coords.add((curr_r, curr_c))\n                    \n                    # Explore neighbors (using 8-connectivity for blob definition)\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=8):\n                        # Add neighbor if it's non-white and not visited\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Add the found blob to the list\n                if current_blob_coords:\n                     blobs.append(current_blob_coords)\n    return blobs\n\ndef is_topologically_enclosed(center_pixels, center_color, frame_color, grid, height, width):\n    \"\"\"\n    Checks if the set of center_pixels is topologically enclosed by the frame_color.\n    A pixel is enclosed if all its 8 neighbors are either the center_color or the frame_color.\n    \n    Args:\n        center_pixels (set): Set of (r, c) coordinates for the candidate center pixels.\n        center_color (int): The color value of the candidate center.\n        frame_color (int): The color value of the candidate frame.\n        grid (np.array): The input grid.\n        height (int): Grid height.\n        width (int): Grid width.\n\n    Returns:\n        bool: True if all center_pixels are enclosed, False otherwise.\n    \"\"\"\n    for r, c in center_pixels:\n        # Check all 8 neighbors\n        for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n            neighbor_color = grid[nr, nc]\n            # If any neighbor is NOT the center color and NOT the frame color, it's not enclosed.\n            if neighbor_color != center_color and neighbor_color != frame_color:\n                return False # Found a neighbor that breaks the enclosure rule\n    return True # All neighbors of all center pixels are valid\n\ndef analyze_blob_for_center(blob_coords, grid):\n    \"\"\"\n    Analyzes a blob to find if it has a valid frame/center structure \n    based on topological enclosure and returns the center color.\n\n    Args:\n        blob_coords (set): Set of (row, col) tuples for the blob pixels.\n        grid (np.array): The input grid.\n\n    Returns:\n        int or None: The center color if found, otherwise None.\n    \"\"\"\n    if not blob_coords:\n        return None\n\n    height, width = grid.shape\n    pixel_map = {} # color -> set of coords\n    \n    # Collect colors and their pixel locations within the blob\n    for r, c in blob_coords:\n        color = grid[r, c]\n        # Should always be non-white based on find_blobs logic\n        if color not in pixel_map:\n            pixel_map[color] = set()\n        pixel_map[color].add((r,c))\n\n    # A valid frame/center blob must have exactly two distinct non-white colors\n    non_white_colors = list(pixel_map.keys())\n    if len(non_white_colors) != 2:\n        return None \n\n    c1, c2 = non_white_colors[0], non_white_colors[1]\n    c1_pixels = pixel_map[c1]\n    c2_pixels = pixel_map[c2]\n    \n    # Check if c1 is enclosed by c2\n    c1_is_enclosed = is_topologically_enclosed(c1_pixels, c1, c2, grid, height, width)\n    \n    # Check if c2 is enclosed by c1\n    c2_is_enclosed = is_topologically_enclosed(c2_pixels, c2, c1, grid, height, width)\n\n    # Return the center color if exactly one color is enclosed by the other\n    if c1_is_enclosed and not c2_is_enclosed:\n        return c1 \n    elif c2_is_enclosed and not c1_is_enclosed:\n        return c2\n    else:\n        # Ambiguous or invalid structure (e.g., adjacent, neither enclosed, or both enclosed)\n        return None\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding frame/center objects, identifying \n    their center colors based on topological enclosure, and returning the \n    most frequent center color (highest value in case of ties).\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: A 1x1 grid containing the most frequent center color.\n    \"\"\"\n    \n    # Step 1: Find all distinct contiguous non-white blobs\n    blobs = find_blobs(input_grid)\n    \n    # Step 2: Analyze each blob to identify center colors based on enclosure\n    center_colors_found = []\n    for blob_coords in blobs:\n        center_color = analyze_blob_for_center(blob_coords, input_grid)\n        # If a valid center color was identified for this blob, add it to the list\n        if center_color is not None:\n            center_colors_found.append(center_color)\n\n    # Step 3: Count frequencies of the identified center colors\n    output_color = 0 # Default to white (0) if no valid centers found\n    if center_colors_found:\n        color_counts = Counter(center_colors_found)\n        \n        # Step 4: Find the maximum frequency\n        max_freq = 0\n        # Check if counter is not empty before finding max\n        if color_counts: \n             max_freq = max(color_counts.values())\n\n        # Step 5: Find all colors that have this maximum frequency\n        most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n        # Step 6: Apply tie-breaking rule: select the color with the highest numerical value\n        if most_frequent_colors:\n            output_color = max(most_frequent_colors)\n\n    # Step 7: Create the 1x1 output grid\n    output_grid = np.array([[output_color]], dtype=int)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10734,
    "candidates_token_count": 2181,
    "total_token_count": 12915,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.158998,
  "retries": 1
}