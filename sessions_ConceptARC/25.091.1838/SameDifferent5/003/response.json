{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentify distinct contiguous non-white regions (blobs) in the input grid. \nFor each blob, determine if it consists of exactly two non-white colors where \none color (the center color) is topologically enclosed by the other color (the \nframe color). A color is considered enclosed if all its pixels within the blob \nonly have neighbors (8-connectivity) that are either the background color (0), \nthe frame color, or the center color itself. Collect all identified center \ncolors from all such valid frame/center blobs. The final output is a 1x1 grid \ncontaining the center color that appears most frequently across all identified \nblobs. If there is a tie in frequency, the color with the highest numerical \nvalue is chosen.\n\"\"\"\n\ndef get_neighbors(r, c, height, width, connectivity=8):\n    \"\"\"\n    Gets valid neighbor coordinates for a given pixel.\n\n    Args:\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n        height (int): Grid height.\n        width (int): Grid width.\n        connectivity (int): 4 or 8 for neighbor connectivity.\n\n    Returns:\n        list: A list of (row, col) tuples for valid neighbors.\n    \"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0: continue # Skip self\n            if connectivity == 4 and abs(dr) + abs(dc) != 1: continue # Skip diagonals for 4-connectivity\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width:\n                neighbors.append((nr, nc))\n    return neighbors\n\ndef find_blobs(grid):\n    \"\"\"\n    Finds all distinct contiguous regions (blobs) of non-white pixels.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list where each element is a list of (row, col) tuples \n              representing the coordinates of a single blob.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    blobs = []\n\n    for r in range(height):\n        for c in range(width):\n            # Start BFS from a non-white, unvisited pixel\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_blob_coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    curr_r, curr_c = q.popleft()\n                    current_blob_coords.append((curr_r, curr_c))\n                    \n                    # Explore neighbors (using 8-connectivity for blob definition)\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width, connectivity=8):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                if current_blob_coords:\n                     blobs.append(current_blob_coords)\n    return blobs\n\ndef analyze_blob_for_center(blob_coords, grid):\n    \"\"\"\n    Analyzes a blob to find if it has a frame/center structure and returns the center color.\n\n    Args:\n        blob_coords (list): List of (row, col) tuples for the blob pixels.\n        grid (np.array): The input grid.\n\n    Returns:\n        int or None: The center color if found, otherwise None.\n    \"\"\"\n    if not blob_coords:\n        return None\n\n    height, width = grid.shape\n    blob_colors = set()\n    pixel_map = {} # color -> list of coords\n    \n    # Collect colors and their pixel locations within the blob\n    for r, c in blob_coords:\n        color = grid[r, c]\n        if color != 0: # Ignore background if somehow included (shouldn't happen with find_blobs)\n            blob_colors.add(color)\n            if color not in pixel_map:\n                pixel_map[color] = []\n            pixel_map[color].append((r,c))\n\n    # A valid frame/center blob must have exactly two non-white colors\n    non_white_colors = list(blob_colors)\n    if len(non_white_colors) != 2:\n        return None \n\n    c1, c2 = non_white_colors[0], non_white_colors[1]\n    c1_pixels = pixel_map[c1]\n    c2_pixels = pixel_map[c2]\n    \n    # Helper to check if a color is enclosed by the other within the blob context\n    def is_topologically_enclosed(center_candidate_pixels, center_candidate_color, frame_candidate_color):\n        for r, c in center_candidate_pixels:\n            # Check all 8 neighbors\n            for nr, nc in get_neighbors(r, c, height, width, connectivity=8):\n                neighbor_color = grid[nr, nc]\n                # A neighbor is invalid if it's NOT background, NOT the center color itself, and NOT the frame color\n                if neighbor_color != 0 and neighbor_color != center_candidate_color and neighbor_color != frame_candidate_color:\n                    return False # Found a neighbor that breaks the enclosure rule\n        return True # All neighbors of all center pixels are valid\n\n    # Check if c1 is enclosed by c2\n    c1_is_center = is_topologically_enclosed(c1_pixels, c1, c2)\n    # Check if c2 is enclosed by c1\n    c2_is_center = is_topologically_enclosed(c2_pixels, c2, c1)\n\n    # Return the center color if exactly one color is enclosed by the other\n    if c1_is_center and not c2_is_center:\n        return c1 \n    elif c2_is_center and not c1_is_center:\n        return c2\n    else:\n        # Ambiguous or invalid structure (e.g., adjacent, neither enclosed, or both somehow seem enclosed)\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by finding frame/center objects, identifying \n    their center colors, and returning the most frequent center color.\n\n    Args:\n        input_grid (np.array): The 2D input grid.\n\n    Returns:\n        np.array: A 1x1 grid containing the most frequent center color.\n    \"\"\"\n    \n    # Step 1: Find all distinct non-white blobs\n    blobs = find_blobs(input_grid)\n    \n    # Step 2: Analyze each blob to identify center colors\n    center_colors_found = []\n    for blob_coords in blobs:\n        center_color = analyze_blob_for_center(blob_coords, input_grid)\n        if center_color is not None:\n            center_colors_found.append(center_color)\n\n    # Step 3: Count frequencies of center colors\n    output_color = 0 # Default to white if no center colors found\n    if center_colors_found:\n        color_counts = Counter(center_colors_found)\n        \n        # Step 4: Find the maximum frequency\n        max_freq = 0\n        if color_counts: # Ensure counter is not empty\n             max_freq = max(color_counts.values())\n\n        # Step 5: Find all colors with the maximum frequency (handle ties)\n        most_frequent_colors = [color for color, count in color_counts.items() if count == max_freq]\n\n        # Step 6: Select the color with the highest numerical value in case of a tie\n        if most_frequent_colors:\n            output_color = max(most_frequent_colors)\n\n    # Step 7: Create the 1x1 output grid\n    output_grid = np.array([[output_color]], dtype=int)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 11995,
    "candidates_token_count": 1912,
    "total_token_count": 13907,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.925233,
  "retries": 1
}