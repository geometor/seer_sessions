{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the presence and location of white (0) pixels.\n\nIf white pixels (color 0) exist, touch the grid's perimeter, and non-white pixels also exist, \nthen the transformation preserves the white pixels and replaces all non-white pixels with the \nsingle most frequent non-white color found in the input grid.\n\nOtherwise (if white pixels are absent, don't touch the perimeter, or no non-white pixels exist), \nthe transformation replaces the entire grid with the single most frequent color found in the \noverall input grid.\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\ndef _check_perimeter_touch(grid_array, color_value):\n    \"\"\"\n    Checks if any pixel of the specified color touches the outer perimeter of the grid.\n\n    Args:\n        grid_array (np.array): The input grid as a NumPy array.\n        color_value (int): The color value to check for.\n\n    Returns:\n        bool: True if the color touches the perimeter, False otherwise.\n    \"\"\"\n    height, width = grid_array.shape\n    if height == 0 or width == 0:\n        return False\n    \n    # Check top row\n    if height > 0 and np.any(grid_array[0, :] == color_value):\n        return True\n    # Check bottom row (only check if height > 1 to avoid double-checking single row)\n    if height > 1 and np.any(grid_array[-1, :] == color_value):\n        return True\n    # Check left column\n    if width > 0 and np.any(grid_array[:, 0] == color_value):\n        return True\n    # Check right column (only check if width > 1 to avoid double-checking single column)\n    if width > 1 and np.any(grid_array[:, -1] == color_value):\n        return True\n        \n    return False\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the conditional homogenization transformation to the input grid.\n\n    Args:\n        input_grid (list of lists): A 2D list representing the input grid.\n\n    Returns:\n        list of lists: A 2D list representing the transformed output grid.\n    \"\"\"\n    # Convert input to NumPy array for efficient processing\n    input_array = np.array(input_grid, dtype=int)\n    height, width = input_array.shape\n\n    # Handle empty grid case\n    if height == 0 or width == 0:\n        return []\n\n    # --- Analysis Step ---\n    \n    # Flatten the grid to easily count all pixels\n    all_pixels = input_array.flatten()\n    if all_pixels.size == 0: \n        return [] # Safety check for edge cases like 1x0 grid\n\n    # 1. Count all pixel colors\n    color_counts = Counter(all_pixels)\n    \n    # 2. Check the three conditions for the special 'white frame' logic\n    # Condition 1: Does white (0) exist?\n    has_white_pixels = 0 in color_counts\n    \n    # Condition 2: Does white touch the perimeter?\n    white_touches_perimeter = False\n    if has_white_pixels:\n        # Use helper function to check perimeter\n        white_touches_perimeter = _check_perimeter_touch(input_array, 0)\n        \n    # Condition 3: Do non-white pixels exist?\n    has_non_white_pixels = any(color != 0 for color in color_counts)\n    \n    # Determine if the special white frame logic applies based on the three conditions\n    apply_white_frame_logic = has_white_pixels and white_touches_perimeter and has_non_white_pixels\n\n    # --- Transformation Step ---\n    \n    # Initialize output array (content will be overwritten)\n    # Using zeros_like ensures the same shape and type\n    output_array = np.zeros_like(input_array) \n\n    if apply_white_frame_logic:\n        # Branch 1: Preserve white, fill rest with dominant non-white color\n        \n        # Find all non-white pixels\n        non_white_pixels = all_pixels[all_pixels != 0]\n        # We know non_white_pixels is not empty because has_non_white_pixels is True\n        \n        # Count frequencies of non-white pixels\n        interior_counts = Counter(non_white_pixels)\n        \n        # Find the most frequent non-white color\n        dominant_interior_color = interior_counts.most_common(1)[0][0]\n        \n        # Create output grid: Start by filling everything with the dominant non-white color\n        output_array = np.full_like(input_array, dominant_interior_color) \n        \n        # Identify the locations of the original white pixels\n        white_mask = (input_array == 0)\n        \n        # Put the white pixels (0) back into the output grid at their original locations\n        output_array[white_mask] = 0 \n\n    else:\n        # Branch 2: Fill entire grid with the overall dominant color\n        \n        # Find the most frequent color among ALL pixels (calculated earlier in color_counts)\n        dominant_overall_color = color_counts.most_common(1)[0][0]\n        \n        # Create output grid filled entirely with the overall dominant color\n        output_array = np.full_like(input_array, dominant_overall_color)\n\n    # Convert the final NumPy array back to the required list of lists format\n    output_grid = output_array.tolist()\n    \n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12459,
    "candidates_token_count": 1294,
    "total_token_count": 13753,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 15.962906,
  "retries": 1
}