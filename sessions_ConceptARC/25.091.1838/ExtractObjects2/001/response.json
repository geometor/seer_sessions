{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a target color that forms exactly one contiguous object in the input grid. \nFinds the bounding box of this target object.\nExtracts the subgrid corresponding to the bounding box.\nFilters the extracted subgrid: keeps pixels of the target color and white (0), \nreplaces all other colors with white (0).\nThe final filtered subgrid is the output.\n\"\"\"\n\ndef find_objects(grid, color):\n    \"\"\"\n    Finds all contiguous objects of a given color in the grid using 4-way adjacency.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color to search for.\n\n    Returns:\n        list[set]: A list where each element is a set of (row, col) tuples \n                   representing a contiguous object.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set()\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == color and (r, c) not in visited:\n                # Start BFS for a new object\n                current_object = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_object.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = curr_r + dr, curr_c + dc\n\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr, nc] == color and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_object.add((nr, nc))\n                            q.append((nr, nc))\n                \n                objects.append(current_object)\n    return objects\n\ndef get_bounding_box(obj_coords):\n    \"\"\"\n    Calculates the bounding box for a set of coordinates.\n\n    Args:\n        obj_coords (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_row, max_row, min_col, max_col) or None if obj_coords is empty.\n    \"\"\"\n    if not obj_coords:\n        return None\n    \n    rows = [r for r, c in obj_coords]\n    cols = [c for r, c in obj_coords]\n    \n    min_row = min(rows)\n    max_row = max(rows)\n    min_col = min(cols)\n    max_col = max(cols)\n    \n    return min_row, max_row, min_col, max_col\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on the described logic.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    rows, cols = input_np.shape\n    \n    # --- Workflow ---\n    \n    # 1. Analyze the input grid to identify all unique non-white colors present.\n    unique_colors = np.unique(input_np)\n    non_white_colors = [color for color in unique_colors if color != 0]\n\n    target_color = -1 # Initialize with an invalid value\n    target_object_coords = None \n\n    # 2. For each unique non-white color, determine the number of distinct contiguous objects.\n    # 3. Identify the 'target color' as the color that forms exactly one contiguous object.\n    for color in non_white_colors:\n        objects = find_objects(input_np, color)\n        if len(objects) == 1:\n            # Check if we already found a target color (ambiguous case, though not in examples)\n            if target_color != -1:\n                # Handle ambiguity if necessary, for now assume it won't happen based on examples\n                # print(f\"Warning: Multiple colors ({target_color}, {color}) form exactly one object.\")\n                pass # Or raise an error, or prioritize based on some rule\n            target_color = color\n            target_object_coords = objects[0]\n            # Optimization: if we found one, we can potentially break if ambiguity isn't expected\n            # break \n            \n    # Handle case where no target color is found\n    if target_color == -1:\n        # Return empty grid or handle error as appropriate for the broader ARC context\n        # Based on examples, this shouldn't happen. Maybe return the input? Or empty grid?\n        # Let's return an empty grid for now.\n        print(\"Warning: No color found that forms exactly one object.\")\n        return [] \n\n    # 4. Find the minimum bounding box of the target color object.\n    min_row, max_row, min_col, max_col = get_bounding_box(target_object_coords)\n\n    # 5. Determine the height and width of the output grid.\n    # (Implicitly done by slicing)\n    \n    # 6. Create a new grid (the output grid) by extracting the subgrid.\n    extracted_grid = input_np[min_row:max_row+1, min_col:max_col+1]\n    \n    # 7-11. Filter the extracted grid.\n    output_grid = np.copy(extracted_grid)\n    output_rows, output_cols = output_grid.shape\n    for r in range(output_rows):\n        for c in range(output_cols):\n            pixel_color = extracted_grid[r, c]\n            if pixel_color != target_color and pixel_color != 0:\n                output_grid[r, c] = 0 # Replace non-target, non-white colors with white\n\n    # 12. Return the resulting grid as a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3580,
    "candidates_token_count": 1396,
    "total_token_count": 4976,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.226652,
  "retries": 1
}