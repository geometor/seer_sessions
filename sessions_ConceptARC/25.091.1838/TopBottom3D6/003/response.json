{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms an input grid based on the following rules:\n1. Find all unique non-white colors in the input grid.\n2. For each color, determine its bounding box (min/max row/col), its dimensions (height, width), and the count of its pixels.\n3. Identify colors whose bounding box height equals the input grid height.\n4. If exactly one such color exists, select it as the target color.\n5. If not (zero or multiple colors match the input height), find the maximum bounding box width among all non-white colors.\n6. Identify all colors having this maximum width.\n7. If exactly one such color exists, select it as the target color.\n8. If multiple colors have the maximum width, select the one among them with the minimum pixel count.\n9. Create an output grid whose dimensions match the bounding box dimensions (height, width) of the selected target color.\n10. Fill the output grid entirely with the selected target color.\n\"\"\"\n\nimport numpy as np\nfrom collections import defaultdict\n\ndef find_bounding_box_and_pixels(grid_np, color):\n    \"\"\"\n    Finds the minimum bounding box containing all pixels of a given color\n    and counts the pixels of that color.\n\n    Args:\n        grid_np (np.array): The input grid as a numpy array.\n        color (int): The color value to find.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c, height, width, pixel_count)\n               Returns None for coords/dims if color not found, pixel_count is 0.\n    \"\"\"\n    coords = np.argwhere(grid_np == color)\n    pixel_count = coords.shape[0]\n\n    if pixel_count == 0:\n        return None, None, None, None, 0, 0, 0\n\n    min_r, min_c = coords.min(axis=0)\n    max_r, max_c = coords.max(axis=0)\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    return min_r, min_c, max_r, max_c, height, width, pixel_count\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array\n    grid_np = np.array(input_grid, dtype=int)\n    input_h, input_w = grid_np.shape\n\n    # Find unique non-white colors and their properties\n    unique_colors = np.unique(grid_np)\n    non_white_colors = unique_colors[unique_colors != 0]\n\n    if non_white_colors.size == 0:\n        # Handle case with no non-white colors - return empty or based on spec\n        return np.array([[]], dtype=int) # Return empty grid\n\n    color_properties = {}\n    for color in non_white_colors:\n        min_r, min_c, max_r, max_c, height, width, pixel_count = find_bounding_box_and_pixels(grid_np, color)\n        if pixel_count > 0:\n            color_properties[color] = {\n                \"height\": height,\n                \"width\": width,\n                \"pixels\": pixel_count\n            }\n\n    target_color = -1\n    target_height = -1\n    target_width = -1\n\n    # --- Selection Logic ---\n\n    # Criterion 1: Check for unique color with bounding box height matching input height\n    full_height_colors = [\n        color for color, props in color_properties.items()\n        if props[\"height\"] == input_h\n    ]\n\n    if len(full_height_colors) == 1:\n        target_color = full_height_colors[0]\n        target_height = color_properties[target_color][\"height\"]\n        target_width = color_properties[target_color][\"width\"]\n    else:\n        # Criterion 2: Find max width among all colors\n        max_width = 0\n        for color, props in color_properties.items():\n            if props[\"width\"] > max_width:\n                max_width = props[\"width\"]\n\n        max_width_colors = [\n            color for color, props in color_properties.items()\n            if props[\"width\"] == max_width\n        ]\n\n        if len(max_width_colors) == 1:\n            # If only one color has the max width, select it\n            target_color = max_width_colors[0]\n            target_height = color_properties[target_color][\"height\"]\n            target_width = color_properties[target_color][\"width\"]\n        elif len(max_width_colors) > 1:\n            # Criterion 3 (Tie-breaking): Min pixel count among max-width colors\n            min_pixels = float('inf')\n            candidate_color = -1\n            for color in max_width_colors:\n                if color_properties[color][\"pixels\"] < min_pixels:\n                    min_pixels = color_properties[color][\"pixels\"]\n                    candidate_color = color\n                # Optional: Add tie-breaking based on color index if pixel counts are also tied\n                # elif color_properties[color][\"pixels\"] == min_pixels:\n                #     if candidate_color == -1 or color < candidate_color: # Lower color index breaks tie\n                #         candidate_color = color\n\n            target_color = candidate_color\n            if target_color != -1:\n                target_height = color_properties[target_color][\"height\"]\n                target_width = color_properties[target_color][\"width\"]\n            else:\n                 # This state should ideally not be reached if there are colors\n                 return np.array([[]], dtype=int) # Failsafe\n\n\n        else: # No non-white colors found (already handled) or issue finding max width\n             return np.array([[]], dtype=int) # Failsafe\n\n    # Check if a valid target was found\n    if target_color == -1 or target_height <= 0 or target_width <= 0:\n         # This case indicates an issue in logic or unexpected input\n         # Maybe default to input or a specific small grid?\n         print(f\"Warning: Could not determine target color or dimensions. Target Color: {target_color}, H: {target_height}, W: {target_width}\")\n         return np.array([[]], dtype=int) # Failsafe empty grid\n\n\n    # --- Output Generation ---\n    # Create the output grid with the target dimensions and fill it with the target color\n    output_grid = np.full((target_height, target_width), target_color, dtype=int)\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7184,
    "candidates_token_count": 1564,
    "total_token_count": 8748,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.509986,
  "retries": 1
}