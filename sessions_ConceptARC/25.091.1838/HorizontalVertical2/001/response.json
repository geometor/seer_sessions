{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify two distinct, separated non-white patterns in the input grid. \nOne pattern will exhibit horizontal stripes (colors change primarily vertically), \nand the other will exhibit vertical stripes (colors change primarily horizontally).\nThe transformation rule is to isolate and keep only the pattern with horizontal stripes, \nplacing it in its original position on an otherwise white background grid of the same dimensions.\nThe pattern with vertical stripes and any separating white pixels are discarded.\n\"\"\"\n\ndef _get_neighbors(coord, max_rows, max_cols):\n    \"\"\"Gets valid neighbor coordinates (up, down, left, right).\"\"\"\n    r, c = coord\n    neighbors = []\n    if r > 0:\n        neighbors.append((r - 1, c))\n    if r < max_rows - 1:\n        neighbors.append((r + 1, c))\n    if c > 0:\n        neighbors.append((r, c - 1))\n    if c < max_cols - 1:\n        neighbors.append((r, c + 1))\n    return neighbors\n\ndef _find_objects(grid):\n    \"\"\"Finds connected components of non-white pixels.\"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-white pixel and not yet visited\n            if grid[r, c] != 0 and not visited[r, c]:\n                current_object_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    \n                    # Explore neighbors\n                    for nr, nc in _get_neighbors((row, col), rows, cols):\n                        if grid[nr, nc] != 0 and not visited[nr, nc]:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                if current_object_coords:\n                    objects.append(current_object_coords)\n                    \n    # Simple filter: Assume the two largest objects are the patterns\n    # This helps ignore small noise pixels if any exist.\n    if len(objects) > 2:\n        objects.sort(key=len, reverse=True)\n        return objects[:2]\n        \n    return objects\n\ndef _get_stripe_orientation(grid, object_coords):\n    \"\"\"Determines if an object has horizontal or vertical stripes.\"\"\"\n    if not object_coords:\n        return 'unknown'\n\n    horizontal_changes = 0\n    vertical_changes = 0\n\n    for r, c in object_coords:\n        # Check right neighbor\n        right_neighbor = (r, c + 1)\n        if right_neighbor in object_coords and grid[r, c] != grid[right_neighbor]:\n            horizontal_changes += 1\n            \n        # Check bottom neighbor\n        bottom_neighbor = (r + 1, c)\n        if bottom_neighbor in object_coords and grid[r, c] != grid[bottom_neighbor]:\n            vertical_changes += 1\n\n    # If colors change more often vertically, the stripes are horizontal.\n    if vertical_changes > horizontal_changes:\n        return 'horizontal'\n    # If colors change more often horizontally, the stripes are vertical.\n    elif horizontal_changes > vertical_changes:\n        return 'vertical'\n    # Handle cases with no changes or equal changes (e.g., solid color blocks)\n    # Based on the task examples, we expect clear differentiation.\n    # If an object is a single row/column of alternating colors, this logic holds.\n    # If it's ambiguous, classify as 'unknown'.\n    else: \n         # If it's a single line/solid block, default check.\n         # A single row object -> vertical stripes (changes are horizontal)\n         # A single col object -> horizontal stripes (changes are vertical)\n         rows = {r for r, c in object_coords}\n         cols = {c for r, c in object_coords}\n         if len(rows) == 1 and len(cols) > 1 and horizontal_changes > 0:\n             return 'vertical'\n         if len(cols) == 1 and len(rows) > 1 and vertical_changes > 0:\n             return 'horizontal'\n         # Otherwise, truly ambiguous or uniform color\n         return 'unknown' \n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by isolating the pattern with horizontal stripes.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    rows, cols = input_array.shape\n    \n    # Initialize output grid with background color (white, 0)\n    output_grid = np.zeros_like(input_array, dtype=int)\n\n    # Find all non-white connected objects\n    objects = _find_objects(input_array)\n\n    # Expecting exactly two main objects based on examples\n    if len(objects) != 2:\n        # If not exactly two objects found, return empty grid or handle error\n        # For this task, the structure seems consistent. Let's find the horizontal one if possible.\n        # pass # Re-evaluate if this happens in tests\n        pass # Continue to see if one has horizontal stripes\n        \n    horizontal_stripe_object_coords = None\n\n    # Identify the object with horizontal stripes\n    for obj_coords in objects:\n        orientation = _get_stripe_orientation(input_array, obj_coords)\n        if orientation == 'horizontal':\n            # Ensure only one horizontal object is found, otherwise ambiguous\n            if horizontal_stripe_object_coords is not None:\n                 # Ambiguous case: found more than one horizontal pattern\n                 return output_grid.tolist() # Return empty grid\n            horizontal_stripe_object_coords = obj_coords\n\n    # If a horizontal stripe object was successfully identified\n    if horizontal_stripe_object_coords:\n        # Copy the pixels of the selected object to the output grid\n        for r, c in horizontal_stripe_object_coords:\n            # Check bounds just in case, though coordinates should be valid\n            if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = input_array[r, c]\n\n    # Return the result as a list of lists\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3769,
    "candidates_token_count": 1498,
    "total_token_count": 5267,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 29.026936,
  "retries": 1
}