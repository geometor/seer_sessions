{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import namedtuple\n\nBlock = namedtuple('Block', ['color', 'height', 'width', 'top_row', 'left_col'])\n\n\"\"\"\nIdentify distinct horizontal rectangular blocks of non-background color in the input grid.\nSort these blocks based on their width in ascending order.\nReconstruct the output grid by placing the sorted blocks vertically, starting from the minimum top row occupied by any block in the input, preserving their original height, width, color, and horizontal position (starting at column 0).\n\"\"\"\n\ndef find_blocks(grid):\n    \"\"\"\n    Finds all distinct horizontal rectangular blocks of non-background color.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of Block namedtuples, each containing color, height, width, top_row, left_col.\n              Returns an empty list if no blocks are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    min_top_row = height # Initialize with a value larger than any possible row index\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                block_height = 0\n                block_width = 0\n\n                # Find width\n                curr_c = c\n                while curr_c < width and grid[r, curr_c] == color and not visited[r, curr_c]:\n                     # Check if this pixel starts a new potential block width-wise\n                     if c == curr_c or grid[r, curr_c-1] != color:\n                          potential_width = 0\n                          temp_c = curr_c\n                          while temp_c < width and grid[r, temp_c] == color:\n                              potential_width += 1\n                              temp_c += 1\n                          if potential_width > block_width:\n                               block_width = potential_width\n                     curr_c += 1\n\n                # Find height and mark visited\n                curr_r = r\n                while curr_r < height and all(grid[curr_r, col] == color for col in range(c, c + block_width)):\n                    # Mark row as visited for this block\n                    visited[curr_r, c:c+block_width] = True\n                    block_height += 1\n                    curr_r += 1\n\n                # Ensure we only add complete blocks once (top-left corner)\n                # Note: The current logic might re-find blocks if scanning isn't perfect.\n                # The visited check should prevent duplicates, but let's refine block detection.\n\n                # Simpler Block Detection for horizontal rectangles starting at col 0\n                # Check if this is the top-left corner of a potential block\n                if c == 0 and (r == 0 or grid[r-1, c] != color):\n                    b_color = grid[r,c]\n                    b_width = 0\n                    # Determine width by scanning right\n                    for w_idx in range(width):\n                        if grid[r, w_idx] == b_color:\n                            b_width += 1\n                        else:\n                            break # Width ends here or gap\n\n                    # Check if the potential block exists fully\n                    is_block = True\n                    if b_width == 0:\n                        is_block = False\n                    else:\n                         # Determine height by scanning down\n                        b_height = 0\n                        for h_idx in range(r, height):\n                            row_matches = True\n                            for w_check in range(b_width):\n                                if grid[h_idx, w_check] != b_color:\n                                    row_matches = False\n                                    break\n                            # Check for pixels to the right of the block in the same row\n                            if b_width < width and grid[h_idx, b_width] == b_color:\n                                row_matches = False # It's part of a wider block starting above or not rectangular\n\n                            if row_matches:\n                                b_height += 1\n                            else:\n                                break # Height ends here or gap\n\n                        if b_height == 0:\n                            is_block = False\n\n\n                    if is_block:\n                       # Check if already visited (part of another block processed)\n                       is_new = True\n                       for h_check in range(r, r + b_height):\n                           for w_check in range(b_width):\n                               if visited[h_check, w_check]:\n                                   is_new = False\n                                   break\n                           if not is_new:\n                               break\n\n                       if is_new:\n                           blocks.append(Block(color=b_color, height=b_height, width=b_width, top_row=r, left_col=0))\n                           if r < min_top_row:\n                               min_top_row = r\n                           # Mark as visited\n                           for h_visit in range(r, r + b_height):\n                               for w_visit in range(b_width):\n                                   visited[h_visit, w_visit] = True\n\n\n    # Recalculate min_top_row accurately from found blocks\n    if blocks:\n        min_top_row = min(b.top_row for b in blocks)\n    else:\n        min_top_row = 0 # Default if no blocks\n\n    return blocks, min_top_row\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by rearranging horizontal blocks based on width.\n\n    Args:\n        input_grid (list of lists or np.array): The input grid.\n\n    Returns:\n        np.array: The transformed grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid)\n    height, width = input_grid_np.shape\n    background_color = 0\n\n    # 1. & 2. Find all distinct horizontal rectangular blocks and their properties\n    blocks, min_original_top_row = find_blocks(input_grid_np)\n\n    # Handle edge case: No blocks found\n    if not blocks:\n        return input_grid_np.tolist() # Return original grid if no blocks\n\n    # 4. Sort the blocks by width in ascending order\n    sorted_blocks = sorted(blocks, key=lambda b: b.width)\n\n    # 5. Create a new output grid filled with the background color\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 6. Initialize the starting row for placing blocks\n    current_row = min_original_top_row\n\n    # 7. Iterate through sorted blocks and place them on the output grid\n    for block in sorted_blocks:\n        # Get block properties\n        color = block.color\n        block_height = block.height\n        block_width = block.width\n        # Assumes blocks start at column 0 based on examples\n        start_col = 0\n\n        # Place the block\n        # Ensure placement doesn't exceed grid bounds (though it shouldn't with this logic)\n        end_row = min(current_row + block_height, height)\n        end_col = min(start_col + block_width, width)\n\n        output_grid[current_row:end_row, start_col:end_col] = color\n\n        # Update the current row for the next block\n        current_row += block_height\n\n    # 8. Return the completed output grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3021,
    "candidates_token_count": 1742,
    "total_token_count": 4763,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.022132,
  "retries": 1
}