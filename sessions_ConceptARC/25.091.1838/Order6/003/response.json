{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define a structure to hold block information\nBlock = namedtuple('Block', ['color', 'height', 'width', 'top_row'])\n\n\"\"\"\nIdentifies distinct horizontal rectangular blocks of non-background color starting at column 0 in the input grid.\nSorts these blocks based on their width in ascending order.\nReconstructs the output grid by placing the sorted blocks vertically, starting from the minimum top row occupied by any block in the original input, preserving their original height, width, and color. Blocks are placed starting at column 0.\n\"\"\"\n\ndef _find_blocks(grid: np.ndarray) -> tuple[list[Block], int]:\n    \"\"\"\n    Finds all distinct horizontal rectangular blocks starting at column 0.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple[list[Block], int]: A tuple containing:\n            - A list of Block namedtuples found.\n            - The minimum top_row index among all found blocks (or grid height if none found).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    blocks = []\n    min_original_top_row = height # Initialize high\n\n    # Iterate through rows, checking the first column for potential block starts\n    for r in range(height):\n        # Check column 0 for a non-background color that hasn't been visited\n        if grid[r, 0] != 0 and not visited[r, 0]:\n            color = grid[r, 0]\n            \n            # Determine width by scanning right from (r, 0)\n            current_width = 0\n            for c in range(width):\n                if grid[r, c] == color:\n                    current_width += 1\n                else:\n                    break # Width ends here\n\n            if current_width == 0: # Should not happen with grid[r,0] != 0 check, but safe\n                continue\n\n            # Determine height by scanning down\n            current_height = 0\n            for h_idx in range(r, height):\n                row_matches = True\n                # Check if the segment matches the color\n                for w_idx in range(current_width):\n                    if h_idx >= height or grid[h_idx, w_idx] != color:\n                        row_matches = False\n                        break\n                if not row_matches:\n                    break # Height ends here\n                \n                # Check if the block incorrectly extends further right in this row\n                if current_width < width and grid[h_idx, current_width] == color:\n                    row_matches = False\n                    break # This isn't a clean rectangle of current_width\n\n                # If row matches and doesn't extend, increment height\n                if row_matches:\n                    current_height += 1\n                else: # Should be caught by breaks above, but double-check\n                    break\n\n            # If a valid block is found (height > 0)\n            if current_height > 0:\n                # Store block info\n                block = Block(color=color, height=current_height, width=current_width, top_row=r)\n                blocks.append(block)\n                \n                # Update minimum starting row\n                if r < min_original_top_row:\n                    min_original_top_row = r\n\n                # Mark visited cells for this block\n                for r_visit in range(r, r + current_height):\n                    for c_visit in range(current_width):\n                         # Check bounds before marking visited\n                        if r_visit < height and c_visit < width:\n                            visited[r_visit, c_visit] = True\n            \n            # Skip rows already part of the detected block\n            # Note: The outer loop continues, but visited check prevents reprocessing\n            \n    # If no blocks found, set min_top_row to 0 for default behavior if needed,\n    # though the main function handles the empty block list.\n    if not blocks:\n        min_original_top_row = 0\n        \n    return blocks, min_original_top_row\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid by rearranging horizontal blocks based on width.\n\n    Args:\n        input_grid (list[list[int]]): The input grid represented as a list of lists.\n\n    Returns:\n        list[list[int]]: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n    background_color = 0 # Assuming white background\n\n    # 1. Find all distinct horizontal rectangular blocks starting at col 0\n    #    and the minimum original top row they occupy.\n    blocks, min_original_top_row = _find_blocks(input_grid_np)\n\n    # 2. Handle edge case: No blocks found, return the original grid.\n    if not blocks:\n        return input_grid # Return original list of lists\n\n    # 3. Sort the blocks based on their width in ascending order.\n    sorted_blocks = sorted(blocks, key=lambda b: b.width)\n\n    # 4. Create a new output grid filled with the background color.\n    output_grid = np.full_like(input_grid_np, background_color)\n\n    # 5. Initialize the starting row for placing blocks in the output grid.\n    current_row = min_original_top_row\n\n    # 6. Iterate through sorted blocks and place them onto the output grid.\n    for block in sorted_blocks:\n        # Get block properties\n        color = block.color\n        block_height = block.height\n        block_width = block.width\n        start_col = 0 # Blocks always start at column 0\n\n        # Calculate end row and column, ensuring they don't exceed grid bounds\n        end_row = min(current_row + block_height, height)\n        end_col = min(start_col + block_width, width)\n\n        # Place the block onto the output grid\n        output_grid[current_row:end_row, start_col:end_col] = color\n\n        # Update the current row for the next block\n        current_row += block_height # Next block starts immediately below\n\n    # 7. Convert the output numpy array back to a list of lists and return.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9752,
    "candidates_token_count": 1498,
    "total_token_count": 11250,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.480904,
  "retries": 1
}