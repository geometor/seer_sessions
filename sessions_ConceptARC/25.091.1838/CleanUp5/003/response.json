{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nProcesses input grids based on the number and frequency of non-white colors.\n\n1.  Analyze the input grid to identify all distinct non-white colors present and count them.\n2.  If there is more than one distinct non-white color:\n    a. Find the non-white color with the minimum count ('target color').\n    b. Change all pixels with the 'target color' to white (0).\n3.  If there is exactly one distinct non-white color ('the_color'):\n    a. For each pixel with 'the_color', check its 8 neighbors (Moore neighborhood).\n    b. If none of the neighbors also have 'the_color', change the pixel to white (0).\n4.  If there are no non-white colors, the output is identical to the input.\nWhite (0) pixels always remain unchanged unless they are the target of a change described above (which doesn't happen in this logic).\n\"\"\"\n\nimport numpy as np\nfrom collections import Counter\n\n# Define relative coordinates for the 8 neighbors (Moore neighborhood)\n_NEIGHBOR_OFFSETS = [\n    (-1, -1), (-1, 0), (-1, 1),\n    (0, -1),          (0, 1),\n    (1, -1), (1, 0), (1, 1)\n]\n\ndef _has_same_color_neighbor(grid, r, c):\n    \"\"\"\n    Checks if the pixel at (r, c) in the grid has any neighbor\n    (out of the 8 surrounding cells) with the same color.\n\n    Args:\n        grid (np.array): The input grid.\n        r (int): Row index of the pixel.\n        c (int): Column index of the pixel.\n\n    Returns:\n        bool: True if at least one neighbor has the same color, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    pixel_color = grid[r, c]\n\n    # Iterate through all 8 neighbor positions\n    for dr, dc in _NEIGHBOR_OFFSETS:\n        nr, nc = r + dr, c + dc\n        # Check if the neighbor coordinates are within the grid boundaries\n        if 0 <= nr < rows and 0 <= nc < cols:\n            # Check if the neighbor pixel has the same color\n            if grid[nr, nc] == pixel_color:\n                return True # Found a neighbor with the same color\n\n    # If the loop completes without finding a same-colored neighbor\n    return False\n\ndef transform(input_grid_list):\n    \"\"\"\n    Transforms the input grid based on the rules derived from the examples.\n\n    Args:\n        input_grid_list (list of list of int): The input grid.\n\n    Returns:\n        list of list of int: The transformed output grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for easier manipulation\n    input_grid = np.array(input_grid_list, dtype=int)\n    rows, cols = input_grid.shape\n    \n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # --- Analysis Phase ---\n    # Find all non-white pixels\n    non_white_pixels = input_grid[input_grid != 0]\n    \n    # Count the occurrences of each non-white color\n    color_counts = Counter(non_white_pixels)\n    \n    # Get the number of distinct non-white colors\n    num_distinct_colors = len(color_counts)\n\n    # --- Transformation Logic ---\n    \n    # Case 1: More than one distinct non-white color\n    if num_distinct_colors > 1:\n        # Find the color with the minimum count\n        # Initialize with a high count and placeholder color\n        min_count = float('inf')\n        target_color = -1 \n        # Iterate through the counts to find the minimum\n        # Note: If ties occur, the first color encountered with the minimum count is chosen.\n        # Example 1 has counts {2: 19, 3: 9}, so 3 is correctly chosen.\n        for color, count in color_counts.items():\n            if count < min_count:\n                min_count = count\n                target_color = color\n            # Optional: If counts are equal, could use color value as tie-breaker\n            # elif count == min_count and color < target_color:\n            #     target_color = color \n                \n        # Change all pixels of the target color to white (0) in the output grid\n        output_grid[output_grid == target_color] = 0\n        \n    # Case 2: Exactly one distinct non-white color\n    elif num_distinct_colors == 1:\n        # Get the single non-white color\n        the_color = list(color_counts.keys())[0]\n        \n        # Iterate through each pixel of the input grid\n        for r in range(rows):\n            for c in range(cols):\n                # Check if the current pixel has 'the_color'\n                if input_grid[r, c] == the_color:\n                    # Check if it's isolated (has no neighbors of the same color)\n                    if not _has_same_color_neighbor(input_grid, r, c):\n                        # If isolated, change this pixel to white (0) in the output grid\n                        output_grid[r, c] = 0\n                        \n    # Case 3: No non-white colors (num_distinct_colors == 0)\n    # No action needed, the output_grid is already a copy of the input.\n\n    # Convert the final numpy array back to a list of lists format for the ARC standard\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9013,
    "candidates_token_count": 1314,
    "total_token_count": 10327,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.377752,
  "retries": 1
}