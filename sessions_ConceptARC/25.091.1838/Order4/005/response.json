{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on object colors and the presence of gray (5), filling internal holes.\n\n1.  Identifies distinct objects in the input grid. An object consists of:\n    *   A core set of connected non-white (non-zero) pixels ('Pixels').\n    *   An optional set of enclosed white (0) pixels ('Internal_Holes') surrounded by the object's 'Pixels'.\n2.  For each object, checks if gray (5) is present among its core pixels.\n3.  Determines a 'primary color':\n    *   If gray is present, it's the other non-white color.\n    *   If gray is absent, it's the single non-white color.\n4.  Applies one of two color transformation rules to the primary color based on gray's presence, yielding a 'target output color':\n    *   Rule (Gray Present): Blue(1)->Yellow(4), Red(2)->Red(2), Yellow(4)->Green(3), Green(3)->Blue(1).\n    *   Rule (Gray Absent): Yellow(4)->Magenta(6), Red(2)->Orange(7), Magenta(6)->Red(2), Orange(7)->Yellow(4).\n5.  Updates the output grid by setting all pixels corresponding to the object's core ('Pixels') and its 'Internal_Holes' to the 'target output color'.\n6.  External background pixels remain unchanged.\n\"\"\"\n\ndef _find_objects_and_holes(grid):\n    \"\"\"\n    Finds connected components (objects) of non-background pixels \n    and associates enclosed background pixels (internal holes) with them.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (set of non-zero pixel coordinates),\n              'internal_holes' (set of enclosed zero pixel coordinates),\n              'colors' (set of non-zero color values), and 'has_gray' (boolean).\n    \"\"\"\n    height, width = grid.shape\n    visited_objects = set()\n    objects = []\n    all_object_pixels = set()\n\n    # --- Step 1: Find connected non-zero components (object pixels) ---\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and (r, c) not in visited_objects:\n                # Found the start of a new non-zero component\n                current_object_coords = set()\n                current_object_colors = set()\n                q = deque([(r, c)])\n                visited_objects.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    current_object_colors.add(grid[row, col])\n                    all_object_pixels.add((row, col)) # Keep track of all object pixels globally\n\n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in visited_objects:\n                            visited_objects.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_object_coords:\n                    objects.append({\n                        'coords': current_object_coords,\n                        'colors': current_object_colors,\n                        'has_gray': 5 in current_object_colors,\n                        'internal_holes': set() # Initialize hole set for this object\n                    })\n\n    # --- Step 2: Identify all background pixels reachable from the border ---\n    reachable_background = set()\n    q_background = deque()\n    \n    # Add all border background pixels to the queue if they are background(0)\n    for r in range(height):\n        if grid[r, 0] == 0: q_background.append((r, 0)); reachable_background.add((r,0))\n        if grid[r, width-1] == 0: q_background.append((r, width-1)); reachable_background.add((r,width-1))\n    # Avoid adding corners twice\n    for c in range(1, width - 1): \n        if grid[0, c] == 0: q_background.append((0, c)); reachable_background.add((0,c))\n        if grid[height-1, c] == 0: q_background.append((height-1, c)); reachable_background.add((height-1,c))\n\n    # BFS from border background pixels to find all connected external background\n    visited_background = set(reachable_background) # Use separate visited set for background BFS\n    while q_background:\n        r, c = q_background.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and (nr, nc) not in visited_background:\n                visited_background.add((nr, nc))\n                reachable_background.add((nr, nc))\n                q_background.append((nr, nc))\n\n    # --- Step 3: Identify internal holes and associate them with objects ---\n    for r in range(height):\n        for c in range(width):\n            # If a pixel is background(0) and not reachable from the outside, it's an internal hole\n            if grid[r, c] == 0 and (r, c) not in reachable_background:\n                hole_coord = (r, c)\n                # Find which object this hole belongs to by checking adjacent pixels\n                adjacent_object_found = False\n                for obj in objects:\n                     # Check if any neighbor of the hole is part of this object's coordinates\n                     is_adjacent = False\n                     for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = r + dr, c + dc\n                         if (nr, nc) in obj['coords']:\n                             is_adjacent = True\n                             break\n                     if is_adjacent:\n                         obj['internal_holes'].add(hole_coord)\n                         adjacent_object_found = True\n                         # Assuming a hole belongs to only one object based on problem structure\n                         break \n                # Optional: Handle case where a hole isn't adjacent to any identified object? \n                # This shouldn't happen if object finding is correct for ARC tasks.\n\n    return objects\n\ndef transform(input_grid):\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define the color transformation maps\n    map_gray_present = {\n        1: 4,  # Blue -> Yellow\n        2: 2,  # Red -> Red\n        4: 3,  # Yellow -> Green\n        3: 1   # Green -> Blue\n    }\n    map_gray_absent = {\n        4: 6,  # Yellow -> Magenta\n        2: 7,  # Red -> Orange\n        6: 2,  # Magenta -> Red\n        7: 4   # Orange -> Yellow\n    }\n\n    # Find all objects and their associated internal holes\n    objects = _find_objects_and_holes(input_grid)\n\n    # Process each object\n    for obj in objects:\n        coords = obj['coords']\n        colors = obj['colors']\n        has_gray = obj['has_gray']\n        internal_holes = obj['internal_holes']\n        \n        primary_color = -1\n        target_color = -1\n\n        # Determine primary color based on presence of gray\n        if has_gray:\n            # Find the non-gray, non-zero color\n            primary_colors = [c for c in colors if c != 0 and c != 5]\n            if primary_colors: # Should have exactly one based on examples\n                 primary_color = primary_colors[0]\n                 # Apply the transformation rule for objects with gray\n                 target_color = map_gray_present.get(primary_color, primary_color) \n            else:\n                 # Handle case of object being *only* gray (not seen in examples)\n                 # Default: keep gray as gray? or treat as error? Keeping gray for now.\n                 if colors == {5}:\n                     target_color = 5 \n            \n        else: # No gray color (5) in the object\n            # Find the single non-zero color\n            primary_colors = [c for c in colors if c != 0]\n            if len(primary_colors) == 1: # Should have exactly one based on examples\n                primary_color = primary_colors[0]\n                # Apply the transformation rule for objects without gray\n                target_color = map_gray_absent.get(primary_color, primary_color) \n            # else: Handle case of multiple non-gray colors without gray (not seen in examples)\n            # Default: Keep original colors by not setting target_color? For now assume valid input.\n\n        # Update the output grid for all pixels in the object's footprint (coords + holes)\n        if target_color != -1: # Ensure we found a valid transformation target\n            all_pixels_to_update = coords.union(internal_holes)\n            for r, c in all_pixels_to_update:\n                 # Bounds check just for safety\n                if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = target_color\n        # If target_color remained -1 (due to unexpected object composition),\n        # the original colors in output_grid (copied from input) are preserved for that object.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12959,
    "candidates_token_count": 2345,
    "total_token_count": 15304,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.620425,
  "retries": 1
}