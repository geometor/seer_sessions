{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nThis program transforms an input grid into an output grid based on the colors within connected objects.\n\n1.  Identifies distinct objects in the input grid. An object is a contiguous group of non-white (non-zero) pixels.\n2.  For each object, it determines if the color gray (5) is present among its pixels.\n3.  Based on the presence or absence of gray (5), it identifies a 'primary' color for the object:\n    - If gray (5) is present, the primary color is the other non-white color in the object.\n    - If gray (5) is absent, the primary color is the single non-white color composing the object.\n4.  Applies a color transformation rule to the primary color to get a target output color. There are two separate rules: one for objects containing gray, and one for objects without gray.\n    - Rule (Gray Present): Blue (1) -> Yellow (4), Red (2) -> Red (2), Yellow (4) -> Green (3), Green (3) -> Blue (1).\n    - Rule (Gray Absent): Yellow (4) -> Magenta (6), Red (2) -> Orange (7), Magenta (6) -> Red (2), Orange (7) -> Yellow (4).\n5.  Updates all pixels belonging to the original object in the output grid to this single target output color, preserving the object's shape and position.\n6.  White (0) pixels (background or internal holes) remain unchanged.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds connected components of non-background (non-zero) pixels in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (a set of (row, col) tuples) and 'colors'\n              (a set of color values present in the object).\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                # Found the start of a new object\n                current_object_coords = set()\n                current_object_colors = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    current_object_colors.add(grid[row, col])\n\n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n\n                if current_object_coords:\n                    objects.append({\n                        'coords': current_object_coords,\n                        'colors': current_object_colors\n                    })\n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on object colors and presence of gray.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define the color transformation maps\n    map_gray_present = {\n        1: 4,  # Blue -> Yellow\n        2: 2,  # Red -> Red\n        4: 3,  # Yellow -> Green\n        3: 1   # Green -> Blue\n    }\n    map_gray_absent = {\n        4: 6,  # Yellow -> Magenta\n        2: 7,  # Red -> Orange\n        6: 2,  # Magenta -> Red\n        7: 4   # Orange -> Yellow\n    }\n\n    # Find all objects in the input grid\n    objects = find_objects(input_grid)\n\n    # Process each object\n    for obj in objects:\n        coords = obj['coords']\n        colors = obj['colors']\n        \n        # Check if gray (5) is present\n        has_gray = 5 in colors\n\n        primary_color = -1\n        target_color = -1\n\n        if has_gray:\n            # Find the primary color (the one that's not 0 or 5)\n            # Assuming exactly one primary color exists alongside gray based on examples\n            primary_colors = [c for c in colors if c != 0 and c != 5]\n            if primary_colors: # Should always be true if has_gray and object exists\n                 primary_color = primary_colors[0]\n                 # Apply the transformation rule for objects with gray\n                 target_color = map_gray_present.get(primary_color, primary_color) # Default to itself if not in map\n            else:\n                # Handle edge case? E.g., an object made *only* of gray?\n                # Based on examples, this doesn't seem to happen. Assume we find a primary.\n                # If only gray existed, maybe it maps to itself? For now, stick to observed rules.\n                # Let's assume primary_color must be found if gray is present. If not, something is wrong.\n                # If object was ONLY gray, target_color would remain -1. We can add a fallback.\n                if not primary_colors and colors == {5}:\n                     target_color = 5 # Map gray-only object to gray? Or maybe another rule applies? Let's keep gray.\n                     # However, based on task, this scenario doesn't occur.\n                else:\n                     # This case signifies an unexpected object composition (e.g. {0, 5})\n                     # Defaulting to keep original color might be safest if primary unclear\n                     # For now, assume the primary color is always identifiable per rules.\n                     pass # target_color remains -1 initially\n\n        else: # No gray color (5) in the object\n            # Find the primary color (the single non-zero color)\n            primary_colors = [c for c in colors if c != 0]\n            if len(primary_colors) == 1: # Should be true for non-gray objects based on examples\n                primary_color = primary_colors[0]\n                # Apply the transformation rule for objects without gray\n                target_color = map_gray_absent.get(primary_color, primary_color) # Default to itself if not in map\n            else:\n                # Handle edge case: multiple non-gray colors without gray present?\n                # Not observed in examples. Assume single primary color if no gray.\n                pass # target_color remains -1\n\n        # Update the output grid for all pixels in this object\n        if target_color != -1: # Ensure we found a valid transformation\n            for r, c in coords:\n                 # Check bounds just in case, though coords should be valid\n                if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = target_color\n        # If target_color remained -1 (due to unexpected object composition),\n        # the original colors in output_grid (copied from input) are preserved for that object.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3202,
    "candidates_token_count": 1752,
    "total_token_count": 4954,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.300069,
  "retries": 1
}