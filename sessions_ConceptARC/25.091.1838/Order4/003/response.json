{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on object colors and the presence of gray (5), filling internal holes.\n\n1.  Identifies distinct objects in the input grid. An object consists of:\n    *   A core set of connected non-white (non-zero) pixels ('Pixels').\n    *   An optional set of enclosed white (0) pixels ('Internal_Holes') surrounded by the object's 'Pixels'.\n2.  For each object, checks if gray (5) is present among its core pixels.\n3.  Determines a 'primary color':\n    *   If gray is present, it's the other non-white color.\n    *   If gray is absent, it's the single non-white color.\n4.  Applies one of two color transformation rules to the primary color based on gray's presence, yielding a 'target output color':\n    *   Rule (Gray Present): Blue(1)->Yellow(4), Red(2)->Red(2), Yellow(4)->Green(3), Green(3)->Blue(1).\n    *   Rule (Gray Absent): Yellow(4)->Magenta(6), Red(2)->Orange(7), Magenta(6)->Red(2), Orange(7)->Yellow(4).\n5.  Updates the output grid by setting all pixels corresponding to the object's core ('Pixels') and its 'Internal_Holes' to the 'target output color'.\n6.  External background pixels remain unchanged.\n\"\"\"\n\ndef _find_objects(grid):\n    \"\"\"\n    Finds connected components (objects) of non-background pixels and their internal holes.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              and contains 'coords' (set of non-zero pixel coordinates),\n              'internal_holes' (set of enclosed zero pixel coordinates),\n              'colors' (set of non-zero color values), and 'has_gray' (boolean).\n    \"\"\"\n    height, width = grid.shape\n    visited = set()\n    objects = []\n    \n    # First pass: Find connected non-zero components (object pixels)\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and (r, c) not in visited:\n                # Found the start of a new non-zero component\n                current_object_coords = set()\n                current_object_colors = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.popleft()\n                    current_object_coords.add((row, col))\n                    current_object_colors.add(grid[row, col])\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           grid[nr, nc] != 0 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            q.append((nr, nc))\n                \n                if current_object_coords:\n                    objects.append({\n                        'coords': current_object_coords,\n                        'colors': current_object_colors,\n                        'has_gray': 5 in current_object_colors,\n                        'bounding_box': (min_r, min_c, max_r, max_c),\n                        'internal_holes': set() # To be filled later\n                    })\n\n    # Second pass: Identify internal holes for each object\n    all_object_pixels = set().union(*[obj['coords'] for obj in objects])\n    \n    # Find all background pixels potentially reachable from the outer border\n    reachable_background = set()\n    q_background = deque()\n    \n    # Add all border background pixels to the queue\n    for r in range(height):\n        if grid[r, 0] == 0 and (r, 0) not in reachable_background:\n             q_background.append((r, 0))\n             reachable_background.add((r,0))\n        if grid[r, width-1] == 0 and (r, width-1) not in reachable_background:\n             q_background.append((r, width-1))\n             reachable_background.add((r,width-1))\n    for c in range(width):\n        if grid[0, c] == 0 and (0, c) not in reachable_background:\n             q_background.append((0, c))\n             reachable_background.add((0,c))\n        if grid[height-1, c] == 0 and (height-1, c) not in reachable_background:\n             q_background.append((height-1, c))\n             reachable_background.add((height-1,c))\n\n    # BFS from border background pixels\n    while q_background:\n        r, c = q_background.popleft()\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and (nr, nc) not in reachable_background:\n                reachable_background.add((nr, nc))\n                q_background.append((nr, nc))\n\n    # Assign internal holes to objects\n    for obj in objects:\n        min_r, min_c, max_r, max_c = obj['bounding_box']\n        for r in range(min_r, max_r + 1):\n            for c in range(min_c, max_c + 1):\n                # If a pixel is background(0), within the bounding box,\n                # and NOT reachable from the outer border, it's an internal hole for *some* object.\n                # We assume it belongs to the object defining this bounding box for simplicity in this task structure.\n                # A more complex check might be needed if objects interleave holes.\n                if grid[r,c] == 0 and (r,c) not in reachable_background and (r,c) not in all_object_pixels:\n                     # Double check adjacency to *this* object's coords - improves robustness slightly\n                     is_adjacent_to_this_obj = False\n                     for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                         nr, nc = r + dr, c + dc\n                         if (nr, nc) in obj['coords']:\n                             is_adjacent_to_this_obj = True\n                             break\n                     if is_adjacent_to_this_obj:\n                         obj['internal_holes'].add((r, c))\n\n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rules to the input grid.\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Define the color transformation maps\n    map_gray_present = {\n        1: 4,  # Blue -> Yellow\n        2: 2,  # Red -> Red\n        4: 3,  # Yellow -> Green\n        3: 1   # Green -> Blue\n    }\n    map_gray_absent = {\n        4: 6,  # Yellow -> Magenta\n        2: 7,  # Red -> Orange\n        6: 2,  # Magenta -> Red\n        7: 4   # Orange -> Yellow\n    }\n\n    # Find all objects and their internal holes in the input grid\n    objects = _find_objects(input_grid)\n\n    # Process each object\n    for obj in objects:\n        coords = obj['coords']\n        colors = obj['colors']\n        has_gray = obj['has_gray']\n        internal_holes = obj['internal_holes']\n        \n        primary_color = -1\n        target_color = -1\n\n        # Determine primary color and apply transformation map\n        if has_gray:\n            primary_colors = [c for c in colors if c != 0 and c != 5]\n            if primary_colors: # Should have exactly one based on examples\n                 primary_color = primary_colors[0]\n                 target_color = map_gray_present.get(primary_color, primary_color) # Default to itself if not in map\n            # else: handle unexpected case like only gray? Keep original color maybe?\n            # target_color remains -1 or handle explicitly. For now assume valid primary.\n            \n        else: # No gray color (5) in the object\n            primary_colors = [c for c in colors if c != 0]\n            if len(primary_colors) == 1: # Should have exactly one based on examples\n                primary_color = primary_colors[0]\n                target_color = map_gray_absent.get(primary_color, primary_color) # Default to itself if not in map\n            # else: handle unexpected case like multiple non-gray colors? Keep original?\n            # target_color remains -1 or handle explicitly. For now assume valid primary.\n\n        # Update the output grid for all pixels belonging to the object's footprint\n        if target_color != -1: # Ensure we found a valid transformation target\n            all_pixels_to_update = coords.union(internal_holes)\n            for r, c in all_pixels_to_update:\n                 # Bounds check just in case, though coords should be valid\n                if 0 <= r < height and 0 <= c < width:\n                    output_grid[r, c] = target_color\n        # If target_color remained -1 (due to unexpected object composition),\n        # the original colors in output_grid (copied from input) are preserved for that object.\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13758,
    "candidates_token_count": 2440,
    "total_token_count": 16198,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.783352,
  "retries": 1
}