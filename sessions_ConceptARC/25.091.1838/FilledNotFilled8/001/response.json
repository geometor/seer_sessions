{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nfrom skimage.measure import label\nfrom skimage.draw import polygon\n\n\"\"\"\nIdentify all non-white pixels (color C) in the input grid.\nDetermine if these pixels form a single connected component (8-way adjacency) or multiple components.\n\nIf a single connected component exists:\n  Keep only the boundary pixels of this component (pixels of color C that are adjacent, including diagonally, to at least one white pixel).\n  Change the interior pixels of the component to white.\n\nIf multiple disconnected components/pixels exist:\n  Calculate the convex hull enclosing all non-white pixel coordinates.\n  Fill the area inside and on the boundary of this convex hull with color C.\n  The rest of the grid remains white.\n\"\"\"\n\ndef find_non_background_pixels(grid_np, background_color=0):\n    \"\"\"Finds coordinates and the unique color of non-background pixels.\"\"\"\n    coords = np.argwhere(grid_np != background_color)\n    if coords.size == 0:\n        return [], -1  # No non-background pixels\n    \n    colors = grid_np[coords[:, 0], coords[:, 1]]\n    unique_colors = np.unique(colors)\n    \n    if len(unique_colors) > 1:\n         # This specific task seems to assume only one non-background color\n         # Handle error or specific logic if multiple colors are possible\n         # For now, let's take the first one found or the most frequent one\n         print(f\"Warning: Multiple non-background colors found: {unique_colors}. Using {unique_colors[0]}.\")\n         main_color = unique_colors[0]\n         # Filter coords for the main color if necessary, but the logic seems to operate on all non-bg collectively\n    elif len(unique_colors) == 1:\n        main_color = unique_colors[0]\n    else: # Should not happen if coords.size > 0\n        return [], -1\n        \n    # Return coordinates as list of tuples for easier processing later\n    return [tuple(coord) for coord in coords], main_color\n\ndef check_connectivity(grid_np, background_color=0):\n    \"\"\"Checks the connectivity of non-background pixels.\"\"\"\n    binary_grid = (grid_np != background_color).astype(int)\n    # Use connectivity=2 for 8-way adjacency (including diagonals)\n    labeled_grid, num_labels = label(binary_grid, connectivity=2, background=0, return_num=True)\n    return num_labels\n\ndef find_outline(grid_np, non_bg_coords, color, background_color=0):\n    \"\"\"Keeps only boundary pixels of a single connected component.\"\"\"\n    output_grid = np.full(grid_np.shape, background_color, dtype=int)\n    rows, cols = grid_np.shape\n    \n    for r, c in non_bg_coords:\n        is_boundary = False\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue  # Skip self\n                \n                nr, nc = r + dr, c + dc\n                \n                # Check bounds\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid_np[nr, nc] == background_color:\n                        is_boundary = True\n                        break # Found a background neighbor, it's a boundary pixel\n                else:\n                    # Pixel is on the grid edge, implicitly adjacent to 'outside' which we can consider background\n                    is_boundary = True\n                    break\n            if is_boundary:\n                break\n                \n        if is_boundary:\n            output_grid[r, c] = color\n            \n    return output_grid\n\ndef fill_convex_hull(grid_shape, non_bg_coords, color, background_color=0):\n    \"\"\"Fills the convex hull of the given coordinates.\"\"\"\n    output_grid = np.full(grid_shape, background_color, dtype=int)\n    \n    if not non_bg_coords:\n        return output_grid # Return empty grid if no points\n        \n    points = np.array(non_bg_coords)\n    \n    if len(points) <= 2:\n        # Handle cases with 0, 1 or 2 points (line)\n        for r, c in non_bg_coords:\n             # Check bounds just in case, though coords should be valid\n             if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                 output_grid[r, c] = color\n        # If 2 points, draw a line? The examples don't cover this.\n        # For now, just color the points themselves. Convex hull isn't well-defined.\n        # Example 1 implies filling, maybe just draw the points if hull fails.\n        # Let's stick to coloring just the points for < 3 points.\n        return output_grid\n\n    try:\n        hull = ConvexHull(points)\n        # Get the vertices of the hull\n        hull_vertices = points[hull.vertices]\n        \n        # Use skimage.draw.polygon to get all points inside the hull\n        # Note: polygon needs row and column coordinates separately\n        rr, cc = polygon(hull_vertices[:, 0], hull_vertices[:, 1], shape=grid_shape)\n        \n        # Ensure coordinates are within bounds (polygon might sometimes slightly exceed?)\n        valid_indices = (rr >= 0) & (rr < grid_shape[0]) & (cc >= 0) & (cc < grid_shape[1])\n        rr_valid = rr[valid_indices]\n        cc_valid = cc[valid_indices]\n\n        output_grid[rr_valid, cc_valid] = color\n        \n    except Exception as e:\n        # ConvexHull can fail if points are collinear\n        print(f\"Convex Hull calculation failed: {e}. Coloring original points.\")\n        # Fallback: just color the original points if hull fails\n        for r, c in non_bg_coords:\n            if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                output_grid[r, c] = color\n\n    return output_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Applies transformation based on connectivity of non-background pixels.\n    - If single connected component: Extracts the outline.\n    - If multiple components: Fills the convex hull.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    # Find non-background pixels and their color\n    non_bg_coords, color = find_non_background_pixels(input_grid_np)\n    \n    # Handle edge case: no non-background pixels\n    if not non_bg_coords:\n        return input_grid # Return original grid if nothing to transform\n        \n    # Check connectivity\n    num_components = check_connectivity(input_grid_np)\n    \n    # Apply transformation based on connectivity\n    if num_components == 1:\n        # Single component -> Find outline\n        output_grid_np = find_outline(input_grid_np, non_bg_coords, color)\n    else: # num_components > 1 or num_components == 0 (but handled above)\n        # Multiple components -> Fill convex hull\n        output_grid_np = fill_convex_hull(input_grid_np.shape, non_bg_coords, color)\n        \n    # Convert back to list of lists\n    output_grid = output_grid_np.tolist()\n    \n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3267,
    "candidates_token_count": 1796,
    "total_token_count": 5063,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 25.196812,
  "retries": 1
}