{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nfrom skimage.measure import label\nfrom skimage.draw import polygon\nimport math # Import math for potential use, though not strictly needed for hull/polygon\n\n\"\"\"\nTransforms the input grid based on the connectivity of its non-background pixels (assuming white '0' is background).\n\n1.  If the non-background pixels form a single connected component (using 8-way adjacency), \n    the output grid contains only the boundary pixels of that component. Boundary pixels are \n    those non-background pixels adjacent (including diagonally) to at least one background pixel \n    or the grid edge.\n\n2.  If the non-background pixels form multiple disconnected components (or are isolated pixels),\n    the output grid is the original grid with the area defined by the convex hull of all \n    non-background pixels filled with their color. If fewer than 3 non-background pixels exist,\n    only those pixels are colored in the output.\n\"\"\"\n\ndef find_non_background_pixels(grid_np, background_color=0):\n    \"\"\"Finds coordinates and the unique color of non-background pixels.\"\"\"\n    coords = np.argwhere(grid_np != background_color)\n    if coords.size == 0:\n        return [], -1  # No non-background pixels, return empty list and invalid color\n\n    # Extract colors at found coordinates\n    colors = grid_np[coords[:, 0], coords[:, 1]]\n    unique_colors = np.unique(colors)\n\n    # Assuming a single non-background color per task based on examples\n    if len(unique_colors) == 1:\n        main_color = int(unique_colors[0]) # Convert numpy dtype to standard int\n    elif len(unique_colors) > 1:\n        # Fallback: use the most frequent color or the first one if tie.\n        # This might need adjustment based on specific task rules if multiple colors appear.\n        print(f\"Warning: Multiple non-background colors found: {unique_colors}. Using the first one: {unique_colors[0]}.\")\n        main_color = int(unique_colors[0])\n        # Filter coordinates to only include those of the main color\n        # Although the logic branches based on connectivity of *all* non-bg pixels together.\n        # Let's return all coords but identify the primary color to use for drawing.\n    else: # Should not happen if coords.size > 0\n         return [], -1\n\n    # Return coordinates as list of tuples (standard ints) for easier processing\n    return [tuple(map(int, coord)) for coord in coords], main_color\n\ndef check_connectivity(grid_np, background_color=0):\n    \"\"\"Checks the connectivity of non-background pixels using 8-way adjacency.\"\"\"\n    # Create a binary grid: 1 for non-background, 0 for background\n    binary_grid = (grid_np != background_color).astype(int)\n    # Label connected components using 8-way connectivity\n    # connectivity=2 corresponds to 8-way adjacency in skimage.measure.label\n    labeled_grid, num_labels = label(binary_grid, connectivity=2, background=0, return_num=True)\n    return int(num_labels) # Return the number of distinct components found\n\ndef find_outline(grid_np, non_bg_coords, color, background_color=0):\n    \"\"\"Keeps only boundary pixels of a single connected component.\"\"\"\n    output_grid = np.full(grid_np.shape, background_color, dtype=int)\n    rows, cols = grid_np.shape\n\n    for r, c in non_bg_coords:\n        is_boundary = False\n        # Check 8 neighbors (including diagonals)\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue  # Skip the pixel itself\n\n                nr, nc = r + dr, c + dc\n\n                # Check if neighbor is outside grid bounds\n                if not (0 <= nr < rows and 0 <= nc < cols):\n                    is_boundary = True  # Pixel is on the edge, thus a boundary pixel\n                    break\n                # Check if neighbor is background color\n                elif grid_np[nr, nc] == background_color:\n                    is_boundary = True\n                    break # Found a background neighbor, it's a boundary pixel\n\n            if is_boundary:\n                break # No need to check further neighbors for this pixel\n\n        # If it was determined to be a boundary pixel, color it in the output\n        if is_boundary:\n            output_grid[r, c] = color\n\n    return output_grid\n\ndef fill_convex_hull(grid_shape, non_bg_coords, color, background_color=0):\n    \"\"\"Fills the convex hull of the given coordinates.\"\"\"\n    output_grid = np.full(grid_shape, background_color, dtype=int)\n\n    if not non_bg_coords:\n        return output_grid # Return empty grid if no points\n\n    points = np.array(non_bg_coords)\n\n    # Handle cases with fewer than 3 points where ConvexHull is not defined or is trivial\n    if len(points) < 3:\n        for r, c in non_bg_coords:\n             # Ensure coordinates are within bounds before coloring\n             if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                 output_grid[r, c] = color\n        return output_grid\n\n    try:\n        # Calculate the convex hull\n        hull = ConvexHull(points)\n        # Get the vertices of the hull polygon\n        hull_vertices = points[hull.vertices]\n\n        # Get all integer coordinates inside the polygon defined by hull_vertices\n        # Note: polygon requires row and column coordinates separately\n        rr, cc = polygon(hull_vertices[:, 0], hull_vertices[:, 1], shape=grid_shape)\n\n        # Ensure coordinates from polygon are within grid bounds before coloring\n        valid_indices = (rr >= 0) & (rr < grid_shape[0]) & (cc >= 0) & (cc < grid_shape[1])\n        rr_valid = rr[valid_indices]\n        cc_valid = cc[valid_indices]\n\n        # Color the pixels inside the hull\n        output_grid[rr_valid, cc_valid] = color\n\n    except Exception as e:\n        # ConvexHull can fail if points are collinear or other geometric issues occur.\n        # Or polygon rasterization might have issues.\n        print(f\"Convex Hull / Polygon filling failed: {e}. Coloring original points as fallback.\")\n        # Fallback: color the original non-background points if hull calculation/filling fails\n        for r, c in non_bg_coords:\n            if 0 <= r < grid_shape[0] and 0 <= c < grid_shape[1]:\n                output_grid[r, c] = color\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic: outline for single component, convex hull fill for multiple.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    background_color = 0 # Assuming background is always 0\n\n    # Find the non-background pixels and their primary color\n    non_bg_coords, color = find_non_background_pixels(input_grid_np, background_color)\n\n    # If there are no non-background pixels, return the original grid\n    if not non_bg_coords:\n        return input_grid\n\n    # Check the connectivity of these pixels\n    num_components = check_connectivity(input_grid_np, background_color)\n\n    # --- Apply transformation based on connectivity ---\n    if num_components == 1:\n        # Case 1: Single connected component -> Find its outline\n        output_grid_np = find_outline(input_grid_np, non_bg_coords, color, background_color)\n    else: # Case 2: Multiple components (num_components > 1) or potentially 0 if logic missed edge case\n        # Fill the convex hull defined by the points\n        output_grid_np = fill_convex_hull(input_grid_np.shape, non_bg_coords, color, background_color)\n\n    # Convert the resulting numpy array back to a list of lists for the expected output format\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13752,
    "candidates_token_count": 1970,
    "total_token_count": 15722,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.806447,
  "retries": 1
}