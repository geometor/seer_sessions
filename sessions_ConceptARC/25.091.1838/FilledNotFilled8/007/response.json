{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the connectivity of its non-background pixels (assuming white '0' is background).\n\n1.  Identify all non-background pixels and their unique color `C`.\n2.  Determine the number of connected components formed by these pixels using 8-way adjacency (horizontal, vertical, diagonal).\n3.  If there is exactly one connected component:\n    - The output grid contains the original non-background pixels minus the \"interior\" pixels.\n    - An \"interior\" pixel is a non-background pixel where all 8 of its neighbors are within the grid boundaries and are also non-background pixels of color `C`.\n    - All other pixels in the output grid are background color.\n4.  If there is more than one connected component (or isolated pixels):\n    - Calculate the convex hull polygon enclosing all non-background pixel coordinates.\n    - The output grid contains all pixels whose centers fall inside or on the boundary of this convex hull, colored `C`.\n    - All other pixels are background color.\n    - If there are fewer than 3 non-background pixels, or if the convex hull calculation fails (e.g., collinear points), only the original non-background pixels are colored `C` in the output.\n5.  If there are no non-background pixels, the input grid is returned unchanged.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_non_background_pixels(grid_np, background_color=0):\n    \"\"\"Finds coordinates and the unique color of non-background pixels.\"\"\"\n    coords = np.argwhere(grid_np != background_color)\n    if coords.size == 0:\n        return [], -1, set() # No non-background pixels\n\n    colors = grid_np[coords[:, 0], coords[:, 1]]\n    unique_colors = np.unique(colors)\n\n    if len(unique_colors) == 1:\n        main_color = int(unique_colors[0])\n    elif len(unique_colors) > 1:\n        # Task examples imply single color, take the first one if multiple exist\n        main_color = int(unique_colors[0])\n        # Keep all coords, but use main_color for output.\n    else:\n        return [], -1, set() # Should not happen\n\n    # Return coordinates as list of tuples and set for quick lookup\n    coord_list = [tuple(map(int, coord)) for coord in coords]\n    coord_set = set(coord_list)\n    return coord_list, main_color, coord_set\n\ndef check_connectivity(grid_shape, non_bg_coords_list, non_bg_coords_set):\n    \"\"\"Checks the connectivity of non-background pixels using BFS (8-way adjacency).\"\"\"\n    if not non_bg_coords_list:\n        return 0\n\n    rows, cols = grid_shape\n    visited = set()\n    num_components = 0\n\n    for start_coord in non_bg_coords_list:\n        if start_coord not in visited:\n            num_components += 1\n            queue = deque([start_coord])\n            visited.add(start_coord)\n\n            while queue:\n                r, c = queue.popleft()\n\n                # Explore 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue # Skip self\n\n                        nr, nc = r + dr, c + dc\n                        neighbor_coord = (nr, nc)\n\n                        # Check if neighbor is a non-background pixel and not visited\n                        if neighbor_coord in non_bg_coords_set and neighbor_coord not in visited:\n                            visited.add(neighbor_coord)\n                            queue.append(neighbor_coord)\n    return num_components\n\ndef find_thin_outline(grid_np, non_bg_coords_list, color, background_color=0):\n    \"\"\"Removes interior pixels from a single connected component.\"\"\"\n    output_grid = grid_np.copy() # Start with a copy of the input\n    rows, cols = grid_np.shape\n\n    for r, c in non_bg_coords_list:\n        is_interior = True\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n\n                nr, nc = r + dr, c + dc\n\n                # Check if neighbor is outside grid bounds or is background\n                if not (0 <= nr < rows and 0 <= nc < cols) or grid_np[nr, nc] == background_color:\n                    is_interior = False # Found a neighbor that makes it non-interior\n                    break\n            if not is_interior:\n                break # No need to check further neighbors for this pixel\n\n        # If all neighbors were within bounds and non-background, it's interior\n        if is_interior:\n            output_grid[r, c] = background_color # Set interior pixel to background\n\n    return output_grid\n\ndef is_point_in_polygon(point, polygon_vertices):\n    \"\"\"\n    Checks if a point is inside a polygon using the Ray Casting algorithm.\n    Handles points on the boundary as inside. Integer coordinates assumed.\n    \"\"\"\n    pr, pc = point\n    num_vertices = len(polygon_vertices)\n    inside = False # Use standard ray casting state variable\n\n    p1r, p1c = polygon_vertices[0]\n    for i in range(num_vertices + 1):\n        p2r, p2c = polygon_vertices[i % num_vertices]\n\n        # Check if point is on a vertex\n        if pr == p1r and pc == p1c:\n            return True\n            \n        # Check if point is on a horizontal segment\n        if pr == p1r == p2r and min(p1c, p2c) <= pc <= max(p1c, p2c):\n             return True\n             \n        # Check if point is on a vertical segment\n        if pc == p1c == p2c and min(p1r, p2r) <= pr <= max(p1r, p2r):\n             return True\n\n        # Ray casting logic: Check if the horizontal ray crosses the segment\n        if min(p1r, p2r) <= pr < max(p1r, p2r): # Point's row is between segment's rows (exclusive upper bound)\n             # Calculate the column intersection of the ray (at row pr) with the line segment\n             # Avoid division by zero for vertical lines (handled by on-segment check)\n            if p1r != p2r:\n                c_intersect = (pr - p1r) * (p2c - p1c) / (p2r - p1r) + p1c\n                # If intersection is at or to the right of the point's column, toggle inside state\n                if c_intersect >= pc:\n                    inside = not inside\n\n        p1r, p1c = p2r, p2c # Move to next segment\n\n    return inside\n\n\ndef fill_convex_hull(grid_shape, non_bg_coords_list, color, background_color=0):\n    \"\"\"Fills the convex hull of the given coordinates using ray casting.\"\"\"\n    output_grid = np.full(grid_shape, background_color, dtype=int)\n    rows, cols = grid_shape\n\n    if not non_bg_coords_list:\n        return output_grid\n\n    points = np.array(non_bg_coords_list)\n\n    # --- Fallback function ---\n    def color_original_points():\n        out_fallback = np.full(grid_shape, background_color, dtype=int)\n        for r, c in non_bg_coords_list:\n            if 0 <= r < rows and 0 <= c < cols:\n                out_fallback[r, c] = color\n        return out_fallback\n\n    # --- Handle few points case ---\n    if len(points) < 3:\n        return color_original_points()\n\n    try:\n        # --- Calculate Convex Hull ---\n        hull = ConvexHull(points)\n        # Get vertices in order\n        hull_vertices_indices = hull.vertices\n        # Use integer coordinates for polygon vertices\n        hull_vertices = [tuple(map(int, points[i])) for i in hull_vertices_indices]\n\n        # --- Find Bounding Box ---\n        min_r = int(np.min(points[hull_vertices_indices, 0]))\n        max_r = int(np.max(points[hull_vertices_indices, 0]))\n        min_c = int(np.min(points[hull_vertices_indices, 1]))\n        max_c = int(np.max(points[hull_vertices_indices, 1]))\n\n        # --- Fill using Point-in-Polygon Test ---\n        for r in range(max(0, min_r), min(rows, max_r + 1)):\n            for c in range(max(0, min_c), min(cols, max_c + 1)):\n                 # Check if the center of the pixel (r, c) is inside the polygon\n                 # For grid coordinates, simply checking (r, c) is sufficient\n                if is_point_in_polygon((r, c), hull_vertices):\n                    output_grid[r, c] = color\n\n    except Exception as e:\n        # Catch scipy errors (e.g., QhullError for collinear points)\n        # Use the fallback method if hull fails\n        return color_original_points()\n\n    return output_grid\n\n\n# === Main Transform Function ===\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation logic: thin outline for single component,\n    convex hull fill for multiple components.\n    \"\"\"\n    # Convert input list of lists to numpy array\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    background_color = 0 # Assuming background is always 0\n\n    # --- Step 1: Find non-background pixels ---\n    non_bg_coords_list, color, non_bg_coords_set = find_non_background_pixels(input_grid_np, background_color)\n\n    # Handle empty case: return original grid if no non-bg pixels\n    if not non_bg_coords_list:\n        return input_grid\n\n    # --- Step 2: Check connectivity ---\n    num_components = check_connectivity(input_grid_np.shape, non_bg_coords_list, non_bg_coords_set)\n\n    # --- Step 3 & 4: Apply transformation based on connectivity ---\n    if num_components == 1:\n        # Single component -> Find thin outline (remove interior pixels)\n        output_grid_np = find_thin_outline(input_grid_np, non_bg_coords_list, color, background_color)\n    else: # num_components > 1\n        # Multiple components -> Fill convex hull\n        output_grid_np = fill_convex_hull(input_grid_np.shape, non_bg_coords_list, color, background_color)\n\n    # --- Step 5: Convert result back to list of lists ---\n    output_grid = output_grid_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 21655,
    "candidates_token_count": 2636,
    "total_token_count": 24291,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 26.20517,
  "retries": 1
}