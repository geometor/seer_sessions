{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nfrom collections import deque\n\n\"\"\"\nTransforms the input grid based on the connectivity of its non-background pixels (assuming white '0' is background).\n\n1.  Identify all non-background pixels and their unique color `C`.\n2.  Determine the number of connected components formed by these pixels using 8-way adjacency (horizontal, vertical, diagonal).\n3.  If there is exactly one connected component:\n    - The output grid contains only the boundary pixels of that component, colored `C`.\n    - A pixel is considered a boundary pixel if it's a non-background pixel adjacent (8-way) to at least one background pixel or the grid edge.\n    - All other pixels in the output grid are background color.\n4.  If there is more than one connected component (or isolated pixels):\n    - Calculate the convex hull polygon enclosing all non-background pixel coordinates.\n    - The output grid contains all pixels inside or on the boundary of this convex hull, colored `C`.\n    - All other pixels are background color.\n    - If there are fewer than 3 non-background pixels, or if the convex hull calculation fails (e.g., collinear points), only the original non-background pixels are colored `C` in the output.\n5.  If there are no non-background pixels, the input grid is returned unchanged.\n\"\"\"\n\ndef find_non_background_pixels(grid_np, background_color=0):\n    \"\"\"Finds coordinates and the unique color of non-background pixels.\"\"\"\n    coords = np.argwhere(grid_np != background_color)\n    if coords.size == 0:\n        return [], -1, set() # No non-background pixels\n\n    colors = grid_np[coords[:, 0], coords[:, 1]]\n    unique_colors = np.unique(colors)\n\n    if len(unique_colors) == 1:\n        main_color = int(unique_colors[0])\n    elif len(unique_colors) > 1:\n        # Task examples imply single color, take the first one if multiple exist\n        main_color = int(unique_colors[0])\n        print(f\"Warning: Multiple non-background colors {unique_colors}. Using {main_color}.\")\n        # Adjust coords if only main_color pixels should be considered (not needed based on examples)\n    else:\n        return [], -1, set() # Should not happen\n\n    # Return coordinates as list of tuples and set for quick lookup\n    coord_list = [tuple(map(int, coord)) for coord in coords]\n    coord_set = set(coord_list)\n    return coord_list, main_color, coord_set\n\ndef check_connectivity(grid_shape, non_bg_coords_list, non_bg_coords_set):\n    \"\"\"Checks the connectivity of non-background pixels using BFS (8-way adjacency).\"\"\"\n    if not non_bg_coords_list:\n        return 0\n\n    rows, cols = grid_shape\n    visited = set()\n    num_components = 0\n\n    for start_coord in non_bg_coords_list:\n        if start_coord not in visited:\n            num_components += 1\n            queue = deque([start_coord])\n            visited.add(start_coord)\n\n            while queue:\n                r, c = queue.popleft()\n\n                # Explore 8 neighbors\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if dr == 0 and dc == 0:\n                            continue # Skip self\n\n                        nr, nc = r + dr, c + dc\n                        neighbor_coord = (nr, nc)\n\n                        # Check if neighbor is a non-background pixel and not visited\n                        # Boundary checks are implicit as coords not in set won't be processed\n                        if neighbor_coord in non_bg_coords_set and neighbor_coord not in visited:\n                            visited.add(neighbor_coord)\n                            queue.append(neighbor_coord)\n    return num_components\n\ndef find_outline(grid_np, non_bg_coords_list, color, background_color=0):\n    \"\"\"Keeps only boundary pixels of a single connected component.\"\"\"\n    output_grid = np.full(grid_np.shape, background_color, dtype=int)\n    rows, cols = grid_np.shape\n\n    for r, c in non_bg_coords_list:\n        is_boundary = False\n        # Check 8 neighbors\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n\n                nr, nc = r + dr, c + dc\n\n                # Check if neighbor is outside grid bounds\n                if not (0 <= nr < rows and 0 <= nc < cols):\n                    is_boundary = True\n                    break\n                # Check if neighbor is background color\n                elif grid_np[nr, nc] == background_color:\n                    is_boundary = True\n                    break\n            if is_boundary:\n                break # Found a boundary condition\n\n        if is_boundary:\n            output_grid[r, c] = color\n\n    return output_grid\n\ndef is_point_in_polygon(point, polygon_vertices):\n    \"\"\"\n    Checks if a point is inside a polygon using the Ray Casting algorithm.\n    Handles points on the boundary as inside.\n    Args:\n        point (tuple): (row, col) of the point to check.\n        polygon_vertices (list): List of (row, col) tuples defining the polygon vertices in order.\n    Returns:\n        bool: True if the point is inside or on the boundary, False otherwise.\n    \"\"\"\n    pr, pc = point\n    num_vertices = len(polygon_vertices)\n    intersections = 0\n\n    for i in range(num_vertices):\n        p1 = polygon_vertices[i]\n        p2 = polygon_vertices[(i + 1) % num_vertices]\n        r1, c1 = p1\n        r2, c2 = p2\n\n        # Check if point is a vertex\n        if (pr, pc) == p1:\n            return True\n            \n        # Check if point lies on a horizontal edge\n        if r1 == r2 == pr and min(c1, c2) <= pc <= max(c1, c2):\n            return True\n\n        # Check if point lies on a vertical edge\n        if c1 == c2 == pc and min(r1, r2) <= pr <= max(r1, r2):\n             return True\n             \n        # Standard ray casting intersection check\n        if min(r1, r2) <= pr < max(r1, r2): # Ray must cross edge vertically\n            # Calculate intersection column (x-coordinate)\n            # Avoid division by zero for vertical lines (handled by on-edge check above)\n            if r1 != r2:\n                 c_intersect = (pr - r1) * (c2 - c1) / (r2 - r1) + c1\n                 # Count intersection if it's to the right of or at the point's column\n                 if c_intersect >= pc:\n                      intersections += 1\n\n    return intersections % 2 == 1\n\n\ndef fill_convex_hull(grid_shape, non_bg_coords_list, color, background_color=0):\n    \"\"\"Fills the convex hull of the given coordinates.\"\"\"\n    output_grid = np.full(grid_shape, background_color, dtype=int)\n    rows, cols = grid_shape\n\n    if not non_bg_coords_list:\n        return output_grid\n\n    points = np.array(non_bg_coords_list)\n\n    # Fallback: Color original points if < 3 points or hull fails\n    def color_original_points():\n        for r, c in non_bg_coords_list:\n            if 0 <= r < rows and 0 <= c < cols:\n                output_grid[r, c] = color\n        return output_grid\n\n    if len(points) < 3:\n        return color_original_points()\n\n    try:\n        hull = ConvexHull(points)\n        # Get vertices in order (ConvexHull provides this)\n        hull_vertices_indices = hull.vertices\n        hull_vertices = [tuple(map(int, points[i])) for i in hull_vertices_indices]\n\n        # Find bounding box of the hull for efficiency\n        min_r = int(np.min(points[hull_vertices_indices, 0]))\n        max_r = int(np.max(points[hull_vertices_indices, 0]))\n        min_c = int(np.min(points[hull_vertices_indices, 1]))\n        max_c = int(np.max(points[hull_vertices_indices, 1]))\n\n        # Iterate through pixels within the bounding box\n        for r in range(max(0, min_r), min(rows, max_r + 1)):\n            for c in range(max(0, min_c), min(cols, max_c + 1)):\n                if is_point_in_polygon((r, c), hull_vertices):\n                    output_grid[r, c] = color\n\n    except Exception as e:\n        # Catch scipy errors (e.g., QhullError for collinear points)\n        print(f\"Convex Hull calculation/filling failed: {e}. Coloring original points.\")\n        return color_original_points()\n\n    return output_grid\n\n\ndef transform(input_grid):\n    # Convert input to numpy array\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    background_color = 0\n\n    # Find non-background pixels, their color, and a set of coordinates\n    non_bg_coords_list, color, non_bg_coords_set = find_non_background_pixels(input_grid_np, background_color)\n\n    # Handle empty case\n    if not non_bg_coords_list:\n        return input_grid # Return original grid\n\n    # Check connectivity\n    num_components = check_connectivity(input_grid_np.shape, non_bg_coords_list, non_bg_coords_set)\n\n    # Apply transformation based on connectivity\n    if num_components == 1:\n        # Single component -> Find outline\n        output_grid_np = find_outline(input_grid_np, non_bg_coords_list, color, background_color)\n    else: # num_components > 1 or potentially 0 (handled by empty check)\n        # Multiple components -> Fill convex hull\n        output_grid_np = fill_convex_hull(input_grid_np.shape, non_bg_coords_list, color, background_color)\n\n    # Convert result back to list of lists\n    output_grid = output_grid_np.tolist()\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 10832,
    "candidates_token_count": 2522,
    "total_token_count": 13354,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 36.520717,
  "retries": 1
}