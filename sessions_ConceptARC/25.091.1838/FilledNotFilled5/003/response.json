{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\n1. Identify the background color (assumed white, 0) and the primary object's color.\n2. Determine if the object is \"hollow\" (contains enclosed background pixels) or \"solid\" using a 4-way flood fill from border background pixels.\n3. If \"hollow\", fill the enclosed background pixels (holes) with the object's color.\n4. If \"solid\", hollow the object by changing object pixels that are *not* 4-way adjacent to any background pixel to the background color. Keep object pixels adjacent to background pixels.\n5. Return the modified grid.\n\"\"\"\n\ndef find_colors(grid):\n    \"\"\"Identifies the background (assumed 0) and object colors.\"\"\"\n    unique_colors = np.unique(grid)\n    background_color = 0\n    object_color = -1\n    for color in unique_colors:\n        if color != background_color:\n            # Assuming only one non-background color based on examples\n            object_color = color\n            break\n    # If only background color is present\n    if object_color == -1:\n        object_color = background_color\n    return background_color, object_color\n\ndef find_reachable_background(grid, background_color):\n    \"\"\"\n    Finds all background pixels reachable from the border using 4-way flood fill.\n    Returns a boolean grid where True indicates a reachable background pixel.\n    \"\"\"\n    rows, cols = grid.shape\n    reachable = np.zeros_like(grid, dtype=bool)\n    queue = deque()\n\n    # Add border background pixels to the queue\n    for r in range(rows):\n        for c in [0, cols - 1]:\n            if grid[r, c] == background_color and not reachable[r, c]:\n                reachable[r, c] = True\n                queue.append((r, c))\n    for c in range(1, cols - 1): # Avoid double-adding corners\n        for r in [0, rows - 1]:\n             if grid[r, c] == background_color and not reachable[r, c]:\n                reachable[r, c] = True\n                queue.append((r, c))\n\n    # Perform BFS (flood fill)\n    while queue:\n        r, c = queue.popleft()\n        # Check 4 neighbors (N, S, E, W)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == background_color and not reachable[nr, nc]:\n                reachable[nr, nc] = True\n                queue.append((nr, nc))\n    return reachable\n\ndef is_hollow(grid, background_color, reachable_background):\n    \"\"\"Checks if any background pixels are unreachable from the border.\"\"\"\n    rows, cols = grid.shape\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == background_color and not reachable_background[r, c]:\n                return True # Found an enclosed background pixel\n    return False\n\ndef fill_holes(grid, object_color, reachable_background):\n    \"\"\"Fills unreachable background areas (holes) with the object color.\"\"\"\n    output_grid = np.copy(grid)\n    rows, cols = grid.shape\n    background_color = 0 # Assuming background is 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == background_color and not reachable_background[r, c]:\n                output_grid[r, c] = object_color\n    return output_grid\n\ndef hollow_object(grid, background_color, object_color):\n    \"\"\"\n    Changes interior pixels (not 4-way adjacent to background) of a solid\n    object to the background color.\n    \"\"\"\n    rows, cols = grid.shape\n    output_grid = np.copy(grid)\n\n    # Iterate through each pixel potentially belonging to the object\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == object_color:\n                is_boundary = False\n                # Check 4 neighbors (N, S, E, W)\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    # Check if neighbor is within bounds\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        # If any neighbor is the background color, it's a boundary pixel\n                        if grid[nr, nc] == background_color:\n                            is_boundary = True\n                            break\n                    else:\n                        # If a neighbor position is out of bounds, the pixel is on the grid edge,\n                        # treat it as adjacent to background implicitly.\n                        is_boundary = True\n                        break\n\n                # If the object pixel is NOT a boundary pixel (i.e., it's interior),\n                # change it to background color in the output grid.\n                if not is_boundary:\n                   output_grid[r, c] = background_color\n\n    return output_grid\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by either filling a hollow object or\n    hollowing a solid object based on adjacency rules.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n\n    # Identify background and object colors\n    background_color, object_color = find_colors(grid_np)\n\n    # Handle edge case: grid is all one color (no distinct object)\n    if object_color == background_color:\n         return grid_np.tolist() # Return the original grid\n\n    # Find background pixels reachable from the border\n    reachable_background = find_reachable_background(grid_np, background_color)\n\n    # Determine if the object is hollow\n    hollow = is_hollow(grid_np, background_color, reachable_background)\n\n    # Apply the appropriate transformation\n    if hollow:\n        # Fill the holes using the pre-calculated reachable map\n        output_grid_np = fill_holes(grid_np, object_color, reachable_background)\n    else:\n        # Hollow the solid object based on 4-way adjacency to background\n        output_grid_np = hollow_object(grid_np, background_color, object_color)\n\n    # Convert the result back to a list of lists\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12578,
    "candidates_token_count": 1552,
    "total_token_count": 14130,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.196588,
  "retries": 1
}