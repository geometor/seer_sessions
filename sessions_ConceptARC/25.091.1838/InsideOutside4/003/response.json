{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nTransformation Rule:\nConditionally change a single unique magenta pixel (color 6) to white (color 0)\nbased on the colors of its two innermost enclosing non-background objects.\n\n1. Locate the unique magenta pixel (P, color 6). If not found or not unique, return the input grid.\n2. Find the background region (color 0) immediately adjacent to P using flood fill (BFS) starting from a background neighbor of P.\n3. Identify the color (C_inner) of the object forming the immediate boundary of this background region (excluding color 6). The fill must not reach the grid boundary, and C_inner must be unique. If not, return the input grid.\n4. Find the background region (color 0) immediately adjacent to the C_inner object using flood fill starting from a background neighbor of any C_inner pixel.\n5. Identify the color (C_outer) of the object forming the immediate boundary of this second background region (excluding C_inner). The fill must not reach the grid boundary, and C_outer must be unique. If not, return the input grid.\n6. Check if the color pair (C_inner, C_outer) matches specific conditions:\n   - (Yellow=4, Red=2) OR\n   - (Blue=1, Green=3)\n7. If a condition is met, change the magenta pixel P to white (0) in a copy of the grid and return the copy.\n8. Otherwise, return the original input grid unchanged.\n\"\"\"\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    coords_array = np.argwhere(grid == color)\n    return [tuple(coord) for coord in coords_array]\n\ndef find_adjacent_pixel(grid, start_coords, target_color):\n    \"\"\"\n    Finds the coordinates of the first pixel with target_color adjacent \n    (4-connectivity) to any of the start_coords. Returns None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    q = deque(start_coords)\n    visited = set(start_coords) # Avoid checking pixels within the starting shape\n\n    processed_neighbors = set() # Keep track of neighbours already checked\n\n    while q:\n        r, c = q.popleft()\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                if neighbor_pos not in visited and neighbor_pos not in processed_neighbors:\n                    processed_neighbors.add(neighbor_pos) # Mark as checked\n                    if grid[nr, nc] == target_color:\n                        return neighbor_pos # Found one\n                    # If it's not the target, but part of the original shape color, add to queue\n                    # This helps explore the boundary of the start_coords shape.\n                    # We assume start_coords belong to a contiguous object of the same color.\n                    # This part might be unnecessary if start_coords is just one pixel.\n                    # If start_coords can be multiple, need grid[r,c] == grid[nr,nc] check maybe?\n                    # For this problem:\n                    # - First call: start_coords is just the single magenta pixel P.\n                    # - Second call: start_coords are all pixels of C_inner.\n                    # Let's simplify: only check immediate neighbors of the initial start_coords list.\n                    \n    # Simplified approach: Iterate through initial coords and check direct neighbors\n    rows, cols = grid.shape\n    initial_coords_set = set(start_coords)\n    for r, c in start_coords:\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                # Check if neighbor is the target color AND not part of the initial set\n                # (relevant if target_color could be the same as start_coords color)\n                if grid[nr, nc] == target_color and neighbor_pos not in initial_coords_set:\n                    return neighbor_pos\n    return None\n\n\ndef get_unique_colors(grid, coords):\n    \"\"\"Gets the set of unique non-zero colors at the given coordinates.\"\"\"\n    colors = set()\n    rows, cols = grid.shape\n    for r, c in coords:\n        # Coords should be valid if coming from flood_fill adjacent set\n        color = grid[r, c]\n        if color != 0: # Ignore background color\n            colors.add(color)\n    return colors\n\ndef flood_fill_boundary(grid, start_pos):\n    \"\"\"\n    Performs a flood fill (BFS) starting from start_pos, traversing only background (0).\n    Identifies the boundary pixels (non-zero adjacent to the fill) and if the fill hits the grid edge.\n\n    Args:\n        grid: The numpy grid.\n        start_pos: The (row, col) tuple to start from (must be background color 0).\n\n    Returns:\n        A tuple: (boundary_coords, boundary_reached)\n        - boundary_coords: set of (row, col) of non-background pixels adjacent to the filled area.\n        - boundary_reached: boolean indicating if the fill touched the grid edge.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Ensure start pos is valid background\n    start_r, start_c = start_pos\n    if not (0 <= start_r < rows and 0 <= start_c < cols and grid[start_r, start_c] == 0):\n         # Invalid start position for this specific flood fill\n         return set(), True # Treat as boundary reached if start is invalid\n\n    q = deque([start_pos])\n    visited = {start_pos}\n    boundary_coords = set()\n    boundary_reached = False\n\n    # Check if start position itself is on the boundary\n    if start_r == 0 or start_r == rows - 1 or start_c == 0 or start_c == cols - 1:\n        boundary_reached = True\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is out of bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                boundary_reached = True\n                continue # Don't process out-of-bounds coordinates further\n\n            # Process in-bounds neighbor\n            neighbor_pos = (nr, nc)\n            if neighbor_pos not in visited:\n                visited.add(neighbor_pos)\n                neighbor_color = grid[nr, nc]\n\n                # If neighbor is background (0), add to queue\n                if neighbor_color == 0:\n                    q.append(neighbor_pos)\n                    # Check if this newly added traversable cell is on boundary\n                    if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:\n                        boundary_reached = True\n                # If neighbor is not background (non-zero), add to boundary set\n                else:\n                    boundary_coords.add(neighbor_pos)\n\n    return boundary_coords, boundary_reached\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional color change based on nested object colors.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid) # Start with a copy\n\n    # --- Step 1: Locate Target ---\n    magenta_pixels = find_pixels(output_grid, 6)\n    if len(magenta_pixels) != 1:\n        return input_grid_list # Return original if not exactly one magenta pixel\n    target_pos = magenta_pixels[0]\n\n    # --- Step 2: Find adjacent background pixel to start Fill 1 ---\n    start_pos1 = find_adjacent_pixel(output_grid, [target_pos], 0)\n    if start_pos1 is None:\n        # Magenta pixel is not adjacent to any background pixel\n        return input_grid_list\n\n    # --- Step 3: Perform Fill 1 and find C_inner ---\n    boundary1_coords, boundary1_reached = flood_fill_boundary(output_grid, start_pos1)\n    if boundary1_reached:\n        # The background area around the magenta pixel reaches the edge -> not enclosed\n        return input_grid_list\n\n    # Identify potential inner colors (non-zero colors on the boundary)\n    colors1 = get_unique_colors(output_grid, boundary1_coords)\n    # Remove the target magenta color itself from consideration\n    colors1.discard(6)\n    \n    if len(colors1) != 1:\n        # Must have exactly one unique non-background color (besides 6) forming the boundary\n        return input_grid_list\n    C_inner = list(colors1)[0]\n\n    # --- Step 4: Find C_inner pixels and adjacent background pixel to start Fill 2 ---\n    c_inner_pixels = find_pixels(output_grid, C_inner)\n    if not c_inner_pixels:\n         # Should not happen if C_inner was found, but safety check\n         return input_grid_list\n         \n    start_pos2 = find_adjacent_pixel(output_grid, c_inner_pixels, 0)\n    if start_pos2 is None:\n        # C_inner object is not adjacent to any background pixel (fills grid or touches only non-background?)\n        # This implies C_inner object might be touching the outer boundary directly or only other colors.\n        # If it fills the grid or touches only non-background, it can't be enclosed by C_outer via background.\n        return input_grid_list\n\n    # --- Step 5: Perform Fill 2 and find C_outer ---\n    boundary2_coords, boundary2_reached = flood_fill_boundary(output_grid, start_pos2)\n    if boundary2_reached:\n        # The background area around the C_inner object reaches the edge -> C_inner not enclosed\n        return input_grid_list\n\n    # Identify potential outer colors\n    colors2 = get_unique_colors(output_grid, boundary2_coords)\n    # Remove the C_inner color itself from consideration\n    colors2.discard(C_inner)\n\n    if len(colors2) != 1:\n        # Must have exactly one unique non-background color (besides C_inner) forming the outer boundary\n        return input_grid_list\n    C_outer = list(colors2)[0]\n\n    # --- Step 6: Evaluate Condition ---\n    condition_met = False\n    # Check for Yellow (4) inside Red (2)\n    if C_inner == 4 and C_outer == 2:\n        condition_met = True\n    # Check for Blue (1) inside Green (3)\n    elif C_inner == 1 and C_outer == 3:\n        condition_met = True\n\n    # --- Step 7 & 8: Apply Transformation or Return Original ---\n    if condition_met:\n        # Modify the output grid copy\n        r_target, c_target = target_pos\n        output_grid[r_target, c_target] = 0\n        return output_grid.tolist() # Return the modified grid\n    else:\n        # Condition not met, return the original unchanged input grid\n        return input_grid_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17165,
    "candidates_token_count": 2738,
    "total_token_count": 19903,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 61.947693,
  "retries": 1
}