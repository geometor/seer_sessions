{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nConditionally changes a single unique magenta pixel (color 6) to white (color 0)\nbased on the colors of the two closest enclosing objects found by exploring outwards \nthrough adjacent background pixels using Breadth-First Search (BFS).\n\nTransformation Steps:\n1. Locate the unique magenta pixel (P). Exit if not found or not unique.\n2. Find the first non-background, non-magenta color (C_inner) encountered by BFS starting \n   from a background neighbor of P, exploring only background. Exit if none found.\n3. Find the first non-background color (C_outer) encountered by BFS starting from a \n   background neighbor of any C_inner pixel, exploring only background. C_outer must not be C_inner or magenta. Exit if none found.\n4. Check if (C_inner=4 (yellow), C_outer=2 (red)) or (C_inner=1 (blue), C_outer=3 (green)).\n5. If the condition holds, change pixel P to white (0) in a copy of the grid. Otherwise, make no change.\n6. Return the resulting grid as a list of lists.\n\"\"\"\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    # Ensure grid is numpy array for efficient searching\n    if not isinstance(grid, np.ndarray):\n        grid_np = np.array(grid, dtype=int)\n    else:\n        grid_np = grid\n    # Use np.argwhere to find coordinates\n    return list(map(tuple, np.argwhere(grid_np == color)))\n\ndef find_adjacent_pixel(grid, start_coords, target_color):\n    \"\"\"\n    Finds the coordinates of the first pixel with target_color adjacent \n    (4-connectivity) to any of the start_coords. Returns None if not found.\n    Assumes grid is a numpy array.\n    \"\"\"\n    rows, cols = grid.shape\n    initial_coords_set = set(start_coords)\n    \n    for r, c in start_coords:\n         # Check 4 neighbors\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                # Check if neighbor has the target color and is not part of the starting set\n                if grid[nr, nc] == target_color and neighbor_pos not in initial_coords_set:\n                    return neighbor_pos # Found one\n    return None # Not found\n\ndef find_first_enclosing_color(grid, start_pos, excluded_colors):\n    \"\"\"\n    Performs BFS starting from start_pos (must be background) traversing only background (0).\n    Returns the color (as standard Python int) of the first non-background neighbor \n    encountered whose color is NOT in excluded_colors.\n    Returns None if the BFS completes without finding such a neighbor or if start_pos is invalid.\n    Assumes grid is a numpy array.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Validate start_pos: must be within bounds and background color (0)\n    if start_pos is None or not (0 <= start_pos[0] < rows and 0 <= start_pos[1] < cols and grid[start_pos] == 0):\n         return None # Invalid start\n\n    q = deque([start_pos])\n    visited_background = {start_pos}\n    \n    # Ensure excluded colors are standard Python ints\n    excluded_colors_int = {int(ex) for ex in excluded_colors}\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue # Skip out-of-bounds\n\n            neighbor_pos = (nr, nc)\n            neighbor_color = grid[nr, nc]\n\n            # If neighbor is background (0) and not visited, add to queue\n            if neighbor_color == 0:\n                if neighbor_pos not in visited_background:\n                    visited_background.add(neighbor_pos)\n                    q.append(neighbor_pos)\n            # If neighbor is non-background\n            else:\n                # Convert color to standard int for checks and return\n                neighbor_color_int = int(neighbor_color) \n                # Check if its color is one we are looking for (not excluded)\n                if neighbor_color_int not in excluded_colors_int:\n                    return neighbor_color_int # Found the first valid enclosing color\n\n    # If queue empties and we haven't returned, no valid enclosing color was found\n    return None\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional color change based on the nested object color logic.\n    \n    Args:\n        input_grid_list: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the output grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient processing\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Create a copy to modify, ensuring the original is unchanged if conditions aren't met\n    output_grid = np.copy(input_grid) \n\n    # --- Step 1: Locate Target ---\n    # Find all magenta pixels (color 6)\n    magenta_pixels = find_pixels(output_grid, 6)\n    # Check if exactly one magenta pixel exists\n    if len(magenta_pixels) != 1:\n        # Return the original grid if not exactly one magenta pixel\n        return input_grid_list \n    target_pos = magenta_pixels[0]\n\n    # --- Step 2: Find Inner Color (C_inner) ---\n    # Find a background pixel (color 0) adjacent to the target magenta pixel\n    start_pos_inner = find_adjacent_pixel(output_grid, [target_pos], 0)\n    if start_pos_inner is None:\n        # If no adjacent background pixel, cannot perform search, return original\n        return input_grid_list\n        \n    # Search outwards from the adjacent background pixel using BFS\n    # Find the first non-background, non-magenta color encountered.\n    # Exclude background (0) and magenta (6) from being considered the inner color.\n    C_inner = find_first_enclosing_color(output_grid, start_pos_inner, {0, 6})\n    if C_inner is None:\n        # If BFS doesn't find a suitable inner enclosing color, return original\n        return input_grid_list\n\n    # --- Step 3: Find Outer Color (C_outer) ---\n    # Find all pixels belonging to the inner object (color C_inner)\n    c_inner_pixels = find_pixels(output_grid, C_inner)\n    if not c_inner_pixels:\n         # Safety check: if no pixels found for C_inner (shouldn't happen), return original\n         return input_grid_list\n         \n    # Find a background pixel adjacent to any of the inner object's pixels\n    start_pos_outer = find_adjacent_pixel(output_grid, c_inner_pixels, 0)\n    if start_pos_outer is None:\n        # If the C_inner object has no adjacent background pixels, it cannot be enclosed by another\n        # object via background space, so return original.\n        return input_grid_list\n\n    # Search outwards from this new background starting point using BFS.\n    # Exclude background (0), magenta (6), and the inner color (C_inner) itself.\n    C_outer = find_first_enclosing_color(output_grid, start_pos_outer, {0, 6, C_inner})\n    if C_outer is None:\n        # If BFS doesn't find a suitable outer enclosing color, return original\n        return input_grid_list\n\n    # --- Step 4: Evaluate Condition ---\n    condition_met = False\n    # Check for the specific required pairs of inner and outer colors\n    # Condition 1: Yellow (4) inside Red (2)\n    if C_inner == 4 and C_outer == 2:\n        condition_met = True\n    # Condition 2: Blue (1) inside Green (3)\n    elif C_inner == 1 and C_outer == 3:\n        condition_met = True\n\n    # --- Step 5: Apply Transformation or Return Original ---\n    if condition_met:\n        # If the condition is met, modify the output grid copy\n        r_target, c_target = target_pos\n        # Change the target magenta pixel to white (0)\n        output_grid[r_target, c_target] = 0\n        # Return the modified grid as a list of lists\n        return output_grid.tolist() \n    else:\n        # If condition is not met, return the original unchanged input grid\n        return input_grid_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 43737,
    "candidates_token_count": 2159,
    "total_token_count": 45896,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.583508,
  "retries": 1
}