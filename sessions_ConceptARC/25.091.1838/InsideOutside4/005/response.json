{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nConditionally changes a single unique magenta pixel (color 6) to white (color 0)\nbased on the colors of the two closest enclosing objects found by exploring outwards \nthrough adjacent background pixels using Breadth-First Search (BFS).\n\nTransformation Steps:\n1. Locate the unique magenta pixel (P). Exit if not found or not unique.\n2. Find the first non-background, non-magenta color (C_inner) encountered by BFS starting \n   from a background neighbor of P, exploring only background. Exit if none found.\n3. Find the first non-background color (C_outer) encountered by BFS starting from a \n   background neighbor of any C_inner pixel, exploring only background. C_outer must not be C_inner or magenta. Exit if none found.\n4. Check if (C_inner=4, C_outer=2) or (C_inner=1, C_outer=3).\n5. If the condition holds, change pixel P to white (0). Otherwise, make no change.\n\"\"\"\n\ndef find_pixels(grid, color):\n    \"\"\"Finds all coordinates (row, col) of pixels with a specific color.\"\"\"\n    return list(map(tuple, np.argwhere(grid == color)))\n\ndef find_adjacent_pixel(grid, start_coords, target_color):\n    \"\"\"\n    Finds the coordinates of the first pixel with target_color adjacent \n    (4-connectivity) to any of the start_coords. Returns None if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    initial_coords_set = set(start_coords)\n    \n    # Use a queue to explore boundary efficiently if start_coords is large,\n    # but for small number of start points, direct checking is fine.\n    # Let's stick to direct checking for simplicity based on the refined NL program.\n    for r, c in start_coords:\n         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbor_pos = (nr, nc)\n                # Ensure neighbor is the target color and not part of the initial set\n                if grid[nr, nc] == target_color and neighbor_pos not in initial_coords_set:\n                    return neighbor_pos # Found one\n    return None # Not found\n\ndef find_first_enclosing_color(grid, start_pos, excluded_colors):\n    \"\"\"\n    Performs BFS starting from start_pos (must be background) traversing only background (0).\n    Returns the color of the first non-background neighbor encountered whose color is NOT in excluded_colors.\n    Returns None if the BFS completes without finding such a neighbor.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Basic check: start_pos should be background\n    if not (0 <= start_pos[0] < rows and 0 <= start_pos[1] < cols and grid[start_pos] == 0):\n        return None # Invalid start\n\n    q = deque([start_pos])\n    visited_background = {start_pos}\n    \n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                continue # Skip out-of-bounds\n\n            neighbor_pos = (nr, nc)\n            neighbor_color = grid[nr, nc]\n\n            # If neighbor is background and not visited, add to queue\n            if neighbor_color == 0:\n                if neighbor_pos not in visited_background:\n                    visited_background.add(neighbor_pos)\n                    q.append(neighbor_pos)\n            # If neighbor is non-background\n            else:\n                # Check if its color is one we are looking for (not excluded)\n                if neighbor_color not in excluded_colors:\n                    return neighbor_color # Found the first enclosing color\n\n    # If queue empties and we haven't returned, no valid enclosing color was found\n    return None\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Applies the conditional color change based on the refined nested object color logic.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    output_grid = np.copy(input_grid) # Start with a copy\n\n    # --- Step 1: Locate Target ---\n    magenta_pixels = find_pixels(output_grid, 6)\n    if len(magenta_pixels) != 1:\n        return input_grid_list # Return original if not exactly one magenta pixel\n    target_pos = magenta_pixels[0]\n\n    # --- Step 2: Find Inner Color (C_inner) ---\n    # Find a background pixel adjacent to the target to start the search\n    start_pos_inner = find_adjacent_pixel(output_grid, [target_pos], 0)\n    if start_pos_inner is None:\n        # Magenta pixel is not adjacent to any background pixel\n        return input_grid_list\n        \n    # Search outwards from this background pixel for the first non-background, non-magenta color\n    C_inner = find_first_enclosing_color(output_grid, start_pos_inner, {0, 6})\n    if C_inner is None:\n        # BFS did not find a suitable inner enclosing color\n        return input_grid_list\n\n    # --- Step 3: Find Outer Color (C_outer) ---\n    # Find all pixels belonging to the inner object\n    c_inner_pixels = find_pixels(output_grid, C_inner)\n    if not c_inner_pixels:\n         # Should not happen if C_inner was found, but safety check\n         return input_grid_list\n         \n    # Find a background pixel adjacent to the inner object to start the next search\n    start_pos_outer = find_adjacent_pixel(output_grid, c_inner_pixels, 0)\n    if start_pos_outer is None:\n        # C_inner object has no adjacent background pixels\n        return input_grid_list\n\n    # Search outwards from this background pixel for the first non-background color\n    # that is neither the inner color nor magenta.\n    C_outer = find_first_enclosing_color(output_grid, start_pos_outer, {0, 6, C_inner})\n    if C_outer is None:\n        # BFS did not find a suitable outer enclosing color\n        return input_grid_list\n\n    # --- Step 4: Evaluate Condition ---\n    condition_met = False\n    # Check for Yellow (4) inside Red (2)\n    if C_inner == 4 and C_outer == 2:\n        condition_met = True\n    # Check for Blue (1) inside Green (3)\n    elif C_inner == 1 and C_outer == 3:\n        condition_met = True\n\n    # --- Step 5: Apply Transformation or Return Original ---\n    if condition_met:\n        # Modify the output grid copy\n        r_target, c_target = target_pos\n        output_grid[r_target, c_target] = 0\n        return output_grid.tolist() # Return the modified grid\n    else:\n        # Condition not met, return the original unchanged input grid\n        return input_grid_list\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19808,
    "candidates_token_count": 1760,
    "total_token_count": 21568,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.703879,
  "retries": 1
}