
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 1 1 1 0 0
0 1 0 0 0 0 0 0 0 0 0 1 0 0
0 1 0 3 3 3 3 3 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 0 0 6 0 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 3 3 3 3 3 0 0 1 0 0
0 1 0 0 0 0 0 0 0 0 0 1 0 0
0 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 1 1 1 0 0
0 1 0 0 0 0 0 0 0 0 0 1 0 0
0 1 0 3 3 3 3 3 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 0 0 6 0 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 0 0 0 0 3 0 0 1 0 0
0 1 0 3 3 3 3 3 3 0 0 1 0 0
0 1 0 0 0 0 0 0 0 0 0 1 0 0
0 1 1 1 1 1 1 1 1 1 1 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 0 0 0 0 0
0 0 2 2 2 2 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 2 2 2 2 0 0
0 0 2 0 4 4 4 4 0 0 0 2 0 0
2 2 2 0 4 0 0 4 0 6 0 2 0 0
2 0 0 0 4 4 4 4 0 0 0 2 0 0
2 0 0 0 0 0 0 0 2 2 2 2 0 0
2 2 2 2 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 2 2 2 2 0 0 0 0 0
0 0 2 2 2 2 0 0 2 0 0 0 0 0
0 0 2 0 0 0 0 0 2 2 2 2 0 0
0 0 2 0 4 4 4 4 0 0 0 2 0 0
2 2 2 0 4 0 0 4 0 0 0 2 0 0
2 0 0 0 4 4 4 4 0 0 0 2 0 0
2 0 0 0 0 0 0 0 2 2 2 2 0 0
2 2 2 2 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 0 0 0 2 0 0 0 0 0
0 0 0 0 2 2 2 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 3 0 0 0 0 7 7 0 0 0 0 0 3
0 3 0 0 0 7 0 7 0 0 0 0 0 3
0 3 0 0 7 0 0 7 0 0 0 0 0 3
0 3 0 7 0 0 0 0 7 0 0 0 0 3
0 3 7 0 0 0 0 0 0 7 0 0 0 3
0 3 7 0 0 6 0 0 0 0 7 0 0 3
0 3 7 0 0 0 0 0 0 0 0 7 0 3
0 3 7 0 0 0 0 0 0 0 0 0 7 3
0 3 7 7 7 7 7 7 7 7 7 7 7 3
0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 3 0 0 0 0 7 7 0 0 0 0 0 3
0 3 0 0 0 7 0 7 0 0 0 0 0 3
0 3 0 0 7 0 0 7 0 0 0 0 0 3
0 3 0 7 0 0 0 0 7 0 0 0 0 3
0 3 7 0 0 0 0 0 0 7 0 0 0 3
0 3 7 0 0 6 0 0 0 0 7 0 0 3
0 3 7 0 0 0 0 0 0 0 0 7 0 3
0 3 7 0 0 0 0 0 0 0 0 0 7 3
0 3 7 7 7 7 7 7 7 7 7 7 7 3
0 3 3 3 3 3 3 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_4

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 3 3 0 0 0 0 0 0 0 0 3 3 0
3 0 0 0 1 1 1 1 1 1 0 0 0 3
3 0 0 1 1 1 0 0 0 1 1 0 0 3
3 0 0 1 1 0 0 0 0 0 1 1 0 3
3 0 0 0 1 0 0 0 0 0 0 1 1 3
0 3 0 0 0 1 1 0 0 0 0 0 1 3
0 3 3 0 6 0 0 1 0 0 0 0 1 3
0 0 3 0 0 0 0 1 1 0 0 1 0 3
0 0 3 3 3 0 0 0 1 1 1 1 0 3
0 0 0 0 3 3 3 0 0 0 0 0 0 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 3 3 3 3 3 3 3 3 3 0 0
0 3 3 0 0 0 0 0 0 0 0 3 3 0
3 0 0 0 1 1 1 1 1 1 0 0 0 3
3 0 0 1 1 1 0 0 0 1 1 0 0 3
3 0 0 1 1 0 0 0 0 0 1 1 0 3
3 0 0 0 1 0 0 0 0 0 0 1 1 3
0 3 0 0 0 1 1 0 0 0 0 0 1 3
0 3 3 0 0 0 0 1 0 0 0 0 1 3
0 0 3 0 0 0 0 1 1 0 0 1 0 3
0 0 3 3 3 0 0 0 1 1 1 1 0 3
0 0 0 0 3 3 3 0 0 0 0 0 0 3
0 0 0 0 0 0 0 3 3 3 3 3 3 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

**Perception of Task Elements**

1.  **Input/Output:** Both input and output are grids of pixels with colors represented by integers 0-9.
2.  **Background:** The background color is consistently white (0).
3.  **Objects:** The grids contain distinct objects, which are contiguous areas of non-white pixels. These objects often form nested structures or frames.
4.  **Key Pixel:** A single magenta pixel (color 6) appears in a specific location within the nested structures in each input grid.
5.  **Transformation:** The core transformation observed involves conditionally changing the color of the single magenta pixel to white (0). In some examples, the grid remains unchanged.
6.  **Condition:** The change depends on the colors of the objects immediately surrounding the magenta pixel. Specifically, it seems related to the color pair of the innermost object containing the magenta pixel and the next object containing the innermost one.

**YAML Fact Document**


```yaml
task_description: "Conditionally change a single magenta pixel based on the colors of its two innermost containing objects."

elements:
  - element: grid
    description: "A 2D array of pixels representing colors 0-9."
  - element: pixel
    properties:
      - color: integer value 0-9
      - position: (row, column) coordinates
  - element: background
    value: 0 (white)
    description: "The default color filling empty space."
  - element: object
    description: "A contiguous block of pixels of the same non-background color."
    properties:
      - color: The color of the pixels in the object.
      - pixels: Set of (row, column) coordinates belonging to the object.
      - connectivity: Usually 4-connectivity or 8-connectivity (appears to be 8-connectivity here based on how objects enclose).
  - element: target_pixel
    description: "The specific pixel being evaluated for transformation."
    properties:
      - color: 6 (magenta)
      - uniqueness: Appears to be exactly one such pixel in relevant inputs.
  - element: containing_object
    description: "An object that encloses a given pixel or another object."
    relation: "A pixel P is contained within object O if any path from P to the grid border must intersect O."

transformation:
  - action: identify
    target: target_pixel (magenta, 6)
    condition: "Must be exactly one magenta pixel present."
  - action: identify_containment
    target: target_pixel
    details: "Determine the sequence of nested objects containing the target_pixel. Need at least two levels of containment."
    outputs:
      - innermost_object: O_inner (Color: C_inner)
      - next_outer_object: O_outer (Color: C_outer)
  - action: conditional_change
    target: target_pixel
    condition: "(C_inner == 4 (yellow) AND C_outer == 2 (red)) OR (C_inner == 1 (blue) AND C_outer == 3 (green))"
    effect: "Change target_pixel color to 0 (white)."
  - action: no_change
    condition: "If the target_pixel is not found, not unique, not contained by at least two objects, or the color condition is not met."
    effect: "Output grid is identical to the input grid."

```


**Natural Language Program**

1.  **Locate Target:** Find the unique pixel with the color magenta (6) in the input grid. If there isn't exactly one magenta pixel, return the input grid unchanged. Let the location of this pixel be `P`.
2.  **Check Innermost Containment:** Determine the innermost object (`O_inner`) that completely encloses the magenta pixel `P`. This means any path from `P` travelling only through the background color (white, 0) cannot reach the grid boundary without hitting `O_inner`. If no such object exists (i.e., `P` can reach the boundary), return the input grid unchanged. Let the color of `O_inner` be `C_inner`.
3.  **Check Next Outer Containment:** Determine the next object (`O_outer`) that completely encloses the object `O_inner`. This means any path starting from a pixel of `O_inner` and travelling only through the background color (white, 0) or the color `C_inner` cannot reach the grid boundary without hitting `O_outer`. If no such object `O_outer` exists, return the input grid unchanged. Let the color of `O_outer` be `C_outer`.
4.  **Evaluate Condition:** Check if the colors `C_inner` and `C_outer` match specific pairs:
    *   Is `C_inner` yellow (4) AND `C_outer` red (2)?
    *   OR is `C_inner` blue (1) AND `C_outer` green (3)?
5.  **Apply Transformation:**
    *   If either condition in step 4 is true, create a copy of the input grid, change the color of the pixel at location `P` to white (0), and return this modified grid.
    *   Otherwise (if neither condition is true), return the input grid unchanged.
```python
import numpy as np
from collections import deque

"""
Conditionally changes a single magenta pixel (6) to white (0) based on the
colors of its two innermost containing non-background objects.

The transformation rule is as follows:
1. Locate the unique magenta pixel (color 6). If not found or not unique, return the input grid.
2. Determine the color of the immediate object enclosing the magenta pixel and its surrounding white space (if any). Let this be C_inner. If no single enclosing object color is found, return the input grid.
3. Determine the color of the object immediately enclosing the C_inner object and its surrounding white space (if any). Let this be C_outer. If no single enclosing object color is found, return the input grid.
4. Check if the color pair (C_inner, C_outer) matches specific conditions:
   - (Yellow=4, Red=2) OR
   - (Blue=1, Green=3)
5. If a condition is met, change the magenta pixel to white (0). Otherwise, return the input grid unchanged.

Containment is determined using flood fill (BFS). A pixel/object is considered contained if a flood fill starting from it (traversing background color 0 and the object's own color) cannot reach the grid boundary.
"""

def find_pixel(grid, color):
    """Finds all coordinates of pixels with a specific color."""
    # Use numpy's where function for efficiency
    coords_array = np.argwhere(grid == color)
    # Convert numpy array to list of tuples
    return [tuple(coord) for coord in coords_array]

def get_unique_colors(grid, coords):
    """Gets the set of unique non-zero colors at the given coordinates."""
    colors = set()
    rows, cols = grid.shape
    for r, c in coords:
        # Ensure coordinates are within bounds (though they should be from flood_fill)
        if 0 <= r < rows and 0 <= c < cols:
            color = grid[r, c]
            if color != 0: # Ignore background color
                colors.add(color)
    return colors

def flood_fill(grid, start_pos, traversable_colors):
    """
    Performs a flood fill (BFS) starting from start_pos.

    Args:
        grid: The numpy grid.
        start_pos: The (row, col) tuple to start from.
        traversable_colors: A set of colors allowed to traverse.

    Returns:
        A tuple: (filled_coords, adjacent_coords, boundary_reached)
        - filled_coords: set of (row, col) visited during the fill.
        - adjacent_coords: set of (row, col) neighboring the filled region but not part of it.
        - boundary_reached: boolean indicating if the fill touched the grid edge.
    """
    rows, cols = grid.shape
    
    # Ensure start pos is valid and traversable
    start_r, start_c = start_pos
    if not (0 <= start_r < rows and 0 <= start_c < cols):
         # Should not happen if called correctly
         return set(), set(), False 
    if grid[start_r, start_c] not in traversable_colors:
         # Start point itself isn't traversable (e.g., starting on the border color)
         # In this implementation, we expect start point to be traversable.
         # If we start on C_inner for the second fill, C_inner *must* be in traversable_colors.
         # Let's assume valid calls. If start not traversable, it fills nothing.
         return set(), {start_pos}, False # Adjacent is just the start pos itself

    q = deque([start_pos])
    visited = {start_pos}
    filled_coords = {start_pos}
    adjacent_coords = set()
    boundary_reached = False

    # Check if start position itself is on the boundary
    if start_r == 0 or start_r == rows - 1 or start_c == 0 or start_c == cols - 1:
        # Starting on the boundary means boundary is trivially reached *if* fill can move.
        boundary_reached = True

    while q:
        r, c = q.popleft()

        # Check neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is out of bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                boundary_reached = True
                continue # Don't process out-of-bounds coordinates further

            # Process in-bounds neighbor
            neighbor_pos = (nr, nc)
            if neighbor_pos not in visited:
                visited.add(neighbor_pos)
                neighbor_color = grid[nr, nc]

                # If neighbor is traversable, add to queue and filled set
                if neighbor_color in traversable_colors:
                    q.append(neighbor_pos)
                    filled_coords.add(neighbor_pos)
                    # Check if this newly added traversable cell is on boundary
                    if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:
                        boundary_reached = True
                # If neighbor is not traversable, add to adjacent set
                else:
                    adjacent_coords.add(neighbor_pos)

    return filled_coords, adjacent_coords, boundary_reached


def transform(input_grid_list):
    """
    Main transformation function. Applies the conditional color change based on nested object colors.

    Args:
        input_grid_list: A list of lists representing the input grid.

    Returns:
        A list of lists representing the output grid.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    # Start with a copy that will be modified if conditions are met
    output_grid = np.copy(input_grid)
    rows, cols = output_grid.shape

    # --- Step 1: Locate Target ---
    magenta_pixels = find_pixel(output_grid, 6)
    if len(magenta_pixels) != 1:
        # If not exactly one magenta pixel, return the original input
        return input_grid_list
    target_pos = magenta_pixels[0]

    # --- Step 2: Check Innermost Containment ---
    # Flood fill from target, allowed to move through background (0) and target color (6).
    # This identifies the space immediately around the target pixel(s) inside the first barrier.
    fill1_coords, adjacent1_coords, boundary1_reached = flood_fill(
        output_grid, target_pos, {0, 6}
    )

    # If the first fill reaches the boundary, the target pixel is not enclosed.
    if boundary1_reached:
        return input_grid_list

    # Determine the color of the immediate enclosing object (must be unique non-zero).
    neighbor1_colors = get_unique_colors(output_grid, adjacent1_coords)
    if len(neighbor1_colors) != 1:
        # Needs exactly one enclosing color. If 0 or >1, no clear inner object found.
        return input_grid_list
    C_inner = list(neighbor1_colors)[0]

    # --- Step 3: Check Next Outer Containment ---
    # Find a starting point for the second fill. This point should be on the border
    # identified previously, and have the color C_inner.
    start_pos2 = None
    for r_adj, c_adj in adjacent1_coords:
        if output_grid[r_adj, c_adj] == C_inner:
            start_pos2 = (r_adj, c_adj)
            break

    # If no suitable starting point found (should be impossible if C_inner was valid).
    if start_pos2 is None:
        # This indicates a potential logic error or unexpected grid structure
        # Safest is to return original grid.
        return input_grid_list

    # Perform the second fill, starting from the inner object's border.
    # Allow traversal through background (0) and the inner object's color (C_inner).
    # This identifies the space between the inner and outer objects.
    fill2_coords, adjacent2_coords, boundary2_reached = flood_fill(
        output_grid, start_pos2, {0, C_inner}
    )

    # If the second fill reaches the boundary, the C_inner object is not enclosed.
    if boundary2_reached:
        return input_grid_list

    # Determine the color of the next enclosing object (must be unique non-zero).
    neighbor2_colors = get_unique_colors(output_grid, adjacent2_coords)
    if len(neighbor2_colors) != 1:
         # Needs exactly one outer enclosing color.
        return input_grid_list
    C_outer = list(neighbor2_colors)[0]

    # --- Step 4: Evaluate Condition ---
    condition_met = False
    # Check for Yellow (4) inside Red (2)
    if C_inner == 4 and C_outer == 2:
        condition_met = True
    # Check for Blue (1) inside Green (3)
    elif C_inner == 1 and C_outer == 3:
        condition_met = True

    # --- Step 5: Apply Transformation ---
    if condition_met:
        # Modify the output grid by changing the target pixel's color to white (0)
        r_target, c_target = target_pos
        output_grid[r_target, c_target] = 0
        # Return the modified grid
        return output_grid.tolist()
    else:
        # If condition not met, return the original unchanged input grid
        return input_grid_list
```
```python
import numpy as np
from collections import deque

"""
Transformation Rule:
Conditionally change a single unique magenta pixel (color 6) to white (color 0)
based on the colors of its two innermost enclosing non-background objects.

1. Locate the unique magenta pixel (P, color 6). If not found or not unique, return the input grid.
2. Find the background region (color 0) immediately adjacent to P using flood fill (BFS) starting from a background neighbor of P.
3. Identify the color (C_inner) of the object forming the immediate boundary of this background region (excluding color 6). The fill must not reach the grid boundary, and C_inner must be unique. If not, return the input grid.
4. Find the background region (color 0) immediately adjacent to the C_inner object using flood fill starting from a background neighbor of any C_inner pixel.
5. Identify the color (C_outer) of the object forming the immediate boundary of this second background region (excluding C_inner). The fill must not reach the grid boundary, and C_outer must be unique. If not, return the input grid.
6. Check if the color pair (C_inner, C_outer) matches specific conditions:
   - (Yellow=4, Red=2) OR
   - (Blue=1, Green=3)
7. If a condition is met, change the magenta pixel P to white (0) in a copy of the grid and return the copy.
8. Otherwise, return the original input grid unchanged.
"""

def find_pixels(grid, color):
    """Finds all coordinates of pixels with a specific color."""
    coords_array = np.argwhere(grid == color)
    return [tuple(coord) for coord in coords_array]

def find_adjacent_pixel(grid, start_coords, target_color):
    """
    Finds the coordinates of the first pixel with target_color adjacent 
    (4-connectivity) to any of the start_coords. Returns None if not found.
    """
    rows, cols = grid.shape
    q = deque(start_coords)
    visited = set(start_coords) # Avoid checking pixels within the starting shape

    processed_neighbors = set() # Keep track of neighbours already checked

    while q:
        r, c = q.popleft()
        
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            if 0 <= nr < rows and 0 <= nc < cols:
                neighbor_pos = (nr, nc)
                if neighbor_pos not in visited and neighbor_pos not in processed_neighbors:
                    processed_neighbors.add(neighbor_pos) # Mark as checked
                    if grid[nr, nc] == target_color:
                        return neighbor_pos # Found one
                    # If it's not the target, but part of the original shape color, add to queue
                    # This helps explore the boundary of the start_coords shape.
                    # We assume start_coords belong to a contiguous object of the same color.
                    # This part might be unnecessary if start_coords is just one pixel.
                    # If start_coords can be multiple, need grid[r,c] == grid[nr,nc] check maybe?
                    # For this problem:
                    # - First call: start_coords is just the single magenta pixel P.
                    # - Second call: start_coords are all pixels of C_inner.
                    # Let's simplify: only check immediate neighbors of the initial start_coords list.
                    
    # Simplified approach: Iterate through initial coords and check direct neighbors
    rows, cols = grid.shape
    initial_coords_set = set(start_coords)
    for r, c in start_coords:
         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbor_pos = (nr, nc)
                # Check if neighbor is the target color AND not part of the initial set
                # (relevant if target_color could be the same as start_coords color)
                if grid[nr, nc] == target_color and neighbor_pos not in initial_coords_set:
                    return neighbor_pos
    return None


def get_unique_colors(grid, coords):
    """Gets the set of unique non-zero colors at the given coordinates."""
    colors = set()
    rows, cols = grid.shape
    for r, c in coords:
        # Coords should be valid if coming from flood_fill adjacent set
        color = grid[r, c]
        if color != 0: # Ignore background color
            colors.add(color)
    return colors

def flood_fill_boundary(grid, start_pos):
    """
    Performs a flood fill (BFS) starting from start_pos, traversing only background (0).
    Identifies the boundary pixels (non-zero adjacent to the fill) and if the fill hits the grid edge.

    Args:
        grid: The numpy grid.
        start_pos: The (row, col) tuple to start from (must be background color 0).

    Returns:
        A tuple: (boundary_coords, boundary_reached)
        - boundary_coords: set of (row, col) of non-background pixels adjacent to the filled area.
        - boundary_reached: boolean indicating if the fill touched the grid edge.
    """
    rows, cols = grid.shape
    
    # Ensure start pos is valid background
    start_r, start_c = start_pos
    if not (0 <= start_r < rows and 0 <= start_c < cols and grid[start_r, start_c] == 0):
         # Invalid start position for this specific flood fill
         return set(), True # Treat as boundary reached if start is invalid

    q = deque([start_pos])
    visited = {start_pos}
    boundary_coords = set()
    boundary_reached = False

    # Check if start position itself is on the boundary
    if start_r == 0 or start_r == rows - 1 or start_c == 0 or start_c == cols - 1:
        boundary_reached = True

    while q:
        r, c = q.popleft()

        # Check neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check if neighbor is out of bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                boundary_reached = True
                continue # Don't process out-of-bounds coordinates further

            # Process in-bounds neighbor
            neighbor_pos = (nr, nc)
            if neighbor_pos not in visited:
                visited.add(neighbor_pos)
                neighbor_color = grid[nr, nc]

                # If neighbor is background (0), add to queue
                if neighbor_color == 0:
                    q.append(neighbor_pos)
                    # Check if this newly added traversable cell is on boundary
                    if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:
                        boundary_reached = True
                # If neighbor is not background (non-zero), add to boundary set
                else:
                    boundary_coords.add(neighbor_pos)

    return boundary_coords, boundary_reached

def transform(input_grid_list):
    """
    Applies the conditional color change based on nested object colors.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid) # Start with a copy

    # --- Step 1: Locate Target ---
    magenta_pixels = find_pixels(output_grid, 6)
    if len(magenta_pixels) != 1:
        return input_grid_list # Return original if not exactly one magenta pixel
    target_pos = magenta_pixels[0]

    # --- Step 2: Find adjacent background pixel to start Fill 1 ---
    start_pos1 = find_adjacent_pixel(output_grid, [target_pos], 0)
    if start_pos1 is None:
        # Magenta pixel is not adjacent to any background pixel
        return input_grid_list

    # --- Step 3: Perform Fill 1 and find C_inner ---
    boundary1_coords, boundary1_reached = flood_fill_boundary(output_grid, start_pos1)
    if boundary1_reached:
        # The background area around the magenta pixel reaches the edge -> not enclosed
        return input_grid_list

    # Identify potential inner colors (non-zero colors on the boundary)
    colors1 = get_unique_colors(output_grid, boundary1_coords)
    # Remove the target magenta color itself from consideration
    colors1.discard(6)
    
    if len(colors1) != 1:
        # Must have exactly one unique non-background color (besides 6) forming the boundary
        return input_grid_list
    C_inner = list(colors1)[0]

    # --- Step 4: Find C_inner pixels and adjacent background pixel to start Fill 2 ---
    c_inner_pixels = find_pixels(output_grid, C_inner)
    if not c_inner_pixels:
         # Should not happen if C_inner was found, but safety check
         return input_grid_list
         
    start_pos2 = find_adjacent_pixel(output_grid, c_inner_pixels, 0)
    if start_pos2 is None:
        # C_inner object is not adjacent to any background pixel (fills grid or touches only non-background?)
        # This implies C_inner object might be touching the outer boundary directly or only other colors.
        # If it fills the grid or touches only non-background, it can't be enclosed by C_outer via background.
        return input_grid_list

    # --- Step 5: Perform Fill 2 and find C_outer ---
    boundary2_coords, boundary2_reached = flood_fill_boundary(output_grid, start_pos2)
    if boundary2_reached:
        # The background area around the C_inner object reaches the edge -> C_inner not enclosed
        return input_grid_list

    # Identify potential outer colors
    colors2 = get_unique_colors(output_grid, boundary2_coords)
    # Remove the C_inner color itself from consideration
    colors2.discard(C_inner)

    if len(colors2) != 1:
        # Must have exactly one unique non-background color (besides C_inner) forming the outer boundary
        return input_grid_list
    C_outer = list(colors2)[0]

    # --- Step 6: Evaluate Condition ---
    condition_met = False
    # Check for Yellow (4) inside Red (2)
    if C_inner == 4 and C_outer == 2:
        condition_met = True
    # Check for Blue (1) inside Green (3)
    elif C_inner == 1 and C_outer == 3:
        condition_met = True

    # --- Step 7 & 8: Apply Transformation or Return Original ---
    if condition_met:
        # Modify the output grid copy
        r_target, c_target = target_pos
        output_grid[r_target, c_target] = 0
        return output_grid.tolist() # Return the modified grid
    else:
        # Condition not met, return the original unchanged input grid
        return input_grid_list
```
```python
import numpy as np
from collections import deque

"""
Conditionally changes a single unique magenta pixel (color 6) to white (color 0)
based on the colors of the two closest enclosing objects found by exploring outwards 
through adjacent background pixels using Breadth-First Search (BFS).

Transformation Steps:
1. Locate the unique magenta pixel (P). Exit if not found or not unique.
2. Find the first non-background, non-magenta color (C_inner) encountered by BFS starting 
   from a background neighbor of P, exploring only background. Exit if none found.
3. Find the first non-background color (C_outer) encountered by BFS starting from a 
   background neighbor of any C_inner pixel, exploring only background. C_outer must not be C_inner or magenta. Exit if none found.
4. Check if (C_inner=4, C_outer=2) or (C_inner=1, C_outer=3).
5. If the condition holds, change pixel P to white (0). Otherwise, make no change.
"""

def find_pixels(grid, color):
    """Finds all coordinates (row, col) of pixels with a specific color."""
    return list(map(tuple, np.argwhere(grid == color)))

def find_adjacent_pixel(grid, start_coords, target_color):
    """
    Finds the coordinates of the first pixel with target_color adjacent 
    (4-connectivity) to any of the start_coords. Returns None if not found.
    """
    rows, cols = grid.shape
    initial_coords_set = set(start_coords)
    
    # Use a queue to explore boundary efficiently if start_coords is large,
    # but for small number of start points, direct checking is fine.
    # Let's stick to direct checking for simplicity based on the refined NL program.
    for r, c in start_coords:
         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbor_pos = (nr, nc)
                # Ensure neighbor is the target color and not part of the initial set
                if grid[nr, nc] == target_color and neighbor_pos not in initial_coords_set:
                    return neighbor_pos # Found one
    return None # Not found

def find_first_enclosing_color(grid, start_pos, excluded_colors):
    """
    Performs BFS starting from start_pos (must be background) traversing only background (0).
    Returns the color of the first non-background neighbor encountered whose color is NOT in excluded_colors.
    Returns None if the BFS completes without finding such a neighbor.
    """
    rows, cols = grid.shape
    
    # Basic check: start_pos should be background
    if not (0 <= start_pos[0] < rows and 0 <= start_pos[1] < cols and grid[start_pos] == 0):
        return None # Invalid start

    q = deque([start_pos])
    visited_background = {start_pos}
    
    while q:
        r, c = q.popleft()

        # Check neighbors (4-connectivity)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc

            # Check bounds
            if not (0 <= nr < rows and 0 <= nc < cols):
                continue # Skip out-of-bounds

            neighbor_pos = (nr, nc)
            neighbor_color = grid[nr, nc]

            # If neighbor is background and not visited, add to queue
            if neighbor_color == 0:
                if neighbor_pos not in visited_background:
                    visited_background.add(neighbor_pos)
                    q.append(neighbor_pos)
            # If neighbor is non-background
            else:
                # Check if its color is one we are looking for (not excluded)
                if neighbor_color not in excluded_colors:
                    return neighbor_color # Found the first enclosing color

    # If queue empties and we haven't returned, no valid enclosing color was found
    return None


def transform(input_grid_list):
    """
    Applies the conditional color change based on the refined nested object color logic.
    """
    input_grid = np.array(input_grid_list, dtype=int)
    output_grid = np.copy(input_grid) # Start with a copy

    # --- Step 1: Locate Target ---
    magenta_pixels = find_pixels(output_grid, 6)
    if len(magenta_pixels) != 1:
        return input_grid_list # Return original if not exactly one magenta pixel
    target_pos = magenta_pixels[0]

    # --- Step 2: Find Inner Color (C_inner) ---
    # Find a background pixel adjacent to the target to start the search
    start_pos_inner = find_adjacent_pixel(output_grid, [target_pos], 0)
    if start_pos_inner is None:
        # Magenta pixel is not adjacent to any background pixel
        return input_grid_list
        
    # Search outwards from this background pixel for the first non-background, non-magenta color
    C_inner = find_first_enclosing_color(output_grid, start_pos_inner, {0, 6})
    if C_inner is None:
        # BFS did not find a suitable inner enclosing color
        return input_grid_list

    # --- Step 3: Find Outer Color (C_outer) ---
    # Find all pixels belonging to the inner object
    c_inner_pixels = find_pixels(output_grid, C_inner)
    if not c_inner_pixels:
         # Should not happen if C_inner was found, but safety check
         return input_grid_list
         
    # Find a background pixel adjacent to the inner object to start the next search
    start_pos_outer = find_adjacent_pixel(output_grid, c_inner_pixels, 0)
    if start_pos_outer is None:
        # C_inner object has no adjacent background pixels
        return input_grid_list

    # Search outwards from this background pixel for the first non-background color
    # that is neither the inner color nor magenta.
    C_outer = find_first_enclosing_color(output_grid, start_pos_outer, {0, 6, C_inner})
    if C_outer is None:
        # BFS did not find a suitable outer enclosing color
        return input_grid_list

    # --- Step 4: Evaluate Condition ---
    condition_met = False
    # Check for Yellow (4) inside Red (2)
    if C_inner == 4 and C_outer == 2:
        condition_met = True
    # Check for Blue (1) inside Green (3)
    elif C_inner == 1 and C_outer == 3:
        condition_met = True

    # --- Step 5: Apply Transformation or Return Original ---
    if condition_met:
        # Modify the output grid copy
        r_target, c_target = target_pos
        output_grid[r_target, c_target] = 0
        return output_grid.tolist() # Return the modified grid
    else:
        # Condition not met, return the original unchanged input grid
        return input_grid_list

```
