{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nConditionally changes a single magenta pixel (6) to white (0) based on the\ncolors of its two innermost containing non-background objects.\n\nThe transformation rule is as follows:\n1. Locate the unique magenta pixel (color 6). If not found or not unique, return the input grid.\n2. Determine the color of the immediate object enclosing the magenta pixel and its surrounding white space (if any). Let this be C_inner. If no single enclosing object color is found, return the input grid.\n3. Determine the color of the object immediately enclosing the C_inner object and its surrounding white space (if any). Let this be C_outer. If no single enclosing object color is found, return the input grid.\n4. Check if the color pair (C_inner, C_outer) matches specific conditions:\n   - (Yellow=4, Red=2) OR\n   - (Blue=1, Green=3)\n5. If a condition is met, change the magenta pixel to white (0). Otherwise, return the input grid unchanged.\n\nContainment is determined using flood fill (BFS). A pixel/object is considered contained if a flood fill starting from it (traversing background color 0 and the object's own color) cannot reach the grid boundary.\n\"\"\"\n\ndef find_pixel(grid, color):\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    # Use numpy's where function for efficiency\n    coords_array = np.argwhere(grid == color)\n    # Convert numpy array to list of tuples\n    return [tuple(coord) for coord in coords_array]\n\ndef get_unique_colors(grid, coords):\n    \"\"\"Gets the set of unique non-zero colors at the given coordinates.\"\"\"\n    colors = set()\n    rows, cols = grid.shape\n    for r, c in coords:\n        # Ensure coordinates are within bounds (though they should be from flood_fill)\n        if 0 <= r < rows and 0 <= c < cols:\n            color = grid[r, c]\n            if color != 0: # Ignore background color\n                colors.add(color)\n    return colors\n\ndef flood_fill(grid, start_pos, traversable_colors):\n    \"\"\"\n    Performs a flood fill (BFS) starting from start_pos.\n\n    Args:\n        grid: The numpy grid.\n        start_pos: The (row, col) tuple to start from.\n        traversable_colors: A set of colors allowed to traverse.\n\n    Returns:\n        A tuple: (filled_coords, adjacent_coords, boundary_reached)\n        - filled_coords: set of (row, col) visited during the fill.\n        - adjacent_coords: set of (row, col) neighboring the filled region but not part of it.\n        - boundary_reached: boolean indicating if the fill touched the grid edge.\n    \"\"\"\n    rows, cols = grid.shape\n    \n    # Ensure start pos is valid and traversable\n    start_r, start_c = start_pos\n    if not (0 <= start_r < rows and 0 <= start_c < cols):\n         # Should not happen if called correctly\n         return set(), set(), False \n    if grid[start_r, start_c] not in traversable_colors:\n         # Start point itself isn't traversable (e.g., starting on the border color)\n         # In this implementation, we expect start point to be traversable.\n         # If we start on C_inner for the second fill, C_inner *must* be in traversable_colors.\n         # Let's assume valid calls. If start not traversable, it fills nothing.\n         return set(), {start_pos}, False # Adjacent is just the start pos itself\n\n    q = deque([start_pos])\n    visited = {start_pos}\n    filled_coords = {start_pos}\n    adjacent_coords = set()\n    boundary_reached = False\n\n    # Check if start position itself is on the boundary\n    if start_r == 0 or start_r == rows - 1 or start_c == 0 or start_c == cols - 1:\n        # Starting on the boundary means boundary is trivially reached *if* fill can move.\n        boundary_reached = True\n\n    while q:\n        r, c = q.popleft()\n\n        # Check neighbors (4-connectivity)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is out of bounds\n            if not (0 <= nr < rows and 0 <= nc < cols):\n                boundary_reached = True\n                continue # Don't process out-of-bounds coordinates further\n\n            # Process in-bounds neighbor\n            neighbor_pos = (nr, nc)\n            if neighbor_pos not in visited:\n                visited.add(neighbor_pos)\n                neighbor_color = grid[nr, nc]\n\n                # If neighbor is traversable, add to queue and filled set\n                if neighbor_color in traversable_colors:\n                    q.append(neighbor_pos)\n                    filled_coords.add(neighbor_pos)\n                    # Check if this newly added traversable cell is on boundary\n                    if nr == 0 or nr == rows - 1 or nc == 0 or nc == cols - 1:\n                        boundary_reached = True\n                # If neighbor is not traversable, add to adjacent set\n                else:\n                    adjacent_coords.add(neighbor_pos)\n\n    return filled_coords, adjacent_coords, boundary_reached\n\n\ndef transform(input_grid_list):\n    \"\"\"\n    Main transformation function. Applies the conditional color change based on nested object colors.\n\n    Args:\n        input_grid_list: A list of lists representing the input grid.\n\n    Returns:\n        A list of lists representing the output grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list, dtype=int)\n    # Start with a copy that will be modified if conditions are met\n    output_grid = np.copy(input_grid)\n    rows, cols = output_grid.shape\n\n    # --- Step 1: Locate Target ---\n    magenta_pixels = find_pixel(output_grid, 6)\n    if len(magenta_pixels) != 1:\n        # If not exactly one magenta pixel, return the original input\n        return input_grid_list\n    target_pos = magenta_pixels[0]\n\n    # --- Step 2: Check Innermost Containment ---\n    # Flood fill from target, allowed to move through background (0) and target color (6).\n    # This identifies the space immediately around the target pixel(s) inside the first barrier.\n    fill1_coords, adjacent1_coords, boundary1_reached = flood_fill(\n        output_grid, target_pos, {0, 6}\n    )\n\n    # If the first fill reaches the boundary, the target pixel is not enclosed.\n    if boundary1_reached:\n        return input_grid_list\n\n    # Determine the color of the immediate enclosing object (must be unique non-zero).\n    neighbor1_colors = get_unique_colors(output_grid, adjacent1_coords)\n    if len(neighbor1_colors) != 1:\n        # Needs exactly one enclosing color. If 0 or >1, no clear inner object found.\n        return input_grid_list\n    C_inner = list(neighbor1_colors)[0]\n\n    # --- Step 3: Check Next Outer Containment ---\n    # Find a starting point for the second fill. This point should be on the border\n    # identified previously, and have the color C_inner.\n    start_pos2 = None\n    for r_adj, c_adj in adjacent1_coords:\n        if output_grid[r_adj, c_adj] == C_inner:\n            start_pos2 = (r_adj, c_adj)\n            break\n\n    # If no suitable starting point found (should be impossible if C_inner was valid).\n    if start_pos2 is None:\n        # This indicates a potential logic error or unexpected grid structure\n        # Safest is to return original grid.\n        return input_grid_list\n\n    # Perform the second fill, starting from the inner object's border.\n    # Allow traversal through background (0) and the inner object's color (C_inner).\n    # This identifies the space between the inner and outer objects.\n    fill2_coords, adjacent2_coords, boundary2_reached = flood_fill(\n        output_grid, start_pos2, {0, C_inner}\n    )\n\n    # If the second fill reaches the boundary, the C_inner object is not enclosed.\n    if boundary2_reached:\n        return input_grid_list\n\n    # Determine the color of the next enclosing object (must be unique non-zero).\n    neighbor2_colors = get_unique_colors(output_grid, adjacent2_coords)\n    if len(neighbor2_colors) != 1:\n         # Needs exactly one outer enclosing color.\n        return input_grid_list\n    C_outer = list(neighbor2_colors)[0]\n\n    # --- Step 4: Evaluate Condition ---\n    condition_met = False\n    # Check for Yellow (4) inside Red (2)\n    if C_inner == 4 and C_outer == 2:\n        condition_met = True\n    # Check for Blue (1) inside Green (3)\n    elif C_inner == 1 and C_outer == 3:\n        condition_met = True\n\n    # --- Step 5: Apply Transformation ---\n    if condition_met:\n        # Modify the output grid by changing the target pixel's color to white (0)\n        r_target, c_target = target_pos\n        output_grid[r_target, c_target] = 0\n        # Return the modified grid\n        return output_grid.tolist()\n    else:\n        # If condition not met, return the original unchanged input grid\n        return input_grid_list\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 5333,
    "candidates_token_count": 2312,
    "total_token_count": 7645,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 66.659584,
  "retries": 1
}