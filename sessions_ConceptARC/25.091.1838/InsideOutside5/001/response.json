{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify all distinct objects (contiguous areas of the same non-white color) in the input grid.\nDetermine which objects are 'internal', meaning they are not reachable from the outer boundary of the grid by traversing only white (0) pixels.\nCreate an output grid of the same dimensions as the input, initialized to white (0).\nCopy only the 'internal' objects to the output grid, preserving their original colors and positions.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components of non-white pixels in the grid.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'pixels' (a set of (row, col) tuples) and 'color'.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    \n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    obj_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (horizontal/vertical)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                objects.append({'pixels': obj_pixels, 'color': color})\n                \n    return objects\n\ndef flood_fill_outside(grid):\n    \"\"\"\n    Performs a flood fill starting from white pixels on the border\n    to find all white pixels reachable from the outside.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        set: A set of (row, col) tuples representing reachable white pixels.\n    \"\"\"\n    height, width = grid.shape\n    reachable_white = set()\n    q = deque()\n\n    # Add border white pixels to the queue and set\n    for r in range(height):\n        if grid[r, 0] == 0:\n            if (r, 0) not in reachable_white:\n                reachable_white.add((r, 0))\n                q.append((r, 0))\n        if grid[r, width - 1] == 0:\n             if (r, width - 1) not in reachable_white:\n                reachable_white.add((r, width - 1))\n                q.append((r, width - 1))\n                \n    for c in range(width):\n        if grid[0, c] == 0:\n            if (0, c) not in reachable_white:\n                reachable_white.add((0, c))\n                q.append((0, c))\n        if grid[height - 1, c] == 0:\n            if (height - 1, c) not in reachable_white:\n                reachable_white.add((height - 1, c))\n                q.append((height - 1, c))\n\n    # Perform BFS for reachable white pixels\n    while q:\n        r, c = q.popleft()\n        \n        # Check 8 neighbors (including diagonals) - important for finding adjacency later\n        # Actually, only 4 neighbours needed for flood fill itself\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < height and 0 <= nc < width and \\\n               grid[nr, nc] == 0 and (nr, nc) not in reachable_white:\n                reachable_white.add((nr, nc))\n                q.append((nr, nc))\n                \n    return reachable_white\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by keeping only objects that are fully enclosed\n    (not reachable from the outside via white pixels).\n\n    Args:\n        input_grid (np.ndarray): The input grid.\n\n    Returns:\n        np.ndarray: The transformed output grid.\n    \"\"\"\n    input_grid = np.array(input_grid)\n    height, width = input_grid.shape\n    \n    # Initialize output_grid with white (0)\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all distinct non-white objects\n    objects = find_objects(input_grid)\n    \n    # Find all white pixels reachable from the outside border\n    reachable_white = flood_fill_outside(input_grid)\n    \n    # Identify internal objects and draw them on the output grid\n    for obj in objects:\n        is_internal = True\n        # Check if any pixel of the object is adjacent (8 directions) to a reachable white pixel\n        for r, c in obj['pixels']:\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = r + dr, c + dc\n                    # Check if neighbor is within bounds and is a reachable white pixel\n                    if 0 <= nr < height and 0 <= nc < width:\n                         if (nr, nc) in reachable_white:\n                            is_internal = False\n                            break # No need to check other neighbours for this pixel\n                if not is_internal:\n                    break # No need to check other pixels for this object\n            if not is_internal:\n                break # Exit outer loop as well\n\n        # If the object is internal, copy its pixels to the output grid\n        if is_internal:\n            for r, c in obj['pixels']:\n                output_grid[r, c] = obj['color']\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4693,
    "candidates_token_count": 1465,
    "total_token_count": 6158,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 108.849174,
  "retries": 2
}