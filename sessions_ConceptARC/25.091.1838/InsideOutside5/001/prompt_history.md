
## train_1

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 2 2 2 2 2 2 2 2 0 3 3 3 3 0 0 0
0 0 2 0 0 0 0 0 0 2 0 3 0 0 3 0 0 0
0 0 2 0 4 4 4 0 0 2 0 3 0 0 3 0 0 0
0 0 2 0 4 0 4 0 0 2 0 3 3 3 3 0 0 0
0 0 2 0 4 4 4 0 0 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 2 0 0 0 0 0 0 2 0 0 6 6 6 0 0 0
0 0 2 2 2 2 2 2 2 2 0 0 6 0 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 0 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_2

**input:**
```
0 0 0 0 4 4 4 0 0 0 0 0 0 0 0
6 6 0 0 4 0 4 0 0 0 0 0 0 0 0
6 6 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 4 0 4 0 0 0 0 0 0 0 0
0 0 0 0 4 4 4 5 5 5 5 5 5 0 0
7 7 7 0 0 0 0 5 0 0 0 0 5 0 0
7 7 7 0 0 0 0 5 0 3 3 0 5 0 0
7 7 7 0 0 0 0 5 0 3 3 0 5 0 0
0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 0 0 0 0 5 0 0
0 0 0 0 0 0 0 5 5 5 5 5 5 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 3 3 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```


## train_3

**input:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 0 0 0 0 0 0 0
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 9 9 9 9 9 0 0
0 0 7 0 0 8 8 8 8 8 8 8 8 8 8 0 7 0 9 0 0 0 9 0 0
0 0 7 0 0 8 0 0 0 0 0 0 0 0 8 0 7 0 9 0 0 0 9 0 0
0 0 7 0 0 8 0 0 3 3 3 3 0 0 8 0 7 0 9 9 9 9 9 0 0
0 0 7 0 0 8 0 0 3 3 3 3 0 0 8 0 7 0 0 0 0 0 0 0 0
0 0 7 0 0 8 0 0 0 0 0 0 0 0 8 0 7 0 3 3 3 3 3 3 3
0 0 7 0 0 8 8 8 8 8 8 8 8 8 8 0 7 0 3 0 0 0 0 0 3
0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 3 0 8 8 8 0 3
0 0 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 0 3 0 0 0 0 0 3
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3
```


**output:**
```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 3 3 3 3 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 3 3 3 3 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## Perception

The input grids contain multiple distinct "objects," which are contiguous areas of non-white pixels. Many of these objects are hollow rectangular shapes acting as borders or containers, typically with a single color outlining an area of white pixels. Inside some of these container objects, there are other distinct objects of different colors.

The transformation involves identifying objects that are fully enclosed *within* another object. The outer object often acts as a frame or container. Only the objects found *inside* these containers are preserved in the output grid. All other pixels, including the container objects themselves and any objects not enclosed, are turned white (0). The position and color of the preserved inner objects remain unchanged relative to the grid dimensions.

## Facts


```yaml
observations:
  - task_type: object_extraction
  - description: Identify and extract objects that are fully contained within other hollow objects (containers).
  - components:
      - input_grid:
          - contains: multiple distinct objects of various colors (non-white).
          - background: white (0).
          - features:
              - some objects are hollow rectangular shapes (containers/borders) of a single color.
              - some objects are solid shapes.
              - some solid objects are located geographically inside the area defined by the hollow objects.
      - output_grid:
          - background: entirely white (0).
          - contents: only the objects that were located inside a container object in the input grid.
          - properties:
              - preserved_objects: maintain their original color and relative position from the input.
              - removed_objects: container objects and any objects not enclosed within another are removed (turned white).
  - rule: An object is preserved if and only if it is fully enclosed within the boundaries of another hollow, single-color object.
  - examples:
      - example_1:
          - input: Contains red, green, and magenta hollow containers. A yellow object is inside the red container.
          - output: Only the yellow object remains.
      - example_2:
          - input: Contains yellow, gray, magenta, and orange objects. A green object is inside the gray container.
          - output: Only the green object remains.
      - example_3:
          - input: Contains orange, maroon, and green containers. An azure object (containing a green object) is inside the orange container. A small azure object is inside the green container.
          - output: Only the azure object (with its internal green object) from inside the orange container and the small azure object from inside the green container remain.
```


## Natural Language Program

1.  Identify all distinct objects in the input grid (contiguous areas of the same non-white color).
2.  For each object (`object_A`), determine if it acts as a container. A container is typically a hollow shape, often rectangular, made of a single color.
3.  For each potential container object (`object_A`), identify all other distinct objects (`object_B`) located within the geometric boundaries defined by `object_A`.
4.  Check if `object_B` is *fully* contained within `object_A`. This means all pixels of `object_B` must reside within the area enclosed by `object_A`, not touching or overlapping `object_A` itself.
5.  Create a new output grid initialized with white pixels (0) and having the same dimensions as the input grid.
6.  Copy only those objects (`object_B`) that were identified as being fully contained within a container object (`object_A`) from the input grid to the output grid, preserving their original colors and positions.
7.  All other pixels in the output grid remain white (0).
