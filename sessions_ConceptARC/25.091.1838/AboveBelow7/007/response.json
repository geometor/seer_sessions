{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nIdentifies distinct groups of pixels based on their non-background color.\nReverses the vertical stacking order of these color groups while maintaining their internal structure, \nhorizontal position, and the vertical spacing that originally existed between them. \nThe absolute vertical position of the resulting stack is determined by placing the new top group \n(originally the bottom group) such that its top row (`min_row`) equals the `min_row` of the \noriginal top group plus the height of the original top group.\n\"\"\"\n\ndef find_color_groups(grid):\n    \"\"\"Finds all pixels belonging to each non-background color.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - defaultdict: Dictionary mapping color values to lists of (row, col) coordinates.\n            - list: A list of unique non-background colors found in the grid, preserving \n                    order of appearance roughly top-to-bottom, left-to-right.\n    \"\"\"\n    color_coords = defaultdict(list)\n    rows, cols = grid.shape\n    unique_colors = []\n    color_set = set() # Keep track of colors added to unique_colors\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            if color != 0: # 0 is background (white)\n                color_coords[color].append((r, c))\n                if color not in color_set:\n                    unique_colors.append(color)\n                    color_set.add(color)\n    return color_coords, unique_colors\n\ndef get_group_properties(coords):\n    \"\"\"Calculates bounding box and height for a list of coordinates.\n\n    Args:\n        coords (list): A list of (row, col) coordinates for a color group.\n\n    Returns:\n        dict or None: A dictionary with 'min_row', 'max_row', 'height' \n                      if coordinates exist, otherwise None.\n    \"\"\"\n    if not coords:\n        return None\n    rows = [r for r, c in coords]\n    min_row = min(rows)\n    max_row = max(rows)\n    height = max_row - min_row + 1\n    return {'min_row': min_row, 'max_row': max_row, 'height': height}\n\ndef transform(input_grid):\n    \"\"\"\n    Reverses the vertical order of color groups in the grid according to the specified rules.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    \n    # Initialize output_grid with background color (0)\n    output_grid = np.zeros_like(input_grid_np)\n\n    # --- Workflow ---\n\n    # 1. Identify Color Groups: Find unique non-background colors and their pixels.\n    color_coords, unique_colors = find_color_groups(input_grid_np)\n\n    # If no non-background colors, return the empty grid.\n    if not unique_colors:\n        return output_grid.tolist()\n\n    # 2. Calculate Group Properties: Get bounding box and height for each group.\n    groups = []\n    for color in unique_colors:\n        coords = color_coords[color]\n        properties = get_group_properties(coords)\n        if properties:\n            group_info = {\n                'color': color,\n                'pixels': coords,\n                'min_row': properties['min_row'],\n                'max_row': properties['max_row'],\n                'height': properties['height'],\n                'original_min_row': properties['min_row'] # Store original top position\n            }\n            groups.append(group_info)\n\n    # Handle case where no valid groups were formed (e.g., only background pixels)\n    if not groups:\n         return output_grid.tolist()\n\n    # 3. Determine Initial Order and Gaps: Sort groups top-to-bottom, calculate gaps.\n    groups.sort(key=lambda g: g['min_row'])\n    \n    # Remember the original top group's properties\n    original_top_group_min_row = groups[0]['min_row']\n    original_top_group_height = groups[0]['height']\n\n    # Calculate vertical gaps between consecutive groups in the original sorted order.\n    gaps = []\n    if len(groups) > 1:\n        for i in range(len(groups) - 1):\n            # Gap = next group's top - current group's bottom - 1\n            gap = groups[i+1]['min_row'] - groups[i]['max_row'] - 1\n            gaps.append(max(0, gap)) # Ensure gap is not negative\n\n    # 4. Reverse Order: Reverse the groups list and the gaps list for placement.\n    reversed_groups = list(reversed(groups))\n    reversed_gaps = list(reversed(gaps))\n\n    # 5. Calculate Target Starting Row: Determine where the new top group starts.\n    current_target_row = original_top_group_min_row + original_top_group_height\n\n    # 6. Create Output Grid: Already initialized above.\n\n    # 7. Place Groups: Iterate through reversed groups and place them in the output grid.\n    for i, group in enumerate(reversed_groups):\n        # a. Calculate the vertical shift needed for the current group.\n        shift = current_target_row - group['original_min_row']\n\n        # b. Place all pixels of the current group onto the output grid at the new position.\n        for r, c in group['pixels']:\n            new_r = r + shift\n            # Check bounds just in case, although logic should prevent out-of-bounds\n            if 0 <= new_r < rows and 0 <= c < cols:\n                output_grid[new_r, c] = group['color']\n\n        # c. Update the `current_target_row` for placing the *next* group.\n        #    The next group starts below the current one, accounting for the relevant gap.\n        #    Update happens *after* placing the current group.\n        #    Next row = current target row + current group height + gap\n        gap_to_add = 0\n        if i < len(reversed_gaps):\n             gap_to_add = reversed_gaps[i] + 1 # +1 because gap is space *between* rows\n        \n        current_target_row += group['height'] + gap_to_add\n\n\n    # 8. Return Result: Convert the numpy array back to a list of lists.\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 18302,
    "candidates_token_count": 1599,
    "total_token_count": 19901,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 18.084839,
  "retries": 1
}