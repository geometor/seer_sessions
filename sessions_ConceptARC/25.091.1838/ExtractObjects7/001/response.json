{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies a single-color line (vertical or horizontal) separator in the input grid.\nIdentifies distinct objects (contiguous blocks of color other than background or separator) on either side/top/bottom of the separator.\nExtracts each object into its minimal bounding box grid.\nIf the separator was vertical, removes the top row from each extracted object grid.\nConcatenates the processed object grids: horizontally if the separator was vertical, vertically if it was horizontal, maintaining original relative order.\n\"\"\"\n\ndef find_separator(grid):\n    \"\"\"\n    Finds a horizontal or vertical line of a single non-background color.\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        tuple: (separator_color, orientation, index) or (None, None, None) if not found.\n               orientation is 'horizontal' or 'vertical'.\n               index is the row or column index of the separator.\n    \"\"\"\n    rows, cols = grid.shape\n    background_color = 0\n\n    # Check for horizontal separator\n    for r in range(rows):\n        color = grid[r, 0]\n        if color != background_color and np.all(grid[r, :] == color):\n            # Check if it truly separates regions (not just a border line)\n            has_non_bg_above = r > 0 and np.any(grid[:r, :] != background_color)\n            has_non_bg_below = r < rows - 1 and np.any(grid[r+1:, :] != background_color)\n            if has_non_bg_above and has_non_bg_below:\n                 return color, 'horizontal', r\n\n    # Check for vertical separator\n    for c in range(cols):\n        color = grid[0, c]\n        if color != background_color and np.all(grid[:, c] == color):\n             # Check if it truly separates regions\n            has_non_bg_left = c > 0 and np.any(grid[:, :c] != background_color)\n            has_non_bg_right = c < cols - 1 and np.any(grid[:, c+1:] != background_color)\n            if has_non_bg_left and has_non_bg_right:\n                return color, 'vertical', c\n\n    return None, None, None\n\n\ndef find_and_extract_objects(grid, ignore_color):\n    \"\"\"\n    Finds connected components (objects) of the same color, ignoring background and a specific color.\n    Extracts each object into its minimal bounding box.\n\n    Args:\n        grid (np.array): Input grid.\n        ignore_color (int): Color to ignore (typically the separator color).\n\n    Returns:\n        list: A list of tuples, where each tuple is (object_grid, bounding_box).\n              bounding_box is (min_r, min_c, max_r, max_c).\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            color = grid[r, c]\n            # Start search if pixel is not background, not ignored, and not visited\n            if color != background_color and color != ignore_color and not visited[r, c]:\n                component_color = color\n                q = deque([(r, c)])\n                visited[r, c] = True\n                points = [(r, c)]\n                min_r, min_c, max_r, max_c = r, c, r, c\n\n                while q:\n                    row, col = q.popleft()\n\n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == component_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            points.append((nr, nc))\n\n                # Extract the object into its own grid\n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                # Initialize with background color (important for shapes like 'C')\n                obj_grid = np.full((height, width), background_color, dtype=int) \n                for pr, pc in points:\n                    obj_grid[pr - min_r, pc - min_c] = component_color\n\n                objects.append((obj_grid, (min_r, min_c, max_r, max_c)))\n\n    return objects\n\ndef crop_top_row(obj_grid):\n    \"\"\"Removes the top row of a grid.\"\"\"\n    if obj_grid.shape[0] > 1:\n        return obj_grid[1:, :]\n    else:\n        # Handle case of 1-row object, return empty grid of same width?\n        # Or maybe just the original grid if cropping makes it disappear?\n        # For this task, based on examples, objects are > 1 row high when cropped.\n        return obj_grid[1:, :] # This will be empty if height was 1\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on separator and object manipulation rules.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    rows, cols = grid.shape\n\n    # 1. Identify the separator line\n    sep_color, sep_orientation, sep_index = find_separator(grid)\n    if sep_color is None:\n        # Handle error or return input? Based on task, assume separator exists.\n        return input_grid # Or raise an error\n\n    # 2. Identify and extract objects\n    objects = find_and_extract_objects(grid, sep_color)\n\n    # 3. Filter and sort objects based on separator position\n    objects_part1 = [] # Left or Top\n    objects_part2 = [] # Right or Bottom\n\n    if sep_orientation == 'vertical':\n        for obj_grid, bbox in objects:\n            min_r, min_c, max_r, max_c = bbox\n            if max_c < sep_index:\n                objects_part1.append((obj_grid, bbox))\n            elif min_c > sep_index:\n                objects_part2.append((obj_grid, bbox))\n        # Sort by horizontal position (min_c) just in case, though examples have one per side\n        objects_part1.sort(key=lambda x: x[1][1])\n        objects_part2.sort(key=lambda x: x[1][1])\n\n    elif sep_orientation == 'horizontal':\n        for obj_grid, bbox in objects:\n             min_r, min_c, max_r, max_c = bbox\n             if max_r < sep_index:\n                 objects_part1.append((obj_grid, bbox))\n             elif min_r > sep_index:\n                 objects_part2.append((obj_grid, bbox))\n        # Sort by vertical position (min_r)\n        objects_part1.sort(key=lambda x: x[1][0])\n        objects_part2.sort(key=lambda x: x[1][0])\n\n    ordered_objects = objects_part1 + objects_part2\n    processed_grids = [obj[0] for obj in ordered_objects] # Get just the grids\n\n    # 4. Conditional Step: Crop top row if separator was vertical\n    if sep_orientation == 'vertical':\n        processed_grids = [crop_top_row(g) for g in processed_grids]\n\n    # 5. Combine the processed object grids\n    if not processed_grids:\n        return [] # Return empty if no objects found/processed\n\n    if sep_orientation == 'vertical':\n        # Concatenate horizontally\n        output_grid_np = np.hstack(processed_grids)\n    elif sep_orientation == 'horizontal':\n        # Concatenate vertically\n        output_grid_np = np.vstack(processed_grids)\n    else: # Should not happen if separator was found\n        return input_grid\n\n    # Convert final numpy array back to list of lists\n    output_grid = output_grid_np.tolist()\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2868,
    "candidates_token_count": 2027,
    "total_token_count": 4895,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.449115,
  "retries": 1
}