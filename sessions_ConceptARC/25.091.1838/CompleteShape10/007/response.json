{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFill horizontal gaps within contiguous horizontal segments of the largest \nnon-background object, using the object's color.\n\n1. Identify the background color (assumed white/0).\n2. Find the largest contiguous non-background object and its color (fill_color).\n3. Iterate through each row of the grid.\n4. For each row, identify contiguous horizontal segments composed solely of \n   the fill_color.\n5. For each identified segment (defined by start and end columns), fill any \n   background-colored pixels located strictly *between* the start and end \n   columns of that segment with the fill_color. Note: The logic should fill\n   pixels *within* the segment's bounds [start_col, end_col].\n\"\"\"\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color designated as background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'pixels' (set of (r, c) tuples), and 'size'.\n              Returns an empty list if no non-background objects are found.\n              Returns None if grid is empty or invalid.\n    \"\"\"\n    # Check for empty or invalid grid early\n    if grid is None or grid.size == 0:\n        # print(\"Warning: Input grid is None or empty.\")\n        return None\n    # Ensure grid is 2D numpy array\n    if grid.ndim != 2:\n         # print(f\"Warning: Input grid is not 2D (shape: {grid.shape}).\")\n         return None \n    \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and not visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found object to the list\n                if current_object_pixels:\n                    objects.append({\n                        'color': obj_color,\n                        'pixels': current_object_pixels, \n                        'size': len(current_object_pixels)\n                    })\n                    \n    return objects\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the horizontal segment gap filling transformation to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    try:\n        input_np = np.array(input_grid, dtype=int)\n        if input_np.ndim != 2:\n             # Return original potentially invalid input if not 2D\n             return input_grid \n    except ValueError:\n        # Handle non-rectangular lists etc.\n        return input_grid # Return original input on conversion error\n\n    rows, cols = input_np.shape\n    if rows == 0 or cols == 0:\n        return input_grid # Handle empty grid case\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # Step 1: Identify background color (assuming 0 based on ARC convention)\n    background_color = 0 \n\n    # Step 2: Find all non-background objects\n    objects = _find_objects(input_np, background_color)\n\n    # If no non-background objects found, return the original grid\n    if not objects:\n        return output_grid.tolist() \n\n    # Step 3: Find the largest object to determine the fill color\n    largest_object = max(objects, key=lambda obj: obj['size'])\n    fill_color = largest_object['color']\n    \n    # Step 4: Iterate through each row of the grid\n    for r in range(rows):\n        c = 0 # Column iterator for the current row\n        while c < cols:\n            # Step 5: Find the start of a potential segment of fill_color\n            if input_np[r, c] == fill_color:\n                # Found the start of a segment at column c\n                c_start = c\n                # Find the end of this contiguous segment\n                c_end = c\n                while c_end + 1 < cols and input_np[r, c_end + 1] == fill_color:\n                    c_end += 1\n                \n                # Now we have a segment from c_start to c_end\n                # Step 6: Fill background pixels *within* this segment's bounds\n                for k in range(c_start, c_end + 1):\n                    if input_np[r, k] == background_color:\n                        output_grid[r, k] = fill_color\n                        \n                # Advance the main column iterator past this segment\n                c = c_end + 1\n            else:\n                # Not the fill color, just move to the next column\n                c += 1\n\n    # Convert the final numpy array back to list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16805,
    "candidates_token_count": 1404,
    "total_token_count": 18209,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.381996,
  "retries": 1
}