{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nFill horizontal gaps within each row, bounded by the horizontal extent\n(minimum to maximum column) of the largest non-background object's pixels\npresent in that specific row. The gaps are filled with the color of the \nlargest non-background object.\n\"\"\"\n\ndef _find_objects(grid, background_color):\n    \"\"\"\n    Finds all contiguous objects of non-background colors using BFS.\n\n    Args:\n        grid (np.array): The input grid.\n        background_color (int): The color designated as background.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'color', 'pixels' (set of (r, c) tuples), and 'size'.\n              Returns an empty list if no non-background objects are found.\n              Returns None if grid is empty or invalid.\n    \"\"\"\n    # Check for empty or invalid grid early\n    if grid is None or grid.size == 0:\n        # print(\"Warning: Input grid is None or empty.\")\n        return None\n    # Ensure grid is 2D numpy array\n    if grid.ndim != 2:\n         # print(f\"Warning: Input grid is not 2D (shape: {grid.shape}).\")\n         return None \n    \n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(rows):\n        for c in range(cols):\n            # If it's a non-background pixel and not visited yet, start BFS\n            if grid[r, c] != background_color and not visited[r, c]:\n                obj_color = grid[r, c]\n                current_object_pixels = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    current_object_pixels.add((row, col))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check bounds, color match, and visited status\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == obj_color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            \n                # Add the found object to the list\n                if current_object_pixels:\n                    objects.append({\n                        'color': obj_color,\n                        'pixels': current_object_pixels, \n                        'size': len(current_object_pixels)\n                    })\n                    \n    return objects\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the horizontal gap filling transformation to the input grid.\n    \"\"\"\n    # Convert input list of lists to numpy array for efficient processing\n    try:\n        input_np = np.array(input_grid, dtype=int)\n        if input_np.ndim != 2:\n             # Return original potentially invalid input if not 2D\n             # print(\"Warning: Input grid is not 2D.\")\n             return input_grid \n    except ValueError:\n        # Handle non-rectangular lists etc.\n        # print(\"Warning: Input grid could not be converted to NumPy array (e.g., non-rectangular).\")\n        return input_grid # Return original input on conversion error\n\n    rows, cols = input_np.shape\n    if rows == 0 or cols == 0:\n        # print(\"Warning: Input grid is empty.\")\n        return input_grid # Handle empty grid case\n\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_np)\n\n    # Step 1: Identify background color (assuming 0 based on examples/ARC convention)\n    # In ARC tasks, background is almost always 0 (black/white confusion here, but value is 0).\n    background_color = 0 \n    # Alternate: find most frequent color - more robust but maybe not needed for ARC\n    # colors, counts = np.unique(input_np, return_counts=True)\n    # if counts.size > 0:\n    #     background_color = colors[np.argmax(counts)]\n    # else: # Grid was empty or single color\n    #      return output_grid.tolist() \n\n    # Step 2: Find all non-background objects using the helper function\n    objects = _find_objects(input_np, background_color)\n\n    # If no non-background objects found (or grid was invalid), return the original grid\n    if not objects:\n        # print(\"No non-background objects found.\")\n        return output_grid.tolist() \n\n    # Step 3: Find the largest object (by pixel count) to determine the fill color\n    largest_object = max(objects, key=lambda obj: obj['size'])\n    fill_color = largest_object['color']\n    \n    # Step 4: Iterate through each row of the grid\n    for r in range(rows):\n        # Step 5: Find all column indices where the *input* grid has the *fill_color* in the current row\n        row_pixels_indices = np.where(input_np[r, :] == fill_color)[0]\n\n        # Step 6: Check if the fill_color was present in this row\n        if len(row_pixels_indices) > 0:\n            # Determine the horizontal extent (minimum and maximum column indices) of the fill_color in this row\n            min_col = np.min(row_pixels_indices)\n            max_col = np.max(row_pixels_indices)\n\n            # Step 7: Fill background pixels within this horizontal extent in the output grid\n            # Iterate through columns from min_col to max_col (inclusive)\n            for c in range(min_col, max_col + 1):\n                # Check if the pixel at (r, c) in the *original input* grid was the background color\n                if input_np[r, c] == background_color:\n                    # If it was background, change its color to the fill_color in the *output* grid\n                    output_grid[r, c] = fill_color\n\n    # Convert the final numpy array back to list of lists format for the ARC standard output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19112,
    "candidates_token_count": 1507,
    "total_token_count": 20619,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 72.493663,
  "retries": 1
}