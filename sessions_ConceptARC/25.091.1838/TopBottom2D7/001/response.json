{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentify the blue (1) and green (3) objects in the input grid. \nDetermine the topmost row index for each object.\nSelect the object whose topmost row index is smaller (higher in the grid).\nCreate a new output grid containing only the pixels of the selected object, \ncropped to its minimal bounding box.\n\"\"\"\n\ndef find_connected_pixels(grid, start_row, start_col, target_color, visited):\n    \"\"\"\n    Finds all connected pixels of target_color starting from (start_row, start_col)\n    using Breadth-First Search (BFS).\n\n    Args:\n        grid (np.array): The input grid.\n        start_row (int): The starting row index.\n        start_col (int): The starting column index.\n        target_color (int): The color of the object to find.\n        visited (set): A set of coordinates already visited during the search for\n                       this color.\n\n    Returns:\n        set: A set of (row, col) tuples representing the pixels of the found object.\n    \"\"\"\n    rows, cols = grid.shape\n    pixels = set()\n    q = deque([(start_row, start_col)])\n    visited.add((start_row, start_col))\n    pixels.add((start_row, start_col))\n\n    while q:\n        r, c = q.popleft()\n        # Check 4 adjacent neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            # Check bounds, target color, and if not visited\n            if 0 <= nr < rows and 0 <= nc < cols and \\\n               grid[nr, nc] == target_color and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                pixels.add((nr, nc))\n                q.append((nr, nc))\n    return pixels\n\ndef find_object(grid, color):\n    \"\"\"\n    Finds the first complete object (contiguous group of pixels) of the specified color.\n\n    Args:\n        grid (np.array): The input grid.\n        color (int): The color of the object to find.\n\n    Returns:\n        set: A set of (row, col) tuples for the object, or an empty set if not found.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = set() # Keep track of visited pixels for this specific search\n    for r in range(rows):\n        for c in range(cols):\n            # If we find a pixel of the target color that hasn't been visited yet,\n            # start a search from there to find the whole object.\n            if grid[r, c] == color and (r, c) not in visited:\n                return find_connected_pixels(grid, r, c, color, visited)\n    return set() # Return empty set if no object of that color is found\n\ndef get_min_row(object_pixels):\n    \"\"\"\n    Gets the minimum row index from a set of pixel coordinates.\n\n    Args:\n        object_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        int: The minimum row index, or float('inf') if the set is empty.\n    \"\"\"\n    if not object_pixels:\n        return float('inf') # Use infinity to ensure an empty object isn't selected\n    return min(r for r, c in object_pixels)\n\ndef get_bounding_box(object_pixels):\n    \"\"\"\n    Calculates the bounding box coordinates (min_row, min_col, max_row, max_col).\n\n    Args:\n        object_pixels (set): A set of (row, col) tuples.\n\n    Returns:\n        tuple: (min_r, min_c, max_r, max_c) or None if the set is empty.\n    \"\"\"\n    if not object_pixels:\n        return None\n    min_r = min(r for r, c in object_pixels)\n    min_c = min(c for r, c in object_pixels)\n    max_r = max(r for r, c in object_pixels)\n    max_c = max(c for r, c in object_pixels)\n    return min_r, min_c, max_r, max_c\n\ndef crop_object(object_pixels, color):\n    \"\"\"\n    Creates a new grid containing the cropped object, preserving its color.\n    The background of the cropped grid is white (0).\n\n    Args:\n        object_pixels (set): A set of (row, col) tuples for the object.\n        color (int): The color of the object.\n\n    Returns:\n        np.array: The cropped grid containing the object. Returns an empty\n                  array shape (0,0) if object_pixels is empty.\n    \"\"\"\n    if not object_pixels:\n        # Return an empty array if there are no pixels\n        return np.array([[]], dtype=int).reshape(0,0)\n\n    bbox = get_bounding_box(object_pixels)\n    if bbox is None:\n         return np.array([[]], dtype=int).reshape(0,0)\n\n    min_r, min_c, max_r, max_c = bbox\n    # Calculate height and width of the bounding box\n    height = max_r - min_r + 1\n    width = max_c - min_c + 1\n\n    # Create the output grid, initialized with background color 0 (white)\n    output_grid = np.full((height, width), 0, dtype=int)\n\n    # Place the object pixels onto the output grid relative to the bounding box\n    for r, c in object_pixels:\n        # Calculate relative coordinates within the output grid\n        output_r = r - min_r\n        output_c = c - min_c\n        # Set the pixel to the object's color\n        output_grid[output_r, output_c] = color\n\n    return output_grid\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by identifying blue (1) and green (3) objects,\n    selecting the one that appears higher vertically (smaller minimum row index),\n    and returning that object cropped to its minimal bounding box.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists.\n\n    Returns:\n        np.array: The transformed grid as a numpy array.\n    \"\"\"\n    # Convert input to numpy array for easier manipulation\n    grid_np = np.array(input_grid, dtype=int)\n\n    # --- Workflow ---\n\n    # 1. Identify the blue object (color 1)\n    blue_object_pixels = find_object(grid_np, 1)\n\n    # 2. Identify the green object (color 3)\n    green_object_pixels = find_object(grid_np, 3)\n\n    # 3. Determine the topmost row index for the blue object\n    min_row_blue = get_min_row(blue_object_pixels)\n\n    # 4. Determine the topmost row index for the green object\n    min_row_green = get_min_row(green_object_pixels)\n\n    # 5. Compare topmost rows and select the higher object\n    selected_object_pixels = None\n    selected_color = -1 # Default invalid color\n    if min_row_blue <= min_row_green: # Blue is higher or at the same level\n        selected_object_pixels = blue_object_pixels\n        selected_color = 1\n    else: # Green is strictly higher\n        selected_object_pixels = green_object_pixels\n        selected_color = 3\n\n    # Handle cases where one or both objects might be missing (though problem implies both exist)\n    if not selected_object_pixels:\n         # If for some reason neither object is found or selected properly, return empty\n         return np.array([[]], dtype=int).reshape(0,0)\n\n\n    # 6. Create the output grid containing only the selected object, cropped\n    output_grid = crop_object(selected_object_pixels, selected_color)\n\n    return output_grid.tolist() # Convert back to list of lists for consistency if needed by ARC framework\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2621,
    "candidates_token_count": 1922,
    "total_token_count": 4543,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 34.914566,
  "retries": 1
}