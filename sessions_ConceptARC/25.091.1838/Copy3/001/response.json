{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on its width:\n\n1. If the grid width is even:\n   - The output grid is formed by copying the left half of the input grid onto the right half. The left half remains unchanged.\n\n2. If the grid width is odd:\n   - Identify a marker object: a horizontal 1x2 block of magenta pixels ([[6, 6]]).\n   - Find the instance of this marker object whose top-left corner is closest to the geometric center of the grid. The coordinates (r_marker, c_marker) of this marker's top-left corner define an offset vector.\n   - If no marker is found, the output is identical to the input.\n   - Identify all distinct connected objects (contiguous blocks of the same non-white color) in the input grid.\n   - For each object *except* the specific marker object used for the offset:\n     - Copy the object to a new location in the output grid by adding the offset (r_marker, c_marker) to the coordinates of each pixel in the object.\n     - Only pixels landing within the grid boundaries are placed.\n     - Copied pixels overwrite the existing content at the target location. The original grid content and objects (including the marker) remain unless overwritten.\n\"\"\"\n\ndef find_objects(grid, colors_to_ignore=[0]):\n    \"\"\"\n    Finds all connected objects of the same color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (list): List of color values to ignore (background).\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object:\n              (color, set_of_coordinates, top_left_coordinate).\n              set_of_coordinates is a set of (row, col) tuples.\n              top_left_coordinate is a tuple (min_row, min_col).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            if color not in colors_to_ignore and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append((color, obj_coords, (min_r, min_c)))\n    return objects\n\ndef find_pattern(grid, pattern):\n    \"\"\"\n    Finds all occurrences of a given pattern in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        pattern (np.array): The pattern to search for.\n\n    Returns:\n        list: A list of (row, col) tuples representing the top-left coordinates\n              of found pattern instances.\n    \"\"\"\n    grid_h, grid_w = grid.shape\n    pattern_h, pattern_w = pattern.shape\n    locations = []\n\n    for r in range(grid_h - pattern_h + 1):\n        for c in range(grid_w - pattern_w + 1):\n            subgrid = grid[r:r+pattern_h, c:c+pattern_w]\n            if np.array_equal(subgrid, pattern):\n                locations.append((r, c))\n    return locations\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on grid width.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    output_np = np.copy(input_np) # Start with a copy\n\n    # Check if width is even or odd\n    if width % 2 == 0:\n        # Even width: Mirror left half to right half\n        mid = width // 2\n        left_half = input_np[:, :mid]\n        output_np[:, mid:] = left_half\n    else:\n        # Odd width: Offset copy based on marker\n        marker_pattern = np.array([[6, 6]]) # Magenta 1x2 block\n        marker_locations = find_pattern(input_np, marker_pattern)\n\n        if not marker_locations:\n            # No marker found, return the copy of the input\n            return output_np.tolist()\n\n        # Calculate grid center\n        center_r = (height - 1) / 2.0\n        center_c = (width - 1) / 2.0\n        grid_center = (center_r, center_c)\n\n        # Find the marker closest to the center\n        closest_marker_loc = min(\n            marker_locations,\n            key=lambda loc: euclidean(loc, grid_center)\n        )\n        r_marker, c_marker = closest_marker_loc\n        offset_dr, offset_dc = r_marker, c_marker\n\n        # Find all objects\n        objects = find_objects(input_np, colors_to_ignore=[0]) # Ignore white background\n\n        # Iterate through objects and copy them with offset, skipping the chosen marker\n        for color, coords, top_left_coord in objects:\n            # Check if this object is the chosen marker\n            is_marker = False\n            # For a 1x2 marker, the top_left_coord is sufficient to identify it\n            if top_left_coord == closest_marker_loc and color == 6: \n                 # Basic check, might need refinement if other magenta objects exist\n                 # Let's be more specific: check if the object's pixels exactly match the marker pattern relative to top_left\n                 obj_pixels_relative = {(r - top_left_coord[0], c - top_left_coord[1]) for r, c in coords}\n                 marker_pixels_relative = {(0,0), (0,1)} # For [[6, 6]] pattern\n                 if obj_pixels_relative == marker_pixels_relative:\n                     is_marker = True\n\n            if not is_marker:\n                # Copy this object with offset\n                for r_p, c_p in coords:\n                    target_r = r_p + offset_dr\n                    target_c = c_p + offset_dc\n\n                    # Check grid boundaries\n                    if 0 <= target_r < height and 0 <= target_c < width:\n                        output_np[target_r, target_c] = color\n\n    # Convert back to list of lists before returning\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4110,
    "candidates_token_count": 1717,
    "total_token_count": 5827,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 22.931088,
  "retries": 1
}