{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on its width parity:\n\n1. If the grid width is even:\n   - The output grid is created by taking the input grid, keeping the left half as is, and overwriting the right half with an exact copy of the left half.\n\n2. If the grid width is odd:\n   - The output grid starts as a copy of the input grid.\n   - A marker object (horizontal 1x2 block of magenta pixels [[6, 6]]) is searched for.\n   - The instance of this marker closest to the geometric grid center determines an offset vector (dr, dc) equal to its top-left coordinates (r_marker, c_marker).\n   - If no marker is found, the initial copy of the input is returned.\n   - All distinct connected non-white objects in the input grid are identified (using 4-connectivity).\n   - Each object, *except* the specific marker object instance used to determine the offset, is copied.\n   - The copy is performed by adding the offset (dr, dc) to each pixel coordinate of the object.\n   - Copied pixels are placed onto the output grid, overwriting existing content, only if the target coordinates are within the grid bounds.\n\"\"\"\n\n# --- Helper Functions ---\n\ndef find_objects(grid, colors_to_ignore=[0]):\n    \"\"\"\n    Finds all connected objects of the same color in the grid using 4-connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (list): List of color values to ignore (e.g., background).\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object:\n              (color, set_of_coordinates, top_left_coordinate).\n              set_of_coordinates is a set of (row, col) tuples.\n              top_left_coordinate is a tuple (min_row, min_col).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the pixel is not ignored and not visited yet\n            if color not in colors_to_ignore and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Track top-left for easy identification\n\n                # Breadth-First Search (BFS) to find connected components\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds, has the same color, and hasn't been visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object\n                objects.append((color, obj_coords, (min_r, min_c)))\n    return objects\n\ndef find_pattern(grid, pattern):\n    \"\"\"\n    Finds all occurrences of a given 2D pattern in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        pattern (np.array): The 2D pattern (subgrid) to search for.\n\n    Returns:\n        list: A list of (row, col) tuples representing the top-left coordinates\n              of found pattern instances.\n    \"\"\"\n    grid_h, grid_w = grid.shape\n    pattern_h, pattern_w = pattern.shape\n    locations = []\n\n    # Iterate through possible top-left positions for the pattern\n    for r in range(grid_h - pattern_h + 1):\n        for c in range(grid_w - pattern_w + 1):\n            # Extract the subgrid matching the pattern's dimensions\n            subgrid = grid[r:r+pattern_h, c:c+pattern_w]\n            # Compare the subgrid with the pattern\n            if np.array_equal(subgrid, pattern):\n                locations.append((r, c))\n    return locations\n\n# --- Main Transformation Function ---\n\ndef transform(input_grid):\n    \"\"\"Applies the transformation rule based on the input grid's width.\"\"\"\n    # Convert input list of lists to a NumPy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Initialize the output grid as a copy of the input grid\n    output_np = np.copy(input_np) \n\n    # --- Determine transformation based on width parity ---\n    if width % 2 == 0:\n        # --- Even Width: Mirror Left Half Pixel-wise to Right Half ---\n        \n        # Calculate the midpoint column index\n        mid = width // 2\n        # Extract the left half from the current output (which is a copy of input)\n        left_half = output_np[:, :mid]\n        # Overwrite the right half of the output grid with the left half\n        output_np[:, mid:] = left_half\n        \n    else:\n        # --- Odd Width: Offset Copy Based on Central Marker ---\n        \n        # Define the marker pattern: a horizontal 1x2 block of magenta (6)\n        marker_pattern = np.array([[6, 6]]) \n        # Find all locations where this pattern occurs in the input grid\n        marker_locations = find_pattern(input_np, marker_pattern)\n\n        # If no marker is found, the output is just the copy of the input\n        if not marker_locations:\n            return output_np.tolist()\n\n        # Calculate the geometric center of the grid\n        center_r = (height - 1) / 2.0\n        center_c = (width - 1) / 2.0\n        grid_center = (center_r, center_c)\n\n        # Find the marker instance closest to the grid center\n        closest_marker_loc = min(\n            marker_locations,\n            key=lambda loc: euclidean(loc, grid_center) # Use Euclidean distance\n        )\n        # The offset vector is the coordinates of the closest marker's top-left pixel\n        offset_dr, offset_dc = closest_marker_loc \n\n        # Find all distinct objects (connected components of non-white pixels) in the input grid\n        objects = find_objects(input_np, colors_to_ignore=[0]) # Ignore white (0)\n        \n        # Define the relative coordinates for the marker pattern for precise identification\n        # This helps distinguish the exact marker object from other magenta objects\n        marker_pixels_relative = {(0,0), (0,1)} # Relative coords for [[6, 6]] pattern starting at (0,0)\n\n        # Iterate through all found objects to perform the copy\n        for color, coords, top_left_coord in objects:\n            \n            # --- Check if the current object is the specific marker used for the offset ---\n            is_the_offset_marker = False\n            # Quick check: Compare color and top-left coordinate\n            if color == 6 and top_left_coord == closest_marker_loc:\n                 # Precise check: Verify the exact shape/pixels relative to its top-left coordinate\n                 obj_pixels_relative = {(r - top_left_coord[0], c - top_left_coord[1]) for r, c in coords}\n                 if obj_pixels_relative == marker_pixels_relative:\n                     is_the_offset_marker = True # Confirmed it's the specific marker object\n\n            # --- If it's NOT the offset marker, copy it ---\n            if not is_the_offset_marker:\n                # Iterate through each pixel coordinate (r_p, c_p) of the object\n                for r_p, c_p in coords:\n                    # Calculate the target coordinates using the offset\n                    target_r = r_p + offset_dr\n                    target_c = c_p + offset_dc\n\n                    # Check if the target coordinates are within the grid boundaries\n                    if 0 <= target_r < height and 0 <= target_c < width:\n                        # Place the object's pixel color at the target location in the output grid\n                        output_np[target_r, target_c] = color\n\n    # Convert the final NumPy array back to a list of lists before returning\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 19098,
    "candidates_token_count": 2066,
    "total_token_count": 21164,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.951546,
  "retries": 1
}