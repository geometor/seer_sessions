{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\nfrom collections import deque\n\n\"\"\"\nTransforms an input grid based on its width:\n\n1. If the grid width is even:\n   - Identify all distinct connected non-white objects where *all* pixels of the object lie in the left half of the grid (columns 0 to width/2 - 1).\n   - Copy each of these identified objects to the right half of the grid using an offset of (0, width/2).\n   - The output grid starts as a copy of the input, and copied pixels overwrite the existing content in the right half.\n\n2. If the grid width is odd:\n   - Identify a marker object: a horizontal 1x2 block of magenta pixels ([[6, 6]]).\n   - Find the instance of this marker object whose top-left corner is closest (using Euclidean distance) to the geometric center of the grid.\n   - The coordinates (r_marker, c_marker) of this marker's top-left corner define an offset vector.\n   - If no such marker is found, the output is identical to the input.\n   - Identify all distinct connected objects (non-white pixels) in the input grid using 4-connectivity.\n   - For each identified object *except* the specific marker object instance used for the offset:\n     - Copy the object to a new location in the output grid by adding the offset vector (r_marker, c_marker) to the coordinates of each pixel in the object.\n     - Only pixels whose target coordinates land within the grid boundaries are placed.\n     - Copied pixels overwrite the existing content at the target location. The original grid content and objects (including the marker) remain unless overwritten.\n\"\"\"\n\ndef find_objects(grid, colors_to_ignore=[0]):\n    \"\"\"\n    Finds all connected objects of the same color in the grid using 4-connectivity.\n\n    Args:\n        grid (np.array): The input grid.\n        colors_to_ignore (list): List of color values to ignore (e.g., background).\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object:\n              (color, set_of_coordinates, top_left_coordinate).\n              set_of_coordinates is a set of (row, col) tuples.\n              top_left_coordinate is a tuple (min_row, min_col).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros((height, width), dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            color = grid[r, c]\n            # Check if the pixel is not ignored and not visited yet\n            if color not in colors_to_ignore and not visited[r, c]:\n                obj_coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c # Track top-left for easy identification\n\n                # Breadth-First Search (BFS) to find connected components\n                while q:\n                    row, col = q.popleft()\n                    obj_coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n\n                    # Check neighbors (4-connectivity: up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check if neighbor is within bounds, has the same color, and hasn't been visited\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                # Store the found object\n                objects.append((color, obj_coords, (min_r, min_c)))\n    return objects\n\ndef find_pattern(grid, pattern):\n    \"\"\"\n    Finds all occurrences of a given 2D pattern in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n        pattern (np.array): The 2D pattern (subgrid) to search for.\n\n    Returns:\n        list: A list of (row, col) tuples representing the top-left coordinates\n              of found pattern instances.\n    \"\"\"\n    grid_h, grid_w = grid.shape\n    pattern_h, pattern_w = pattern.shape\n    locations = []\n\n    # Iterate through possible top-left positions for the pattern\n    for r in range(grid_h - pattern_h + 1):\n        for c in range(grid_w - pattern_w + 1):\n            # Extract the subgrid matching the pattern's dimensions\n            subgrid = grid[r:r+pattern_h, c:c+pattern_w]\n            # Compare the subgrid with the pattern\n            if np.array_equal(subgrid, pattern):\n                locations.append((r, c))\n    return locations\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on the input grid's width.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for efficient operations\n    input_np = np.array(input_grid, dtype=int)\n    height, width = input_np.shape\n    # Initialize the output grid as a copy of the input grid\n    output_np = np.copy(input_np) \n\n    # --- Determine transformation based on width parity ---\n    if width % 2 == 0:\n        # --- Even Width: Copy Left-Half Objects to Right Half ---\n        \n        # Calculate the midpoint column index\n        mid = width // 2\n        # Define the copy offset\n        offset_dr, offset_dc = 0, mid\n        \n        # Find all distinct objects (non-white) in the entire input grid\n        objects = find_objects(input_np, colors_to_ignore=[0]) \n\n        # Iterate through found objects to check if they are fully in the left half\n        for color, coords, _ in objects:\n            # Check if all pixels of the object are in the left half (column < mid)\n            is_in_left_half = all(c < mid for r, c in coords)\n\n            # If the object is entirely within the left half, copy it\n            if is_in_left_half:\n                # Iterate through each pixel of the object\n                for r_p, c_p in coords:\n                    # Calculate the target coordinates using the offset\n                    target_r = r_p + offset_dr\n                    target_c = c_p + offset_dc\n\n                    # Check if the target coordinates are within the grid boundaries\n                    # Note: target_c will always be >= mid because offset_dc is mid\n                    if 0 <= target_r < height and target_c < width: \n                        # Place the object's pixel color at the target location in the output grid\n                        output_np[target_r, target_c] = color\n        \n    else:\n        # --- Odd Width: Offset Copy Based on Central Marker ---\n        \n        # Define the marker pattern: a horizontal 1x2 block of magenta (6)\n        marker_pattern = np.array([[6, 6]]) \n        # Find all locations where this pattern occurs\n        marker_locations = find_pattern(input_np, marker_pattern)\n\n        # If no marker is found, the output is just the copy of the input\n        if not marker_locations:\n            return output_np.tolist()\n\n        # Calculate the geometric center of the grid\n        center_r = (height - 1) / 2.0\n        center_c = (width - 1) / 2.0\n        grid_center = (center_r, center_c)\n\n        # Find the marker instance closest to the grid center\n        closest_marker_loc = min(\n            marker_locations,\n            key=lambda loc: euclidean(loc, grid_center) # Use Euclidean distance\n        )\n        # The offset vector is the coordinates of the closest marker's top-left pixel\n        offset_dr, offset_dc = closest_marker_loc \n\n        # Find all distinct objects (connected components of non-white pixels)\n        objects = find_objects(input_np, colors_to_ignore=[0]) # Ignore white (0)\n        \n        # Define the relative coordinates for the marker pattern for precise identification\n        marker_pixels_relative = {(0,0), (0,1)} # Relative coords for [[6, 6]] pattern\n\n        # Iterate through all found objects to perform the copy\n        for color, coords, top_left_coord in objects:\n            \n            # --- Check if the current object is the specific marker used for the offset ---\n            is_the_offset_marker = False\n            # Check color and top-left coordinate first for efficiency\n            if color == 6 and top_left_coord == closest_marker_loc:\n                 # Verify the exact shape/pixels relative to top-left to be sure\n                 obj_pixels_relative = {(r - top_left_coord[0], c - top_left_coord[1]) for r, c in coords}\n                 if obj_pixels_relative == marker_pixels_relative:\n                     is_the_offset_marker = True\n\n            # --- If it's NOT the offset marker, copy it ---\n            if not is_the_offset_marker:\n                # Iterate through each pixel of the object\n                for r_p, c_p in coords:\n                    # Calculate the target coordinates using the offset\n                    target_r = r_p + offset_dr\n                    target_c = c_p + offset_dc\n\n                    # Check if the target coordinates are within the grid boundaries\n                    if 0 <= target_r < height and 0 <= target_c < width:\n                        # Place the object's pixel color at the target location in the output grid\n                        output_np[target_r, target_c] = color\n\n    # Convert the final NumPy array back to a list of lists before returning\n    return output_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17088,
    "candidates_token_count": 2333,
    "total_token_count": 19421,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.561693,
  "retries": 1
}