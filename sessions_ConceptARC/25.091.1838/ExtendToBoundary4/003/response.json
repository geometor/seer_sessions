{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Dict, List, Optional\n\n\"\"\"\nIdentifies a single vertical line and a single horizontal line in the input grid. \nBased on their relative positions, extends one of the lines by adding pixels of that line's color.\nRules:\n1. If the horizontal line is entirely to the right of the vertical line's column, the horizontal line extends one pixel to the left.\n2. If the vertical line is entirely above the horizontal line's row (and rule 1 doesn't apply), the vertical line extends downwards to fill the gap until the row just above the horizontal line.\n3. If the vertical line is entirely below the horizontal line's row (and rule 1 doesn't apply), the vertical line extends upwards by one pixel.\n4. Otherwise (lines intersect or touch, and rule 1 doesn't apply), the vertical line extends downwards by one pixel.\nBoundary checks are performed to ensure added pixels are within the grid.\n\"\"\"\n\n# === Helper Functions ===\n\ndef find_objects(grid: np.ndarray) -> List[Dict]:\n    \"\"\"\n    Finds contiguous objects of the same non-background color in the grid.\n    Uses Breadth-First Search (BFS).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                obj_pixels = []\n                q = [(r, c)]\n                visited[r, c] = True\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                while q:\n                    row, col = q.pop(0)\n                    obj_pixels.append((row, col))\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n\n                objects.append({\n                    \"color\": color,\n                    \"pixels\": obj_pixels,\n                    \"min_r\": min_r,\n                    \"max_r\": max_r,\n                    \"min_c\": min_c,\n                    \"max_c\": max_c,\n                    \"height\": max_r - min_r + 1,\n                    \"width\": max_c - min_c + 1\n                })\n    return objects\n\ndef find_lines(grid: np.ndarray) -> Tuple[Optional[Dict], Optional[Dict]]:\n    \"\"\"\n    Identifies the single vertical and single horizontal line among found objects.\n    A vertical line has width=1, height>=1.\n    A horizontal line has height=1, width>=1.\n    \"\"\"\n    objects = find_objects(grid)\n    vertical_line = None\n    horizontal_line = None\n\n    for obj in objects:\n        is_vertical = obj['width'] == 1 and obj['height'] >= 1\n        is_horizontal = obj['height'] == 1 and obj['width'] >= 1\n\n        if is_vertical:\n             if vertical_line is None: # Take the first one found\n                 vertical_line = obj\n             else:\n                 # Assumption: only one vertical line per input based on examples\n                 pass\n        elif is_horizontal:\n             if horizontal_line is None: # Take the first one found\n                horizontal_line = obj\n             else:\n                 # Assumption: only one horizontal line per input based on examples\n                 pass\n\n    return vertical_line, horizontal_line\n\n# === Main Transform Function ===\n\ndef transform(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Applies the line extension transformation based on relative positions.\n    \"\"\"\n    # Initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # Find the vertical and horizontal lines\n    vertical_line, horizontal_line = find_lines(input_grid)\n\n    # Check if both lines were found (as expected by the problem description)\n    if vertical_line is None or horizontal_line is None:\n        # Should not happen based on examples, but return original grid if lines aren't found\n        print(\"Warning: Could not find both a vertical and horizontal line.\")\n        return output_grid\n\n    # Extract properties for easier access\n    v_color = vertical_line['color']\n    v_col = vertical_line['min_c'] # Since width is 1, min_c == max_c\n    v_min_r = vertical_line['min_r']\n    v_max_r = vertical_line['max_r']\n\n    h_color = horizontal_line['color']\n    h_row = horizontal_line['min_r'] # Since height is 1, min_r == max_r\n    h_min_c = horizontal_line['min_c']\n    h_max_c = horizontal_line['max_c']\n\n    # Apply transformation rules based on relative positions\n\n    # Rule 1: Horizontal line is entirely to the right of the vertical line\n    if h_min_c > v_col:\n        extend_col = h_min_c - 1\n        # Check boundary before modifying grid\n        if 0 <= extend_col < width and 0 <= h_row < height:\n            output_grid[h_row, extend_col] = h_color\n            \n    # Rule 2: Vertical line is entirely above the horizontal line (and Rule 1 is false)\n    elif v_max_r < h_row:\n        # Extend downwards until the row just before the horizontal line\n        for r in range(v_max_r + 1, h_row):\n             # Check boundary for each pixel to add\n             if 0 <= r < height and 0 <= v_col < width:\n                output_grid[r, v_col] = v_color\n                \n    # Rule 3: Vertical line is entirely below the horizontal line (and Rule 1 is false)\n    elif v_min_r > h_row:\n        extend_row = v_min_r - 1\n        # Check boundary before modifying grid\n        if 0 <= extend_row < height and 0 <= v_col < width:\n             output_grid[extend_row, v_col] = v_color\n             \n    # Rule 4: Otherwise (lines intersect or touch, and Rule 1 is false)\n    else:\n        extend_row = v_max_r + 1\n        # Check boundary before modifying grid\n        if 0 <= extend_row < height and 0 <= v_col < width:\n             output_grid[extend_row, v_col] = v_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 15070,
    "candidates_token_count": 1711,
    "total_token_count": 16781,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.906421,
  "retries": 1
}