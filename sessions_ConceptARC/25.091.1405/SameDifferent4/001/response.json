{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, deque\n\n\"\"\"\nIdentifies all distinct connected objects (shapes) of non-white pixels in the input grid using 8-way connectivity (including diagonals).\nDetermines the orientation (Horizontal, Vertical, or Diagonal) for each shape with 2 or more pixels.\nCounts the number of shapes for each orientation.\nIdentifies the majority orientation (the one with the highest count). Assumes a unique majority based on examples. If there is a tie for the majority, all shapes are kept.\nCreates the output grid by removing shapes (setting their pixels to white/0) whose orientation does not match the majority orientation. Shapes with no determined orientation (e.g., single pixels) and shapes matching the majority orientation are kept.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected objects of the same color in the grid using BFS.\n    Uses 8-way connectivity (includes diagonals).\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of dictionaries, where each dictionary represents an object\n              with keys 'coords' (list of (r, c) tuples) and 'color' (int).\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n\n    for r in range(height):\n        for c in range(width):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                coords = []\n                q = deque([(r, c)])\n                visited[r, c] = True\n                \n                while q:\n                    row, col = q.popleft()\n                    coords.append((row, col))\n                    \n                    # Check 8 neighbors (including diagonals)\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            \n                            if 0 <= nr < height and 0 <= nc < width and \\\n                               not visited[nr, nc] and grid[nr, nc] == color:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                                \n                if coords: \n                    objects.append({'coords': coords, 'color': color})\n    return objects\n\ndef get_orientation(coords):\n    \"\"\"\n    Determines the orientation of an object based on its pixel coordinates.\n\n    Args:\n        coords (list): A list of (row, col) tuples representing the object's pixels.\n\n    Returns:\n        str or None: \"Horizontal\", \"Vertical\", \"Diagonal\", or None if orientation\n                     cannot be determined (e.g., single pixel).\n    \"\"\"\n    if len(coords) < 2:\n        return None  # Cannot determine orientation for single pixel or empty list\n\n    rows = {r for r, c in coords}\n    cols = {c for r, c in coords}\n\n    is_horizontal = len(rows) == 1\n    is_vertical = len(cols) == 1\n\n    if is_horizontal:\n        return \"Horizontal\"\n    elif is_vertical:\n        return \"Vertical\"\n    else:\n        # Any other multi-pixel shape is considered Diagonal for this task\n        return \"Diagonal\"\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by keeping only the shapes that belong to the\n    majority orientation category (Horizontal, Vertical, or Diagonal).\n\n    Args:\n        input_grid (list of lists): The input grid represented as a 2D list.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    grid = np.array(input_grid, dtype=int)\n    output_grid = np.copy(grid)\n\n    # 1. Find all distinct objects\n    objects = find_objects(grid)\n\n    # 2. Determine orientation for each object and store details\n    object_details = []\n    orientations = []\n    for obj in objects:\n        coords = obj['coords']\n        orientation = get_orientation(coords)\n        object_details.append({'coords': coords, 'orientation': orientation})\n        if orientation:  # Only consider valid orientations (H, V, D) for counting\n            orientations.append(orientation)\n\n    # 3. Count orientations\n    orientation_counts = Counter(orientations)\n\n    # 4. Find the majority orientation\n    majority_orientation = None\n    max_count = 0\n    if orientation_counts:\n        max_count = max(orientation_counts.values())\n        majority_orientations = [o for o, c in orientation_counts.items() if c == max_count]\n        \n        # Assume unique majority based on examples. If tied, keep all shapes.\n        if len(majority_orientations) == 1:\n            majority_orientation = majority_orientations[0]\n            # print(f\"Majority Orientation: {majority_orientation} (Count: {max_count})\") # Debug\n        # else: print(\"Tie or no valid orientations found. Keeping all shapes.\") # Debug\n\n    # 5. & 6. Create output grid by filtering shapes\n    # Iterate through objects and remove those not matching the majority orientation\n    for obj_detail in object_details:\n        coords = obj_detail['coords']\n        orientation = obj_detail['orientation']\n\n        # Condition to remove: A unique majority exists, AND the object has a valid \n        # orientation, AND that orientation does not match the majority.\n        if majority_orientation is not None and \\\n           orientation is not None and \\\n           orientation != majority_orientation:\n            # 8. Change pixels of non-majority objects to background color\n            for r, c in coords:\n                output_grid[r, c] = 0\n\n    # 9. Return the final grid\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2984,
    "candidates_token_count": 1366,
    "total_token_count": 4350,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 45.256849,
  "retries": 1
}