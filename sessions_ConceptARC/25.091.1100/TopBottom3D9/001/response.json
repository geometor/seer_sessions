{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom scipy.ndimage import label, binary_dilation, generate_binary_structure\n\n\"\"\"\nIdentify the background color (assumed to be 0) and the two non-background colors (C1, C2) in the input grid.\n\nCheck if there are any internal regions of the background color (holes) that are exclusively surrounded by only C1 or only C2.\nA hole is a region of background color not connected to the grid's border.\nExclusive surrounding means all non-background pixels directly adjacent to the hole pixels have the same color (either all C1 or all C2).\n\nRule 1: If exactly one non-background color (e.g., C1) exclusively surrounds at least one background hole, replace all pixels of the other non-background color (C2) with C1. Similarly, if C2 exclusively surrounds a hole, replace C1 with C2.\n\nRule 2: If no non-background color exclusively surrounds a background hole (either no holes exist, or holes are bordered by both C1 and C2), then:\n  a. Count the number of pixels for C1 and C2.\n  b. Identify the color with the maximum pixel count (C_max) and the color with the minimum pixel count (C_min).\n  c. Replace all pixels of C_max with C_min.\n  d. If counts are equal, assume replacement based on color value (replace higher value color with lower value color, although this case is not explicitly covered by examples).\n\nThe background color pixels remain unchanged throughout the process.\nReturn the modified grid.\n\"\"\"\n\ndef find_colors(grid):\n    \"\"\"Identifies background (0) and the two non-background colors.\"\"\"\n    unique_colors = np.unique(grid)\n    bg_color = 0 # Assume 0 is always background\n    non_bg_colors = sorted([c for c in unique_colors if c != bg_color]) # Sort for consistency\n    if len(non_bg_colors) != 2:\n        # This case shouldn't happen based on the task description/examples\n        print(f\"Warning: Expected 2 non-background colors, found {len(non_bg_colors)}\")\n        return bg_color, None, None\n    return bg_color, non_bg_colors[0], non_bg_colors[1]\n\ndef check_hole_enclosure(grid, bg_color, c1, c2):\n    \"\"\"\n    Checks if C1 or C2 exclusively surrounds an internal background region (hole).\n    Returns the surrounding color (c1 or c2) if exclusive, otherwise None.\n    \"\"\"\n    height, width = grid.shape\n    bg_mask = (grid == bg_color)\n\n    # Label connected components of the background using 8-connectivity\n    structure = generate_binary_structure(2, 2) # Corresponds to connectivity=2\n    labeled_bg, num_bg_labels = label(bg_mask, structure=structure)\n\n    c1_exclusively_surrounds = False\n    c2_exclusively_surrounds = False\n\n    # Iterate through each background component label\n    for bg_label in range(1, num_bg_labels + 1):\n        component_mask = (labeled_bg == bg_label)\n        component_coords = np.argwhere(component_mask)\n\n        # Check if this component touches the border (is part of the outer background)\n        is_outer_bg = np.any(component_coords[:, 0] == 0) or \\\n                      np.any(component_coords[:, 0] == height - 1) or \\\n                      np.any(component_coords[:, 1] == 0) or \\\n                      np.any(component_coords[:, 1] == width - 1)\n\n        if not is_outer_bg:\n            # This is an internal component (a potential hole)\n            # Find border pixels adjacent to this hole using dilation\n            dilated_component = binary_dilation(component_mask, structure=structure, border_value=1) # Ensure dilation doesn't go out of bounds implicitly\n            border_mask = dilated_component & ~component_mask & (grid != bg_color) # Mask of non-bg neighbors\n\n            # Check the colors of the neighbors\n            neighbor_colors = np.unique(grid[border_mask])\n\n            # Ensure we only consider C1 and C2 as neighbors\n            valid_neighbor_colors = [nc for nc in neighbor_colors if nc in [c1, c2]]\n\n            if len(valid_neighbor_colors) == 1:\n                if valid_neighbor_colors[0] == c1:\n                    c1_exclusively_surrounds = True\n                elif valid_neighbor_colors[0] == c2:\n                    c2_exclusively_surrounds = True\n            # If len is 0 (no C1/C2 neighbours?) or 2 (both C1 and C2 border it), it's not exclusive.\n\n\n    # Determine the final result based on exclusive surrounding checks across all holes\n    if c1_exclusively_surrounds and not c2_exclusively_surrounds:\n        return c1 # C1 exclusively surrounds at least one hole, and C2 does not.\n    elif c2_exclusively_surrounds and not c1_exclusively_surrounds:\n        return c2 # C2 exclusively surrounds at least one hole, and C1 does not.\n    else:\n        # Neither surrounds exclusively, or both do (violating \"exactly one\" condition), or no holes found\n        return None\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule based on hole enclosure or pixel counts.\n    \"\"\"\n    # initialize output_grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # 1. Identify the background color and the two non-background colors\n    bg_color, c1, c2 = find_colors(input_grid)\n    if c1 is None or c2 is None:\n         print(\"Error: Could not identify two distinct non-background colors.\")\n         return output_grid # Return unchanged grid if colors are not as expected\n\n    # 2. Check for exclusive hole enclosure\n    surrounding_color = check_hole_enclosure(input_grid, bg_color, c1, c2)\n\n    # 3. Apply transformation rules\n    if surrounding_color is not None:\n        # Rule 1: Hole enclosure determines replacement\n        if surrounding_color == c1:\n            # C1 surrounds a hole exclusively, replace C2 with C1\n            replace_from, replace_to = c2, c1\n            print(f\"Rule 1: C1 ({c1}) surrounds hole. Replacing C2 ({c2}) with C1 ({c1}).\")\n        else: # surrounding_color == c2\n            # C2 surrounds a hole exclusively, replace C1 with C2\n            replace_from, replace_to = c1, c2\n            print(f\"Rule 1: C2 ({c2}) surrounds hole. Replacing C1 ({c1}) with C2 ({c2}).\")\n        \n        output_grid[output_grid == replace_from] = replace_to\n\n    else:\n        # Rule 2: No exclusive hole enclosure, use pixel counts\n        print(\"Rule 2: No exclusive hole enclosure. Using pixel counts.\")\n        # a. Count pixels\n        count1 = np.sum(input_grid == c1)\n        count2 = np.sum(input_grid == c2)\n        print(f\"Counts: C1 ({c1})={count1}, C2 ({c2})={count2}\")\n\n        # b. Identify max and min count colors\n        if count1 > count2:\n            c_max, c_min = c1, c2\n        elif count2 > count1:\n            c_max, c_min = c2, c1\n        else:\n            # c. Handle tie in counts (replace higher value color with lower value color as a fallback)\n             print(\"Counts are equal. Fallback: Replacing higher value color with lower value color.\")\n             if c1 > c2:\n                 c_max, c_min = c1, c2\n             else: # c2 > c1 (c1==c2 already handled by find_colors)\n                 c_max, c_min = c2, c1\n\n        # d. Replace C_max with C_min\n        print(f\"Replacing Max Count Color ({c_max}) with Min Count Color ({c_min}).\")\n        output_grid[output_grid == c_max] = c_min\n\n    # 4. Return the final grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3939,
    "candidates_token_count": 1972,
    "total_token_count": 5911,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 43.320117,
  "retries": 1
}