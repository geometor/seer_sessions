{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nIdentify three key colors: background (BKG), vertical pattern (C_vert), and horizontal pattern (C_horz).\nDetermine the columns (Cols_vert) containing C_vert and rows (Rows_horz) containing C_horz.\nCreate a copy of the input grid.\nIterate through the intersections of Rows_horz and Cols_vert.\nIf a pixel at an intersection (r, c) in the input grid has color C_horz, change its color to C_vert in the output grid.\nOtherwise, keep the original color.\nReturn the modified grid.\n\"\"\"\n\ndef find_colors(grid):\n    \"\"\"\n    Identifies background, horizontal pattern, and vertical pattern colors.\n\n    The background color is assumed to be 0.\n    The horizontal pattern color (C_horz) is the non-background color present in the fewest distinct rows.\n    The vertical pattern color (C_vert) is the non-background color present in the fewest distinct columns.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: (background_color, c_horz, c_vert)\n\n    Raises:\n        ValueError: If exactly two non-background colors are not found, or if\n                    horizontal/vertical roles are ambiguous based on row/column counts.\n    \"\"\"\n    unique_colors = np.unique(grid)\n\n    # Assume background is 0\n    if 0 in unique_colors:\n        background_color = 0\n    else:\n        # This case is not expected based on the examples, but provides a fallback.\n        # It might be better to raise an error if 0 is not present.\n        raise ValueError(\"Background color 0 not found in the grid.\")\n\n    other_colors = [c for c in unique_colors if c != background_color]\n\n    if len(other_colors) != 2:\n        raise ValueError(f\"Expected exactly two non-background colors, found {len(other_colors)}: {other_colors}\")\n\n    color1, color2 = other_colors\n\n    # Calculate how many distinct rows/columns each color appears in\n    rows1 = set(np.where(grid == color1)[0])\n    cols1 = set(np.where(grid == color1)[1])\n    rows2 = set(np.where(grid == color2)[0])\n    cols2 = set(np.where(grid == color2)[1])\n\n    num_rows1 = len(rows1)\n    num_cols1 = len(cols1)\n    num_rows2 = len(rows2)\n    num_cols2 = len(cols2)\n\n    # Identify C_horz: the color present in fewer distinct rows\n    if num_rows1 < num_rows2:\n        c_horz = color1\n    elif num_rows2 < num_rows1:\n        c_horz = color2\n    else:\n        raise ValueError(f\"Ambiguous horizontal color: Color {color1} in {num_rows1} rows, Color {color2} in {num_rows2} rows.\")\n\n    # Identify C_vert: the color present in fewer distinct columns\n    if num_cols1 < num_cols2:\n        c_vert = color1\n    elif num_cols2 < num_cols1:\n        c_vert = color2\n    else:\n        raise ValueError(f\"Ambiguous vertical color: Color {color1} in {num_cols1} cols, Color {color2} in {num_cols2} cols.\")\n\n    # Final sanity check: Ensure C_horz and C_vert are different colors\n    if c_horz == c_vert:\n        # This condition should technically not be reachable if the row/col counts are different\n        # but serves as a safeguard against unexpected logic flaws.\n        raise ValueError(f\"Identified horizontal ({c_horz}) and vertical ({c_vert}) colors are the same. Check logic.\")\n\n    return background_color, c_horz, c_vert\n\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule: Changes pixels at the intersection of\n    horizontal pattern rows and vertical pattern columns from the horizontal\n    color to the vertical color.\n\n    Args:\n        input_grid (list of lists): The input grid representing colors as integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input to numpy array for efficient processing\n    grid = np.array(input_grid, dtype=int)\n    # Initialize output_grid as a copy of the input grid\n    output_grid = grid.copy()\n\n    # --- Workflow ---\n\n    # 1. Identify the key colors: background, horizontal pattern (C_horz), vertical pattern (C_vert)\n    try:\n        _, c_horz, c_vert = find_colors(grid)\n    except ValueError as e:\n        # If colors cannot be determined unambiguously, return the original grid\n        # This handles cases not fitting the expected pattern.\n        print(f\"Warning: Could not determine colors reliably - {e}. Returning original grid.\")\n        return input_grid\n\n    # 2. Determine the set of column indices (Cols_vert) where C_vert appears\n    # A column is included if it contains at least one C_vert pixel.\n    cols_vert = set(np.where(np.any(grid == c_vert, axis=0))[0])\n\n    # 3. Determine the set of row indices (Rows_horz) where C_horz appears\n    # A row is included if it contains at least one C_horz pixel.\n    rows_horz = set(np.where(np.any(grid == c_horz, axis=1))[0])\n\n    # 4. Iterate through the identified rows and columns defining the intersections\n    for r in rows_horz:\n        for c in cols_vert:\n            # 5. Check the color of the pixel at the intersection (r, c) in the *original* input grid\n            if grid[r, c] == c_horz:\n                # 6. If the pixel color is C_horz, change its color to C_vert in the output grid\n                output_grid[r, c] = c_vert\n            # 7. If the pixel color is not C_horz, it remains unchanged (already copied)\n\n    # 8. Convert the result back to a list of lists format\n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3676,
    "candidates_token_count": 1482,
    "total_token_count": 5158,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 49.691554,
  "retries": 1
}