{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nTransforms the input grid based on the following rule:\n1. Identify all unique columns in the input grid by comparing their vertical pixel sequences.\n2. Select the leftmost unique column (the one with the smallest column index). If no unique columns exist, return the input grid unchanged.\n3. Iterate through each row of the input grid.\n4. For each row, check if it contains the background color white (0) and at most one other non-white color. (i.e., the set of unique colors in the row is {0} or {0, C} for some C > 0).\n5. If a row satisfies this condition, change the color of the pixel located at the intersection of this row and the selected unique column to white (0) in the output grid.\n6. All other pixels retain their original color from the input grid.\n\"\"\"\n\ndef find_unique_columns(grid):\n    \"\"\"\n    Identifies indices of columns that are unique in the grid based on their pixel values.\n\n    Args:\n        grid (np.ndarray): The input grid.\n\n    Returns:\n        list: A sorted list of indices of the unique columns. Returns an empty list\n              if no columns are unique.\n    \"\"\"\n    num_rows, num_cols = grid.shape\n    if num_cols <= 1: # A grid with 0 or 1 column has no non-unique columns to compare against\n        return list(range(num_cols)) # Or arguably [] if definition requires comparison\n\n    column_tuples = {}\n    # Store each column as a tuple and map it to the list of indices where it appears\n    for c in range(num_cols):\n        # Extract column c as a tuple of its pixel values\n        column_data = tuple(grid[:, c])\n        # Add the index 'c' to the list associated with this column pattern\n        if column_data not in column_tuples:\n            column_tuples[column_data] = []\n        column_tuples[column_data].append(c)\n\n    unique_column_indices = []\n    # Collect indices of columns whose pattern appears exactly once\n    for col_data, indices in column_tuples.items():\n        if len(indices) == 1:\n            unique_column_indices.append(indices[0])\n\n    # Return the indices sorted, maintaining the left-to-right order\n    return sorted(unique_column_indices)\n\ndef check_row_condition(row):\n    \"\"\"\n    Checks if a row contains the background color white (0)\n    and at most one other non-white color.\n\n    Args:\n        row (np.ndarray): A 1D numpy array representing a row of the grid.\n\n    Returns:\n        bool: True if the condition is met, False otherwise.\n    \"\"\"\n    # Find all unique color values present in the row\n    unique_colors = np.unique(row)\n\n    # Condition 1: The row must contain the background color white (0).\n    contains_white = 0 in unique_colors\n\n    # Condition 2: The row must contain at most two unique colors in total.\n    # Since we already require white (0) to be present, this means the row can\n    # either contain only white ({0}) or white and one other color ({0, C}).\n    at_most_two_colors = len(unique_colors) <= 2\n\n    # The row meets the condition only if both sub-conditions are true.\n    return contains_white and at_most_two_colors\n\ndef transform(input_grid):\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid (list of lists): The input grid represented as a list of lists of integers.\n\n    Returns:\n        list of lists: The transformed grid.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier processing\n    input_grid_np = np.array(input_grid, dtype=int)\n    num_rows, num_cols = input_grid_np.shape\n\n    # Step 1: Identify all unique columns\n    unique_cols_indices = find_unique_columns(input_grid_np)\n\n    # Step 2: Select the leftmost unique column. If none exist, return original grid.\n    if not unique_cols_indices:\n        # No unique columns found, return the input grid unchanged\n        return input_grid_np.tolist()\n\n    # The target column is the unique column with the smallest index\n    target_column_index = unique_cols_indices[0]\n\n    # Initialize the output grid as a copy of the input grid. Modifications will be made to this copy.\n    output_grid_np = input_grid_np.copy()\n\n    # Step 3 & 4 & 5: Iterate through each row, check condition, and modify output grid if needed\n    for r in range(num_rows):\n        # Get the current row from the original input grid\n        row = input_grid_np[r, :]\n\n        # Check if the current row meets the specified color composition condition\n        if check_row_condition(row):\n            # If the condition is met, change the pixel in the output grid\n            # at this row 'r' and the target column 'target_column_index' to white (0).\n            output_grid_np[r, target_column_index] = 0\n            # Note: Pixels in rows that don't meet the condition, or pixels outside\n            # the target column, remain unchanged due to starting with a copy.\n\n    # Step 6: Return the modified grid, converted back to list of lists format.\n    return output_grid_np.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2768,
    "candidates_token_count": 1284,
    "total_token_count": 4052,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 39.729365,
  "retries": 1
}