{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional, List, Dict, Set\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the unique vertical line in the input grid. This line consists of pixels of a single non-background color (`V_color`) and background pixels (0) in a single column (`C`).\n2. Iterate through each row (`R`) of the grid.\n3. For each row `R`, check if the pixel at the intersection with the vertical line (`grid[R, C]`) is non-background.\n4. If it intersects, analyze the colors present in row `R`.\n    a. **Pure Horizontal Line Intersection:** If row `R` contains only background pixels (0) and one other non-background color `H_color`, and the intersection pixel `grid[R, C]` is equal to `H_color`, then this is a \"pure\" intersection.\n    b. **Non-Pure Horizontal Line Intersection:** If row `R` contains the vertical line color `V_color` at the intersection (`grid[R, C] == V_color`) and at least one *other* non-background color `H_dom_color`, this is a \"non-pure\" intersection. Identify `H_dom_color` (assuming only one such other color exists based on examples).\n5. Collect all identified pure intersections `(R, C)` and non-pure intersections `(R, C, H_dom_color)`.\n6. **Apply Transformation Priority:**\n    a. If there are any pure intersections, modify the output grid only at these locations. For each pure intersection `(R, C)`, set the output pixel `output_grid[R, C]` to the vertical line color `V_color`. Ignore all non-pure intersections.\n    b. If there are *no* pure intersections, but there are non-pure intersections, modify the output grid at these locations. For each non-pure intersection `(R, C, H_dom_color)`, set the output pixel `output_grid[R, C]` to the corresponding dominant horizontal color `H_dom_color`.\n7. If an intersection doesn't meet the criteria for pure or non-pure transformation (or is ignored due to the priority rule), its color remains unchanged from the input.\n8. Return the modified grid.\n\"\"\"\n\ndef find_vertical_line(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the column index and color of the unique vertical line.\n    A vertical line column contains only background (0) and one other color.\n    Returns (column_index, line_color) or None if not found.\n    \"\"\"\n    height, width = grid.shape\n    for c in range(width):\n        col_pixels = grid[:, c]\n        non_background_pixels = col_pixels[col_pixels != 0]\n        unique_colors = np.unique(non_background_pixels)\n        if len(unique_colors) == 1:\n            # Check if all other pixels in the column are background\n            if np.all((col_pixels == 0) | (col_pixels == unique_colors[0])):\n                 return c, unique_colors[0]\n    return None # Should not happen based on problem description\n\ndef analyze_row_intersection(grid: np.ndarray, r: int, v_col: int, v_color: int) -> Tuple[str, Optional[int]]:\n    \"\"\"\n    Analyzes a row `r` to determine the type of intersection with the vertical line.\n\n    Args:\n        grid: The input grid.\n        r: The row index.\n        v_col: The column index of the vertical line.\n        v_color: The color of the vertical line.\n\n    Returns:\n        A tuple:\n        - Interaction type: \"pure\", \"non-pure\", or \"none\".\n        - Target color (if applicable):\n            - For \"pure\", returns v_color (the color to change *to*).\n            - For \"non-pure\", returns the dominant horizontal color H_dom_color (the color to change *to*).\n            - For \"none\", returns None.\n    \"\"\"\n    row = grid[r, :]\n    intersection_pixel_color = grid[r, v_col]\n    \n    # Ignore rows where the vertical line column is background\n    if intersection_pixel_color == 0:\n        return \"none\", None\n\n    non_background_row_pixels = row[row != 0]\n    unique_non_background_colors = set(np.unique(non_background_row_pixels))\n\n    # Check for Pure Intersection\n    if len(unique_non_background_colors) == 1:\n        h_color = list(unique_non_background_colors)[0]\n        # The intersection pixel must match the horizontal color\n        if intersection_pixel_color == h_color:\n            return \"pure\", v_color # Target color is the vertical line's color\n        else:\n             # This case happens in train_2 where the intersection pixel is already\n             # v_color, but the row *only* contains h_color otherwise.\n             # Let's re-evaluate based on the examples.\n             # train_1: intersect=2 (h), row={0,2}. output -> 1 (v). Rule: pure intersect -> v_color\n             # train_3: intersect=7 (h), row={0,7}. output -> 8 (v). Rule: pure intersect -> v_color\n             # train_4 (row 3): intersect=5 (h), row={0,5}. output -> 8 (v). Rule: pure intersect -> v_color\n             # Okay, the original pure rule holds: if row has only 1 non-bg color (h_color) AND intersect == h_color, target is v_color.\n             return \"none\", None\n\n\n    # Check for Non-Pure Intersection\n    elif len(unique_non_background_colors) > 1:\n        # The intersection pixel must match the vertical line color\n        if intersection_pixel_color == v_color:\n            other_colors = unique_non_background_colors - {v_color}\n            # Based on examples, assume only one 'other' non-background color matters\n            if len(other_colors) == 1:\n                h_dom_color = list(other_colors)[0]\n                return \"non-pure\", h_dom_color # Target color is the other horizontal color\n            else:\n                 # Ambiguous case based on examples, treat as no change\n                 return \"none\", None\n        else:\n             # Intersection pixel is non-background but not v_color, and row has multiple colors.\n             # This happens in train_4, row 1. Intersect=8(v), row={0, 5(h_dom), 8(v)}.\n             # The definition needs refinement. Let's revisit the rules from analysis:\n             # - Pure: Row has only H_color (and 0). Intersect pixel MUST BE H_color. Output is V_color.\n             # - Non-Pure: Row has V_color at intersect. Row also has H_dom_color elsewhere. Output is H_dom_color.\n             # So, if intersection pixel != v_color, it cannot be a non-pure intersection eligible for change by that rule.\n            return \"none\", None\n            \n    # Row only contains background? (Shouldn't happen if intersection pixel is non-background)\n    return \"none\", None\n\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule:\n    Finds a vertical line and horizontal lines/segments.\n    Modifies the intersection pixel based on whether the horizontal line is \"pure\"\n    (only one non-background color) or \"non-pure\" (contains the vertical line color\n    at the intersection plus another dominant color). Pure intersections take priority\n    and change the intersection to the vertical line's color. If no pure intersections\n    exist, non-pure intersections change the intersection pixel to the dominant\n    horizontal color.\n    \"\"\"\n    grid = np.array(input_grid, dtype=np.int8)\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Find the unique vertical line\n    line_info = find_vertical_line(grid)\n    if line_info is None:\n        return input_grid # Should not happen in ARC tasks\n    v_col, v_color = line_info\n\n    # 2. Find all potential intersections and classify them\n    pure_intersections: List[Tuple[int, int]] = [] # Stores (r, c)\n    non_pure_intersections: List[Tuple[int, int, int]] = [] # Stores (r, c, h_dom_color)\n\n    for r in range(height):\n        # Check only rows where the vertical line column is non-background\n        if grid[r, v_col] != 0:\n            intersection_type, target_color = analyze_row_intersection(grid, r, v_col, v_color)\n            \n            if intersection_type == \"pure\":\n                 # We store the target color (v_color) directly now for simplicity\n                 pure_intersections.append((r, v_col, target_color)) \n            elif intersection_type == \"non-pure\":\n                 non_pure_intersections.append((r, v_col, target_color)) # target_color is h_dom_color\n\n    # 3. Apply transformations based on priority\n    if pure_intersections: # If any pure intersections exist, process only them\n        for r, c, target_color in pure_intersections:\n            output_grid[r, c] = target_color # target_color is v_color here\n    elif non_pure_intersections: # Otherwise, process non-pure intersections\n        for r, c, target_color in non_pure_intersections:\n            output_grid[r, c] = target_color # target_color is h_dom_color here\n            \n    # If neither list has entries, no changes are made, output_grid remains a copy of input.\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3661,
    "candidates_token_count": 2324,
    "total_token_count": 5985,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 32.626379,
  "retries": 1
}