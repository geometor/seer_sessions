{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional, List, Set\n\n\"\"\"\nTransformation Rule:\n\n1.  Identify the unique vertical line in the input grid. The vertical line is defined as the unique column `C` where exactly one non-background color `V_color` appears more than once.\n2.  Create a copy of the input grid to serve as the output grid.\n3.  Iterate through each row `R` of the grid.\n4.  Analyze the intersection point `(R, C)` and the composition of colors in row `R`.\n5.  Apply changes based on two independent rules:\n    a.  **Pure Rule:** If row `R` contains exactly one unique non-background color `H_color`, AND the intersection pixel `grid[R, C]` has this color `H_color`, then update the output grid at `(R, C)` to `V_color`.\n    b.  **Non-Pure Rule:** If row `R` contains multiple unique non-background colors, AND the intersection pixel `grid[R, C]` has the vertical line's color `V_color`, AND there is exactly one *other* non-background color `H_dom_color` present in the row, then update the output grid at `(R, C)` to `H_dom_color`.\n6.  These rules are evaluated for each intersection, and if the conditions for either rule are met, the corresponding change is applied directly to the output grid.\n7.  Return the modified output grid.\n\"\"\"\n\n\ndef find_vertical_line(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the column index and color of the unique vertical line.\n    A vertical line is defined as the unique column C where exactly one\n    non-background color V_color appears more than once.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        A tuple (column_index, line_color) or None if no such line is found.\n    \"\"\"\n    height, width = grid.shape\n    potential_lines = []\n    for c in range(width):\n        col = grid[:, c]\n        non_bg_col = col[col != 0] # Filter out background pixels\n        if len(non_bg_col) == 0:\n            continue # Skip columns with only background\n\n        # Count occurrences of each non-background color in the column\n        unique_colors, counts = np.unique(non_bg_col, return_counts=True)\n\n        # Find colors that appear more than once\n        colors_more_than_once = unique_colors[counts > 1]\n\n        # Check if exactly one color appears more than once\n        if len(colors_more_than_once) == 1:\n            v_color = colors_more_than_once[0]\n            # Store the column index and the dominant color\n            potential_lines.append({'col': c, 'color': v_color})\n\n    # Assuming there's always exactly one such line based on ARC examples\n    if len(potential_lines) == 1:\n         return potential_lines[0]['col'], potential_lines[0]['color']\n    elif len(potential_lines) > 1:\n         # Fallback for potential ambiguity, though not seen in examples\n         # Returning the first one found based on column index.\n         print(f\"Warning: Multiple potential vertical lines found: {potential_lines}. Using the first one (column {potential_lines[0]['col']}).\")\n         return potential_lines[0]['col'], potential_lines[0]['color']\n\n    return None # No line found meeting the criteria\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule based on vertical line intersections\n    and row color composition. Applies 'Pure' and 'Non-Pure' rules independently.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier manipulation\n    grid = np.array(input_grid, dtype=np.int8)\n    # Create a copy to modify, which will become the output\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Identify the unique vertical line (column index C, color V_color)\n    line_info = find_vertical_line(grid)\n    if line_info is None:\n        # If no vertical line is found (shouldn't happen based on examples), return original grid\n        print(\"Warning: No unique vertical line found based on the definition.\")\n        return input_grid # Return input as is\n    v_col, v_color = line_info\n\n    # 2. Iterate through each row to analyze intersections and apply rules\n    for r in range(height):\n        intersect_color = grid[r, v_col]\n\n        # 2a. Skip if the intersection point is background color\n        if intersect_color == 0:\n            continue\n\n        # 2b. Analyze colors in the current row\n        row = grid[r, :]\n        non_background_row_pixels = row[row != 0]\n        # Handle rows with only background (apart from intersection) if needed\n        if len(non_background_row_pixels) == 0:\n             # This case implies the intersection pixel is the only non-bg pixel.\n             # It doesn't fit either rule cleanly. Let's assume no change.\n             continue\n             \n        unique_row_colors: Set[int] = set(np.unique(non_background_row_pixels))\n\n        # 3. Check and Apply Pure Rule\n        # Condition: Row has exactly one unique non-bg color (h_color) AND intersect pixel IS h_color\n        if len(unique_row_colors) == 1:\n            h_color = list(unique_row_colors)[0]\n            if intersect_color == h_color:\n                # Action: Change the output pixel to v_color\n                output_grid[r, v_col] = v_color\n                # Continue to next row as rules are mutually exclusive based on len(unique_row_colors)\n                continue \n\n        # 4. Check and Apply Non-Pure Rule\n        # Condition: Row has multiple unique non-bg colors AND intersect pixel IS v_color\n        # AND exactly one OTHER non-bg color (h_dom_color) exists in the row\n        elif len(unique_row_colors) > 1:\n            if intersect_color == v_color:\n                other_colors = unique_row_colors - {v_color}\n                if len(other_colors) == 1:\n                    h_dom_color = list(other_colors)[0]\n                    # Action: Change the output pixel to h_dom_color\n                    output_grid[r, v_col] = h_dom_color\n                    # Continue to next row\n                    continue\n                    \n        # 5. If neither rule applied, the pixel in output_grid remains unchanged (as it was copied initially)\n\n    # 6. Return the modified grid converted back to list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 13246,
    "candidates_token_count": 1625,
    "total_token_count": 14871,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 16.994005,
  "retries": 1
}