{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import Tuple, Optional, List, Set\n\n\"\"\"\nTransformation Rule:\n\n1. Identify the unique vertical line in the input grid. The vertical line is defined as the unique column `C` where exactly one non-background color `V_color` appears more than once.\n2. Iterate through each row `R` of the grid.\n3. Analyze the intersection point `(R, C)` and the composition of colors in row `R`.\n4. Determine required changes based on two rules:\n    a. **Pure Rule:** If row `R` contains exactly one unique non-background color `H_color`, AND the intersection pixel `grid[R, C]` has this color `H_color`, then a change is required: set the intersection pixel to `V_color`.\n    b. **Non-Pure Rule:** If row `R` contains multiple unique non-background colors, AND the intersection pixel `grid[R, C]` has the vertical line's color `V_color`, AND there is exactly one *other* non-background color `H_dom_color` present in the row, then a change is required: set the intersection pixel to `H_dom_color`.\n5. Collect all required changes identified by the Pure Rule into a `pure_changes` list and those by the Non-Pure Rule into a `non_pure_changes` list.\n6. Apply the changes with priority: If the `pure_changes` list is not empty, apply *only* those changes to the output grid. Otherwise (if `pure_changes` is empty), apply all the changes from the `non_pure_changes` list.\n7. Return the modified grid. Pixels not part of a prioritized change remain unchanged.\n\"\"\"\n\ndef find_vertical_line(grid: np.ndarray) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Finds the column index and color of the unique vertical line.\n    A vertical line is defined as the unique column C where exactly one\n    non-background color V_color appears more than once.\n\n    Args:\n        grid: The input grid as a NumPy array.\n\n    Returns:\n        A tuple (column_index, line_color) or None if no such line is found.\n    \"\"\"\n    height, width = grid.shape\n    potential_lines = []\n    for c in range(width):\n        col = grid[:, c]\n        non_bg_col = col[col != 0] # Filter out background pixels\n        if len(non_bg_col) == 0:\n            continue # Skip columns with only background\n\n        # Count occurrences of each non-background color in the column\n        unique_colors, counts = np.unique(non_bg_col, return_counts=True)\n\n        # Find colors that appear more than once\n        colors_more_than_once = unique_colors[counts > 1]\n\n        # Check if exactly one color appears more than once\n        if len(colors_more_than_once) == 1:\n            v_color = colors_more_than_once[0]\n            # Store the column index and the dominant color\n            potential_lines.append({'col': c, 'color': v_color})\n\n    # Assuming there's always exactly one such line based on ARC examples\n    if len(potential_lines) == 1:\n         return potential_lines[0]['col'], potential_lines[0]['color']\n    # Add fallback for potential ambiguity, though not seen in examples\n    elif len(potential_lines) > 1:\n         # Heuristic: if multiple columns match, maybe return the leftmost one?\n         # Or based on color count if that differs? For now, return first found.\n         print(f\"Warning: Multiple potential vertical lines found: {potential_lines}. Using the first one.\")\n         return potential_lines[0]['col'], potential_lines[0]['color']\n\n    return None # No line found meeting the criteria\n\ndef transform(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Applies the transformation rule based on vertical line intersections\n    and row color composition with priority for 'pure' intersections.\n    \"\"\"\n    # Convert input list of lists to a NumPy array for easier manipulation\n    grid = np.array(input_grid, dtype=np.int8)\n    # Create a copy to modify, which will become the output\n    output_grid = np.copy(grid)\n    height, width = grid.shape\n\n    # 1. Identify the unique vertical line (column index C, color V_color)\n    line_info = find_vertical_line(grid)\n    if line_info is None:\n        # If no vertical line is found (should not happen based on examples), return original grid\n        print(\"Warning: No unique vertical line found based on the definition.\")\n        return input_grid\n    v_col, v_color = line_info\n\n    # 2. Initialize lists to store required changes based on rules\n    pure_changes: List[Tuple[int, int, int]] = [] # Stores (row, col, new_color)\n    non_pure_changes: List[Tuple[int, int, int]] = [] # Stores (row, col, new_color)\n\n    # 3. Analyze Intersections and Determine Required Changes\n    for r in range(height):\n        intersect_color = grid[r, v_col]\n\n        # 3a. Skip if the intersection point is background color\n        if intersect_color == 0:\n            continue\n\n        # 3b. Analyze colors in the current row\n        row = grid[r, :]\n        non_background_row_pixels = row[row != 0]\n        # Handle empty rows if necessary, though unlikely if intersect is non-zero\n        if len(non_background_row_pixels) == 0:\n            continue\n        unique_row_colors: Set[int] = set(np.unique(non_background_row_pixels))\n\n        # 4a. Check for Pure Rule Condition\n        if len(unique_row_colors) == 1:\n            h_color = list(unique_row_colors)[0]\n            # Condition: Row has only one non-bg color (h_color) AND intersect pixel IS h_color\n            if intersect_color == h_color:\n                # Store the required change: intersect pixel becomes v_color\n                pure_changes.append((r, v_col, v_color))\n\n        # 4b. Check for Non-Pure Rule Condition\n        elif len(unique_row_colors) > 1:\n            # Condition: Intersect pixel IS v_color\n            if intersect_color == v_color:\n                other_colors = unique_row_colors - {v_color}\n                # Condition: Exactly one OTHER non-bg color exists in the row\n                if len(other_colors) == 1:\n                    h_dom_color = list(other_colors)[0]\n                    # Store the required change: intersect pixel becomes h_dom_color\n                    non_pure_changes.append((r, v_col, h_dom_color))\n\n    # 5. Apply Changes Based on Priority\n    # 5a. If pure changes exist, apply ONLY them\n    if pure_changes:\n        for r_change, c_change, target_color in pure_changes:\n            output_grid[r_change, c_change] = target_color\n    # 5b. Else (no pure changes), apply non-pure changes (if any)\n    elif non_pure_changes:\n        for r_change, c_change, target_color in non_pure_changes:\n            output_grid[r_change, c_change] = target_color\n    \n    # 6. Return the modified grid converted back to list of lists format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 17291,
    "candidates_token_count": 1776,
    "total_token_count": 19067,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 21.495894,
  "retries": 1
}