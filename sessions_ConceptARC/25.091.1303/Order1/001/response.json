{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\n\"\"\"\nIdentifies distinct non-background colored objects in the input grid.\nDetermines if the objects are arranged primarily horizontally or vertically.\nIf arranged horizontally, reorders the objects based on their width (ascending) while preserving horizontal spacing and vertical alignment.\nIf arranged vertically, reverses the vertical order of the objects while preserving vertical spacing and horizontal alignment.\nReconstructs the output grid with the reordered objects.\n\"\"\"\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all connected components of non-background colors in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents an object:\n              (color, set_of_coordinates, bounding_box)\n              bounding_box is (min_r, min_c, max_r, max_c)\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    background_color = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != background_color and not visited[r, c]:\n                color = grid[r, c]\n                coords = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                min_r, min_c = r, c\n                max_r, max_c = r, c\n\n                while q:\n                    row, col = q.popleft()\n                    coords.add((row, col))\n                    min_r = min(min_r, row)\n                    min_c = min(min_c, col)\n                    max_r = max(max_r, row)\n                    max_c = max(max_c, col)\n\n                    # Check neighbors (4-connectivity)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                \n                bounding_box = (min_r, min_c, max_r, max_c)\n                objects.append({'color': color, 'coords': coords, 'bbox': bounding_box})\n\n    return objects\n\ndef determine_layout_and_order(objects):\n    \"\"\"\n    Determines the layout (horizontal/vertical) and calculates spacing.\n    Sorts objects initially by position (top-left).\n\n    Args:\n        objects (list): List of object dictionaries.\n\n    Returns:\n        tuple: (layout_axis, sorted_original_objects, separation)\n               layout_axis is 'horizontal' or 'vertical' or 'unknown'.\n               sorted_original_objects is the list sorted by position.\n               separation is the average gap size (int). Returns 0 if layout unclear or < 2 objects.\n    \"\"\"\n    if not objects:\n        return 'unknown', [], 0\n    \n    # Sort objects by top-left corner (row first, then column)\n    objects.sort(key=lambda o: (o['bbox'][0], o['bbox'][1]))\n\n    if len(objects) < 2:\n        return 'unknown', objects, 0 # Layout needs at least 2 objects to be meaningful\n\n    # Check for horizontal layout\n    is_horizontal = True\n    horizontal_gaps = []\n    for i in range(len(objects) - 1):\n        o1 = objects[i]\n        o2 = objects[i+1]\n        min_r1, min_c1, max_r1, max_c1 = o1['bbox']\n        min_r2, min_c2, max_r2, max_c2 = o2['bbox']\n        \n        # Check if o2 is to the right of o1\n        if min_c2 > max_c1:\n             # Check vertical overlap (at least one row must overlap)\n             overlap_start = max(min_r1, min_r2)\n             overlap_end = min(max_r1, max_r2)\n             if overlap_end >= overlap_start:\n                 horizontal_gaps.append(min_c2 - max_c1 - 1)\n             else:\n                 is_horizontal = False\n                 break\n        else:\n            is_horizontal = False\n            break\n            \n    if is_horizontal and horizontal_gaps:\n        separation = round(sum(horizontal_gaps) / len(horizontal_gaps))\n        return 'horizontal', objects, int(separation)\n\n    # Check for vertical layout (reset sort order check based on vertical position)\n    # Re-sort based on column first might be needed if horizontal alignment is strict\n    # For now, assume the initial row-then-col sort is sufficient for vertical stacking check too.\n    is_vertical = True\n    vertical_gaps = []\n    for i in range(len(objects) - 1):\n        o1 = objects[i]\n        o2 = objects[i+1]\n        min_r1, min_c1, max_r1, max_c1 = o1['bbox']\n        min_r2, min_c2, max_r2, max_c2 = o2['bbox']\n\n        # Check if o2 is below o1\n        if min_r2 > max_r1:\n            # Check horizontal overlap (at least one column must overlap)\n            overlap_start = max(min_c1, min_c2)\n            overlap_end = min(max_c1, max_c2)\n            if overlap_end >= overlap_start:\n                vertical_gaps.append(min_r2 - max_r1 - 1)\n            else:\n                # This case might occur if objects are staggered vertically AND horizontally\n                # Let's assume for now pure vertical implies good horizontal overlap\n                 is_vertical = False\n                 break\n        else:\n            # This could be side-by-side or overlapping, not purely vertical stacking\n             is_vertical = False\n             break\n             \n    if is_vertical and vertical_gaps:\n        separation = round(sum(vertical_gaps) / len(vertical_gaps))\n        return 'vertical', objects, int(separation)\n\n    # If neither clearly horizontal nor vertical based on sequence\n    return 'unknown', objects, 0\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid by reordering objects based on layout.\n    Horizontal layout: sort by width (ascending).\n    Vertical layout: reverse order.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    rows, cols = input_grid_np.shape\n    output_grid = np.zeros_like(input_grid_np, dtype=int) # Initialize with background color 0\n    \n    # --- Step 1: Identify Objects ---\n    objects = find_objects(input_grid_np)\n    \n    if not objects:\n        return output_grid.tolist() # Return empty grid if no objects\n\n    # --- Step 2: Determine Layout and Original Order ---\n    layout_axis, original_ordered_objects, separation = determine_layout_and_order(objects)\n\n    if layout_axis == 'unknown' or len(objects) < 2:\n        # If layout is unclear or only one object, return the original grid (or as identified)\n        # We'll place the single object back for robustness\n         if objects:\n             obj = objects[0]\n             for r, c in obj['coords']:\n                  if 0 <= r < rows and 0 <= c < cols:\n                      output_grid[r, c] = obj['color']\n         return output_grid.tolist()\n\n\n    # --- Step 3: Apply Reordering Rule ---\n    if layout_axis == 'horizontal':\n        # Calculate width for sorting\n        for obj in objects:\n            min_r, min_c, max_r, max_c = obj['bbox']\n            obj['width'] = max_c - min_c + 1\n        # Sort by width\n        reordered_objects = sorted(objects, key=lambda o: o['width'])\n        \n        # --- Step 4: Reconstruct Grid (Horizontal) ---\n        # Find the starting column of the first object in the *original* sequence\n        start_col = min(o['bbox'][1] for o in original_ordered_objects)\n        current_col = start_col\n        \n        for obj in reordered_objects:\n            color = obj['color']\n            min_r_orig, min_c_orig, _, _ = obj['bbox']\n            # Place object relative to current_col and its original min_r\n            for r, c in obj['coords']:\n                # Calculate offset: how far each pixel is from the object's original top-left\n                offset_r = r - min_r_orig\n                offset_c = c - min_c_orig\n                # Calculate new position\n                new_r = min_r_orig + offset_r # Keep original row position\n                new_c = current_col + offset_c\n                if 0 <= new_r < rows and 0 <= new_c < cols:\n                    output_grid[new_r, new_c] = color\n            \n            # Update current_col for the next object\n            obj_width = obj['width'] # Use calculated width\n            current_col += obj_width + separation\n\n    elif layout_axis == 'vertical':\n        # Reverse the order (original_ordered_objects is already sorted by position)\n        reordered_objects = original_ordered_objects[::-1]\n\n        # --- Step 4: Reconstruct Grid (Vertical) ---\n        # Find the starting row of the first object in the *original* sequence\n        start_row = min(o['bbox'][0] for o in original_ordered_objects)\n        current_row = start_row\n\n        for obj in reordered_objects:\n            color = obj['color']\n            min_r_orig, min_c_orig, max_r_orig, _ = obj['bbox']\n            obj_height = max_r_orig - min_r_orig + 1\n\n            # Place object relative to current_row and its original min_c\n            for r, c in obj['coords']:\n                 # Calculate offset: how far each pixel is from the object's original top-left\n                offset_r = r - min_r_orig\n                offset_c = c - min_c_orig\n                # Calculate new position\n                new_r = current_row + offset_r\n                new_c = min_c_orig + offset_c # Keep original col position\n                if 0 <= new_r < rows and 0 <= new_c < cols:\n                    output_grid[new_r, new_c] = color\n            \n            # Update current_row for the next object\n            current_row += obj_height + separation\n            \n    return output_grid.tolist()\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 4257,
    "candidates_token_count": 2593,
    "total_token_count": 6850,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 35.682937,
  "retries": 1
}