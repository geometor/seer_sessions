{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import deque\n\ndef find_objects(grid):\n    \"\"\"\n    Finds all contiguous objects of the same non-background color in the grid.\n\n    Args:\n        grid (np.array): The input grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: A list of dictionaries, where each dictionary represents an\n                    object and contains its 'content' (np.array), 'width' (int),\n                    'height' (int), 'start_row' (int), and 'start_col' (int).\n            - int: The minimum starting row index among all found objects.\n                   Returns grid height if no objects are found.\n    \"\"\"\n    height, width = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    objects = []\n    # Initialize with a value larger than any possible row index\n    min_start_row_overall = height\n\n    for r in range(height):\n        for c in range(width):\n            # Check for non-background color (0 is white background) and unvisited cell\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                object_pixels = [(r, c)] # Store coordinates of pixels in this object\n                # Bounding box initialization for this object\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n\n                # Breadth-First Search (BFS) to find all connected pixels of the same color\n                while q:\n                    row, col = q.popleft()\n                    \n                    # Update bounding box\n                    min_r = min(min_r, row)\n                    max_r = max(max_r, row)\n                    min_c = min(min_c, col)\n                    max_c = max(max_c, col)\n\n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        # Check grid boundaries, visited status, and color match\n                        if 0 <= nr < height and 0 <= nc < width and \\\n                           not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                            object_pixels.append((nr, nc))\n\n                # Calculate object dimensions from bounding box\n                obj_height = max_r - min_r + 1\n                obj_width = max_c - min_c + 1\n\n                # Extract the object's pixel data into its own grid (content)\n                content = np.zeros((obj_height, obj_width), dtype=grid.dtype)\n                for pr, pc in object_pixels:\n                    # Map absolute coordinates to relative coordinates within the content grid\n                    content[pr - min_r, pc - min_c] = color\n                \n                # Update the overall minimum start row found across all objects\n                min_start_row_overall = min(min_start_row_overall, min_r)\n\n                # Store object properties\n                objects.append({\n                    'content': content,   # The actual pixel data np.array\n                    'width': obj_width,   # Width based on bounding box\n                    'height': obj_height,  # Height based on bounding box\n                    'start_row': min_r,   # Original top row index\n                    'start_col': min_c    # Original leftmost column index\n                })\n\n    # If no objects were found, min_start_row_overall remains grid height.\n    # It might be better to return 0 or handle this case specifically if needed.\n    # Based on examples, we expect objects.\n    if not objects:\n        min_start_row_overall = 0 # Default to 0 if no objects\n\n    return objects, min_start_row_overall\n\n\ndef transform(input_grid):\n    \"\"\"\n    Identifies non-background objects in the input grid, sorts them by width\n    in ascending order, and stacks them vertically in the output grid starting\n    from the row where the topmost object originally began. Objects are placed\n    starting at column 0 in the output, preserving their original content,\n    height, and width.\n    \"\"\"\n    # Convert input list of lists to numpy array for easier manipulation\n    input_grid_np = np.array(input_grid, dtype=int)\n    height, width = input_grid_np.shape\n\n    # Step 1 & 2: Find all distinct objects and their properties, \n    # and determine the minimum start row.\n    objects, min_start_row = find_objects(input_grid_np)\n\n    # Handle case where no objects are found (return a copy of the input)\n    if not objects:\n        return input_grid # Return original list of lists\n\n    # Step 4 & 5: Sort the objects based on their width (ascending).\n    # Using stable sort (default in Python's sort/sorted) preserves original \n    # relative order for objects with the same width.\n    objects.sort(key=lambda obj: obj['width'])\n\n    # Step 6: Initialize the output grid with the background color (white=0)\n    output_grid = np.zeros_like(input_grid_np, dtype=input_grid_np.dtype)\n\n    # Step 7: Initialize the row counter for placing objects in the output grid\n    current_output_row = min_start_row\n\n    # Step 8-11: Iterate through the width-sorted list of objects and place them.\n    for obj in objects:\n        obj_content = obj['content']\n        obj_height = obj['height']\n        obj_width = obj['width'] # Use the width derived from bounding box/content\n\n        # Calculate target slice boundaries for placement in the output grid.\n        # Objects are placed starting at column 0 as per observed pattern.\n        end_row = current_output_row + obj_height\n        target_col_start = 0\n        end_col = target_col_start + obj_width\n\n        # Ensure placement stays within output grid bounds\n        if end_row <= height and end_col <= width:\n            # Place the object's content onto the output grid\n            output_grid[current_output_row : end_row, target_col_start : end_col] = obj_content\n        else:\n            # Handle partial placement if object exceeds grid boundaries\n            # This might indicate an issue or require clipping based on task rules\n            # For now, we clip the part of the object that fits.\n            fit_height = min(obj_height, height - current_output_row)\n            fit_width = min(obj_width, width - target_col_start)\n\n            if fit_height > 0 and fit_width > 0:\n                 output_grid[current_output_row : current_output_row + fit_height, target_col_start : target_col_start + fit_width] = \\\n                     obj_content[:fit_height, :fit_width]\n            # Note: If an object doesn't fit at all, it won't be placed.\n\n        # Update the starting row for the next object\n        current_output_row += obj_height\n\n    # Step 12: Convert the final numpy array back to a list of lists for the ARC standard output\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2952,
    "candidates_token_count": 1740,
    "total_token_count": 4692,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 57.722494,
  "retries": 1
}