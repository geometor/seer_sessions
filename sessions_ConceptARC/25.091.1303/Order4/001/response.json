{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nimport collections\n\n\"\"\"\nIdentifies vertical bands of non-background colors in the input grid.\nFor each band, it determines a primary color (ignoring gray-5) and calculates the bounding box of all non-background pixels within that band.\nA color transformation rule is applied to the primary color. This rule depends on whether gray-5 is present anywhere in the *entire* input grid.\n  - If gray-5 is present: Blue(1)->Yellow(4), Red(2)->Red(2), Green(3)->Blue(1), Yellow(4)->Green(3).\n  - If gray-5 is absent: Red(2)->Orange(7), Yellow(4)->Magenta(6), Magenta(6)->Red(2), Orange(7)->Yellow(4).\nThe calculated bounding box in the output grid is filled with the transformed color.\n\"\"\"\n\ndef find_vertical_bands(grid):\n    \"\"\"\n    Finds contiguous columns containing non-background pixels.\n\n    Args:\n        grid (np.array): Input grid.\n\n    Returns:\n        list: A list of tuples, where each tuple represents a band\n              as (start_column_index, end_column_index_exclusive).\n    \"\"\"\n    bands = []\n    num_cols = grid.shape[1]\n    if num_cols == 0:\n        return bands\n\n    # Check which columns contain any non-zero pixels\n    has_non_zero = np.any(grid != 0, axis=0)\n\n    in_band = False\n    start_col = 0\n    for c in range(num_cols):\n        if has_non_zero[c] and not in_band:\n            in_band = True\n            start_col = c\n        elif not has_non_zero[c] and in_band:\n            in_band = False\n            bands.append((start_col, c))\n\n    # Handle case where the last column is part of a band\n    if in_band:\n        bands.append((start_col, num_cols))\n\n    return bands\n\ndef process_band(grid_slice, start_col, color_map):\n    \"\"\"\n    Processes a single vertical band slice to find its bounding box,\n    primary color, and transformed output color.\n\n    Args:\n        grid_slice (np.array): The slice of the input grid corresponding to the band.\n        start_col (int): The starting column index of this slice in the original grid.\n        color_map (dict): The color transformation map to use.\n\n    Returns:\n        tuple: (r_min, r_max, c_min, c_max, output_color) if a primary color is found,\n               otherwise None.\n    \"\"\"\n    # Find coordinates of all non-background pixels in the slice\n    non_zero_coords_local = np.argwhere(grid_slice != 0)\n    if non_zero_coords_local.size == 0:\n        return None # Band is effectively empty\n\n    # Determine the primary (non-gray, non-background) color within this band\n    primary_colors = np.unique(grid_slice[(grid_slice != 0) & (grid_slice != 5)])\n\n    if primary_colors.size == 0:\n         # This band might only contain gray or background, ignore for color transformation\n         # but still need bbox if only gray exists for shape transformation?\n         # The examples suggest output objects correspond to primary colors.\n         # If only gray, treat as empty for output object creation.\n        return None\n    elif primary_colors.size > 1:\n        # This case is not expected based on examples, assume one primary color per band\n        # print(f\"Warning: Multiple primary colors found in band starting at col {start_col}: {primary_colors}\")\n        # Defaulting to the smallest color number if multiple exist\n        input_color = np.min(primary_colors)\n    else:\n      input_color = primary_colors[0]\n\n\n    # Apply the color transformation\n    output_color = color_map.get(input_color, input_color) # Default to input if not in map\n\n    # Calculate the bounding box using all non-background pixels (including gray)\n    rows = non_zero_coords_local[:, 0]\n    local_cols = non_zero_coords_local[:, 1]\n    global_cols = local_cols + start_col # Convert local column indices to global\n\n    r_min, r_max = np.min(rows), np.max(rows)\n    c_min, c_max = np.min(global_cols), np.max(global_cols) # Use global columns for bbox\n\n    return r_min, r_max, c_min, c_max, output_color\n\n\ndef transform(input_grid):\n    \"\"\"\n    Transforms the input grid based on vertical bands, bounding boxes,\n    and a context-dependent color mapping rule.\n\n    Args:\n        input_grid (list of lists): The input grid.\n\n    Returns:\n        list of lists: The transformed output grid.\n    \"\"\"\n    input_grid_np = np.array(input_grid, dtype=int)\n    output_grid = np.zeros_like(input_grid_np) # Initialize with background color 0\n\n    # Check if gray (5) is present anywhere in the input grid (excluding background 0)\n    unique_colors_non_bg = np.unique(input_grid_np[input_grid_np != 0])\n    gray_present = 5 in unique_colors_non_bg\n\n    # Define the color map based on the presence of gray\n    if gray_present:\n        # Rule from train_1\n        color_map = {1: 4, 2: 2, 3: 1, 4: 3}\n    else:\n        # Rule from train_2\n        color_map = {2: 7, 4: 6, 6: 2, 7: 4}\n\n    # Find vertical bands of non-background colors\n    bands = find_vertical_bands(input_grid_np)\n\n    # Process each band\n    for start_col, end_col in bands:\n        # Extract the slice corresponding to the band\n        band_slice = input_grid_np[:, start_col:end_col]\n\n        # Process the band to get bounding box and output color\n        result = process_band(band_slice, start_col, color_map)\n\n        if result:\n            r_min, r_max, c_min, c_max, output_color = result\n            # Fill the bounding box in the output grid with the transformed color\n            output_grid[r_min : r_max + 1, c_min : c_max + 1] = output_color\n\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 3215,
    "candidates_token_count": 1562,
    "total_token_count": 4777,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 44.923819,
  "retries": 1
}