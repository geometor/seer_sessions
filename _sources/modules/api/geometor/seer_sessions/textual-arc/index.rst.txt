geometor.seer_sessions.textual-arc
==================================

.. py:module:: geometor.seer_sessions.textual-arc


Attributes
----------

.. autoapisummary::

   geometor.seer_sessions.textual-arc.COLOR_PALETTE
   geometor.seer_sessions.textual-arc.GRID_DATA
   geometor.seer_sessions.textual-arc.app


Classes
-------

.. autoapisummary::

   geometor.seer_sessions.textual-arc.BaseGrid
   geometor.seer_sessions.textual-arc.ImageGrid
   geometor.seer_sessions.textual-arc.UnicodeBlockGrid
   geometor.seer_sessions.textual-arc.HalfBlockGrid
   geometor.seer_sessions.textual-arc.ARCGridApp


Module Contents
---------------

.. py:data:: COLOR_PALETTE

.. py:data:: GRID_DATA
   :value: [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],...


.. py:class:: BaseGrid(grid, **kwargs)

   Bases: :py:obj:`textual.widgets.Static`


   Base widget class for rendering the colored grid.


   .. py:attribute:: grid


   .. py:attribute:: rows


   .. py:attribute:: cols


   .. py:attribute:: DEFAULT_CSS
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
             Static {
                 height: auto;
             }
             """

      .. raw:: html

         </details>



      Default TCSS.


   .. py:attribute:: expand
      :value: False


      Rich renderable may expand beyond optimal size.


   .. py:attribute:: shrink
      :value: False


      Rich renderable may shrink below optimal size.


   .. py:property:: visual
      :type: textual.visual.Visual


      The visual to be displayed.

      Note that the visual is what is ultimately rendered in the widget, but may not be the
      same object set with the `update` method  or `content` property. For instance, if you
      update with a string, then the visual will be a [Content][textual.content.Content] instance.


   .. py:property:: content
      :type: textual.visual.VisualType


      The original content set in the constructor.


   .. py:method:: render() -> textual.app.RenderResult

      Get a rich renderable for the widget's content.

      :returns: A rich renderable.



   .. py:method:: update(content: textual.visual.VisualType = '', *, layout: bool = True) -> None

      Update the widget's content area with a string, a Visual (such as [Content][textual.content.Content]), or a [Rich renderable](https://rich.readthedocs.io/en/latest/protocol.html).

      :param content: New content.
      :param layout: Also perform a layout operation (set to `False` if you are certain the size won't change).



   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: BORDER_TITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_title attribute.


   .. py:attribute:: BORDER_SUBTITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_subtitle attribute.


   .. py:attribute:: ALLOW_MAXIMIZE
      :type:  ClassVar[bool | None]
      :value: None


      Defines default logic to allow the widget to be maximized.

      - `None` Use default behavior (Focusable widgets may be maximized)
      - `False` Do not allow widget to be maximized
      - `True` Allow widget to be maximized


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      Does this widget support automatic text selection? May be further refined with [Widget.allow_select][textual.widget.Widget.allow_select].


   .. py:attribute:: FOCUS_ON_CLICK
      :type:  ClassVar[bool]
      :value: True


      Should focusable widgets be automatically focused on click? Default return value of [Widget.focus_on_click][textual.widget.Widget.focus_on_click].


   .. py:attribute:: can_focus
      :type:  bool
      :value: False


      Widget may receive focus.


   .. py:attribute:: can_focus_children
      :type:  bool
      :value: True


      Widget's children may receive focus.


   .. py:attribute:: auto_links
      :type:  textual.reactive.Reactive[bool]

      Widget will highlight links automatically.


   .. py:attribute:: disabled
      :type:  textual.reactive.Reactive[bool]

      Is the widget disabled? Disabled widgets can not be interacted with, and are typically styled to look dimmer.


   .. py:attribute:: hover_style
      :type:  textual.reactive.Reactive[rich.style.Style]

      The current hover style (style under the mouse cursor). Read only.


   .. py:attribute:: highlight_link_id
      :type:  textual.reactive.Reactive[str]

      The currently highlighted link id. Read only.


   .. py:attribute:: loading
      :type:  textual.reactive.Reactive[bool]

      If set to `True` this widget will temporarily be replaced with a loading indicator.


   .. py:attribute:: virtual_size
      :type:  textual.reactive.Reactive[textual.geometry.Size]

      The virtual (scrollable) [size][textual.geometry.Size] of the widget.


   .. py:attribute:: has_focus
      :type:  textual.reactive.Reactive[bool]

      Does this widget have focus? Read only.


   .. py:attribute:: mouse_hover
      :type:  textual.reactive.Reactive[bool]

      Is the mouse over this widget? Read only.


   .. py:attribute:: scroll_x
      :type:  textual.reactive.Reactive[float]

      The scroll position on the X axis.


   .. py:attribute:: scroll_y
      :type:  textual.reactive.Reactive[float]

      The scroll position on the Y axis.


   .. py:attribute:: scroll_target_x

      Scroll target destination, X coord.


   .. py:attribute:: scroll_target_y

      Scroll target destination, Y coord.


   .. py:attribute:: show_vertical_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a vertical scrollbar?


   .. py:attribute:: show_horizontal_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a horizontal scrollbar?


   .. py:attribute:: border_title

      A title to show in the top border (if there is one).


   .. py:attribute:: border_subtitle

      A title to show in the bottom border (if there is one).


   .. py:attribute:: sort_order
      :value: 0



   .. py:attribute:: highlight_style
      :type:  rich.style.Style | None
      :value: None



   .. py:attribute:: absolute_offset
      :type:  textual.geometry.Offset | None
      :value: None


      Force an absolute offset for the widget (used by tooltips).


   .. py:attribute:: lock

      `asyncio` lock to be used to synchronize the state of the widget.

      Two different tasks might call methods on a widget at the same time, which
      might result in a race condition.
      This can be fixed by adding `async with widget.lock:` around the method calls.


   .. py:property:: is_mounted
      :type: bool


      Check if this widget is mounted.


   .. py:property:: siblings
      :type: list[Widget]


      Get the widget's siblings (self is removed from the return list).

      :returns: A list of siblings.


   .. py:property:: visible_siblings
      :type: list[Widget]


      A list of siblings which will be shown.

      :returns: List of siblings.


   .. py:property:: allow_vertical_scroll
      :type: bool


      Check if vertical scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_horizontal_scroll
      :type: bool


      Check if horizontal scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_maximize
      :type: bool


      Check if the widget may be maximized.

      :returns: `True` if the widget may be maximized, or `False` if it should not be maximized.


   .. py:property:: offset
      :type: textual.geometry.Offset


      Widget offset from origin.

      :returns: Relative offset.


   .. py:property:: opacity
      :type: float


      Total opacity of widget.


   .. py:property:: is_anchored
      :type: bool


      Is this widget anchored?

      See [anchor()][textual.widget.Widget.anchor] for an explanation of anchoring.


   .. py:property:: is_mouse_over
      :type: bool


      Is the mouse currently over this widget?

      Note this will be `True` if the mouse pointer is within the widget's region, even if
      the mouse pointer is not directly over the widget (there could be another widget between
      the mouse pointer and self).


   .. py:property:: is_maximized
      :type: bool


      Is this widget maximized?


   .. py:property:: is_in_maximized_view
      :type: bool


      Is this widget, or a parent maximized?


   .. py:property:: text_selection
      :type: textual.selection.Selection | None


      Text selection information, or `None` if no text is selected in this widget.


   .. py:method:: focus_on_click() -> bool

      Automatically focus the widget on click?

      Implement this if you want to change the default click to focus behavior.
      The default will return the classvar `FOCUS_ON_CLICK`.

      :returns: `True` if Textual should set focus automatically on a click, or `False` if it shouldn't.



   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get the line filters enabled for this widget.

      :returns: A sequence of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: preflight_checks() -> None

      Called in debug mode to do preflight checks.

      This is used by Textual to log some common errors, but you could implement this
      in custom widgets to perform additional checks.




   .. py:method:: pre_render() -> None

      Called prior to rendering.

      If you implement this in a subclass, be sure to call the base class method via super.




   .. py:method:: process_layout(placements: list[textual.layout.WidgetPlacement]) -> list[textual.layout.WidgetPlacement]

      A hook to allow for the manipulation of widget placements before rendering.

      You could use this as a way to modify the positions / margins of widgets if your requirement is
      not supported in TCSS. In practice, this method is rarely needed!

      :param placements: A list of [`WidgetPlacement`][textual.layout.WidgetPlacement] objects.

      :returns: A new list of placements.



   .. py:method:: anchor(anchor: bool = True) -> None

      Anchor a scrollable widget.

      An anchored widget will stay scrolled the bottom when new content is added, until
      the user moves the scroll position.

      :param anchor: Anchor the widget if `True`, clear the anchor if `False`.



   .. py:method:: release_anchor() -> None

      Release the [anchor][textual.widget.Widget].

      If a widget is anchored, releasing the anchor will allow the user to scroll as normal.




   .. py:property:: tooltip
      :type: textual.visual.VisualType | None


      Tooltip for the widget, or `None` for no tooltip.


   .. py:method:: with_tooltip(tooltip: textual.visual.Visual | rich.console.RenderableType | None) -> typing_extensions.Self

      Chainable method to set a tooltip.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Label("Hello").with_tooltip("A greeting")
      ```

      :param tooltip: New tooltip, or `None` to clear the tooltip.

      :returns: Self.



   .. py:method:: allow_focus() -> bool

      Check if the widget is permitted to focus.

      The base class returns [`can_focus`][textual.widget.Widget.can_focus].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget may be focused, or `False` if it may not be focused.



   .. py:method:: allow_focus_children() -> bool

      Check if a widget's children may be focused.

      The base class returns [`can_focus_children`][textual.widget.Widget.can_focus_children].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget's children may be focused, or `False` if the widget's children may not be focused.



   .. py:method:: compose_add_child(widget: Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: is_disabled
      :type: bool


      Is the widget disabled either because `disabled=True` or an ancestor has `disabled=True`.


   .. py:property:: has_focus_within
      :type: bool


      Are any descendants focused?


   .. py:property:: first_of_type
      :type: bool


      Is this the first widget of its type in its siblings?


   .. py:property:: last_of_type
      :type: bool


      Is this the last widget of its type in its siblings?


   .. py:property:: first_child
      :type: bool


      Is this the first widget in its siblings?


   .. py:property:: last_child
      :type: bool


      Is this the last widget in its siblings?


   .. py:property:: is_odd
      :type: bool


      Is this widget at an oddly numbered position within its siblings?


   .. py:property:: is_even
      :type: bool


      Is this widget at an evenly numbered position within its siblings?


   .. py:method:: __enter__() -> typing_extensions.Self

      Use as context manager when composing.



   .. py:method:: __exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None

      Exit compose context manager.



   .. py:method:: clear_cached_dimensions() -> None

      Clear cached results of `get_content_width` and `get_content_height`.

      Call if the widget's renderable changes size after the widget has been created.

      !!! note

          This is not required if you are extending [`Static`][textual.widgets.Static].




   .. py:method:: get_loading_widget() -> Widget

      Get a widget to display a loading indicator.

      The default implementation will defer to App.get_loading_widget.

      :returns: A widget in place of this widget to indicate a loading.



   .. py:method:: set_loading(loading: bool) -> None

      Set or reset the loading state of this widget.

      A widget in a loading state will display a `LoadingIndicator` or a custom widget
      set through overriding the `get_loading_widget` method.

      :param loading: `True` to put the widget into a loading state, or `False` to reset the loading state.



   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> Widget

      Return the first child (immediate descendent) of this node with the given ID.

      :param id: The ID of the child.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first child of this node with the ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> Widget

      Return the first descendant widget with the given ID.

      Performs a depth-first search rooted at this widget.

      :param id: The ID to search for in the subtree.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID.
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get the first immediate child of a given type.

      Only returns exact matches, and so will not match subclasses of the given type.

      :param expect_type: The type of the child to search for.

      :raises NoMatches: If no matching child is found.

      :returns: The first immediate child widget with the expected type.



   .. py:method:: get_component_rich_style(*names: str, partial: bool = False) -> rich.style.Style

      Get a *Rich* style for a component.

      :param names: Names of components.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Rich style object.



   .. py:method:: get_visual_style(*component_classes: str, partial: bool = False) -> textual.style.Style

      Get the visual style for the widget, including any component styles.

      :param component_classes: Optional component styles.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Visual style instance.



   .. py:method:: render_str(text_content: str) -> textual.content.Content
                  render_str(text_content: textual.content.Content) -> textual.content.Content

      Convert str into a [Content][textual.content.Content] instance.

      If you pass in an existing Content instance it will be returned unaltered.

      :param text_content: Content or str.

      :returns: Content object.



   .. py:method:: arrange(size: textual.geometry.Size, optimal: bool = False) -> textual._arrange.DockArrangeResult

      Arrange child widgets.

      This method is best left alone, unless you have a deep understanding of what it does.

      :param size: Size of container.
      :param optimal: Whether fr units should expand the widget (`False`) or avoid expanding the widget (`True`).

      :returns: Widget locations.



   .. py:method:: mount(*widgets: Widget, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets below this widget (making this widget a container).

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of ``before`` or ``after`` can be provided. If both are
         provided a ``MountError`` will be raised.



   .. py:method:: mount_all(widgets: Iterable[Widget], *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_compose(compose_result: textual.app.ComposeResult, *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from the result of a compose method.

      Example:
      ```python
          def on_key(self, event:events.Key) -> None:

              def add_key(key:str) -> ComposeResult:
                  '''Compose key information widgets'''
                  with containers.HorizontalGroup():
                      yield Label("You pressed:")
                      yield Label(key)

              self.mount_compose(add_key(event.key))

      ```

      :param compose_result: The result of a compose method.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: move_child(child: int | Widget, *, before: int | Widget, after: None = None) -> None

      Move a child widget within its parent's list of children.

      :param child: The child widget to move.
      :param before: Child widget or location index to move before.
      :param after: Child widget or location index to move after.

      :raises WidgetError: If there is a problem with the child or target.

      .. note::

         Only one of `before` or `after` can be provided. If neither
         or both are provided a `WidgetError` will be raised.



   .. py:method:: compose() -> textual.app.ComposeResult

      Called by Textual to create child widgets.

      This method is called when a widget is mounted or by setting `recompose=True` when
      calling [`refresh()`][textual.widget.Widget.refresh].

      Note that you don't typically need to explicitly call this method.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Header()
          yield Label("Press the button below:")
          yield Button()
          yield Footer()
      ```



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: get_content_width(container: textual.geometry.Size, viewport: textual.geometry.Size) -> int

      Called by textual to get the width of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.

      :returns: The optimal width of the content.



   .. py:method:: get_content_height(container: textual.geometry.Size, viewport: textual.geometry.Size, width: int) -> int

      Called by Textual to get the height of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.
      :param width: Width of renderable.

      :returns: The height of the content.



   .. py:method:: watch_hover_style(previous_hover_style: rich.style.Style, hover_style: rich.style.Style) -> None


   .. py:method:: watch_scroll_x(old_value: float, new_value: float) -> None


   .. py:method:: watch_scroll_y(old_value: float, new_value: float) -> None


   .. py:method:: validate_scroll_x(value: float) -> float


   .. py:method:: validate_scroll_target_x(value: float) -> float


   .. py:method:: validate_scroll_y(value: float) -> float


   .. py:method:: validate_scroll_target_y(value: float) -> float


   .. py:property:: max_scroll_x
      :type: int


      The maximum value of `scroll_x`.


   .. py:property:: max_scroll_y
      :type: int


      The maximum value of `scroll_y`.


   .. py:property:: is_vertical_scroll_end
      :type: bool


      Is the vertical scroll position at the maximum?


   .. py:property:: is_horizontal_scroll_end
      :type: bool


      Is the horizontal scroll position at the maximum?


   .. py:property:: is_vertical_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: is_horizontal_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: scrollbar_corner
      :type: textual.scrollbar.ScrollBarCorner


      The scrollbar corner.

      .. note:: This will *create* a scrollbar corner if one doesn't exist.

      :returns: ScrollBarCorner Widget.


   .. py:property:: vertical_scrollbar
      :type: textual.scrollbar.ScrollBar


      The vertical scrollbar (create if necessary).

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: horizontal_scrollbar
      :type: textual.scrollbar.ScrollBar


      The horizontal scrollbar.

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: scrollbars_enabled
      :type: tuple[bool, bool]


      A tuple of booleans that indicate if scrollbars are enabled.

      :returns: A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)


   .. py:property:: scrollbars_space
      :type: tuple[int, int]


      The number of cells occupied by scrollbars for width and height


   .. py:property:: scrollbar_size_vertical
      :type: int


      Get the width used by the *vertical* scrollbar.

      :returns: Number of columns in the vertical scrollbar.


   .. py:property:: scrollbar_size_horizontal
      :type: int


      Get the height used by the *horizontal* scrollbar.

      :returns: Number of rows in the horizontal scrollbar.


   .. py:property:: scrollbar_gutter
      :type: textual.geometry.Spacing


      Spacing required to fit scrollbar(s).

      :returns: Scrollbar gutter spacing.


   .. py:property:: gutter
      :type: textual.geometry.Spacing


      Spacing for padding / border / scrollbars.

      :returns: Additional spacing around content area.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: scrollable_size
      :type: textual.geometry.Size


      The size of the scrollable content.

      :returns: Scrollable content size.


   .. py:property:: outer_size
      :type: textual.geometry.Size


      The size of the widget (including padding and border).

      :returns: Outer size.


   .. py:property:: container_size
      :type: textual.geometry.Size


      The size of the container (parent widget).

      :returns: Container size.


   .. py:property:: content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the content (minus padding and border).

      :returns: Screen region that contains a widget's content.


   .. py:property:: scrollable_content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the scrollable content (minus padding, border, and scrollbars).

      :returns: Screen region that contains a widget's content.


   .. py:property:: content_offset
      :type: textual.geometry.Offset


      An offset from the Widget origin where the content begins.

      :returns: Offset from widget's origin.


   .. py:property:: content_size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: region
      :type: textual.geometry.Region


      The region occupied by this widget, relative to the Screen.

      :raises NoScreen: If there is no screen.
      :raises errors.NoWidget: If the widget is not on the screen.

      :returns: Region within screen occupied by widget.


   .. py:property:: dock_gutter
      :type: textual.geometry.Spacing


      Space allocated to docks in the parent.

      :returns: Space to be subtracted from scrollable area.


   .. py:property:: container_viewport
      :type: textual.geometry.Region


      The viewport region (parent window).

      :returns: The region that contains this widget.


   .. py:property:: virtual_region
      :type: textual.geometry.Region


      The widget region relative to its container (which may not be visible,
      depending on scroll offset).


      :returns: The virtual region.


   .. py:property:: window_region
      :type: textual.geometry.Region


      The region within the scrollable area that is currently visible.

      :returns: New region.


   .. py:property:: virtual_region_with_margin
      :type: textual.geometry.Region


      The widget region relative to its container (*including margin*), which may not be visible,
      depending on the scroll offset.

      :returns: The virtual region of the Widget, inclusive of its margin.


   .. py:property:: focusable
      :type: bool


      Can this widget currently be focused?


   .. py:property:: scroll_offset
      :type: textual.geometry.Offset


      Get the current scroll offset.

      :returns: Offset a container has been scrolled by.


   .. py:property:: container_scroll_offset
      :type: textual.geometry.Offset


      The scroll offset the nearest container ancestor.


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation. Defaults to `value` if not set.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: layout
      :type: textual.layout.Layout


      Get the layout object if set in styles, or a default layout.

      :returns: A layout object.


   .. py:property:: is_container
      :type: bool


      Is this widget a container (contains other widgets)?


   .. py:property:: is_scrollable
      :type: bool


      Can this widget be scrolled?


   .. py:property:: is_scrolling
      :type: bool


      Is this widget currently scrolling?


   .. py:property:: layer
      :type: str


      Get the name of this widgets layer.

      :returns: Name of layer.


   .. py:property:: layers
      :type: tuple[str, Ellipsis]


      Layers of from parent.

      :returns: Tuple of layer names.


   .. py:property:: link_style
      :type: rich.style.Style


      Style of links.

      :returns: Rich style.


   .. py:property:: link_style_hover
      :type: rich.style.Style


      Style of links underneath the mouse cursor.

      :returns: Rich Style.


   .. py:property:: select_container
      :type: Widget


      The widget's container used when selecting text..

      :returns: A widget which contains this widget.


   .. py:property:: allow_select
      :type: bool


      Check if this widget permits text selection.

      :returns: `True` if the widget supports text selection, otherwise `False`.


   .. py:method:: pre_layout(layout: textual.layout.Layout) -> None

      This method id called prior to a layout operation.

      Implement this method if you want to make updates that should impact
      the layout.

      :param layout: The [Layout][textual.layout.Layout] instance that will be used to arrange this widget's children.



   .. py:method:: set_scroll(x: float | None, y: float | None) -> None

      Set the scroll position without any validation.

      This is a low-level method for when you want to see the scroll position in the next frame.
      For a more fully featured method, see [`scroll_to`][textual.widget.Widget.scroll_to].

      :param x: Desired `X` coordinate.
      :param y: Desired `Y` coordinate.



   .. py:method:: scroll_to(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, release_anchor: bool = True) -> None

      Scroll to a given (absolute) coordinate, optionally animating.

      :param x: X coordinate (column) to scroll to, or `None` for no change.
      :param y: Y coordinate (row) to scroll to, or `None` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param release_anchor: If `True` call `release_anchor`.

      .. note:: The call to scroll is made after the next refresh.



   .. py:method:: scroll_relative(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll relative to current position.

      :param x: X distance (columns) to scroll, or ``None`` for no change.
      :param y: Y distance (rows) to scroll, or ``None`` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`. Or `None` to use `duration`.
      :param duration: Duration of animation, if animate is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_home(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to home position.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use duration.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_end(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to the end of the container.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_page_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_to_widget(widget: Widget, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> bool

      Scroll scrolling to bring a widget into view.

      :param widget: A descendant widget.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll widget to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: `True` if any scrolling has occurred in any descendant, otherwise `False`.



   .. py:method:: scroll_to_region(region: textual.geometry.Region, *, spacing: textual.geometry.Spacing | None = None, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', x_axis: bool = True, y_axis: bool = True, immediate: bool = False) -> textual.geometry.Offset

      Scrolls a given region into view, if required.

      This method will scroll the least distance required to move `region` fully within
      the scrollable area.

      :param region: A region that should be visible.
      :param spacing: Optional spacing around the region.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll `region` to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: The distance that was scrolled.



   .. py:method:: scroll_visible(animate: bool = True, *, speed: float | None = None, duration: float | None = None, top: bool = False, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll the container to make this widget visible.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param top: Scroll to top of container.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_to_center(widget: Widget, animate: bool = True, *, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, origin_visible: bool = True, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll this widget to the center of self.

      The center of the widget will be scrolled to the center of the container.

      :param widget: The widget to scroll to the center of self.
      :param animate: Whether to animate the scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param origin_visible: Ensure that the top left corner of the widget remains visible after the scroll.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: can_view_entire(widget: Widget) -> bool

      Check if a given widget is *fully* within the current view (scrollable area).

      Note: This doesn't necessarily equate to a widget being visible.
      There are other reasons why a widget may not be visible.

      :param widget: A widget that is a descendant of self.

      :returns: `True` if the entire widget is in view, `False` if it is partially visible or not in view.



   .. py:method:: can_view_partial(widget: Widget) -> bool

      Check if a given widget at least partially visible within the current view (scrollable area).

      :param widget: A widget that is a descendant of self.

      :returns: `True` if any part of the widget is visible, `False` if it is outside of the viewable area.



   .. py:method:: __init_subclass__(can_focus: bool | None = None, can_focus_children: bool | None = None, inherit_css: bool = True, inherit_bindings: bool = True) -> None
      :classmethod:



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:method:: get_pseudo_class_state() -> PseudoClasses

      Get an object describing whether each pseudo class is present on this object or not.

      :returns: A PseudoClasses object describing the pseudo classes that are present.



   .. py:method:: post_render(renderable: rich.console.RenderableType, base_style: rich.style.Style) -> rich.console.ConsoleRenderable

      Applies style attributes to the default renderable.

      This method is called by Textual itself.
      It is unlikely you will need to call or implement this method.

      :returns: A new renderable.



   .. py:method:: watch_has_focus(_has_focus: bool) -> None

      Update from CSS if has focus state changes.



   .. py:method:: watch_disabled(disabled: bool) -> None

      Update the styles of the widget and its children when disabled is toggled.



   .. py:property:: visual_style
      :type: textual.style.Style



   .. py:method:: get_selection(selection: textual.selection.Selection) -> tuple[str, str] | None

      Get the text under the selection.

              Args:
                  selection: Selection information.

              Returns:
                  Tuple of extracted text and ending (typically "
      " or " "), or `None` if no text could be extracted.




   .. py:method:: selection_updated(selection: textual.selection.Selection | None) -> None

      Called when the selection is updated.

      :param selection: Selection information or `None` if no selection.



   .. py:method:: render_line(y: int) -> textual.strip.Strip

      Render a line of content.

      :param y: Y Coordinate of line.

      :returns: A rendered line.



   .. py:method:: render_lines(crop: textual.geometry.Region) -> list[textual.strip.Strip]

      Render the widget into lines.

      :param crop: Region within visible area to render.

      :returns: A list of list of segments.



   .. py:method:: get_style_at(x: int, y: int) -> rich.style.Style

      Get the Rich style in a widget at a given relative offset.

      :param x: X coordinate relative to the widget.
      :param y: Y coordinate relative to the widget.

      :returns: A rich Style object.



   .. py:method:: suppress_click() -> None

      Suppress a click event.

      This will prevent a [Click][textual.events.Click] event being sent,
      if called after a mouse down event and before the click itself.




   .. py:method:: refresh(*regions: textual.geometry.Region, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Initiate a refresh of the widget.

      This method sets an internal flag to perform a refresh, which will be done on the
      next idle event. Only one refresh will be done even if this method is called multiple times.

      By default this method will cause the content of the widget to refresh, but not change its size. You can also
      set `layout=True` to perform a layout.

      !!! warning

          It is rarely necessary to call this method explicitly. Updating styles or reactive attributes will
          do this automatically.

      :param \*regions: Additional screen regions to mark as dirty.
      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `Widget` instance.



   .. py:method:: remove() -> textual.await_remove.AwaitRemove

      Remove the Widget from the DOM (effectively deleting it).

      :returns: An awaitable object that waits for the widget to be removed.



   .. py:method:: remove_children(selector: str | type[textual.css.query.QueryType] | Iterable[Widget] = '*') -> textual.await_remove.AwaitRemove

      Remove the immediate children of this Widget from the DOM.

      :param selector: A CSS selector or iterable of widgets to remove.

      :returns: An awaitable object that waits for the direct children to be removed.



   .. py:method:: batch() -> AsyncGenerator[None, None]
      :async:


      Async context manager that combines widget locking and update batching.

      Use this async context manager whenever you want to acquire the widget lock and
      batch app updates at the same time.

      .. rubric:: Example

      ```py
      async with container.batch():
          await container.remove_children(Button)
          await container.mount(Label("All buttons are gone."))
      ```



   .. py:method:: run_action(action: str, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> None
      :async:


      Perform a given action, with this widget as the default namespace.

      :param action: Action encoded as a string.
      :param namespaces: Mapping of namespaces.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Post a message to this widget.

      :param message: Message to post.

      :returns: True if the message was posted, False if this widget was closed / closing.



   .. py:method:: on_prune(event: textual.messages.Prune) -> None
      :async:


      Close message loop when asked to prune.



   .. py:method:: focus(scroll_visible: bool = True) -> typing_extensions.Self

      Give focus to this widget.

      :param scroll_visible: Scroll parent to make this widget visible.

      :returns: The `Widget` instance.



   .. py:method:: blur() -> typing_extensions.Self

      Blur (un-focus) the widget.

      Focus will be moved to the next available widget in the focus chain.

      :returns: The `Widget` instance.



   .. py:method:: capture_mouse(capture: bool = True) -> None

      Capture (or release) the mouse.

      When captured, mouse events will go to this widget even when the pointer is not directly over the widget.

      :param capture: True to capture or False to release.



   .. py:method:: release_mouse() -> None

      Release the mouse.

      Mouse events will only be sent when the mouse is over the widget.



   .. py:method:: text_select_all() -> None

      Select the entire widget.



   .. py:method:: begin_capture_print(stdout: bool = True, stderr: bool = True) -> None

      Capture text from print statements (or writes to stdout / stderr).

      If printing is captured, the widget will be sent an [`events.Print`][textual.events.Print] message.

      Call [`end_capture_print`][textual.widget.Widget.end_capture_print] to disable print capture.

      :param stdout: Whether to capture stdout.
      :param stderr: Whether to capture stderr.



   .. py:method:: end_capture_print() -> None

      End print capture (set with [`begin_capture_print`][textual.widget.Widget.begin_capture_print]).



   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: broker_event(event_name: str, event: textual.events.Event) -> bool
      :async:



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:method:: handle_key(event: textual.events.Key) -> bool
      :async:



   .. py:method:: mount_composed_widgets(widgets: list[Widget]) -> None
      :async:


      Called by Textual to mount widgets after compose.

      There is generally no need to implement this method in your application.
      See [Lazy][textual.lazy.Lazy] for a class which uses this method to implement
      *lazy* mounting.

      :param widgets: A list of child widgets.



   .. py:method:: action_scroll_home() -> None


   .. py:method:: action_scroll_end() -> None


   .. py:method:: action_scroll_left() -> None


   .. py:method:: action_scroll_right() -> None


   .. py:method:: action_scroll_up() -> None


   .. py:method:: action_scroll_down() -> None


   .. py:method:: action_page_down() -> None


   .. py:method:: action_page_up() -> None


   .. py:method:: action_page_left() -> None


   .. py:method:: action_page_right() -> None


   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.

      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      See [`App.notify`][textual.app.App.notify] for the full
      documentation for this method.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information', markup: bool = True) -> None


   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Title of widget used where bindings are displayed (such as in the key panel).


   .. py:attribute:: BINDINGS
      :type:  ClassVar[list[textual.binding.BindingType]]
      :value: []


      A list of key bindings.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view on to the children.

      :returns: The node's children.


   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The app's worker manager. Shortcut for `self.app.workers`.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: screen
      :type: Screen[object]


      The screen containing this node.

      :returns: A screen object.

      :raises NoScreen: If this node isn't mounted (and has no screen).


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:property:: is_dom_root

      Is this a root node (i.e. the App)?


   .. py:attribute:: app


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:property:: log
      :type: textual.Logger


      Get a logger for this object.

      :returns: A logger.


   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:class:: ImageGrid(grid, **kwargs)

   Bases: :py:obj:`BaseGrid`


   Grid rendered using an image-based approach via rich-pixels (requires PIL and rich-pixels).


   .. py:method:: on_mount()


   .. py:method:: on_resize(event)

      Regenerate the image when the widget is resized to adjust scaling.



   .. py:attribute:: grid


   .. py:attribute:: rows


   .. py:attribute:: cols


   .. py:attribute:: DEFAULT_CSS
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
             Static {
                 height: auto;
             }
             """

      .. raw:: html

         </details>



      Default TCSS.


   .. py:attribute:: expand
      :value: False


      Rich renderable may expand beyond optimal size.


   .. py:attribute:: shrink
      :value: False


      Rich renderable may shrink below optimal size.


   .. py:property:: visual
      :type: textual.visual.Visual


      The visual to be displayed.

      Note that the visual is what is ultimately rendered in the widget, but may not be the
      same object set with the `update` method  or `content` property. For instance, if you
      update with a string, then the visual will be a [Content][textual.content.Content] instance.


   .. py:property:: content
      :type: textual.visual.VisualType


      The original content set in the constructor.


   .. py:method:: render() -> textual.app.RenderResult

      Get a rich renderable for the widget's content.

      :returns: A rich renderable.



   .. py:method:: update(content: textual.visual.VisualType = '', *, layout: bool = True) -> None

      Update the widget's content area with a string, a Visual (such as [Content][textual.content.Content]), or a [Rich renderable](https://rich.readthedocs.io/en/latest/protocol.html).

      :param content: New content.
      :param layout: Also perform a layout operation (set to `False` if you are certain the size won't change).



   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: BORDER_TITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_title attribute.


   .. py:attribute:: BORDER_SUBTITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_subtitle attribute.


   .. py:attribute:: ALLOW_MAXIMIZE
      :type:  ClassVar[bool | None]
      :value: None


      Defines default logic to allow the widget to be maximized.

      - `None` Use default behavior (Focusable widgets may be maximized)
      - `False` Do not allow widget to be maximized
      - `True` Allow widget to be maximized


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      Does this widget support automatic text selection? May be further refined with [Widget.allow_select][textual.widget.Widget.allow_select].


   .. py:attribute:: FOCUS_ON_CLICK
      :type:  ClassVar[bool]
      :value: True


      Should focusable widgets be automatically focused on click? Default return value of [Widget.focus_on_click][textual.widget.Widget.focus_on_click].


   .. py:attribute:: can_focus
      :type:  bool
      :value: False


      Widget may receive focus.


   .. py:attribute:: can_focus_children
      :type:  bool
      :value: True


      Widget's children may receive focus.


   .. py:attribute:: auto_links
      :type:  textual.reactive.Reactive[bool]

      Widget will highlight links automatically.


   .. py:attribute:: disabled
      :type:  textual.reactive.Reactive[bool]

      Is the widget disabled? Disabled widgets can not be interacted with, and are typically styled to look dimmer.


   .. py:attribute:: hover_style
      :type:  textual.reactive.Reactive[rich.style.Style]

      The current hover style (style under the mouse cursor). Read only.


   .. py:attribute:: highlight_link_id
      :type:  textual.reactive.Reactive[str]

      The currently highlighted link id. Read only.


   .. py:attribute:: loading
      :type:  textual.reactive.Reactive[bool]

      If set to `True` this widget will temporarily be replaced with a loading indicator.


   .. py:attribute:: virtual_size
      :type:  textual.reactive.Reactive[textual.geometry.Size]

      The virtual (scrollable) [size][textual.geometry.Size] of the widget.


   .. py:attribute:: has_focus
      :type:  textual.reactive.Reactive[bool]

      Does this widget have focus? Read only.


   .. py:attribute:: mouse_hover
      :type:  textual.reactive.Reactive[bool]

      Is the mouse over this widget? Read only.


   .. py:attribute:: scroll_x
      :type:  textual.reactive.Reactive[float]

      The scroll position on the X axis.


   .. py:attribute:: scroll_y
      :type:  textual.reactive.Reactive[float]

      The scroll position on the Y axis.


   .. py:attribute:: scroll_target_x

      Scroll target destination, X coord.


   .. py:attribute:: scroll_target_y

      Scroll target destination, Y coord.


   .. py:attribute:: show_vertical_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a vertical scrollbar?


   .. py:attribute:: show_horizontal_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a horizontal scrollbar?


   .. py:attribute:: border_title

      A title to show in the top border (if there is one).


   .. py:attribute:: border_subtitle

      A title to show in the bottom border (if there is one).


   .. py:attribute:: sort_order
      :value: 0



   .. py:attribute:: highlight_style
      :type:  rich.style.Style | None
      :value: None



   .. py:attribute:: absolute_offset
      :type:  textual.geometry.Offset | None
      :value: None


      Force an absolute offset for the widget (used by tooltips).


   .. py:attribute:: lock

      `asyncio` lock to be used to synchronize the state of the widget.

      Two different tasks might call methods on a widget at the same time, which
      might result in a race condition.
      This can be fixed by adding `async with widget.lock:` around the method calls.


   .. py:property:: is_mounted
      :type: bool


      Check if this widget is mounted.


   .. py:property:: siblings
      :type: list[Widget]


      Get the widget's siblings (self is removed from the return list).

      :returns: A list of siblings.


   .. py:property:: visible_siblings
      :type: list[Widget]


      A list of siblings which will be shown.

      :returns: List of siblings.


   .. py:property:: allow_vertical_scroll
      :type: bool


      Check if vertical scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_horizontal_scroll
      :type: bool


      Check if horizontal scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_maximize
      :type: bool


      Check if the widget may be maximized.

      :returns: `True` if the widget may be maximized, or `False` if it should not be maximized.


   .. py:property:: offset
      :type: textual.geometry.Offset


      Widget offset from origin.

      :returns: Relative offset.


   .. py:property:: opacity
      :type: float


      Total opacity of widget.


   .. py:property:: is_anchored
      :type: bool


      Is this widget anchored?

      See [anchor()][textual.widget.Widget.anchor] for an explanation of anchoring.


   .. py:property:: is_mouse_over
      :type: bool


      Is the mouse currently over this widget?

      Note this will be `True` if the mouse pointer is within the widget's region, even if
      the mouse pointer is not directly over the widget (there could be another widget between
      the mouse pointer and self).


   .. py:property:: is_maximized
      :type: bool


      Is this widget maximized?


   .. py:property:: is_in_maximized_view
      :type: bool


      Is this widget, or a parent maximized?


   .. py:property:: text_selection
      :type: textual.selection.Selection | None


      Text selection information, or `None` if no text is selected in this widget.


   .. py:method:: focus_on_click() -> bool

      Automatically focus the widget on click?

      Implement this if you want to change the default click to focus behavior.
      The default will return the classvar `FOCUS_ON_CLICK`.

      :returns: `True` if Textual should set focus automatically on a click, or `False` if it shouldn't.



   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get the line filters enabled for this widget.

      :returns: A sequence of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: preflight_checks() -> None

      Called in debug mode to do preflight checks.

      This is used by Textual to log some common errors, but you could implement this
      in custom widgets to perform additional checks.




   .. py:method:: pre_render() -> None

      Called prior to rendering.

      If you implement this in a subclass, be sure to call the base class method via super.




   .. py:method:: process_layout(placements: list[textual.layout.WidgetPlacement]) -> list[textual.layout.WidgetPlacement]

      A hook to allow for the manipulation of widget placements before rendering.

      You could use this as a way to modify the positions / margins of widgets if your requirement is
      not supported in TCSS. In practice, this method is rarely needed!

      :param placements: A list of [`WidgetPlacement`][textual.layout.WidgetPlacement] objects.

      :returns: A new list of placements.



   .. py:method:: anchor(anchor: bool = True) -> None

      Anchor a scrollable widget.

      An anchored widget will stay scrolled the bottom when new content is added, until
      the user moves the scroll position.

      :param anchor: Anchor the widget if `True`, clear the anchor if `False`.



   .. py:method:: release_anchor() -> None

      Release the [anchor][textual.widget.Widget].

      If a widget is anchored, releasing the anchor will allow the user to scroll as normal.




   .. py:property:: tooltip
      :type: textual.visual.VisualType | None


      Tooltip for the widget, or `None` for no tooltip.


   .. py:method:: with_tooltip(tooltip: textual.visual.Visual | rich.console.RenderableType | None) -> typing_extensions.Self

      Chainable method to set a tooltip.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Label("Hello").with_tooltip("A greeting")
      ```

      :param tooltip: New tooltip, or `None` to clear the tooltip.

      :returns: Self.



   .. py:method:: allow_focus() -> bool

      Check if the widget is permitted to focus.

      The base class returns [`can_focus`][textual.widget.Widget.can_focus].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget may be focused, or `False` if it may not be focused.



   .. py:method:: allow_focus_children() -> bool

      Check if a widget's children may be focused.

      The base class returns [`can_focus_children`][textual.widget.Widget.can_focus_children].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget's children may be focused, or `False` if the widget's children may not be focused.



   .. py:method:: compose_add_child(widget: Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: is_disabled
      :type: bool


      Is the widget disabled either because `disabled=True` or an ancestor has `disabled=True`.


   .. py:property:: has_focus_within
      :type: bool


      Are any descendants focused?


   .. py:property:: first_of_type
      :type: bool


      Is this the first widget of its type in its siblings?


   .. py:property:: last_of_type
      :type: bool


      Is this the last widget of its type in its siblings?


   .. py:property:: first_child
      :type: bool


      Is this the first widget in its siblings?


   .. py:property:: last_child
      :type: bool


      Is this the last widget in its siblings?


   .. py:property:: is_odd
      :type: bool


      Is this widget at an oddly numbered position within its siblings?


   .. py:property:: is_even
      :type: bool


      Is this widget at an evenly numbered position within its siblings?


   .. py:method:: __enter__() -> typing_extensions.Self

      Use as context manager when composing.



   .. py:method:: __exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None

      Exit compose context manager.



   .. py:method:: clear_cached_dimensions() -> None

      Clear cached results of `get_content_width` and `get_content_height`.

      Call if the widget's renderable changes size after the widget has been created.

      !!! note

          This is not required if you are extending [`Static`][textual.widgets.Static].




   .. py:method:: get_loading_widget() -> Widget

      Get a widget to display a loading indicator.

      The default implementation will defer to App.get_loading_widget.

      :returns: A widget in place of this widget to indicate a loading.



   .. py:method:: set_loading(loading: bool) -> None

      Set or reset the loading state of this widget.

      A widget in a loading state will display a `LoadingIndicator` or a custom widget
      set through overriding the `get_loading_widget` method.

      :param loading: `True` to put the widget into a loading state, or `False` to reset the loading state.



   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> Widget

      Return the first child (immediate descendent) of this node with the given ID.

      :param id: The ID of the child.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first child of this node with the ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> Widget

      Return the first descendant widget with the given ID.

      Performs a depth-first search rooted at this widget.

      :param id: The ID to search for in the subtree.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID.
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get the first immediate child of a given type.

      Only returns exact matches, and so will not match subclasses of the given type.

      :param expect_type: The type of the child to search for.

      :raises NoMatches: If no matching child is found.

      :returns: The first immediate child widget with the expected type.



   .. py:method:: get_component_rich_style(*names: str, partial: bool = False) -> rich.style.Style

      Get a *Rich* style for a component.

      :param names: Names of components.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Rich style object.



   .. py:method:: get_visual_style(*component_classes: str, partial: bool = False) -> textual.style.Style

      Get the visual style for the widget, including any component styles.

      :param component_classes: Optional component styles.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Visual style instance.



   .. py:method:: render_str(text_content: str) -> textual.content.Content
                  render_str(text_content: textual.content.Content) -> textual.content.Content

      Convert str into a [Content][textual.content.Content] instance.

      If you pass in an existing Content instance it will be returned unaltered.

      :param text_content: Content or str.

      :returns: Content object.



   .. py:method:: arrange(size: textual.geometry.Size, optimal: bool = False) -> textual._arrange.DockArrangeResult

      Arrange child widgets.

      This method is best left alone, unless you have a deep understanding of what it does.

      :param size: Size of container.
      :param optimal: Whether fr units should expand the widget (`False`) or avoid expanding the widget (`True`).

      :returns: Widget locations.



   .. py:method:: mount(*widgets: Widget, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets below this widget (making this widget a container).

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of ``before`` or ``after`` can be provided. If both are
         provided a ``MountError`` will be raised.



   .. py:method:: mount_all(widgets: Iterable[Widget], *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_compose(compose_result: textual.app.ComposeResult, *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from the result of a compose method.

      Example:
      ```python
          def on_key(self, event:events.Key) -> None:

              def add_key(key:str) -> ComposeResult:
                  '''Compose key information widgets'''
                  with containers.HorizontalGroup():
                      yield Label("You pressed:")
                      yield Label(key)

              self.mount_compose(add_key(event.key))

      ```

      :param compose_result: The result of a compose method.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: move_child(child: int | Widget, *, before: int | Widget, after: None = None) -> None

      Move a child widget within its parent's list of children.

      :param child: The child widget to move.
      :param before: Child widget or location index to move before.
      :param after: Child widget or location index to move after.

      :raises WidgetError: If there is a problem with the child or target.

      .. note::

         Only one of `before` or `after` can be provided. If neither
         or both are provided a `WidgetError` will be raised.



   .. py:method:: compose() -> textual.app.ComposeResult

      Called by Textual to create child widgets.

      This method is called when a widget is mounted or by setting `recompose=True` when
      calling [`refresh()`][textual.widget.Widget.refresh].

      Note that you don't typically need to explicitly call this method.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Header()
          yield Label("Press the button below:")
          yield Button()
          yield Footer()
      ```



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: get_content_width(container: textual.geometry.Size, viewport: textual.geometry.Size) -> int

      Called by textual to get the width of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.

      :returns: The optimal width of the content.



   .. py:method:: get_content_height(container: textual.geometry.Size, viewport: textual.geometry.Size, width: int) -> int

      Called by Textual to get the height of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.
      :param width: Width of renderable.

      :returns: The height of the content.



   .. py:method:: watch_hover_style(previous_hover_style: rich.style.Style, hover_style: rich.style.Style) -> None


   .. py:method:: watch_scroll_x(old_value: float, new_value: float) -> None


   .. py:method:: watch_scroll_y(old_value: float, new_value: float) -> None


   .. py:method:: validate_scroll_x(value: float) -> float


   .. py:method:: validate_scroll_target_x(value: float) -> float


   .. py:method:: validate_scroll_y(value: float) -> float


   .. py:method:: validate_scroll_target_y(value: float) -> float


   .. py:property:: max_scroll_x
      :type: int


      The maximum value of `scroll_x`.


   .. py:property:: max_scroll_y
      :type: int


      The maximum value of `scroll_y`.


   .. py:property:: is_vertical_scroll_end
      :type: bool


      Is the vertical scroll position at the maximum?


   .. py:property:: is_horizontal_scroll_end
      :type: bool


      Is the horizontal scroll position at the maximum?


   .. py:property:: is_vertical_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: is_horizontal_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: scrollbar_corner
      :type: textual.scrollbar.ScrollBarCorner


      The scrollbar corner.

      .. note:: This will *create* a scrollbar corner if one doesn't exist.

      :returns: ScrollBarCorner Widget.


   .. py:property:: vertical_scrollbar
      :type: textual.scrollbar.ScrollBar


      The vertical scrollbar (create if necessary).

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: horizontal_scrollbar
      :type: textual.scrollbar.ScrollBar


      The horizontal scrollbar.

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: scrollbars_enabled
      :type: tuple[bool, bool]


      A tuple of booleans that indicate if scrollbars are enabled.

      :returns: A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)


   .. py:property:: scrollbars_space
      :type: tuple[int, int]


      The number of cells occupied by scrollbars for width and height


   .. py:property:: scrollbar_size_vertical
      :type: int


      Get the width used by the *vertical* scrollbar.

      :returns: Number of columns in the vertical scrollbar.


   .. py:property:: scrollbar_size_horizontal
      :type: int


      Get the height used by the *horizontal* scrollbar.

      :returns: Number of rows in the horizontal scrollbar.


   .. py:property:: scrollbar_gutter
      :type: textual.geometry.Spacing


      Spacing required to fit scrollbar(s).

      :returns: Scrollbar gutter spacing.


   .. py:property:: gutter
      :type: textual.geometry.Spacing


      Spacing for padding / border / scrollbars.

      :returns: Additional spacing around content area.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: scrollable_size
      :type: textual.geometry.Size


      The size of the scrollable content.

      :returns: Scrollable content size.


   .. py:property:: outer_size
      :type: textual.geometry.Size


      The size of the widget (including padding and border).

      :returns: Outer size.


   .. py:property:: container_size
      :type: textual.geometry.Size


      The size of the container (parent widget).

      :returns: Container size.


   .. py:property:: content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the content (minus padding and border).

      :returns: Screen region that contains a widget's content.


   .. py:property:: scrollable_content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the scrollable content (minus padding, border, and scrollbars).

      :returns: Screen region that contains a widget's content.


   .. py:property:: content_offset
      :type: textual.geometry.Offset


      An offset from the Widget origin where the content begins.

      :returns: Offset from widget's origin.


   .. py:property:: content_size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: region
      :type: textual.geometry.Region


      The region occupied by this widget, relative to the Screen.

      :raises NoScreen: If there is no screen.
      :raises errors.NoWidget: If the widget is not on the screen.

      :returns: Region within screen occupied by widget.


   .. py:property:: dock_gutter
      :type: textual.geometry.Spacing


      Space allocated to docks in the parent.

      :returns: Space to be subtracted from scrollable area.


   .. py:property:: container_viewport
      :type: textual.geometry.Region


      The viewport region (parent window).

      :returns: The region that contains this widget.


   .. py:property:: virtual_region
      :type: textual.geometry.Region


      The widget region relative to its container (which may not be visible,
      depending on scroll offset).


      :returns: The virtual region.


   .. py:property:: window_region
      :type: textual.geometry.Region


      The region within the scrollable area that is currently visible.

      :returns: New region.


   .. py:property:: virtual_region_with_margin
      :type: textual.geometry.Region


      The widget region relative to its container (*including margin*), which may not be visible,
      depending on the scroll offset.

      :returns: The virtual region of the Widget, inclusive of its margin.


   .. py:property:: focusable
      :type: bool


      Can this widget currently be focused?


   .. py:property:: scroll_offset
      :type: textual.geometry.Offset


      Get the current scroll offset.

      :returns: Offset a container has been scrolled by.


   .. py:property:: container_scroll_offset
      :type: textual.geometry.Offset


      The scroll offset the nearest container ancestor.


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation. Defaults to `value` if not set.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: layout
      :type: textual.layout.Layout


      Get the layout object if set in styles, or a default layout.

      :returns: A layout object.


   .. py:property:: is_container
      :type: bool


      Is this widget a container (contains other widgets)?


   .. py:property:: is_scrollable
      :type: bool


      Can this widget be scrolled?


   .. py:property:: is_scrolling
      :type: bool


      Is this widget currently scrolling?


   .. py:property:: layer
      :type: str


      Get the name of this widgets layer.

      :returns: Name of layer.


   .. py:property:: layers
      :type: tuple[str, Ellipsis]


      Layers of from parent.

      :returns: Tuple of layer names.


   .. py:property:: link_style
      :type: rich.style.Style


      Style of links.

      :returns: Rich style.


   .. py:property:: link_style_hover
      :type: rich.style.Style


      Style of links underneath the mouse cursor.

      :returns: Rich Style.


   .. py:property:: select_container
      :type: Widget


      The widget's container used when selecting text..

      :returns: A widget which contains this widget.


   .. py:property:: allow_select
      :type: bool


      Check if this widget permits text selection.

      :returns: `True` if the widget supports text selection, otherwise `False`.


   .. py:method:: pre_layout(layout: textual.layout.Layout) -> None

      This method id called prior to a layout operation.

      Implement this method if you want to make updates that should impact
      the layout.

      :param layout: The [Layout][textual.layout.Layout] instance that will be used to arrange this widget's children.



   .. py:method:: set_scroll(x: float | None, y: float | None) -> None

      Set the scroll position without any validation.

      This is a low-level method for when you want to see the scroll position in the next frame.
      For a more fully featured method, see [`scroll_to`][textual.widget.Widget.scroll_to].

      :param x: Desired `X` coordinate.
      :param y: Desired `Y` coordinate.



   .. py:method:: scroll_to(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, release_anchor: bool = True) -> None

      Scroll to a given (absolute) coordinate, optionally animating.

      :param x: X coordinate (column) to scroll to, or `None` for no change.
      :param y: Y coordinate (row) to scroll to, or `None` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param release_anchor: If `True` call `release_anchor`.

      .. note:: The call to scroll is made after the next refresh.



   .. py:method:: scroll_relative(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll relative to current position.

      :param x: X distance (columns) to scroll, or ``None`` for no change.
      :param y: Y distance (rows) to scroll, or ``None`` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`. Or `None` to use `duration`.
      :param duration: Duration of animation, if animate is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_home(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to home position.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use duration.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_end(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to the end of the container.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_page_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_to_widget(widget: Widget, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> bool

      Scroll scrolling to bring a widget into view.

      :param widget: A descendant widget.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll widget to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: `True` if any scrolling has occurred in any descendant, otherwise `False`.



   .. py:method:: scroll_to_region(region: textual.geometry.Region, *, spacing: textual.geometry.Spacing | None = None, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', x_axis: bool = True, y_axis: bool = True, immediate: bool = False) -> textual.geometry.Offset

      Scrolls a given region into view, if required.

      This method will scroll the least distance required to move `region` fully within
      the scrollable area.

      :param region: A region that should be visible.
      :param spacing: Optional spacing around the region.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll `region` to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: The distance that was scrolled.



   .. py:method:: scroll_visible(animate: bool = True, *, speed: float | None = None, duration: float | None = None, top: bool = False, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll the container to make this widget visible.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param top: Scroll to top of container.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_to_center(widget: Widget, animate: bool = True, *, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, origin_visible: bool = True, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll this widget to the center of self.

      The center of the widget will be scrolled to the center of the container.

      :param widget: The widget to scroll to the center of self.
      :param animate: Whether to animate the scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param origin_visible: Ensure that the top left corner of the widget remains visible after the scroll.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: can_view_entire(widget: Widget) -> bool

      Check if a given widget is *fully* within the current view (scrollable area).

      Note: This doesn't necessarily equate to a widget being visible.
      There are other reasons why a widget may not be visible.

      :param widget: A widget that is a descendant of self.

      :returns: `True` if the entire widget is in view, `False` if it is partially visible or not in view.



   .. py:method:: can_view_partial(widget: Widget) -> bool

      Check if a given widget at least partially visible within the current view (scrollable area).

      :param widget: A widget that is a descendant of self.

      :returns: `True` if any part of the widget is visible, `False` if it is outside of the viewable area.



   .. py:method:: __init_subclass__(can_focus: bool | None = None, can_focus_children: bool | None = None, inherit_css: bool = True, inherit_bindings: bool = True) -> None
      :classmethod:



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:method:: get_pseudo_class_state() -> PseudoClasses

      Get an object describing whether each pseudo class is present on this object or not.

      :returns: A PseudoClasses object describing the pseudo classes that are present.



   .. py:method:: post_render(renderable: rich.console.RenderableType, base_style: rich.style.Style) -> rich.console.ConsoleRenderable

      Applies style attributes to the default renderable.

      This method is called by Textual itself.
      It is unlikely you will need to call or implement this method.

      :returns: A new renderable.



   .. py:method:: watch_has_focus(_has_focus: bool) -> None

      Update from CSS if has focus state changes.



   .. py:method:: watch_disabled(disabled: bool) -> None

      Update the styles of the widget and its children when disabled is toggled.



   .. py:property:: visual_style
      :type: textual.style.Style



   .. py:method:: get_selection(selection: textual.selection.Selection) -> tuple[str, str] | None

      Get the text under the selection.

              Args:
                  selection: Selection information.

              Returns:
                  Tuple of extracted text and ending (typically "
      " or " "), or `None` if no text could be extracted.




   .. py:method:: selection_updated(selection: textual.selection.Selection | None) -> None

      Called when the selection is updated.

      :param selection: Selection information or `None` if no selection.



   .. py:method:: render_line(y: int) -> textual.strip.Strip

      Render a line of content.

      :param y: Y Coordinate of line.

      :returns: A rendered line.



   .. py:method:: render_lines(crop: textual.geometry.Region) -> list[textual.strip.Strip]

      Render the widget into lines.

      :param crop: Region within visible area to render.

      :returns: A list of list of segments.



   .. py:method:: get_style_at(x: int, y: int) -> rich.style.Style

      Get the Rich style in a widget at a given relative offset.

      :param x: X coordinate relative to the widget.
      :param y: Y coordinate relative to the widget.

      :returns: A rich Style object.



   .. py:method:: suppress_click() -> None

      Suppress a click event.

      This will prevent a [Click][textual.events.Click] event being sent,
      if called after a mouse down event and before the click itself.




   .. py:method:: refresh(*regions: textual.geometry.Region, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Initiate a refresh of the widget.

      This method sets an internal flag to perform a refresh, which will be done on the
      next idle event. Only one refresh will be done even if this method is called multiple times.

      By default this method will cause the content of the widget to refresh, but not change its size. You can also
      set `layout=True` to perform a layout.

      !!! warning

          It is rarely necessary to call this method explicitly. Updating styles or reactive attributes will
          do this automatically.

      :param \*regions: Additional screen regions to mark as dirty.
      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `Widget` instance.



   .. py:method:: remove() -> textual.await_remove.AwaitRemove

      Remove the Widget from the DOM (effectively deleting it).

      :returns: An awaitable object that waits for the widget to be removed.



   .. py:method:: remove_children(selector: str | type[textual.css.query.QueryType] | Iterable[Widget] = '*') -> textual.await_remove.AwaitRemove

      Remove the immediate children of this Widget from the DOM.

      :param selector: A CSS selector or iterable of widgets to remove.

      :returns: An awaitable object that waits for the direct children to be removed.



   .. py:method:: batch() -> AsyncGenerator[None, None]
      :async:


      Async context manager that combines widget locking and update batching.

      Use this async context manager whenever you want to acquire the widget lock and
      batch app updates at the same time.

      .. rubric:: Example

      ```py
      async with container.batch():
          await container.remove_children(Button)
          await container.mount(Label("All buttons are gone."))
      ```



   .. py:method:: run_action(action: str, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> None
      :async:


      Perform a given action, with this widget as the default namespace.

      :param action: Action encoded as a string.
      :param namespaces: Mapping of namespaces.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Post a message to this widget.

      :param message: Message to post.

      :returns: True if the message was posted, False if this widget was closed / closing.



   .. py:method:: on_prune(event: textual.messages.Prune) -> None
      :async:


      Close message loop when asked to prune.



   .. py:method:: focus(scroll_visible: bool = True) -> typing_extensions.Self

      Give focus to this widget.

      :param scroll_visible: Scroll parent to make this widget visible.

      :returns: The `Widget` instance.



   .. py:method:: blur() -> typing_extensions.Self

      Blur (un-focus) the widget.

      Focus will be moved to the next available widget in the focus chain.

      :returns: The `Widget` instance.



   .. py:method:: capture_mouse(capture: bool = True) -> None

      Capture (or release) the mouse.

      When captured, mouse events will go to this widget even when the pointer is not directly over the widget.

      :param capture: True to capture or False to release.



   .. py:method:: release_mouse() -> None

      Release the mouse.

      Mouse events will only be sent when the mouse is over the widget.



   .. py:method:: text_select_all() -> None

      Select the entire widget.



   .. py:method:: begin_capture_print(stdout: bool = True, stderr: bool = True) -> None

      Capture text from print statements (or writes to stdout / stderr).

      If printing is captured, the widget will be sent an [`events.Print`][textual.events.Print] message.

      Call [`end_capture_print`][textual.widget.Widget.end_capture_print] to disable print capture.

      :param stdout: Whether to capture stdout.
      :param stderr: Whether to capture stderr.



   .. py:method:: end_capture_print() -> None

      End print capture (set with [`begin_capture_print`][textual.widget.Widget.begin_capture_print]).



   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: broker_event(event_name: str, event: textual.events.Event) -> bool
      :async:



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:method:: handle_key(event: textual.events.Key) -> bool
      :async:



   .. py:method:: mount_composed_widgets(widgets: list[Widget]) -> None
      :async:


      Called by Textual to mount widgets after compose.

      There is generally no need to implement this method in your application.
      See [Lazy][textual.lazy.Lazy] for a class which uses this method to implement
      *lazy* mounting.

      :param widgets: A list of child widgets.



   .. py:method:: action_scroll_home() -> None


   .. py:method:: action_scroll_end() -> None


   .. py:method:: action_scroll_left() -> None


   .. py:method:: action_scroll_right() -> None


   .. py:method:: action_scroll_up() -> None


   .. py:method:: action_scroll_down() -> None


   .. py:method:: action_page_down() -> None


   .. py:method:: action_page_up() -> None


   .. py:method:: action_page_left() -> None


   .. py:method:: action_page_right() -> None


   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.

      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      See [`App.notify`][textual.app.App.notify] for the full
      documentation for this method.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information', markup: bool = True) -> None


   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Title of widget used where bindings are displayed (such as in the key panel).


   .. py:attribute:: BINDINGS
      :type:  ClassVar[list[textual.binding.BindingType]]
      :value: []


      A list of key bindings.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view on to the children.

      :returns: The node's children.


   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The app's worker manager. Shortcut for `self.app.workers`.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: screen
      :type: Screen[object]


      The screen containing this node.

      :returns: A screen object.

      :raises NoScreen: If this node isn't mounted (and has no screen).


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:property:: is_dom_root

      Is this a root node (i.e. the App)?


   .. py:attribute:: app


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:property:: log
      :type: textual.Logger


      Get a logger for this object.

      :returns: A logger.


   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:class:: UnicodeBlockGrid(grid, **kwargs)

   Bases: :py:obj:`BaseGrid`


   Grid rendered using colored Unicode blocks (using colored spaces or block characters).


   .. py:method:: render()

      Get a rich renderable for the widget's content.

      :returns: A rich renderable.



   .. py:attribute:: grid


   .. py:attribute:: rows


   .. py:attribute:: cols


   .. py:attribute:: DEFAULT_CSS
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
             Static {
                 height: auto;
             }
             """

      .. raw:: html

         </details>



      Default TCSS.


   .. py:attribute:: expand
      :value: False


      Rich renderable may expand beyond optimal size.


   .. py:attribute:: shrink
      :value: False


      Rich renderable may shrink below optimal size.


   .. py:property:: visual
      :type: textual.visual.Visual


      The visual to be displayed.

      Note that the visual is what is ultimately rendered in the widget, but may not be the
      same object set with the `update` method  or `content` property. For instance, if you
      update with a string, then the visual will be a [Content][textual.content.Content] instance.


   .. py:property:: content
      :type: textual.visual.VisualType


      The original content set in the constructor.


   .. py:method:: update(content: textual.visual.VisualType = '', *, layout: bool = True) -> None

      Update the widget's content area with a string, a Visual (such as [Content][textual.content.Content]), or a [Rich renderable](https://rich.readthedocs.io/en/latest/protocol.html).

      :param content: New content.
      :param layout: Also perform a layout operation (set to `False` if you are certain the size won't change).



   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: BORDER_TITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_title attribute.


   .. py:attribute:: BORDER_SUBTITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_subtitle attribute.


   .. py:attribute:: ALLOW_MAXIMIZE
      :type:  ClassVar[bool | None]
      :value: None


      Defines default logic to allow the widget to be maximized.

      - `None` Use default behavior (Focusable widgets may be maximized)
      - `False` Do not allow widget to be maximized
      - `True` Allow widget to be maximized


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      Does this widget support automatic text selection? May be further refined with [Widget.allow_select][textual.widget.Widget.allow_select].


   .. py:attribute:: FOCUS_ON_CLICK
      :type:  ClassVar[bool]
      :value: True


      Should focusable widgets be automatically focused on click? Default return value of [Widget.focus_on_click][textual.widget.Widget.focus_on_click].


   .. py:attribute:: can_focus
      :type:  bool
      :value: False


      Widget may receive focus.


   .. py:attribute:: can_focus_children
      :type:  bool
      :value: True


      Widget's children may receive focus.


   .. py:attribute:: auto_links
      :type:  textual.reactive.Reactive[bool]

      Widget will highlight links automatically.


   .. py:attribute:: disabled
      :type:  textual.reactive.Reactive[bool]

      Is the widget disabled? Disabled widgets can not be interacted with, and are typically styled to look dimmer.


   .. py:attribute:: hover_style
      :type:  textual.reactive.Reactive[rich.style.Style]

      The current hover style (style under the mouse cursor). Read only.


   .. py:attribute:: highlight_link_id
      :type:  textual.reactive.Reactive[str]

      The currently highlighted link id. Read only.


   .. py:attribute:: loading
      :type:  textual.reactive.Reactive[bool]

      If set to `True` this widget will temporarily be replaced with a loading indicator.


   .. py:attribute:: virtual_size
      :type:  textual.reactive.Reactive[textual.geometry.Size]

      The virtual (scrollable) [size][textual.geometry.Size] of the widget.


   .. py:attribute:: has_focus
      :type:  textual.reactive.Reactive[bool]

      Does this widget have focus? Read only.


   .. py:attribute:: mouse_hover
      :type:  textual.reactive.Reactive[bool]

      Is the mouse over this widget? Read only.


   .. py:attribute:: scroll_x
      :type:  textual.reactive.Reactive[float]

      The scroll position on the X axis.


   .. py:attribute:: scroll_y
      :type:  textual.reactive.Reactive[float]

      The scroll position on the Y axis.


   .. py:attribute:: scroll_target_x

      Scroll target destination, X coord.


   .. py:attribute:: scroll_target_y

      Scroll target destination, Y coord.


   .. py:attribute:: show_vertical_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a vertical scrollbar?


   .. py:attribute:: show_horizontal_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a horizontal scrollbar?


   .. py:attribute:: border_title

      A title to show in the top border (if there is one).


   .. py:attribute:: border_subtitle

      A title to show in the bottom border (if there is one).


   .. py:attribute:: sort_order
      :value: 0



   .. py:attribute:: highlight_style
      :type:  rich.style.Style | None
      :value: None



   .. py:attribute:: absolute_offset
      :type:  textual.geometry.Offset | None
      :value: None


      Force an absolute offset for the widget (used by tooltips).


   .. py:attribute:: lock

      `asyncio` lock to be used to synchronize the state of the widget.

      Two different tasks might call methods on a widget at the same time, which
      might result in a race condition.
      This can be fixed by adding `async with widget.lock:` around the method calls.


   .. py:property:: is_mounted
      :type: bool


      Check if this widget is mounted.


   .. py:property:: siblings
      :type: list[Widget]


      Get the widget's siblings (self is removed from the return list).

      :returns: A list of siblings.


   .. py:property:: visible_siblings
      :type: list[Widget]


      A list of siblings which will be shown.

      :returns: List of siblings.


   .. py:property:: allow_vertical_scroll
      :type: bool


      Check if vertical scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_horizontal_scroll
      :type: bool


      Check if horizontal scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_maximize
      :type: bool


      Check if the widget may be maximized.

      :returns: `True` if the widget may be maximized, or `False` if it should not be maximized.


   .. py:property:: offset
      :type: textual.geometry.Offset


      Widget offset from origin.

      :returns: Relative offset.


   .. py:property:: opacity
      :type: float


      Total opacity of widget.


   .. py:property:: is_anchored
      :type: bool


      Is this widget anchored?

      See [anchor()][textual.widget.Widget.anchor] for an explanation of anchoring.


   .. py:property:: is_mouse_over
      :type: bool


      Is the mouse currently over this widget?

      Note this will be `True` if the mouse pointer is within the widget's region, even if
      the mouse pointer is not directly over the widget (there could be another widget between
      the mouse pointer and self).


   .. py:property:: is_maximized
      :type: bool


      Is this widget maximized?


   .. py:property:: is_in_maximized_view
      :type: bool


      Is this widget, or a parent maximized?


   .. py:property:: text_selection
      :type: textual.selection.Selection | None


      Text selection information, or `None` if no text is selected in this widget.


   .. py:method:: focus_on_click() -> bool

      Automatically focus the widget on click?

      Implement this if you want to change the default click to focus behavior.
      The default will return the classvar `FOCUS_ON_CLICK`.

      :returns: `True` if Textual should set focus automatically on a click, or `False` if it shouldn't.



   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get the line filters enabled for this widget.

      :returns: A sequence of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: preflight_checks() -> None

      Called in debug mode to do preflight checks.

      This is used by Textual to log some common errors, but you could implement this
      in custom widgets to perform additional checks.




   .. py:method:: pre_render() -> None

      Called prior to rendering.

      If you implement this in a subclass, be sure to call the base class method via super.




   .. py:method:: process_layout(placements: list[textual.layout.WidgetPlacement]) -> list[textual.layout.WidgetPlacement]

      A hook to allow for the manipulation of widget placements before rendering.

      You could use this as a way to modify the positions / margins of widgets if your requirement is
      not supported in TCSS. In practice, this method is rarely needed!

      :param placements: A list of [`WidgetPlacement`][textual.layout.WidgetPlacement] objects.

      :returns: A new list of placements.



   .. py:method:: anchor(anchor: bool = True) -> None

      Anchor a scrollable widget.

      An anchored widget will stay scrolled the bottom when new content is added, until
      the user moves the scroll position.

      :param anchor: Anchor the widget if `True`, clear the anchor if `False`.



   .. py:method:: release_anchor() -> None

      Release the [anchor][textual.widget.Widget].

      If a widget is anchored, releasing the anchor will allow the user to scroll as normal.




   .. py:property:: tooltip
      :type: textual.visual.VisualType | None


      Tooltip for the widget, or `None` for no tooltip.


   .. py:method:: with_tooltip(tooltip: textual.visual.Visual | rich.console.RenderableType | None) -> typing_extensions.Self

      Chainable method to set a tooltip.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Label("Hello").with_tooltip("A greeting")
      ```

      :param tooltip: New tooltip, or `None` to clear the tooltip.

      :returns: Self.



   .. py:method:: allow_focus() -> bool

      Check if the widget is permitted to focus.

      The base class returns [`can_focus`][textual.widget.Widget.can_focus].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget may be focused, or `False` if it may not be focused.



   .. py:method:: allow_focus_children() -> bool

      Check if a widget's children may be focused.

      The base class returns [`can_focus_children`][textual.widget.Widget.can_focus_children].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget's children may be focused, or `False` if the widget's children may not be focused.



   .. py:method:: compose_add_child(widget: Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: is_disabled
      :type: bool


      Is the widget disabled either because `disabled=True` or an ancestor has `disabled=True`.


   .. py:property:: has_focus_within
      :type: bool


      Are any descendants focused?


   .. py:property:: first_of_type
      :type: bool


      Is this the first widget of its type in its siblings?


   .. py:property:: last_of_type
      :type: bool


      Is this the last widget of its type in its siblings?


   .. py:property:: first_child
      :type: bool


      Is this the first widget in its siblings?


   .. py:property:: last_child
      :type: bool


      Is this the last widget in its siblings?


   .. py:property:: is_odd
      :type: bool


      Is this widget at an oddly numbered position within its siblings?


   .. py:property:: is_even
      :type: bool


      Is this widget at an evenly numbered position within its siblings?


   .. py:method:: __enter__() -> typing_extensions.Self

      Use as context manager when composing.



   .. py:method:: __exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None

      Exit compose context manager.



   .. py:method:: clear_cached_dimensions() -> None

      Clear cached results of `get_content_width` and `get_content_height`.

      Call if the widget's renderable changes size after the widget has been created.

      !!! note

          This is not required if you are extending [`Static`][textual.widgets.Static].




   .. py:method:: get_loading_widget() -> Widget

      Get a widget to display a loading indicator.

      The default implementation will defer to App.get_loading_widget.

      :returns: A widget in place of this widget to indicate a loading.



   .. py:method:: set_loading(loading: bool) -> None

      Set or reset the loading state of this widget.

      A widget in a loading state will display a `LoadingIndicator` or a custom widget
      set through overriding the `get_loading_widget` method.

      :param loading: `True` to put the widget into a loading state, or `False` to reset the loading state.



   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> Widget

      Return the first child (immediate descendent) of this node with the given ID.

      :param id: The ID of the child.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first child of this node with the ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> Widget

      Return the first descendant widget with the given ID.

      Performs a depth-first search rooted at this widget.

      :param id: The ID to search for in the subtree.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID.
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get the first immediate child of a given type.

      Only returns exact matches, and so will not match subclasses of the given type.

      :param expect_type: The type of the child to search for.

      :raises NoMatches: If no matching child is found.

      :returns: The first immediate child widget with the expected type.



   .. py:method:: get_component_rich_style(*names: str, partial: bool = False) -> rich.style.Style

      Get a *Rich* style for a component.

      :param names: Names of components.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Rich style object.



   .. py:method:: get_visual_style(*component_classes: str, partial: bool = False) -> textual.style.Style

      Get the visual style for the widget, including any component styles.

      :param component_classes: Optional component styles.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Visual style instance.



   .. py:method:: render_str(text_content: str) -> textual.content.Content
                  render_str(text_content: textual.content.Content) -> textual.content.Content

      Convert str into a [Content][textual.content.Content] instance.

      If you pass in an existing Content instance it will be returned unaltered.

      :param text_content: Content or str.

      :returns: Content object.



   .. py:method:: arrange(size: textual.geometry.Size, optimal: bool = False) -> textual._arrange.DockArrangeResult

      Arrange child widgets.

      This method is best left alone, unless you have a deep understanding of what it does.

      :param size: Size of container.
      :param optimal: Whether fr units should expand the widget (`False`) or avoid expanding the widget (`True`).

      :returns: Widget locations.



   .. py:method:: mount(*widgets: Widget, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets below this widget (making this widget a container).

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of ``before`` or ``after`` can be provided. If both are
         provided a ``MountError`` will be raised.



   .. py:method:: mount_all(widgets: Iterable[Widget], *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_compose(compose_result: textual.app.ComposeResult, *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from the result of a compose method.

      Example:
      ```python
          def on_key(self, event:events.Key) -> None:

              def add_key(key:str) -> ComposeResult:
                  '''Compose key information widgets'''
                  with containers.HorizontalGroup():
                      yield Label("You pressed:")
                      yield Label(key)

              self.mount_compose(add_key(event.key))

      ```

      :param compose_result: The result of a compose method.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: move_child(child: int | Widget, *, before: int | Widget, after: None = None) -> None

      Move a child widget within its parent's list of children.

      :param child: The child widget to move.
      :param before: Child widget or location index to move before.
      :param after: Child widget or location index to move after.

      :raises WidgetError: If there is a problem with the child or target.

      .. note::

         Only one of `before` or `after` can be provided. If neither
         or both are provided a `WidgetError` will be raised.



   .. py:method:: compose() -> textual.app.ComposeResult

      Called by Textual to create child widgets.

      This method is called when a widget is mounted or by setting `recompose=True` when
      calling [`refresh()`][textual.widget.Widget.refresh].

      Note that you don't typically need to explicitly call this method.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Header()
          yield Label("Press the button below:")
          yield Button()
          yield Footer()
      ```



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: get_content_width(container: textual.geometry.Size, viewport: textual.geometry.Size) -> int

      Called by textual to get the width of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.

      :returns: The optimal width of the content.



   .. py:method:: get_content_height(container: textual.geometry.Size, viewport: textual.geometry.Size, width: int) -> int

      Called by Textual to get the height of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.
      :param width: Width of renderable.

      :returns: The height of the content.



   .. py:method:: watch_hover_style(previous_hover_style: rich.style.Style, hover_style: rich.style.Style) -> None


   .. py:method:: watch_scroll_x(old_value: float, new_value: float) -> None


   .. py:method:: watch_scroll_y(old_value: float, new_value: float) -> None


   .. py:method:: validate_scroll_x(value: float) -> float


   .. py:method:: validate_scroll_target_x(value: float) -> float


   .. py:method:: validate_scroll_y(value: float) -> float


   .. py:method:: validate_scroll_target_y(value: float) -> float


   .. py:property:: max_scroll_x
      :type: int


      The maximum value of `scroll_x`.


   .. py:property:: max_scroll_y
      :type: int


      The maximum value of `scroll_y`.


   .. py:property:: is_vertical_scroll_end
      :type: bool


      Is the vertical scroll position at the maximum?


   .. py:property:: is_horizontal_scroll_end
      :type: bool


      Is the horizontal scroll position at the maximum?


   .. py:property:: is_vertical_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: is_horizontal_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: scrollbar_corner
      :type: textual.scrollbar.ScrollBarCorner


      The scrollbar corner.

      .. note:: This will *create* a scrollbar corner if one doesn't exist.

      :returns: ScrollBarCorner Widget.


   .. py:property:: vertical_scrollbar
      :type: textual.scrollbar.ScrollBar


      The vertical scrollbar (create if necessary).

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: horizontal_scrollbar
      :type: textual.scrollbar.ScrollBar


      The horizontal scrollbar.

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: scrollbars_enabled
      :type: tuple[bool, bool]


      A tuple of booleans that indicate if scrollbars are enabled.

      :returns: A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)


   .. py:property:: scrollbars_space
      :type: tuple[int, int]


      The number of cells occupied by scrollbars for width and height


   .. py:property:: scrollbar_size_vertical
      :type: int


      Get the width used by the *vertical* scrollbar.

      :returns: Number of columns in the vertical scrollbar.


   .. py:property:: scrollbar_size_horizontal
      :type: int


      Get the height used by the *horizontal* scrollbar.

      :returns: Number of rows in the horizontal scrollbar.


   .. py:property:: scrollbar_gutter
      :type: textual.geometry.Spacing


      Spacing required to fit scrollbar(s).

      :returns: Scrollbar gutter spacing.


   .. py:property:: gutter
      :type: textual.geometry.Spacing


      Spacing for padding / border / scrollbars.

      :returns: Additional spacing around content area.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: scrollable_size
      :type: textual.geometry.Size


      The size of the scrollable content.

      :returns: Scrollable content size.


   .. py:property:: outer_size
      :type: textual.geometry.Size


      The size of the widget (including padding and border).

      :returns: Outer size.


   .. py:property:: container_size
      :type: textual.geometry.Size


      The size of the container (parent widget).

      :returns: Container size.


   .. py:property:: content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the content (minus padding and border).

      :returns: Screen region that contains a widget's content.


   .. py:property:: scrollable_content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the scrollable content (minus padding, border, and scrollbars).

      :returns: Screen region that contains a widget's content.


   .. py:property:: content_offset
      :type: textual.geometry.Offset


      An offset from the Widget origin where the content begins.

      :returns: Offset from widget's origin.


   .. py:property:: content_size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: region
      :type: textual.geometry.Region


      The region occupied by this widget, relative to the Screen.

      :raises NoScreen: If there is no screen.
      :raises errors.NoWidget: If the widget is not on the screen.

      :returns: Region within screen occupied by widget.


   .. py:property:: dock_gutter
      :type: textual.geometry.Spacing


      Space allocated to docks in the parent.

      :returns: Space to be subtracted from scrollable area.


   .. py:property:: container_viewport
      :type: textual.geometry.Region


      The viewport region (parent window).

      :returns: The region that contains this widget.


   .. py:property:: virtual_region
      :type: textual.geometry.Region


      The widget region relative to its container (which may not be visible,
      depending on scroll offset).


      :returns: The virtual region.


   .. py:property:: window_region
      :type: textual.geometry.Region


      The region within the scrollable area that is currently visible.

      :returns: New region.


   .. py:property:: virtual_region_with_margin
      :type: textual.geometry.Region


      The widget region relative to its container (*including margin*), which may not be visible,
      depending on the scroll offset.

      :returns: The virtual region of the Widget, inclusive of its margin.


   .. py:property:: focusable
      :type: bool


      Can this widget currently be focused?


   .. py:property:: scroll_offset
      :type: textual.geometry.Offset


      Get the current scroll offset.

      :returns: Offset a container has been scrolled by.


   .. py:property:: container_scroll_offset
      :type: textual.geometry.Offset


      The scroll offset the nearest container ancestor.


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation. Defaults to `value` if not set.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: layout
      :type: textual.layout.Layout


      Get the layout object if set in styles, or a default layout.

      :returns: A layout object.


   .. py:property:: is_container
      :type: bool


      Is this widget a container (contains other widgets)?


   .. py:property:: is_scrollable
      :type: bool


      Can this widget be scrolled?


   .. py:property:: is_scrolling
      :type: bool


      Is this widget currently scrolling?


   .. py:property:: layer
      :type: str


      Get the name of this widgets layer.

      :returns: Name of layer.


   .. py:property:: layers
      :type: tuple[str, Ellipsis]


      Layers of from parent.

      :returns: Tuple of layer names.


   .. py:property:: link_style
      :type: rich.style.Style


      Style of links.

      :returns: Rich style.


   .. py:property:: link_style_hover
      :type: rich.style.Style


      Style of links underneath the mouse cursor.

      :returns: Rich Style.


   .. py:property:: select_container
      :type: Widget


      The widget's container used when selecting text..

      :returns: A widget which contains this widget.


   .. py:property:: allow_select
      :type: bool


      Check if this widget permits text selection.

      :returns: `True` if the widget supports text selection, otherwise `False`.


   .. py:method:: pre_layout(layout: textual.layout.Layout) -> None

      This method id called prior to a layout operation.

      Implement this method if you want to make updates that should impact
      the layout.

      :param layout: The [Layout][textual.layout.Layout] instance that will be used to arrange this widget's children.



   .. py:method:: set_scroll(x: float | None, y: float | None) -> None

      Set the scroll position without any validation.

      This is a low-level method for when you want to see the scroll position in the next frame.
      For a more fully featured method, see [`scroll_to`][textual.widget.Widget.scroll_to].

      :param x: Desired `X` coordinate.
      :param y: Desired `Y` coordinate.



   .. py:method:: scroll_to(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, release_anchor: bool = True) -> None

      Scroll to a given (absolute) coordinate, optionally animating.

      :param x: X coordinate (column) to scroll to, or `None` for no change.
      :param y: Y coordinate (row) to scroll to, or `None` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param release_anchor: If `True` call `release_anchor`.

      .. note:: The call to scroll is made after the next refresh.



   .. py:method:: scroll_relative(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll relative to current position.

      :param x: X distance (columns) to scroll, or ``None`` for no change.
      :param y: Y distance (rows) to scroll, or ``None`` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`. Or `None` to use `duration`.
      :param duration: Duration of animation, if animate is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_home(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to home position.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use duration.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_end(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to the end of the container.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_page_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_to_widget(widget: Widget, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> bool

      Scroll scrolling to bring a widget into view.

      :param widget: A descendant widget.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll widget to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: `True` if any scrolling has occurred in any descendant, otherwise `False`.



   .. py:method:: scroll_to_region(region: textual.geometry.Region, *, spacing: textual.geometry.Spacing | None = None, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', x_axis: bool = True, y_axis: bool = True, immediate: bool = False) -> textual.geometry.Offset

      Scrolls a given region into view, if required.

      This method will scroll the least distance required to move `region` fully within
      the scrollable area.

      :param region: A region that should be visible.
      :param spacing: Optional spacing around the region.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll `region` to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: The distance that was scrolled.



   .. py:method:: scroll_visible(animate: bool = True, *, speed: float | None = None, duration: float | None = None, top: bool = False, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll the container to make this widget visible.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param top: Scroll to top of container.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_to_center(widget: Widget, animate: bool = True, *, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, origin_visible: bool = True, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll this widget to the center of self.

      The center of the widget will be scrolled to the center of the container.

      :param widget: The widget to scroll to the center of self.
      :param animate: Whether to animate the scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param origin_visible: Ensure that the top left corner of the widget remains visible after the scroll.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: can_view_entire(widget: Widget) -> bool

      Check if a given widget is *fully* within the current view (scrollable area).

      Note: This doesn't necessarily equate to a widget being visible.
      There are other reasons why a widget may not be visible.

      :param widget: A widget that is a descendant of self.

      :returns: `True` if the entire widget is in view, `False` if it is partially visible or not in view.



   .. py:method:: can_view_partial(widget: Widget) -> bool

      Check if a given widget at least partially visible within the current view (scrollable area).

      :param widget: A widget that is a descendant of self.

      :returns: `True` if any part of the widget is visible, `False` if it is outside of the viewable area.



   .. py:method:: __init_subclass__(can_focus: bool | None = None, can_focus_children: bool | None = None, inherit_css: bool = True, inherit_bindings: bool = True) -> None
      :classmethod:



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:method:: get_pseudo_class_state() -> PseudoClasses

      Get an object describing whether each pseudo class is present on this object or not.

      :returns: A PseudoClasses object describing the pseudo classes that are present.



   .. py:method:: post_render(renderable: rich.console.RenderableType, base_style: rich.style.Style) -> rich.console.ConsoleRenderable

      Applies style attributes to the default renderable.

      This method is called by Textual itself.
      It is unlikely you will need to call or implement this method.

      :returns: A new renderable.



   .. py:method:: watch_has_focus(_has_focus: bool) -> None

      Update from CSS if has focus state changes.



   .. py:method:: watch_disabled(disabled: bool) -> None

      Update the styles of the widget and its children when disabled is toggled.



   .. py:property:: visual_style
      :type: textual.style.Style



   .. py:method:: get_selection(selection: textual.selection.Selection) -> tuple[str, str] | None

      Get the text under the selection.

              Args:
                  selection: Selection information.

              Returns:
                  Tuple of extracted text and ending (typically "
      " or " "), or `None` if no text could be extracted.




   .. py:method:: selection_updated(selection: textual.selection.Selection | None) -> None

      Called when the selection is updated.

      :param selection: Selection information or `None` if no selection.



   .. py:method:: render_line(y: int) -> textual.strip.Strip

      Render a line of content.

      :param y: Y Coordinate of line.

      :returns: A rendered line.



   .. py:method:: render_lines(crop: textual.geometry.Region) -> list[textual.strip.Strip]

      Render the widget into lines.

      :param crop: Region within visible area to render.

      :returns: A list of list of segments.



   .. py:method:: get_style_at(x: int, y: int) -> rich.style.Style

      Get the Rich style in a widget at a given relative offset.

      :param x: X coordinate relative to the widget.
      :param y: Y coordinate relative to the widget.

      :returns: A rich Style object.



   .. py:method:: suppress_click() -> None

      Suppress a click event.

      This will prevent a [Click][textual.events.Click] event being sent,
      if called after a mouse down event and before the click itself.




   .. py:method:: refresh(*regions: textual.geometry.Region, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Initiate a refresh of the widget.

      This method sets an internal flag to perform a refresh, which will be done on the
      next idle event. Only one refresh will be done even if this method is called multiple times.

      By default this method will cause the content of the widget to refresh, but not change its size. You can also
      set `layout=True` to perform a layout.

      !!! warning

          It is rarely necessary to call this method explicitly. Updating styles or reactive attributes will
          do this automatically.

      :param \*regions: Additional screen regions to mark as dirty.
      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `Widget` instance.



   .. py:method:: remove() -> textual.await_remove.AwaitRemove

      Remove the Widget from the DOM (effectively deleting it).

      :returns: An awaitable object that waits for the widget to be removed.



   .. py:method:: remove_children(selector: str | type[textual.css.query.QueryType] | Iterable[Widget] = '*') -> textual.await_remove.AwaitRemove

      Remove the immediate children of this Widget from the DOM.

      :param selector: A CSS selector or iterable of widgets to remove.

      :returns: An awaitable object that waits for the direct children to be removed.



   .. py:method:: batch() -> AsyncGenerator[None, None]
      :async:


      Async context manager that combines widget locking and update batching.

      Use this async context manager whenever you want to acquire the widget lock and
      batch app updates at the same time.

      .. rubric:: Example

      ```py
      async with container.batch():
          await container.remove_children(Button)
          await container.mount(Label("All buttons are gone."))
      ```



   .. py:method:: run_action(action: str, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> None
      :async:


      Perform a given action, with this widget as the default namespace.

      :param action: Action encoded as a string.
      :param namespaces: Mapping of namespaces.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Post a message to this widget.

      :param message: Message to post.

      :returns: True if the message was posted, False if this widget was closed / closing.



   .. py:method:: on_prune(event: textual.messages.Prune) -> None
      :async:


      Close message loop when asked to prune.



   .. py:method:: focus(scroll_visible: bool = True) -> typing_extensions.Self

      Give focus to this widget.

      :param scroll_visible: Scroll parent to make this widget visible.

      :returns: The `Widget` instance.



   .. py:method:: blur() -> typing_extensions.Self

      Blur (un-focus) the widget.

      Focus will be moved to the next available widget in the focus chain.

      :returns: The `Widget` instance.



   .. py:method:: capture_mouse(capture: bool = True) -> None

      Capture (or release) the mouse.

      When captured, mouse events will go to this widget even when the pointer is not directly over the widget.

      :param capture: True to capture or False to release.



   .. py:method:: release_mouse() -> None

      Release the mouse.

      Mouse events will only be sent when the mouse is over the widget.



   .. py:method:: text_select_all() -> None

      Select the entire widget.



   .. py:method:: begin_capture_print(stdout: bool = True, stderr: bool = True) -> None

      Capture text from print statements (or writes to stdout / stderr).

      If printing is captured, the widget will be sent an [`events.Print`][textual.events.Print] message.

      Call [`end_capture_print`][textual.widget.Widget.end_capture_print] to disable print capture.

      :param stdout: Whether to capture stdout.
      :param stderr: Whether to capture stderr.



   .. py:method:: end_capture_print() -> None

      End print capture (set with [`begin_capture_print`][textual.widget.Widget.begin_capture_print]).



   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: broker_event(event_name: str, event: textual.events.Event) -> bool
      :async:



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:method:: handle_key(event: textual.events.Key) -> bool
      :async:



   .. py:method:: mount_composed_widgets(widgets: list[Widget]) -> None
      :async:


      Called by Textual to mount widgets after compose.

      There is generally no need to implement this method in your application.
      See [Lazy][textual.lazy.Lazy] for a class which uses this method to implement
      *lazy* mounting.

      :param widgets: A list of child widgets.



   .. py:method:: action_scroll_home() -> None


   .. py:method:: action_scroll_end() -> None


   .. py:method:: action_scroll_left() -> None


   .. py:method:: action_scroll_right() -> None


   .. py:method:: action_scroll_up() -> None


   .. py:method:: action_scroll_down() -> None


   .. py:method:: action_page_down() -> None


   .. py:method:: action_page_up() -> None


   .. py:method:: action_page_left() -> None


   .. py:method:: action_page_right() -> None


   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.

      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      See [`App.notify`][textual.app.App.notify] for the full
      documentation for this method.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information', markup: bool = True) -> None


   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Title of widget used where bindings are displayed (such as in the key panel).


   .. py:attribute:: BINDINGS
      :type:  ClassVar[list[textual.binding.BindingType]]
      :value: []


      A list of key bindings.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view on to the children.

      :returns: The node's children.


   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The app's worker manager. Shortcut for `self.app.workers`.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: screen
      :type: Screen[object]


      The screen containing this node.

      :returns: A screen object.

      :raises NoScreen: If this node isn't mounted (and has no screen).


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:property:: is_dom_root

      Is this a root node (i.e. the App)?


   .. py:attribute:: app


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:property:: log
      :type: textual.Logger


      Get a logger for this object.

      :returns: A logger.


   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:class:: HalfBlockGrid(grid, **kwargs)

   Bases: :py:obj:`BaseGrid`


   Grid rendered by combining two rows into one using half-block characters.


   .. py:method:: render()

      Get a rich renderable for the widget's content.

      :returns: A rich renderable.



   .. py:attribute:: grid


   .. py:attribute:: rows


   .. py:attribute:: cols


   .. py:attribute:: DEFAULT_CSS
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
             Static {
                 height: auto;
             }
             """

      .. raw:: html

         </details>



      Default TCSS.


   .. py:attribute:: expand
      :value: False


      Rich renderable may expand beyond optimal size.


   .. py:attribute:: shrink
      :value: False


      Rich renderable may shrink below optimal size.


   .. py:property:: visual
      :type: textual.visual.Visual


      The visual to be displayed.

      Note that the visual is what is ultimately rendered in the widget, but may not be the
      same object set with the `update` method  or `content` property. For instance, if you
      update with a string, then the visual will be a [Content][textual.content.Content] instance.


   .. py:property:: content
      :type: textual.visual.VisualType


      The original content set in the constructor.


   .. py:method:: update(content: textual.visual.VisualType = '', *, layout: bool = True) -> None

      Update the widget's content area with a string, a Visual (such as [Content][textual.content.Content]), or a [Rich renderable](https://rich.readthedocs.io/en/latest/protocol.html).

      :param content: New content.
      :param layout: Also perform a layout operation (set to `False` if you are certain the size won't change).



   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: BORDER_TITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_title attribute.


   .. py:attribute:: BORDER_SUBTITLE
      :type:  ClassVar[str]
      :value: ''


      Initial value for border_subtitle attribute.


   .. py:attribute:: ALLOW_MAXIMIZE
      :type:  ClassVar[bool | None]
      :value: None


      Defines default logic to allow the widget to be maximized.

      - `None` Use default behavior (Focusable widgets may be maximized)
      - `False` Do not allow widget to be maximized
      - `True` Allow widget to be maximized


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      Does this widget support automatic text selection? May be further refined with [Widget.allow_select][textual.widget.Widget.allow_select].


   .. py:attribute:: FOCUS_ON_CLICK
      :type:  ClassVar[bool]
      :value: True


      Should focusable widgets be automatically focused on click? Default return value of [Widget.focus_on_click][textual.widget.Widget.focus_on_click].


   .. py:attribute:: can_focus
      :type:  bool
      :value: False


      Widget may receive focus.


   .. py:attribute:: can_focus_children
      :type:  bool
      :value: True


      Widget's children may receive focus.


   .. py:attribute:: auto_links
      :type:  textual.reactive.Reactive[bool]

      Widget will highlight links automatically.


   .. py:attribute:: disabled
      :type:  textual.reactive.Reactive[bool]

      Is the widget disabled? Disabled widgets can not be interacted with, and are typically styled to look dimmer.


   .. py:attribute:: hover_style
      :type:  textual.reactive.Reactive[rich.style.Style]

      The current hover style (style under the mouse cursor). Read only.


   .. py:attribute:: highlight_link_id
      :type:  textual.reactive.Reactive[str]

      The currently highlighted link id. Read only.


   .. py:attribute:: loading
      :type:  textual.reactive.Reactive[bool]

      If set to `True` this widget will temporarily be replaced with a loading indicator.


   .. py:attribute:: virtual_size
      :type:  textual.reactive.Reactive[textual.geometry.Size]

      The virtual (scrollable) [size][textual.geometry.Size] of the widget.


   .. py:attribute:: has_focus
      :type:  textual.reactive.Reactive[bool]

      Does this widget have focus? Read only.


   .. py:attribute:: mouse_hover
      :type:  textual.reactive.Reactive[bool]

      Is the mouse over this widget? Read only.


   .. py:attribute:: scroll_x
      :type:  textual.reactive.Reactive[float]

      The scroll position on the X axis.


   .. py:attribute:: scroll_y
      :type:  textual.reactive.Reactive[float]

      The scroll position on the Y axis.


   .. py:attribute:: scroll_target_x

      Scroll target destination, X coord.


   .. py:attribute:: scroll_target_y

      Scroll target destination, Y coord.


   .. py:attribute:: show_vertical_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a vertical scrollbar?


   .. py:attribute:: show_horizontal_scrollbar
      :type:  textual.reactive.Reactive[bool]

      Show a horizontal scrollbar?


   .. py:attribute:: border_title

      A title to show in the top border (if there is one).


   .. py:attribute:: border_subtitle

      A title to show in the bottom border (if there is one).


   .. py:attribute:: sort_order
      :value: 0



   .. py:attribute:: highlight_style
      :type:  rich.style.Style | None
      :value: None



   .. py:attribute:: absolute_offset
      :type:  textual.geometry.Offset | None
      :value: None


      Force an absolute offset for the widget (used by tooltips).


   .. py:attribute:: lock

      `asyncio` lock to be used to synchronize the state of the widget.

      Two different tasks might call methods on a widget at the same time, which
      might result in a race condition.
      This can be fixed by adding `async with widget.lock:` around the method calls.


   .. py:property:: is_mounted
      :type: bool


      Check if this widget is mounted.


   .. py:property:: siblings
      :type: list[Widget]


      Get the widget's siblings (self is removed from the return list).

      :returns: A list of siblings.


   .. py:property:: visible_siblings
      :type: list[Widget]


      A list of siblings which will be shown.

      :returns: List of siblings.


   .. py:property:: allow_vertical_scroll
      :type: bool


      Check if vertical scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_horizontal_scroll
      :type: bool


      Check if horizontal scroll is permitted.

      May be overridden if you want different logic regarding allowing scrolling.


   .. py:property:: allow_maximize
      :type: bool


      Check if the widget may be maximized.

      :returns: `True` if the widget may be maximized, or `False` if it should not be maximized.


   .. py:property:: offset
      :type: textual.geometry.Offset


      Widget offset from origin.

      :returns: Relative offset.


   .. py:property:: opacity
      :type: float


      Total opacity of widget.


   .. py:property:: is_anchored
      :type: bool


      Is this widget anchored?

      See [anchor()][textual.widget.Widget.anchor] for an explanation of anchoring.


   .. py:property:: is_mouse_over
      :type: bool


      Is the mouse currently over this widget?

      Note this will be `True` if the mouse pointer is within the widget's region, even if
      the mouse pointer is not directly over the widget (there could be another widget between
      the mouse pointer and self).


   .. py:property:: is_maximized
      :type: bool


      Is this widget maximized?


   .. py:property:: is_in_maximized_view
      :type: bool


      Is this widget, or a parent maximized?


   .. py:property:: text_selection
      :type: textual.selection.Selection | None


      Text selection information, or `None` if no text is selected in this widget.


   .. py:method:: focus_on_click() -> bool

      Automatically focus the widget on click?

      Implement this if you want to change the default click to focus behavior.
      The default will return the classvar `FOCUS_ON_CLICK`.

      :returns: `True` if Textual should set focus automatically on a click, or `False` if it shouldn't.



   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get the line filters enabled for this widget.

      :returns: A sequence of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: preflight_checks() -> None

      Called in debug mode to do preflight checks.

      This is used by Textual to log some common errors, but you could implement this
      in custom widgets to perform additional checks.




   .. py:method:: pre_render() -> None

      Called prior to rendering.

      If you implement this in a subclass, be sure to call the base class method via super.




   .. py:method:: process_layout(placements: list[textual.layout.WidgetPlacement]) -> list[textual.layout.WidgetPlacement]

      A hook to allow for the manipulation of widget placements before rendering.

      You could use this as a way to modify the positions / margins of widgets if your requirement is
      not supported in TCSS. In practice, this method is rarely needed!

      :param placements: A list of [`WidgetPlacement`][textual.layout.WidgetPlacement] objects.

      :returns: A new list of placements.



   .. py:method:: anchor(anchor: bool = True) -> None

      Anchor a scrollable widget.

      An anchored widget will stay scrolled the bottom when new content is added, until
      the user moves the scroll position.

      :param anchor: Anchor the widget if `True`, clear the anchor if `False`.



   .. py:method:: release_anchor() -> None

      Release the [anchor][textual.widget.Widget].

      If a widget is anchored, releasing the anchor will allow the user to scroll as normal.




   .. py:property:: tooltip
      :type: textual.visual.VisualType | None


      Tooltip for the widget, or `None` for no tooltip.


   .. py:method:: with_tooltip(tooltip: textual.visual.Visual | rich.console.RenderableType | None) -> typing_extensions.Self

      Chainable method to set a tooltip.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Label("Hello").with_tooltip("A greeting")
      ```

      :param tooltip: New tooltip, or `None` to clear the tooltip.

      :returns: Self.



   .. py:method:: allow_focus() -> bool

      Check if the widget is permitted to focus.

      The base class returns [`can_focus`][textual.widget.Widget.can_focus].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget may be focused, or `False` if it may not be focused.



   .. py:method:: allow_focus_children() -> bool

      Check if a widget's children may be focused.

      The base class returns [`can_focus_children`][textual.widget.Widget.can_focus_children].
      This method may be overridden if additional logic is required.

      :returns: `True` if the widget's children may be focused, or `False` if the widget's children may not be focused.



   .. py:method:: compose_add_child(widget: Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: is_disabled
      :type: bool


      Is the widget disabled either because `disabled=True` or an ancestor has `disabled=True`.


   .. py:property:: has_focus_within
      :type: bool


      Are any descendants focused?


   .. py:property:: first_of_type
      :type: bool


      Is this the first widget of its type in its siblings?


   .. py:property:: last_of_type
      :type: bool


      Is this the last widget of its type in its siblings?


   .. py:property:: first_child
      :type: bool


      Is this the first widget in its siblings?


   .. py:property:: last_child
      :type: bool


      Is this the last widget in its siblings?


   .. py:property:: is_odd
      :type: bool


      Is this widget at an oddly numbered position within its siblings?


   .. py:property:: is_even
      :type: bool


      Is this widget at an evenly numbered position within its siblings?


   .. py:method:: __enter__() -> typing_extensions.Self

      Use as context manager when composing.



   .. py:method:: __exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None

      Exit compose context manager.



   .. py:method:: clear_cached_dimensions() -> None

      Clear cached results of `get_content_width` and `get_content_height`.

      Call if the widget's renderable changes size after the widget has been created.

      !!! note

          This is not required if you are extending [`Static`][textual.widgets.Static].




   .. py:method:: get_loading_widget() -> Widget

      Get a widget to display a loading indicator.

      The default implementation will defer to App.get_loading_widget.

      :returns: A widget in place of this widget to indicate a loading.



   .. py:method:: set_loading(loading: bool) -> None

      Set or reset the loading state of this widget.

      A widget in a loading state will display a `LoadingIndicator` or a custom widget
      set through overriding the `get_loading_widget` method.

      :param loading: `True` to put the widget into a loading state, or `False` to reset the loading state.



   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> Widget

      Return the first child (immediate descendent) of this node with the given ID.

      :param id: The ID of the child.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first child of this node with the ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> Widget

      Return the first descendant widget with the given ID.

      Performs a depth-first search rooted at this widget.

      :param id: The ID to search for in the subtree.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID.
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get the first immediate child of a given type.

      Only returns exact matches, and so will not match subclasses of the given type.

      :param expect_type: The type of the child to search for.

      :raises NoMatches: If no matching child is found.

      :returns: The first immediate child widget with the expected type.



   .. py:method:: get_component_rich_style(*names: str, partial: bool = False) -> rich.style.Style

      Get a *Rich* style for a component.

      :param names: Names of components.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Rich style object.



   .. py:method:: get_visual_style(*component_classes: str, partial: bool = False) -> textual.style.Style

      Get the visual style for the widget, including any component styles.

      :param component_classes: Optional component styles.
      :param partial: Return a partial style (not combined with parent).

      :returns: A Visual style instance.



   .. py:method:: render_str(text_content: str) -> textual.content.Content
                  render_str(text_content: textual.content.Content) -> textual.content.Content

      Convert str into a [Content][textual.content.Content] instance.

      If you pass in an existing Content instance it will be returned unaltered.

      :param text_content: Content or str.

      :returns: Content object.



   .. py:method:: arrange(size: textual.geometry.Size, optimal: bool = False) -> textual._arrange.DockArrangeResult

      Arrange child widgets.

      This method is best left alone, unless you have a deep understanding of what it does.

      :param size: Size of container.
      :param optimal: Whether fr units should expand the widget (`False`) or avoid expanding the widget (`True`).

      :returns: Widget locations.



   .. py:method:: mount(*widgets: Widget, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets below this widget (making this widget a container).

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of ``before`` or ``after`` can be provided. If both are
         provided a ``MountError`` will be raised.



   .. py:method:: mount_all(widgets: Iterable[Widget], *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_compose(compose_result: textual.app.ComposeResult, *, before: int | str | Widget | None = None, after: int | str | Widget | None = None) -> AwaitMount

      Mount widgets from the result of a compose method.

      Example:
      ```python
          def on_key(self, event:events.Key) -> None:

              def add_key(key:str) -> ComposeResult:
                  '''Compose key information widgets'''
                  with containers.HorizontalGroup():
                      yield Label("You pressed:")
                      yield Label(key)

              self.mount_compose(add_key(event.key))

      ```

      :param compose_result: The result of a compose method.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: move_child(child: int | Widget, *, before: int | Widget, after: None = None) -> None

      Move a child widget within its parent's list of children.

      :param child: The child widget to move.
      :param before: Child widget or location index to move before.
      :param after: Child widget or location index to move after.

      :raises WidgetError: If there is a problem with the child or target.

      .. note::

         Only one of `before` or `after` can be provided. If neither
         or both are provided a `WidgetError` will be raised.



   .. py:method:: compose() -> textual.app.ComposeResult

      Called by Textual to create child widgets.

      This method is called when a widget is mounted or by setting `recompose=True` when
      calling [`refresh()`][textual.widget.Widget.refresh].

      Note that you don't typically need to explicitly call this method.

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield Header()
          yield Label("Press the button below:")
          yield Button()
          yield Footer()
      ```



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: get_content_width(container: textual.geometry.Size, viewport: textual.geometry.Size) -> int

      Called by textual to get the width of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.

      :returns: The optimal width of the content.



   .. py:method:: get_content_height(container: textual.geometry.Size, viewport: textual.geometry.Size, width: int) -> int

      Called by Textual to get the height of the content area. May be overridden in a subclass.

      :param container: Size of the container (immediate parent) widget.
      :param viewport: Size of the viewport.
      :param width: Width of renderable.

      :returns: The height of the content.



   .. py:method:: watch_hover_style(previous_hover_style: rich.style.Style, hover_style: rich.style.Style) -> None


   .. py:method:: watch_scroll_x(old_value: float, new_value: float) -> None


   .. py:method:: watch_scroll_y(old_value: float, new_value: float) -> None


   .. py:method:: validate_scroll_x(value: float) -> float


   .. py:method:: validate_scroll_target_x(value: float) -> float


   .. py:method:: validate_scroll_y(value: float) -> float


   .. py:method:: validate_scroll_target_y(value: float) -> float


   .. py:property:: max_scroll_x
      :type: int


      The maximum value of `scroll_x`.


   .. py:property:: max_scroll_y
      :type: int


      The maximum value of `scroll_y`.


   .. py:property:: is_vertical_scroll_end
      :type: bool


      Is the vertical scroll position at the maximum?


   .. py:property:: is_horizontal_scroll_end
      :type: bool


      Is the horizontal scroll position at the maximum?


   .. py:property:: is_vertical_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: is_horizontal_scrollbar_grabbed
      :type: bool


      Is the user dragging the vertical scrollbar?


   .. py:property:: scrollbar_corner
      :type: textual.scrollbar.ScrollBarCorner


      The scrollbar corner.

      .. note:: This will *create* a scrollbar corner if one doesn't exist.

      :returns: ScrollBarCorner Widget.


   .. py:property:: vertical_scrollbar
      :type: textual.scrollbar.ScrollBar


      The vertical scrollbar (create if necessary).

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: horizontal_scrollbar
      :type: textual.scrollbar.ScrollBar


      The horizontal scrollbar.

      .. note:: This will *create* a scrollbar if one doesn't exist.

      :returns: ScrollBar Widget.


   .. py:property:: scrollbars_enabled
      :type: tuple[bool, bool]


      A tuple of booleans that indicate if scrollbars are enabled.

      :returns: A tuple of (<vertical scrollbar enabled>, <horizontal scrollbar enabled>)


   .. py:property:: scrollbars_space
      :type: tuple[int, int]


      The number of cells occupied by scrollbars for width and height


   .. py:property:: scrollbar_size_vertical
      :type: int


      Get the width used by the *vertical* scrollbar.

      :returns: Number of columns in the vertical scrollbar.


   .. py:property:: scrollbar_size_horizontal
      :type: int


      Get the height used by the *horizontal* scrollbar.

      :returns: Number of rows in the horizontal scrollbar.


   .. py:property:: scrollbar_gutter
      :type: textual.geometry.Spacing


      Spacing required to fit scrollbar(s).

      :returns: Scrollbar gutter spacing.


   .. py:property:: gutter
      :type: textual.geometry.Spacing


      Spacing for padding / border / scrollbars.

      :returns: Additional spacing around content area.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: scrollable_size
      :type: textual.geometry.Size


      The size of the scrollable content.

      :returns: Scrollable content size.


   .. py:property:: outer_size
      :type: textual.geometry.Size


      The size of the widget (including padding and border).

      :returns: Outer size.


   .. py:property:: container_size
      :type: textual.geometry.Size


      The size of the container (parent widget).

      :returns: Container size.


   .. py:property:: content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the content (minus padding and border).

      :returns: Screen region that contains a widget's content.


   .. py:property:: scrollable_content_region
      :type: textual.geometry.Region


      Gets an absolute region containing the scrollable content (minus padding, border, and scrollbars).

      :returns: Screen region that contains a widget's content.


   .. py:property:: content_offset
      :type: textual.geometry.Offset


      An offset from the Widget origin where the content begins.

      :returns: Offset from widget's origin.


   .. py:property:: content_size
      :type: textual.geometry.Size


      The size of the content area.

      :returns: Content area size.


   .. py:property:: region
      :type: textual.geometry.Region


      The region occupied by this widget, relative to the Screen.

      :raises NoScreen: If there is no screen.
      :raises errors.NoWidget: If the widget is not on the screen.

      :returns: Region within screen occupied by widget.


   .. py:property:: dock_gutter
      :type: textual.geometry.Spacing


      Space allocated to docks in the parent.

      :returns: Space to be subtracted from scrollable area.


   .. py:property:: container_viewport
      :type: textual.geometry.Region


      The viewport region (parent window).

      :returns: The region that contains this widget.


   .. py:property:: virtual_region
      :type: textual.geometry.Region


      The widget region relative to its container (which may not be visible,
      depending on scroll offset).


      :returns: The virtual region.


   .. py:property:: window_region
      :type: textual.geometry.Region


      The region within the scrollable area that is currently visible.

      :returns: New region.


   .. py:property:: virtual_region_with_margin
      :type: textual.geometry.Region


      The widget region relative to its container (*including margin*), which may not be visible,
      depending on the scroll offset.

      :returns: The virtual region of the Widget, inclusive of its margin.


   .. py:property:: focusable
      :type: bool


      Can this widget currently be focused?


   .. py:property:: scroll_offset
      :type: textual.geometry.Offset


      Get the current scroll offset.

      :returns: Offset a container has been scrolled by.


   .. py:property:: container_scroll_offset
      :type: textual.geometry.Offset


      The scroll offset the nearest container ancestor.


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation. Defaults to `value` if not set.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: layout
      :type: textual.layout.Layout


      Get the layout object if set in styles, or a default layout.

      :returns: A layout object.


   .. py:property:: is_container
      :type: bool


      Is this widget a container (contains other widgets)?


   .. py:property:: is_scrollable
      :type: bool


      Can this widget be scrolled?


   .. py:property:: is_scrolling
      :type: bool


      Is this widget currently scrolling?


   .. py:property:: layer
      :type: str


      Get the name of this widgets layer.

      :returns: Name of layer.


   .. py:property:: layers
      :type: tuple[str, Ellipsis]


      Layers of from parent.

      :returns: Tuple of layer names.


   .. py:property:: link_style
      :type: rich.style.Style


      Style of links.

      :returns: Rich style.


   .. py:property:: link_style_hover
      :type: rich.style.Style


      Style of links underneath the mouse cursor.

      :returns: Rich Style.


   .. py:property:: select_container
      :type: Widget


      The widget's container used when selecting text..

      :returns: A widget which contains this widget.


   .. py:property:: allow_select
      :type: bool


      Check if this widget permits text selection.

      :returns: `True` if the widget supports text selection, otherwise `False`.


   .. py:method:: pre_layout(layout: textual.layout.Layout) -> None

      This method id called prior to a layout operation.

      Implement this method if you want to make updates that should impact
      the layout.

      :param layout: The [Layout][textual.layout.Layout] instance that will be used to arrange this widget's children.



   .. py:method:: set_scroll(x: float | None, y: float | None) -> None

      Set the scroll position without any validation.

      This is a low-level method for when you want to see the scroll position in the next frame.
      For a more fully featured method, see [`scroll_to`][textual.widget.Widget.scroll_to].

      :param x: Desired `X` coordinate.
      :param y: Desired `Y` coordinate.



   .. py:method:: scroll_to(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, release_anchor: bool = True) -> None

      Scroll to a given (absolute) coordinate, optionally animating.

      :param x: X coordinate (column) to scroll to, or `None` for no change.
      :param y: Y coordinate (row) to scroll to, or `None` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param release_anchor: If `True` call `release_anchor`.

      .. note:: The call to scroll is made after the next refresh.



   .. py:method:: scroll_relative(x: float | None = None, y: float | None = None, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll relative to current position.

      :param x: X distance (columns) to scroll, or ``None`` for no change.
      :param y: Y distance (rows) to scroll, or ``None`` for no change.
      :param animate: Animate to new scroll position.
      :param speed: Speed of scroll if `animate` is `True`. Or `None` to use `duration`.
      :param duration: Duration of animation, if animate is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_home(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to home position.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use duration.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_end(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False, x_axis: bool = True, y_axis: bool = True) -> None

      Scroll to the end of the container.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?



   .. py:method:: scroll_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one cell right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll one line up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and speed is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_page_up(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page up.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_down(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page down.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_left(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page left.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_page_right(*, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic') -> None

      Scroll one page right.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: scroll_to_widget(widget: Widget, *, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> bool

      Scroll scrolling to bring a widget into view.

      :param widget: A descendant widget.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll widget to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: `True` if any scrolling has occurred in any descendant, otherwise `False`.



   .. py:method:: scroll_to_region(region: textual.geometry.Region, *, spacing: textual.geometry.Spacing | None = None, animate: bool = True, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, center: bool = False, top: bool = False, origin_visible: bool = True, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', x_axis: bool = True, y_axis: bool = True, immediate: bool = False) -> textual.geometry.Offset

      Scrolls a given region into view, if required.

      This method will scroll the least distance required to move `region` fully within
      the scrollable area.

      :param region: A region that should be visible.
      :param spacing: Optional spacing around the region.
      :param animate: `True` to animate, or `False` to jump.
      :param speed: Speed of scroll if `animate` is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param top: Scroll `region` to top of container.
      :param origin_visible: Ensure that the top left of the widget is within the window.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param x_axis: Allow scrolling on X axis?
      :param y_axis: Allow scrolling on Y axis?
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.

      :returns: The distance that was scrolled.



   .. py:method:: scroll_visible(animate: bool = True, *, speed: float | None = None, duration: float | None = None, top: bool = False, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll the container to make this widget visible.

      :param animate: Animate scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param top: Scroll to top of container.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: scroll_to_center(widget: Widget, animate: bool = True, *, speed: float | None = None, duration: float | None = None, easing: textual._animator.EasingFunction | str | None = None, force: bool = False, origin_visible: bool = True, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'basic', immediate: bool = False) -> None

      Scroll this widget to the center of self.

      The center of the widget will be scrolled to the center of the container.

      :param widget: The widget to scroll to the center of self.
      :param animate: Whether to animate the scroll.
      :param speed: Speed of scroll if animate is `True`; or `None` to use `duration`.
      :param duration: Duration of animation, if `animate` is `True` and `speed` is `None`.
      :param easing: An easing method for the scrolling animation.
      :param force: Force scrolling even when prohibited by overflow styling.
      :param origin_visible: Ensure that the top left corner of the widget remains visible after the scroll.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).
      :param immediate: If `False` the scroll will be deferred until after a screen refresh,
                        set to `True` to scroll immediately.



   .. py:method:: can_view_entire(widget: Widget) -> bool

      Check if a given widget is *fully* within the current view (scrollable area).

      Note: This doesn't necessarily equate to a widget being visible.
      There are other reasons why a widget may not be visible.

      :param widget: A widget that is a descendant of self.

      :returns: `True` if the entire widget is in view, `False` if it is partially visible or not in view.



   .. py:method:: can_view_partial(widget: Widget) -> bool

      Check if a given widget at least partially visible within the current view (scrollable area).

      :param widget: A widget that is a descendant of self.

      :returns: `True` if any part of the widget is visible, `False` if it is outside of the viewable area.



   .. py:method:: __init_subclass__(can_focus: bool | None = None, can_focus_children: bool | None = None, inherit_css: bool = True, inherit_bindings: bool = True) -> None
      :classmethod:



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:method:: get_pseudo_class_state() -> PseudoClasses

      Get an object describing whether each pseudo class is present on this object or not.

      :returns: A PseudoClasses object describing the pseudo classes that are present.



   .. py:method:: post_render(renderable: rich.console.RenderableType, base_style: rich.style.Style) -> rich.console.ConsoleRenderable

      Applies style attributes to the default renderable.

      This method is called by Textual itself.
      It is unlikely you will need to call or implement this method.

      :returns: A new renderable.



   .. py:method:: watch_has_focus(_has_focus: bool) -> None

      Update from CSS if has focus state changes.



   .. py:method:: watch_disabled(disabled: bool) -> None

      Update the styles of the widget and its children when disabled is toggled.



   .. py:property:: visual_style
      :type: textual.style.Style



   .. py:method:: get_selection(selection: textual.selection.Selection) -> tuple[str, str] | None

      Get the text under the selection.

              Args:
                  selection: Selection information.

              Returns:
                  Tuple of extracted text and ending (typically "
      " or " "), or `None` if no text could be extracted.




   .. py:method:: selection_updated(selection: textual.selection.Selection | None) -> None

      Called when the selection is updated.

      :param selection: Selection information or `None` if no selection.



   .. py:method:: render_line(y: int) -> textual.strip.Strip

      Render a line of content.

      :param y: Y Coordinate of line.

      :returns: A rendered line.



   .. py:method:: render_lines(crop: textual.geometry.Region) -> list[textual.strip.Strip]

      Render the widget into lines.

      :param crop: Region within visible area to render.

      :returns: A list of list of segments.



   .. py:method:: get_style_at(x: int, y: int) -> rich.style.Style

      Get the Rich style in a widget at a given relative offset.

      :param x: X coordinate relative to the widget.
      :param y: Y coordinate relative to the widget.

      :returns: A rich Style object.



   .. py:method:: suppress_click() -> None

      Suppress a click event.

      This will prevent a [Click][textual.events.Click] event being sent,
      if called after a mouse down event and before the click itself.




   .. py:method:: refresh(*regions: textual.geometry.Region, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Initiate a refresh of the widget.

      This method sets an internal flag to perform a refresh, which will be done on the
      next idle event. Only one refresh will be done even if this method is called multiple times.

      By default this method will cause the content of the widget to refresh, but not change its size. You can also
      set `layout=True` to perform a layout.

      !!! warning

          It is rarely necessary to call this method explicitly. Updating styles or reactive attributes will
          do this automatically.

      :param \*regions: Additional screen regions to mark as dirty.
      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `Widget` instance.



   .. py:method:: remove() -> textual.await_remove.AwaitRemove

      Remove the Widget from the DOM (effectively deleting it).

      :returns: An awaitable object that waits for the widget to be removed.



   .. py:method:: remove_children(selector: str | type[textual.css.query.QueryType] | Iterable[Widget] = '*') -> textual.await_remove.AwaitRemove

      Remove the immediate children of this Widget from the DOM.

      :param selector: A CSS selector or iterable of widgets to remove.

      :returns: An awaitable object that waits for the direct children to be removed.



   .. py:method:: batch() -> AsyncGenerator[None, None]
      :async:


      Async context manager that combines widget locking and update batching.

      Use this async context manager whenever you want to acquire the widget lock and
      batch app updates at the same time.

      .. rubric:: Example

      ```py
      async with container.batch():
          await container.remove_children(Button)
          await container.mount(Label("All buttons are gone."))
      ```



   .. py:method:: run_action(action: str, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> None
      :async:


      Perform a given action, with this widget as the default namespace.

      :param action: Action encoded as a string.
      :param namespaces: Mapping of namespaces.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Post a message to this widget.

      :param message: Message to post.

      :returns: True if the message was posted, False if this widget was closed / closing.



   .. py:method:: on_prune(event: textual.messages.Prune) -> None
      :async:


      Close message loop when asked to prune.



   .. py:method:: focus(scroll_visible: bool = True) -> typing_extensions.Self

      Give focus to this widget.

      :param scroll_visible: Scroll parent to make this widget visible.

      :returns: The `Widget` instance.



   .. py:method:: blur() -> typing_extensions.Self

      Blur (un-focus) the widget.

      Focus will be moved to the next available widget in the focus chain.

      :returns: The `Widget` instance.



   .. py:method:: capture_mouse(capture: bool = True) -> None

      Capture (or release) the mouse.

      When captured, mouse events will go to this widget even when the pointer is not directly over the widget.

      :param capture: True to capture or False to release.



   .. py:method:: release_mouse() -> None

      Release the mouse.

      Mouse events will only be sent when the mouse is over the widget.



   .. py:method:: text_select_all() -> None

      Select the entire widget.



   .. py:method:: begin_capture_print(stdout: bool = True, stderr: bool = True) -> None

      Capture text from print statements (or writes to stdout / stderr).

      If printing is captured, the widget will be sent an [`events.Print`][textual.events.Print] message.

      Call [`end_capture_print`][textual.widget.Widget.end_capture_print] to disable print capture.

      :param stdout: Whether to capture stdout.
      :param stderr: Whether to capture stderr.



   .. py:method:: end_capture_print() -> None

      End print capture (set with [`begin_capture_print`][textual.widget.Widget.begin_capture_print]).



   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: broker_event(event_name: str, event: textual.events.Event) -> bool
      :async:



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:method:: handle_key(event: textual.events.Key) -> bool
      :async:



   .. py:method:: mount_composed_widgets(widgets: list[Widget]) -> None
      :async:


      Called by Textual to mount widgets after compose.

      There is generally no need to implement this method in your application.
      See [Lazy][textual.lazy.Lazy] for a class which uses this method to implement
      *lazy* mounting.

      :param widgets: A list of child widgets.



   .. py:method:: action_scroll_home() -> None


   .. py:method:: action_scroll_end() -> None


   .. py:method:: action_scroll_left() -> None


   .. py:method:: action_scroll_right() -> None


   .. py:method:: action_scroll_up() -> None


   .. py:method:: action_scroll_down() -> None


   .. py:method:: action_page_down() -> None


   .. py:method:: action_page_up() -> None


   .. py:method:: action_page_left() -> None


   .. py:method:: action_page_right() -> None


   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.

      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      See [`App.notify`][textual.app.App.notify] for the full
      documentation for this method.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information', markup: bool = True) -> None


   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Title of widget used where bindings are displayed (such as in the key panel).


   .. py:attribute:: BINDINGS
      :type:  ClassVar[list[textual.binding.BindingType]]
      :value: []


      A list of key bindings.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view on to the children.

      :returns: The node's children.


   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The app's worker manager. Shortcut for `self.app.workers`.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: screen
      :type: Screen[object]


      The screen containing this node.

      :returns: A screen object.

      :raises NoScreen: If this node isn't mounted (and has no screen).


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:property:: is_dom_root

      Is this a root node (i.e. the App)?


   .. py:attribute:: app


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:property:: log
      :type: textual.Logger


      Get a logger for this object.

      :returns: A logger.


   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:class:: ARCGridApp(driver_class: Type[textual.driver.Driver] | None = None, css_path: textual._path.CSSPathType | None = None, watch_css: bool = False, ansi_color: bool = False)

   Bases: :py:obj:`textual.app.App`


   Textual Application to display the ARC-style grid with switchable rendering modes.


   .. py:attribute:: CSS
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
             Screen {
                 align: center middle;
             }
             """

      .. raw:: html

         </details>



      Inline CSS, useful for quick scripts. This is loaded after CSS_PATH,
      and therefore takes priority in the event of a specificity clash.


   .. py:method:: compose() -> textual.app.ComposeResult

      Yield child widgets for a container.

      This method should be implemented in a subclass.



   .. py:method:: on_button_pressed(event: textual.widgets.Button.Pressed) -> None

      Callback when a mode switch button is pressed.



   .. py:attribute:: DEFAULT_CSS
      :type:  ClassVar[str]

      Default TCSS.


   .. py:attribute:: MODES
      :type:  ClassVar[dict[str, str | Callable[[], textual.screen.Screen]]]

      Modes associated with the app and their base screens.

      The base screen is the screen at the bottom of the mode stack. You can think of
      it as the default screen for that stack.
      The base screens can be names of screens listed in [SCREENS][textual.app.App.SCREENS],
      [`Screen`][textual.screen.Screen] instances, or callables that return screens.

      .. rubric:: Example

      ```py
      class HelpScreen(Screen[None]):
          ...

      class MainAppScreen(Screen[None]):
          ...

      class MyApp(App[None]):
          MODES = {
              "default": "main",
              "help": HelpScreen,
          }

          SCREENS = {
              "main": MainAppScreen,
          }

          ...
      ```


   .. py:attribute:: DEFAULT_MODE
      :type:  ClassVar[str]
      :value: '_default'


      Name of the default mode.


   .. py:attribute:: SCREENS
      :type:  ClassVar[dict[str, Callable[[], textual.screen.Screen[Any]]]]

      Screens associated with the app for the lifetime of the app.


   .. py:attribute:: AUTO_FOCUS
      :type:  ClassVar[str | None]
      :value: '*'


      A selector to determine what to focus automatically when a screen is activated.

      The widget focused is the first that matches the given [CSS selector](/guide/queries/#query-selectors).
      Setting to `None` or `""` disables auto focus.


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      A switch to toggle arbitrary text selection for the app.

      Note that this doesn't apply to Input and TextArea which have builtin support for selection.


   .. py:attribute:: CSS_PATH
      :type:  ClassVar[textual._path.CSSPathType | None]
      :value: None


      File paths to load CSS from.


   .. py:attribute:: TITLE
      :type:  str | None
      :value: None


      A class variable to set the *default* title for the application.

      To update the title while the app is running, you can set the [title][textual.app.App.title] attribute.
      See also [the `Screen.TITLE` attribute][textual.screen.Screen.TITLE].


   .. py:attribute:: SUB_TITLE
      :type:  str | None
      :value: None


      A class variable to set the default sub-title for the application.

      To update the sub-title while the app is running, you can set the [sub_title][textual.app.App.sub_title] attribute.
      See also [the `Screen.SUB_TITLE` attribute][textual.screen.Screen.SUB_TITLE].


   .. py:attribute:: ENABLE_COMMAND_PALETTE
      :type:  ClassVar[bool]
      :value: True


      Should the [command palette][textual.command.CommandPalette] be enabled for the application?


   .. py:attribute:: NOTIFICATION_TIMEOUT
      :type:  ClassVar[float]
      :value: 5


      Default number of seconds to show notifications before removing them.


   .. py:attribute:: COMMANDS
      :type:  ClassVar[set[type[textual.command.Provider] | Callable[[], type[textual.command.Provider]]]]

      Command providers used by the [command palette](/guide/command_palette).

      Should be a set of [command.Provider][textual.command.Provider] classes.


   .. py:attribute:: COMMAND_PALETTE_BINDING
      :type:  ClassVar[str]
      :value: 'ctrl+p'


      The key that launches the command palette (if enabled by [`App.ENABLE_COMMAND_PALETTE`][textual.app.App.ENABLE_COMMAND_PALETTE]).


   .. py:attribute:: COMMAND_PALETTE_DISPLAY
      :type:  ClassVar[str | None]
      :value: None


      How the command palette key should be displayed in the footer (or `None` for default).


   .. py:attribute:: ALLOW_IN_MAXIMIZED_VIEW
      :type:  ClassVar[str]
      :value: 'Footer'


      The default value of [Screen.ALLOW_IN_MAXIMIZED_VIEW][textual.screen.Screen.ALLOW_IN_MAXIMIZED_VIEW].


   .. py:attribute:: CLICK_CHAIN_TIME_THRESHOLD
      :type:  ClassVar[float]
      :value: 0.5


      The maximum number of seconds between clicks to upgrade a single click to a double click,
      a double click to a triple click, etc.


   .. py:attribute:: BINDINGS
      :type:  ClassVar[list[textual.binding.BindingType]]

      The default key bindings.


   .. py:attribute:: CLOSE_TIMEOUT
      :type:  float | None
      :value: 5.0


      Timeout waiting for widget's to close, or `None` for no timeout.


   .. py:attribute:: TOOLTIP_DELAY
      :type:  float
      :value: 0.5


      The time in seconds after which a tooltip gets displayed.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Set to text to show in the key panel.


   .. py:attribute:: ESCAPE_TO_MINIMIZE
      :type:  ClassVar[bool]
      :value: True


      Use escape key to minimize widgets (potentially overriding bindings).

      This is the default value, used if the active screen's `ESCAPE_TO_MINIMIZE` is not changed from `None`.


   .. py:attribute:: INLINE_PADDING
      :type:  ClassVar[int]
      :value: 1


      Number of blank lines above an inline app.


   .. py:attribute:: SUSPENDED_SCREEN_CLASS
      :type:  ClassVar[str]
      :value: ''


      Class to apply to suspended screens, or empty string for no class.


   .. py:attribute:: HORIZONTAL_BREAKPOINTS
      :type:  ClassVar[list[tuple[int, str]]] | None
      :value: []


      List of horizontal breakpoints for responsive classes.

      This allows for styles to be responsive to the dimensions of the terminal.
      For instance, you might want to show less information, or fewer columns on a narrow displays -- or more information when the terminal is sized wider than usual.

      A breakpoint consists of a tuple containing the minimum width where the class should applied, and the name of the class to set.

      Note that only one class name is set, and if you should avoid having more than one breakpoint set for the same size.

      .. rubric:: Example

      ```python
      # Up to 80 cells wide, the app has the class "-normal"
      # 80 - 119 cells wide, the app has the class "-wide"
      # 120 cells or wider, the app has the class "-very-wide"
      HORIZONTAL_BREAKPOINTS = [(0, "-normal"), (80, "-wide"), (120, "-very-wide")]
      ```


   .. py:attribute:: VERTICAL_BREAKPOINTS
      :type:  ClassVar[list[tuple[int, str]]] | None
      :value: []


      List of vertical breakpoints for responsive classes.

      Contents are the same as [`HORIZONTAL_BREAKPOINTS`][textual.app.App.HORIZONTAL_BREAKPOINTS], but the integer is compared to the height, rather than the width.


   .. py:attribute:: title
      :type:  textual.reactive.Reactive[str]

      The title of the app, displayed in the header.


   .. py:attribute:: sub_title
      :type:  textual.reactive.Reactive[str]

      The app's sub-title, combined with [`title`][textual.app.App.title] in the header.


   .. py:attribute:: app_focus

      Indicates if the app has focus.

      When run in the terminal, the app always has focus. When run in the web, the app will
      get focus when the terminal widget has focus.


   .. py:attribute:: theme
      :type:  textual.reactive.Reactive[str]

      The name of the currently active theme.


   .. py:attribute:: ansi_theme_dark

      Maps ANSI colors to hex colors using a Rich TerminalTheme object while using a dark theme.


   .. py:attribute:: ansi_theme_light

      Maps ANSI colors to hex colors using a Rich TerminalTheme object while using a light theme.


   .. py:attribute:: ansi_color

      Allow ANSI colors in UI?


   .. py:attribute:: features
      :type:  frozenset[textual.features.FeatureFlag]


   .. py:attribute:: no_color


   .. py:attribute:: console


   .. py:attribute:: error_console


   .. py:attribute:: driver_class


   .. py:attribute:: mouse_over
      :type:  textual.widget.Widget | None
      :value: None


      The widget directly under the mouse.


   .. py:attribute:: hover_over
      :type:  textual.widget.Widget | None
      :value: None


      The first widget with a hover style under the mouse.


   .. py:attribute:: mouse_captured
      :type:  textual.widget.Widget | None
      :value: None



   .. py:attribute:: mouse_position


   .. py:attribute:: cursor_position

      The position of the terminal cursor in screen-space.

      This can be set by widgets and is useful for controlling the
      positioning of OS IME and emoji popup menus.


   .. py:attribute:: use_command_palette
      :type:  bool
      :value: True


      A flag to say if the application should use the command palette.

      If set to `False` any call to
      [`action_command_palette`][textual.app.App.action_command_palette]
      will be ignored.


   .. py:attribute:: theme_variables
      :type:  dict[str, str]

      Variables generated from the current theme.


   .. py:attribute:: stylesheet


   .. py:attribute:: css_path


   .. py:attribute:: scroll_sensitivity_x
      :type:  float
      :value: 4.0


      Number of columns to scroll in the X direction with wheel or trackpad.


   .. py:attribute:: scroll_sensitivity_y
      :type:  float
      :value: 2.0


      Number of lines to scroll in the Y direction with wheel or trackpad.


   .. py:attribute:: devtools
      :type:  textual_dev.client.DevtoolsClient | None
      :value: None



   .. py:attribute:: css_monitor


   .. py:attribute:: theme_changed_signal
      :type:  textual.signal.Signal[textual.theme.Theme]

      Signal that is published when the App's theme is changed.

      Subscribers will receive the new theme object as an argument to the callback.


   .. py:attribute:: app_suspend_signal
      :type:  textual.signal.Signal[App]

      The signal that is published when the app is suspended.

      When [`App.suspend`][textual.app.App.suspend] is called this signal
      will be [published][textual.signal.Signal.publish];
      [subscribe][textual.signal.Signal.subscribe] to this signal to
      perform work before the suspension takes place.


   .. py:attribute:: app_resume_signal
      :type:  textual.signal.Signal[App]

      The signal that is published when the app is resumed after a suspend.

      When the app is resumed after a
      [`App.suspend`][textual.app.App.suspend] call this signal will be
      [published][textual.signal.Signal.publish];
      [subscribe][textual.signal.Signal.subscribe] to this signal to
      perform work after the app has resumed.


   .. py:attribute:: animation_level
      :type:  textual._types.AnimationLevel

      Determines what type of animations the app will display.

      See [`textual.constants.TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS].


   .. py:attribute:: supports_smooth_scrolling
      :type:  bool
      :value: False


      Does the terminal support smooth scrolling?


   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get currently enabled line filters.

      :returns: A list of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: __init_subclass__(*args, **kwargs) -> None
      :classmethod:



   .. py:method:: validate_title(title: Any) -> str

      Make sure the title is set to a string.



   .. py:method:: validate_sub_title(sub_title: Any) -> str

      Make sure the subtitle is set to a string.



   .. py:property:: default_screen
      :type: textual.screen.Screen


      The default screen instance.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The [worker](/guide/workers/) manager.

      :returns: An object to manage workers.


   .. py:property:: return_value
      :type: ReturnType | None


      The return value of the app, or `None` if it has not yet been set.

      The return value is set when calling [exit][textual.app.App.exit].


   .. py:property:: return_code
      :type: int | None


      The return code with which the app exited.

      Non-zero codes indicate errors.
      A value of 1 means the app exited with a fatal error.
      If the app hasn't exited yet, this will be `None`.

      .. rubric:: Example

      The return code can be used to exit the process via `sys.exit`.
      ```py
      my_app.run()
      sys.exit(my_app.return_code)
      ```


   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view onto the app's immediate children.

      This attribute exists on all widgets.
      In the case of the App, it will only ever contain a single child, which will
      be the currently active screen.

      :returns: A sequence of widgets.


   .. py:property:: clipboard
      :type: str


      The value of the local clipboard.

      Note, that this only contains text copied in the app, and not
      text copied from elsewhere in the OS.


   .. py:method:: format_title(title: str, sub_title: str) -> textual.content.Content

      Format the title for display.

      :param title: The title.
      :param sub_title: The sub title.

      :returns: Content instance with title and subtitle.



   .. py:method:: batch_update() -> Generator[None, None, None]

      A context manager to suspend all repaints until the end of the batch.



   .. py:method:: delay_update(delay: float = 0.05) -> None

      Delay updates for a short period of time.

      May be used to mask a brief transition.
      Consider this method only if you aren't able to use `App.batch_update`.

      :param delay: Delay before updating.



   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      See the guide for how to use the [animation](/guide/animation) system.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: is_dom_root
      :type: bool


      Is this a root node (i.e. the App)?


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: debug
      :type: bool


      Is debug mode enabled?


   .. py:property:: is_headless
      :type: bool


      Is the app running in 'headless' mode?

      Headless mode is used when running tests with [run_test][textual.app.App.run_test].


   .. py:property:: is_inline
      :type: bool


      Is the app running in 'inline' mode?


   .. py:property:: is_web
      :type: bool


      Is the app running in 'web' mode via a browser?


   .. py:property:: screen_stack
      :type: list[textual.screen.Screen[Any]]


      A snapshot of the current screen stack.

      :returns: A snapshot of the current state of the screen stack.


   .. py:property:: current_mode
      :type: str


      The name of the currently active mode.


   .. py:property:: console_options
      :type: rich.console.ConsoleOptions


      Get options for the Rich console.

      :returns: Console options (same object returned from `console.options`).


   .. py:method:: exit(result: ReturnType | None = None, return_code: int = 0, message: rich.console.RenderableType | None = None) -> None

      Exit the app, and return the supplied result.

      :param result: Return value.
      :param return_code: The return code. Use non-zero values for error codes.
      :param message: Optional message to display on exit.



   .. py:property:: focused
      :type: textual.widget.Widget | None


      The widget that is focused on the currently active screen, or `None`.

      Focused widgets receive keyboard input.

      :returns: The currently focused widget, or `None` if nothing is focused.


   .. py:property:: active_bindings
      :type: dict[str, textual.screen.ActiveBinding]


      Get currently active bindings.

      If no widget is focused, then app-level bindings are returned.
      If a widget is focused, then any bindings present in the active screen and app are merged and returned.

      This property may be used to inspect current bindings.

      :returns: A dict that maps keys on to binding information.


   .. py:method:: get_system_commands(screen: textual.screen.Screen) -> Iterable[SystemCommand]

      A generator of system commands used in the command palette.

      :param screen: The screen where the command palette was invoked from.

      Implement this method in your App subclass if you want to add custom commands.
      Here is an example:

      ```python
      def get_system_commands(self, screen: Screen) -> Iterable[SystemCommand]:
          yield from super().get_system_commands(screen)
          yield SystemCommand("Bell", "Ring the bell", self.bell)
      ```

      !!! note
          Requires that [`SystemCommandsProvider`][textual.system_commands.SystemCommandsProvider] is in `App.COMMANDS` class variable.

      :Yields: [SystemCommand][textual.app.SystemCommand] instances.



   .. py:method:: get_default_screen() -> textual.screen.Screen

      Get the default screen.

      This is called when the App is first composed. The returned screen instance
      will be the first screen on the stack.

      Implement this method if you would like to use a custom Screen as the default screen.

      :returns: A screen instance.



   .. py:method:: get_theme_variable_defaults() -> dict[str, str]

      Get the default values for the `variables` used in a theme.

      If the currently specified theme doesn't define a value for a variable,
      the value specified here will be used as a fallback.

      If a variable is referenced in CSS but does not appear either here
      or in the theme, the CSS will fail to parse on startup.

      This method allows applications to define their own variables, beyond
      those offered by Textual, which can then be overridden by a Theme.

      :returns: A mapping of variable name (e.g. "my-button-background-color") to value.
                Values can be any valid CSS value, e.g. "red 50%", "auto 90%",
                "#ff0000", "rgb(255, 0, 0)", etc.



   .. py:method:: get_css_variables() -> dict[str, str]

      Get a mapping of variables used to pre-populate CSS.

      May be implemented in a subclass to add new CSS variables.

      :returns: A mapping of variable name to value.



   .. py:method:: get_theme(theme_name: str) -> textual.theme.Theme | None

      Get a theme by name.

      :param theme_name: The name of the theme to get. May also be a comma
                         separated list of names, to pick the first available theme.

      :returns: A Theme instance and None if the theme doesn't exist.



   .. py:method:: register_theme(theme: textual.theme.Theme) -> None

      Register a theme with the app.

      If the theme already exists, it will be overridden.

      After registering a theme, you can activate it by setting the
      `App.theme` attribute. To retrieve a registered theme, use the
      `App.get_theme` method.

      :param theme: The theme to register.



   .. py:method:: unregister_theme(theme_name: str) -> None

      Unregister a theme with the app.

      :param theme_name: The name of the theme to unregister.



   .. py:property:: available_themes
      :type: dict[str, textual.theme.Theme]


      All available themes (all built-in themes plus any that have been registered).

      A dictionary mapping theme names to Theme instances.


   .. py:property:: current_theme
      :type: textual.theme.Theme



   .. py:method:: watch_ansi_theme_dark(theme: rich.terminal_theme.TerminalTheme) -> None


   .. py:method:: watch_ansi_theme_light(theme: rich.terminal_theme.TerminalTheme) -> None


   .. py:property:: ansi_theme
      :type: rich.terminal_theme.TerminalTheme


      The ANSI TerminalTheme currently being used.

      Defines how colors defined as ANSI (e.g. `magenta`) inside Rich renderables
      are mapped to hex codes.


   .. py:method:: get_driver_class() -> Type[textual.driver.Driver]

      Get a driver class for this platform.

      This method is called by the constructor, and unlikely to be required when
      building a Textual app.

      :returns: A Driver class which manages input and display.



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:property:: animator
      :type: textual._animator.Animator


      The animator object.


   .. py:property:: screen
      :type: textual.screen.Screen[object]


      The current active screen.

      :returns: The currently active (visible) screen.

      :raises ScreenStackError: If there are no screens on the stack.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the terminal.

      :returns: Size of the terminal.


   .. py:property:: viewport_size
      :type: textual.geometry.Size


      Get the viewport size (size of the screen).


   .. py:property:: log
      :type: textual.Logger


      The textual logger.

      .. rubric:: Example

      ```python
      self.log("Hello, World!")
      self.log(self.tree)
      ```

      :returns: A Textual logger.


   .. py:method:: get_loading_widget() -> textual.widget.Widget

      Get a widget to be used as a loading indicator.

      Extend this method if you want to display the loading state a little differently.

      :returns: A widget to display a loading state.



   .. py:method:: copy_to_clipboard(text: str) -> None

      Copy text to the clipboard.

      !!! note

          This does not work on macOS Terminal, but will work on most other terminals.

      :param text: Text you wish to copy to the clipboard.



   .. py:method:: call_from_thread(callback: Callable[Ellipsis, CallThreadReturnType | Awaitable[CallThreadReturnType]], *args: Any, **kwargs: Any) -> CallThreadReturnType

      Run a callable from another thread, and return the result.

      Like asyncio apps in general, Textual apps are not thread-safe. If you call methods
      or set attributes on Textual objects from a thread, you may get unpredictable results.

      This method will ensure that your code runs within the correct context.

      !!! tip

          Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.

      :param callback: A callable to run.
      :param \*args: Arguments to the callback.
      :param \*\*kwargs: Keyword arguments for the callback.

      :raises RuntimeError: If the app isn't running or if this method is called from the same
          thread where the app is running.

      :returns: The result of the callback.



   .. py:method:: action_change_theme() -> None

      An [action](/guide/actions) to change the current theme.



   .. py:method:: action_screenshot(filename: str | None = None, path: str | None = None) -> None

      This [action](/guide/actions) will save an SVG file containing the current contents of the screen.

      :param filename: Filename of screenshot, or None to auto-generate.
      :param path: Path to directory. Defaults to the user's Downloads directory.



   .. py:method:: export_screenshot(*, title: str | None = None, simplify: bool = False) -> str

      Export an SVG screenshot of the current screen.

      See also [save_screenshot][textual.app.App.save_screenshot] which writes the screenshot to a file.

      :param title: The title of the exported screenshot or None
                    to use app title.
      :param simplify: Simplify the segments by combining contiguous segments with the same style.



   .. py:method:: save_screenshot(filename: str | None = None, path: str | None = None, time_format: str | None = None) -> str

      Save an SVG screenshot of the current screen.

      :param filename: Filename of SVG screenshot, or None to auto-generate
                       a filename with the date and time.
      :param path: Path to directory for output. Defaults to current working directory.
      :param time_format: Date and time format to use if filename is None.
                          Defaults to a format like ISO 8601 with some reserved characters replaced with underscores.

      :returns: Filename of screenshot.



   .. py:method:: deliver_screenshot(filename: str | None = None, path: str | None = None, time_format: str | None = None) -> str | None

      Deliver a screenshot of the app.

      This will save the screenshot when running locally, or serve it when the app
      is running in a web browser.

      :param filename: Filename of SVG screenshot, or None to auto-generate
                       a filename with the date and time.
      :param path: Path to directory for output when saving locally (not used when app is running in the browser).
                   Defaults to current working directory.
      :param time_format: Date and time format to use if filename is None.
                          Defaults to a format like ISO 8601 with some reserved characters replaced with underscores.

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:method:: search_commands(commands: Sequence[textual.command.CommandListItem], placeholder: str = 'Search for commands') -> textual.widget.AwaitMount

      Show a list of commands in the app.

      :param commands: A list of SimpleCommand instances.
      :param placeholder: Placeholder text for the search field.

      :returns: An awaitable that resolves when the commands are shown.
      :rtype: AwaitMount



   .. py:method:: search_themes() -> None

      Show a fuzzy search command palette containing all registered themes.

      Selecting a theme in the list will change the app's theme.



   .. py:method:: bind(keys: str, action: str, *, description: str = '', show: bool = True, key_display: str | None = None) -> None

      Bind a key to an action.

      !!! warning
          This method may be private or removed in a future version of Textual.
          See [dynamic actions](/guide/actions#dynamic-actions) for a more flexible alternative to updating bindings.

      :param keys: A comma separated list of keys, i.e.
      :param action: Action to bind to.
      :param description: Short description of action.
      :param show: Show key in UI.
      :param key_display: Replacement text for key, or None to use default.



   .. py:method:: get_key_display(binding: textual.binding.Binding) -> str

      Format a bound key for display in footer / key panel etc.

      !!! note
          You can implement this in a subclass if you want to change how keys are displayed in your app.

      :param binding: A Binding.

      :returns: A string used to represent the key.



   .. py:method:: begin_capture_print(target: textual._types.MessageTarget, stdout: bool = True, stderr: bool = True) -> None

      Capture content that is printed (or written to stdout / stderr).

      If printing is captured, the `target` will be sent an [events.Print][textual.events.Print] message.

      :param target: The widget where print content will be sent.
      :param stdout: Capture stdout.
      :param stderr: Capture stderr.



   .. py:method:: end_capture_print(target: textual._types.MessageTarget) -> None

      End capturing of prints.

      :param target: The widget that was capturing prints.



   .. py:method:: run_test(*, headless: bool = True, size: tuple[int, int] | None = (80, 24), tooltips: bool = False, notifications: bool = False, message_hook: Callable[[textual.message.Message], None] | None = None) -> AsyncGenerator[textual.pilot.Pilot[ReturnType], None]
      :async:


      An asynchronous context manager for testing apps.

      !!! tip

          See the guide for [testing](/guide/testing) Textual apps.

      Use this to run your app in "headless" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.

      .. rubric:: Example

      ```python
      async with app.run_test() as pilot:
          await pilot.click("#Button.ok")
          assert ...
      ```

      :param headless: Run in headless mode (no output or input).
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param tooltips: Enable tooltips when testing.
      :param notifications: Enable notifications when testing.
      :param message_hook: An optional callback that will be called each time any message arrives at any
                           message pump in the app.



   .. py:method:: run_async(*, headless: bool = False, inline: bool = False, inline_no_clear: bool = False, mouse: bool = True, size: tuple[int, int] | None = None, auto_pilot: AutopilotCallbackType | None = None) -> ReturnType | None
      :async:


      Run the app asynchronously.

      :param headless: Run in headless mode (no output).
      :param inline: Run the app inline (under the prompt).
      :param inline_no_clear: Don't clear the app output when exiting an inline app.
      :param mouse: Enable mouse support.
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param auto_pilot: An autopilot coroutine.

      :returns: App return value.



   .. py:method:: run(*, headless: bool = False, inline: bool = False, inline_no_clear: bool = False, mouse: bool = True, size: tuple[int, int] | None = None, auto_pilot: AutopilotCallbackType | None = None, loop: asyncio.AbstractEventLoop | None = None) -> ReturnType | None

      Run the app.

      :param headless: Run in headless mode (no output).
      :param inline: Run the app inline (under the prompt).
      :param inline_no_clear: Don't clear the app output when exiting an inline app.
      :param mouse: Enable mouse support.
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param auto_pilot: An auto pilot coroutine.
      :param loop: Asyncio loop instance, or `None` to use default.

      :returns: App return value.



   .. py:method:: render() -> RenderResult

      Render method, inherited from widget, to render the screen's background.

      May be overridden to customize background visuals.




   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> textual.widget.Widget

      Get the first child (immediate descendant) of this DOMNode with the given ID.

      :param id: The ID of the node to search for.
      :param expect_type: Require the object be of the supplied type,
                          or use `None` to apply no type restriction.

      :returns: The first child of this node with the specified ID.

      :raises NoMatches: If no children could be found for this ID.
      :raises WrongType: If the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> textual.widget.Widget

      Get the first descendant widget with the given ID.

      Performs a breadth-first search rooted at the current screen.
      It will not return the Screen if that matches the ID.
      To get the screen, use `self.screen`.

      :param id: The ID to search for in the subtree
      :param expect_type: Require the object be of the supplied type, or None for any type.
                          Defaults to None.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get a child of a give type.

      :param expect_type: The type of the expected child.

      :raises NoMatches: If no valid child is found.

      :returns: A widget.



   .. py:method:: update_styles(node: textual.dom.DOMNode) -> None

      Immediately update the styles of this node and all descendant nodes.

      Should be called whenever CSS classes / pseudo classes change.
      For example, when you hover over a button, the :hover pseudo class
      will be added, and this method is called to apply the corresponding
      :hover styles.



   .. py:method:: mount(*widgets: textual.widget.Widget, before: int | str | textual.widget.Widget | None = None, after: int | str | textual.widget.Widget | None = None) -> textual.widget.AwaitMount

      Mount the given widgets relative to the app's screen.

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_all(widgets: Iterable[textual.widget.Widget], *, before: int | str | textual.widget.Widget | None = None, after: int | str | textual.widget.Widget | None = None) -> textual.widget.AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: switch_mode(mode: str) -> textual.widget.AwaitMount

      Switch to a given mode.

      :param mode: The mode to switch to.

      :returns:

                An optionally awaitable object which waits for the screen associated
                    with the mode to be mounted.

      :raises UnknownModeError: If trying to switch to an unknown mode.



   .. py:method:: add_mode(mode: str, base_screen: str | Callable[[], textual.screen.Screen]) -> None

      Adds a mode and its corresponding base screen to the app.

      :param mode: The new mode.
      :param base_screen: The base screen associated with the given mode.

      :raises InvalidModeError: If the name of the mode is not valid/duplicated.



   .. py:method:: remove_mode(mode: str) -> textual.await_complete.AwaitComplete

      Removes a mode from the app.

      Screens that are running in the stack of that mode are scheduled for pruning.

      :param mode: The mode to remove. It can't be the active mode.

      :raises ActiveModeError: If trying to remove the active mode.
      :raises UnknownModeError: If trying to remove an unknown mode.



   .. py:method:: is_screen_installed(screen: textual.screen.Screen | str) -> bool

      Check if a given screen has been installed.

      :param screen: Either a Screen object or screen name (the `name` argument when installed).

      :returns: True if the screen is currently installed,



   .. py:method:: get_screen(screen: ScreenType) -> ScreenType
                  get_screen(screen: str) -> textual.screen.Screen
                  get_screen(screen: str, screen_class: Type[ScreenType] | None = None) -> ScreenType
                  get_screen(screen: ScreenType, screen_class: Type[ScreenType] | None = None) -> ScreenType

      Get an installed screen.

      .. rubric:: Example

      ```python
      my_screen = self.get_screen("settings", MyScreen)
      ```

      :param screen: Either a Screen object or screen name (the `name` argument when installed).
      :param screen_class: Class of expected screen, or `None` for any screen class.

      :raises KeyError: If the named screen doesn't exist.

      :returns: A screen instance.



   .. py:method:: push_screen(screen: textual.screen.Screen[textual.screen.ScreenResultType] | str, callback: textual.screen.ScreenResultCallbackType[textual.screen.ScreenResultType] | None = None, wait_for_dismiss: typing_extensions.Literal[False] = False) -> textual.widget.AwaitMount

      Push a new [screen](/guide/screens) on the screen stack, making it the current screen.

      :param screen: A Screen instance or the name of an installed screen.
      :param callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.
      :param wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting
                               this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.

      :raises NoActiveWorker: If using `wait_for_dismiss` outside of a worker.

      :returns:

                An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future
                    to await the result of the screen.



   .. py:method:: push_screen_wait(screen: textual.screen.Screen[textual.screen.ScreenResultType]) -> textual.screen.ScreenResultType
      :async:


      Push a screen and wait for the result (received from [`Screen.dismiss`][textual.screen.Screen.dismiss]).

      Note that this method may only be called when running in a worker.

      :param screen: A screen or the name of an installed screen.

      :returns: The screen's result.



   .. py:method:: switch_screen(screen: textual.screen.Screen | str) -> textual.await_complete.AwaitComplete

      Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.

      :param screen: Either a Screen object or screen name (the `name` argument when installed).



   .. py:method:: install_screen(screen: textual.screen.Screen, name: str) -> None

      Install a screen.

      Installing a screen prevents Textual from destroying it when it is no longer on the screen stack.
      Note that you don't need to install a screen to use it. See [push_screen][textual.app.App.push_screen]
      or [switch_screen][textual.app.App.switch_screen] to make a new screen current.

      :param screen: Screen to install.
      :param name: Unique name to identify the screen.

      :raises ScreenError: If the screen can't be installed.

      :returns: An awaitable that awaits the mounting of the screen and its children.



   .. py:method:: uninstall_screen(screen: textual.screen.Screen | str) -> str | None

      Uninstall a screen.

      If the screen was not previously installed, then this method is a null-op.
      Uninstalling a screen allows Textual to delete it when it is popped or switched.
      Note that uninstalling a screen is only required if you have previously installed it
      with [install_screen][textual.app.App.install_screen].
      Textual will also uninstall screens automatically on exit.

      :param screen: The screen to uninstall or the name of an installed screen.

      :returns: The name of the screen that was uninstalled, or None if no screen was uninstalled.



   .. py:method:: pop_screen() -> textual.await_complete.AwaitComplete

      Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.

      :returns: The screen that was replaced.



   .. py:method:: set_focus(widget: textual.widget.Widget | None, scroll_visible: bool = True) -> None

      Focus (or unfocus) a widget. A focused widget will receive key events first.

      :param widget: Widget to focus.
      :param scroll_visible: Scroll widget into view.



   .. py:method:: capture_mouse(widget: textual.widget.Widget | None) -> None

      Send all mouse events to the given widget or disable mouse capture.

      Normally mouse events are sent to the widget directly under the pointer.
      Capturing the mouse allows a widget to receive mouse events even when the pointer is over another widget.

      :param widget: Widget to capture mouse events, or `None` to end mouse capture.



   .. py:method:: panic(*renderables: rich.console.RenderableType) -> None

      Exits the app and display error message(s).

      Used in response to unexpected errors.
      For a more graceful exit, see the [exit][textual.app.App.exit] method.

      :param \*renderables: Text or Rich renderable(s) to display on exit.



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: is_mounted(widget: textual.widget.Widget) -> bool

      Check if a widget is mounted.

      :param widget: A widget.

      :returns: True of the widget is mounted.



   .. py:method:: refresh(*, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Refresh the entire screen.

      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `App` instance.



   .. py:method:: refresh_css(animate: bool = True) -> None

      Refresh CSS.

      :param animate: Also execute CSS animations.



   .. py:method:: post_display_hook() -> None

      Called immediately after a display is done. Used in tests.



   .. py:method:: get_widget_at(x: int, y: int) -> tuple[textual.widget.Widget, textual.geometry.Region]

      Get the widget under the given coordinates.

      :param x: X coordinate.
      :param y: Y coordinate.

      :returns: The widget and the widget's screen region.



   .. py:method:: bell() -> None

      Play the console 'bell'.

      For terminals that support a bell, this typically makes a notification or error sound.
      Some terminals may make no sound or display a visual bell indicator, depending on configuration.



   .. py:method:: simulate_key(key: str) -> None

      Simulate a key press.

      This will perform the same action as if the user had pressed the key.

      :param key: Key to simulate. May also be the name of a key, e.g. "space".



   .. py:method:: action_help_quit() -> None

      Bound to ctrl+C to alert the user that it no longer quits.



   .. py:method:: set_keymap(keymap: textual.binding.Keymap) -> None

      Set the keymap, a mapping of binding IDs to key strings.

      Bindings in the keymap are used to override default key bindings,
      i.e. those defined in `BINDINGS` class variables.

      Bindings with IDs that are present in the keymap will have
      their key string replaced with the value from the keymap.

      :param keymap: A mapping of binding IDs to key strings.



   .. py:method:: update_keymap(keymap: textual.binding.Keymap) -> None

      Update the App's keymap, merging with `keymap`.

      If a Binding ID exists in both the App's keymap and the `keymap`
      argument, the `keymap` argument takes precedence.

      :param keymap: A mapping of binding IDs to key strings.



   .. py:method:: handle_bindings_clash(clashed_bindings: set[textual.binding.Binding], node: textual.dom.DOMNode) -> None

      Handle a clash between bindings.

      Bindings clashes are likely due to users setting conflicting
      keys via their keymap.

      This method is intended to be overridden by subclasses.

      Textual will call this each time a clash is encountered -
      which may be on each keypress if a clashing widget is focused
      or is in the bindings chain.

      :param clashed_bindings: The bindings that are clashing.
      :param node: The node that has the clashing bindings.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:property:: escape_to_minimize
      :type: bool


      Use the escape key to minimize?

      When a widget is [maximized][textual.screen.Screen.maximize], this boolean determines if the `escape` key will
      minimize the widget (potentially overriding any bindings).

      The default logic is to use the screen's `ESCAPE_TO_MINIMIZE` classvar if it is set to `True` or `False`.
      If the classvar on the screen is *not* set (and left as `None`), then the app's `ESCAPE_TO_MINIMIZE` is used.


   .. py:method:: run_action(action: str | textual.actions.ActionParseResult, default_namespace: textual.dom.DOMNode | None = None, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> bool
      :async:


      Perform an [action](/guide/actions).

      Actions are typically associated with key bindings, where you wouldn't need to call this method manually.

      :param action: Action encoded in a string.
      :param default_namespace: Namespace to use if not provided in the action,
                                or None to use app.
      :param namespaces: Mapping of namespaces.

      :returns: True if the event has been handled.



   .. py:method:: action_simulate_key(key: str) -> None
      :async:


      An [action](/guide/actions) to simulate a key press.

      This will invoke the same actions as if the user had pressed the key.

      :param key: The key to process.



   .. py:method:: action_quit() -> None
      :async:


      An [action](/guide/actions) to quit the app as soon as possible.



   .. py:method:: action_bell() -> None
      :async:


      An [action](/guide/actions) to play the terminal 'bell'.



   .. py:method:: action_focus(widget_id: str) -> None
      :async:


      An [action](/guide/actions) to focus the given widget.

      :param widget_id: ID of widget to focus.



   .. py:method:: action_switch_screen(screen: str) -> None
      :async:


      An [action](/guide/actions) to switch screens.

      :param screen: Name of the screen.



   .. py:method:: action_push_screen(screen: str) -> None
      :async:


      An [action](/guide/actions) to push a new screen on to the stack and make it active.

      :param screen: Name of the screen.



   .. py:method:: action_pop_screen() -> None
      :async:


      An [action](/guide/actions) to remove the topmost screen and makes the new topmost screen active.



   .. py:method:: action_switch_mode(mode: str) -> None
      :async:


      An [action](/guide/actions) that switches to the given mode.



   .. py:method:: action_back() -> None
      :async:


      An [action](/guide/actions) to go back to the previous screen (pop the current screen).

      .. note::

         If there is no screen to go back to, this is a non-operation (in
         other words it's safe to call even if there are no other screens
         on the stack.)



   .. py:method:: action_add_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to add a CSS class to the selected widget.

      :param selector: Selects the widget to add the class to.
      :param class_name: The class to add to the selected widget.



   .. py:method:: action_remove_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to remove a CSS class from the selected widget.

      :param selector: Selects the widget to remove the class from.
      :param class_name: The class to remove from  the selected widget.



   .. py:method:: action_toggle_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to toggle a CSS class on the selected widget.

      :param selector: Selects the widget to toggle the class on.
      :param class_name: The class to toggle on the selected widget.



   .. py:method:: action_toggle_dark() -> None

      An [action](/guide/actions) to toggle the theme between textual-light
      and textual-dark. This is offered as a convenience to simplify backwards
      compatibility with previous versions of Textual which only had light mode
      and dark mode.



   .. py:method:: action_focus_next() -> None

      An [action](/guide/actions) to focus the next widget.



   .. py:method:: action_focus_previous() -> None

      An [action](/guide/actions) to focus the previous widget.



   .. py:method:: action_hide_help_panel() -> None

      Hide the keys panel (if present).



   .. py:method:: action_show_help_panel() -> None

      Show the keys panel.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information') -> None

      Show a notification.



   .. py:method:: clear_selection() -> None

      Clear text selection on the active screen.



   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.


      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      The `notify` method is used to create an application-wide
      notification, shown in a [`Toast`][textual.widgets._toast.Toast],
      normally originating in the bottom right corner of the display.

      Notifications can have the following severity levels:

      - `information`
      - `warning`
      - `error`

      The default is `information`.

      .. rubric:: Example

      ```python
      # Show an information notification.
      self.notify("It's an older code, sir, but it checks out.")

      # Show a warning. Note that Textual's notification system allows
      # for the use of Rich console markup.
      self.notify(
          "Now witness the firepower of this fully "
          "[b]ARMED[/b] and [i][b]OPERATIONAL[/b][/i] battle station!",
          title="Possible trap detected",
          severity="warning",
      )

      # Show an error. Set a longer timeout so it's noticed.
      self.notify("It's a trap!", severity="error", timeout=10)

      # Show an information notification, but without any sort of title.
      self.notify("It's against my programming to impersonate a deity.", title="")
      ```



   .. py:method:: clear_notifications() -> None

      Clear all the current notifications.



   .. py:method:: action_command_palette() -> None

      Show the Textual command palette.



   .. py:method:: suspend() -> Iterator[None]

      A context manager that temporarily suspends the app.

      While inside the `with` block, the app will stop reading input and
      emitting output. Other applications will have full control of the
      terminal, configured as it was before the app started running. When
      the `with` block ends, the application will start reading input and
      emitting output again.

      .. rubric:: Example

      ```python
      with self.suspend():
          os.system("emacs -nw")
      ```

      :raises SuspendNotSupported: If the environment doesn't support suspending.

      !!! note
          Suspending the application is currently only supported on
          Unix-like operating systems and Microsoft Windows. Suspending is
          not supported in Textual Web.



   .. py:method:: action_suspend_process() -> None

      Suspend the process into the background.

      .. note::

         On Unix and Unix-like systems a `SIGTSTP` is sent to the
         application's process. Currently on Windows and when running
         under Textual Web this is a non-operation.



   .. py:method:: open_url(url: str, *, new_tab: bool = True) -> None

      Open a URL in the default web browser.

      :param url: The URL to open.
      :param new_tab: Whether to open the URL in a new tab.



   .. py:method:: deliver_text(path_or_file: str | pathlib.Path | TextIO, *, save_directory: str | pathlib.Path | None = None, save_filename: str | None = None, open_method: typing_extensions.Literal[browser, download] = 'download', encoding: str | None = None, mime_type: str | None = None, name: str | None = None) -> str | None

      Deliver a text file to the end-user of the application.

      If a TextIO object is supplied, it will be closed by this method
      and *must not be used* after this method is called.

      If running in a terminal, this will save the file to the user's
      downloads directory.

      If running via a web browser, this will initiate a download via
      a single-use URL.

      After the file has been delivered, a `DeliveryComplete` message will be posted
      to this `App`, which contains the `delivery_key` returned by this method. By
      handling this message, you can add custom logic to your application that fires
      only after the file has been delivered.

      :param path_or_file: The path or file-like object to save.
      :param save_directory: The directory to save the file to.
      :param save_filename: The filename to save the file to.  If `path_or_file`
                            is a file-like object, the filename will be generated from
                            the `name` attribute if available. If `path_or_file` is a path
                            the filename will be generated from the path.
      :param encoding: The encoding to use when saving the file. If `None`,
                       the encoding will be determined by supplied file-like object
                       (if possible). If this is not possible, 'utf-8' will be used.
      :param mime_type: The MIME type of the file or None to guess based on file extension.
                        If no MIME type is supplied and we cannot guess the MIME type, from the
                        file extension, the MIME type will be set to "text/plain".
      :param name: A user-defined named which will be returned in [`DeliveryComplete`][textual.events.DeliveryComplete]
                   and [`DeliveryComplete`][textual.events.DeliveryComplete].

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:method:: deliver_binary(path_or_file: str | pathlib.Path | BinaryIO, *, save_directory: str | pathlib.Path | None = None, save_filename: str | None = None, open_method: typing_extensions.Literal[browser, download] = 'download', mime_type: str | None = None, name: str | None = None) -> str | None

      Deliver a binary file to the end-user of the application.

      If an IO object is supplied, it will be closed by this method
      and *must not be used* after it is supplied to this method.

      If running in a terminal, this will save the file to the user's
      downloads directory.

      If running via a web browser, this will initiate a download via
      a single-use URL.

      This operation runs in a thread when running on web, so this method
      returning does not indicate that the file has been delivered.

      After the file has been delivered, a `DeliveryComplete` message will be posted
      to this `App`, which contains the `delivery_key` returned by this method. By
      handling this message, you can add custom logic to your application that fires
      only after the file has been delivered.

      :param path_or_file: The path or file-like object to save.
      :param save_directory: The directory to save the file to. If None,
                             the default "downloads" directory will be used. This
                             argument is ignored when running via the web.
      :param save_filename: The filename to save the file to. If None, the following logic
                            applies to generate the filename:
                            - If `path_or_file` is a file-like object, the filename will be taken from
                              the `name` attribute if available.
                            - If `path_or_file` is a path, the filename will be taken from the path.
                            - If a filename is not available, a filename will be generated using the
                              App's title and the current date and time.
      :param open_method: The method to use to open the file. "browser" will open the file in the
                          web browser, "download" will initiate a download. Note that this can sometimes
                          be impacted by the browser's settings.
      :param mime_type: The MIME type of the file or None to guess based on file extension.
                        If no MIME type is supplied and we cannot guess the MIME type, from the
                        file extension, the MIME type will be set to "application/octet-stream".
      :param name: A user-defined named which will be returned in [`DeliveryComplete`][textual.events.DeliveryComplete]
                   and [`DeliveryComplete`][textual.events.DeliveryComplete].

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:method:: compose_add_child(widget: textual.widget.Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:attribute:: app


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object.

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Posts a message on to this widget's queue.

      :param message: A message (including Event).

      :returns: `True` if the message was queued for processing, otherwise `False`.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:data:: app

