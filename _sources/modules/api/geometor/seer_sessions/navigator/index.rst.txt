geometor.seer_sessions.navigator
================================

.. py:module:: geometor.seer_sessions.navigator


Attributes
----------

.. autoapisummary::

   geometor.seer_sessions.navigator.PATTERNS
   geometor.seer_sessions.navigator.app


Classes
-------

.. autoapisummary::

   geometor.seer_sessions.navigator.GridApp


Functions
---------

.. autoapisummary::

   geometor.seer_sessions.navigator.make_checkerboard
   geometor.seer_sessions.navigator.make_gradient
   geometor.seer_sessions.navigator.make_random


Module Contents
---------------

.. py:function:: make_checkerboard(size=8)

   Generate an NxN checkerboard pattern with two colors (blue and yellow).


.. py:function:: make_gradient(size=8)

   Generate an NxN gradient pattern (color varies smoothly from one corner to another).


.. py:function:: make_random(size=8)

   Generate an NxN grid of random colors.


.. py:data:: PATTERNS

.. py:class:: GridApp(patterns: dict[str, tuple], **kwargs)

   Bases: :py:obj:`textual.app.App`


   Textual Application that displays buttons to select grid patterns and updates a Matplotlib plot.


   .. py:attribute:: CSS_PATH
      :value: None


      File paths to load CSS from.


   .. py:attribute:: BINDINGS
      :value: [('q', 'quit', 'Quit')]


      The default key bindings.


   .. py:attribute:: patterns


   .. py:attribute:: fig
      :value: None



   .. py:attribute:: ax
      :value: None



   .. py:method:: compose() -> textual.app.ComposeResult

      Create the UI layout with one button per grid pattern.



   .. py:method:: on_mount() -> None

      Called when the app is mounted (initialized). Set up Matplotlib figure here.



   .. py:method:: on_button_pressed(event: textual.widgets.Button.Pressed) -> None

      Event handler for button presses. Updates the Matplotlib plot based on which button was clicked.



   .. py:method:: display_pattern(pattern_key: str) -> None

      Generate and display the grid pattern corresponding to the given key on the Matplotlib plot.



   .. py:method:: on_unmount() -> None

      Called when the app is unmounted. Close the Matplotlib plot.



   .. py:attribute:: CSS
      :type:  ClassVar[str]
      :value: ''


      Inline CSS, useful for quick scripts. This is loaded after CSS_PATH,
      and therefore takes priority in the event of a specificity clash.


   .. py:attribute:: DEFAULT_CSS
      :type:  ClassVar[str]

      Default TCSS.


   .. py:attribute:: MODES
      :type:  ClassVar[dict[str, str | Callable[[], textual.screen.Screen]]]

      Modes associated with the app and their base screens.

      The base screen is the screen at the bottom of the mode stack. You can think of
      it as the default screen for that stack.
      The base screens can be names of screens listed in [SCREENS][textual.app.App.SCREENS],
      [`Screen`][textual.screen.Screen] instances, or callables that return screens.

      .. rubric:: Example

      ```py
      class HelpScreen(Screen[None]):
          ...

      class MainAppScreen(Screen[None]):
          ...

      class MyApp(App[None]):
          MODES = {
              "default": "main",
              "help": HelpScreen,
          }

          SCREENS = {
              "main": MainAppScreen,
          }

          ...
      ```


   .. py:attribute:: DEFAULT_MODE
      :type:  ClassVar[str]
      :value: '_default'


      Name of the default mode.


   .. py:attribute:: SCREENS
      :type:  ClassVar[dict[str, Callable[[], textual.screen.Screen[Any]]]]

      Screens associated with the app for the lifetime of the app.


   .. py:attribute:: AUTO_FOCUS
      :type:  ClassVar[str | None]
      :value: '*'


      A selector to determine what to focus automatically when a screen is activated.

      The widget focused is the first that matches the given [CSS selector](/guide/queries/#query-selectors).
      Setting to `None` or `""` disables auto focus.


   .. py:attribute:: ALLOW_SELECT
      :type:  ClassVar[bool]
      :value: True


      A switch to toggle arbitrary text selection for the app.

      Note that this doesn't apply to Input and TextArea which have builtin support for selection.


   .. py:attribute:: TITLE
      :type:  str | None
      :value: None


      A class variable to set the *default* title for the application.

      To update the title while the app is running, you can set the [title][textual.app.App.title] attribute.
      See also [the `Screen.TITLE` attribute][textual.screen.Screen.TITLE].


   .. py:attribute:: SUB_TITLE
      :type:  str | None
      :value: None


      A class variable to set the default sub-title for the application.

      To update the sub-title while the app is running, you can set the [sub_title][textual.app.App.sub_title] attribute.
      See also [the `Screen.SUB_TITLE` attribute][textual.screen.Screen.SUB_TITLE].


   .. py:attribute:: ENABLE_COMMAND_PALETTE
      :type:  ClassVar[bool]
      :value: True


      Should the [command palette][textual.command.CommandPalette] be enabled for the application?


   .. py:attribute:: NOTIFICATION_TIMEOUT
      :type:  ClassVar[float]
      :value: 5


      Default number of seconds to show notifications before removing them.


   .. py:attribute:: COMMANDS
      :type:  ClassVar[set[type[textual.command.Provider] | Callable[[], type[textual.command.Provider]]]]

      Command providers used by the [command palette](/guide/command_palette).

      Should be a set of [command.Provider][textual.command.Provider] classes.


   .. py:attribute:: COMMAND_PALETTE_BINDING
      :type:  ClassVar[str]
      :value: 'ctrl+p'


      The key that launches the command palette (if enabled by [`App.ENABLE_COMMAND_PALETTE`][textual.app.App.ENABLE_COMMAND_PALETTE]).


   .. py:attribute:: COMMAND_PALETTE_DISPLAY
      :type:  ClassVar[str | None]
      :value: None


      How the command palette key should be displayed in the footer (or `None` for default).


   .. py:attribute:: ALLOW_IN_MAXIMIZED_VIEW
      :type:  ClassVar[str]
      :value: 'Footer'


      The default value of [Screen.ALLOW_IN_MAXIMIZED_VIEW][textual.screen.Screen.ALLOW_IN_MAXIMIZED_VIEW].


   .. py:attribute:: CLICK_CHAIN_TIME_THRESHOLD
      :type:  ClassVar[float]
      :value: 0.5


      The maximum number of seconds between clicks to upgrade a single click to a double click,
      a double click to a triple click, etc.


   .. py:attribute:: CLOSE_TIMEOUT
      :type:  float | None
      :value: 5.0


      Timeout waiting for widget's to close, or `None` for no timeout.


   .. py:attribute:: TOOLTIP_DELAY
      :type:  float
      :value: 0.5


      The time in seconds after which a tooltip gets displayed.


   .. py:attribute:: BINDING_GROUP_TITLE
      :type:  str | None
      :value: None


      Set to text to show in the key panel.


   .. py:attribute:: ESCAPE_TO_MINIMIZE
      :type:  ClassVar[bool]
      :value: True


      Use escape key to minimize widgets (potentially overriding bindings).

      This is the default value, used if the active screen's `ESCAPE_TO_MINIMIZE` is not changed from `None`.


   .. py:attribute:: INLINE_PADDING
      :type:  ClassVar[int]
      :value: 1


      Number of blank lines above an inline app.


   .. py:attribute:: SUSPENDED_SCREEN_CLASS
      :type:  ClassVar[str]
      :value: ''


      Class to apply to suspended screens, or empty string for no class.


   .. py:attribute:: HORIZONTAL_BREAKPOINTS
      :type:  ClassVar[list[tuple[int, str]]] | None
      :value: []


      List of horizontal breakpoints for responsive classes.

      This allows for styles to be responsive to the dimensions of the terminal.
      For instance, you might want to show less information, or fewer columns on a narrow displays -- or more information when the terminal is sized wider than usual.

      A breakpoint consists of a tuple containing the minimum width where the class should applied, and the name of the class to set.

      Note that only one class name is set, and if you should avoid having more than one breakpoint set for the same size.

      .. rubric:: Example

      ```python
      # Up to 80 cells wide, the app has the class "-normal"
      # 80 - 119 cells wide, the app has the class "-wide"
      # 120 cells or wider, the app has the class "-very-wide"
      HORIZONTAL_BREAKPOINTS = [(0, "-normal"), (80, "-wide"), (120, "-very-wide")]
      ```


   .. py:attribute:: VERTICAL_BREAKPOINTS
      :type:  ClassVar[list[tuple[int, str]]] | None
      :value: []


      List of vertical breakpoints for responsive classes.

      Contents are the same as [`HORIZONTAL_BREAKPOINTS`][textual.app.App.HORIZONTAL_BREAKPOINTS], but the integer is compared to the height, rather than the width.


   .. py:attribute:: title
      :type:  textual.reactive.Reactive[str]

      The title of the app, displayed in the header.


   .. py:attribute:: sub_title
      :type:  textual.reactive.Reactive[str]

      The app's sub-title, combined with [`title`][textual.app.App.title] in the header.


   .. py:attribute:: app_focus

      Indicates if the app has focus.

      When run in the terminal, the app always has focus. When run in the web, the app will
      get focus when the terminal widget has focus.


   .. py:attribute:: theme
      :type:  textual.reactive.Reactive[str]

      The name of the currently active theme.


   .. py:attribute:: ansi_theme_dark

      Maps ANSI colors to hex colors using a Rich TerminalTheme object while using a dark theme.


   .. py:attribute:: ansi_theme_light

      Maps ANSI colors to hex colors using a Rich TerminalTheme object while using a light theme.


   .. py:attribute:: ansi_color

      Allow ANSI colors in UI?


   .. py:attribute:: features
      :type:  frozenset[textual.features.FeatureFlag]


   .. py:attribute:: no_color


   .. py:attribute:: console


   .. py:attribute:: error_console


   .. py:attribute:: driver_class


   .. py:attribute:: mouse_over
      :type:  textual.widget.Widget | None
      :value: None


      The widget directly under the mouse.


   .. py:attribute:: hover_over
      :type:  textual.widget.Widget | None
      :value: None


      The first widget with a hover style under the mouse.


   .. py:attribute:: mouse_captured
      :type:  textual.widget.Widget | None
      :value: None



   .. py:attribute:: mouse_position


   .. py:attribute:: cursor_position

      The position of the terminal cursor in screen-space.

      This can be set by widgets and is useful for controlling the
      positioning of OS IME and emoji popup menus.


   .. py:attribute:: use_command_palette
      :type:  bool
      :value: True


      A flag to say if the application should use the command palette.

      If set to `False` any call to
      [`action_command_palette`][textual.app.App.action_command_palette]
      will be ignored.


   .. py:attribute:: theme_variables
      :type:  dict[str, str]

      Variables generated from the current theme.


   .. py:attribute:: stylesheet


   .. py:attribute:: css_path


   .. py:attribute:: scroll_sensitivity_x
      :type:  float
      :value: 4.0


      Number of columns to scroll in the X direction with wheel or trackpad.


   .. py:attribute:: scroll_sensitivity_y
      :type:  float
      :value: 2.0


      Number of lines to scroll in the Y direction with wheel or trackpad.


   .. py:attribute:: devtools
      :type:  textual_dev.client.DevtoolsClient | None
      :value: None



   .. py:attribute:: css_monitor


   .. py:attribute:: theme_changed_signal
      :type:  textual.signal.Signal[textual.theme.Theme]

      Signal that is published when the App's theme is changed.

      Subscribers will receive the new theme object as an argument to the callback.


   .. py:attribute:: app_suspend_signal
      :type:  textual.signal.Signal[App]

      The signal that is published when the app is suspended.

      When [`App.suspend`][textual.app.App.suspend] is called this signal
      will be [published][textual.signal.Signal.publish];
      [subscribe][textual.signal.Signal.subscribe] to this signal to
      perform work before the suspension takes place.


   .. py:attribute:: app_resume_signal
      :type:  textual.signal.Signal[App]

      The signal that is published when the app is resumed after a suspend.

      When the app is resumed after a
      [`App.suspend`][textual.app.App.suspend] call this signal will be
      [published][textual.signal.Signal.publish];
      [subscribe][textual.signal.Signal.subscribe] to this signal to
      perform work after the app has resumed.


   .. py:attribute:: animation_level
      :type:  textual._types.AnimationLevel

      Determines what type of animations the app will display.

      See [`textual.constants.TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS].


   .. py:attribute:: supports_smooth_scrolling
      :type:  bool
      :value: False


      Does the terminal support smooth scrolling?


   .. py:method:: get_line_filters() -> Sequence[textual.filter.LineFilter]

      Get currently enabled line filters.

      :returns: A list of [LineFilter][textual.filters.LineFilter] instances.



   .. py:method:: __init_subclass__(*args, **kwargs) -> None
      :classmethod:



   .. py:method:: validate_title(title: Any) -> str

      Make sure the title is set to a string.



   .. py:method:: validate_sub_title(sub_title: Any) -> str

      Make sure the subtitle is set to a string.



   .. py:property:: default_screen
      :type: textual.screen.Screen


      The default screen instance.


   .. py:property:: workers
      :type: textual.worker_manager.WorkerManager


      The [worker](/guide/workers/) manager.

      :returns: An object to manage workers.


   .. py:property:: return_value
      :type: ReturnType | None


      The return value of the app, or `None` if it has not yet been set.

      The return value is set when calling [exit][textual.app.App.exit].


   .. py:property:: return_code
      :type: int | None


      The return code with which the app exited.

      Non-zero codes indicate errors.
      A value of 1 means the app exited with a fatal error.
      If the app hasn't exited yet, this will be `None`.

      .. rubric:: Example

      The return code can be used to exit the process via `sys.exit`.
      ```py
      my_app.run()
      sys.exit(my_app.return_code)
      ```


   .. py:property:: children
      :type: Sequence[textual.widget.Widget]


      A view onto the app's immediate children.

      This attribute exists on all widgets.
      In the case of the App, it will only ever contain a single child, which will
      be the currently active screen.

      :returns: A sequence of widgets.


   .. py:property:: clipboard
      :type: str


      The value of the local clipboard.

      Note, that this only contains text copied in the app, and not
      text copied from elsewhere in the OS.


   .. py:method:: format_title(title: str, sub_title: str) -> textual.content.Content

      Format the title for display.

      :param title: The title.
      :param sub_title: The sub title.

      :returns: Content instance with title and subtitle.



   .. py:method:: batch_update() -> Generator[None, None, None]

      A context manager to suspend all repaints until the end of the batch.



   .. py:method:: delay_update(delay: float = 0.05) -> None

      Delay updates for a short period of time.

      May be used to mask a brief transition.
      Consider this method only if you aren't able to use `App.batch_update`.

      :param delay: Delay before updating.



   .. py:method:: animate(attribute: str, value: float | textual._animator.Animatable, *, final_value: object = ..., duration: float | None = None, speed: float | None = None, delay: float = 0.0, easing: textual._animator.EasingFunction | str = DEFAULT_EASING, on_complete: textual.messages.CallbackType | None = None, level: textual._types.AnimationLevel = 'full') -> None

      Animate an attribute.

      See the guide for how to use the [animation](/guide/animation) system.

      :param attribute: Name of the attribute to animate.
      :param value: The value to animate to.
      :param final_value: The final value of the animation.
      :param duration: The duration (in seconds) of the animation.
      :param speed: The speed of the animation.
      :param delay: A delay (in seconds) before the animation starts.
      :param easing: An easing method.
      :param on_complete: A callable to invoke when the animation is finished.
      :param level: Minimum level required for the animation to take place (inclusive).



   .. py:method:: stop_animation(attribute: str, complete: bool = True) -> None
      :async:


      Stop an animation on an attribute.

      :param attribute: Name of the attribute whose animation should be stopped.
      :param complete: Should the animation be set to its final value?

      .. note:: If there is no animation scheduled or running, this is a no-op.



   .. py:property:: is_dom_root
      :type: bool


      Is this a root node (i.e. the App)?


   .. py:property:: is_attached
      :type: bool


      Is this node linked to the app through the DOM?


   .. py:property:: debug
      :type: bool


      Is debug mode enabled?


   .. py:property:: is_headless
      :type: bool


      Is the app running in 'headless' mode?

      Headless mode is used when running tests with [run_test][textual.app.App.run_test].


   .. py:property:: is_inline
      :type: bool


      Is the app running in 'inline' mode?


   .. py:property:: is_web
      :type: bool


      Is the app running in 'web' mode via a browser?


   .. py:property:: screen_stack
      :type: list[textual.screen.Screen[Any]]


      A snapshot of the current screen stack.

      :returns: A snapshot of the current state of the screen stack.


   .. py:property:: current_mode
      :type: str


      The name of the currently active mode.


   .. py:property:: console_options
      :type: rich.console.ConsoleOptions


      Get options for the Rich console.

      :returns: Console options (same object returned from `console.options`).


   .. py:method:: exit(result: ReturnType | None = None, return_code: int = 0, message: rich.console.RenderableType | None = None) -> None

      Exit the app, and return the supplied result.

      :param result: Return value.
      :param return_code: The return code. Use non-zero values for error codes.
      :param message: Optional message to display on exit.



   .. py:property:: focused
      :type: textual.widget.Widget | None


      The widget that is focused on the currently active screen, or `None`.

      Focused widgets receive keyboard input.

      :returns: The currently focused widget, or `None` if nothing is focused.


   .. py:property:: active_bindings
      :type: dict[str, textual.screen.ActiveBinding]


      Get currently active bindings.

      If no widget is focused, then app-level bindings are returned.
      If a widget is focused, then any bindings present in the active screen and app are merged and returned.

      This property may be used to inspect current bindings.

      :returns: A dict that maps keys on to binding information.


   .. py:method:: get_system_commands(screen: textual.screen.Screen) -> Iterable[SystemCommand]

      A generator of system commands used in the command palette.

      :param screen: The screen where the command palette was invoked from.

      Implement this method in your App subclass if you want to add custom commands.
      Here is an example:

      ```python
      def get_system_commands(self, screen: Screen) -> Iterable[SystemCommand]:
          yield from super().get_system_commands(screen)
          yield SystemCommand("Bell", "Ring the bell", self.bell)
      ```

      !!! note
          Requires that [`SystemCommandsProvider`][textual.system_commands.SystemCommandsProvider] is in `App.COMMANDS` class variable.

      :Yields: [SystemCommand][textual.app.SystemCommand] instances.



   .. py:method:: get_default_screen() -> textual.screen.Screen

      Get the default screen.

      This is called when the App is first composed. The returned screen instance
      will be the first screen on the stack.

      Implement this method if you would like to use a custom Screen as the default screen.

      :returns: A screen instance.



   .. py:method:: get_theme_variable_defaults() -> dict[str, str]

      Get the default values for the `variables` used in a theme.

      If the currently specified theme doesn't define a value for a variable,
      the value specified here will be used as a fallback.

      If a variable is referenced in CSS but does not appear either here
      or in the theme, the CSS will fail to parse on startup.

      This method allows applications to define their own variables, beyond
      those offered by Textual, which can then be overridden by a Theme.

      :returns: A mapping of variable name (e.g. "my-button-background-color") to value.
                Values can be any valid CSS value, e.g. "red 50%", "auto 90%",
                "#ff0000", "rgb(255, 0, 0)", etc.



   .. py:method:: get_css_variables() -> dict[str, str]

      Get a mapping of variables used to pre-populate CSS.

      May be implemented in a subclass to add new CSS variables.

      :returns: A mapping of variable name to value.



   .. py:method:: get_theme(theme_name: str) -> textual.theme.Theme | None

      Get a theme by name.

      :param theme_name: The name of the theme to get. May also be a comma
                         separated list of names, to pick the first available theme.

      :returns: A Theme instance and None if the theme doesn't exist.



   .. py:method:: register_theme(theme: textual.theme.Theme) -> None

      Register a theme with the app.

      If the theme already exists, it will be overridden.

      After registering a theme, you can activate it by setting the
      `App.theme` attribute. To retrieve a registered theme, use the
      `App.get_theme` method.

      :param theme: The theme to register.



   .. py:method:: unregister_theme(theme_name: str) -> None

      Unregister a theme with the app.

      :param theme_name: The name of the theme to unregister.



   .. py:property:: available_themes
      :type: dict[str, textual.theme.Theme]


      All available themes (all built-in themes plus any that have been registered).

      A dictionary mapping theme names to Theme instances.


   .. py:property:: current_theme
      :type: textual.theme.Theme



   .. py:method:: watch_ansi_theme_dark(theme: rich.terminal_theme.TerminalTheme) -> None


   .. py:method:: watch_ansi_theme_light(theme: rich.terminal_theme.TerminalTheme) -> None


   .. py:property:: ansi_theme
      :type: rich.terminal_theme.TerminalTheme


      The ANSI TerminalTheme currently being used.

      Defines how colors defined as ANSI (e.g. `magenta`) inside Rich renderables
      are mapped to hex codes.


   .. py:method:: get_driver_class() -> Type[textual.driver.Driver]

      Get a driver class for this platform.

      This method is called by the constructor, and unlikely to be required when
      building a Textual app.

      :returns: A Driver class which manages input and display.



   .. py:method:: __rich_repr__() -> rich.repr.Result


   .. py:property:: animator
      :type: textual._animator.Animator


      The animator object.


   .. py:property:: screen
      :type: textual.screen.Screen[object]


      The current active screen.

      :returns: The currently active (visible) screen.

      :raises ScreenStackError: If there are no screens on the stack.


   .. py:property:: size
      :type: textual.geometry.Size


      The size of the terminal.

      :returns: Size of the terminal.


   .. py:property:: viewport_size
      :type: textual.geometry.Size


      Get the viewport size (size of the screen).


   .. py:property:: log
      :type: textual.Logger


      The textual logger.

      .. rubric:: Example

      ```python
      self.log("Hello, World!")
      self.log(self.tree)
      ```

      :returns: A Textual logger.


   .. py:method:: get_loading_widget() -> textual.widget.Widget

      Get a widget to be used as a loading indicator.

      Extend this method if you want to display the loading state a little differently.

      :returns: A widget to display a loading state.



   .. py:method:: copy_to_clipboard(text: str) -> None

      Copy text to the clipboard.

      !!! note

          This does not work on macOS Terminal, but will work on most other terminals.

      :param text: Text you wish to copy to the clipboard.



   .. py:method:: call_from_thread(callback: Callable[Ellipsis, CallThreadReturnType | Awaitable[CallThreadReturnType]], *args: Any, **kwargs: Any) -> CallThreadReturnType

      Run a callable from another thread, and return the result.

      Like asyncio apps in general, Textual apps are not thread-safe. If you call methods
      or set attributes on Textual objects from a thread, you may get unpredictable results.

      This method will ensure that your code runs within the correct context.

      !!! tip

          Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.

      :param callback: A callable to run.
      :param \*args: Arguments to the callback.
      :param \*\*kwargs: Keyword arguments for the callback.

      :raises RuntimeError: If the app isn't running or if this method is called from the same
          thread where the app is running.

      :returns: The result of the callback.



   .. py:method:: action_change_theme() -> None

      An [action](/guide/actions) to change the current theme.



   .. py:method:: action_screenshot(filename: str | None = None, path: str | None = None) -> None

      This [action](/guide/actions) will save an SVG file containing the current contents of the screen.

      :param filename: Filename of screenshot, or None to auto-generate.
      :param path: Path to directory. Defaults to the user's Downloads directory.



   .. py:method:: export_screenshot(*, title: str | None = None, simplify: bool = False) -> str

      Export an SVG screenshot of the current screen.

      See also [save_screenshot][textual.app.App.save_screenshot] which writes the screenshot to a file.

      :param title: The title of the exported screenshot or None
                    to use app title.
      :param simplify: Simplify the segments by combining contiguous segments with the same style.



   .. py:method:: save_screenshot(filename: str | None = None, path: str | None = None, time_format: str | None = None) -> str

      Save an SVG screenshot of the current screen.

      :param filename: Filename of SVG screenshot, or None to auto-generate
                       a filename with the date and time.
      :param path: Path to directory for output. Defaults to current working directory.
      :param time_format: Date and time format to use if filename is None.
                          Defaults to a format like ISO 8601 with some reserved characters replaced with underscores.

      :returns: Filename of screenshot.



   .. py:method:: deliver_screenshot(filename: str | None = None, path: str | None = None, time_format: str | None = None) -> str | None

      Deliver a screenshot of the app.

      This will save the screenshot when running locally, or serve it when the app
      is running in a web browser.

      :param filename: Filename of SVG screenshot, or None to auto-generate
                       a filename with the date and time.
      :param path: Path to directory for output when saving locally (not used when app is running in the browser).
                   Defaults to current working directory.
      :param time_format: Date and time format to use if filename is None.
                          Defaults to a format like ISO 8601 with some reserved characters replaced with underscores.

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:method:: search_commands(commands: Sequence[textual.command.CommandListItem], placeholder: str = 'Search for commandsâ€¦') -> textual.widget.AwaitMount

      Show a list of commands in the app.

      :param commands: A list of SimpleCommand instances.
      :param placeholder: Placeholder text for the search field.

      :returns: An awaitable that resolves when the commands are shown.
      :rtype: AwaitMount



   .. py:method:: search_themes() -> None

      Show a fuzzy search command palette containing all registered themes.

      Selecting a theme in the list will change the app's theme.



   .. py:method:: bind(keys: str, action: str, *, description: str = '', show: bool = True, key_display: str | None = None) -> None

      Bind a key to an action.

      !!! warning
          This method may be private or removed in a future version of Textual.
          See [dynamic actions](/guide/actions#dynamic-actions) for a more flexible alternative to updating bindings.

      :param keys: A comma separated list of keys, i.e.
      :param action: Action to bind to.
      :param description: Short description of action.
      :param show: Show key in UI.
      :param key_display: Replacement text for key, or None to use default.



   .. py:method:: get_key_display(binding: textual.binding.Binding) -> str

      Format a bound key for display in footer / key panel etc.

      !!! note
          You can implement this in a subclass if you want to change how keys are displayed in your app.

      :param binding: A Binding.

      :returns: A string used to represent the key.



   .. py:method:: begin_capture_print(target: textual._types.MessageTarget, stdout: bool = True, stderr: bool = True) -> None

      Capture content that is printed (or written to stdout / stderr).

      If printing is captured, the `target` will be sent an [events.Print][textual.events.Print] message.

      :param target: The widget where print content will be sent.
      :param stdout: Capture stdout.
      :param stderr: Capture stderr.



   .. py:method:: end_capture_print(target: textual._types.MessageTarget) -> None

      End capturing of prints.

      :param target: The widget that was capturing prints.



   .. py:method:: run_test(*, headless: bool = True, size: tuple[int, int] | None = (80, 24), tooltips: bool = False, notifications: bool = False, message_hook: Callable[[textual.message.Message], None] | None = None) -> AsyncGenerator[textual.pilot.Pilot[ReturnType], None]
      :async:


      An asynchronous context manager for testing apps.

      !!! tip

          See the guide for [testing](/guide/testing) Textual apps.

      Use this to run your app in "headless" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.

      .. rubric:: Example

      ```python
      async with app.run_test() as pilot:
          await pilot.click("#Button.ok")
          assert ...
      ```

      :param headless: Run in headless mode (no output or input).
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param tooltips: Enable tooltips when testing.
      :param notifications: Enable notifications when testing.
      :param message_hook: An optional callback that will be called each time any message arrives at any
                           message pump in the app.



   .. py:method:: run_async(*, headless: bool = False, inline: bool = False, inline_no_clear: bool = False, mouse: bool = True, size: tuple[int, int] | None = None, auto_pilot: AutopilotCallbackType | None = None) -> ReturnType | None
      :async:


      Run the app asynchronously.

      :param headless: Run in headless mode (no output).
      :param inline: Run the app inline (under the prompt).
      :param inline_no_clear: Don't clear the app output when exiting an inline app.
      :param mouse: Enable mouse support.
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param auto_pilot: An autopilot coroutine.

      :returns: App return value.



   .. py:method:: run(*, headless: bool = False, inline: bool = False, inline_no_clear: bool = False, mouse: bool = True, size: tuple[int, int] | None = None, auto_pilot: AutopilotCallbackType | None = None, loop: asyncio.AbstractEventLoop | None = None) -> ReturnType | None

      Run the app.

      :param headless: Run in headless mode (no output).
      :param inline: Run the app inline (under the prompt).
      :param inline_no_clear: Don't clear the app output when exiting an inline app.
      :param mouse: Enable mouse support.
      :param size: Force terminal size to `(WIDTH, HEIGHT)`,
                   or None to auto-detect.
      :param auto_pilot: An auto pilot coroutine.
      :param loop: Asyncio loop instance, or `None` to use default.

      :returns: App return value.



   .. py:method:: render() -> RenderResult

      Render method, inherited from widget, to render the screen's background.

      May be overridden to customize background visuals.




   .. py:attribute:: ExpectType


   .. py:method:: get_child_by_id(id: str) -> textual.widget.Widget

      Get the first child (immediate descendant) of this DOMNode with the given ID.

      :param id: The ID of the node to search for.
      :param expect_type: Require the object be of the supplied type,
                          or use `None` to apply no type restriction.

      :returns: The first child of this node with the specified ID.

      :raises NoMatches: If no children could be found for this ID.
      :raises WrongType: If the wrong type was found.



   .. py:method:: get_widget_by_id(id: str) -> textual.widget.Widget

      Get the first descendant widget with the given ID.

      Performs a breadth-first search rooted at the current screen.
      It will not return the Screen if that matches the ID.
      To get the screen, use `self.screen`.

      :param id: The ID to search for in the subtree
      :param expect_type: Require the object be of the supplied type, or None for any type.
                          Defaults to None.

      :returns: The first descendant encountered with this ID.

      :raises NoMatches: if no children could be found for this ID
      :raises WrongType: if the wrong type was found.



   .. py:method:: get_child_by_type(expect_type: type[ExpectType]) -> ExpectType

      Get a child of a give type.

      :param expect_type: The type of the expected child.

      :raises NoMatches: If no valid child is found.

      :returns: A widget.



   .. py:method:: update_styles(node: textual.dom.DOMNode) -> None

      Immediately update the styles of this node and all descendant nodes.

      Should be called whenever CSS classes / pseudo classes change.
      For example, when you hover over a button, the :hover pseudo class
      will be added, and this method is called to apply the corresponding
      :hover styles.



   .. py:method:: mount(*widgets: textual.widget.Widget, before: int | str | textual.widget.Widget | None = None, after: int | str | textual.widget.Widget | None = None) -> textual.widget.AwaitMount

      Mount the given widgets relative to the app's screen.

      :param \*widgets: The widget(s) to mount.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: mount_all(widgets: Iterable[textual.widget.Widget], *, before: int | str | textual.widget.Widget | None = None, after: int | str | textual.widget.Widget | None = None) -> textual.widget.AwaitMount

      Mount widgets from an iterable.

      :param widgets: An iterable of widgets.
      :param before: Optional location to mount before. An `int` is the index
                     of the child to mount before, a `str` is a `query_one` query to
                     find the widget to mount before.
      :param after: Optional location to mount after. An `int` is the index
                    of the child to mount after, a `str` is a `query_one` query to
                    find the widget to mount after.

      :returns: An awaitable object that waits for widgets to be mounted.

      :raises MountError: If there is a problem with the mount request.

      .. note::

         Only one of `before` or `after` can be provided. If both are
         provided a `MountError` will be raised.



   .. py:method:: switch_mode(mode: str) -> textual.widget.AwaitMount

      Switch to a given mode.

      :param mode: The mode to switch to.

      :returns:

                An optionally awaitable object which waits for the screen associated
                    with the mode to be mounted.

      :raises UnknownModeError: If trying to switch to an unknown mode.



   .. py:method:: add_mode(mode: str, base_screen: str | Callable[[], textual.screen.Screen]) -> None

      Adds a mode and its corresponding base screen to the app.

      :param mode: The new mode.
      :param base_screen: The base screen associated with the given mode.

      :raises InvalidModeError: If the name of the mode is not valid/duplicated.



   .. py:method:: remove_mode(mode: str) -> textual.await_complete.AwaitComplete

      Removes a mode from the app.

      Screens that are running in the stack of that mode are scheduled for pruning.

      :param mode: The mode to remove. It can't be the active mode.

      :raises ActiveModeError: If trying to remove the active mode.
      :raises UnknownModeError: If trying to remove an unknown mode.



   .. py:method:: is_screen_installed(screen: textual.screen.Screen | str) -> bool

      Check if a given screen has been installed.

      :param screen: Either a Screen object or screen name (the `name` argument when installed).

      :returns: True if the screen is currently installed,



   .. py:method:: get_screen(screen: ScreenType) -> ScreenType
                  get_screen(screen: str) -> textual.screen.Screen
                  get_screen(screen: str, screen_class: Type[ScreenType] | None = None) -> ScreenType
                  get_screen(screen: ScreenType, screen_class: Type[ScreenType] | None = None) -> ScreenType

      Get an installed screen.

      .. rubric:: Example

      ```python
      my_screen = self.get_screen("settings", MyScreen)
      ```

      :param screen: Either a Screen object or screen name (the `name` argument when installed).
      :param screen_class: Class of expected screen, or `None` for any screen class.

      :raises KeyError: If the named screen doesn't exist.

      :returns: A screen instance.



   .. py:method:: push_screen(screen: textual.screen.Screen[textual.screen.ScreenResultType] | str, callback: textual.screen.ScreenResultCallbackType[textual.screen.ScreenResultType] | None = None, wait_for_dismiss: typing_extensions.Literal[False] = False) -> textual.widget.AwaitMount

      Push a new [screen](/guide/screens) on the screen stack, making it the current screen.

      :param screen: A Screen instance or the name of an installed screen.
      :param callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.
      :param wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting
                               this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.

      :raises NoActiveWorker: If using `wait_for_dismiss` outside of a worker.

      :returns:

                An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future
                    to await the result of the screen.



   .. py:method:: push_screen_wait(screen: textual.screen.Screen[textual.screen.ScreenResultType]) -> textual.screen.ScreenResultType
      :async:


      Push a screen and wait for the result (received from [`Screen.dismiss`][textual.screen.Screen.dismiss]).

      Note that this method may only be called when running in a worker.

      :param screen: A screen or the name of an installed screen.

      :returns: The screen's result.



   .. py:method:: switch_screen(screen: textual.screen.Screen | str) -> textual.await_complete.AwaitComplete

      Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.

      :param screen: Either a Screen object or screen name (the `name` argument when installed).



   .. py:method:: install_screen(screen: textual.screen.Screen, name: str) -> None

      Install a screen.

      Installing a screen prevents Textual from destroying it when it is no longer on the screen stack.
      Note that you don't need to install a screen to use it. See [push_screen][textual.app.App.push_screen]
      or [switch_screen][textual.app.App.switch_screen] to make a new screen current.

      :param screen: Screen to install.
      :param name: Unique name to identify the screen.

      :raises ScreenError: If the screen can't be installed.

      :returns: An awaitable that awaits the mounting of the screen and its children.



   .. py:method:: uninstall_screen(screen: textual.screen.Screen | str) -> str | None

      Uninstall a screen.

      If the screen was not previously installed, then this method is a null-op.
      Uninstalling a screen allows Textual to delete it when it is popped or switched.
      Note that uninstalling a screen is only required if you have previously installed it
      with [install_screen][textual.app.App.install_screen].
      Textual will also uninstall screens automatically on exit.

      :param screen: The screen to uninstall or the name of an installed screen.

      :returns: The name of the screen that was uninstalled, or None if no screen was uninstalled.



   .. py:method:: pop_screen() -> textual.await_complete.AwaitComplete

      Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.

      :returns: The screen that was replaced.



   .. py:method:: set_focus(widget: textual.widget.Widget | None, scroll_visible: bool = True) -> None

      Focus (or unfocus) a widget. A focused widget will receive key events first.

      :param widget: Widget to focus.
      :param scroll_visible: Scroll widget into view.



   .. py:method:: capture_mouse(widget: textual.widget.Widget | None) -> None

      Send all mouse events to the given widget or disable mouse capture.

      Normally mouse events are sent to the widget directly under the pointer.
      Capturing the mouse allows a widget to receive mouse events even when the pointer is over another widget.

      :param widget: Widget to capture mouse events, or `None` to end mouse capture.



   .. py:method:: panic(*renderables: rich.console.RenderableType) -> None

      Exits the app and display error message(s).

      Used in response to unexpected errors.
      For a more graceful exit, see the [exit][textual.app.App.exit] method.

      :param \*renderables: Text or Rich renderable(s) to display on exit.



   .. py:method:: recompose() -> None
      :async:


      Recompose the widget.

      Recomposing will remove children and call `self.compose` again to remount.



   .. py:method:: is_mounted(widget: textual.widget.Widget) -> bool

      Check if a widget is mounted.

      :param widget: A widget.

      :returns: True of the widget is mounted.



   .. py:method:: refresh(*, repaint: bool = True, layout: bool = False, recompose: bool = False) -> typing_extensions.Self

      Refresh the entire screen.

      :param repaint: Repaint the widget (will call render() again).
      :param layout: Also layout widgets in the view.
      :param recompose: Re-compose the widget (will remove and re-mount children).

      :returns: The `App` instance.



   .. py:method:: refresh_css(animate: bool = True) -> None

      Refresh CSS.

      :param animate: Also execute CSS animations.



   .. py:method:: post_display_hook() -> None

      Called immediately after a display is done. Used in tests.



   .. py:method:: get_widget_at(x: int, y: int) -> tuple[textual.widget.Widget, textual.geometry.Region]

      Get the widget under the given coordinates.

      :param x: X coordinate.
      :param y: Y coordinate.

      :returns: The widget and the widget's screen region.



   .. py:method:: bell() -> None

      Play the console 'bell'.

      For terminals that support a bell, this typically makes a notification or error sound.
      Some terminals may make no sound or display a visual bell indicator, depending on configuration.



   .. py:method:: simulate_key(key: str) -> None

      Simulate a key press.

      This will perform the same action as if the user had pressed the key.

      :param key: Key to simulate. May also be the name of a key, e.g. "space".



   .. py:method:: action_help_quit() -> None

      Bound to ctrl+C to alert the user that it no longer quits.



   .. py:method:: set_keymap(keymap: textual.binding.Keymap) -> None

      Set the keymap, a mapping of binding IDs to key strings.

      Bindings in the keymap are used to override default key bindings,
      i.e. those defined in `BINDINGS` class variables.

      Bindings with IDs that are present in the keymap will have
      their key string replaced with the value from the keymap.

      :param keymap: A mapping of binding IDs to key strings.



   .. py:method:: update_keymap(keymap: textual.binding.Keymap) -> None

      Update the App's keymap, merging with `keymap`.

      If a Binding ID exists in both the App's keymap and the `keymap`
      argument, the `keymap` argument takes precedence.

      :param keymap: A mapping of binding IDs to key strings.



   .. py:method:: handle_bindings_clash(clashed_bindings: set[textual.binding.Binding], node: textual.dom.DOMNode) -> None

      Handle a clash between bindings.

      Bindings clashes are likely due to users setting conflicting
      keys via their keymap.

      This method is intended to be overridden by subclasses.

      Textual will call this each time a clash is encountered -
      which may be on each keypress if a clashing widget is focused
      or is in the bindings chain.

      :param clashed_bindings: The bindings that are clashing.
      :param node: The node that has the clashing bindings.



   .. py:method:: on_event(event: textual.events.Event) -> None
      :async:


      Called to process an event.

      :param event: An Event object.



   .. py:property:: escape_to_minimize
      :type: bool


      Use the escape key to minimize?

      When a widget is [maximized][textual.screen.Screen.maximize], this boolean determines if the `escape` key will
      minimize the widget (potentially overriding any bindings).

      The default logic is to use the screen's `ESCAPE_TO_MINIMIZE` classvar if it is set to `True` or `False`.
      If the classvar on the screen is *not* set (and left as `None`), then the app's `ESCAPE_TO_MINIMIZE` is used.


   .. py:method:: run_action(action: str | textual.actions.ActionParseResult, default_namespace: textual.dom.DOMNode | None = None, namespaces: Mapping[str, textual.dom.DOMNode] | None = None) -> bool
      :async:


      Perform an [action](/guide/actions).

      Actions are typically associated with key bindings, where you wouldn't need to call this method manually.

      :param action: Action encoded in a string.
      :param default_namespace: Namespace to use if not provided in the action,
                                or None to use app.
      :param namespaces: Mapping of namespaces.

      :returns: True if the event has been handled.



   .. py:method:: action_simulate_key(key: str) -> None
      :async:


      An [action](/guide/actions) to simulate a key press.

      This will invoke the same actions as if the user had pressed the key.

      :param key: The key to process.



   .. py:method:: action_quit() -> None
      :async:


      An [action](/guide/actions) to quit the app as soon as possible.



   .. py:method:: action_bell() -> None
      :async:


      An [action](/guide/actions) to play the terminal 'bell'.



   .. py:method:: action_focus(widget_id: str) -> None
      :async:


      An [action](/guide/actions) to focus the given widget.

      :param widget_id: ID of widget to focus.



   .. py:method:: action_switch_screen(screen: str) -> None
      :async:


      An [action](/guide/actions) to switch screens.

      :param screen: Name of the screen.



   .. py:method:: action_push_screen(screen: str) -> None
      :async:


      An [action](/guide/actions) to push a new screen on to the stack and make it active.

      :param screen: Name of the screen.



   .. py:method:: action_pop_screen() -> None
      :async:


      An [action](/guide/actions) to remove the topmost screen and makes the new topmost screen active.



   .. py:method:: action_switch_mode(mode: str) -> None
      :async:


      An [action](/guide/actions) that switches to the given mode.



   .. py:method:: action_back() -> None
      :async:


      An [action](/guide/actions) to go back to the previous screen (pop the current screen).

      .. note::

         If there is no screen to go back to, this is a non-operation (in
         other words it's safe to call even if there are no other screens
         on the stack.)



   .. py:method:: action_add_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to add a CSS class to the selected widget.

      :param selector: Selects the widget to add the class to.
      :param class_name: The class to add to the selected widget.



   .. py:method:: action_remove_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to remove a CSS class from the selected widget.

      :param selector: Selects the widget to remove the class from.
      :param class_name: The class to remove from  the selected widget.



   .. py:method:: action_toggle_class(selector: str, class_name: str) -> None
      :async:


      An [action](/guide/actions) to toggle a CSS class on the selected widget.

      :param selector: Selects the widget to toggle the class on.
      :param class_name: The class to toggle on the selected widget.



   .. py:method:: action_toggle_dark() -> None

      An [action](/guide/actions) to toggle the theme between textual-light
      and textual-dark. This is offered as a convenience to simplify backwards
      compatibility with previous versions of Textual which only had light mode
      and dark mode.



   .. py:method:: action_focus_next() -> None

      An [action](/guide/actions) to focus the next widget.



   .. py:method:: action_focus_previous() -> None

      An [action](/guide/actions) to focus the previous widget.



   .. py:method:: action_hide_help_panel() -> None

      Hide the keys panel (if present).



   .. py:method:: action_show_help_panel() -> None

      Show the keys panel.



   .. py:method:: action_notify(message: str, title: str = '', severity: str = 'information') -> None

      Show a notification.



   .. py:method:: clear_selection() -> None

      Clear text selection on the active screen.



   .. py:method:: notify(message: str, *, title: str = '', severity: textual.notifications.SeverityLevel = 'information', timeout: float | None = None, markup: bool = True) -> None

      Create a notification.

      !!! tip

          This method is thread-safe.


      :param message: The message for the notification.
      :param title: The title for the notification.
      :param severity: The severity of the notification.
      :param timeout: The timeout (in seconds) for the notification, or `None` for default.
      :param markup: Render the message as content markup?

      The `notify` method is used to create an application-wide
      notification, shown in a [`Toast`][textual.widgets._toast.Toast],
      normally originating in the bottom right corner of the display.

      Notifications can have the following severity levels:

      - `information`
      - `warning`
      - `error`

      The default is `information`.

      .. rubric:: Example

      ```python
      # Show an information notification.
      self.notify("It's an older code, sir, but it checks out.")

      # Show a warning. Note that Textual's notification system allows
      # for the use of Rich console markup.
      self.notify(
          "Now witness the firepower of this fully "
          "[b]ARMED[/b] and [i][b]OPERATIONAL[/b][/i] battle station!",
          title="Possible trap detected",
          severity="warning",
      )

      # Show an error. Set a longer timeout so it's noticed.
      self.notify("It's a trap!", severity="error", timeout=10)

      # Show an information notification, but without any sort of title.
      self.notify("It's against my programming to impersonate a deity.", title="")
      ```



   .. py:method:: clear_notifications() -> None

      Clear all the current notifications.



   .. py:method:: action_command_palette() -> None

      Show the Textual command palette.



   .. py:method:: suspend() -> Iterator[None]

      A context manager that temporarily suspends the app.

      While inside the `with` block, the app will stop reading input and
      emitting output. Other applications will have full control of the
      terminal, configured as it was before the app started running. When
      the `with` block ends, the application will start reading input and
      emitting output again.

      .. rubric:: Example

      ```python
      with self.suspend():
          os.system("emacs -nw")
      ```

      :raises SuspendNotSupported: If the environment doesn't support suspending.

      !!! note
          Suspending the application is currently only supported on
          Unix-like operating systems and Microsoft Windows. Suspending is
          not supported in Textual Web.



   .. py:method:: action_suspend_process() -> None

      Suspend the process into the background.

      .. note::

         On Unix and Unix-like systems a `SIGTSTP` is sent to the
         application's process. Currently on Windows and when running
         under Textual Web this is a non-operation.



   .. py:method:: open_url(url: str, *, new_tab: bool = True) -> None

      Open a URL in the default web browser.

      :param url: The URL to open.
      :param new_tab: Whether to open the URL in a new tab.



   .. py:method:: deliver_text(path_or_file: str | pathlib.Path | TextIO, *, save_directory: str | pathlib.Path | None = None, save_filename: str | None = None, open_method: typing_extensions.Literal[browser, download] = 'download', encoding: str | None = None, mime_type: str | None = None, name: str | None = None) -> str | None

      Deliver a text file to the end-user of the application.

      If a TextIO object is supplied, it will be closed by this method
      and *must not be used* after this method is called.

      If running in a terminal, this will save the file to the user's
      downloads directory.

      If running via a web browser, this will initiate a download via
      a single-use URL.

      After the file has been delivered, a `DeliveryComplete` message will be posted
      to this `App`, which contains the `delivery_key` returned by this method. By
      handling this message, you can add custom logic to your application that fires
      only after the file has been delivered.

      :param path_or_file: The path or file-like object to save.
      :param save_directory: The directory to save the file to.
      :param save_filename: The filename to save the file to.  If `path_or_file`
                            is a file-like object, the filename will be generated from
                            the `name` attribute if available. If `path_or_file` is a path
                            the filename will be generated from the path.
      :param encoding: The encoding to use when saving the file. If `None`,
                       the encoding will be determined by supplied file-like object
                       (if possible). If this is not possible, 'utf-8' will be used.
      :param mime_type: The MIME type of the file or None to guess based on file extension.
                        If no MIME type is supplied and we cannot guess the MIME type, from the
                        file extension, the MIME type will be set to "text/plain".
      :param name: A user-defined named which will be returned in [`DeliveryComplete`][textual.events.DeliveryComplete]
                   and [`DeliveryComplete`][textual.events.DeliveryComplete].

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:method:: deliver_binary(path_or_file: str | pathlib.Path | BinaryIO, *, save_directory: str | pathlib.Path | None = None, save_filename: str | None = None, open_method: typing_extensions.Literal[browser, download] = 'download', mime_type: str | None = None, name: str | None = None) -> str | None

      Deliver a binary file to the end-user of the application.

      If an IO object is supplied, it will be closed by this method
      and *must not be used* after it is supplied to this method.

      If running in a terminal, this will save the file to the user's
      downloads directory.

      If running via a web browser, this will initiate a download via
      a single-use URL.

      This operation runs in a thread when running on web, so this method
      returning does not indicate that the file has been delivered.

      After the file has been delivered, a `DeliveryComplete` message will be posted
      to this `App`, which contains the `delivery_key` returned by this method. By
      handling this message, you can add custom logic to your application that fires
      only after the file has been delivered.

      :param path_or_file: The path or file-like object to save.
      :param save_directory: The directory to save the file to. If None,
                             the default "downloads" directory will be used. This
                             argument is ignored when running via the web.
      :param save_filename: The filename to save the file to. If None, the following logic
                            applies to generate the filename:
                            - If `path_or_file` is a file-like object, the filename will be taken from
                              the `name` attribute if available.
                            - If `path_or_file` is a path, the filename will be taken from the path.
                            - If a filename is not available, a filename will be generated using the
                              App's title and the current date and time.
      :param open_method: The method to use to open the file. "browser" will open the file in the
                          web browser, "download" will initiate a download. Note that this can sometimes
                          be impacted by the browser's settings.
      :param mime_type: The MIME type of the file or None to guess based on file extension.
                        If no MIME type is supplied and we cannot guess the MIME type, from the
                        file extension, the MIME type will be set to "application/octet-stream".
      :param name: A user-defined named which will be returned in [`DeliveryComplete`][textual.events.DeliveryComplete]
                   and [`DeliveryComplete`][textual.events.DeliveryComplete].

      :returns: The delivery key that uniquely identifies the file delivery.



   .. py:attribute:: DEFAULT_CLASSES
      :type:  ClassVar[str]
      :value: ''


      Default classes argument if not supplied.


   .. py:attribute:: COMPONENT_CLASSES
      :type:  ClassVar[set[str]]

      Virtual DOM nodes, used to expose styles to line API widgets.


   .. py:attribute:: SCOPED_CSS
      :type:  ClassVar[bool]
      :value: True


      Should default css be limited to the widget type?


   .. py:attribute:: HELP
      :type:  ClassVar[str | None]
      :value: None


      Optional help text shown in help panel (Markdown format).


   .. py:attribute:: styles
      :type:  textual.css.styles.RenderStyles


   .. py:method:: set_reactive(reactive: textual.reactive.Reactive[ReactiveType], value: ReactiveType) -> None

      Sets a reactive value *without* invoking validators or watchers.

      .. rubric:: Example

      ```python
      self.set_reactive(App.theme, "textual-light")
      ```

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).
      :param value: New value of reactive.

      :raises AttributeError: If the first argument is not a reactive.



   .. py:method:: mutate_reactive(reactive: textual.reactive.Reactive[ReactiveType]) -> None

      Force an update to a mutable reactive.

      .. rubric:: Example

      ```python
      self.reactive_name_list.append("Jessica")
      self.mutate_reactive(MyClass.reactive_name_list)
      ```

      Textual will automatically detect when a reactive is set to a new value, but it is unable
      to detect if a value is _mutated_ (such as updating a list, dict, or attribute of an object).
      If you do wish to use a collection or other mutable object in a reactive, then you can call
      this method after your reactive is updated. This will ensure that all the reactive _superpowers_
      work.

      !!! note

          This method will cause watchers to be called, even if the value hasn't changed.

      :param reactive: A reactive property (use the class scope syntax, i.e. `MyClass.my_reactive`).



   .. py:method:: data_bind(*reactives: textual.reactive.Reactive[Any], **bind_vars: textual.reactive.Reactive[Any] | object) -> typing_extensions.Self

      Bind reactive data so that changes to a reactive automatically change the reactive on another widget.

      Reactives may be given as positional arguments or keyword arguments.
      See the [guide on data binding](/guide/reactivity#data-binding).

      .. rubric:: Example

      ```python
      def compose(self) -> ComposeResult:
          yield WorldClock("Europe/London").data_bind(WorldClockApp.time)
          yield WorldClock("Europe/Paris").data_bind(WorldClockApp.time)
          yield WorldClock("Asia/Tokyo").data_bind(WorldClockApp.time)
      ```

      :raises ReactiveError: If the data wasn't bound.

      :returns: Self.



   .. py:method:: compose_add_child(widget: textual.widget.Widget) -> None

      Add a node to children.

      This is used by the compose process when it adds children.
      There is no need to use it directly, but you may want to override it in a subclass
      if you want children to be attached to a different node.

      :param widget: A Widget to add.



   .. py:property:: displayed_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True`).

      :returns: A sequence of widgets.


   .. py:property:: displayed_and_visible_children
      :type: Sequence[textual.widget.Widget]


      The displayed children (where `node.display==True` and `node.visible==True`).

      :returns: A sequence of widgets.


   .. py:property:: is_empty
      :type: bool


      Are there no displayed children?


   .. py:method:: sort_children(*, key: Callable[[textual.widget.Widget], _typeshed.SupportsRichComparison] | None = None, reverse: bool = False) -> None

      Sort child widgets with an optional key function.

      If `key` is not provided then widgets will be sorted in the order they are constructed.

      .. rubric:: Example

      ```python
      # Sort widgets by name
      screen.sort_children(key=lambda widget: widget.name or "")
      ```

      :param key: A callable which accepts a widget and returns something that can be sorted,
                  or `None` to sort without a key function.
      :param reverse: Sort in descending order.



   .. py:property:: auto_refresh
      :type: float | None


      Number of seconds between automatic refresh, or `None` for no automatic refresh.


   .. py:method:: trap_focus(trap_focus: bool = True) -> None

      Trap the focus.

      When applied to a container, this will limit tab-to-focus to the children of that
      container (once focus is within that container).

      This can be useful for widgets that act like modal dialogs, where you want to restrict
      the user to the controls within the dialog.

      :param trap_focus: `True` to trap focus. `False` to restore default behavior.



   .. py:method:: run_worker(work: textual.worker.WorkType[textual.worker.ResultType], name: str | None = '', group: str = 'default', description: str = '', exit_on_error: bool = True, start: bool = True, exclusive: bool = False, thread: bool = False) -> textual.worker.Worker[textual.worker.ResultType]

      Run work in a worker.

      A worker runs a function, coroutine, or awaitable, in the *background* as an async task or as a thread.

      :param work: A function, async function, or an awaitable object to run in a worker.
      :param name: A short string to identify the worker (in logs and debugging).
      :param group: A short string to identify a group of workers.
      :param description: A longer string to store longer information on the worker.
      :param exit_on_error: Exit the app if the worker raises an error. Set to `False` to suppress exceptions.
      :param start: Start the worker immediately.
      :param exclusive: Cancel all workers in the same group.
      :param thread: Mark the worker as a thread worker.

      :returns: New Worker instance.



   .. py:property:: is_modal
      :type: bool


      Is the node a modal?


   .. py:property:: is_on_screen
      :type: bool


      Check if the node was displayed in the last screen update.


   .. py:method:: automatic_refresh() -> None

      Perform an automatic refresh.

      This method is called when you set the `auto_refresh` attribute.
      You could implement this method if you want to perform additional work
      during an automatic refresh.




   .. py:method:: get_component_styles(*names: str) -> textual.css.styles.RenderStyles

      Get a "component" styles object (must be defined in COMPONENT_CLASSES classvar).

      :param names: Names of the components.

      :raises KeyError: If the component class doesn't exist.

      :returns: A Styles object.



   .. py:method:: notify_style_update() -> None

      Called after styles are updated.

      Implement this in a subclass if you want to clear any cached data when the CSS is reloaded.



   .. py:property:: parent
      :type: DOMNode | None


      The parent node.

      All nodes have parent once added to the DOM, with the exception of the App which is the *root* node.


   .. py:property:: id
      :type: str | None


      The ID of this node, or None if the node has no ID.


   .. py:property:: name
      :type: str | None


      The name of the node.


   .. py:property:: css_identifier
      :type: str


      A CSS selector that identifies this DOM node.


   .. py:property:: css_identifier_styled
      :type: rich.text.Text


      A syntax highlighted CSS identifier.

      :returns: A Rich Text object.


   .. py:attribute:: classes

      CSS class names for this node.


   .. py:property:: pseudo_classes
      :type: frozenset[str]


      A (frozen) set of all pseudo classes.


   .. py:property:: css_path_nodes
      :type: list[DOMNode]


      A list of nodes from the App to this node, forming a "path".

      :returns: A list of nodes, where the first item is the App, and the last is this node.


   .. py:property:: display
      :type: bool


      Should the DOM node be displayed?

      May be set to a boolean to show or hide the node, or to any valid value for the `display` rule.

      .. rubric:: Example

      ```python
      my_widget.display = False  # Hide my_widget
      ```


   .. py:property:: visible
      :type: bool


      Is this widget visible in the DOM?

      If a widget hasn't had its visibility set explicitly, then it inherits it from its
      DOM ancestors.

      This may be set explicitly to override inherited values.
      The valid values include the valid values for the `visibility` rule and the booleans
      `True` or `False`, to set the widget to be visible or invisible, respectively.

      When a node is invisible, Textual will reserve space for it, but won't display anything.


   .. py:property:: tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: css_tree
      :type: rich.tree.Tree


      A Rich tree to display the DOM, annotated with the node's CSS.

      Log this to visualize your app in the textual console.

      .. rubric:: Example

      ```python
      self.log(self.css_tree)
      ```

      :returns: A Tree renderable.


   .. py:property:: text_style
      :type: rich.style.Style


      Get the text style object.

      A widget's style is influenced by its parent. for instance if a parent is bold, then
      the child will also be bold.

      :returns: A Rich Style.


   .. py:property:: selection_style
      :type: rich.style.Style


      The style of selected text.


   .. py:property:: rich_style
      :type: rich.style.Style


      Get a Rich Style object for this DOMNode.

      :returns: A Rich style.


   .. py:method:: check_consume_key(key: str, character: str | None) -> bool

      Check if the widget may consume the given key.

      This should be implemented in widgets that handle [`Key`][textual.events.Key] events and
      stop propagation (such as Input and TextArea).

      Implementing this method will hide key bindings from the footer and key panel that would
      be *consumed* by the focused widget.

      :param key: A key identifier.
      :param character: A character associated with the key, or `None` if there isn't one.

      :returns: `True` if the widget may capture the key in its `Key` event handler, or `False` if it won't.



   .. py:property:: background_colors
      :type: tuple[textual.color.Color, textual.color.Color]


      Background colors adjusted for opacity.

      :returns: `(<background color>, <color>)`


   .. py:property:: colors
      :type: tuple[textual.color.Color, textual.color.Color, textual.color.Color, textual.color.Color]


      The widget's background and foreground colors, and the parent's background and foreground colors.

      :returns: `(<parent background>, <parent color>, <background>, <color>)`


   .. py:property:: ancestors_with_self
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      .. note:: This is inclusive of ``self``.

      :returns: A list of nodes.


   .. py:property:: ancestors
      :type: list[DOMNode]


      A list of ancestor nodes found by tracing a path all the way back to App.

      :returns: A list of nodes.


   .. py:method:: watch(obj: DOMNode, attribute_name: str, callback: textual._types.WatchCallbackType, init: bool = True) -> None

      Watches for modifications to reactive attributes on another object.

      .. rubric:: Example

      ```python
      def on_theme_change(old_value:str, new_value:str) -> None:
          # Called when app.theme changes.
          print(f"App.theme went from {old_value} to {new_value}")

      self.watch(self.app, "theme", self.on_theme_change, init=False)
      ```

      :param obj: Object containing attribute to watch.
      :param attribute_name: Attribute to watch.
      :param callback: A callback to run when attribute changes.
      :param init: Check watchers on first call.



   .. py:method:: get_pseudo_classes() -> set[str]

      Pseudo classes for a widget.

      :returns: Names of the pseudo classes.



   .. py:method:: reset_styles() -> None

      Reset styles back to their initial state.



   .. py:attribute:: WalkType


   .. py:method:: walk_children(filter_type: type[WalkType], *, with_self: bool = False, method: WalkMethod = 'depth', reverse: bool = False) -> list[WalkType]

      Walk the subtree rooted at this node, and return every descendant encountered in a list.

      :param filter_type: Filter only this type, or None for no filter.
      :param with_self: Also yield self in addition to descendants.
      :param method: One of "depth" or "breadth".
      :param reverse: Reverse the order (bottom up).

      :returns: A list of nodes.



   .. py:method:: query(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for children that match a selector or widget type.

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_children(selector: str | None = None) -> textual.css.query.DOMQuery[textual.widget.Widget]

      Query the DOM for the immediate children that match a selector or widget type.

      Note that this will not return child widgets more than a single level deep.
      If you want to a query to potentially match all children in the widget tree,
      see [query][textual.dom.DOMNode.query].

      :param selector: A CSS selector, widget type, or `None` for all nodes.

      :returns: A query object.



   .. py:method:: query_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.

      :returns: A widget matching the selector.



   .. py:method:: query_exactly_one(selector: str) -> textual.widget.Widget

      Get a widget from this widget's children that matches a selector or widget type.

      !!! Note
          This method is similar to [query_one][textual.dom.DOMNode.query_one].
          The only difference is that it will raise `TooManyMatches` if there is more than a single match.

      :param selector: A selector or widget type.
      :param expect_type: Require the object be of the supplied type, or None for any type.

      :raises WrongType: If the wrong type was found.
      :raises NoMatches: If no node matches the query.
      :raises TooManyMatches: If there is more than one matching node in the query (and `exactly_one==True`).

      :returns: A widget matching the selector.



   .. py:method:: query_ancestor(selector: str) -> DOMNode

      Get an ancestor which matches a query.

      :param selector: A TCSS selector.
      :param expect_type: Expected type, or `None` for any DOMNode.

      :raises InvalidQueryFormat: If the selector is invalid.
      :raises NoMatches: If there are no matching ancestors.

      :returns: A DOMNode or subclass if `expect_type` is provided.



   .. py:method:: set_styles(css: str | None = None, **update_styles: Any) -> typing_extensions.Self

      Set custom styles on this object.

      :param css: Styles in CSS format.
      :param update_styles: Keyword arguments map style names onto style values.

      :returns: Self.



   .. py:method:: has_class(*class_names: str) -> bool

      Check if the Node has all the given class names.

      :param \*class_names: CSS class names to check.

      :returns: ``True`` if the node has all the given class names, otherwise ``False``.



   .. py:method:: set_class(add: bool, *class_names: str, update: bool = True) -> typing_extensions.Self

      Add or remove class(es) based on a condition.

      This can condense the four lines required to implement the equivalent branch into a single line.

      .. rubric:: Example

      ```python
      #if foo:
      #    self.add_class("-foo")
      #else:
      #    self.remove_class("-foo")
      self.set_class(foo, "-foo")
      ```

      :param add: Add the classes if True, otherwise remove them.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: set_classes(classes: str | Iterable[str]) -> typing_extensions.Self

      Replace all classes.

      :param classes: A string containing space separated classes, or an
                      iterable of class names.

      :returns: Self.



   .. py:method:: add_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Add class names to this Node.

      :param \*class_names: CSS class names to add.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: remove_class(*class_names: str, update: bool = True) -> typing_extensions.Self

      Remove class names from this Node.

      :param \*class_names: CSS class names to remove.
      :param update: Also update styles.

      :returns: Self.



   .. py:method:: toggle_class(*class_names: str) -> typing_extensions.Self

      Toggle class names on this Node.

      :param \*class_names: CSS class names to toggle.

      :returns: Self.



   .. py:method:: has_pseudo_class(class_name: str) -> bool

      Check the node has the given pseudo class.

      :param class_name: The pseudo class to check for.

      :returns: `True` if the DOM node has the pseudo class, `False` if not.



   .. py:method:: has_pseudo_classes(class_names: set[str]) -> bool

      Check the node has all the given pseudo classes.

      :param class_names: Set of class names to check for.

      :returns: `True` if all pseudo class names are present.



   .. py:method:: check_action(action: str, parameters: tuple[object, Ellipsis]) -> bool | None

      Check whether an action is enabled.

      Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.

      :param action: The name of an action.
      :param parameters: A tuple of any action parameters.

      :returns:

                `True` if the action is enabled+visible,
                    `False` if the action is disabled+hidden,
                    `None` if the action is disabled+visible (grayed out in footer)



   .. py:method:: refresh_bindings() -> None

      Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update
      the display of key bindings.

      See [actions](/guide/actions#dynamic-actions) for how to use this method.




   .. py:method:: action_toggle(attribute_name: str) -> None
      :async:


      Toggle an attribute on the node.

      Assumes the attribute is a bool.

      :param attribute_name: Name of the attribute.



   .. py:attribute:: message_signal
      :type:  textual.signal.Signal[textual.message.Message]

      Subscribe to this signal to be notified of all messages sent to this widget.

      This is a fairly low-level mechanism, and shouldn't replace regular message handling.


   .. py:method:: prevent(*message_types: type[textual.message.Message]) -> Generator[None, None, None]

      A context manager to *temporarily* prevent the given message types from being posted.

      .. rubric:: Example

      ```python
      input = self.query_one(Input)
      with self.prevent(Input.Changed):
          input.value = "foo"
      ```



   .. py:property:: task
      :type: asyncio.Task



   .. py:property:: has_parent
      :type: bool


      Does this object have a parent?


   .. py:property:: message_queue_size
      :type: int


      The current size of the message queue.


   .. py:attribute:: app


   .. py:property:: is_parent_active
      :type: bool


      Is the parent active?


   .. py:property:: is_running
      :type: bool


      Is the message pump running (potentially processing messages)?


   .. py:method:: check_message_enabled(message: textual.message.Message) -> bool

      Check if a given message is enabled (allowed to be sent).

      :param message: A message object.

      :returns: `True` if the message will be sent, or `False` if it is disabled.



   .. py:method:: disable_messages(*messages: type[textual.message.Message]) -> None

      Disable message types from being processed.



   .. py:method:: enable_messages(*messages: type[textual.message.Message]) -> None

      Enable processing of messages types.



   .. py:method:: set_timer(delay: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, pause: bool = False) -> textual.timer.Timer

      Call a function after a delay.

      .. rubric:: Example

      ```python
      def ready():
          self.notify("Your soft boiled egg is ready!")
      # Call ready() after 3 minutes
      self.set_timer(3 * 60, ready)
      ```

      :param delay: Time (in seconds) to wait before invoking callback.
      :param callback: Callback to call after time has expired.
      :param name: Name of the timer (for debug).
      :param pause: Start timer paused.

      :returns: A timer object.



   .. py:method:: set_interval(interval: float, callback: textual.timer.TimerCallback | None = None, *, name: str | None = None, repeat: int = 0, pause: bool = False) -> textual.timer.Timer

      Call a function at periodic intervals.

      :param interval: Time (in seconds) between calls.
      :param callback: Function to call.
      :param name: Name of the timer object.
      :param repeat: Number of times to repeat the call or 0 for continuous.
      :param pause: Start the timer paused.

      :returns: A timer object.



   .. py:method:: call_after_refresh(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed and the screen
      has been refreshed. Positional and keyword arguments are passed to the callable.

      :param callback: A callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: wait_for_refresh() -> bool
      :async:


      Wait for the next refresh.

      This method should only be called from a task other than the one running this widget.
      If called from the same task, it will return immediately to avoid blocking the event loop.

      :returns:

                `True` if waiting for refresh was successful, or `False` if the call was a null-op
                    due to calling it within the node's own task.



   .. py:method:: call_later(callback: Callback, *args: Any, **kwargs: Any) -> bool

      Schedule a callback to run after all messages are processed in this object.
      Positional and keywords arguments are passed to the callable.

      :param callback: Callable to call next.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.

      :returns:

                `True` if the callback was scheduled, or `False` if the callback could not be
                    scheduled (may occur if the message pump was closed or closing).



   .. py:method:: call_next(callback: Callback, *args: Any, **kwargs: Any) -> None

      Schedule a callback to run immediately after processing the current message.

      :param callback: Callable to run after current event.
      :param \*args: Positional arguments to pass to the callable.
      :param \*\*kwargs: Keyword arguments to pass to the callable.



   .. py:method:: check_idle() -> None

      Prompt the message pump to call idle if the queue is empty.



   .. py:method:: post_message(message: textual.message.Message) -> bool

      Posts a message on to this widget's queue.

      :param message: A message (including Event).

      :returns: `True` if the message was queued for processing, otherwise `False`.



   .. py:method:: on_callback(event: textual.events.Callback) -> None
      :async:



   .. py:method:: on_timer(event: textual.events.Timer) -> None
      :async:



.. py:data:: app

