{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid of integers based on connected components of non-7 values.\n\n1. Identifies connected components of cells with values other than 7 using 4-way adjacency (up, down, left, right). Cells with value 7 act as boundaries.\n2. For each component, determines its properties: size, unique values, and minimum value from the input grid.\n3. Determines which single transformation rule applies to the entire component based on these properties.\n4. Applies the determined rule to all cells within the component in the output grid.\n\nRules:\n- Rule_Size1: Component size is 1 -> all cells become 7.\n- Rule_Size4_Only6: Component size is 4 AND all values are 6 -> all cells remain 6.\n- Rule_Size5_Only6: Component size is 5 AND all values are 6 -> all cells become 4.\n- Rule_General: None of the above rules apply -> cells with the original minimum value become 7, all other cells become the minimum value.\n\nCells with the value 7 in the input grid remain unchanged.\n\"\"\"\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\"Yields valid neighbor coordinates (up, down, left, right).\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            yield nr, nc\n\ndef _find_component_and_properties(start_r, start_c, grid, visited):\n    \"\"\"\n    Finds a connected component using BFS starting from (start_r, start_c)\n    and returns its cells, size, unique values, and minimum value.\n    Marks visited cells in the `visited` grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Should not happen if called correctly, but safety check\n    if visited[start_r][start_c] or grid[start_r][start_c] == 7:\n        return None, 0, set(), float('inf') \n\n    component_cells = []\n    component_values = []\n    q = deque([(start_r, start_c)])\n    visited[start_r][start_c] = True\n\n    # BFS to find all connected non-7 cells\n    while q:\n        r, c = q.popleft()\n        component_cells.append((r, c))\n        component_values.append(grid[r][c])\n\n        for nr, nc in _get_neighbors(r, c, rows, cols):\n            if not visited[nr][nc] and grid[nr][nc] != 7:\n                visited[nr][nc] = True\n                q.append((nr, nc))\n\n    # Calculate component properties\n    size = len(component_cells)\n    unique_values = set(component_values)\n    min_value = min(component_values) if component_values else float('inf') # Handle empty case theoretically\n\n    return component_cells, size, unique_values, min_value\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n\n    # Keep track of visited cells to avoid reprocessing components\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n\n    # Iterate through each cell to find components\n    for r in range(rows):\n        for c in range(cols):\n            # If cell is active (not 7) and not yet visited, it's the start of a new component\n            if input_grid[r][c] != 7 and not visited[r][c]:\n                \n                # Find the component and its properties\n                component_cells, size, unique_values, min_value = _find_component_and_properties(r, c, input_grid, visited)\n\n                # Should always find a component if initial check passes, but check anyway\n                if not component_cells:\n                    continue \n\n                # Determine which single rule applies to this component\n                apply_rule = None\n                if size == 1:\n                    apply_rule = \"Rule_Size1\"\n                elif size == 4 and unique_values == {6}:\n                    apply_rule = \"Rule_Size4_Only6\"\n                elif size == 5 and unique_values == {6}:\n                    apply_rule = \"Rule_Size5_Only6\"\n                else:\n                    apply_rule = \"Rule_General\"\n\n                # Apply the determined transformation rule to all cells in the component\n                for cell_r, cell_c in component_cells:\n                    if apply_rule == \"Rule_Size1\":\n                        output_grid[cell_r][cell_c] = 7\n                    elif apply_rule == \"Rule_Size4_Only6\":\n                        # No change needed, value remains 6\n                        pass \n                    elif apply_rule == \"Rule_Size5_Only6\":\n                        output_grid[cell_r][cell_c] = 4\n                    elif apply_rule == \"Rule_General\":\n                        original_value = input_grid[cell_r][cell_c]\n                        if original_value == min_value:\n                            output_grid[cell_r][cell_c] = 7\n                        else:\n                            output_grid[cell_r][cell_c] = min_value\n                            \n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 7072,
    "candidates_token_count": 1750,
    "total_token_count": 8822,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.798395,
  "retries": 1
}