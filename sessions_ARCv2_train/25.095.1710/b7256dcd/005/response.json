{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid of integers based on connected components of non-7 values.\n\nThe transformation operates on connected components of cells with values other than 7, \nusing 4-way adjacency. Cells with value 7 act as boundaries and remain unchanged.\n\nFor each connected component, its properties (size, unique values, minimum value, \nsecond minimum value, and the locations of cells holding these minimum values) \ndetermine how the cells within that component are transformed in the output grid.\n\nSpecific Rules Applied:\n1.  Rule S1 (Size 1): If component size is 1, the cell becomes 7.\n2.  Rule S2 (Size 2, All 6s): If size is 2 and the only value is 6, both cells become 3.\n3.  Rule S3 (Size 3, All 6s): If size is 3 and the only value is 6, all cells remain 6.\n4.  Rule S4 (Size 4, All 6s): If size is 4 and the only value is 6, all cells remain 6.\n5.  Rule S5 (Size 5, All 6s): If size is 5 and the only value is 6, all cells become 4.\n6.  Rule G1 (General - 1 Unique Value, Not 6): If size > 1 and there's only one unique value (not 6), all cells become 7.\n7.  Rule G2 (General - 2 Unique Values): If there are exactly two unique values:\n    - Cells originally holding the minimum value become 7.\n    - All other cells become the minimum value.\n8.  Rule G3 (General - 3+ Unique Values): If there are three or more unique values:\n    - Identify the minimum (`min_val`) and second minimum (`second_min_val`) values.\n    - Identify cells originally holding these values (`min_cells`, `second_min_cells`).\n    - Cells in `min_cells` and `second_min_cells` become 7.\n    - For all other cells in the component:\n        - Calculate the shortest path distance within the component to any cell in `min_cells`.\n        - Calculate the shortest path distance within the component to any cell in `second_min_cells`.\n        - If the distance to a `min_cell` is less than or equal to the distance to a `second_min_cell`, the cell becomes `min_val`.\n        - Otherwise, the cell becomes `second_min_val`.\n\"\"\"\n\ndef _get_neighbors(r, c, rows, cols):\n    \"\"\"Yields valid neighbor coordinates (up, down, left, right).\"\"\"\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            yield nr, nc\n\ndef _find_component_and_properties(start_r, start_c, grid, visited):\n    \"\"\"\n    Finds a connected component using BFS and calculates its properties.\n    Marks visited cells.\n    Returns: component_cells (list of ((r,c), value)), size, unique_values (sorted list), \n             min_val, min_cells (set of (r,c)), second_min_val, second_min_cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    if visited[start_r][start_c] or grid[start_r][start_c] == 7:\n        return None, 0, [], float('inf'), set(), float('inf'), set()\n\n    component_cells_dict = {} # Store {(r, c): value}\n    q = deque([(start_r, start_c)])\n    visited[start_r][start_c] = True\n    \n    component_cells_set = set() # Keep track of component coordinates efficiently\n\n    while q:\n        r, c = q.popleft()\n        component_cells_dict[(r, c)] = grid[r][c]\n        component_cells_set.add((r,c))\n\n        for nr, nc in _get_neighbors(r, c, rows, cols):\n            if not visited[nr][nc] and grid[nr][nc] != 7:\n                visited[nr][nc] = True\n                q.append((nr, nc))\n\n    component_cells_list = list(component_cells_dict.items())\n    size = len(component_cells_list)\n    \n    if not component_cells_list:\n         return [], 0, [], float('inf'), set(), float('inf'), set()\n\n    values = [v for (r,c), v in component_cells_list]\n    unique_values = sorted(list(set(values)))\n    \n    min_val = unique_values[0]\n    min_cells = {pos for pos, val in component_cells_list if val == min_val}\n    \n    second_min_val = float('inf')\n    second_min_cells = set()\n    if len(unique_values) >= 2:\n        second_min_val = unique_values[1]\n        second_min_cells = {pos for pos, val in component_cells_list if val == second_min_val}\n\n    return component_cells_dict, size, unique_values, min_val, min_cells, second_min_val, second_min_cells, component_cells_set\n\ndef _bfs_distance(component_cells_set, start_cells, grid_rows, grid_cols):\n    \"\"\"\n    Performs BFS within a component to find shortest distances from start_cells.\n    Returns a dictionary {(r, c): distance} for cells reachable from start_cells.\n    \"\"\"\n    distances = {}\n    q = deque()\n    \n    # Initialize queue with start cells and distance 0\n    for r, c in start_cells:\n        if (r, c) in component_cells_set: # Ensure start cell is part of the component\n             distances[(r,c)] = 0\n             q.append(((r, c), 0)) # Store ((r,c), dist)\n             \n    processed = set(start_cells) # Keep track of cells added to queue\n\n    while q:\n        (r, c), dist = q.popleft()\n\n        for nr, nc in _get_neighbors(r, c, grid_rows, grid_cols):\n            neighbor_pos = (nr, nc)\n            # Check if neighbor is within the component and not yet processed\n            if neighbor_pos in component_cells_set and neighbor_pos not in processed:\n                processed.add(neighbor_pos)\n                distances[neighbor_pos] = dist + 1\n                q.append((neighbor_pos, dist + 1))\n                \n    return distances\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid based on connected components.\n    \"\"\"\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n\n    # Keep track of visited cells to avoid reprocessing components\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n\n    # Iterate through each cell to find components\n    for r in range(rows):\n        for c in range(cols):\n            # If cell is active (not 7) and not yet visited, it's the start of a new component\n            if input_grid[r][c] != 7 and not visited[r][c]:\n                \n                # Find the component and its properties\n                component_cells_dict, size, unique_values, min_val, min_cells, second_min_val, second_min_cells, component_cells_set = \\\n                    _find_component_and_properties(r, c, input_grid, visited)\n\n                # Should always find a component if initial check passes, but check anyway\n                if not component_cells_dict:\n                    continue \n\n                # --- Determine and Apply Transformation Rule ---\n                \n                # Rule S1 (Size 1)\n                if size == 1:\n                    cell_r, cell_c = list(component_cells_dict.keys())[0]\n                    output_grid[cell_r][cell_c] = 7\n                \n                # Rules for components containing only 6s\n                elif unique_values == [6]:\n                    new_val = 6 # Default for S3, S4\n                    if size == 2: # Rule S2\n                        new_val = 3\n                    elif size == 5: # Rule S5\n                        new_val = 4\n                    # Apply for S2, S3, S4, S5 (and potentially others if size>5 all 6s exist)\n                    for cell_r, cell_c in component_cells_dict:\n                         output_grid[cell_r][cell_c] = new_val\n\n                # Rule G1 (General - 1 Unique Value, Not 6)\n                elif len(unique_values) == 1: # Size > 1 implicitly (handled S1) and value != 6 (handled above)\n                    for cell_r, cell_c in component_cells_dict:\n                        output_grid[cell_r][cell_c] = 7\n\n                # Rule G2 (General - 2 Unique Values)\n                elif len(unique_values) == 2:\n                    for (cell_r, cell_c), original_value in component_cells_dict.items():\n                        if original_value == min_val:\n                            output_grid[cell_r][cell_c] = 7\n                        else: # Must be the second unique value\n                            output_grid[cell_r][cell_c] = min_val\n                \n                # Rule G3 (General - 3+ Unique Values)\n                elif len(unique_values) >= 3:\n                    # Calculate distances needed for G3\n                    dist_to_min = _bfs_distance(component_cells_set, min_cells, rows, cols)\n                    dist_to_second = _bfs_distance(component_cells_set, second_min_cells, rows, cols)\n\n                    for (cell_r, cell_c), original_value in component_cells_dict.items():\n                        # Cells that were originally min or second min become 7\n                        if original_value == min_val or original_value == second_min_val:\n                            output_grid[cell_r][cell_c] = 7\n                        else:\n                            # For other cells, compare distances\n                            d1 = dist_to_min.get((cell_r, cell_c), float('inf'))\n                            d2 = dist_to_second.get((cell_r, cell_c), float('inf'))\n                            \n                            if d1 <= d2:\n                                output_grid[cell_r][cell_c] = min_val\n                            else:\n                                output_grid[cell_r][cell_c] = second_min_val\n\n    # Return the modified grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8588,
    "candidates_token_count": 4721,
    "total_token_count": 13309,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 40.22424,
  "retries": 1
}