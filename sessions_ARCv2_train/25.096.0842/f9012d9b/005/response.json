{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nfrom collections import defaultdict\nimport numpy as np\n\n\"\"\"\nTransforms an input square grid of integers into an output square grid based on the following rules:\n\n1.  Determine the dimension (`Dim`) of the input square grid.\n2.  Calculate the subgrid dimension (`M`) as `floor(sqrt(Dim))`.\n3.  Extract all unique `M x M` subgrid patterns from the input grid. For each unique pattern, record its frequency, the sum of its elements, and the list of top-left (row, col) locations where it occurs.\n4.  Filter the patterns to keep only those with the maximum sum of elements found across all patterns.\n5.  From the filtered set, further filter to keep only those patterns with the maximum frequency.\n6.  If only one pattern remains, select it as the target pattern (`P`).\n7.  If multiple patterns remain tied after the sum and frequency filters, apply a location-based tie-breaker:\n    a. For each tied pattern, find its occurrence(s) with the maximum row index.\n    b. Among these, find the occurrence with the maximum column index.\n    c. Select the pattern associated with this winning (max row, max col) location.\n8.  Determine the output grid dimension (`N`): `N = M // 2` if `Dim` is even, otherwise `N = M`.\n9.  Construct the output grid by taking the top-left `N x N` portion of the selected pattern `P`.\n\"\"\"\n\ndef _get_subgrid_data(grid: list[list[int]], m: int) -> dict:\n    \"\"\"\n    Extracts M x M subgrids, calculates sum, frequency, and locations for each unique pattern.\n\n    Args:\n        grid: The input 2D list of integers.\n        m: The dimension of the subgrids to extract.\n\n    Returns:\n        A dictionary where keys are tuple representations of subgrid patterns\n        and values are dictionaries containing 'count', 'sum', and 'locations'.\n        Example: { ((1,2),(3,4)): {'count': 2, 'sum': 10, 'locations': [(0,0), (5,5)]} }\n    \"\"\"\n    dim = len(grid)\n    pattern_data = defaultdict(lambda: {'count': 0, 'sum': 0, 'locations': []})\n\n    if m <= 0 or m > dim:\n        return {}\n\n    for r in range(dim - m + 1):\n        for c in range(dim - m + 1):\n            subgrid_rows = []\n            current_sum = 0\n            for i in range(m):\n                row_tuple = tuple(grid[r + i][c : c + m])\n                subgrid_rows.append(row_tuple)\n                current_sum += sum(row_tuple)\n            \n            pattern_tuple = tuple(subgrid_rows)\n            \n            # Update data for this pattern\n            pattern_data[pattern_tuple]['count'] += 1\n            pattern_data[pattern_tuple]['locations'].append((r, c))\n            # Sum is calculated only once when the pattern is first encountered implicitly\n            if pattern_data[pattern_tuple]['count'] == 1:\n                 pattern_data[pattern_tuple]['sum'] = current_sum\n                 \n    return dict(pattern_data)\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    # 1. Determine input dimension (Dim)\n    dim = len(input_grid)\n    if dim == 0:\n        return []\n\n    # 2. Calculate subgrid dimension (M)\n    m = math.floor(math.sqrt(dim))\n    if m == 0:\n        return [] # Cannot proceed with M=0\n\n    # 3. Extract subgrids and their data (frequency, sum, locations)\n    all_pattern_data = _get_subgrid_data(input_grid, m)\n    if not all_pattern_data:\n        return [] # No subgrids found\n\n    # 4. Filter by maximum sum\n    max_sum = -1\n    for data in all_pattern_data.values():\n        if data['sum'] > max_sum:\n            max_sum = data['sum']\n    \n    sum_filtered_patterns = {\n        p: data for p, data in all_pattern_data.items() if data['sum'] == max_sum\n    }\n\n    if not sum_filtered_patterns:\n        # This case implies max_sum remained -1, should not happen if all_pattern_data is not empty\n        return [] \n\n    # 5. Filter by maximum frequency (among max_sum patterns)\n    max_freq = 0\n    for data in sum_filtered_patterns.values():\n        if data['count'] > max_freq:\n            max_freq = data['count']\n\n    freq_filtered_patterns = {\n        p: data for p, data in sum_filtered_patterns.items() if data['count'] == max_freq\n    }\n\n    # 6. & 7. Select the target pattern (P), handling ties with location\n    selected_pattern_tuple = None\n    patterns_after_freq_filter = list(freq_filtered_patterns.keys())\n\n    if len(patterns_after_freq_filter) == 1:\n        selected_pattern_tuple = patterns_after_freq_filter[0]\n    elif len(patterns_after_freq_filter) > 1:\n        # Location-based tie-breaking\n        best_location = (-1, -1) # (row, col)\n        winning_pattern = None\n\n        for pattern in patterns_after_freq_filter:\n            locations = freq_filtered_patterns[pattern]['locations']\n            # Find the location for *this* pattern with max row, then max col\n            current_max_loc = (-1, -1)\n            for loc in locations:\n                # Check if current location `loc` is better than `current_max_loc`\n                if loc[0] > current_max_loc[0] or \\\n                   (loc[0] == current_max_loc[0] and loc[1] > current_max_loc[1]):\n                    current_max_loc = loc\n            \n            # Check if this pattern's best location (`current_max_loc`) \n            # is better than the overall best found so far (`best_location`)\n            if current_max_loc[0] > best_location[0] or \\\n               (current_max_loc[0] == best_location[0] and current_max_loc[1] > best_location[1]):\n                best_location = current_max_loc\n                winning_pattern = pattern\n        \n        selected_pattern_tuple = winning_pattern\n    else:\n         # No patterns left after filtering, should not happen if initial data existed\n         return []\n\n    if selected_pattern_tuple is None:\n        # Should not be reachable if logic above is correct\n        return []\n\n    # 8. Determine output dimension (N)\n    if dim % 2 == 0:\n        n = m // 2\n    else:\n        n = m\n        \n    if n <= 0:\n        return [] # Output is empty if N is 0 or less\n\n    # 9. Construct the output grid (top-left N x N of selected pattern)\n    output_grid = []\n    # Ensure N doesn't exceed M (which it shouldn't by calculation)\n    actual_n = min(n, m) \n    if actual_n == 0: return []\n\n    for i in range(actual_n):\n        # Ensure pattern has enough rows\n        if i < len(selected_pattern_tuple):\n            row = selected_pattern_tuple[i]\n            # Ensure row has enough columns and take the first N elements\n            output_grid.append(list(row[:actual_n]))\n        else:\n            # Should not happen if N <= M\n            break \n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8346,
    "candidates_token_count": 2219,
    "total_token_count": 10565,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 20.436025,
  "retries": 1
}