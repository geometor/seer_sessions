{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport math\nfrom collections import defaultdict\n\n\"\"\"\nThis function transforms an input square grid of integers into an output square grid.\nThe transformation involves finding the most frequent square subgrid of a specific size within the input grid.\n\n1.  Determine the dimension (`Dim`) of the input square grid.\n2.  Calculate the subgrid dimension (`M`) as floor(sqrt(Dim)).\n3.  Extract all M x M subgrids from the input grid, counting the frequency of each unique pattern and recording the top-left location(s) of each occurrence.\n4.  Find the maximum frequency among all patterns.\n5.  Identify all patterns that occur with this maximum frequency.\n6.  If only one pattern has the maximum frequency, select it.\n7.  If multiple patterns tie for maximum frequency, select the pattern whose occurrence has the highest index sum (row + col). Use the highest row index, then the highest column index as further tie-breakers.\n8.  Determine the output grid dimension (`N`): N = M // 2 if Dim is even, N = M if Dim is odd.\n9.  Construct the output grid by taking the top-left N x N portion of the selected pattern.\n\"\"\"\n\ndef _extract_and_count_subgrids(grid: list[list[int]], m: int) -> dict:\n    \"\"\"\n    Extracts all M x M subgrids, counts their frequencies, and records locations.\n\n    Args:\n        grid: The input 2D list of integers.\n        m: The dimension of the subgrids to extract.\n\n    Returns:\n        A dictionary where keys are tuple representations of subgrid patterns\n        and values are dictionaries containing 'count' and 'locations' (list of (row, col) tuples).\n        Example: { ((1,2),(3,4)): {'count': 2, 'locations': [(0,0), (5,5)]} }\n    \"\"\"\n    dim = len(grid)\n    pattern_data = defaultdict(lambda: {'count': 0, 'locations': []})\n\n    if m == 0: # Handle cases where sqrt(Dim) < 1, although unlikely with grid inputs\n        return {}\n    if m > dim: # Cannot extract subgrid larger than grid\n        return {}\n\n    for r in range(dim - m + 1):\n        for c in range(dim - m + 1):\n            # Extract the M x M subgrid\n            subgrid = []\n            for i in range(m):\n                subgrid.append(tuple(grid[r + i][c : c + m]))\n            \n            pattern_tuple = tuple(subgrid)\n            \n            # Update count and locations\n            pattern_data[pattern_tuple]['count'] += 1\n            pattern_data[pattern_tuple]['locations'].append((r, c))\n            \n    return dict(pattern_data) # Convert back to regular dict\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the most frequent subgrid pattern.\n\n    Args:\n        input_grid: A square 2D list of integers.\n\n    Returns:\n        A square 2D list of integers representing the transformed output grid.\n    \"\"\"\n\n    # 1. Determine input dimension (Dim)\n    dim = len(input_grid)\n    if dim == 0:\n        return []\n\n    # 2. Calculate subgrid dimension (M)\n    m = math.floor(math.sqrt(dim))\n    \n    # Handle edge case where M might be 0 if Dim is 0 (already handled), or Dim < 1 (not possible for list len)\n    # If Dim is 1, M=1. If Dim is 2 or 3, M=1. If Dim is 4, M=2. Seems reasonable.\n    if m == 0: \n         # If Dim is 0, m is undefined by sqrt, but handled above.\n         # If Dim is > 0 but < 1 (not possible for len), m would be 0.\n         # Let's assume Dim >= 1. If Dim = 1, m=1. If Dim=0.x, m=0.\n         # If calculation leads to m=0 but grid exists, maybe default to M=1?\n         # Based on examples, Dim is always >= 2. M will be >= 1.\n         # If for some reason m ends up 0 with a valid grid, return empty or handle as error?\n         # Let's stick to the formula: if M=0, no subgrids possible per formula.\n         return [] # Or raise ValueError(\"Cannot operate on grid resulting in M=0\")\n\n\n    # 3. Extract subgrids, count frequencies, and record locations\n    pattern_data = _extract_and_count_subgrids(input_grid, m)\n\n    if not pattern_data: # No subgrids found (e.g., M > Dim or M=0)\n        return []\n\n    # 4. Find maximum frequency\n    max_freq = 0\n    for pattern, data in pattern_data.items():\n        if data['count'] > max_freq:\n            max_freq = data['count']\n\n    # 5. Identify patterns with maximum frequency\n    tied_patterns = [p for p, data in pattern_data.items() if data['count'] == max_freq]\n\n    # 6. & 7. Select the target pattern (P), handling ties\n    selected_pattern_tuple = None\n    if len(tied_patterns) == 1:\n        selected_pattern_tuple = tied_patterns[0]\n    else:\n        # Tie-breaking logic\n        best_occurrence_pattern = None\n        max_index_sum = -1\n        max_row = -1\n        max_col = -1\n\n        for pattern in tied_patterns:\n            for r, c in pattern_data[pattern]['locations']:\n                current_index_sum = r + c\n                # Compare using (index_sum, row, col) tuple for lexicographical comparison\n                if (current_index_sum > max_index_sum or\n                   (current_index_sum == max_index_sum and r > max_row) or\n                   (current_index_sum == max_index_sum and r == max_row and c > max_col)):\n                    \n                    max_index_sum = current_index_sum\n                    max_row = r\n                    max_col = c\n                    best_occurrence_pattern = pattern\n\n        selected_pattern_tuple = best_occurrence_pattern\n\n    if selected_pattern_tuple is None:\n         # Should not happen if pattern_data was populated and max_freq > 0\n         return [] # Or raise error\n\n    # 8. Determine output dimension (N)\n    if dim % 2 == 0:\n        n = m // 2\n    else:\n        n = m\n        \n    # Ensure N is not larger than M (can happen if M=1 and Dim is even -> N=0)\n    # Also ensure N isn't negative (not possible with floor/division on non-negatives)\n    # If N is 0, the output should be an empty grid.\n    if n <= 0:\n        return []\n\n    # 9. Construct the output grid (top-left N x N of selected pattern)\n    output_grid = []\n    for i in range(n):\n         # Take the first N elements from the i-th row of the pattern tuple\n         output_grid.append(list(selected_pattern_tuple[i][:n]))\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1672,
    "candidates_token_count": 2792,
    "total_token_count": 4464,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 27.832691,
  "retries": 1
}