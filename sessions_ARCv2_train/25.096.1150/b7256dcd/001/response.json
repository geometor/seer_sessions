{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\n\"\"\"\nTransforms a 2D grid based on the following rules:\n1. Identifies connected components of cells with the value '6'.\n2. For each '6' component, it examines the values of adjacent cells (neighbors).\n3. If exactly one unique value 'v' (other than '6' or '7') exists among the neighbors, all cells in that '6' component are changed to 'v' in the output grid. The neighboring cells with value 'v' that caused this change are marked as 'source cells'.\n4. After processing all '6' components, the grid is scanned again.\n5. Any cell whose original value was not '6' or '7' is changed to '7' in the output grid if:\n    a. It was marked as a 'source cell' in step 3.\n    b. Or, if all of its neighbors in the original input grid had the value '7' (i.e., it was isolated by '7's).\n6. Cells with the value '7' generally remain unchanged, as do '6' components that did not meet the condition in step 3.\n\"\"\"\n\nimport copy\nfrom collections import deque\n\ndef get_neighbors(r: int, c: int, height: int, width: int) -> list[tuple[int, int]]:\n    \"\"\"Gets the valid 4-way adjacent neighbor coordinates for a cell.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < height and 0 <= nc < width:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n    \"\"\"\n    height = len(input_grid)\n    width = len(input_grid[0])\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    visited = set() # Keep track of visited cells during component search\n    components = [] # List to store found '6' components (each a set of coordinates)\n    source_cells = set() # Keep track of cells that influenced a component change\n\n    # Step 1: Find all connected components of '6's using BFS\n    for r in range(height):\n        for c in range(width):\n            # If cell is '6' and not yet visited, start BFS for a new component\n            if input_grid[r][c] == 6 and (r, c) not in visited:\n                current_component = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                current_component.add((r, c))\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Explore neighbors\n                    for nr, nc in get_neighbors(curr_r, curr_c, height, width):\n                        # Add to component if it's a '6' and not visited\n                        if input_grid[nr][nc] == 6 and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            current_component.add((nr, nc))\n                            q.append((nr, nc))\n                components.append(current_component) # Store the found component\n\n    # Step 2 & 3: Process each '6' component to determine its fate and identify sources\n    for component in components:\n        border_cells_coords = set()\n        neighbor_influences = []\n        # potential_component_sources stores ((coord), value) for border cells that might influence\n        potential_component_sources = set()\n\n        # Step 2a: Find border cells adjacent to the component\n        for r, c in component:\n            for nr, nc in get_neighbors(r, c, height, width):\n                if (nr, nc) not in component: # It's a border cell\n                    border_cells_coords.add((nr, nc))\n                    border_value = input_grid[nr][nc]\n                    # Step 2b: Collect non-6, non-7 influencing values\n                    if border_value != 6 and border_value != 7:\n                        neighbor_influences.append(border_value)\n                        potential_component_sources.add(((nr, nc), border_value))\n\n        # Step 2c: Find the unique influencing values\n        unique_influences = set(neighbor_influences)\n\n        # Step 3: If exactly one unique influence value exists, update the component and mark sources\n        if len(unique_influences) == 1:\n            v = list(unique_influences)[0]\n            # Step 3d.i: Update output grid for all cells in the component\n            for r, c in component:\n                output_grid[r][c] = v\n            # Step 3d.ii: Identify the actual source cells (border cells with value v) and add to the global set\n            for (sr, sc), val in potential_component_sources:\n                if val == v:\n                    source_cells.add((sr, sc))\n\n    # Step 4 & 5: Update source cells and isolated non-6, non-7 cells to 7\n    for r in range(height):\n        for c in range(width):\n            current_value = input_grid[r][c]\n            # Consider only cells that were originally not '6' or '7'\n            if current_value != 6 and current_value != 7:\n                is_source = (r, c) in source_cells # Check if it was marked as a source\n\n                # Check if it's isolated (all neighbors are '7')\n                is_isolated = True\n                neighbors_coords = get_neighbors(r, c, height, width)\n                if not neighbors_coords: # Cell has no neighbors (e.g., 1x1 grid)\n                    is_isolated = False # Define as not isolated if no neighbors exist\n                else:\n                    for nr, nc in neighbors_coords:\n                        if input_grid[nr][nc] != 7:\n                            is_isolated = False\n                            break\n\n                # Step 5a & 5b: Update the output grid if it's a source or isolated\n                if is_source or is_isolated:\n                    output_grid[r][c] = 7\n\n    # Step 6: Return the final transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 1931,
    "candidates_token_count": 4395,
    "total_token_count": 6326,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 37.562965,
  "retries": 1
}