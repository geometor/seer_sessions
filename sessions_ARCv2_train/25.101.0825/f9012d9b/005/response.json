{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify Template Size:** Locate the bounding box of all white (0) pixels in the input grid. Determine its height (H) and width (W).\n2.  **Identify & Count Candidates:** Scan the input grid to find all unique HxW subgrids that contain *no* white pixels. Store the location (top-left corner) of the first occurrence of each unique pattern. Count the number of unique patterns found (k).\n3.  **Sort Candidates:** Create a list of these unique candidate patterns and sort them lexicographically. Let the sorted list be S = [S0, S1, ..., S(k-1)].\n4.  **Select Target Pattern:**\n    *   If the count `k` is equal to the template area `H * W`: Select the pattern at index `1 % k` in the sorted list (effectively index 1 if k>1, index 0 if k=1) as the Target Pattern.\n    *   If the count `k` is *not* equal to the template area `H * W`: Select the pattern at index `k-1` (the last pattern / lexicographically largest) in the sorted list as the Target Pattern.\n5.  **Find First Occurrence:** Retrieve the pre-recorded location of the first occurrence for the selected Target Pattern.\n6.  **Extract Output:** Return the HxW subgrid from the input grid starting at the location found in step 5.\n\"\"\"\n\n\n# Helper function to find the bounding box of all pixels of a specific color\ndef find_color_bbox(grid: np.ndarray, color: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the minimum bounding box containing all pixels of the given color.\n    Returns (min_row, min_col, height, width) or None if color not found.\n    \"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None\n    min_row, max_row = np.min(rows), np.max(rows)\n    min_col, max_col = np.min(cols), np.max(cols)\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    # Return the top-left corner (min_row, min_col) as well\n    return min_row, min_col, height, width \n\n# Helper function to extract a subgrid\ndef extract_subgrid(grid: np.ndarray, r: int, c: int, h: int, w: int) -> np.ndarray:\n    \"\"\"Extracts a subgrid of size h x w starting at (r, c).\"\"\"\n    return grid[r:r+h, c:c+w]\n\n# Helper function to convert numpy array to tuple for dict keys/sorting\ndef grid_to_tuple(grid: np.ndarray) -> tuple:\n    \"\"\"Converts a numpy array (grid) to a hashable tuple of tuples.\"\"\"\n    # Ensure the input is a 2D numpy array before mapping\n    if not isinstance(grid, np.ndarray):\n         return tuple() # Should not happen with proper slicing\n    if grid.ndim == 1:\n         grid = grid.reshape(1, -1) # Handle 1D case (e.g., 1xN or Nx1)\n    elif grid.ndim == 0:\n         grid = grid.reshape(1, 1) # Handle scalar case (1x1)\n         \n    # Ensure elements within rows are tuples of standard Python ints if needed,\n    # although numpy types are usually hashable. Stick with numpy types for now.\n    return tuple(map(tuple, grid))\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation based on finding a white template block,\n    identifying candidate patterns without white pixels, selecting one based\n    on comparing candidate count (k) to template area (H*W), \n    and finding the first occurrence of the selected pattern.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    grid_h, grid_w = input_array.shape\n\n    # 1. Identify Template Size\n    white_bbox = find_color_bbox(input_array, 0)\n    if white_bbox is None:\n        # No white block found, cannot determine template size.\n        return [] # Return empty list for failure/ambiguity\n        \n    _, _, h, w = white_bbox # Template height and width\n\n    # Check if template size is valid\n    if h <= 0 or w <= 0 or h > grid_h or w > grid_w:\n         return []\n\n    # 2. Identify & Count Candidates (unique patterns without white pixels)\n    #    Store the first occurrence location for each unique pattern found.\n    pattern_first_occurrence: Dict[tuple, Tuple[int, int]] = {}\n\n    for r in range(grid_h - h + 1):\n        for c in range(grid_w - w + 1):\n            subgrid = extract_subgrid(input_array, r, c, h, w)\n            \n            # Skip if the subgrid contains any white pixels (color 0)\n            if np.any(subgrid == 0):\n                continue\n                \n            pattern_key = grid_to_tuple(subgrid)\n            \n            # Record the first time (top-leftmost location) we encounter this pattern\n            if pattern_key not in pattern_first_occurrence:\n                pattern_first_occurrence[pattern_key] = (r, c)\n\n    # If no non-white patterns of the required size were found\n    if not pattern_first_occurrence:\n         return []\n\n    # 3. Sort Candidates\n    candidate_patterns = list(pattern_first_occurrence.keys())\n    k = len(candidate_patterns)\n    sorted_patterns = sorted(candidate_patterns)\n    \n    # 4. Select Target Pattern\n    hw = h * w\n    target_pattern_key = None\n\n    if k > 0: # Ensure there are candidates to select from\n        if k == hw:\n            # Rule: If k == H*W, select the pattern at index (1 % k)\n            # This handles k=1 case correctly (1%1=0), and k>1 case (selects index 1)\n            select_index = 1 % k\n            target_pattern_key = sorted_patterns[select_index]\n        else:\n            # Rule: If k != H*W, select the pattern at index k-1 (largest)\n            select_index = k - 1\n            target_pattern_key = sorted_patterns[select_index]\n    \n    # If no target pattern was selected (e.g., if k=0, although handled above)\n    if target_pattern_key is None:\n        return []\n\n    # 5. Find First Occurrence location (already stored)\n    try:\n        first_occurrence_r, first_occurrence_c = pattern_first_occurrence[target_pattern_key]\n    except KeyError:\n         # This should not happen if target_pattern_key came from the dictionary keys\n         return [] \n\n    # 6. Extract and return the subgrid found at that first occurrence location.\n    output_array = extract_subgrid(input_array, first_occurrence_r, first_occurrence_c, h, w)\n    \n    # Convert the numpy array back to a list of lists for the final output\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 20950,
    "candidates_token_count": 2809,
    "total_token_count": 23759,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.694372,
  "retries": 1
}