{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom typing import List, Tuple, Optional, Dict\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify Template Size:** Locate the bounding box of all white (0) pixels in the input grid. Let its dimensions be Height (H) and Width (W).\n2.  **Identify Candidate Patterns:** Scan the input grid and find all unique HxW subgrids that do *not* contain any white pixels (value 0). Store the location (top-left corner) of the first occurrence of each unique pattern.\n3.  **Select Target Pattern:** Apply a selection rule to choose one specific pattern (P_target) from the unique candidate patterns identified in step 2. The rule used here is based on comparing the count (k) of unique candidate patterns to the size of the template (H * W):\n    - If k equals H * W, select the lexicographically *smallest* candidate pattern.\n    - If k does not equal H * W, select the lexicographically *largest* candidate pattern.\n    - NOTE: This rule works for train_1 and train_3 but is known to fail for train_2. The correct general rule remains undetermined from the provided examples.\n4.  **Find First Occurrence:** Retrieve the pre-recorded location of the first occurrence for the selected Target Pattern (P_target).\n5.  **Extract Output:** Return the HxW subgrid from the input grid starting at the location found in step 4.\n\"\"\"\n\n\n# Helper function to find the bounding box of all pixels of a specific color\ndef find_color_bbox(grid: np.ndarray, color: int) -> Optional[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds the minimum bounding box containing all pixels of the given color.\n    Returns (min_row, min_col, height, width) or None if color not found.\n    \"\"\"\n    rows, cols = np.where(grid == color)\n    if rows.size == 0:\n        return None\n    min_row, max_row = np.min(rows), np.max(rows)\n    min_col, max_col = np.min(cols), np.max(cols)\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    # Return the top-left corner (min_row, min_col) as well\n    return min_row, min_col, height, width \n\n# Helper function to extract a subgrid\ndef extract_subgrid(grid: np.ndarray, r: int, c: int, h: int, w: int) -> np.ndarray:\n    \"\"\"Extracts a subgrid of size h x w starting at (r, c).\"\"\"\n    return grid[r:r+h, c:c+w]\n\n# Helper function to convert numpy array to tuple for dict keys/sorting\ndef grid_to_tuple(grid: np.ndarray) -> tuple:\n    \"\"\"Converts a numpy array (grid) to a hashable tuple of tuples.\"\"\"\n    # Ensure the input is a 2D numpy array before mapping\n    if not isinstance(grid, np.ndarray):\n         return tuple() # Should not happen with proper slicing\n    if grid.ndim == 1:\n         grid = grid.reshape(1, -1) # Handle 1D case (e.g., 1xN or Nx1)\n    elif grid.ndim == 0:\n         grid = grid.reshape(1, 1) # Handle scalar case (1x1)\n         \n    return tuple(map(tuple, grid))\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Applies the transformation based on finding a white template block,\n    identifying candidate patterns without white pixels, selecting one based\n    on the k vs H*W rule, and finding its first occurrence.\n    \"\"\"\n    input_array = np.array(input_grid, dtype=int)\n    grid_h, grid_w = input_array.shape\n\n    # 1. Find the white block bounding box to get template H and W\n    white_bbox = find_color_bbox(input_array, 0)\n    if white_bbox is None:\n        # No white block found, cannot determine template size.\n        return [] # Return empty list for failure/ambiguity\n        \n    _, _, h, w = white_bbox # Template height and width\n\n    # Check if template size is valid\n    if h <= 0 or w <= 0 or h > grid_h or w > grid_w:\n         return []\n\n    # 2. Identify unique candidate patterns (no white pixels) and their first occurrences\n    pattern_first_occurrence: Dict[tuple, Tuple[int, int]] = {}\n\n    for r in range(grid_h - h + 1):\n        for c in range(grid_w - w + 1):\n            subgrid = extract_subgrid(input_array, r, c, h, w)\n            \n            # Skip if the subgrid contains any white pixels (color 0)\n            if np.any(subgrid == 0):\n                continue\n                \n            pattern_key = grid_to_tuple(subgrid)\n            \n            # Record the first time (top-leftmost location) we encounter this pattern\n            if pattern_key not in pattern_first_occurrence:\n                pattern_first_occurrence[pattern_key] = (r, c)\n\n    # If no non-white patterns of the required size were found\n    if not pattern_first_occurrence:\n         return []\n\n    # 3. Select Target Pattern using the k vs H*W rule\n    candidate_patterns = list(pattern_first_occurrence.keys())\n    k = len(candidate_patterns)\n    hw = h * w\n\n    # Sort the patterns lexicographically to apply the rule\n    sorted_patterns = sorted(candidate_patterns)\n    \n    target_pattern_key = None\n    if k == hw:\n        # Rule: If k == H*W, select the lexicographically smallest\n        target_pattern_key = sorted_patterns[0]\n    else:\n        # Rule: If k != H*W, select the lexicographically largest\n        target_pattern_key = sorted_patterns[-1]\n        \n    # Check if a target was actually selected (should always happen if candidates exist)\n    if target_pattern_key is None:\n         return []\n\n    # 4. Find First Occurrence location (already stored)\n    # Retrieve the location where the target pattern *first* appeared.\n    try:\n        first_occurrence_r, first_occurrence_c = pattern_first_occurrence[target_pattern_key]\n    except KeyError:\n         # This should not happen if target_pattern_key came from the dictionary keys\n         return [] \n\n    # 5. Extract and return the subgrid found at that first occurrence location.\n    output_array = extract_subgrid(input_array, first_occurrence_r, first_occurrence_c, h, w)\n    \n    # Convert the numpy array back to a list of lists for the final output\n    return output_array.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 12349,
    "candidates_token_count": 2608,
    "total_token_count": 14957,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.180836,
  "retries": 1
}