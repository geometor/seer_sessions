{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\n\n\"\"\"\nTransforms a 3x3 input grid into a 9x9 output grid.\nThe input grid contains exactly one red pixel (2) and several pixels of another \n'active' color (non-white, non-red).\nThe output grid is white (0) except for two 4x4 blocks of the 'active' color.\nThe placement of these two blocks depends on the relative position of the \n'active' color pixels with respect to the red pixel in the input grid:\n- If the 'active' pixels are predominantly below and/or to the right of the red pixel, \n  the 4x4 blocks are placed starting at (1,1) and (5,5) in the 9x9 output grid.\n- If the 'active' pixels are predominantly above and/or to the left of the red pixel, \n  the 4x4 blocks are placed starting at (0,0) and (4,4) in the 9x9 output grid.\n\"\"\"\n\ndef find_pixels(grid: np.ndarray, color: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates of pixels with a specific color.\"\"\"\n    rows, cols = np.where(grid == color)\n    return list(zip(rows, cols))\n\ndef get_active_color(grid: np.ndarray) -> int | None:\n    \"\"\"Finds the single 'active' color (non-white, non-red).\"\"\"\n    unique_colors = np.unique(grid)\n    active_colors = [c for c in unique_colors if c != 0 and c != 2]\n    if len(active_colors) == 1:\n        return active_colors[0]\n    # Handle cases with no or multiple active colors if necessary, \n    # but task description implies exactly one.\n    return None \n\ndef determine_relative_direction(red_coord: tuple[int, int], active_coords: list[tuple[int, int]]) -> str:\n    \"\"\"Determines if active pixels are predominantly above/left or below/right of the red pixel.\"\"\"\n    if not active_coords:\n        return \"unknown\" # Or some default\n        \n    rr, rc = red_coord\n    \n    # Calculate average relative coordinates\n    avg_dr = np.mean([r - rr for r, c in active_coords])\n    avg_dc = np.mean([c - rc for r, c in active_coords])\n\n    # Determine overall direction based on average relative coords\n    # Using a small threshold helps avoid issues with exact zero averages, though not strictly needed for these examples.\n    thresh = 0.0 \n    is_above = avg_dr < -thresh\n    is_below = avg_dr > thresh\n    is_left = avg_dc < -thresh\n    is_right = avg_dc > thresh\n\n    # Prioritize the patterns seen in examples\n    if is_above and is_left:\n        return \"above-left\"\n    if is_below and is_right:\n        return \"below-right\"\n        \n    # Fallback/general direction logic if needed (more complex scenarios)\n    if is_below or is_right:\n        return \"below-right\" # Default preference if mixed but tends towards this side\n    elif is_above or is_left:\n        return \"above-left\" # Default preference if mixed but tends towards this side\n    else:\n        # This case (average exactly at red pixel) shouldn't happen with multiple active pixels\n        # unless perfectly symmetrical, but we need a default.\n        # Let's arbitrarily choose one based on example frequency or simplicity.\n        return \"below-right\" # Arbitrary default if perfectly centered\n\ndef place_block(grid: np.ndarray, color: int, r_start: int, c_start: int, size: int = 4):\n    \"\"\"Places a square block of a given color onto the grid.\"\"\"\n    grid[r_start:r_start+size, c_start:c_start+size] = color\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:  \n    \"\"\"\n    Transforms the input grid based on the relative position of active color pixels\n    to the red pixel.\n    \"\"\"\n    input_np = np.array(input_grid, dtype=int)\n    input_height, input_width = input_np.shape\n    \n    # Assume output is always 3x input size based on examples\n    output_height = input_height * 3\n    output_width = input_width * 3\n    \n    # Initialize output grid with white (0)\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # Find the single red pixel (color 2)\n    red_pixels = find_pixels(input_np, 2)\n    if not red_pixels:\n        # Handle error: No red pixel found (or return default grid)\n        return output_grid.tolist() \n    red_coord = red_pixels[0] # Assume exactly one red pixel\n\n    # Find the active color and its pixels\n    active_color = get_active_color(input_np)\n    if active_color is None:\n        # Handle error: No or multiple active colors found (or return default grid)\n        return output_grid.tolist() \n    active_coords = find_pixels(input_np, active_color)\n\n    # Determine the relative direction of active pixels\n    direction = determine_relative_direction(red_coord, active_coords)\n\n    # Place the two 4x4 blocks based on the direction\n    if direction == \"above-left\":\n        place_block(output_grid, active_color, 0, 0)\n        place_block(output_grid, active_color, 4, 4)\n    elif direction == \"below-right\":\n        place_block(output_grid, active_color, 1, 1)\n        place_block(output_grid, active_color, 5, 5)\n    # else: # Handle 'unknown' or other directions if the logic is expanded\n        # Default behavior or error handling\n        # For now, assume it must be one of the two based on examples\n\n    # Convert back to list of lists for the expected output format\n    return output_grid.tolist()\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 6554,
    "candidates_token_count": 2449,
    "total_token_count": 9003,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.803216,
  "retries": 1
}