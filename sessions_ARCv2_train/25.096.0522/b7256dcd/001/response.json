{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid of integers based on the following rules:\n\n1. Identifies connected components of cells with the value 6 (using 4-way adjacency).\n2. For each component of 6s:\n    a. Finds all unique non-6, non-7 colors (\"source colors\": 1, 3, 4) in adjacent cells.\n    b. If exactly one unique source color is adjacent, all cells in the 6s component change to that source color. The coordinates of the influencing source cell(s) are noted.\n    c. If no source colors are adjacent:\n        i. If the input grid contains the color 4 anywhere, all cells in the 6s component change to 4.\n        ii. Otherwise (input grid does not contain 4), the cells in the 6s component remain 6.\n    d. If more than one unique source color is adjacent, the cells in the 6s component remain 6.\n3. All original source color cells (1, 3, 4 in the input grid) are changed to 7 in the output grid, regardless of whether they influenced a component of 6s.\n4. All other cells (including the background color 7) retain their original value unless modified by the above rules.\n\"\"\"\n\ndef _find_components(grid: list[list[int]], target_value: int) -> list[set[tuple[int, int]]]:\n    \"\"\"Finds all connected components of target_value using BFS.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0]) if rows > 0 else 0\n    visited = set()\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == target_value and (r, c) not in visited:\n                component = set()\n                q = deque([(r, c)])\n                visited.add((r, c))\n                component.add((r, c))\n\n                while q:\n                    row, col = q.popleft()\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = row + dr, col + dc\n                        if 0 <= nr < rows and 0 <= nc < cols and \\\n                           grid[nr][nc] == target_value and (nr, nc) not in visited:\n                            visited.add((nr, nc))\n                            component.add((nr, nc))\n                            q.append((nr, nc))\n                components.append(component)\n    return components\n\ndef _get_valid_neighbors(rows: int, cols: int, r: int, c: int) -> list[tuple[int, int]]:\n    \"\"\"Gets valid neighbor coordinates within grid bounds.\"\"\"\n    neighbors = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < rows and 0 <= nc < cols:\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rules to the input grid.\n    \"\"\"\n    # initialize output_grid as a deep copy of input_grid\n    output_grid = copy.deepcopy(input_grid)\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    source_colors = {1, 3, 4}\n    mutable_color = 6\n    background_color = 7\n\n    # Check if 4 exists anywhere in the input grid\n    input_contains_4 = any(4 in row for row in input_grid)\n\n    # Find all connected components of the mutable color (6)\n    components_6 = _find_components(input_grid, mutable_color)\n\n    # Store original locations of source colors\n    original_source_locations = set()\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r][c] in source_colors:\n                original_source_locations.add((r, c))\n\n    # Process each component of 6s\n    for component in components_6:\n        adjacent_source_colors = set()\n        # adjacent_source_coords = set() # Not needed based on revised understanding of step 6\n\n        # Find unique adjacent source colors for the current component\n        for r_comp, c_comp in component:\n            neighbors = _get_valid_neighbors(rows, cols, r_comp, c_comp)\n            for nr, nc in neighbors:\n                neighbor_val = input_grid[nr][nc]\n                if neighbor_val in source_colors:\n                    adjacent_source_colors.add(neighbor_val)\n                    # adjacent_source_coords.add((nr, nc)) # Not needed\n\n        num_unique_sources = len(adjacent_source_colors)\n\n        # Apply transformation rules based on adjacent sources\n        if num_unique_sources == 1:\n            # Change component to the single adjacent source color\n            source_color = adjacent_source_colors.pop()\n            for r_comp, c_comp in component:\n                output_grid[r_comp][c_comp] = source_color\n            # Mark influencing source cells - Revised: This tracking isn't needed for final step\n            # used_source_coords.update(coords for coords in adjacent_source_coords if input_grid[coords[0]][coords[1]] == source_color)\n\n        elif num_unique_sources == 0:\n            # No adjacent sources - check global presence of 4\n            if input_contains_4:\n                # Change component to 4\n                for r_comp, c_comp in component:\n                    output_grid[r_comp][c_comp] = 4\n            # else: component remains 6 (already the case in output_grid copy)\n\n        # else (num_unique_sources > 1): component remains 6 (already the case)\n\n    # Neutralize all original source cells\n    for r_src, c_src in original_source_locations:\n         output_grid[r_src][c_src] = background_color\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2032,
    "candidates_token_count": 2642,
    "total_token_count": 4674,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 23.2404,
  "retries": 1
}