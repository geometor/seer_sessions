{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransforms an input 2D grid of integers into an output 1x1 or 2x2 grid based on frequency analysis of subgrids.\n\nThe core logic branches based on the input grid size:\n\n1.  **If Grid <= 4x4:**\n    - Find all unique non-zero 1x1 elements (numbers).\n    - Count their frequencies.\n    - Find the minimum frequency.\n    - Select the number(s) with this minimum frequency.\n    - Tie-break: Choose the largest numerical value among the tied numbers.\n    - Output the selected number as a 1x1 grid.\n\n2.  **If Grid > 4x4:**\n    - Find all unique non-zero 2x2 subgrids.\n    - Record each pattern, its frequency, and all its top-left occurrence coordinates.\n    - **If no non-zero 2x2 subgrids exist:** Fall back to the 1x1 logic (Rule 1).\n    - **If non-zero 2x2 subgrids exist:**\n        - Separate patterns into two groups: those with frequency F=1 and those with F>1.\n        - **If there are NO patterns with F>1 (all unique patterns appear only once):**\n            - Consider all the F=1 patterns.\n            - Tie-break: Select the pattern whose single occurrence is bottom-most (max row index), then right-most (max column index).\n            - Output the selected 2x2 pattern.\n        - **Else (at least one pattern has F>1):**\n            - Consider only the patterns with F>1.\n            - Find the minimum frequency among *these* patterns (F>1).\n            - Select the pattern(s) with this minimum frequency.\n            - Tie-break: For each tied pattern, find its *first* occurrence (top-most, then left-most). Select the pattern whose *first* occurrence is bottom-most (max row index), then left-most (min column index).\n            - Output the selected 2x2 pattern.\n\"\"\"\n\ndef _get_non_zero_2x2_patterns_with_details(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds all unique non-zero 2x2 subgrids, their frequencies, and occurrences.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A dictionary where keys are pattern tuples (tuple of tuples)\n        and values are dictionaries {'freq': int, 'occurrences': list[tuple(int, int)]}.\n    \"\"\"\n    patterns_details = defaultdict(lambda: {'freq': 0, 'occurrences': []})\n    rows, cols = grid.shape\n    if rows < 2 or cols < 2:\n        return {}\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements are non-zero\n            if np.all(subgrid != 0):\n                # Convert numpy array to tuple of tuples for hashability\n                pattern_tuple = tuple(tuple(row) for row in subgrid)\n                patterns_details[pattern_tuple]['freq'] += 1\n                patterns_details[pattern_tuple]['occurrences'].append((r, c))\n\n    # Sort occurrences for each pattern (top-down, left-right) to easily find first/last\n    for pattern in patterns_details:\n        patterns_details[pattern]['occurrences'].sort()\n\n    return dict(patterns_details)\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    input_grid = np.array(input_grid_list)\n    rows, cols = input_grid.shape\n\n    # ========== Rule 1: Grid <= 4x4 ==========\n    if rows <= 4 and cols <= 4:\n        # Find all non-zero 1x1 elements\n        non_zero_1x1 = [val for val in input_grid.flat if val != 0]\n\n        if not non_zero_1x1:\n             return [[]] # Handle empty or all-zero grid case\n\n        # Count frequencies\n        non_zero_1x1_freq = Counter(non_zero_1x1)\n\n        # Find minimum frequency\n        min_freq_1x1 = min(non_zero_1x1_freq.values())\n\n        # Identify numbers with minimum frequency\n        patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n\n        # Tie-breaking: largest numerical value\n        selected_pattern_1x1 = max(patterns_min_freq_1x1)\n        return [[selected_pattern_1x1]]\n\n    # ========== Rule 2: Grid > 4x4 ==========\n    else:\n        # Find all non-zero 2x2 patterns with details\n        patterns_2x2_details = _get_non_zero_2x2_patterns_with_details(input_grid)\n\n        # If no non-zero 2x2 patterns exist, fall back to 1x1 logic\n        if not patterns_2x2_details:\n            non_zero_1x1 = [val for val in input_grid.flat if val != 0]\n            if not non_zero_1x1: return [[]]\n            non_zero_1x1_freq = Counter(non_zero_1x1)\n            min_freq_1x1 = min(non_zero_1x1_freq.values())\n            patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n            selected_pattern_1x1 = max(patterns_min_freq_1x1)\n            return [[selected_pattern_1x1]]\n\n        # Separate patterns by frequency (F=1 vs F>1)\n        patterns_f1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] == 1}\n        patterns_f_gt1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] > 1}\n\n        # Case 2.c.ii: Only F=1 patterns exist\n        if not patterns_f_gt1:\n            selected_pattern = None\n            best_occurrence = (-1, -1) # (row, col)\n\n            for pattern, details in patterns_f1.items():\n                # Since freq is 1, there's only one occurrence\n                current_occurrence = details['occurrences'][0]\n                # Tie-breaking: bottom-most (max row), then right-most (max col)\n                if current_occurrence[0] > best_occurrence[0] or \\\n                   (current_occurrence[0] == best_occurrence[0] and current_occurrence[1] > best_occurrence[1]):\n                    best_occurrence = current_occurrence\n                    selected_pattern = pattern\n\n            # Convert selected pattern tuple back to list of lists\n            return [list(row) for row in selected_pattern] if selected_pattern else [[]]\n\n\n        # Case 2.c.iii: Patterns with F>1 exist\n        else:\n            # Find the minimum frequency among patterns with F>1\n            min_freq_gt1 = min(details['freq'] for details in patterns_f_gt1.values())\n\n            # Identify patterns matching this minimum frequency\n            candidate_patterns = {p: d for p, d in patterns_f_gt1.items() if d['freq'] == min_freq_gt1}\n\n            selected_pattern = None\n            # Tie-breaking criteria: first occurrence (max row, min col)\n            best_first_occurrence = (-1, float('inf'))\n\n            for pattern, details in candidate_patterns.items():\n                # First occurrence is the first element in the sorted list\n                first_occurrence = details['occurrences'][0]\n\n                # Tie-breaking: bottom-most (max row), then left-most (min col) for the *first* occurrence\n                if first_occurrence[0] > best_first_occurrence[0] or \\\n                   (first_occurrence[0] == best_first_occurrence[0] and first_occurrence[1] < best_first_occurrence[1]):\n                    best_first_occurrence = first_occurrence\n                    selected_pattern = pattern\n\n            # Convert selected pattern tuple back to list of lists\n            return [list(row) for row in selected_pattern] if selected_pattern else [[]]\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 9670,
    "candidates_token_count": 2749,
    "total_token_count": 12419,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.058879,
  "retries": 1
}