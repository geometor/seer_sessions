{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter\n\n\"\"\"\nAnalyzes a 2D grid of integers to extract a specific pattern (1x1 or 2x2) based on the frequency of non-zero subgrids.\n\nThe logic proceeds as follows:\n1. Find all unique 2x2 subgrids consisting entirely of non-zero numbers and count their frequencies.\n2. If any non-zero 2x2 subgrids exist:\n   a. Find the minimum frequency (`F_min_2x2`) among them.\n   b. If `F_min_2x2` is 1:\n      i. Identify all patterns with frequency 1.\n      ii. Apply tie-breaking: Select the pattern whose last occurrence (scanning top-to-bottom, left-to-right) is bottom-most, then right-most.\n      iii. Output the selected 2x2 pattern.\n   c. If `F_min_2x2` is greater than 1:\n      i. Check the grid dimensions (Rows x Cols).\n      ii. If Rows <= 4 and Cols <= 4: Proceed to step 3 (1x1 analysis).\n      iii. If Rows > 4 or Cols > 4:\n         - Find the maximum frequency (`F_max_2x2`) among the non-zero 2x2 subgrids.\n         - Identify all patterns with this maximum frequency.\n         - Apply tie-breaking: Select the pattern whose first occurrence (scanning top-to-bottom, left-to-right) is bottom-most, then left-most.\n         - Output the selected 2x2 pattern.\n3. If no non-zero 2x2 subgrids exist OR if step 2.c.ii was triggered:\n   a. Find all unique non-zero numbers (1x1 patterns) in the grid and count their frequencies.\n   b. Find the minimum frequency (`F_min_1x1`) among them.\n   c. Identify all numbers with this minimum frequency.\n   d. Apply tie-breaking: Select the largest numerical value among the tied numbers.\n   e. Output the selected number as a 1x1 grid.\n\nOutput Format:\n- A single number is returned as [[number]].\n- A 2x2 grid is returned as [[row1_val1, row1_val2], [row2_val1, row2_val2]].\n\"\"\"\n\ndef _get_subgrids(grid: np.ndarray, size: int) -> list[tuple[tuple[int, ...], ...]]:\n    \"\"\"Extracts all subgrids of a given square size from the grid.\"\"\"\n    subgrids = []\n    rows, cols = grid.shape\n    for r in range(rows - size + 1):\n        for c in range(cols - size + 1):\n            subgrid_np = grid[r:r+size, c:c+size]\n            # Convert numpy array to tuple of tuples for hashability\n            subgrid_tuple = tuple(tuple(row) for row in subgrid_np)\n            subgrids.append(((r, c), subgrid_tuple)) # Store top-left corner too\n    return subgrids\n\ndef _is_non_zero(subgrid_tuple: tuple[tuple[int, ...], ...]) -> bool:\n    \"\"\"Checks if a subgrid (tuple of tuples) contains only non-zero elements.\"\"\"\n    return all(all(val != 0 for val in row) for row in subgrid_tuple)\n\ndef _find_occurrences(grid: np.ndarray, pattern: tuple[tuple[int, ...], ...]) -> list[tuple[int, int]]:\n    \"\"\"Finds all top-left coordinates of a pattern in the grid.\"\"\"\n    occurrences = []\n    rows, cols = grid.shape\n    p_rows, p_cols = len(pattern), len(pattern[0])\n    pattern_np = np.array(pattern)\n\n    for r in range(rows - p_rows + 1):\n        for c in range(cols - p_cols + 1):\n            subgrid_np = grid[r:r+p_rows, c:c+p_cols]\n            if np.array_equal(subgrid_np, pattern_np):\n                occurrences.append((r, c))\n    return occurrences\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Transforms the input grid based on the frequency analysis of non-zero subgrids.\n    \"\"\"\n    input_grid = np.array(input_grid_list)\n    rows, cols = input_grid.shape\n\n    # --- Step 1 & 2: Analyze 2x2 non-zero subgrids ---\n    all_2x2_subgrids_with_pos = _get_subgrids(input_grid, size=2)\n    non_zero_2x2_subgrids = [sg for _, sg in all_2x2_subgrids_with_pos if _is_non_zero(sg)]\n\n    non_zero_2x2_freq = Counter(non_zero_2x2_subgrids)\n    min_freq_2x2 = float('inf')\n    max_freq_2x2 = 0\n    patterns_min_freq_2x2 = []\n    patterns_max_freq_2x2 = []\n\n    if non_zero_2x2_freq:\n        min_freq_2x2 = min(non_zero_2x2_freq.values())\n        max_freq_2x2 = max(non_zero_2x2_freq.values())\n        patterns_min_freq_2x2 = [p for p, freq in non_zero_2x2_freq.items() if freq == min_freq_2x2]\n        patterns_max_freq_2x2 = [p for p, freq in non_zero_2x2_freq.items() if freq == max_freq_2x2]\n\n    # --- Step 3: Check for minimum frequency == 1 for 2x2 ---\n    if min_freq_2x2 == 1:\n        selected_pattern_2x2 = None\n        last_occurrence_pos = (-1, -1)\n\n        for pattern in patterns_min_freq_2x2:\n            occurrences = _find_occurrences(input_grid, pattern)\n            # We only care about the single occurrence since freq is 1\n            current_pos = occurrences[0] # Should only be one\n            # Tie-breaking: bottom-most, then right-most (use > for both)\n            if current_pos[0] > last_occurrence_pos[0] or \\\n               (current_pos[0] == last_occurrence_pos[0] and current_pos[1] > last_occurrence_pos[1]):\n                last_occurrence_pos = current_pos\n                selected_pattern_2x2 = pattern\n\n        return [list(row) for row in selected_pattern_2x2] # Convert tuple back to list\n\n    # --- Step 4: Handle F_min_2x2 > 1 (or none found) AND small grid ---\n    if (not non_zero_2x2_freq or min_freq_2x2 > 1) and (rows <= 4 and cols <= 4):\n        # Analyze 1x1 non-zero elements\n        non_zero_1x1 = [val for row in input_grid_list for val in row if val != 0]\n        if not non_zero_1x1:\n             return [[]] # Or handle as error, though examples suggest this won't happen with non-zero outputs\n\n        non_zero_1x1_freq = Counter(non_zero_1x1)\n        min_freq_1x1 = min(non_zero_1x1_freq.values())\n        patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n\n        # Tie-breaking: largest numerical value\n        selected_pattern_1x1 = max(patterns_min_freq_1x1)\n        return [[selected_pattern_1x1]]\n\n    # --- Step 5: Handle F_min_2x2 > 1 AND large grid ---\n    if min_freq_2x2 > 1 and (rows > 4 or cols > 4):\n         # Use maximum frequency 2x2 patterns\n        selected_pattern_2x2 = None\n        first_occurrence_criteria = (-1, float('inf')) # (max_row, min_col)\n\n        for pattern in patterns_max_freq_2x2:\n            # Find the *first* occurrence (top-down, left-right)\n            first_occurrence = _find_occurrences(input_grid, pattern)[0]\n\n            # Tie-breaking: first occurrence bottom-most (max row), then left-most (min col)\n            if first_occurrence[0] > first_occurrence_criteria[0] or \\\n               (first_occurrence[0] == first_occurrence_criteria[0] and first_occurrence[1] < first_occurrence_criteria[1]):\n                first_occurrence_criteria = first_occurrence\n                selected_pattern_2x2 = pattern\n\n        return [list(row) for row in selected_pattern_2x2] # Convert tuple back to list\n\n    # Fallback or error case if none of the conditions are met\n    # This might indicate an issue with the logic or an unexpected input type.\n    # Based on the examples, one of the above conditions should always be met.\n    # If non_zero_2x2_freq is empty and the grid is large, the logic defaults here.\n    # Let's assume the 1x1 logic should apply if no non-zero 2x2 exist, regardless of size.\n    # Revisit Step 4 condition:\n    if not non_zero_2x2_freq:\n        non_zero_1x1 = [val for row in input_grid_list for val in row if val != 0]\n        if not non_zero_1x1:\n             return [[]] \n        non_zero_1x1_freq = Counter(non_zero_1x1)\n        min_freq_1x1 = min(non_zero_1x1_freq.values())\n        patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n        selected_pattern_1x1 = max(patterns_min_freq_1x1)\n        return [[selected_pattern_1x1]]\n\n\n    # If we reached here, something unexpected happened.\n    # Maybe return empty or raise an error, but based on examples, it should not happen.\n    # Returning empty list of lists as per type hint for now.\n    return [[]]\n\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 2059,
    "candidates_token_count": 3712,
    "total_token_count": 5771,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 27.536843,
  "retries": 1
}