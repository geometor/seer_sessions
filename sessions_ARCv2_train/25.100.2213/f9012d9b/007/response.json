{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransforms an input 2D grid of integers into an output 1x1 or 2x2 grid based on frequency analysis and grid size.\n\nRule Summary:\n1.  If Grid <= 4x4: Find the least frequent non-zero 1x1 number. Tie-break using the largest numerical value. Output as 1x1.\n2.  If Grid > 4x4:\n    a. Find all unique non-zero 2x2 patterns, their frequencies, and occurrence locations (top-left coordinates).\n    b. If no such patterns exist, fall back to Rule 1 (1x1 logic).\n    c. If patterns exist:\n        i. If *all* patterns have frequency 1: Select the pattern whose single occurrence is bottom-most (max row), then right-most (max col). Output as 2x2.\n        ii. If *some* patterns have frequency > 1: Consider only patterns with frequency > 1. Find the *minimum* frequency among these. Select the pattern(s) with this minimum frequency. Tie-break using the *first* occurrence (top-most row, then left-most col): select the pattern whose *first* occurrence is bottom-most (max row), then left-most (min col). Output as 2x2.\n\"\"\"\n\ndef _get_non_zero_2x2_patterns_with_details(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds all unique non-zero 2x2 subgrids, their frequencies, and occurrences.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A dictionary where keys are pattern tuples (tuple of tuples)\n        and values are dictionaries {'freq': int, 'occurrences': list[tuple(int, int)]}.\n        Occurrences are sorted primarily by row index, secondarily by column index.\n    \"\"\"\n    patterns_details = defaultdict(lambda: {'freq': 0, 'occurrences': []})\n    rows, cols = grid.shape\n    # Need at least a 2x2 grid to find 2x2 patterns\n    if rows < 2 or cols < 2:\n        return {}\n\n    # Iterate through all possible top-left corners of 2x2 subgrids\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements in the subgrid are non-zero\n            if np.all(subgrid != 0):\n                # Convert numpy array to tuple of tuples for hashability (dictionary key)\n                pattern_tuple = tuple(tuple(row) for row in subgrid)\n                # Increment frequency count and record occurrence coordinate\n                patterns_details[pattern_tuple]['freq'] += 1\n                patterns_details[pattern_tuple]['occurrences'].append((r, c))\n\n    # Sort occurrences for each pattern to easily find first/last\n    # Sorting is done top-down (row index), then left-right (column index)\n    for pattern in patterns_details:\n        patterns_details[pattern]['occurrences'].sort()\n\n    # Return the dictionary containing details for all found non-zero 2x2 patterns\n    return dict(patterns_details)\n\ndef _solve_1x1(input_grid: np.ndarray) -> list[list[int]]:\n    \"\"\"\n    Handles the logic for small grids (<=4x4) or as fallback:\n    Finds the least frequent, largest value 1x1 non-zero number.\n\n    Args:\n        input_grid: The input numpy array.\n\n    Returns:\n        The selected number as a 1x1 list of lists, or [[]] if no non-zero numbers exist.\n    \"\"\"\n    # Flatten the grid and filter out zero values\n    non_zero_1x1 = [val for val in input_grid.flat if val != 0]\n\n    # Handle case where grid contains only zeros or is empty\n    if not non_zero_1x1:\n         return [[]]\n\n    # Count the frequency of each non-zero number\n    non_zero_1x1_freq = Counter(non_zero_1x1)\n\n    # Find the minimum frequency among all non-zero numbers\n    min_freq_1x1 = min(non_zero_1x1_freq.values())\n\n    # Identify all numbers that occur with this minimum frequency\n    patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n\n    # Apply tie-breaking rule: select the largest numerical value among those tied\n    selected_pattern_1x1 = max(patterns_min_freq_1x1)\n\n    # Return the selected number formatted as a 1x1 grid\n    return [[selected_pattern_1x1]]\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    # Convert input list of lists to a numpy array for efficient processing\n    input_grid = np.array(input_grid_list)\n    rows, cols = input_grid.shape\n\n    # --- Branch based on Grid Size ---\n\n    # Rule 1: Grid dimensions are 4x4 or smaller\n    if rows <= 4 and cols <= 4:\n        # Use the helper function for 1x1 analysis\n        output_grid = _solve_1x1(input_grid)\n        return output_grid\n\n    # Rule 2: Grid dimensions are larger than 4x4 in at least one dimension\n    else:\n        # Step 2a: Find all non-zero 2x2 patterns and their details\n        patterns_2x2_details = _get_non_zero_2x2_patterns_with_details(input_grid)\n\n        # Step 2b: Handle fallback case: no non-zero 2x2 patterns found\n        if not patterns_2x2_details:\n            # Fall back to the 1x1 analysis logic\n            output_grid = _solve_1x1(input_grid)\n            return output_grid\n\n        # Step 2c: Non-zero 2x2 patterns exist, proceed with frequency analysis\n        else:\n            # Separate patterns based on frequency: F=1 and F>1\n            patterns_f1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] == 1}\n            patterns_f_gt1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] > 1}\n\n            # Step 2.c.i: Case where ONLY F=1 patterns exist\n            if not patterns_f_gt1:\n                selected_pattern = None\n                # Tie-breaking criteria: max row, then max col of the single occurrence\n                best_occurrence = (-1, -1) # Initialize to be beaten by any valid occurrence\n\n                # Iterate through all patterns (which have frequency 1)\n                for pattern, details in patterns_f1.items():\n                    # Get the single occurrence coordinate (list has only one element)\n                    current_occurrence = details['occurrences'][0]\n                    # Apply tie-breaker: bottom-most (max row), then right-most (max col)\n                    if current_occurrence[0] > best_occurrence[0] or \\\n                       (current_occurrence[0] == best_occurrence[0] and current_occurrence[1] > best_occurrence[1]):\n                        best_occurrence = current_occurrence\n                        selected_pattern = pattern\n\n                # Convert the selected pattern tuple back to list of lists\n                output_grid = [list(row) for row in selected_pattern] if selected_pattern else [[]]\n                return output_grid\n\n\n            # Step 2.c.ii: Case where patterns with F>1 exist\n            else:\n                # Find the minimum frequency among the group of patterns with F>1\n                min_freq_gt1 = min(details['freq'] for details in patterns_f_gt1.values())\n\n                # Identify candidate patterns matching this minimum frequency\n                candidate_patterns = {p: d for p, d in patterns_f_gt1.items() if d['freq'] == min_freq_gt1}\n\n                selected_pattern = None\n                # Tie-breaking criteria: max row, then min col of the *first* occurrence\n                # Initialize criteria to be beaten by any valid first occurrence\n                best_first_occurrence_criteria = (-1, float('inf')) # (row, col) - start row low, col high\n\n                # Iterate through candidate patterns\n                for pattern, details in candidate_patterns.items():\n                    # Get the first occurrence (list is sorted, so it's the first element)\n                    first_occurrence = details['occurrences'][0]\n\n                    # Apply tie-breaker: bottom-most (max row), then left-most (min col) for the *first* occurrence\n                    if first_occurrence[0] > best_first_occurrence_criteria[0] or \\\n                       (first_occurrence[0] == best_first_occurrence_criteria[0] and first_occurrence[1] < best_first_occurrence_criteria[1]):\n                        # Update best criteria and selected pattern\n                        best_first_occurrence_criteria = first_occurrence\n                        selected_pattern = pattern\n\n                # Convert the selected pattern tuple back to list of lists\n                output_grid = [list(row) for row in selected_pattern] if selected_pattern else [[]]\n                return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 23680,
    "candidates_token_count": 2947,
    "total_token_count": 26627,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 20.471816,
  "retries": 1
}