{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import Counter, defaultdict\n\n\"\"\"\nTransforms an input 2D grid of integers into an output 1x1 or 2x2 grid. The transformation logic depends on the grid size and the frequency analysis of non-zero subgrids (1x1 or 2x2).\n\nRule Summary:\n1.  If Grid <= 4x4: Find the least frequent non-zero 1x1 number. Tie-break using the largest numerical value. Output as 1x1.\n2.  If Grid > 4x4:\n    a. Find all unique non-zero 2x2 patterns, their frequencies, and occurrence locations.\n    b. If no such patterns exist, fall back to Rule 1 (1x1 logic).\n    c. If patterns exist:\n        i. If *all* patterns have frequency 1: Select the pattern whose single occurrence is bottom-most (max row), then right-most (max col). Output as 2x2.\n        ii. If *some* patterns have frequency > 1: Consider only patterns with frequency > 1. Find the *minimum* frequency among these. Select the pattern(s) with this minimum frequency. Tie-break using the *first* occurrence: select the one that is bottom-most (max row), then left-most (min col). Output as 2x2.\n\"\"\"\n\ndef _get_non_zero_2x2_patterns_with_details(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds all unique non-zero 2x2 subgrids, their frequencies, and occurrences.\n\n    Args:\n        grid: The input numpy array.\n\n    Returns:\n        A dictionary where keys are pattern tuples (tuple of tuples)\n        and values are dictionaries {'freq': int, 'occurrences': list[tuple(int, int)]}.\n        Occurrences are sorted (top-down, left-right).\n    \"\"\"\n    patterns_details = defaultdict(lambda: {'freq': 0, 'occurrences': []})\n    rows, cols = grid.shape\n    # Need at least a 2x2 grid to find 2x2 patterns\n    if rows < 2 or cols < 2:\n        return {}\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            subgrid = grid[r:r+2, c:c+2]\n            # Check if all elements are non-zero\n            if np.all(subgrid != 0):\n                # Convert numpy array to tuple of tuples for hashability\n                pattern_tuple = tuple(tuple(row) for row in subgrid)\n                patterns_details[pattern_tuple]['freq'] += 1\n                patterns_details[pattern_tuple]['occurrences'].append((r, c))\n\n    # Sort occurrences for each pattern (top-down, left-right) to easily find first/last\n    for pattern in patterns_details:\n        # Sort by row, then by column\n        patterns_details[pattern]['occurrences'].sort()\n\n    return dict(patterns_details)\n\ndef _solve_1x1(input_grid: np.ndarray) -> list[list[int]]:\n    \"\"\"\n    Handles the logic for finding the least frequent, largest value 1x1 non-zero number.\n    \"\"\"\n    # Find all non-zero 1x1 elements\n    non_zero_1x1 = [val for val in input_grid.flat if val != 0]\n\n    if not non_zero_1x1:\n         return [[]] # Handle empty or all-zero grid case\n\n    # Count frequencies\n    non_zero_1x1_freq = Counter(non_zero_1x1)\n\n    # Find minimum frequency\n    min_freq_1x1 = min(non_zero_1x1_freq.values())\n\n    # Identify numbers with minimum frequency\n    patterns_min_freq_1x1 = [p for p, freq in non_zero_1x1_freq.items() if freq == min_freq_1x1]\n\n    # Tie-breaking: largest numerical value\n    selected_pattern_1x1 = max(patterns_min_freq_1x1)\n    return [[selected_pattern_1x1]]\n\n\ndef transform(input_grid_list: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation logic to the input grid.\n    \"\"\"\n    # Convert input to numpy array for easier slicing and operations\n    input_grid = np.array(input_grid_list)\n    rows, cols = input_grid.shape\n\n    # --- Determine Grid Size Category and Apply Rule ---\n\n    # Rule 1: Grid dimensions are 4x4 or smaller\n    if rows <= 4 and cols <= 4:\n        # Delegate to 1x1 solving logic\n        return _solve_1x1(input_grid)\n\n    # Rule 2: Grid dimensions are larger than 4x4 in at least one dimension\n    else:\n        # Step 2a: Find all non-zero 2x2 patterns with details\n        patterns_2x2_details = _get_non_zero_2x2_patterns_with_details(input_grid)\n\n        # Step 2b: Handle case where no non-zero 2x2 patterns exist\n        if not patterns_2x2_details:\n            # Fall back to Rule 1 (1x1 logic)\n            return _solve_1x1(input_grid)\n\n        # Step 2c: Non-zero 2x2 patterns exist, proceed with frequency analysis\n        else:\n            # Separate patterns by frequency (F=1 vs F>1)\n            patterns_f1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] == 1}\n            patterns_f_gt1 = {p: d for p, d in patterns_2x2_details.items() if d['freq'] > 1}\n\n            # Step 2.c.i: Handle case where ONLY F=1 patterns exist\n            if not patterns_f_gt1:\n                selected_pattern = None\n                # Tie-breaking criteria: max row, then max col of the single occurrence\n                best_occurrence = (-1, -1) # Use (-1,-1) as initial comparison point\n\n                for pattern, details in patterns_f1.items():\n                    # Since freq is 1, there's only one occurrence\n                    current_occurrence = details['occurrences'][0]\n                    # Tie-breaking logic: higher row is better, if rows equal, higher col is better\n                    if current_occurrence[0] > best_occurrence[0] or \\\n                       (current_occurrence[0] == best_occurrence[0] and current_occurrence[1] > best_occurrence[1]):\n                        best_occurrence = current_occurrence\n                        selected_pattern = pattern\n\n                # Convert selected pattern tuple back to list of lists for output\n                return [list(row) for row in selected_pattern] if selected_pattern else [[]]\n\n\n            # Step 2.c.ii: Handle case where patterns with F>1 exist\n            else:\n                # Find the minimum frequency among patterns with F>1\n                min_freq_gt1 = min(details['freq'] for details in patterns_f_gt1.values())\n\n                # Identify candidate patterns matching this minimum frequency\n                candidate_patterns = {p: d for p, d in patterns_f_gt1.items() if d['freq'] == min_freq_gt1}\n\n                selected_pattern = None\n                # Tie-breaking criteria: max row, then min col of the *first* occurrence\n                # Initialize with values that will be beaten by any valid occurrence\n                best_first_occurrence_criteria = (-1, float('inf')) # (row, col)\n\n                for pattern, details in candidate_patterns.items():\n                    # First occurrence is the first element in the sorted list\n                    first_occurrence = details['occurrences'][0]\n\n                    # Tie-breaking logic: higher row is better, if rows equal, lower col is better\n                    if first_occurrence[0] > best_first_occurrence_criteria[0] or \\\n                       (first_occurrence[0] == best_first_occurrence_criteria[0] and first_occurrence[1] < best_first_occurrence_criteria[1]):\n                        best_first_occurrence_criteria = first_occurrence\n                        selected_pattern = pattern\n\n                # Convert selected pattern tuple back to list of lists for output\n                return [list(row) for row in selected_pattern] if selected_pattern else [[]]\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16866,
    "candidates_token_count": 2809,
    "total_token_count": 19675,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 19.536309,
  "retries": 1
}