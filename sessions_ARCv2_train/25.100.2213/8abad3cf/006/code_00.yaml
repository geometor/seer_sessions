task_description: "Construct an output grid by combining two blocks derived from specific regions of an input grid. The dimensions of the output grid and the transformation applied to one of the source blocks are context-dependent properties of the specific task instance."

definitions:
  grid: "A 2D numpy array of integer digits (colors)."
  input_grid: "The source grid provided in the task."
  output_grid: "The target grid observed in the task's example output."
  H_out: "Height of the output_grid (observed directly from the example)."
  W_out: "Width of the output_grid (observed directly from the example)."
  least_frequent_color (lfc): "The digit value appearing least frequently in the input_grid. Ties are broken by choosing the smallest digit value."
  min_row_least_frequent (r_min): "The smallest row index (0-based) in input_grid containing the lfc."
  W1: "Width of the right output block and its source block (B1). Calculated as W1 = H_out."
  W2: "Width of the left output block and its source block (B2). Calculated as W2 = W_out - W1."
  r_start: "Starting row index (0-based) for extracting B2. Calculated as r_start = r_min - 1."
  c_start: "Starting column index (0-based) for extracting B2. Observed as a fixed value of 1."
  B1: "The source block in input_grid for the right output block. Extracted from input_grid[0 : H_out, 0 : W1]."
  B2: "The source block in input_grid for the left output block. Extracted from input_grid[r_start : r_start + H_out, c_start : c_start + W2]."
  OutputRight: "The right part of the final output grid, shape H_out x W1. Generated by repeating the first row of B1."
  OutputLeft: "The left part of the final output grid, shape H_out x W2. Generated by applying Transformation T to B2."
  Transformation T: "A context-dependent operation applied to B2 to produce OutputLeft. The specific operation varies per task instance."

processing_steps:
  - step: observe_output_properties
    inputs: output_grid # Provided example output
    outputs: [H_out, W_out] # Determine dimensions by observation
  - step: calculate_block_widths
    inputs: H_out, W_out
    outputs: [W1, W2] # W1 = H_out, W2 = W_out - W1 (Ensure W2 >= 0)
  - step: identify_least_frequent_color_info
    inputs: input_grid
    process: "Find the lfc and its r_min."
    outputs: [lfc, r_min]
  - step: calculate_B2_start_indices
    inputs: r_min
    process: "Calculate r_start = r_min - 1. Set c_start = 1."
    outputs: [r_start, c_start]
  - step: extract_input_block_B1
    inputs: input_grid, H_out, W1
    process: "Extract subgrid B1 = input_grid[0 : H_out, 0 : W1]. Handle boundary conditions."
    outputs: B1
  - step: generate_output_right_block
    inputs: B1, H_out, W1
    process: "If B1 has rows, take its first row. Create OutputRight (H_out x W1) by repeating this row H_out times. Handle empty B1 (OutputRight is H_out x 0)."
    outputs: OutputRight
  - step: extract_input_block_B2
    inputs: input_grid, r_start, c_start, H_out, W2
    process: "Extract subgrid B2 = input_grid[r_start : r_start + H_out, c_start : c_start + W2]. Handle boundary conditions (negative r_start, indices out of range, W2 <= 0). If invalid, B2 is empty (H_out x 0)."
    outputs: B2
  - step: apply_transformation_T
    inputs: B2
    process: >
      Apply the instance-specific transformation T to B2 to produce OutputLeft (H_out x W2).
      - T for train_1 instance (T1): Apply a complex, specific transformation (details currently undefined).
      - T for train_2 instance (T2): If W2 >= 3, swap column 1 and column 2 of B2. Otherwise, leave B2 unchanged.
      If B2 is empty, OutputLeft is empty (H_out x 0).
    outputs: OutputLeft
  - step: concatenate_blocks
    inputs: [OutputLeft, OutputRight]
    process: "Horizontally concatenate OutputLeft and OutputRight. Handles cases where one or both blocks might be empty (zero width)."
    outputs: final_output_grid (shape H_out x W_out)
