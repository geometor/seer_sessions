{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransforms a 2D grid of integers based on connected components of non-7 values.\n\nThe transformation identifies connected components (4-directional adjacency) of identical \nnumbers (excluding 7). The transformation applied to each component depends on its \noriginal value, size (number of cells), and the count of its unique neighboring cells \n(adjacent cells not part of the component).\n\nRules:\n1. Cells with value 7 remain 7.\n2. Components of non-6 values:\n   - If size is 1, change value to 7.\n   - If size > 1, keep the original value.\n3. Components of value 6:\n   - Size 2: Change value to 3.\n   - Size 4 & Neighbor Count 5: Keep value 6.\n   - Size 4 & Neighbor Count 6: Change value to 1.\n   - Size 5: Change value to 4.\n   - All other sizes (1, 3) or other Size 4 neighbor counts: Keep value 6.\n\"\"\"\n\ndef _find_component_and_neighbors(start_r: int, start_c: int, grid: list[list[int]], visited: list[list[bool]]) -> tuple[list[tuple[int, int]], int, set[tuple[int, int]]]:\n    \"\"\"\n    Finds a connected component and its unique neighbors using BFS.\n\n    Args:\n        start_r: Starting row index.\n        start_c: Starting column index.\n        grid: The input grid.\n        visited: A grid tracking visited cells.\n\n    Returns:\n        A tuple containing:\n        - list[(int, int)]: Coordinates of cells in the component.\n        - int: The common value of the component's cells.\n        - set[(int, int)]: Coordinates of unique neighbor cells.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    component_value = grid[start_r][start_c]\n    component_cells = []\n    neighbor_cells = set()\n    q = deque([(start_r, start_c)])\n    visited[start_r][start_c] = True\n\n    while q:\n        r, c = q.popleft()\n        component_cells.append((r, c))\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check if neighbor is within bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If neighbor is part of the component and not visited\n                if not visited[nr][nc] and grid[nr][nc] == component_value:\n                    visited[nr][nc] = True\n                    q.append((nr, nc))\n                # If neighbor has a different value, it's a neighbor cell\n                elif grid[nr][nc] != component_value:\n                    neighbor_cells.add((nr, nc))\n            # Neighbors outside bounds are not counted\n\n    return component_cells, component_value, neighbor_cells\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    # Handle empty grid case\n    if not input_grid or not input_grid[0]:\n        return []\n\n    rows = len(input_grid)\n    cols = len(input_grid[0])\n\n    # Initialize output_grid as a deep copy of the input\n    output_grid = copy.deepcopy(input_grid)\n    # Initialize visited grid to keep track of processed cells\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n\n    # Iterate through each cell of the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Skip if cell is background (7) or already part of a processed component\n            if input_grid[r][c] == 7 or visited[r][c]:\n                continue\n\n            # Found an unvisited, non-7 cell: find its component and neighbors\n            component_cells, component_value, neighbor_cells = _find_component_and_neighbors(r, c, input_grid, visited)\n            \n            # Calculate component size and neighbor count\n            component_size = len(component_cells)\n            neighbor_count = len(neighbor_cells)\n\n            # Determine the new value based on component properties\n            new_value = component_value # Default to original value\n\n            if component_value != 6:\n                if component_size == 1:\n                    new_value = 7 # Isolated non-6 becomes 7\n                # else: keep original value (implicit default for size > 1)\n            elif component_value == 6:\n                # Apply size/neighbor-based rules for value 6\n                if component_size == 2:\n                    new_value = 3\n                elif component_size == 4:\n                    if neighbor_count == 5:\n                        new_value = 6 # Size 4, 5 neighbors -> 6\n                    elif neighbor_count == 6:\n                        new_value = 1 # Size 4, 6 neighbors -> 1\n                    else: # Other neighbor counts for size 4\n                        new_value = 6 # Default for size 4\n                elif component_size == 5:\n                    new_value = 4\n                else: # Covers sizes 1, 3, and > 5 for value 6\n                    new_value = 6 # Default to 6 for other sizes\n\n            # Update the output grid for all cells in the current component\n            for cell_r, cell_c in component_cells:\n                output_grid[cell_r][cell_c] = new_value\n\n    # Return the fully transformed grid\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8838,
    "candidates_token_count": 1893,
    "total_token_count": 10731,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 17.190349,
  "retries": 1
}