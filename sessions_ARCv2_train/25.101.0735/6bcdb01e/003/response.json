{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport copy\nfrom collections import deque\n\n\"\"\"\nTransformation Rule Natural Language Description:\n\n1.  **Identify Boundaries and Sources:** Locate all cells with value '8' (boundaries) and value '3' (sources) in the input grid.\n2.  **Determine Reachable Region (R):** Find the set `R` containing all grid cells `(r, c)` that satisfy:\n    *   The input value `input_grid[r][c]` is not '8'.\n    *   There exists a path from at least one source '3' cell to `(r, c)` consisting only of adjacent cells (up, down, left, right) whose input values are not '8'.\n3.  **Initialize Output Grid:** Create an output grid, initially identical to the input grid.\n4.  **Apply Transformation:** Iterate through each cell `(r, c)` in the grid.\n    a.  If the cell `(r, c)` is *not* part of the reachable region `R`, its value in the output grid remains the same as its input value.\n    b.  If the cell `(r, c)` *is* part of the reachable region `R`:\n        i.  If the input value `input_grid[r][c]` is '3', the output value `output_grid[r][c]` remains '3'.\n        ii. If the input value `input_grid[r][c]` is '7', determine the output value based on adjacent cells:\n            - Check all 4 adjacent neighbors `(nr, nc)` of `(r, c)`.\n            - If *at least one* neighbor `(nr, nc)` exists such that:\n                1) It is within the grid boundaries.\n                2) Its input value `input_grid[nr][nc]` is '7'.\n                3) It is also part of the reachable region `R`.\n            - Then, the cell `(r, c)` retains its value '7' in the output grid (it forms part of a \"hole\" or preserved '7' cluster).\n            - Otherwise (if no such adjacent neighbor exists), the cell's value is changed to '3' in the output grid.\n5.  **Finalize Output:** The resulting grid after applying these rules is the final output.\n\"\"\"\n\ndef find_connected_region(grid: list[list[int]], sources: list[tuple[int, int]]) -> set[tuple[int, int]]:\n    \"\"\"\n    Finds the connected region of non-8 cells reachable from source cells using BFS.\n\n    Args:\n        grid: The input grid.\n        sources: A list of (row, col) tuples representing the starting '3' cells.\n\n    Returns:\n        A set of (row, col) tuples representing the connected region R.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    region_r = set()\n    queue = deque()\n    visited = set()\n\n    # Initialize queue and visited set with sources that are not '8'\n    for r, c in sources:\n        if 0 <= r < rows and 0 <= c < cols and grid[r][c] != 8:\n            if (r, c) not in visited:\n                visited.add((r, c))\n                queue.append((r, c))\n                region_r.add((r, c)) # Add initial sources to region R\n\n    # BFS to find all reachable non-8 cells\n    while queue:\n        r, c = queue.popleft()\n        region_r.add((r, c)) # Add the current cell to region R\n\n        # Explore neighbors (up, down, left, right)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Check if neighbor is not visited and not an '8' wall\n                if (nr, nc) not in visited and grid[nr][nc] != 8:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n                    # Note: We add neighbors to region_r when they are popped from queue\n                    # This ensures initial sources are correctly included if they are isolated non-8s\n\n    return region_r\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid based on reachability\n    from '3' cells and local neighborhood patterns for '7' cells within the\n    reachable region.\n    \"\"\"\n    rows = len(input_grid)\n    if rows == 0:\n        return []\n    cols = len(input_grid[0])\n    if cols == 0:\n        return [[] for _ in range(rows)]\n\n    # initialize output_grid as a deep copy\n    output_grid = copy.deepcopy(input_grid)\n\n    # Find initial '3' source cells\n    sources = []\n    for r in range(rows):\n        for c in range(cols):\n            if input_grid[r][c] == 3:\n                sources.append((r, c))\n\n    # Determine the connected region R reachable from sources, avoiding '8's\n    region_r = find_connected_region(input_grid, sources)\n\n    # perform transformations based on region R and neighbor rules\n    for r in range(rows):\n        for c in range(cols):\n            # Only consider cells within the reachable region R\n            if (r, c) in region_r:\n                # If the cell is originally '7' in the input grid\n                if input_grid[r][c] == 7:\n                    # Check neighbors to see if this '7' should be preserved\n                    preserve_as_7 = False\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nr, nc = r + dr, c + dc\n                        # Check neighbor bounds\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            # Check if neighbor is also '7' in input and in region R\n                            if input_grid[nr][nc] == 7 and (nr, nc) in region_r:\n                                preserve_as_7 = True\n                                break # Found one such neighbor, no need to check further\n\n                    # If no suitable neighbor found, change to '3'\n                    if not preserve_as_7:\n                        output_grid[r][c] = 3\n                    # Else: it remains '7' (already set during deepcopy)\n\n            # Cells outside region R retain their original input values (already handled by deepcopy)\n            # Cells inside region R that were originally '3' or '8' also retain original values\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 8949,
    "candidates_token_count": 2656,
    "total_token_count": 11605,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-preview-03-25",
  "response_time": 21.444804,
  "retries": 1
}