import math
import copy

"""
Transforms an input list of integers by iteratively replacing zeros.

The transformation takes a single list of integers as input. 
It generates a sequence of lists (states) as output.
The first output state is identical to the input list.
Subsequent states are generated by modifying the previous state.
In each step, the next available '0' (starting from the index of the first '0' in the original input) 
is replaced by the value of the first element of the original input list.
The process continues until a number of states equal to the ceiling of (length of the input list / 2) 
has been generated.
"""

def _find_first_zero_index(data_list: list[int]) -> int:
    """Finds the index of the first zero in a list.

    Args:
        data_list: The list of integers to search within.

    Returns:
        The index of the first occurrence of 0, or the length of the list
        if 0 is not found.
    """
    try:
        return data_list.index(0)
    except ValueError:
        # If no zero is found, return the length (an index beyond the end)
        return len(data_list)

def transform(input_grid: list[list[int]]) -> list[list[int]]:
    """
    Generates a sequence of states by iteratively replacing zeros in the input list.

    Args:
        input_grid: A list containing a single list of integers. 
                      Example: [[8, 8, 8, 8, 0, 0]]

    Returns:
        A list of lists, where each inner list represents a state in the 
        transformation sequence.
        Example: [[8, 8, 8, 8, 0, 0], [8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 8]]
    """
    # Check if input is valid (should contain exactly one list)
    if not input_grid or len(input_grid) != 1:
        # Or raise an error, depending on expected behavior for invalid input
        return [] 
        
    # Extract the initial state list - make a copy to modify
    initial_state = input_grid[0]
    current_state = copy.deepcopy(initial_state) # Use deepcopy if inner elements could be mutable, copy is fine for ints

    # --- Get essential parameters ---
    # Length of the list
    list_length = len(initial_state)
    if list_length == 0:
        return [[]] # Handle empty input list

    # Replacement digit (first element of the initial list)
    replacement_digit = initial_state[0]

    # Find the index of the first zero in the *initial* state
    first_zero_index = _find_first_zero_index(initial_state)

    # Calculate the number of output lines/states
    num_output_lines = math.ceil(list_length / 2.0)

    # Initialize the output grid
    output_grid = []

    # --- Perform transformations iteratively ---
    for i in range(num_output_lines):
        # Add a copy of the current state to the output grid
        output_grid.append(copy.copy(current_state)) # Copy is sufficient here

        # Prepare the *next* state (if this isn't the last one)
        if i < num_output_lines - 1:
            # Calculate the index to modify in the current_state for the next iteration
            # The index to modify is relative to the start, incrementing from the first zero pos
            modify_index = first_zero_index + i

            # Check if the index to modify is within the bounds of the list
            if modify_index < list_length:
                 # Check if the element at modify_index is actually a zero 
                 # (although the logic implies it should be, this adds robustness)
                 # Note: The logic based on examples replaces the element at `first_zero_index + i`
                 # regardless of its current value in `current_state`. Let's stick to that.
                 current_state[modify_index] = replacement_digit
            # If modify_index is out of bounds, no more changes are possible/needed for subsequent steps

    return output_grid