{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n\"\"\"\nTransforms an input grid based on analysis of its 2x2 subgrids (patterns).\n\nThe process involves:\n1.  Identify all unique 2x2 patterns, their frequencies, and the sum of their elements.\n2.  Find the maximum sum (MaxS) among all patterns.\n3.  Filter to keep only patterns with sum = MaxS.\n4.  Among these, find the maximum frequency (MaxF).\n5.  Filter again to keep only patterns with sum = MaxS and frequency = MaxF.\n6.  If exactly one pattern remains, output a 1x1 grid containing its top-left element.\n7.  If multiple patterns remain (a tie), select one using a tie-breaking rule:\n    Maximize the bottom-left element, then the top-right, then the top-left.\n    Output the selected 2x2 pattern.\n\"\"\"\n\ndef find_patterns(grid: np.ndarray) -> dict:\n    \"\"\"\n    Finds all unique 2x2 patterns, their frequencies, and sums.\n\n    Args:\n        grid: A NumPy array representing the input grid.\n\n    Returns:\n        A dictionary where keys are unique 2x2 patterns (as tuples of tuples)\n        and values are dictionaries {'freq': frequency, 'sum': sum_of_elements}.\n    \"\"\"\n    patterns_data = defaultdict(lambda: {'freq': 0, 'sum': 0})\n    rows, cols = grid.shape\n    if rows < 2 or cols < 2:\n        return {} # Cannot form 2x2 patterns\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            # Extract 2x2 subgrid\n            pattern_arr = grid[r:r+2, c:c+2]\n            # Convert to tuple of tuples for hashability\n            pattern_tuple = tuple(map(tuple, pattern_arr)) # ((a, b), (c, d))\n\n            # Calculate sum if this is the first time seeing the pattern\n            if patterns_data[pattern_tuple]['freq'] == 0:\n                 patterns_data[pattern_tuple]['sum'] = np.sum(pattern_arr)\n\n            # Increment frequency\n            patterns_data[pattern_tuple]['freq'] += 1\n\n    return dict(patterns_data)\n\ndef tie_break(tied_patterns: list[tuple[tuple[int]]]) -> tuple[tuple[int]]:\n    \"\"\"\n    Selects a single pattern from a list of tied patterns based on element priority.\n\n    Priority: Bottom-Left (max) -> Top-Right (max) -> Top-Left (max).\n\n    Args:\n        tied_patterns: A list of 2x2 patterns (tuples of tuples) that are tied.\n\n    Returns:\n        The single winning pattern (tuple of tuples).\n    \"\"\"\n    # Define a key function for sorting/max based on the priority:\n    # Pattern is ((a, b), (c, d)). Priority is c, then b, then a.\n    # We want to maximize these values.\n    def sort_key(pattern):\n        top_left = pattern[0][0]\n        top_right = pattern[0][1]\n        bottom_left = pattern[1][0]\n        # bottom_right = pattern[1][1] # Not needed for tie-breaking\n        return (bottom_left, top_right, top_left)\n\n    # Find the pattern that has the maximum key value\n    winner = max(tied_patterns, key=sort_key)\n    return winner\n\n\ndef transform(input_grid: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Applies the transformation rule to the input grid.\n\n    Args:\n        input_grid: A list of lists representing the input integer grid.\n\n    Returns:\n        A list of lists representing the output grid (either 1x1 or 2x2).\n    \"\"\"\n    # Convert input to numpy array for easier slicing\n    grid = np.array(input_grid, dtype=int) # Specify dtype for clarity\n    rows, cols = grid.shape\n\n    # Handle grids too small for 2x2 patterns\n    if rows < 2 or cols < 2:\n        # Behavior undefined by examples, returning empty based on problem constraints\n        return []\n\n    # 1. Identify all unique 2x2 patterns, their frequencies, and sums.\n    patterns_info = find_patterns(grid)\n\n    if not patterns_info:\n         # No patterns found (e.g., 1xN or Nx1 grid)\n         return []\n\n    # 3. Find the maximum sum (MaxS).\n    # Using max() with a generator expression is efficient\n    max_sum = max(data['sum'] for data in patterns_info.values())\n\n    # 4. Filter patterns to keep only those with sum == MaxS.\n    sum_candidates = {p: d for p, d in patterns_info.items() if d['sum'] == max_sum}\n\n    # 5. Find the maximum frequency (MaxF) among the filtered patterns.\n    if not sum_candidates: # Should not happen if patterns_info was not empty\n        return []\n    max_freq = max(data['freq'] for data in sum_candidates.values())\n\n    # 6. Filter again to keep patterns with sum == MaxS AND frequency == MaxF.\n    final_candidates = [p for p, d in sum_candidates.items() if d['freq'] == max_freq]\n\n    # 7. Check the size of the final candidate set.\n    if len(final_candidates) == 1:\n        # a. Unique pattern: Output is the top-left element.\n        unique_pattern = final_candidates[0]\n        top_left_element = unique_pattern[0][0]\n        output_grid = [[top_left_element]]\n    elif len(final_candidates) > 1:\n        # b. Multiple patterns (tie): Apply tie-breaking rule.\n        chosen_pattern = tie_break(final_candidates)\n        # Convert the chosen tuple of tuples back to list of lists\n        output_grid = [list(row) for row in chosen_pattern]\n    else:\n         # Should not happen if patterns_info was not empty and MaxS/MaxF were found\n         output_grid = []\n\n    return output_grid\n```"
          }
        ],
        "role": "model"
      },
      "finish_reason": 1,
      "index": 0,
      "safety_ratings": [],
      "token_count": 0,
      "grounding_attributions": [],
      "avg_logprobs": 0.0
    }
  ],
  "usage_metadata": {
    "prompt_token_count": 16619,
    "candidates_token_count": 1997,
    "total_token_count": 18616,
    "cached_content_token_count": 0
  },
  "model_version": "gemini-2.5-pro-exp-03-25",
  "response_time": 14.022933,
  "retries": 1
}